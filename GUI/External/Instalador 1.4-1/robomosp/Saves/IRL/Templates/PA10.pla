% El Lenguaje destino es C++

% Bloque de Preprocesamiento
% En este bloque se ubican las instrucciones necesarias en el lenguaje destino para la ejecución del
% programa objeto.

@{
    #include <pa.h>
    #include <paerr.h>
    #include "listas.h"
    #include "trigo.h"
    #include "soporte.h"
    #include <iostream.h>
    #include <fstream.h>

    char * pointer1, * pointer2;
    char nombre [256];
    fstream filedatalist;
    int i,j;
    int arm = 0;
    char cadena [1024];

    #define cTARGET 0
    #define cJOINT 1
    typedef struct
    {
        int tipo;
        ANGLE angulo;
        MATRIX matriz;
    }punto;

    punto * p;
    List <punto *> puntos;

@}


% Para realizar el archivo de configuración del postprocesador del compilador se debe colocar en el lado
% izquierdo, la regla a traducir, escrita en código intermedio (código de tres direcciones), y en el
% derecho la traducción equivalente de la instrucción en el lenguaje destino.

% La instrucción IFGREATER en código intermedio, representa una comparación "mayor que" entre el primer
% y segundo operador, si el resultado es verdadero, el flujo control se desvía a la instrucción asociada
% a la etiqueta del tercer operador.

% En C++ la instrucción "if" acompañada de la instrucción "goto" representan el flujo de la instrucción
% que se requiere.

% En código C++ el equivalente es:  " if ( <expresion1> > <expresion2> ) goto <etiqueta> ; "
% Esto es representado por la siguiente linea.

%
% Delacraciones . 
% Las declaraciones para PA-10 son diferentes a pesar de que su lenguaje de programacion es 
% c++
%
CHAR $ $ <nombrevariable> = "CHAR <nombrevariable>;"
;
INT $ $ <nombrevariable> = "INT32 <nombrevariable>;"
;
REAL $ $ <nombrevariable> = "REAL64 <nombrevariable>;"
;
BOOL $ $ <nombrevariable> = "bool <nombrevariable> ;"
;
STRING $ $ <nombrevariable> = "CHAR <nombrevariable> [256];"
;
TEXT $ $ <nombrevariable> = "CHAR * <nombrevariable> ;"
;
USER $ <tipo> <objeto> = "<tipo> <objeto>;"
;
ROBOT $ $ <objeto> = "R_SPEC_TYPE * <objeto>;"
;
LIST $ $ $ = " List <"
;
ENDLIST $ $ <variable> = " > <variable>;"
;
RECORD $ $ <nombre_variable> = "struct {"
;
ENDRECORD $ $ <nombrevariable> = "} <nombrevariable> ;"
;
FILE $ $ <nombrevariable> = "fstream <nombrevariable>;"
;
PARININT $ $ <nombrevariable> = "INT32 <nombrevariable>"
;
PARINCHAR $ $ <nombrevariable> = "CHAR <nombrevariable>"
;
PARINREAL $ $ <nombrevariable> = "REAL64 <nombrevariable>"
;
PARINSTRING $ $ <nombrevariable> = "CHAR <nombrevariable> [256]"
;
PARINBOOL $ $ <nombrevariable> = "bool <nombrevariable>"
;
PARINENDRECORD $ $ <nombrevariable> = "} & <nombrevariable>"
;
PARINENDLIST $ $ <variable> = "> & <variable> "
;
PARINFILE $ $ <nombrevariable> = "fstream <nombrevariable>"
;
PARINUSER $ <tipo> <objeto> = "<tipo> <objeto>"
;
PARINARRAYUSER <tamano> <tipo> <variable> = "<tipo> <variable> [ <tamano> ]"
;
PARINARRAYINT <tamano> $ <variable> = "INT32 <variable> [ <tamano> ]"
;
PARINARRAYREAL <tamano> $ <variable> = "REAL64 <variable> [ <tamano> ]"
;
PARINARRAYSTRING <tamano> $ <variable> = "char <variable> [ <tamano> ] [ 256 ]"
;
PARINARRAYCHAR <tamano> $ <variable> = "char <variable> [ <tamano> ]"
;
PARINARRAYBOOL <tamano> $ <variable> = "bool <variable> [ <tamano> ]"
;
PAROUTARRAYUSER <tamano> <tipo> <variable> = "<tipo> <variable> [ <tamano> ]"
;
PAROUTARRAYINT <tamano> $ <variable> = "INT32 <variable> [ <tamano> ]"
;
PAROUTARRAYREAL <tamano> $ <variable> = "REAL64 <variable> [ <tamano> ]"
;
PAROUTARRAYSTRING <tamano> $ <variable> = "char <variable> [ <tamano> ] [ 256 ]"
;
PAROUTARRAYCHAR <tamano> $ <variable> = "char <variable> [ <tamano> ]"
;
PAROUTARRAYBOOL <tamano> $ <variable> = "bool <variable> [ <tamano> ]"
;
PAROUTINT $ $ <nombrevariable> = "INT32 & <nombrevariable>"
;
PAROUTCHAR $ $ <nombrevariable> = "CHAR & <nombrevariable>"
;
PAROUTREAL $ $ <nombrevariable> = "REAL64 & <nombrevariable>"
;
PAROUTSTRING $ $ <nombrevariable> = "CHAR & <nombrevariable> [256]"
;
PAROUTBOOL $ $ <nombrevariable> = "bool & <nombrevariable>"
;
PAROUTENDLIST $ $ <variable> = "> & <variable> "
;
PAROUTENDRECORD $ $ <nombrevariable> = "} & <nombrevariable>"
;
PAROUTFILE $ $ <nombrevariable> = "fstream & <nombrevariable>"
;
PAROUTUSER $ <tipo> <objeto> = "<tipo> & <objeto>"
;
TYPE $ $ $ = "typedef "
;
ENDTYPE $ $ $ = " "
;

%
% Programa
%

BEGINBLOCK $ $ $ = "{"
;
ENDBLOCK $ $ $ = "}"
;
LABEL <etiqueta> $ $ = "<etiqueta> : ;"
;
BEGINMAINBLOCK $ $ $ = "
    #ifndef DATALIST
    char datalist [250] = \"datalist.dls\";
    #define DATALIST
    #endif
    int main ( )
    { 
        filedatalist.open ( datalist, ios::in | ios::binary);
        for (robot =0; robot< 16; robot ++)
        {
            robots[robot] = NULL; 
        }
        robot = 0;
        pa_ini_sys();
        pa_opn_arm(arm);
        pa_sta_arm(arm);
"
;
ENDMAINBLOCK $ $ $ = "
    pa_ext_arm(arm);
    pa_cls_arm(arm);
    pa_ter_sys();
    filedatalist.close ();
    return 1; 
}
"
;

BEGINPROGRAM $ $ $ ="
    void getMat(POSE p, MATRIX m);
    ANGLE angulo;
    R_SPEC_TYPE * robots[16];
    int robot;
"
;
%
% Arreglos
%

ARRAYASSIGNMENT <expresion> <indice> <objetoarreglo> = "<objetoarreglo> [ <indice> ] = <expresion> ;"
;
ARRAYASSIGNMENTCOPY <expresion> <indice> <objetoarreglo> = "
    pointer1 = (char *)&<expresion>;
    pointer2 = (char *)&(<objetoarreglo>[ <indice> ]);
    for ( i = 0; i < sizeof ( <expresion> ) ; i ++ )
        pointer2[i] = pointer1[i];
"
;
ARRAYUSER <tamano> <tipo> <variable> = "<tipo> <variable> [ <tamano> ];"
;
ARRAYINT <tamano> $ <variable> = "INT32 <variable> [ <tamano> ];"
;
ARRAYREAL <tamano> $ <variable> = "REAL64 <variable> [ <tamano> ];"
;
ARRAYSTRING <tamano> $ <variable> = "char <variable> [ <tamano> ] [ 256 ];"
;
ARRAYCHAR <tamano> $ <variable> = "char <variable> [ <tamano> ];"
;
ARRAYBOOL <tamano> $ <variable> = "bool <variable> [ <tamano> ];"
;
ARRAYENDRECORD <tamano> $ <nombrevariable> = "} <nombrevariable> [ <tamano> ];"
;
COPYARRAY <origen> <indice> <destino> = "<destino> [ <indice> ] = <origen> [ <indice> ];"
;
COPYARRAYHARD <origen> <indice> <destino> = "
    pointer1 = (char *)&(<destino> [ <indice> ]);
    pointer2 = (char *)&(<origen> [ <indice> ]);
    for ( i = 0; i < sizeof ( <origen> [ <indice> ] ) ; i ++ )
        pointer2[i] = pointer1[i];
"
;
ARRAYINDEX <indice> <objetoarreglo> <respuesta> = "<respuesta> = <objetoarreglo> [<indice>] ;"
;
ARRAYINDEXCOPY <indice> <objetoarreglo> <respuesta> = "
    pointer1 = (char *)&(<objetoarreglo> [<indice>]);
    pointer2 = (char *)&<respuesta>;
    for ( i = 0; i < sizeof ( <respuesta> ) ; i ++ )
        pointer2[i] = pointer1[i];
"
;

%
% Registros
% Copia el valor de <expresion> en el componente <componente> del registro <registro>, el
% tipo de dato del componente es simple
%
COMPONENTASSIGNMENT <expresion> <componente> <registro> = "<registro>.<componente> = <expresion>;"
;

% Copia el valor del registro2 en el componente <componente> del registro <record1>
%<registro>.<componente> = <expresion>
COMPONENTASSIGNMENTHARD <expresion> <componente> <registro> = "    
    pointer1 = (char *)&<expresion>;
    pointer2 = (char *)&(<registro>.<componente>);
    for ( i = 0; i < sizeof ( <expresion> ) ; i ++ )
        pointer2[i] = pointer1[i];
"
;
RECORDASSIGNMENT <record2> $ <record1> = "
    pointer1 = (char *)&<record2>;
    pointer2 = (char *)&<record1>;
    for ( i = 0; i < sizeof ( <record1> ) ; i ++ )
        pointer2[i] = pointer1[i];
"
;
RECORDCOMPONENT <componente> <objetoregistro> <respuesta> = "<respuesta> = <objetoregistro>.<componente>;"
;
RECORDCOMPONENTCOPY <componente> <objetoregistro> <respuesta> = "
    pointer1 = (char *)&(<objetoregistro>.<componente>);
    pointer2 = (char *)&<respuesta>;
    for ( i = 0; i < sizeof ( <respuesta> ) ; i ++ )
        pointer2[i] = pointer1[i];
"
;
ROBOTCOMPONENT <componente> <objetoregistro> <respuesta> = "<respuesta> = <objetoregistro>-><componente>;"
;
ROBOTCOMPONENTCOPY <componente> <objetoregistro> <respuesta> = "
    pointer1 = (char *)&(<objetoregistro>-><componente>);
    pointer2 = (char *)&<respuesta>;
    for ( i = 0; i < sizeof ( <respuesta> ) ; i ++ )
        pointer2[i] = pointer1[i];
"
;
ROBOTCOMPONENTASSIGNMENT <expresion> <componente> <registro> = "<registro>.<componente> = <expresion>;"
;

% Copia el valor del registro2 en el componente <componente> del registro <record1>
%<registro>.<componente> = <expresion>
ROBOTCOMPONENTASSIGNMENTHARD <expresion> <componente> <registro> = "    
    pointer1 = (char *)&<expresion>;
    pointer2 = (char *)&(<registro>.<componente>);
    for ( i = 0; i < sizeof ( <expresion> ) ; i ++ )
        pointer2[i] = pointer1[i];
"
;

%
% Comparaciones
%
IFGREATER <expresion1> <expresion2> <etiqueta> = "if( <expresion1> > <expresion2> ) goto <etiqueta>;"
;
IFSMALLER <expresion1> <expresion2> <etiqueta> = "if( <expresion1> < <expresion2> ) goto <etiqueta>;"
;
IFEQUAL <expresion1> <expresion2> <etiqueta> = "if( <expresion1> == <expresion2> ) goto <etiqueta>;"
;
IFDIFERENT <expresion1> <expresion2> <etiqueta> = "if( <expresion1> != <expresion2> ) goto <etiqueta>;"
;
IFGREATEREQUAL <expresion1> <expresion2> <etiqueta> = "if( <expresion1> >= <expresion2> ) goto <etiqueta>;"
;
IFSMALLEREQUAL <expresion1> <expresion2> <etiqueta> = "if( <expresion1> <= <expresion2> ) goto <etiqueta>;"
;
IFEQUALSTRING <cadena1> <cadena2> <etiqueta> = "if( strcmp ( <cadena1>, <cadena2> ) == 0 ) goto <etiqueta> ;"
;
IFTRUE <expresion> $ <etiqueta> = "if( <expresion> ) goto <etiqueta> ;"
;
IFFALSE <expresion> $ <etiqueta> = "if( !<expresion> ) goto <etiqueta> ;"
;
GOTO $ $ <etiqueta> = "goto <etiqueta> ;"
;


%
% Operaciones Matematicas
%
ASSIGNMENT <expresion> $ <objeto> = "<objeto>  = <expresion> ;"
;
ADDITION <expresion1> <expresion2> <respuesta> = "<respuesta> = <expresion1> + <expresion2> ;"
;
SUBSTRACTION <expresion1> <expresion2> <respuesta> = "<respuesta>  = <expresion1> - <expresion2> ;"
;
MULTIPLICATION <expresion1> <expresion2> <respuesta> = "<respuesta> = <expresion1> * <expresion2>;"
;
DIVISION <expresion1> <expresion2> <respuesta> = "<respuesta> = <expresion1> / <expresion2> ;"
;
ABS <expresion> $ <respuesta> = "<respuesta> = ABS ( <expresion> );"
;
SQRT <expresion> $ <respuesta> = "<respuesta> = sqrt ( <expresion> );"
;


%
% Operaciones a nivel de Bits
%
ORBIT <expresion1> <expresion2> <respuesta> = "<respuesta> = <expresion1> | <expresion2> ;"
;
ANDBIT <expresion1> <expresion2> <respuesta> = "<respuesta> = <expresion1> & <expresion2> ;"
;
XORBIT <expresion1> <expresion2> <respuesta> = "<respuesta> = <expresion1> ^ <expresion2> ;"
;
SIZEOF <objeto> $ <resp> = "<resp> = sizeof ( <objeto> );"
;

%
% Operaciones Trigonometricas
%

TAN <expresion> $ <respuesta> = "<respuesta> = TAN ( <expresion> ); "
;
SIN <expresion> $ <respuesta> = "<respuesta> = SIN ( <expresion> ); "
;
COS <expresion> $ <respuesta> = "<respuesta> = COS ( <expresion> ); "
;
ATAN2 <expresion1> <expresion2> <respuesta> = "<respuesta> = ATAN2 ( <expresion1>, <expresion2> );"
;
ATAN <expresion> $ <respuesta> = "<respuesta> = ATAN ( <expresion> );"
;
ASIN <expresion> $ <respuesta> = "<respuesta> = ASIN ( <expresion> );"
;
ACOS <expresion> $ <respuesta> = "<respuesta> = ACOS ( <expresion> );"
;


%
% Funciones, Procedimientos y Porcesos Paralelos
%
CALLFUNCTION <nombre> $ <respuesta> = "<respuesta> = <nombre> ( "
;
CALLPROCEDURE <nombre> $ $ = "<nombre> (  "
;
ENDCALL $ $ $ = " ) ; "
;
ENDPROCESS $ $ $ = " */ "
;
PARAMETER <objeto> $ $ = " <objeto> "
;
PARAMETERSEPARATOR $ $ $ = ","
;
PARAMETERBLOCK $ $ $ = "("
;
ENDPARAMETERBLOCK $ $ $ = ")"
;
START <proceso> $ $ = "/* Start */"
;
CANCEL <proceso> $ $ ="/* Cancel */"
;
STOP <proceso> $ $ ="/* Stop */"
;
CONTINUE <proceso> $ $ ="/* Continue */"
;
PROCESS <nombre> <prioridad> $ = "/* "
;
PROCEDURE <nombre> $ $ = "void <nombre> "
;
INTFUNCTION <nombre> $ $ = "INT32 <nombre> "
;
REALFUNCTION <nombre> $ $ = "REAL64 <nombre> "
;
BOOLFUNCTION <nombre> $ $ = "bool <nombre> "
;
CHARFUNCTION <nombre> $ $ = "CHAR <nombre> "
;
USERFUNCTION <nombre> $ <tipo> = "<tipo> & <nombre> "
;
RETURN <expresion> $ $ = "return <expresion>;"
;
EMPTYRETURN $ $ $ = "return;"
;

%
% Strings
%
STRINGASSIGNMENT <stringfuente> $ <stringdestino> = "strcpy (<stringdestino>, <stringfuente>); "
;
COMPARESTRING <cadena1> <cadena2> <respuesta> = "<respuesta> = strcmp ( <cadena1>, <cadena2> );"
;
CONCATSTRING <cadena1> <cadena2> <respuesta> = "
    strcpy ( <respuesta>, <cadena1> );
    strcat ( <respuesta>, <cadena2> );
"
;
GETCHARACTER <cadena> <indice> <respuesta> = "<respuesta> = <cadena> [ <indice> - 1 ];"
;
SETCHARACTER <cadena> <caracter> <indice> = "<cadena> [ <indice> - 1 ] = <caracter>;"
;
LENGTHSTRING <cadena> $ <respuesta> = "<respuesta> = strlen ( <cadena> );"
;
LOCATESTRING <cadena> <subcadena> <respuesta> = "<respuesta> = LocateString ( <cadena>, <subcadena> );"
;
DELETECHARACTERS <cadena> <inicio> <final> = "DeleteCharacteres ( <cadena>, <inicio>, <final> );"
;
EXTRACTSTRING <cadena> <inicio> <final> = "ExtractString ( <cadena>, <inicio>, <final> );"
;
APPENDCHAR <cadena> <caracter> <respuesta> = "
    strcpy ( <respuesta>, <cadena> );
    <respuesta> [ strlen ( <cadena> ) ] = <caracter> ;
    <respuesta> [ strlen ( <cadena> ) + 1 ] = 0 ;
"
;


%
% Puntos y Movimientos del Robot
%


ROBTARGETPATH <robtarget> $ $ = "
    p = new punto;
    p->tipo = cTARGET;
    getMat(<robtarget>.PSE,p->matriz);
    puntos.Listadd(p);
"
;
MAINJOINTPATH <joint> $ $ = "
    p = new punto;
    p->tipo = cJOINT;
    p->angulo.s1 = R(<joint>.A1);
    p->angulo.s2 = R(<joint>.A2);
    p->angulo.s3 = R(<joint>.A3);
    p->angulo.e1 = R(<joint>.A4);
    p->angulo.e2 = R(<joint>.A5);
    p->angulo.w1 = R(<joint>.A6);
    p->angulo.w2 = R(<joint>.A7);
    puntos.Listadd(p);
"
;
ROBOTDEF <nombre> <inicializacion> <variable> = "
    R_SPEC_TYPE * <variable>;
    <variable> = & <inicializacion>;
    robots[robot] = <variable>; 
    robot ++;
"
;

MOVELIN $ <parametros> $ = " 
    for(i = 0; i< puntos.Listlength(); i++)
    {
        p = puntos.Listdata(i);
        ANGLE an;
        if(p->tipo == cTARGET)
            pa_mov_mat(arm,MM_XYZNOA,p->matriz,&an,WM_WAIT);
        else
            pa_exe_axs(arm,S1|S2|S3|E1|E2|W1|W2,&p->angulo,WM_WAIT);
    }
    puntos.Listdestroy();
"
;    
MOVEPTP $ <parametros> $ = " 
    for(i = 0; i< puntos.Listlength(); i++)
    {
        p = puntos.Listdata(i);
        ANGLE an;
        if(p->tipo == cTARGET)
            pa_mov_mat(arm,MM_XYZNOA,p->matriz,&an,WM_WAIT);
        else
            pa_exe_axs(arm,S1|S2|S3|E1|E2|W1|W2,&p->angulo,WM_WAIT);
    }
    puntos.Listdestroy();
"
;    
BRAKE <modo> <robot> $ = " 
    arm = robotId(<robot>);
    if( <modo> )
        pa_stp_arm(arm, WM_NOWAIT);
    else
        pa_stp_arm(arm, WM_WAIT);
"
;
INITUNTIL $ $ $ ="/*"
;
ENDUNTIL $ $ $="*/"
;

%
% Operaciones de lista
%

LISTADD <expresion> $ <objetolista> = "<objetolista>.Listadd(<expresion>) ;"
;
LISTDEL <indice> $ <objetolista> = "<objetolista>.Listdel(<indice>) ;"
;
LISTINS <expresion> <indice> <objetolista> = "<objetolista>.Listins(<expresion>,<indice>) ;"
;
LISTLENGTH <objetolista> $ <objetorespuesta> = " <objetorespuesta> = <objetolista>.Listlength() ;"
;
LISTINDEX <objeto_lista> <expresion> <objeto_respuesta> = "<objeto_respuesta>  = <objeto_lista>.Listindex (<expresion>);"
;
LISTDESTROY <objeto_lista> $ $ = "<objeto_lista>.Listdestroy (  );"
;
LISTELEMENT <indice> <lista> <destino> = "<destino> = <lista>[<indice>];" 
;
LISTELEMENTCOPY <indice> <lista> <destino> = "
    pointer1 = (char *)&<lista>[<indice>];
    pointer2 = (char *)&<destino>;
    for(i = 0; i < sizeof(<lista>[<indice>]); i++)
        pointer2[i] = pointer1[i];
"
;


%
% Entrada y Salida (I/O)
%
OPENREAD <nombrearchivo> $ <objetoarchivo> = "<objetoarchivo>.open ( <nombrearchivo> , ios::in ); "
;
OPENNEW <nombrearchivo> $ <objetoarchivo> = "<objetoarchivo>.open ( <nombrearchivo>, ios::out ); "
;
OPENALEATORY <nombrearchivo> $ <objetoarchivo> = "<objetoarchivo>.open ( <nombrearchivo>, ios::in | ios::out | ios :: /*trunc*/ate | ios::binary );"
;
OPENEND <nombrearchivo> $ <objetoarchivo> = "<objetoarchivo>.open ( <nombrearchivo>, ios::in|ios::app ); "
;
FILEERROR <archivo> $ <variableerror> = "/*<variableerror> = errno;*/"
;
CLOSE <archivo> $ $ = "<archivo>.close ();"
;
FILEWRITE <dato> $ <file> = "<file> << <dato>;"
;
STDWRITE <dato> $ $ = "cout << <dato>;"
;
FILEWRITELN $ $ <file> = "<file> << endl;"
;
STDWRITELN $ $ $ = "cout << endl;"
;
FILESETPRECISION <file> $ <precision> = "<file>.precision( <precision> );"
;
FILESETWIDTH <file> $ <width> = "<file>.width ( <width> );"
;
FILESETRIGTH <file> $ $ = "//<file>.setf (ios::rigth);"
;
FILESETLEFT <file> $ $ = "//<file>.setf (ios::left);"
;
STDSETPRECISION $ $ <precision> = "cout.precision( <precision> );"
;
STDSETWIDTH $ $ <width> = "cout.width ( <width> );"
;
STDSETRIGTH $ $ $ = "//cout.setf (ios::rigth);"
;
STDSETLEFT $ $ $ = "//cout.setf (ios::left);"
;
ERROR $ $ $ = " /* ERROR */ "
;
FILESEEKW <file> <posicion> $ = "<file>.seekp ( <posicion>, ios::beg );"
;
FILESEEKR <file> <posicion> $ = "<file>.seekg ( <posicion>, ios::beg );"
;
FILEWRITERAC <file> <objeto> $ = "<file>.write((char *)&<objeto>, sizeof(<objeto>));"
;
FILEREADRAC <file> <objeto> $ = "<file>.read((char *)&<objeto>, sizeof(<objeto>));"
;
FILEREAD <file> $ <dato> = "<file> >> <dato>;"
;
STDREAD $ $ <dato> = "cin >> <dato>;"
;
FILEREADLN <file> $ $ = "<file>.get ( );"
;
STDREADLN $ $ $ = "cin.get();"
;
ENDOFFILE <archivo> $ <respuesta> = "<respuesta> = <archivo>.feof ( );"
;
TRUNC <expresion> $ <respuesta> = "<respuesta> = (int)trunc ( <expresion> );"
;
ROUND <expresion> $ <respuesta> = "<respuesta> = (int)round ( <expresion> );"
;
TEMPLATEINT $ $ $ = "INT32 "
;
TEMPLATECHAR $ $ $ = "CHAR "
;
TEMPLATEREAL $ $ $ = " REAL64 "
;
TEMPLATESTRING $ $ $ = "CHAR [256]"
;
TEMPLATEBOOL $ $ $ = "bool "
;
TEMPLATEENDLIST $ $ $ = "> ;"
;
TEMPLATEENDRECORD $ $ $ = "}"
;
TEMPLATEFILE $ $ $ = "fstream "
;
TEMPLATESEMABOOL $ $ $ = "static bool"
;
TEMPLATESEMAINT $ $ $ = "static int "
;
TEMPLATEORIENTATION $ $ $ = "ORIENTATION"
;
TEMPLATEUSER  $ <tipo> $ = " <tipo> "
;
PAUSE <mensaje> $ $ = "
    pa_sus_arm ( arm, WM_WAIT );
    cout << <mensaje> << endl;
    cout << \"Presione enter para continuar...\" << endl;
    cin.get ( );
    pa_rsm_arm ( arm, WM_WAIT);
"
;
HALT $ $ $ = "
    pa_stp_arm ( arm, WM_WAIT);
    pa_ext_arm(arm);
    pa_cls_arm(arm);
    pa_ter_sys();
"
;
DATALIST <archivo> $ $ = "char datalist [250] = <archivo>; 
                        #define DATALIST"
;

DECLINTERRUPT <numero> $ $ = "/*DECLINTERRUPT ( <numero> ) { "
;

ENDDECLINTERRUPT $ $ $ = "return; }*/"
;

INPUTINT <byte> <direccion> <nombrevariable> = "INT32 <nombrevariable>;"
;
INPUTREAL <byte> <direccion> <nombrevariable> = "REAL64 <nombrevariable>;"
;
INPUTBOOL <byte> <direccion> <nombrevariable> = "bool <nombrevariable> ;"
;

OUTPUTINT <byte> <direccion> <nombrevariable> = "INT32 <nombrevariable>;"
;
OUTPUTREAL <byte> <direccion> <nombrevariable> = "REAL64 <nombrevariable>;"
;
OUTPUTBOOL <byte> <direccion> <nombrevariable> = "bool <nombrevariable> ;"
;

TEACH $ $ <nombrevariable> = "
    filedatalist.read((char *)&<nombrevariable>, sizeof(<nombrevariable>));
"
;
@{

void getMat (POSE p, MATRIX m)
{
  POSITION o, a, n;
  a = VECTORA (p.ORI);
  o = VECTORO (p.ORI);
  n = VECTORN (p.ORI);

  m[0][0] = n.X;
  m[1][0] = n.Y;
  m[2][0] = n.Z;

  m[0][1] = o.X;
  m[1][1] = o.Y;
  m[2][1] = o.Z;

  m[0][2] = a.X;
  m[1][2] = a.Y;
  m[2][2] = a.Z;

  m[0][3] = p.POS.X;
  m[1][3] = p.POS.Y;
  m[2][3] = p.POS.Z;
}


@}



