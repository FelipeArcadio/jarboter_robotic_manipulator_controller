
controlador_Jarboter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00005990  00802200  00011420  000114d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00011420  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006a5  00807b90  00807b90  00016e64  2**0
                  ALLOC
  3 .eeprom       00000162  00810000  00810000  00016e64  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00015048  00000000  00000000  00016fc8  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000e376  00000000  00000000  0002c010  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 24 03 	jmp	0x648	; 0x648 <__ctors_end>
       4:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
       8:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
       c:	0c 94 4b 12 	jmp	0x2496	; 0x2496 <__vector_3>
      10:	0c 94 e4 11 	jmp	0x23c8	; 0x23c8 <__vector_4>
      14:	0c 94 b8 11 	jmp	0x2370	; 0x2370 <__vector_5>
      18:	0c 94 8c 11 	jmp	0x2318	; 0x2318 <__vector_6>
      1c:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      20:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      24:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      28:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      2c:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      30:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      34:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      38:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      3c:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      40:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      44:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      48:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      4c:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      50:	0c 94 4a 03 	jmp	0x694	; 0x694 <__vector_20>
      54:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      58:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      5c:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      60:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      64:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      68:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      6c:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      70:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      74:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      78:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      7c:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      80:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      84:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      88:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      8c:	0c 94 5b 03 	jmp	0x6b6	; 0x6b6 <__vector_35>
      90:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      94:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      98:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      9c:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      a0:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      a4:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      a8:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      ac:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      b0:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      b4:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      b8:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      bc:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      c0:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      c4:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      c8:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      cc:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      d0:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      d4:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      d8:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      dc:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      e0:	0c 94 48 03 	jmp	0x690	; 0x690 <__bad_interrupt>
      e4:	f4 20       	and	r15, r4
      e6:	f1 20       	and	r15, r1
      e8:	f7 20       	and	r15, r7
      ea:	fa 20       	and	r15, r10
      ec:	fd 20       	and	r15, r13
      ee:	00 21       	and	r16, r0
      f0:	03 21       	and	r16, r3
      f2:	06 21       	and	r16, r6
      f4:	09 21       	and	r16, r9
      f6:	0c 21       	and	r16, r12
      f8:	0f 21       	and	r16, r15
      fa:	12 21       	and	r17, r2
      fc:	15 21       	and	r17, r5
      fe:	18 21       	and	r17, r8
     100:	1b 21       	and	r17, r11
     102:	1e 21       	and	r17, r14
     104:	21 21       	and	r18, r1
     106:	24 21       	and	r18, r4
     108:	27 21       	and	r18, r7
     10a:	80 21       	and	r24, r0
     10c:	7d 21       	and	r23, r13
     10e:	83 21       	and	r24, r3
     110:	86 21       	and	r24, r6
     112:	89 21       	and	r24, r9
     114:	8c 21       	and	r24, r12
     116:	8f 21       	and	r24, r15
     118:	92 21       	and	r25, r2
     11a:	95 21       	and	r25, r5
     11c:	98 21       	and	r25, r8
     11e:	9b 21       	and	r25, r11
     120:	9e 21       	and	r25, r14
     122:	a1 21       	and	r26, r1
     124:	a4 21       	and	r26, r4
     126:	a7 21       	and	r26, r7
     128:	aa 21       	and	r26, r10
     12a:	b9 21       	and	r27, r9
     12c:	b9 21       	and	r27, r9
     12e:	b9 21       	and	r27, r9
     130:	ad 21       	and	r26, r13
     132:	b0 21       	and	r27, r0
     134:	b3 21       	and	r27, r3
     136:	b6 21       	and	r27, r6
     138:	d2 21       	and	r29, r2
     13a:	bb 23       	and	r27, r27
     13c:	bb 23       	and	r27, r27
     13e:	bb 23       	and	r27, r27
     140:	bb 23       	and	r27, r27
     142:	bb 23       	and	r27, r27
     144:	cf 21       	and	r28, r15
     146:	d5 21       	and	r29, r5
     148:	bb 23       	and	r27, r27
     14a:	bb 23       	and	r27, r27
     14c:	bb 23       	and	r27, r27
     14e:	bb 23       	and	r27, r27
     150:	bb 23       	and	r27, r27
     152:	bb 23       	and	r27, r27
     154:	bb 23       	and	r27, r27
     156:	d8 21       	and	r29, r8
     158:	db 21       	and	r29, r11
     15a:	de 21       	and	r29, r14
     15c:	bb 23       	and	r27, r27
     15e:	e1 21       	and	r30, r1
     160:	e4 21       	and	r30, r4
     162:	bb 23       	and	r27, r27
     164:	bb 23       	and	r27, r27
     166:	bb 23       	and	r27, r27
     168:	bb 23       	and	r27, r27
     16a:	bb 23       	and	r27, r27
     16c:	e7 21       	and	r30, r7
     16e:	bb 23       	and	r27, r27
     170:	bb 23       	and	r27, r27
     172:	ea 21       	and	r30, r10
     174:	ed 21       	and	r30, r13
     176:	bb 23       	and	r27, r27
     178:	bb 23       	and	r27, r27
     17a:	bb 23       	and	r27, r27
     17c:	bb 23       	and	r27, r27
     17e:	bb 23       	and	r27, r27
     180:	bb 23       	and	r27, r27
     182:	f0 21       	and	r31, r0
     184:	f3 21       	and	r31, r3
     186:	f6 21       	and	r31, r6
     188:	bb 23       	and	r27, r27
     18a:	bb 23       	and	r27, r27
     18c:	bb 23       	and	r27, r27
     18e:	f9 21       	and	r31, r9
     190:	fc 21       	and	r31, r12
     192:	ff 21       	and	r31, r15
     194:	bb 23       	and	r27, r27
     196:	02 22       	and	r0, r18
     198:	bb 23       	and	r27, r27
     19a:	05 22       	and	r0, r21
     19c:	bb 23       	and	r27, r27
     19e:	bb 23       	and	r27, r27
     1a0:	08 22       	and	r0, r24
     1a2:	bb 23       	and	r27, r27
     1a4:	0b 22       	and	r0, r27
     1a6:	0e 22       	and	r0, r30
     1a8:	11 22       	and	r1, r17
     1aa:	14 22       	and	r1, r20
     1ac:	17 22       	and	r1, r23
     1ae:	bb 23       	and	r27, r27
     1b0:	bb 23       	and	r27, r27
     1b2:	bb 23       	and	r27, r27
     1b4:	1a 22       	and	r1, r26
     1b6:	bb 23       	and	r27, r27
     1b8:	bb 23       	and	r27, r27
     1ba:	bb 23       	and	r27, r27
     1bc:	bb 23       	and	r27, r27
     1be:	bb 23       	and	r27, r27
     1c0:	bb 23       	and	r27, r27
     1c2:	bb 23       	and	r27, r27
     1c4:	bb 23       	and	r27, r27
     1c6:	1d 22       	and	r1, r29
     1c8:	bb 23       	and	r27, r27
     1ca:	bb 23       	and	r27, r27
     1cc:	20 22       	and	r2, r16
     1ce:	23 22       	and	r2, r19
     1d0:	26 22       	and	r2, r22
     1d2:	29 22       	and	r2, r25
     1d4:	bb 23       	and	r27, r27
     1d6:	bb 23       	and	r27, r27
     1d8:	2c 22       	and	r2, r28
     1da:	2f 22       	and	r2, r31
     1dc:	32 22       	and	r3, r18
     1de:	bb 23       	and	r27, r27
     1e0:	35 22       	and	r3, r21
     1e2:	bb 23       	and	r27, r27
     1e4:	38 22       	and	r3, r24
     1e6:	bb 23       	and	r27, r27
     1e8:	3b 22       	and	r3, r27
     1ea:	3e 22       	and	r3, r30
     1ec:	bb 23       	and	r27, r27
     1ee:	41 22       	and	r4, r17
     1f0:	bb 23       	and	r27, r27
     1f2:	bb 23       	and	r27, r27
     1f4:	bb 23       	and	r27, r27
     1f6:	bb 23       	and	r27, r27
     1f8:	bb 23       	and	r27, r27
     1fa:	44 22       	and	r4, r20
     1fc:	bb 23       	and	r27, r27
     1fe:	bb 23       	and	r27, r27
     200:	bb 23       	and	r27, r27
     202:	bb 23       	and	r27, r27
     204:	bb 23       	and	r27, r27
     206:	bb 23       	and	r27, r27
     208:	bb 23       	and	r27, r27
     20a:	47 22       	and	r4, r23
     20c:	4a 22       	and	r4, r26
     20e:	4d 22       	and	r4, r29
     210:	bb 23       	and	r27, r27
     212:	bb 23       	and	r27, r27
     214:	50 22       	and	r5, r16
     216:	bb 23       	and	r27, r27
     218:	bb 23       	and	r27, r27
     21a:	bb 23       	and	r27, r27
     21c:	53 22       	and	r5, r19
     21e:	bb 23       	and	r27, r27
     220:	bb 23       	and	r27, r27
     222:	56 22       	and	r5, r22
     224:	59 22       	and	r5, r25
     226:	5c 22       	and	r5, r28
     228:	bb 23       	and	r27, r27
     22a:	bb 23       	and	r27, r27
     22c:	5f 22       	and	r5, r31
     22e:	62 22       	and	r6, r18
     230:	65 22       	and	r6, r21
     232:	68 22       	and	r6, r24
     234:	bb 23       	and	r27, r27
     236:	bb 23       	and	r27, r27
     238:	6b 22       	and	r6, r27
     23a:	6e 22       	and	r6, r30
     23c:	71 22       	and	r7, r17
     23e:	74 22       	and	r7, r20
     240:	77 22       	and	r7, r23
     242:	7a 22       	and	r7, r26
     244:	7d 22       	and	r7, r29
     246:	80 22       	and	r8, r16
     248:	83 22       	and	r8, r19
     24a:	86 22       	and	r8, r22
     24c:	89 22       	and	r8, r25
     24e:	8c 22       	and	r8, r28
     250:	8f 22       	and	r8, r31
     252:	92 22       	and	r9, r18
     254:	95 22       	and	r9, r21
     256:	98 22       	and	r9, r24
     258:	9b 22       	and	r9, r27
     25a:	9e 22       	and	r9, r30
     25c:	a1 22       	and	r10, r17
     25e:	a4 22       	and	r10, r20
     260:	a7 22       	and	r10, r23
     262:	aa 22       	and	r10, r26
     264:	ad 22       	and	r10, r29
     266:	b0 22       	and	r11, r16
     268:	b3 22       	and	r11, r19
     26a:	b6 22       	and	r11, r22
     26c:	b9 22       	and	r11, r25
     26e:	bc 22       	and	r11, r28
     270:	bf 22       	and	r11, r31
     272:	c2 22       	and	r12, r18
     274:	c5 22       	and	r12, r21
     276:	c8 22       	and	r12, r24
     278:	cb 22       	and	r12, r27
     27a:	ce 22       	and	r12, r30
     27c:	d1 22       	and	r13, r17
     27e:	d4 22       	and	r13, r20
     280:	d7 22       	and	r13, r23
     282:	da 22       	and	r13, r26
     284:	dd 22       	and	r13, r29
     286:	e0 22       	and	r14, r16
     288:	e3 22       	and	r14, r19
     28a:	e6 22       	and	r14, r22
     28c:	e9 22       	and	r14, r25
     28e:	ec 22       	and	r14, r28
     290:	ef 22       	and	r14, r31
     292:	f2 22       	and	r15, r18
     294:	f5 22       	and	r15, r21
     296:	f8 22       	and	r15, r24
     298:	fb 22       	and	r15, r27
     29a:	fe 22       	and	r15, r30
     29c:	01 23       	and	r16, r17
     29e:	04 23       	and	r16, r20
     2a0:	07 23       	and	r16, r23
     2a2:	0a 23       	and	r16, r26
     2a4:	0d 23       	and	r16, r29
     2a6:	10 23       	and	r17, r16
     2a8:	13 23       	and	r17, r19
     2aa:	16 23       	and	r17, r22
     2ac:	19 23       	and	r17, r25
     2ae:	1c 23       	and	r17, r28
     2b0:	1f 23       	and	r17, r31
     2b2:	22 23       	and	r18, r18
     2b4:	25 23       	and	r18, r21
     2b6:	28 23       	and	r18, r24
     2b8:	2b 23       	and	r18, r27
     2ba:	2e 23       	and	r18, r30
     2bc:	31 23       	and	r19, r17
     2be:	34 23       	and	r19, r20
     2c0:	37 23       	and	r19, r23
     2c2:	3a 23       	and	r19, r26
     2c4:	3d 23       	and	r19, r29
     2c6:	40 23       	and	r20, r16
     2c8:	43 23       	and	r20, r19
     2ca:	46 23       	and	r20, r22
     2cc:	49 23       	and	r20, r25
     2ce:	4c 23       	and	r20, r28
     2d0:	bb 23       	and	r27, r27
     2d2:	bb 23       	and	r27, r27
     2d4:	4f 23       	and	r20, r31
     2d6:	52 23       	and	r21, r18
     2d8:	55 23       	and	r21, r21
     2da:	58 23       	and	r21, r24
     2dc:	5b 23       	and	r21, r27
     2de:	5e 23       	and	r21, r30
     2e0:	61 23       	and	r22, r17
     2e2:	64 23       	and	r22, r20
     2e4:	67 23       	and	r22, r23
     2e6:	6a 23       	and	r22, r26
     2e8:	6d 23       	and	r22, r29
     2ea:	70 23       	and	r23, r16
     2ec:	73 23       	and	r23, r19
     2ee:	76 23       	and	r23, r22
     2f0:	79 23       	and	r23, r25
     2f2:	7c 23       	and	r23, r28
     2f4:	7f 23       	and	r23, r31
     2f6:	82 23       	and	r24, r18
     2f8:	85 23       	and	r24, r21
     2fa:	88 23       	and	r24, r24
     2fc:	8b 23       	and	r24, r27
     2fe:	8e 23       	and	r24, r30
     300:	91 23       	and	r25, r17
     302:	94 23       	and	r25, r20
     304:	97 23       	and	r25, r23
     306:	9a 23       	and	r25, r26
     308:	9d 23       	and	r25, r29
     30a:	a0 23       	and	r26, r16
     30c:	a3 23       	and	r26, r19
     30e:	a6 23       	and	r26, r22
     310:	a9 23       	and	r26, r25
     312:	ac 23       	and	r26, r28
     314:	af 23       	and	r26, r31
     316:	b2 23       	and	r27, r18
     318:	bb 23       	and	r27, r27
     31a:	bb 23       	and	r27, r27
     31c:	bb 23       	and	r27, r27
     31e:	bb 23       	and	r27, r27
     320:	bb 23       	and	r27, r27
     322:	b5 23       	and	r27, r21
     324:	bb 23       	and	r27, r27
     326:	bb 23       	and	r27, r27
     328:	b8 23       	and	r27, r24

0000032a <__c.3655>:
     32a:	53 65 63 75 65 6e 63 69 61 20 64 65 20 48 4f 4d     Secuencia de HOM
     33a:	45 20 0a 00                                         E ..

0000033e <__c.3653>:
     33e:	41 70 61 67 75 65 20 65 6c 20 63 6f 6e 74 72 6f     Apague el contro
     34e:	6c 61 64 6f 72 20 0a 00                             lador ..

00000356 <__c.3651>:
     356:	56 65 72 69 66 69 63 61 6e 64 6f 20 43 6f 6e 65     Verificando Cone
     366:	78 69 6f 6e 65 73 20 64 65 20 43 61 62 6c 65 73     xiones de Cables
     376:	20 0a 00                                             ..

00000379 <__c.3649>:
     379:	41 70 61 67 75 65 20 65 6c 20 63 6f 6e 74 72 6f     Apague el contro
     389:	6c 61 64 6f 72 20 0a 00                             lador ..

00000391 <__c.3647>:
     391:	56 65 72 69 66 69 63 61 6e 64 6f 20 54 61 72 6a     Verificando Tarj
     3a1:	65 74 61 73 20 50 4d 44 73 20 0a 00                 etas PMDs ..

000003ad <__c.3593>:
     3ad:	42 6f 74 6f 6e 20 64 65 20 50 61 72 61 64 61 20     Boton de Parada 
     3bd:	64 65 20 45 6d 65 72 67 65 6e 63 69 61 20 41 63     de Emergencia Ac
     3cd:	74 69 76 6f 20 0a 00                                tivo ..

000003d4 <__c.3657>:
     3d4:	45 72 72 6f 72 20 65 6e 20 65 6c 20 43 6f 6e 74     Error en el Cont
     3e4:	72 6f 6c 61 64 6f 72 20 64 65 20 6d 6f 74 6f 72     rolador de motor
     3f4:	65 73 20 4e 6f 2e 20 32 20 0a 00                    es No. 2 ..

000003ff <__c.3655>:
     3ff:	45 72 72 6f 72 20 65 6e 20 43 6f 6e 74 72 6f 6c     Error en Control
     40f:	61 64 6f 72 20 32 20 0a 00                          ador 2 ..

00000418 <__c.3653>:
     418:	45 72 72 6f 72 20 65 6e 20 65 6c 20 43 6f 6e 74     Error en el Cont
     428:	72 6f 6c 61 64 6f 72 20 64 65 20 6d 6f 74 6f 72     rolador de motor
     438:	65 73 20 4e 6f 2e 20 31 20 0a 00                    es No. 1 ..

00000443 <__c.3651>:
     443:	45 72 72 6f 72 20 65 6e 20 43 6f 6e 74 72 6f 6c     Error en Control
     453:	61 64 6f 72 20 31 20 0a 00                          ador 1 ..

0000045c <__c.3412>:
     45c:	43 61 62 6c 65 20 23 32 20 64 65 20 73 65 6e 73     Cable #2 de sens
     46c:	6f 72 65 73 20 64 65 73 63 6f 6e 65 63 74 61 64     ores desconectad
     47c:	6f 20 0a 00                                         o ..

00000480 <__c.3410>:
     480:	43 61 62 6c 65 20 23 31 20 64 65 20 73 65 6e 73     Cable #1 de sens
     490:	6f 72 65 73 20 64 65 73 63 6f 6e 65 63 74 61 64     ores desconectad
     4a0:	6f 20 0a 00                                         o ..

000004a4 <__c.3408>:
     4a4:	42 6f 74 6f 6e 20 64 65 20 50 61 72 61 64 61 20     Boton de Parada 
     4b4:	64 65 20 45 6d 65 72 67 65 6e 63 69 61 20 41 63     de Emergencia Ac
     4c4:	74 69 76 6f 20 0a 00                                tivo ..

000004cb <__c.3317>:
     4cb:	45 72 72 6f 72 20 64 65 20 49 6e 73 74 72 75 63     Error de Instruc
     4db:	63 69 6f 6e 20 0a 00                                cion ..

000004e2 <__c.3257>:
     4e2:	20 45 72 72 6f 72 20 64 65 20 4d 6f 76 69 6d 69      Error de Movimi
     4f2:	65 6e 74 6f 20 0a 00                                ento ..

000004f9 <__c.1790>:
     4f9:	6e 61 6e 00                                         nan.

000004fd <__c.1788>:
     4fd:	69 6e 66 00                                         inf.

00000501 <__c.2085>:
     501:	63 64 69 6e 6f 70 73 75 78 58 5b 65 66 67 45 46     cdinopsuxX[efgEF
     511:	47 00                                               G.

00000513 <pstr_an>:
     513:	61 6e 00                                            an.

00000516 <pstr_nfinity>:
     516:	6e 66 69 6e 69 74 79 00                             nfinity.

0000051e <pwr_m10>:
     51e:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     52e:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

00000536 <pwr_p10>:
     536:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     546:	ca 1b 0e 5a ae c5 9d 74 00 40 7a 10 f3 5a 00 a0     ...Z...t.@z..Z..
     556:	72 4e 18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00     rN..........vH..
     566:	00 e4 0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05     ...T.....;......
     576:	00 00 80 96 98 00 00 00 40 42 0f 00 00 00 a0 86     ........@B......
     586:	01 00 00 00 10 27 00 00 00 00 e8 03 00 00 00 00     .....'..........
     596:	64 00 00 00 00 00 0a 00 00 00 00 00 01 00 00 00     d...............
     5a6:	00 00 2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59     ..,v...gO.#....Y
     5b6:	e1 b1 b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8     .......S.:.Q.v..
     5c6:	e6 c2 84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc     ...&....b.@|o...
     5d6:	9c 9f 40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93     ..@...o....Z*.\.
     5e6:	6b 6c f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6     kl.gm......G.. .
     5f6:	b5 00 d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e     .........5w.....
     606:	08 00 00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f     ... N......3333.
     616:	98 6e 12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf     .n...A..!..;.U..
     626:	fe e6 db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb     ......K8..|.....
     636:	e4 24 20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5     .$ 2.r^"....$...
     646:	3d 27                                               ='

00000648 <__ctors_end>:
     648:	11 24       	eor	r1, r1
     64a:	1f be       	out	0x3f, r1	; 63
     64c:	cf ef       	ldi	r28, 0xFF	; 255
     64e:	d1 e2       	ldi	r29, 0x21	; 33
     650:	de bf       	out	0x3e, r29	; 62
     652:	cd bf       	out	0x3d, r28	; 61

00000654 <Init_EXRAM>:

void Init_EXRAM (void) 
{ 


XMCRA		=	_BV(SRE) | _BV(SRW11) | _BV(SRW10);	
     654:	8c e8       	ldi	r24, 0x8C	; 140
     656:	80 93 74 00 	sts	0x0074, r24
XMCRB = 0x00; 
     65a:	10 92 75 00 	sts	0x0075, r1

0000065e <__do_copy_data>:
}
     65e:	1b e7       	ldi	r17, 0x7B	; 123
     660:	a0 e0       	ldi	r26, 0x00	; 0
     662:	b2 e2       	ldi	r27, 0x22	; 34
     664:	e0 e2       	ldi	r30, 0x20	; 32
     666:	f4 e1       	ldi	r31, 0x14	; 20
     668:	01 e0       	ldi	r16, 0x01	; 1
     66a:	0b bf       	out	0x3b, r16	; 59
     66c:	02 c0       	rjmp	.+4      	; 0x672 <__do_copy_data+0x14>
     66e:	07 90       	elpm	r0, Z+
     670:	0d 92       	st	X+, r0
     672:	a0 39       	cpi	r26, 0x90	; 144
     674:	b1 07       	cpc	r27, r17
     676:	d9 f7       	brne	.-10     	; 0x66e <__do_copy_data+0x10>

00000678 <__do_clear_bss>:
     678:	12 e8       	ldi	r17, 0x82	; 130
     67a:	a0 e9       	ldi	r26, 0x90	; 144
     67c:	bb e7       	ldi	r27, 0x7B	; 123
     67e:	01 c0       	rjmp	.+2      	; 0x682 <.do_clear_bss_start>

00000680 <.do_clear_bss_loop>:
     680:	1d 92       	st	X+, r1

00000682 <.do_clear_bss_start>:
     682:	a5 33       	cpi	r26, 0x35	; 53
     684:	b1 07       	cpc	r27, r17
     686:	e1 f7       	brne	.-8      	; 0x680 <.do_clear_bss_loop>
     688:	0e 94 0b 0f 	call	0x1e16	; 0x1e16 <main>
     68c:	0c 94 0e 8a 	jmp	0x1141c	; 0x1141c <_exit>

00000690 <__bad_interrupt>:
     690:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000694 <__vector_20>:
	InterruptHandling_chipset2(); 
}

//Interrupcion Causada por el Timer1
ISR(TIMER1_OVF_vect)
{
     694:	1f 92       	push	r1
     696:	0f 92       	push	r0
     698:	0f b6       	in	r0, 0x3f	; 63
     69a:	0f 92       	push	r0
     69c:	11 24       	eor	r1, r1
     69e:	8f 93       	push	r24
	
	intflags.Timer1_int=0;
     6a0:	80 91 cf 80 	lds	r24, 0x80CF
     6a4:	87 7f       	andi	r24, 0xF7	; 247
     6a6:	80 93 cf 80 	sts	0x80CF, r24
}
     6aa:	8f 91       	pop	r24
     6ac:	0f 90       	pop	r0
     6ae:	0f be       	out	0x3f, r0	; 63
     6b0:	0f 90       	pop	r0
     6b2:	1f 90       	pop	r1
     6b4:	18 95       	reti

000006b6 <__vector_35>:

//Interrupcion Causada por el Timer3
ISR(TIMER3_OVF_vect)
{
     6b6:	1f 92       	push	r1
     6b8:	0f 92       	push	r0
     6ba:	0f b6       	in	r0, 0x3f	; 63
     6bc:	0f 92       	push	r0
     6be:	11 24       	eor	r1, r1
     6c0:	8f 93       	push	r24
	intflags.Timer3_int=0;
     6c2:	80 91 cf 80 	lds	r24, 0x80CF
     6c6:	8f 7e       	andi	r24, 0xEF	; 239
     6c8:	80 93 cf 80 	sts	0x80CF, r24
}
     6cc:	8f 91       	pop	r24
     6ce:	0f 90       	pop	r0
     6d0:	0f be       	out	0x3f, r0	; 63
     6d2:	0f 90       	pop	r0
     6d4:	1f 90       	pop	r1
     6d6:	18 95       	reti

000006d8 <work_in>:

} // work


void work_in(void)
{
     6d8:	cf 93       	push	r28
     6da:	df 93       	push	r29
    extern 	tCommand        rxCommand;	
	
	

	
	if(ATENDER_INT_IN==1)
     6dc:	c0 91 52 2e 	lds	r28, 0x2E52
     6e0:	d0 91 53 2e 	lds	r29, 0x2E53
     6e4:	c1 30       	cpi	r28, 0x01	; 1
     6e6:	d1 05       	cpc	r29, r1
     6e8:	09 f0       	breq	.+2      	; 0x6ec <work_in+0x14>
     6ea:	e6 c0       	rjmp	.+460    	; 0x8b8 <work_in+0x1e0>
	{
	  
       if(rc != rcOK) 					//Existe algun error?
     6ec:	80 91 ae 7b 	lds	r24, 0x7BAE
     6f0:	90 91 af 7b 	lds	r25, 0x7BAF
     6f4:	89 2b       	or	r24, r25
     6f6:	69 f0       	breq	.+26     	; 0x712 <work_in+0x3a>
	    {   
		
		ATENDER_INT_IN=0;  //Para poder imprimier bien tengo que deshabilitar las interupciones por USB.
     6f8:	10 92 53 2e 	sts	0x2E53, r1
     6fc:	10 92 52 2e 	sts	0x2E52, r1
		printf("work_in=> ERROR\n");
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	92 e2       	ldi	r25, 0x22	; 34
     704:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		// Volver a atender la interupciones
		ATENDER_INT_IN=1;  
     708:	d0 93 53 2e 	sts	0x2E53, r29
     70c:	c0 93 52 2e 	sts	0x2E52, r28
     710:	d3 c0       	rjmp	.+422    	; 0x8b8 <work_in+0x1e0>
	    }
	    else
	    {	
			if(rxCommand.CommandOP==CommandGetPosesID)
     712:	80 91 ee 81 	lds	r24, 0x81EE
     716:	90 91 ef 81 	lds	r25, 0x81EF
     71a:	0a 97       	sbiw	r24, 0x0a	; 10
     71c:	19 f5       	brne	.+70     	; 0x764 <work_in+0x8c>
			{
				ATENDER_INT_IN=0;
     71e:	10 92 53 2e 	sts	0x2E53, r1
     722:	10 92 52 2e 	sts	0x2E52, r1
				printf("work_in=> Estoy mandando el vector de IDs\n");	
     726:	80 e1       	ldi	r24, 0x10	; 16
     728:	92 e2       	ldi	r25, 0x22	; 34
     72a:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				rc=dispatchPacket(PacketPosesvector,(uint8*)id_vector);  
     72e:	60 91 23 82 	lds	r22, 0x8223
     732:	70 91 24 82 	lds	r23, 0x8224
     736:	89 e0       	ldi	r24, 0x09	; 9
     738:	90 e0       	ldi	r25, 0x00	; 0
     73a:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <dispatchPacket>
     73e:	90 93 af 7b 	sts	0x7BAF, r25
     742:	80 93 ae 7b 	sts	0x7BAE, r24
				printf("work_in=> Salgo del dispatchPacket\n ");			
     746:	00 d0       	rcall	.+0      	; 0x748 <work_in+0x70>
     748:	8a e3       	ldi	r24, 0x3A	; 58
     74a:	92 e2       	ldi	r25, 0x22	; 34
     74c:	ed b7       	in	r30, 0x3d	; 61
     74e:	fe b7       	in	r31, 0x3e	; 62
     750:	92 83       	std	Z+2, r25	; 0x02
     752:	81 83       	std	Z+1, r24	; 0x01
     754:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				ATENDER_INT_IN=1;		
     758:	d0 93 53 2e 	sts	0x2E53, r29
     75c:	c0 93 52 2e 	sts	0x2E52, r28
     760:	0f 90       	pop	r0
     762:	0f 90       	pop	r0
			}
			if(rxCommand.CommandOP==CommandGetFecha)
     764:	80 91 ee 81 	lds	r24, 0x81EE
     768:	90 91 ef 81 	lds	r25, 0x81EF
     76c:	0d 97       	sbiw	r24, 0x0d	; 13
     76e:	19 f5       	brne	.+70     	; 0x7b6 <work_in+0xde>
			{
				ATENDER_INT_IN=0;
     770:	10 92 53 2e 	sts	0x2E53, r1
     774:	10 92 52 2e 	sts	0x2E52, r1
				printf("work_in=> Estoy mandando la fecha\n");	
     778:	8f e5       	ldi	r24, 0x5F	; 95
     77a:	92 e2       	ldi	r25, 0x22	; 34
     77c:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				rc=dispatchPacket(PacketFecha,(uint8*)&txFecha);  
     780:	8a e0       	ldi	r24, 0x0A	; 10
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	6b eb       	ldi	r22, 0xBB	; 187
     786:	70 e8       	ldi	r23, 0x80	; 128
     788:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <dispatchPacket>
     78c:	90 93 af 7b 	sts	0x7BAF, r25
     790:	80 93 ae 7b 	sts	0x7BAE, r24
				printf("work_in=> Salgo del dispatchPacket\n ");			
     794:	00 d0       	rcall	.+0      	; 0x796 <work_in+0xbe>
     796:	8a e3       	ldi	r24, 0x3A	; 58
     798:	92 e2       	ldi	r25, 0x22	; 34
     79a:	ed b7       	in	r30, 0x3d	; 61
     79c:	fe b7       	in	r31, 0x3e	; 62
     79e:	92 83       	std	Z+2, r25	; 0x02
     7a0:	81 83       	std	Z+1, r24	; 0x01
     7a2:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				ATENDER_INT_IN=1;		
     7a6:	81 e0       	ldi	r24, 0x01	; 1
     7a8:	90 e0       	ldi	r25, 0x00	; 0
     7aa:	90 93 53 2e 	sts	0x2E53, r25
     7ae:	80 93 52 2e 	sts	0x2E52, r24
     7b2:	0f 90       	pop	r0
     7b4:	0f 90       	pop	r0
			}
			if(rxCommand.CommandOP==CommandGetAxisSettings)
     7b6:	80 91 ee 81 	lds	r24, 0x81EE
     7ba:	90 91 ef 81 	lds	r25, 0x81EF
     7be:	02 97       	sbiw	r24, 0x02	; 2
     7c0:	19 f5       	brne	.+70     	; 0x808 <work_in+0x130>
			{
				ATENDER_INT_IN=0;
     7c2:	10 92 53 2e 	sts	0x2E53, r1
     7c6:	10 92 52 2e 	sts	0x2E52, r1
				printf("work_in=> Estoy mandando la configuracion del robot\n");	
     7ca:	81 e8       	ldi	r24, 0x81	; 129
     7cc:	92 e2       	ldi	r25, 0x22	; 34
     7ce:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				rc=dispatchPacket(PacketAxisSettings,(uint8*)TxAxisSettings);  
     7d2:	86 e0       	ldi	r24, 0x06	; 6
     7d4:	90 e0       	ldi	r25, 0x00	; 0
     7d6:	64 e1       	ldi	r22, 0x14	; 20
     7d8:	7c e7       	ldi	r23, 0x7C	; 124
     7da:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <dispatchPacket>
     7de:	90 93 af 7b 	sts	0x7BAF, r25
     7e2:	80 93 ae 7b 	sts	0x7BAE, r24
				printf("work_in=> Salgo del dispatchPacket\n ");			
     7e6:	00 d0       	rcall	.+0      	; 0x7e8 <work_in+0x110>
     7e8:	8a e3       	ldi	r24, 0x3A	; 58
     7ea:	92 e2       	ldi	r25, 0x22	; 34
     7ec:	ed b7       	in	r30, 0x3d	; 61
     7ee:	fe b7       	in	r31, 0x3e	; 62
     7f0:	92 83       	std	Z+2, r25	; 0x02
     7f2:	81 83       	std	Z+1, r24	; 0x01
     7f4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				ATENDER_INT_IN=1;		
     7f8:	81 e0       	ldi	r24, 0x01	; 1
     7fa:	90 e0       	ldi	r25, 0x00	; 0
     7fc:	90 93 53 2e 	sts	0x2E53, r25
     800:	80 93 52 2e 	sts	0x2E52, r24
     804:	0f 90       	pop	r0
     806:	0f 90       	pop	r0
			}
			if(rxCommand.CommandOP==CommandGetPMDTrace)
     808:	80 91 ee 81 	lds	r24, 0x81EE
     80c:	90 91 ef 81 	lds	r25, 0x81EF
     810:	0c 97       	sbiw	r24, 0x0c	; 12
     812:	c9 f4       	brne	.+50     	; 0x846 <work_in+0x16e>
			{
				ATENDER_INT_IN=0;
     814:	10 92 53 2e 	sts	0x2E53, r1
     818:	10 92 52 2e 	sts	0x2E52, r1
				//rc=dispatchPacket(PacketTrace,(uint8*)Tracebufferdata);  
				EnvioTrazado2PC(rxCommand.Dato);
     81c:	80 91 f2 81 	lds	r24, 0x81F2
     820:	0e 94 76 2f 	call	0x5eec	; 0x5eec <EnvioTrazado2PC>
				printf("work_in=> Salgo del dispatchPacket\n ");			
     824:	00 d0       	rcall	.+0      	; 0x826 <work_in+0x14e>
     826:	8a e3       	ldi	r24, 0x3A	; 58
     828:	92 e2       	ldi	r25, 0x22	; 34
     82a:	ed b7       	in	r30, 0x3d	; 61
     82c:	fe b7       	in	r31, 0x3e	; 62
     82e:	92 83       	std	Z+2, r25	; 0x02
     830:	81 83       	std	Z+1, r24	; 0x01
     832:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				ATENDER_INT_IN=1;		
     836:	81 e0       	ldi	r24, 0x01	; 1
     838:	90 e0       	ldi	r25, 0x00	; 0
     83a:	90 93 53 2e 	sts	0x2E53, r25
     83e:	80 93 52 2e 	sts	0x2E52, r24
     842:	0f 90       	pop	r0
     844:	0f 90       	pop	r0
			}
			if(rxCommand.CommandOP==CommandGetPoseActual)
     846:	80 91 ee 81 	lds	r24, 0x81EE
     84a:	90 91 ef 81 	lds	r25, 0x81EF
     84e:	08 97       	sbiw	r24, 0x08	; 8
     850:	99 f5       	brne	.+102    	; 0x8b8 <work_in+0x1e0>
			{
				ATENDER_INT_IN=0;
     852:	10 92 53 2e 	sts	0x2E53, r1
     856:	10 92 52 2e 	sts	0x2E52, r1
				printf("work_in=> Estoy mandando la poses actual, Poseactual = %d\n",TXPoseActual);	
     85a:	00 d0       	rcall	.+0      	; 0x85c <work_in+0x184>
     85c:	00 d0       	rcall	.+0      	; 0x85e <work_in+0x186>
     85e:	85 eb       	ldi	r24, 0xB5	; 181
     860:	92 e2       	ldi	r25, 0x22	; 34
     862:	ed b7       	in	r30, 0x3d	; 61
     864:	fe b7       	in	r31, 0x3e	; 62
     866:	92 83       	std	Z+2, r25	; 0x02
     868:	81 83       	std	Z+1, r24	; 0x01
     86a:	80 91 92 7b 	lds	r24, 0x7B92
     86e:	90 91 93 7b 	lds	r25, 0x7B93
     872:	94 83       	std	Z+4, r25	; 0x04
     874:	83 83       	std	Z+3, r24	; 0x03
     876:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				rc=dispatchPacket(Packetuint16,(uint8*)&TXPoseActual);  
     87a:	0f 90       	pop	r0
     87c:	0f 90       	pop	r0
     87e:	0f 90       	pop	r0
     880:	0f 90       	pop	r0
     882:	8d e0       	ldi	r24, 0x0D	; 13
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	62 e9       	ldi	r22, 0x92	; 146
     888:	7b e7       	ldi	r23, 0x7B	; 123
     88a:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <dispatchPacket>
     88e:	90 93 af 7b 	sts	0x7BAF, r25
     892:	80 93 ae 7b 	sts	0x7BAE, r24
				printf("work_in=> Salgo del dispatchPacket\n ");			
     896:	00 d0       	rcall	.+0      	; 0x898 <work_in+0x1c0>
     898:	8a e3       	ldi	r24, 0x3A	; 58
     89a:	92 e2       	ldi	r25, 0x22	; 34
     89c:	ed b7       	in	r30, 0x3d	; 61
     89e:	fe b7       	in	r31, 0x3e	; 62
     8a0:	92 83       	std	Z+2, r25	; 0x02
     8a2:	81 83       	std	Z+1, r24	; 0x01
     8a4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				ATENDER_INT_IN=1;		
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	90 e0       	ldi	r25, 0x00	; 0
     8ac:	90 93 53 2e 	sts	0x2E53, r25
     8b0:	80 93 52 2e 	sts	0x2E52, r24
     8b4:	0f 90       	pop	r0
     8b6:	0f 90       	pop	r0
			}
	   }
	}
	printf("work_in=> Salgo del IN\n ");			
     8b8:	00 d0       	rcall	.+0      	; 0x8ba <work_in+0x1e2>
     8ba:	80 ef       	ldi	r24, 0xF0	; 240
     8bc:	92 e2       	ldi	r25, 0x22	; 34
     8be:	ed b7       	in	r30, 0x3d	; 61
     8c0:	fe b7       	in	r31, 0x3e	; 62
     8c2:	92 83       	std	Z+2, r25	; 0x02
     8c4:	81 83       	std	Z+1, r24	; 0x01
     8c6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
     8ca:	0f 90       	pop	r0
     8cc:	0f 90       	pop	r0
}
     8ce:	df 91       	pop	r29
     8d0:	cf 91       	pop	r28
     8d2:	08 95       	ret

000008d4 <work_out>:
}


/************************CUERPO DE LAS FUNCIONES*******************************************/
void work_out(void) 
{
     8d4:	2f 92       	push	r2
     8d6:	3f 92       	push	r3
     8d8:	4f 92       	push	r4
     8da:	5f 92       	push	r5
     8dc:	6f 92       	push	r6
     8de:	7f 92       	push	r7
     8e0:	8f 92       	push	r8
     8e2:	9f 92       	push	r9
     8e4:	af 92       	push	r10
     8e6:	bf 92       	push	r11
     8e8:	cf 92       	push	r12
     8ea:	df 92       	push	r13
     8ec:	ef 92       	push	r14
     8ee:	ff 92       	push	r15
     8f0:	0f 93       	push	r16
     8f2:	1f 93       	push	r17
     8f4:	df 93       	push	r29
     8f6:	cf 93       	push	r28
     8f8:	00 d0       	rcall	.+0      	; 0x8fa <work_out+0x26>
     8fa:	00 d0       	rcall	.+0      	; 0x8fc <work_out+0x28>
     8fc:	0f 92       	push	r0
     8fe:	cd b7       	in	r28, 0x3d	; 61
     900:	de b7       	in	r29, 0x3e	; 62
	static  int8 			Num_Variables_Trazar=0;	/*Numero de variable a trazar en visual*/
	int16					i,maxdata;				/*Para imprimir el vector de IDs*/
	tcontrol_RTC 			ctr;					/*Manejo del RTC*/
	double grados_Pose;                             /*Almacena pose en grados*/
	
	rc = receiptPacket();
     902:	0e 94 c2 1e 	call	0x3d84	; 0x3d84 <receiptPacket>
     906:	8c 01       	movw	r16, r24
     908:	90 93 af 7b 	sts	0x7BAF, r25
     90c:	80 93 ae 7b 	sts	0x7BAE, r24
	if(rc != rcOK) 					//Existe algun error?
     910:	00 97       	sbiw	r24, 0x00	; 0
     912:	09 f4       	brne	.+2      	; 0x916 <work_out+0x42>
     914:	66 c0       	rjmp	.+204    	; 0x9e2 <work_out+0x10e>
	{   			
		printf("work_out=> Codigo de retorno al REcibir los Datos %d = %s \n",rc,rcMsg(rc));
     916:	0e 94 70 21 	call	0x42e0	; 0x42e0 <rcMsg>
     91a:	00 d0       	rcall	.+0      	; 0x91c <work_out+0x48>
     91c:	00 d0       	rcall	.+0      	; 0x91e <work_out+0x4a>
     91e:	00 d0       	rcall	.+0      	; 0x920 <work_out+0x4c>
     920:	ed b7       	in	r30, 0x3d	; 61
     922:	fe b7       	in	r31, 0x3e	; 62
     924:	31 96       	adiw	r30, 0x01	; 1
     926:	29 e0       	ldi	r18, 0x09	; 9
     928:	33 e2       	ldi	r19, 0x23	; 35
     92a:	ad b7       	in	r26, 0x3d	; 61
     92c:	be b7       	in	r27, 0x3e	; 62
     92e:	12 96       	adiw	r26, 0x02	; 2
     930:	3c 93       	st	X, r19
     932:	2e 93       	st	-X, r18
     934:	11 97       	sbiw	r26, 0x01	; 1
     936:	13 83       	std	Z+3, r17	; 0x03
     938:	02 83       	std	Z+2, r16	; 0x02
     93a:	95 83       	std	Z+5, r25	; 0x05
     93c:	84 83       	std	Z+4, r24	; 0x04
     93e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("work_out=> Paquete recibido es %s \n",  PacketMsg(rxPacket));
     942:	ed b7       	in	r30, 0x3d	; 61
     944:	fe b7       	in	r31, 0x3e	; 62
     946:	36 96       	adiw	r30, 0x06	; 6
     948:	0f b6       	in	r0, 0x3f	; 63
     94a:	f8 94       	cli
     94c:	fe bf       	out	0x3e, r31	; 62
     94e:	0f be       	out	0x3f, r0	; 63
     950:	ed bf       	out	0x3d, r30	; 61
     952:	80 91 d0 80 	lds	r24, 0x80D0
     956:	90 91 d1 80 	lds	r25, 0x80D1
     95a:	0e 94 30 21 	call	0x4260	; 0x4260 <PacketMsg>
     95e:	00 d0       	rcall	.+0      	; 0x960 <work_out+0x8c>
     960:	00 d0       	rcall	.+0      	; 0x962 <work_out+0x8e>
     962:	25 e4       	ldi	r18, 0x45	; 69
     964:	33 e2       	ldi	r19, 0x23	; 35
     966:	ad b7       	in	r26, 0x3d	; 61
     968:	be b7       	in	r27, 0x3e	; 62
     96a:	12 96       	adiw	r26, 0x02	; 2
     96c:	3c 93       	st	X, r19
     96e:	2e 93       	st	-X, r18
     970:	11 97       	sbiw	r26, 0x01	; 1
     972:	14 96       	adiw	r26, 0x04	; 4
     974:	9c 93       	st	X, r25
     976:	8e 93       	st	-X, r24
     978:	13 97       	sbiw	r26, 0x03	; 3
     97a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("work_out=> La cantidad de datos  del header.datalength %x \n", rxHeader.dataLength);
     97e:	89 e6       	ldi	r24, 0x69	; 105
     980:	93 e2       	ldi	r25, 0x23	; 35
     982:	ed b7       	in	r30, 0x3d	; 61
     984:	fe b7       	in	r31, 0x3e	; 62
     986:	92 83       	std	Z+2, r25	; 0x02
     988:	81 83       	std	Z+1, r24	; 0x01
     98a:	80 91 d6 80 	lds	r24, 0x80D6
     98e:	90 91 d7 80 	lds	r25, 0x80D7
     992:	94 83       	std	Z+4, r25	; 0x04
     994:	83 83       	std	Z+3, r24	; 0x03
     996:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("work_out=> dataChecksum  es %x \n",rxHeader.dataChecksum);
     99a:	85 ea       	ldi	r24, 0xA5	; 165
     99c:	93 e2       	ldi	r25, 0x23	; 35
     99e:	ad b7       	in	r26, 0x3d	; 61
     9a0:	be b7       	in	r27, 0x3e	; 62
     9a2:	12 96       	adiw	r26, 0x02	; 2
     9a4:	9c 93       	st	X, r25
     9a6:	8e 93       	st	-X, r24
     9a8:	11 97       	sbiw	r26, 0x01	; 1
     9aa:	80 91 d8 80 	lds	r24, 0x80D8
     9ae:	90 91 d9 80 	lds	r25, 0x80D9
     9b2:	14 96       	adiw	r26, 0x04	; 4
     9b4:	9c 93       	st	X, r25
     9b6:	8e 93       	st	-X, r24
     9b8:	13 97       	sbiw	r26, 0x03	; 3
     9ba:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("work_out=> headerCheksum %x \n",rxHeader.headerChecksum);
     9be:	86 ec       	ldi	r24, 0xC6	; 198
     9c0:	93 e2       	ldi	r25, 0x23	; 35
     9c2:	ed b7       	in	r30, 0x3d	; 61
     9c4:	fe b7       	in	r31, 0x3e	; 62
     9c6:	92 83       	std	Z+2, r25	; 0x02
     9c8:	81 83       	std	Z+1, r24	; 0x01
     9ca:	80 91 da 80 	lds	r24, 0x80DA
     9ce:	90 91 db 80 	lds	r25, 0x80DB
     9d2:	94 83       	std	Z+4, r25	; 0x04
     9d4:	83 83       	std	Z+3, r24	; 0x03
     9d6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
     9da:	0f 90       	pop	r0
     9dc:	0f 90       	pop	r0
     9de:	0f 90       	pop	r0
     9e0:	0f 90       	pop	r0
	}
	switch(rxPacket) 
     9e2:	80 91 d0 80 	lds	r24, 0x80D0
     9e6:	90 91 d1 80 	lds	r25, 0x80D1
     9ea:	86 30       	cpi	r24, 0x06	; 6
     9ec:	91 05       	cpc	r25, r1
     9ee:	11 f4       	brne	.+4      	; 0x9f4 <work_out+0x120>
     9f0:	0c 94 76 0e 	jmp	0x1cec	; 0x1cec <work_out+0x1418>
     9f4:	87 30       	cpi	r24, 0x07	; 7
     9f6:	91 05       	cpc	r25, r1
     9f8:	64 f4       	brge	.+24     	; 0xa12 <work_out+0x13e>
     9fa:	83 30       	cpi	r24, 0x03	; 3
     9fc:	91 05       	cpc	r25, r1
     9fe:	09 f4       	brne	.+2      	; 0xa02 <work_out+0x12e>
     a00:	68 c7       	rjmp	.+3792   	; 0x18d2 <work_out+0xffe>
     a02:	84 30       	cpi	r24, 0x04	; 4
     a04:	91 05       	cpc	r25, r1
     a06:	a9 f0       	breq	.+42     	; 0xa32 <work_out+0x15e>
     a08:	01 97       	sbiw	r24, 0x01	; 1
     a0a:	11 f0       	breq	.+4      	; 0xa10 <work_out+0x13c>
     a0c:	0c 94 f3 0e 	jmp	0x1de6	; 0x1de6 <work_out+0x1512>
     a10:	c7 c0       	rjmp	.+398    	; 0xba0 <work_out+0x2cc>
     a12:	8a 30       	cpi	r24, 0x0A	; 10
     a14:	91 05       	cpc	r25, r1
     a16:	11 f4       	brne	.+4      	; 0xa1c <work_out+0x148>
     a18:	0c 94 a9 0d 	jmp	0x1b52	; 0x1b52 <work_out+0x127e>
     a1c:	8b 30       	cpi	r24, 0x0B	; 11
     a1e:	91 05       	cpc	r25, r1
     a20:	11 f4       	brne	.+4      	; 0xa26 <work_out+0x152>
     a22:	0c 94 2d 0e 	jmp	0x1c5a	; 0x1c5a <work_out+0x1386>
     a26:	09 97       	sbiw	r24, 0x09	; 9
     a28:	11 f0       	breq	.+4      	; 0xa2e <work_out+0x15a>
     a2a:	0c 94 f3 0e 	jmp	0x1de6	; 0x1de6 <work_out+0x1512>
     a2e:	0c 94 48 0d 	jmp	0x1a90	; 0x1a90 <work_out+0x11bc>
     a32:	cc 24       	eor	r12, r12
     a34:	dd 24       	eor	r13, r13
		case PacketTeachPendant :
		{
		    #ifdef DEBUGPUNTO
			for(eje=0;eje<DOF;eje++)
			{
		        printf("work_out=> El eje es  %s y su pos es %ld \n" ,AxisName((tAxis)eje),rxTrajectory.point[0].axis[eje].position);
     a36:	e4 ee       	ldi	r30, 0xE4	; 228
     a38:	8e 2e       	mov	r8, r30
     a3a:	e3 e2       	ldi	r30, 0x23	; 35
     a3c:	9e 2e       	mov	r9, r30
			    printf("work_out=> vel  %ld  y su ac  %ld \n" ,rxTrajectory.point[0].axis[eje].velocity,rxTrajectory.point[0].axis[eje].acceleration);
     a3e:	7f e0       	ldi	r23, 0x0F	; 15
     a40:	a7 2e       	mov	r10, r23
     a42:	74 e2       	ldi	r23, 0x24	; 36
     a44:	b7 2e       	mov	r11, r23
		case PacketTeachPendant :
		{
		    #ifdef DEBUGPUNTO
			for(eje=0;eje<DOF;eje++)
			{
		        printf("work_out=> El eje es  %s y su pos es %ld \n" ,AxisName((tAxis)eje),rxTrajectory.point[0].axis[eje].position);
     a46:	c6 01       	movw	r24, r12
     a48:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
     a4c:	2d b7       	in	r18, 0x3d	; 61
     a4e:	3e b7       	in	r19, 0x3e	; 62
     a50:	28 50       	subi	r18, 0x08	; 8
     a52:	30 40       	sbci	r19, 0x00	; 0
     a54:	0f b6       	in	r0, 0x3f	; 63
     a56:	f8 94       	cli
     a58:	3e bf       	out	0x3e, r19	; 62
     a5a:	0f be       	out	0x3f, r0	; 63
     a5c:	2d bf       	out	0x3d, r18	; 61
     a5e:	2f 5f       	subi	r18, 0xFF	; 255
     a60:	3f 4f       	sbci	r19, 0xFF	; 255
     a62:	ad b7       	in	r26, 0x3d	; 61
     a64:	be b7       	in	r27, 0x3e	; 62
     a66:	12 96       	adiw	r26, 0x02	; 2
     a68:	9c 92       	st	X, r9
     a6a:	8e 92       	st	-X, r8
     a6c:	11 97       	sbiw	r26, 0x01	; 1
     a6e:	f9 01       	movw	r30, r18
     a70:	93 83       	std	Z+3, r25	; 0x03
     a72:	82 83       	std	Z+2, r24	; 0x02
     a74:	e0 91 0d 82 	lds	r30, 0x820D
     a78:	f0 91 0e 82 	lds	r31, 0x820E
     a7c:	86 01       	movw	r16, r12
     a7e:	00 0f       	add	r16, r16
     a80:	11 1f       	adc	r17, r17
     a82:	0c 0d       	add	r16, r12
     a84:	1d 1d       	adc	r17, r13
     a86:	78 01       	movw	r14, r16
     a88:	ee 0c       	add	r14, r14
     a8a:	ff 1c       	adc	r15, r15
     a8c:	ee 0c       	add	r14, r14
     a8e:	ff 1c       	adc	r15, r15
     a90:	ee 0d       	add	r30, r14
     a92:	ff 1d       	adc	r31, r15
     a94:	80 81       	ld	r24, Z
     a96:	91 81       	ldd	r25, Z+1	; 0x01
     a98:	a2 81       	ldd	r26, Z+2	; 0x02
     a9a:	b3 81       	ldd	r27, Z+3	; 0x03
     a9c:	f9 01       	movw	r30, r18
     a9e:	84 83       	std	Z+4, r24	; 0x04
     aa0:	95 83       	std	Z+5, r25	; 0x05
     aa2:	a6 83       	std	Z+6, r26	; 0x06
     aa4:	b7 83       	std	Z+7, r27	; 0x07
     aa6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			    printf("work_out=> vel  %ld  y su ac  %ld \n" ,rxTrajectory.point[0].axis[eje].velocity,rxTrajectory.point[0].axis[eje].acceleration);
     aaa:	e0 91 0d 82 	lds	r30, 0x820D
     aae:	f0 91 0e 82 	lds	r31, 0x820E
     ab2:	00 d0       	rcall	.+0      	; 0xab4 <work_out+0x1e0>
     ab4:	2d b7       	in	r18, 0x3d	; 61
     ab6:	3e b7       	in	r19, 0x3e	; 62
     ab8:	2f 5f       	subi	r18, 0xFF	; 255
     aba:	3f 4f       	sbci	r19, 0xFF	; 255
     abc:	ad b7       	in	r26, 0x3d	; 61
     abe:	be b7       	in	r27, 0x3e	; 62
     ac0:	12 96       	adiw	r26, 0x02	; 2
     ac2:	bc 92       	st	X, r11
     ac4:	ae 92       	st	-X, r10
     ac6:	11 97       	sbiw	r26, 0x01	; 1
     ac8:	0f 5f       	subi	r16, 0xFF	; 255
     aca:	1f 4f       	sbci	r17, 0xFF	; 255
     acc:	00 0f       	add	r16, r16
     ace:	11 1f       	adc	r17, r17
     ad0:	00 0f       	add	r16, r16
     ad2:	11 1f       	adc	r17, r17
     ad4:	0e 0f       	add	r16, r30
     ad6:	1f 1f       	adc	r17, r31
     ad8:	d8 01       	movw	r26, r16
     ada:	4d 91       	ld	r20, X+
     adc:	5d 91       	ld	r21, X+
     ade:	6d 91       	ld	r22, X+
     ae0:	7c 91       	ld	r23, X
     ae2:	d9 01       	movw	r26, r18
     ae4:	12 96       	adiw	r26, 0x02	; 2
     ae6:	4d 93       	st	X+, r20
     ae8:	5d 93       	st	X+, r21
     aea:	6d 93       	st	X+, r22
     aec:	7c 93       	st	X, r23
     aee:	15 97       	sbiw	r26, 0x05	; 5
     af0:	ee 0d       	add	r30, r14
     af2:	ff 1d       	adc	r31, r15
     af4:	80 85       	ldd	r24, Z+8	; 0x08
     af6:	91 85       	ldd	r25, Z+9	; 0x09
     af8:	a2 85       	ldd	r26, Z+10	; 0x0a
     afa:	b3 85       	ldd	r27, Z+11	; 0x0b
     afc:	f9 01       	movw	r30, r18
     afe:	86 83       	std	Z+6, r24	; 0x06
     b00:	97 83       	std	Z+7, r25	; 0x07
     b02:	a0 87       	std	Z+8, r26	; 0x08
     b04:	b1 87       	std	Z+9, r27	; 0x09
     b06:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	switch(rxPacket) 
	{   
		case PacketTeachPendant :
		{
		    #ifdef DEBUGPUNTO
			for(eje=0;eje<DOF;eje++)
     b0a:	08 94       	sec
     b0c:	c1 1c       	adc	r12, r1
     b0e:	d1 1c       	adc	r13, r1
     b10:	2d b7       	in	r18, 0x3d	; 61
     b12:	3e b7       	in	r19, 0x3e	; 62
     b14:	26 5f       	subi	r18, 0xF6	; 246
     b16:	3f 4f       	sbci	r19, 0xFF	; 255
     b18:	0f b6       	in	r0, 0x3f	; 63
     b1a:	f8 94       	cli
     b1c:	3e bf       	out	0x3e, r19	; 62
     b1e:	0f be       	out	0x3f, r0	; 63
     b20:	2d bf       	out	0x3d, r18	; 61
     b22:	35 e0       	ldi	r19, 0x05	; 5
     b24:	c3 16       	cp	r12, r19
     b26:	d1 04       	cpc	r13, r1
     b28:	09 f0       	breq	.+2      	; 0xb2c <work_out+0x258>
     b2a:	8d cf       	rjmp	.-230    	; 0xa46 <work_out+0x172>
			{
		        printf("work_out=> El eje es  %s y su pos es %ld \n" ,AxisName((tAxis)eje),rxTrajectory.point[0].axis[eje].position);
			    printf("work_out=> vel  %ld  y su ac  %ld \n" ,rxTrajectory.point[0].axis[eje].velocity,rxTrajectory.point[0].axis[eje].acceleration);
		    }
			printf("work_out=>Invalida Mask= %X \n", rxTrajectory.invalidmask);
     b2c:	00 d0       	rcall	.+0      	; 0xb2e <work_out+0x25a>
     b2e:	00 d0       	rcall	.+0      	; 0xb30 <work_out+0x25c>
     b30:	83 e3       	ldi	r24, 0x33	; 51
     b32:	94 e2       	ldi	r25, 0x24	; 36
     b34:	ad b7       	in	r26, 0x3d	; 61
     b36:	be b7       	in	r27, 0x3e	; 62
     b38:	12 96       	adiw	r26, 0x02	; 2
     b3a:	9c 93       	st	X, r25
     b3c:	8e 93       	st	-X, r24
     b3e:	11 97       	sbiw	r26, 0x01	; 1
     b40:	80 91 0b 82 	lds	r24, 0x820B
     b44:	90 91 0c 82 	lds	r25, 0x820C
     b48:	14 96       	adiw	r26, 0x04	; 4
     b4a:	9c 93       	st	X, r25
     b4c:	8e 93       	st	-X, r24
     b4e:	13 97       	sbiw	r26, 0x03	; 3
     b50:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			printf("work_out=>Tamano %X \n", rxTrajectory.size);
     b54:	81 e5       	ldi	r24, 0x51	; 81
     b56:	94 e2       	ldi	r25, 0x24	; 36
     b58:	ed b7       	in	r30, 0x3d	; 61
     b5a:	fe b7       	in	r31, 0x3e	; 62
     b5c:	92 83       	std	Z+2, r25	; 0x02
     b5e:	81 83       	std	Z+1, r24	; 0x01
     b60:	80 91 09 82 	lds	r24, 0x8209
     b64:	90 91 0a 82 	lds	r25, 0x820A
     b68:	94 83       	std	Z+4, r25	; 0x04
     b6a:	83 83       	std	Z+3, r24	; 0x03
     b6c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		    #endif	
			/*Coloco la pose a 0, pues se a movido una poses nueva*/
			TXPoseActual=0;
     b70:	10 92 93 7b 	sts	0x7B93, r1
     b74:	10 92 92 7b 	sts	0x7B92, r1
			
			printf("work_out=> Efectuando funcion teach_pendant_point en PMDrobotics.c  \n");		
     b78:	0f 90       	pop	r0
     b7a:	0f 90       	pop	r0
     b7c:	0f 90       	pop	r0
     b7e:	0f 90       	pop	r0
     b80:	87 e6       	ldi	r24, 0x67	; 103
     b82:	94 e2       	ldi	r25, 0x24	; 36
     b84:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		    teach_pendant_point(&rxTrajectory,0);	
     b88:	89 e0       	ldi	r24, 0x09	; 9
     b8a:	92 e8       	ldi	r25, 0x82	; 130
     b8c:	60 e0       	ldi	r22, 0x00	; 0
     b8e:	70 e0       	ldi	r23, 0x00	; 0
     b90:	0e 94 7f 51 	call	0xa2fe	; 0xa2fe <teach_pendant_point>
			/*Copia la posicion de los MOTORES a la estructura pose en ram*/
			ObtenerPose(&Pose);			    
     b94:	87 e9       	ldi	r24, 0x97	; 151
     b96:	9b e7       	ldi	r25, 0x7B	; 123
     b98:	0e 94 0a 35 	call	0x6a14	; 0x6a14 <ObtenerPose>
     b9c:	0c 94 f3 0e 	jmp	0x1de6	; 0x1de6 <work_out+0x1512>
		case PacketCommand:
		{
			#ifdef DEBUGUSB 
		    printf("work_out=> el comando es %d => %s \n",rxCommand.CommandOP,CommandMsg(rxCommand));	
			#endif	
			if(rxCommand.CommandOP==CommandOpenGripper)
     ba0:	80 91 ee 81 	lds	r24, 0x81EE
     ba4:	90 91 ef 81 	lds	r25, 0x81EF
     ba8:	03 97       	sbiw	r24, 0x03	; 3
     baa:	11 f4       	brne	.+4      	; 0xbb0 <work_out+0x2dc>
			{	
				openGripper(); 
     bac:	0e 94 69 76 	call	0xecd2	; 0xecd2 <openGripper>
				
			
			}
			if(rxCommand.CommandOP==CommandCloseGripper)
     bb0:	80 91 ee 81 	lds	r24, 0x81EE
     bb4:	90 91 ef 81 	lds	r25, 0x81EF
     bb8:	04 97       	sbiw	r24, 0x04	; 4
     bba:	11 f4       	brne	.+4      	; 0xbc0 <work_out+0x2ec>
			{	
				closeGripper(); 
     bbc:	0e 94 9a 76 	call	0xed34	; 0xed34 <closeGripper>
				
			
			}
			/*Graba la pose en eeprom*/
		    if(rxCommand.CommandOP==CommandSetPoseEEPROM)  			
     bc0:	80 91 ee 81 	lds	r24, 0x81EE
     bc4:	90 91 ef 81 	lds	r25, 0x81EF
     bc8:	05 97       	sbiw	r24, 0x05	; 5
     bca:	09 f0       	breq	.+2      	; 0xbce <work_out+0x2fa>
     bcc:	ef c0       	rjmp	.+478    	; 0xdac <work_out+0x4d8>
			{  
			    
				Pose.id=rxCommand.Dato;
     bce:	80 91 f2 81 	lds	r24, 0x81F2
     bd2:	90 91 f3 81 	lds	r25, 0x81F3
     bd6:	90 93 98 7b 	sts	0x7B98, r25
     bda:	80 93 97 7b 	sts	0x7B97, r24
				TXPoseActual=Pose.id;
     bde:	90 93 93 7b 	sts	0x7B93, r25
     be2:	80 93 92 7b 	sts	0x7B92, r24
				#ifdef DEBUGPOSE
				printf("work_out=> ID de Pose = %ld \n",rxCommand.Dato);	
     be6:	00 d0       	rcall	.+0      	; 0xbe8 <work_out+0x314>
     be8:	00 d0       	rcall	.+0      	; 0xbea <work_out+0x316>
     bea:	00 d0       	rcall	.+0      	; 0xbec <work_out+0x318>
     bec:	8c ea       	ldi	r24, 0xAC	; 172
     bee:	94 e2       	ldi	r25, 0x24	; 36
     bf0:	ad b7       	in	r26, 0x3d	; 61
     bf2:	be b7       	in	r27, 0x3e	; 62
     bf4:	12 96       	adiw	r26, 0x02	; 2
     bf6:	9c 93       	st	X, r25
     bf8:	8e 93       	st	-X, r24
     bfa:	11 97       	sbiw	r26, 0x01	; 1
     bfc:	80 91 f2 81 	lds	r24, 0x81F2
     c00:	90 91 f3 81 	lds	r25, 0x81F3
     c04:	a0 91 f4 81 	lds	r26, 0x81F4
     c08:	b0 91 f5 81 	lds	r27, 0x81F5
     c0c:	ed b7       	in	r30, 0x3d	; 61
     c0e:	fe b7       	in	r31, 0x3e	; 62
     c10:	83 83       	std	Z+3, r24	; 0x03
     c12:	94 83       	std	Z+4, r25	; 0x04
     c14:	a5 83       	std	Z+5, r26	; 0x05
     c16:	b6 83       	std	Z+6, r27	; 0x06
     c18:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			    printf("work_out=> Pose->Pos_num = %d   \n",Pose.id);	
     c1c:	0f 90       	pop	r0
     c1e:	0f 90       	pop	r0
     c20:	8a ec       	ldi	r24, 0xCA	; 202
     c22:	94 e2       	ldi	r25, 0x24	; 36
     c24:	ad b7       	in	r26, 0x3d	; 61
     c26:	be b7       	in	r27, 0x3e	; 62
     c28:	12 96       	adiw	r26, 0x02	; 2
     c2a:	9c 93       	st	X, r25
     c2c:	8e 93       	st	-X, r24
     c2e:	11 97       	sbiw	r26, 0x01	; 1
     c30:	80 91 97 7b 	lds	r24, 0x7B97
     c34:	90 91 98 7b 	lds	r25, 0x7B98
     c38:	14 96       	adiw	r26, 0x04	; 4
     c3a:	9c 93       	st	X, r25
     c3c:	8e 93       	st	-X, r24
     c3e:	13 97       	sbiw	r26, 0x03	; 3
     c40:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	            printf("work_out=> Pose->Pos_Waist = %ld  \n ",Pose.Pos_Waist);	
     c44:	00 d0       	rcall	.+0      	; 0xc46 <work_out+0x372>
     c46:	8c ee       	ldi	r24, 0xEC	; 236
     c48:	94 e2       	ldi	r25, 0x24	; 36
     c4a:	ed b7       	in	r30, 0x3d	; 61
     c4c:	fe b7       	in	r31, 0x3e	; 62
     c4e:	92 83       	std	Z+2, r25	; 0x02
     c50:	81 83       	std	Z+1, r24	; 0x01
     c52:	80 91 99 7b 	lds	r24, 0x7B99
     c56:	90 91 9a 7b 	lds	r25, 0x7B9A
     c5a:	a0 91 9b 7b 	lds	r26, 0x7B9B
     c5e:	b0 91 9c 7b 	lds	r27, 0x7B9C
     c62:	83 83       	std	Z+3, r24	; 0x03
     c64:	94 83       	std	Z+4, r25	; 0x04
     c66:	a5 83       	std	Z+5, r26	; 0x05
     c68:	b6 83       	std	Z+6, r27	; 0x06
     c6a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	            printf("work_out=> Pose->Pos_Shoulder = %ld  \n ",Pose.Pos_Shoulder);	
     c6e:	81 e1       	ldi	r24, 0x11	; 17
     c70:	95 e2       	ldi	r25, 0x25	; 37
     c72:	ad b7       	in	r26, 0x3d	; 61
     c74:	be b7       	in	r27, 0x3e	; 62
     c76:	12 96       	adiw	r26, 0x02	; 2
     c78:	9c 93       	st	X, r25
     c7a:	8e 93       	st	-X, r24
     c7c:	11 97       	sbiw	r26, 0x01	; 1
     c7e:	80 91 9d 7b 	lds	r24, 0x7B9D
     c82:	90 91 9e 7b 	lds	r25, 0x7B9E
     c86:	a0 91 9f 7b 	lds	r26, 0x7B9F
     c8a:	b0 91 a0 7b 	lds	r27, 0x7BA0
     c8e:	ed b7       	in	r30, 0x3d	; 61
     c90:	fe b7       	in	r31, 0x3e	; 62
     c92:	83 83       	std	Z+3, r24	; 0x03
     c94:	94 83       	std	Z+4, r25	; 0x04
     c96:	a5 83       	std	Z+5, r26	; 0x05
     c98:	b6 83       	std	Z+6, r27	; 0x06
     c9a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	            printf("work_out=> Pose->Pos_Elbow = %ld  \n ",Pose.Pos_Elbow);	
     c9e:	89 e3       	ldi	r24, 0x39	; 57
     ca0:	95 e2       	ldi	r25, 0x25	; 37
     ca2:	ad b7       	in	r26, 0x3d	; 61
     ca4:	be b7       	in	r27, 0x3e	; 62
     ca6:	12 96       	adiw	r26, 0x02	; 2
     ca8:	9c 93       	st	X, r25
     caa:	8e 93       	st	-X, r24
     cac:	11 97       	sbiw	r26, 0x01	; 1
     cae:	80 91 a1 7b 	lds	r24, 0x7BA1
     cb2:	90 91 a2 7b 	lds	r25, 0x7BA2
     cb6:	a0 91 a3 7b 	lds	r26, 0x7BA3
     cba:	b0 91 a4 7b 	lds	r27, 0x7BA4
     cbe:	ed b7       	in	r30, 0x3d	; 61
     cc0:	fe b7       	in	r31, 0x3e	; 62
     cc2:	83 83       	std	Z+3, r24	; 0x03
     cc4:	94 83       	std	Z+4, r25	; 0x04
     cc6:	a5 83       	std	Z+5, r26	; 0x05
     cc8:	b6 83       	std	Z+6, r27	; 0x06
     cca:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	            printf("work_out=> Pose->Pos_Pitch = %ld  \n ",Pose.Pos_Pitch);	
     cce:	8e e5       	ldi	r24, 0x5E	; 94
     cd0:	95 e2       	ldi	r25, 0x25	; 37
     cd2:	ad b7       	in	r26, 0x3d	; 61
     cd4:	be b7       	in	r27, 0x3e	; 62
     cd6:	12 96       	adiw	r26, 0x02	; 2
     cd8:	9c 93       	st	X, r25
     cda:	8e 93       	st	-X, r24
     cdc:	11 97       	sbiw	r26, 0x01	; 1
     cde:	80 91 a5 7b 	lds	r24, 0x7BA5
     ce2:	90 91 a6 7b 	lds	r25, 0x7BA6
     ce6:	a0 91 a7 7b 	lds	r26, 0x7BA7
     cea:	b0 91 a8 7b 	lds	r27, 0x7BA8
     cee:	ed b7       	in	r30, 0x3d	; 61
     cf0:	fe b7       	in	r31, 0x3e	; 62
     cf2:	83 83       	std	Z+3, r24	; 0x03
     cf4:	94 83       	std	Z+4, r25	; 0x04
     cf6:	a5 83       	std	Z+5, r26	; 0x05
     cf8:	b6 83       	std	Z+6, r27	; 0x06
     cfa:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	            printf("work_out=> Pose->Pos_Roll= %ld  \n ",Pose.Pos_Roll);	
     cfe:	83 e8       	ldi	r24, 0x83	; 131
     d00:	95 e2       	ldi	r25, 0x25	; 37
     d02:	ad b7       	in	r26, 0x3d	; 61
     d04:	be b7       	in	r27, 0x3e	; 62
     d06:	12 96       	adiw	r26, 0x02	; 2
     d08:	9c 93       	st	X, r25
     d0a:	8e 93       	st	-X, r24
     d0c:	11 97       	sbiw	r26, 0x01	; 1
     d0e:	80 91 a9 7b 	lds	r24, 0x7BA9
     d12:	90 91 aa 7b 	lds	r25, 0x7BAA
     d16:	a0 91 ab 7b 	lds	r26, 0x7BAB
     d1a:	b0 91 ac 7b 	lds	r27, 0x7BAC
     d1e:	ed b7       	in	r30, 0x3d	; 61
     d20:	fe b7       	in	r31, 0x3e	; 62
     d22:	83 83       	std	Z+3, r24	; 0x03
     d24:	94 83       	std	Z+4, r25	; 0x04
     d26:	a5 83       	std	Z+5, r26	; 0x05
     d28:	b6 83       	std	Z+6, r27	; 0x06
     d2a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				printf("work_out=> Pose->Gripper_Status =%d \n",Pose.Gripper_Status);
     d2e:	0f 90       	pop	r0
     d30:	0f 90       	pop	r0
     d32:	86 ea       	ldi	r24, 0xA6	; 166
     d34:	95 e2       	ldi	r25, 0x25	; 37
     d36:	ad b7       	in	r26, 0x3d	; 61
     d38:	be b7       	in	r27, 0x3e	; 62
     d3a:	12 96       	adiw	r26, 0x02	; 2
     d3c:	9c 93       	st	X, r25
     d3e:	8e 93       	st	-X, r24
     d40:	11 97       	sbiw	r26, 0x01	; 1
     d42:	80 91 ad 7b 	lds	r24, 0x7BAD
     d46:	99 27       	eor	r25, r25
     d48:	87 fd       	sbrc	r24, 7
     d4a:	90 95       	com	r25
     d4c:	14 96       	adiw	r26, 0x04	; 4
     d4e:	9c 93       	st	X, r25
     d50:	8e 93       	st	-X, r24
     d52:	13 97       	sbiw	r26, 0x03	; 3
     d54:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				#endif	
				Pose.Gripper_Status=Estado_gripper();
     d58:	0f 90       	pop	r0
     d5a:	0f 90       	pop	r0
     d5c:	0f 90       	pop	r0
     d5e:	0f 90       	pop	r0
     d60:	0e 94 cb 76 	call	0xed96	; 0xed96 <Estado_gripper>
     d64:	80 93 ad 7b 	sts	0x7BAD, r24
				//No es posible determinar el estado del gripper por interuptores 
				//Suponer cerrado con pieza..
				if(Pose.Gripper_Status==-1)
     d68:	8f 3f       	cpi	r24, 0xFF	; 255
     d6a:	19 f4       	brne	.+6      	; 0xd72 <work_out+0x49e>
				{
					Pose.Gripper_Status=1;
     d6c:	81 e0       	ldi	r24, 0x01	; 1
     d6e:	80 93 ad 7b 	sts	0x7BAD, r24
					
				}
				Adicionar_PoseTWI(Pose); 
     d72:	ed b7       	in	r30, 0x3d	; 61
     d74:	fe b7       	in	r31, 0x3e	; 62
     d76:	77 97       	sbiw	r30, 0x17	; 23
     d78:	0f b6       	in	r0, 0x3f	; 63
     d7a:	f8 94       	cli
     d7c:	fe bf       	out	0x3e, r31	; 62
     d7e:	0f be       	out	0x3f, r0	; 63
     d80:	ed bf       	out	0x3d, r30	; 61
     d82:	ad b7       	in	r26, 0x3d	; 61
     d84:	be b7       	in	r27, 0x3e	; 62
     d86:	11 96       	adiw	r26, 0x01	; 1
     d88:	e7 e9       	ldi	r30, 0x97	; 151
     d8a:	fb e7       	ldi	r31, 0x7B	; 123
     d8c:	87 e1       	ldi	r24, 0x17	; 23
     d8e:	01 90       	ld	r0, Z+
     d90:	0d 92       	st	X+, r0
     d92:	81 50       	subi	r24, 0x01	; 1
     d94:	e1 f7       	brne	.-8      	; 0xd8e <work_out+0x4ba>
     d96:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <Adicionar_PoseTWI>
     d9a:	2d b7       	in	r18, 0x3d	; 61
     d9c:	3e b7       	in	r19, 0x3e	; 62
     d9e:	29 5e       	subi	r18, 0xE9	; 233
     da0:	3f 4f       	sbci	r19, 0xFF	; 255
     da2:	0f b6       	in	r0, 0x3f	; 63
     da4:	f8 94       	cli
     da6:	3e bf       	out	0x3e, r19	; 62
     da8:	0f be       	out	0x3f, r0	; 63
     daa:	2d bf       	out	0x3d, r18	; 61
			}
			/*Sobreescribe una poses existente*/
		    if(rxCommand.CommandOP==CommandReSetPoseEEPROM)  			
     dac:	80 91 ee 81 	lds	r24, 0x81EE
     db0:	90 91 ef 81 	lds	r25, 0x81EF
     db4:	06 97       	sbiw	r24, 0x06	; 6
     db6:	09 f0       	breq	.+2      	; 0xdba <work_out+0x4e6>
     db8:	ef c0       	rjmp	.+478    	; 0xf98 <work_out+0x6c4>
			{  
			    
				Pose.id=rxCommand.Dato;
     dba:	80 91 f2 81 	lds	r24, 0x81F2
     dbe:	90 91 f3 81 	lds	r25, 0x81F3
     dc2:	90 93 98 7b 	sts	0x7B98, r25
     dc6:	80 93 97 7b 	sts	0x7B97, r24
				TXPoseActual=Pose.id;
     dca:	90 93 93 7b 	sts	0x7B93, r25
     dce:	80 93 92 7b 	sts	0x7B92, r24
				#ifdef DEBUGPOSE
				printf("work_out=> ID de Pose = %ld \n",rxCommand.Dato);	
     dd2:	00 d0       	rcall	.+0      	; 0xdd4 <work_out+0x500>
     dd4:	00 d0       	rcall	.+0      	; 0xdd6 <work_out+0x502>
     dd6:	00 d0       	rcall	.+0      	; 0xdd8 <work_out+0x504>
     dd8:	8c ea       	ldi	r24, 0xAC	; 172
     dda:	94 e2       	ldi	r25, 0x24	; 36
     ddc:	ad b7       	in	r26, 0x3d	; 61
     dde:	be b7       	in	r27, 0x3e	; 62
     de0:	12 96       	adiw	r26, 0x02	; 2
     de2:	9c 93       	st	X, r25
     de4:	8e 93       	st	-X, r24
     de6:	11 97       	sbiw	r26, 0x01	; 1
     de8:	80 91 f2 81 	lds	r24, 0x81F2
     dec:	90 91 f3 81 	lds	r25, 0x81F3
     df0:	a0 91 f4 81 	lds	r26, 0x81F4
     df4:	b0 91 f5 81 	lds	r27, 0x81F5
     df8:	ed b7       	in	r30, 0x3d	; 61
     dfa:	fe b7       	in	r31, 0x3e	; 62
     dfc:	83 83       	std	Z+3, r24	; 0x03
     dfe:	94 83       	std	Z+4, r25	; 0x04
     e00:	a5 83       	std	Z+5, r26	; 0x05
     e02:	b6 83       	std	Z+6, r27	; 0x06
     e04:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			    printf("work_out=> Pose->Pos_num = %d   \n",Pose.id);	
     e08:	0f 90       	pop	r0
     e0a:	0f 90       	pop	r0
     e0c:	8a ec       	ldi	r24, 0xCA	; 202
     e0e:	94 e2       	ldi	r25, 0x24	; 36
     e10:	ad b7       	in	r26, 0x3d	; 61
     e12:	be b7       	in	r27, 0x3e	; 62
     e14:	12 96       	adiw	r26, 0x02	; 2
     e16:	9c 93       	st	X, r25
     e18:	8e 93       	st	-X, r24
     e1a:	11 97       	sbiw	r26, 0x01	; 1
     e1c:	80 91 97 7b 	lds	r24, 0x7B97
     e20:	90 91 98 7b 	lds	r25, 0x7B98
     e24:	14 96       	adiw	r26, 0x04	; 4
     e26:	9c 93       	st	X, r25
     e28:	8e 93       	st	-X, r24
     e2a:	13 97       	sbiw	r26, 0x03	; 3
     e2c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	            printf("work_out=> Pose->Pos_Waist = %ld  \n ",Pose.Pos_Waist);	
     e30:	00 d0       	rcall	.+0      	; 0xe32 <work_out+0x55e>
     e32:	8c ee       	ldi	r24, 0xEC	; 236
     e34:	94 e2       	ldi	r25, 0x24	; 36
     e36:	ed b7       	in	r30, 0x3d	; 61
     e38:	fe b7       	in	r31, 0x3e	; 62
     e3a:	92 83       	std	Z+2, r25	; 0x02
     e3c:	81 83       	std	Z+1, r24	; 0x01
     e3e:	80 91 99 7b 	lds	r24, 0x7B99
     e42:	90 91 9a 7b 	lds	r25, 0x7B9A
     e46:	a0 91 9b 7b 	lds	r26, 0x7B9B
     e4a:	b0 91 9c 7b 	lds	r27, 0x7B9C
     e4e:	83 83       	std	Z+3, r24	; 0x03
     e50:	94 83       	std	Z+4, r25	; 0x04
     e52:	a5 83       	std	Z+5, r26	; 0x05
     e54:	b6 83       	std	Z+6, r27	; 0x06
     e56:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	            printf("work_out=> Pose->Pos_Shoulder = %ld  \n ",Pose.Pos_Shoulder);	
     e5a:	81 e1       	ldi	r24, 0x11	; 17
     e5c:	95 e2       	ldi	r25, 0x25	; 37
     e5e:	ad b7       	in	r26, 0x3d	; 61
     e60:	be b7       	in	r27, 0x3e	; 62
     e62:	12 96       	adiw	r26, 0x02	; 2
     e64:	9c 93       	st	X, r25
     e66:	8e 93       	st	-X, r24
     e68:	11 97       	sbiw	r26, 0x01	; 1
     e6a:	80 91 9d 7b 	lds	r24, 0x7B9D
     e6e:	90 91 9e 7b 	lds	r25, 0x7B9E
     e72:	a0 91 9f 7b 	lds	r26, 0x7B9F
     e76:	b0 91 a0 7b 	lds	r27, 0x7BA0
     e7a:	ed b7       	in	r30, 0x3d	; 61
     e7c:	fe b7       	in	r31, 0x3e	; 62
     e7e:	83 83       	std	Z+3, r24	; 0x03
     e80:	94 83       	std	Z+4, r25	; 0x04
     e82:	a5 83       	std	Z+5, r26	; 0x05
     e84:	b6 83       	std	Z+6, r27	; 0x06
     e86:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	            printf("work_out=> Pose->Pos_Elbow = %ld  \n ",Pose.Pos_Elbow);	
     e8a:	89 e3       	ldi	r24, 0x39	; 57
     e8c:	95 e2       	ldi	r25, 0x25	; 37
     e8e:	ad b7       	in	r26, 0x3d	; 61
     e90:	be b7       	in	r27, 0x3e	; 62
     e92:	12 96       	adiw	r26, 0x02	; 2
     e94:	9c 93       	st	X, r25
     e96:	8e 93       	st	-X, r24
     e98:	11 97       	sbiw	r26, 0x01	; 1
     e9a:	80 91 a1 7b 	lds	r24, 0x7BA1
     e9e:	90 91 a2 7b 	lds	r25, 0x7BA2
     ea2:	a0 91 a3 7b 	lds	r26, 0x7BA3
     ea6:	b0 91 a4 7b 	lds	r27, 0x7BA4
     eaa:	ed b7       	in	r30, 0x3d	; 61
     eac:	fe b7       	in	r31, 0x3e	; 62
     eae:	83 83       	std	Z+3, r24	; 0x03
     eb0:	94 83       	std	Z+4, r25	; 0x04
     eb2:	a5 83       	std	Z+5, r26	; 0x05
     eb4:	b6 83       	std	Z+6, r27	; 0x06
     eb6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	            printf("work_out=> Pose->Pos_Pitch = %ld  \n ",Pose.Pos_Pitch);	
     eba:	8e e5       	ldi	r24, 0x5E	; 94
     ebc:	95 e2       	ldi	r25, 0x25	; 37
     ebe:	ad b7       	in	r26, 0x3d	; 61
     ec0:	be b7       	in	r27, 0x3e	; 62
     ec2:	12 96       	adiw	r26, 0x02	; 2
     ec4:	9c 93       	st	X, r25
     ec6:	8e 93       	st	-X, r24
     ec8:	11 97       	sbiw	r26, 0x01	; 1
     eca:	80 91 a5 7b 	lds	r24, 0x7BA5
     ece:	90 91 a6 7b 	lds	r25, 0x7BA6
     ed2:	a0 91 a7 7b 	lds	r26, 0x7BA7
     ed6:	b0 91 a8 7b 	lds	r27, 0x7BA8
     eda:	ed b7       	in	r30, 0x3d	; 61
     edc:	fe b7       	in	r31, 0x3e	; 62
     ede:	83 83       	std	Z+3, r24	; 0x03
     ee0:	94 83       	std	Z+4, r25	; 0x04
     ee2:	a5 83       	std	Z+5, r26	; 0x05
     ee4:	b6 83       	std	Z+6, r27	; 0x06
     ee6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	            printf("work_out=> Pose->Pos_Roll= %ld  \n ",Pose.Pos_Roll);
     eea:	83 e8       	ldi	r24, 0x83	; 131
     eec:	95 e2       	ldi	r25, 0x25	; 37
     eee:	ad b7       	in	r26, 0x3d	; 61
     ef0:	be b7       	in	r27, 0x3e	; 62
     ef2:	12 96       	adiw	r26, 0x02	; 2
     ef4:	9c 93       	st	X, r25
     ef6:	8e 93       	st	-X, r24
     ef8:	11 97       	sbiw	r26, 0x01	; 1
     efa:	80 91 a9 7b 	lds	r24, 0x7BA9
     efe:	90 91 aa 7b 	lds	r25, 0x7BAA
     f02:	a0 91 ab 7b 	lds	r26, 0x7BAB
     f06:	b0 91 ac 7b 	lds	r27, 0x7BAC
     f0a:	ed b7       	in	r30, 0x3d	; 61
     f0c:	fe b7       	in	r31, 0x3e	; 62
     f0e:	83 83       	std	Z+3, r24	; 0x03
     f10:	94 83       	std	Z+4, r25	; 0x04
     f12:	a5 83       	std	Z+5, r26	; 0x05
     f14:	b6 83       	std	Z+6, r27	; 0x06
     f16:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				printf("work_out=> Pose->Gripper_Status =%d \n",Pose.Gripper_Status);
     f1a:	0f 90       	pop	r0
     f1c:	0f 90       	pop	r0
     f1e:	86 ea       	ldi	r24, 0xA6	; 166
     f20:	95 e2       	ldi	r25, 0x25	; 37
     f22:	ad b7       	in	r26, 0x3d	; 61
     f24:	be b7       	in	r27, 0x3e	; 62
     f26:	12 96       	adiw	r26, 0x02	; 2
     f28:	9c 93       	st	X, r25
     f2a:	8e 93       	st	-X, r24
     f2c:	11 97       	sbiw	r26, 0x01	; 1
     f2e:	80 91 ad 7b 	lds	r24, 0x7BAD
     f32:	99 27       	eor	r25, r25
     f34:	87 fd       	sbrc	r24, 7
     f36:	90 95       	com	r25
     f38:	14 96       	adiw	r26, 0x04	; 4
     f3a:	9c 93       	st	X, r25
     f3c:	8e 93       	st	-X, r24
     f3e:	13 97       	sbiw	r26, 0x03	; 3
     f40:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				#endif	
				Pose.Gripper_Status=Estado_gripper();
     f44:	0f 90       	pop	r0
     f46:	0f 90       	pop	r0
     f48:	0f 90       	pop	r0
     f4a:	0f 90       	pop	r0
     f4c:	0e 94 cb 76 	call	0xed96	; 0xed96 <Estado_gripper>
     f50:	80 93 ad 7b 	sts	0x7BAD, r24
				//No es posible determinar el estado del gripper por interuptores 
				//suponer con pieza
				if(Pose.Gripper_Status==-1)
     f54:	8f 3f       	cpi	r24, 0xFF	; 255
     f56:	19 f4       	brne	.+6      	; 0xf5e <work_out+0x68a>
				{
					Pose.Gripper_Status=1;
     f58:	81 e0       	ldi	r24, 0x01	; 1
     f5a:	80 93 ad 7b 	sts	0x7BAD, r24
				}
				SobreEscribir_Pose(Pose);
     f5e:	ed b7       	in	r30, 0x3d	; 61
     f60:	fe b7       	in	r31, 0x3e	; 62
     f62:	77 97       	sbiw	r30, 0x17	; 23
     f64:	0f b6       	in	r0, 0x3f	; 63
     f66:	f8 94       	cli
     f68:	fe bf       	out	0x3e, r31	; 62
     f6a:	0f be       	out	0x3f, r0	; 63
     f6c:	ed bf       	out	0x3d, r30	; 61
     f6e:	ad b7       	in	r26, 0x3d	; 61
     f70:	be b7       	in	r27, 0x3e	; 62
     f72:	11 96       	adiw	r26, 0x01	; 1
     f74:	e7 e9       	ldi	r30, 0x97	; 151
     f76:	fb e7       	ldi	r31, 0x7B	; 123
     f78:	87 e1       	ldi	r24, 0x17	; 23
     f7a:	01 90       	ld	r0, Z+
     f7c:	0d 92       	st	X+, r0
     f7e:	81 50       	subi	r24, 0x01	; 1
     f80:	e1 f7       	brne	.-8      	; 0xf7a <work_out+0x6a6>
     f82:	0e 94 20 75 	call	0xea40	; 0xea40 <SobreEscribir_Pose>
     f86:	2d b7       	in	r18, 0x3d	; 61
     f88:	3e b7       	in	r19, 0x3e	; 62
     f8a:	29 5e       	subi	r18, 0xE9	; 233
     f8c:	3f 4f       	sbci	r19, 0xFF	; 255
     f8e:	0f b6       	in	r0, 0x3f	; 63
     f90:	f8 94       	cli
     f92:	3e bf       	out	0x3e, r19	; 62
     f94:	0f be       	out	0x3f, r0	; 63
     f96:	2d bf       	out	0x3d, r18	; 61
				
			}
			/*Lee la Pose y Se mueve el robot*/
			if(rxCommand.CommandOP==CommandGetPoseEEPROM)
     f98:	80 91 ee 81 	lds	r24, 0x81EE
     f9c:	90 91 ef 81 	lds	r25, 0x81EF
     fa0:	07 97       	sbiw	r24, 0x07	; 7
     fa2:	09 f0       	breq	.+2      	; 0xfa6 <work_out+0x6d2>
     fa4:	43 c2       	rjmp	.+1158   	; 0x142c <work_out+0xb58>
			{
                Leer_PoseTWI(rxCommand.Dato,&Pose);
     fa6:	80 91 f2 81 	lds	r24, 0x81F2
     faa:	90 91 f3 81 	lds	r25, 0x81F3
     fae:	67 e9       	ldi	r22, 0x97	; 151
     fb0:	7b e7       	ldi	r23, 0x7B	; 123
     fb2:	0e 94 3c 75 	call	0xea78	; 0xea78 <Leer_PoseTWI>
				#ifdef DEBUGPOSE
				printf("work_out=> Poseleida->Pos_num = %d \n",Pose.id);	
     fb6:	00 d0       	rcall	.+0      	; 0xfb8 <work_out+0x6e4>
     fb8:	00 d0       	rcall	.+0      	; 0xfba <work_out+0x6e6>
     fba:	8c ec       	ldi	r24, 0xCC	; 204
     fbc:	95 e2       	ldi	r25, 0x25	; 37
     fbe:	ad b7       	in	r26, 0x3d	; 61
     fc0:	be b7       	in	r27, 0x3e	; 62
     fc2:	12 96       	adiw	r26, 0x02	; 2
     fc4:	9c 93       	st	X, r25
     fc6:	8e 93       	st	-X, r24
     fc8:	11 97       	sbiw	r26, 0x01	; 1
     fca:	80 91 97 7b 	lds	r24, 0x7B97
     fce:	90 91 98 7b 	lds	r25, 0x7B98
     fd2:	14 96       	adiw	r26, 0x04	; 4
     fd4:	9c 93       	st	X, r25
     fd6:	8e 93       	st	-X, r24
     fd8:	13 97       	sbiw	r26, 0x03	; 3
     fda:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				//cintura
				grados_Pose=uPasosTOgradros(&hAxis[AxisWaist].axisSettings,Pose.Pos_Waist,POSICION_TYPE);
     fde:	0f 90       	pop	r0
     fe0:	0f 90       	pop	r0
     fe2:	0f 90       	pop	r0
     fe4:	0f 90       	pop	r0
     fe6:	40 91 99 7b 	lds	r20, 0x7B99
     fea:	50 91 9a 7b 	lds	r21, 0x7B9A
     fee:	60 91 9b 7b 	lds	r22, 0x7B9B
     ff2:	70 91 9c 7b 	lds	r23, 0x7B9C
     ff6:	88 e7       	ldi	r24, 0x78	; 120
     ff8:	9d e7       	ldi	r25, 0x7D	; 125
     ffa:	20 e0       	ldi	r18, 0x00	; 0
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <uPasosTOgradros>
	            printf("work_out=> Poseleida->Pos_Waist = %ld => %f \n ",Pose.Pos_Waist,grados_Pose);
    1002:	ed b7       	in	r30, 0x3d	; 61
    1004:	fe b7       	in	r31, 0x3e	; 62
    1006:	3a 97       	sbiw	r30, 0x0a	; 10
    1008:	0f b6       	in	r0, 0x3f	; 63
    100a:	f8 94       	cli
    100c:	fe bf       	out	0x3e, r31	; 62
    100e:	0f be       	out	0x3f, r0	; 63
    1010:	ed bf       	out	0x3d, r30	; 61
    1012:	31 96       	adiw	r30, 0x01	; 1
    1014:	21 ef       	ldi	r18, 0xF1	; 241
    1016:	35 e2       	ldi	r19, 0x25	; 37
    1018:	ad b7       	in	r26, 0x3d	; 61
    101a:	be b7       	in	r27, 0x3e	; 62
    101c:	12 96       	adiw	r26, 0x02	; 2
    101e:	3c 93       	st	X, r19
    1020:	2e 93       	st	-X, r18
    1022:	11 97       	sbiw	r26, 0x01	; 1
    1024:	20 91 99 7b 	lds	r18, 0x7B99
    1028:	30 91 9a 7b 	lds	r19, 0x7B9A
    102c:	40 91 9b 7b 	lds	r20, 0x7B9B
    1030:	50 91 9c 7b 	lds	r21, 0x7B9C
    1034:	22 83       	std	Z+2, r18	; 0x02
    1036:	33 83       	std	Z+3, r19	; 0x03
    1038:	44 83       	std	Z+4, r20	; 0x04
    103a:	55 83       	std	Z+5, r21	; 0x05
    103c:	66 83       	std	Z+6, r22	; 0x06
    103e:	77 83       	std	Z+7, r23	; 0x07
    1040:	80 87       	std	Z+8, r24	; 0x08
    1042:	91 87       	std	Z+9, r25	; 0x09
    1044:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				//hombro
				grados_Pose=uPasosTOgradros(&hAxis[AxisShoulder].axisSettings,Pose.Pos_Shoulder,POSICION_TYPE)-140;
    1048:	ed b7       	in	r30, 0x3d	; 61
    104a:	fe b7       	in	r31, 0x3e	; 62
    104c:	3a 96       	adiw	r30, 0x0a	; 10
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	f8 94       	cli
    1052:	fe bf       	out	0x3e, r31	; 62
    1054:	0f be       	out	0x3f, r0	; 63
    1056:	ed bf       	out	0x3d, r30	; 61
    1058:	40 91 9d 7b 	lds	r20, 0x7B9D
    105c:	50 91 9e 7b 	lds	r21, 0x7B9E
    1060:	60 91 9f 7b 	lds	r22, 0x7B9F
    1064:	70 91 a0 7b 	lds	r23, 0x7BA0
    1068:	88 ed       	ldi	r24, 0xD8	; 216
    106a:	9d e7       	ldi	r25, 0x7D	; 125
    106c:	20 e0       	ldi	r18, 0x00	; 0
    106e:	30 e0       	ldi	r19, 0x00	; 0
    1070:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <uPasosTOgradros>
				printf("work_out=> Poseleida->Pos_Shoulder = %ld => %f \n ",Pose.Pos_Shoulder,grados_Pose);		
    1074:	2d b7       	in	r18, 0x3d	; 61
    1076:	3e b7       	in	r19, 0x3e	; 62
    1078:	2a 50       	subi	r18, 0x0A	; 10
    107a:	30 40       	sbci	r19, 0x00	; 0
    107c:	0f b6       	in	r0, 0x3f	; 63
    107e:	f8 94       	cli
    1080:	3e bf       	out	0x3e, r19	; 62
    1082:	0f be       	out	0x3f, r0	; 63
    1084:	2d bf       	out	0x3d, r18	; 61
    1086:	0d b7       	in	r16, 0x3d	; 61
    1088:	1e b7       	in	r17, 0x3e	; 62
    108a:	0f 5f       	subi	r16, 0xFF	; 255
    108c:	1f 4f       	sbci	r17, 0xFF	; 255
    108e:	20 e2       	ldi	r18, 0x20	; 32
    1090:	36 e2       	ldi	r19, 0x26	; 38
    1092:	ad b7       	in	r26, 0x3d	; 61
    1094:	be b7       	in	r27, 0x3e	; 62
    1096:	12 96       	adiw	r26, 0x02	; 2
    1098:	3c 93       	st	X, r19
    109a:	2e 93       	st	-X, r18
    109c:	11 97       	sbiw	r26, 0x01	; 1
    109e:	20 91 9d 7b 	lds	r18, 0x7B9D
    10a2:	30 91 9e 7b 	lds	r19, 0x7B9E
    10a6:	40 91 9f 7b 	lds	r20, 0x7B9F
    10aa:	50 91 a0 7b 	lds	r21, 0x7BA0
    10ae:	f8 01       	movw	r30, r16
    10b0:	22 83       	std	Z+2, r18	; 0x02
    10b2:	33 83       	std	Z+3, r19	; 0x03
    10b4:	44 83       	std	Z+4, r20	; 0x04
    10b6:	55 83       	std	Z+5, r21	; 0x05
    10b8:	20 e0       	ldi	r18, 0x00	; 0
    10ba:	30 e0       	ldi	r19, 0x00	; 0
    10bc:	4c e0       	ldi	r20, 0x0C	; 12
    10be:	53 e4       	ldi	r21, 0x43	; 67
    10c0:	0e 94 00 83 	call	0x10600	; 0x10600 <__subsf3>
    10c4:	d8 01       	movw	r26, r16
    10c6:	16 96       	adiw	r26, 0x06	; 6
    10c8:	6d 93       	st	X+, r22
    10ca:	7d 93       	st	X+, r23
    10cc:	8d 93       	st	X+, r24
    10ce:	9c 93       	st	X, r25
    10d0:	19 97       	sbiw	r26, 0x09	; 9
    10d2:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				//codo
				grados_Pose=uPasosTOgradros(&hAxis[AxisElbow].axisSettings,Pose.Pos_Elbow,POSICION_TYPE)+124;
    10d6:	ed b7       	in	r30, 0x3d	; 61
    10d8:	fe b7       	in	r31, 0x3e	; 62
    10da:	3a 96       	adiw	r30, 0x0a	; 10
    10dc:	0f b6       	in	r0, 0x3f	; 63
    10de:	f8 94       	cli
    10e0:	fe bf       	out	0x3e, r31	; 62
    10e2:	0f be       	out	0x3f, r0	; 63
    10e4:	ed bf       	out	0x3d, r30	; 61
    10e6:	40 91 a1 7b 	lds	r20, 0x7BA1
    10ea:	50 91 a2 7b 	lds	r21, 0x7BA2
    10ee:	60 91 a3 7b 	lds	r22, 0x7BA3
    10f2:	70 91 a4 7b 	lds	r23, 0x7BA4
    10f6:	88 e3       	ldi	r24, 0x38	; 56
    10f8:	9e e7       	ldi	r25, 0x7E	; 126
    10fa:	20 e0       	ldi	r18, 0x00	; 0
    10fc:	30 e0       	ldi	r19, 0x00	; 0
    10fe:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <uPasosTOgradros>
	            printf("work_out=> Poseleida->Pos_Elbow = %ld => %f \n ",Pose.Pos_Elbow,grados_Pose);		
    1102:	2d b7       	in	r18, 0x3d	; 61
    1104:	3e b7       	in	r19, 0x3e	; 62
    1106:	2a 50       	subi	r18, 0x0A	; 10
    1108:	30 40       	sbci	r19, 0x00	; 0
    110a:	0f b6       	in	r0, 0x3f	; 63
    110c:	f8 94       	cli
    110e:	3e bf       	out	0x3e, r19	; 62
    1110:	0f be       	out	0x3f, r0	; 63
    1112:	2d bf       	out	0x3d, r18	; 61
    1114:	0d b7       	in	r16, 0x3d	; 61
    1116:	1e b7       	in	r17, 0x3e	; 62
    1118:	0f 5f       	subi	r16, 0xFF	; 255
    111a:	1f 4f       	sbci	r17, 0xFF	; 255
    111c:	22 e5       	ldi	r18, 0x52	; 82
    111e:	36 e2       	ldi	r19, 0x26	; 38
    1120:	ad b7       	in	r26, 0x3d	; 61
    1122:	be b7       	in	r27, 0x3e	; 62
    1124:	12 96       	adiw	r26, 0x02	; 2
    1126:	3c 93       	st	X, r19
    1128:	2e 93       	st	-X, r18
    112a:	11 97       	sbiw	r26, 0x01	; 1
    112c:	20 91 a1 7b 	lds	r18, 0x7BA1
    1130:	30 91 a2 7b 	lds	r19, 0x7BA2
    1134:	40 91 a3 7b 	lds	r20, 0x7BA3
    1138:	50 91 a4 7b 	lds	r21, 0x7BA4
    113c:	f8 01       	movw	r30, r16
    113e:	22 83       	std	Z+2, r18	; 0x02
    1140:	33 83       	std	Z+3, r19	; 0x03
    1142:	44 83       	std	Z+4, r20	; 0x04
    1144:	55 83       	std	Z+5, r21	; 0x05
    1146:	20 e0       	ldi	r18, 0x00	; 0
    1148:	30 e0       	ldi	r19, 0x00	; 0
    114a:	48 ef       	ldi	r20, 0xF8	; 248
    114c:	52 e4       	ldi	r21, 0x42	; 66
    114e:	0e 94 01 83 	call	0x10602	; 0x10602 <__addsf3>
    1152:	d8 01       	movw	r26, r16
    1154:	16 96       	adiw	r26, 0x06	; 6
    1156:	6d 93       	st	X+, r22
    1158:	7d 93       	st	X+, r23
    115a:	8d 93       	st	X+, r24
    115c:	9c 93       	st	X, r25
    115e:	19 97       	sbiw	r26, 0x09	; 9
    1160:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				//pitch
				grados_Pose=uPasosTOgradros(&hAxis[AxisPitch].axisSettings,Pose.Pos_Pitch,POSICION_TYPE)+170;
    1164:	ed b7       	in	r30, 0x3d	; 61
    1166:	fe b7       	in	r31, 0x3e	; 62
    1168:	3a 96       	adiw	r30, 0x0a	; 10
    116a:	0f b6       	in	r0, 0x3f	; 63
    116c:	f8 94       	cli
    116e:	fe bf       	out	0x3e, r31	; 62
    1170:	0f be       	out	0x3f, r0	; 63
    1172:	ed bf       	out	0x3d, r30	; 61
    1174:	40 91 a5 7b 	lds	r20, 0x7BA5
    1178:	50 91 a6 7b 	lds	r21, 0x7BA6
    117c:	60 91 a7 7b 	lds	r22, 0x7BA7
    1180:	70 91 a8 7b 	lds	r23, 0x7BA8
    1184:	88 e9       	ldi	r24, 0x98	; 152
    1186:	9e e7       	ldi	r25, 0x7E	; 126
    1188:	20 e0       	ldi	r18, 0x00	; 0
    118a:	30 e0       	ldi	r19, 0x00	; 0
    118c:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <uPasosTOgradros>
				printf("work_out=> Poseleida->Pos_Pitch = %ld => %f \n ",Pose.Pos_Pitch,grados_Pose);		
    1190:	2d b7       	in	r18, 0x3d	; 61
    1192:	3e b7       	in	r19, 0x3e	; 62
    1194:	2a 50       	subi	r18, 0x0A	; 10
    1196:	30 40       	sbci	r19, 0x00	; 0
    1198:	0f b6       	in	r0, 0x3f	; 63
    119a:	f8 94       	cli
    119c:	3e bf       	out	0x3e, r19	; 62
    119e:	0f be       	out	0x3f, r0	; 63
    11a0:	2d bf       	out	0x3d, r18	; 61
    11a2:	0d b7       	in	r16, 0x3d	; 61
    11a4:	1e b7       	in	r17, 0x3e	; 62
    11a6:	0f 5f       	subi	r16, 0xFF	; 255
    11a8:	1f 4f       	sbci	r17, 0xFF	; 255
    11aa:	21 e8       	ldi	r18, 0x81	; 129
    11ac:	36 e2       	ldi	r19, 0x26	; 38
    11ae:	ad b7       	in	r26, 0x3d	; 61
    11b0:	be b7       	in	r27, 0x3e	; 62
    11b2:	12 96       	adiw	r26, 0x02	; 2
    11b4:	3c 93       	st	X, r19
    11b6:	2e 93       	st	-X, r18
    11b8:	11 97       	sbiw	r26, 0x01	; 1
    11ba:	20 91 a5 7b 	lds	r18, 0x7BA5
    11be:	30 91 a6 7b 	lds	r19, 0x7BA6
    11c2:	40 91 a7 7b 	lds	r20, 0x7BA7
    11c6:	50 91 a8 7b 	lds	r21, 0x7BA8
    11ca:	f8 01       	movw	r30, r16
    11cc:	22 83       	std	Z+2, r18	; 0x02
    11ce:	33 83       	std	Z+3, r19	; 0x03
    11d0:	44 83       	std	Z+4, r20	; 0x04
    11d2:	55 83       	std	Z+5, r21	; 0x05
    11d4:	20 e0       	ldi	r18, 0x00	; 0
    11d6:	30 e0       	ldi	r19, 0x00	; 0
    11d8:	4a e2       	ldi	r20, 0x2A	; 42
    11da:	53 e4       	ldi	r21, 0x43	; 67
    11dc:	0e 94 01 83 	call	0x10602	; 0x10602 <__addsf3>
    11e0:	d8 01       	movw	r26, r16
    11e2:	16 96       	adiw	r26, 0x06	; 6
    11e4:	6d 93       	st	X+, r22
    11e6:	7d 93       	st	X+, r23
    11e8:	8d 93       	st	X+, r24
    11ea:	9c 93       	st	X, r25
    11ec:	19 97       	sbiw	r26, 0x09	; 9
    11ee:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	            //roll
				grados_Pose=uPasosTOgradros(&hAxis[AxisRoll].axisSettings,Pose.Pos_Roll,POSICION_TYPE);
    11f2:	ed b7       	in	r30, 0x3d	; 61
    11f4:	fe b7       	in	r31, 0x3e	; 62
    11f6:	3a 96       	adiw	r30, 0x0a	; 10
    11f8:	0f b6       	in	r0, 0x3f	; 63
    11fa:	f8 94       	cli
    11fc:	fe bf       	out	0x3e, r31	; 62
    11fe:	0f be       	out	0x3f, r0	; 63
    1200:	ed bf       	out	0x3d, r30	; 61
    1202:	40 91 a9 7b 	lds	r20, 0x7BA9
    1206:	50 91 aa 7b 	lds	r21, 0x7BAA
    120a:	60 91 ab 7b 	lds	r22, 0x7BAB
    120e:	70 91 ac 7b 	lds	r23, 0x7BAC
    1212:	88 ef       	ldi	r24, 0xF8	; 248
    1214:	9e e7       	ldi	r25, 0x7E	; 126
    1216:	20 e0       	ldi	r18, 0x00	; 0
    1218:	30 e0       	ldi	r19, 0x00	; 0
    121a:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <uPasosTOgradros>
				printf("work_out=> Poseleida->Pos_Roll= %ld => %f \n ",Pose.Pos_Roll,grados_Pose);		
    121e:	2d b7       	in	r18, 0x3d	; 61
    1220:	3e b7       	in	r19, 0x3e	; 62
    1222:	2a 50       	subi	r18, 0x0A	; 10
    1224:	30 40       	sbci	r19, 0x00	; 0
    1226:	0f b6       	in	r0, 0x3f	; 63
    1228:	f8 94       	cli
    122a:	3e bf       	out	0x3e, r19	; 62
    122c:	0f be       	out	0x3f, r0	; 63
    122e:	2d bf       	out	0x3d, r18	; 61
    1230:	ed b7       	in	r30, 0x3d	; 61
    1232:	fe b7       	in	r31, 0x3e	; 62
    1234:	31 96       	adiw	r30, 0x01	; 1
    1236:	20 eb       	ldi	r18, 0xB0	; 176
    1238:	36 e2       	ldi	r19, 0x26	; 38
    123a:	ad b7       	in	r26, 0x3d	; 61
    123c:	be b7       	in	r27, 0x3e	; 62
    123e:	12 96       	adiw	r26, 0x02	; 2
    1240:	3c 93       	st	X, r19
    1242:	2e 93       	st	-X, r18
    1244:	11 97       	sbiw	r26, 0x01	; 1
    1246:	20 91 a9 7b 	lds	r18, 0x7BA9
    124a:	30 91 aa 7b 	lds	r19, 0x7BAA
    124e:	40 91 ab 7b 	lds	r20, 0x7BAB
    1252:	50 91 ac 7b 	lds	r21, 0x7BAC
    1256:	22 83       	std	Z+2, r18	; 0x02
    1258:	33 83       	std	Z+3, r19	; 0x03
    125a:	44 83       	std	Z+4, r20	; 0x04
    125c:	55 83       	std	Z+5, r21	; 0x05
    125e:	66 83       	std	Z+6, r22	; 0x06
    1260:	77 83       	std	Z+7, r23	; 0x07
    1262:	80 87       	std	Z+8, r24	; 0x08
    1264:	91 87       	std	Z+9, r25	; 0x09
    1266:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				#endif
				TXPoseActual=Pose.id;
    126a:	80 91 97 7b 	lds	r24, 0x7B97
    126e:	90 91 98 7b 	lds	r25, 0x7B98
    1272:	90 93 93 7b 	sts	0x7B93, r25
    1276:	80 93 92 7b 	sts	0x7B92, r24
				Pose2rxTrayectoria(&Pose);
    127a:	ed b7       	in	r30, 0x3d	; 61
    127c:	fe b7       	in	r31, 0x3e	; 62
    127e:	3a 96       	adiw	r30, 0x0a	; 10
    1280:	0f b6       	in	r0, 0x3f	; 63
    1282:	f8 94       	cli
    1284:	fe bf       	out	0x3e, r31	; 62
    1286:	0f be       	out	0x3f, r0	; 63
    1288:	ed bf       	out	0x3d, r30	; 61
    128a:	87 e9       	ldi	r24, 0x97	; 151
    128c:	9b e7       	ldi	r25, 0x7B	; 123
    128e:	0e 94 da 72 	call	0xe5b4	; 0xe5b4 <Pose2rxTrayectoria>
    1292:	cc 24       	eor	r12, r12
    1294:	dd 24       	eor	r13, r13
				#ifdef DEBUGPUNTO
				for(eje=0; eje<DOF; eje++)
				{
					printf("work_out=>  El eje es  %s y su pos es %ld \n" ,AxisName((tReturnCode)eje),Trajectoryvectorpunto.point[0].axis[eje].position);
    1296:	2d ed       	ldi	r18, 0xDD	; 221
    1298:	82 2e       	mov	r8, r18
    129a:	26 e2       	ldi	r18, 0x26	; 38
    129c:	92 2e       	mov	r9, r18
					printf("work_out=>  vel  %ld  y su ac  %ld \n" ,Trajectoryvectorpunto.point[0].axis[eje].velocity,Trajectoryvectorpunto.point[0].axis[eje].acceleration);
    129e:	99 e0       	ldi	r25, 0x09	; 9
    12a0:	a9 2e       	mov	r10, r25
    12a2:	97 e2       	ldi	r25, 0x27	; 39
    12a4:	b9 2e       	mov	r11, r25
				TXPoseActual=Pose.id;
				Pose2rxTrayectoria(&Pose);
				#ifdef DEBUGPUNTO
				for(eje=0; eje<DOF; eje++)
				{
					printf("work_out=>  El eje es  %s y su pos es %ld \n" ,AxisName((tReturnCode)eje),Trajectoryvectorpunto.point[0].axis[eje].position);
    12a6:	c6 01       	movw	r24, r12
    12a8:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    12ac:	2d b7       	in	r18, 0x3d	; 61
    12ae:	3e b7       	in	r19, 0x3e	; 62
    12b0:	28 50       	subi	r18, 0x08	; 8
    12b2:	30 40       	sbci	r19, 0x00	; 0
    12b4:	0f b6       	in	r0, 0x3f	; 63
    12b6:	f8 94       	cli
    12b8:	3e bf       	out	0x3e, r19	; 62
    12ba:	0f be       	out	0x3f, r0	; 63
    12bc:	2d bf       	out	0x3d, r18	; 61
    12be:	2f 5f       	subi	r18, 0xFF	; 255
    12c0:	3f 4f       	sbci	r19, 0xFF	; 255
    12c2:	ad b7       	in	r26, 0x3d	; 61
    12c4:	be b7       	in	r27, 0x3e	; 62
    12c6:	12 96       	adiw	r26, 0x02	; 2
    12c8:	9c 92       	st	X, r9
    12ca:	8e 92       	st	-X, r8
    12cc:	11 97       	sbiw	r26, 0x01	; 1
    12ce:	f9 01       	movw	r30, r18
    12d0:	93 83       	std	Z+3, r25	; 0x03
    12d2:	82 83       	std	Z+2, r24	; 0x02
    12d4:	e0 91 21 82 	lds	r30, 0x8221
    12d8:	f0 91 22 82 	lds	r31, 0x8222
    12dc:	86 01       	movw	r16, r12
    12de:	00 0f       	add	r16, r16
    12e0:	11 1f       	adc	r17, r17
    12e2:	0c 0d       	add	r16, r12
    12e4:	1d 1d       	adc	r17, r13
    12e6:	78 01       	movw	r14, r16
    12e8:	ee 0c       	add	r14, r14
    12ea:	ff 1c       	adc	r15, r15
    12ec:	ee 0c       	add	r14, r14
    12ee:	ff 1c       	adc	r15, r15
    12f0:	ee 0d       	add	r30, r14
    12f2:	ff 1d       	adc	r31, r15
    12f4:	80 81       	ld	r24, Z
    12f6:	91 81       	ldd	r25, Z+1	; 0x01
    12f8:	a2 81       	ldd	r26, Z+2	; 0x02
    12fa:	b3 81       	ldd	r27, Z+3	; 0x03
    12fc:	f9 01       	movw	r30, r18
    12fe:	84 83       	std	Z+4, r24	; 0x04
    1300:	95 83       	std	Z+5, r25	; 0x05
    1302:	a6 83       	std	Z+6, r26	; 0x06
    1304:	b7 83       	std	Z+7, r27	; 0x07
    1306:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
					printf("work_out=>  vel  %ld  y su ac  %ld \n" ,Trajectoryvectorpunto.point[0].axis[eje].velocity,Trajectoryvectorpunto.point[0].axis[eje].acceleration);
    130a:	e0 91 21 82 	lds	r30, 0x8221
    130e:	f0 91 22 82 	lds	r31, 0x8222
    1312:	00 d0       	rcall	.+0      	; 0x1314 <work_out+0xa40>
    1314:	2d b7       	in	r18, 0x3d	; 61
    1316:	3e b7       	in	r19, 0x3e	; 62
    1318:	2f 5f       	subi	r18, 0xFF	; 255
    131a:	3f 4f       	sbci	r19, 0xFF	; 255
    131c:	ad b7       	in	r26, 0x3d	; 61
    131e:	be b7       	in	r27, 0x3e	; 62
    1320:	12 96       	adiw	r26, 0x02	; 2
    1322:	bc 92       	st	X, r11
    1324:	ae 92       	st	-X, r10
    1326:	11 97       	sbiw	r26, 0x01	; 1
    1328:	0f 5f       	subi	r16, 0xFF	; 255
    132a:	1f 4f       	sbci	r17, 0xFF	; 255
    132c:	00 0f       	add	r16, r16
    132e:	11 1f       	adc	r17, r17
    1330:	00 0f       	add	r16, r16
    1332:	11 1f       	adc	r17, r17
    1334:	0e 0f       	add	r16, r30
    1336:	1f 1f       	adc	r17, r31
    1338:	d8 01       	movw	r26, r16
    133a:	4d 91       	ld	r20, X+
    133c:	5d 91       	ld	r21, X+
    133e:	6d 91       	ld	r22, X+
    1340:	7c 91       	ld	r23, X
    1342:	d9 01       	movw	r26, r18
    1344:	12 96       	adiw	r26, 0x02	; 2
    1346:	4d 93       	st	X+, r20
    1348:	5d 93       	st	X+, r21
    134a:	6d 93       	st	X+, r22
    134c:	7c 93       	st	X, r23
    134e:	15 97       	sbiw	r26, 0x05	; 5
    1350:	ee 0d       	add	r30, r14
    1352:	ff 1d       	adc	r31, r15
    1354:	80 85       	ldd	r24, Z+8	; 0x08
    1356:	91 85       	ldd	r25, Z+9	; 0x09
    1358:	a2 85       	ldd	r26, Z+10	; 0x0a
    135a:	b3 85       	ldd	r27, Z+11	; 0x0b
    135c:	f9 01       	movw	r30, r18
    135e:	86 83       	std	Z+6, r24	; 0x06
    1360:	97 83       	std	Z+7, r25	; 0x07
    1362:	a0 87       	std	Z+8, r26	; 0x08
    1364:	b1 87       	std	Z+9, r27	; 0x09
    1366:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				printf("work_out=> Poseleida->Pos_Roll= %ld => %f \n ",Pose.Pos_Roll,grados_Pose);		
				#endif
				TXPoseActual=Pose.id;
				Pose2rxTrayectoria(&Pose);
				#ifdef DEBUGPUNTO
				for(eje=0; eje<DOF; eje++)
    136a:	08 94       	sec
    136c:	c1 1c       	adc	r12, r1
    136e:	d1 1c       	adc	r13, r1
    1370:	2d b7       	in	r18, 0x3d	; 61
    1372:	3e b7       	in	r19, 0x3e	; 62
    1374:	26 5f       	subi	r18, 0xF6	; 246
    1376:	3f 4f       	sbci	r19, 0xFF	; 255
    1378:	0f b6       	in	r0, 0x3f	; 63
    137a:	f8 94       	cli
    137c:	3e bf       	out	0x3e, r19	; 62
    137e:	0f be       	out	0x3f, r0	; 63
    1380:	2d bf       	out	0x3d, r18	; 61
    1382:	35 e0       	ldi	r19, 0x05	; 5
    1384:	c3 16       	cp	r12, r19
    1386:	d1 04       	cpc	r13, r1
    1388:	09 f0       	breq	.+2      	; 0x138c <work_out+0xab8>
    138a:	8d cf       	rjmp	.-230    	; 0x12a6 <work_out+0x9d2>
				{
					printf("work_out=>  El eje es  %s y su pos es %ld \n" ,AxisName((tReturnCode)eje),Trajectoryvectorpunto.point[0].axis[eje].position);
					printf("work_out=>  vel  %ld  y su ac  %ld \n" ,Trajectoryvectorpunto.point[0].axis[eje].velocity,Trajectoryvectorpunto.point[0].axis[eje].acceleration);
				}
				printf("work_out=> Invalida Mask= %X \n", Trajectoryvectorpunto.invalidmask);
    138c:	00 d0       	rcall	.+0      	; 0x138e <work_out+0xaba>
    138e:	00 d0       	rcall	.+0      	; 0x1390 <work_out+0xabc>
    1390:	8e e2       	ldi	r24, 0x2E	; 46
    1392:	97 e2       	ldi	r25, 0x27	; 39
    1394:	ad b7       	in	r26, 0x3d	; 61
    1396:	be b7       	in	r27, 0x3e	; 62
    1398:	12 96       	adiw	r26, 0x02	; 2
    139a:	9c 93       	st	X, r25
    139c:	8e 93       	st	-X, r24
    139e:	11 97       	sbiw	r26, 0x01	; 1
    13a0:	80 91 1f 82 	lds	r24, 0x821F
    13a4:	90 91 20 82 	lds	r25, 0x8220
    13a8:	14 96       	adiw	r26, 0x04	; 4
    13aa:	9c 93       	st	X, r25
    13ac:	8e 93       	st	-X, r24
    13ae:	13 97       	sbiw	r26, 0x03	; 3
    13b0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				printf("work_out=> Tamano %X \n", Trajectoryvectorpunto.size);
    13b4:	8d e4       	ldi	r24, 0x4D	; 77
    13b6:	97 e2       	ldi	r25, 0x27	; 39
    13b8:	ed b7       	in	r30, 0x3d	; 61
    13ba:	fe b7       	in	r31, 0x3e	; 62
    13bc:	92 83       	std	Z+2, r25	; 0x02
    13be:	81 83       	std	Z+1, r24	; 0x01
    13c0:	80 91 1d 82 	lds	r24, 0x821D
    13c4:	90 91 1e 82 	lds	r25, 0x821E
    13c8:	94 83       	std	Z+4, r25	; 0x04
    13ca:	83 83       	std	Z+3, r24	; 0x03
    13cc:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				#endif
				teach_pendant_point(&Trajectoryvectorpunto,0);
    13d0:	0f 90       	pop	r0
    13d2:	0f 90       	pop	r0
    13d4:	0f 90       	pop	r0
    13d6:	0f 90       	pop	r0
    13d8:	8d e1       	ldi	r24, 0x1D	; 29
    13da:	92 e8       	ldi	r25, 0x82	; 130
    13dc:	60 e0       	ldi	r22, 0x00	; 0
    13de:	70 e0       	ldi	r23, 0x00	; 0
    13e0:	0e 94 7f 51 	call	0xa2fe	; 0xa2fe <teach_pendant_point>
				//Nuevo gripper
				if(Pose.Gripper_Status==1)
    13e4:	80 91 ad 7b 	lds	r24, 0x7BAD
    13e8:	81 30       	cpi	r24, 0x01	; 1
    13ea:	91 f4       	brne	.+36     	; 0x1410 <work_out+0xb3c>
				{
					if(GripperActual!=1)
    13ec:	80 91 94 7b 	lds	r24, 0x7B94
    13f0:	90 91 95 7b 	lds	r25, 0x7B95
    13f4:	01 97       	sbiw	r24, 0x01	; 1
    13f6:	41 f0       	breq	.+16     	; 0x1408 <work_out+0xb34>
					{
						closeGripper();
    13f8:	0e 94 9a 76 	call	0xed34	; 0xed34 <closeGripper>
						GripperActual=1;
    13fc:	81 e0       	ldi	r24, 0x01	; 1
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	90 93 95 7b 	sts	0x7B95, r25
    1404:	80 93 94 7b 	sts	0x7B94, r24
					}
					
					//#ifdef DEBUGPOSE
					printf("work_out=> Pose con gripper cerrado\n");	
    1408:	84 e6       	ldi	r24, 0x64	; 100
    140a:	97 e2       	ldi	r25, 0x27	; 39
    140c:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
					//#endif
				}
				if(Pose.Gripper_Status==0)
    1410:	80 91 ad 7b 	lds	r24, 0x7BAD
    1414:	88 23       	and	r24, r24
    1416:	51 f4       	brne	.+20     	; 0x142c <work_out+0xb58>
				{
					openGripper();
    1418:	0e 94 69 76 	call	0xecd2	; 0xecd2 <openGripper>
					GripperActual=0;
    141c:	10 92 95 7b 	sts	0x7B95, r1
    1420:	10 92 94 7b 	sts	0x7B94, r1
					//#ifdef DEBUGPOSE
					printf("work_out=> Pose con gripper abierto\n");	
    1424:	88 e8       	ldi	r24, 0x88	; 136
    1426:	97 e2       	ldi	r25, 0x27	; 39
    1428:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
					//#endif
				}
			}
			if(rxCommand.CommandOP==CommandEraseEEPROM)
    142c:	80 91 ee 81 	lds	r24, 0x81EE
    1430:	90 91 ef 81 	lds	r25, 0x81EF
    1434:	09 97       	sbiw	r24, 0x09	; 9
    1436:	41 f4       	brne	.+16     	; 0x1448 <work_out+0xb74>
			{
			    printf("work_out=> Borrando memoria eeprom   \n");	
    1438:	8c ea       	ldi	r24, 0xAC	; 172
    143a:	97 e2       	ldi	r25, 0x27	; 39
    143c:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				BorrarEEPROM();
    1440:	0e 94 a5 73 	call	0xe74a	; 0xe74a <BorrarEEPROM>
				return_id_vector(); //Actualizo el vector
    1444:	0e 94 31 74 	call	0xe862	; 0xe862 <return_id_vector>
			}
			if(rxCommand.CommandOP==CommandGetPosesID)
    1448:	80 91 ee 81 	lds	r24, 0x81EE
    144c:	90 91 ef 81 	lds	r25, 0x81EF
    1450:	0a 97       	sbiw	r24, 0x0a	; 10
    1452:	11 f4       	brne	.+4      	; 0x1458 <work_out+0xb84>
			{				
				return_id_vector();
    1454:	0e 94 31 74 	call	0xe862	; 0xe862 <return_id_vector>
				printf("work_out=> En el proximo IN mando la poses actual, Poseactual = %d\n",TXPoseActual);	
				#endif	
				
				
			}	
			if(rxCommand.CommandOP==CommandGetFecha)
    1458:	80 91 ee 81 	lds	r24, 0x81EE
    145c:	90 91 ef 81 	lds	r25, 0x81EF
    1460:	0d 97       	sbiw	r24, 0x0d	; 13
    1462:	09 f0       	breq	.+2      	; 0x1466 <work_out+0xb92>
    1464:	74 c0       	rjmp	.+232    	; 0x154e <work_out+0xc7a>
			{
				#ifdef DEBUGFECHA
			    printf("work_out=> Obtenido Fecha en el uC\n");
				#endif
                Read_Fecha(&txFecha);
    1466:	8b eb       	ldi	r24, 0xBB	; 187
    1468:	90 e8       	ldi	r25, 0x80	; 128
    146a:	0e 94 e6 71 	call	0xe3cc	; 0xe3cc <Read_Fecha>
				printf("work_out=> txFecha.mo %x\n",txFecha.mo);
				printf("work_out=> txFecha.yr %x\n",txFecha.yr);
				printf("work_out=> txFecha.dw %x\n",txFecha.dw);
				printf("work_out=> txFecha.y2k %x\n",rxFecha.y2k);
				#endif
				printf("work_out=> Fecha = Hoy es el dia %s %x de %s de 200%x. \n",Dayname(txFecha.dw),txFecha.dt,Monthname(txFecha.mo),txFecha.yr);						
    146e:	80 91 c1 80 	lds	r24, 0x80C1
    1472:	0e 94 ba 24 	call	0x4974	; 0x4974 <Dayname>
    1476:	8c 01       	movw	r16, r24
    1478:	f0 90 be 80 	lds	r15, 0x80BE
    147c:	80 91 bf 80 	lds	r24, 0x80BF
    1480:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <Monthname>
    1484:	2d b7       	in	r18, 0x3d	; 61
    1486:	3e b7       	in	r19, 0x3e	; 62
    1488:	2a 50       	subi	r18, 0x0A	; 10
    148a:	30 40       	sbci	r19, 0x00	; 0
    148c:	0f b6       	in	r0, 0x3f	; 63
    148e:	f8 94       	cli
    1490:	3e bf       	out	0x3e, r19	; 62
    1492:	0f be       	out	0x3f, r0	; 63
    1494:	2d bf       	out	0x3d, r18	; 61
    1496:	ed b7       	in	r30, 0x3d	; 61
    1498:	fe b7       	in	r31, 0x3e	; 62
    149a:	31 96       	adiw	r30, 0x01	; 1
    149c:	22 ed       	ldi	r18, 0xD2	; 210
    149e:	37 e2       	ldi	r19, 0x27	; 39
    14a0:	ad b7       	in	r26, 0x3d	; 61
    14a2:	be b7       	in	r27, 0x3e	; 62
    14a4:	12 96       	adiw	r26, 0x02	; 2
    14a6:	3c 93       	st	X, r19
    14a8:	2e 93       	st	-X, r18
    14aa:	11 97       	sbiw	r26, 0x01	; 1
    14ac:	13 83       	std	Z+3, r17	; 0x03
    14ae:	02 83       	std	Z+2, r16	; 0x02
    14b0:	f4 82       	std	Z+4, r15	; 0x04
    14b2:	15 82       	std	Z+5, r1	; 0x05
    14b4:	97 83       	std	Z+7, r25	; 0x07
    14b6:	86 83       	std	Z+6, r24	; 0x06
    14b8:	80 91 c0 80 	lds	r24, 0x80C0
    14bc:	80 87       	std	Z+8, r24	; 0x08
    14be:	11 86       	std	Z+9, r1	; 0x09
    14c0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				if((txFecha.hr & 0x20) != 0)			
    14c4:	80 91 bd 80 	lds	r24, 0x80BD
    14c8:	90 e0       	ldi	r25, 0x00	; 0
    14ca:	ed b7       	in	r30, 0x3d	; 61
    14cc:	fe b7       	in	r31, 0x3e	; 62
    14ce:	3a 96       	adiw	r30, 0x0a	; 10
    14d0:	0f b6       	in	r0, 0x3f	; 63
    14d2:	f8 94       	cli
    14d4:	fe bf       	out	0x3e, r31	; 62
    14d6:	0f be       	out	0x3f, r0	; 63
    14d8:	ed bf       	out	0x3d, r30	; 61
    14da:	9c 01       	movw	r18, r24
    14dc:	2f 71       	andi	r18, 0x1F	; 31
    14de:	30 70       	andi	r19, 0x00	; 0
    14e0:	85 ff       	sbrs	r24, 5
    14e2:	0e c0       	rjmp	.+28     	; 0x1500 <work_out+0xc2c>
				    printf("work_out=> Son las %x:%x:%x PM \n",(txFecha.hr & 0x1F),txFecha.mn,txFecha.sc);
    14e4:	8d b7       	in	r24, 0x3d	; 61
    14e6:	9e b7       	in	r25, 0x3e	; 62
    14e8:	08 97       	sbiw	r24, 0x08	; 8
    14ea:	0f b6       	in	r0, 0x3f	; 63
    14ec:	f8 94       	cli
    14ee:	9e bf       	out	0x3e, r25	; 62
    14f0:	0f be       	out	0x3f, r0	; 63
    14f2:	8d bf       	out	0x3d, r24	; 61
    14f4:	ed b7       	in	r30, 0x3d	; 61
    14f6:	fe b7       	in	r31, 0x3e	; 62
    14f8:	31 96       	adiw	r30, 0x01	; 1
    14fa:	8b e0       	ldi	r24, 0x0B	; 11
    14fc:	98 e2       	ldi	r25, 0x28	; 40
    14fe:	0d c0       	rjmp	.+26     	; 0x151a <work_out+0xc46>
				else 
					printf("work_out=> Son las %x:%x:%x AM \n",(txFecha.hr & 0x1F),txFecha.mn,txFecha.sc);
    1500:	8d b7       	in	r24, 0x3d	; 61
    1502:	9e b7       	in	r25, 0x3e	; 62
    1504:	08 97       	sbiw	r24, 0x08	; 8
    1506:	0f b6       	in	r0, 0x3f	; 63
    1508:	f8 94       	cli
    150a:	9e bf       	out	0x3e, r25	; 62
    150c:	0f be       	out	0x3f, r0	; 63
    150e:	8d bf       	out	0x3d, r24	; 61
    1510:	ed b7       	in	r30, 0x3d	; 61
    1512:	fe b7       	in	r31, 0x3e	; 62
    1514:	31 96       	adiw	r30, 0x01	; 1
    1516:	8c e2       	ldi	r24, 0x2C	; 44
    1518:	98 e2       	ldi	r25, 0x28	; 40
    151a:	ad b7       	in	r26, 0x3d	; 61
    151c:	be b7       	in	r27, 0x3e	; 62
    151e:	12 96       	adiw	r26, 0x02	; 2
    1520:	9c 93       	st	X, r25
    1522:	8e 93       	st	-X, r24
    1524:	11 97       	sbiw	r26, 0x01	; 1
    1526:	33 83       	std	Z+3, r19	; 0x03
    1528:	22 83       	std	Z+2, r18	; 0x02
    152a:	80 91 bc 80 	lds	r24, 0x80BC
    152e:	84 83       	std	Z+4, r24	; 0x04
    1530:	15 82       	std	Z+5, r1	; 0x05
    1532:	80 91 bb 80 	lds	r24, 0x80BB
    1536:	86 83       	std	Z+6, r24	; 0x06
    1538:	17 82       	std	Z+7, r1	; 0x07
    153a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    153e:	ed b7       	in	r30, 0x3d	; 61
    1540:	fe b7       	in	r31, 0x3e	; 62
    1542:	38 96       	adiw	r30, 0x08	; 8
    1544:	0f b6       	in	r0, 0x3f	; 63
    1546:	f8 94       	cli
    1548:	fe bf       	out	0x3e, r31	; 62
    154a:	0f be       	out	0x3f, r0	; 63
    154c:	ed bf       	out	0x3d, r30	; 61
				#ifdef DEBUGUSB
				printf("work_out=> En el proximo IN mando esta Fecha hacia el PC\n");
				#endif		
			    
			}
			if(rxCommand.CommandOP==CommandGetAxisSettings)
    154e:	80 91 ee 81 	lds	r24, 0x81EE
    1552:	90 91 ef 81 	lds	r25, 0x81EF
    1556:	02 97       	sbiw	r24, 0x02	; 2
    1558:	41 f4       	brne	.+16     	; 0x156a <work_out+0xc96>
			{
			    printf("work_out=> Obteniendo configuracion del robot\n");
    155a:	8d e4       	ldi	r24, 0x4D	; 77
    155c:	98 e2       	ldi	r25, 0x28	; 40
    155e:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				GetAxissetting((uint8*)TxAxisSettings);
    1562:	84 e1       	ldi	r24, 0x14	; 20
    1564:	9c e7       	ldi	r25, 0x7C	; 124
    1566:	0e 94 1d 27 	call	0x4e3a	; 0x4e3a <GetAxissetting>
				#ifdef DEBUGUSB
				printf("work_out=> En el proximo IN mando la configuracion del robot hacia el PC\n");
				#endif						
			}
			if(rxCommand.CommandOP==CommandSetPMDTrace)
    156a:	80 91 ee 81 	lds	r24, 0x81EE
    156e:	90 91 ef 81 	lds	r25, 0x81EF
    1572:	0b 97       	sbiw	r24, 0x0b	; 11
    1574:	09 f0       	breq	.+2      	; 0x1578 <work_out+0xca4>
    1576:	a0 c0       	rjmp	.+320    	; 0x16b8 <work_out+0xde4>
			{
				/*rxCommand.Dato tiene la cantidad de variables a trazar*/
				/*Num_Variables_Trazar Sera igual a rxCommand.Dato si cumple con la restricciones*/
				/*Obtenemos la cantidad de puntos configurados*/
			    printf("work_out=> Configuracion el trazado del robot en los ejes: %d, %d, %d, %d, %d, %d, %d, %d\n",
    1578:	2d b7       	in	r18, 0x3d	; 61
    157a:	3e b7       	in	r19, 0x3e	; 62
    157c:	22 51       	subi	r18, 0x12	; 18
    157e:	30 40       	sbci	r19, 0x00	; 0
    1580:	0f b6       	in	r0, 0x3f	; 63
    1582:	f8 94       	cli
    1584:	3e bf       	out	0x3e, r19	; 62
    1586:	0f be       	out	0x3f, r0	; 63
    1588:	2d bf       	out	0x3d, r18	; 61
    158a:	ed b7       	in	r30, 0x3d	; 61
    158c:	fe b7       	in	r31, 0x3e	; 62
    158e:	31 96       	adiw	r30, 0x01	; 1
    1590:	8b e7       	ldi	r24, 0x7B	; 123
    1592:	98 e2       	ldi	r25, 0x28	; 40
    1594:	ad b7       	in	r26, 0x3d	; 61
    1596:	be b7       	in	r27, 0x3e	; 62
    1598:	12 96       	adiw	r26, 0x02	; 2
    159a:	9c 93       	st	X, r25
    159c:	8e 93       	st	-X, r24
    159e:	11 97       	sbiw	r26, 0x01	; 1
    15a0:	80 91 f9 81 	lds	r24, 0x81F9
    15a4:	99 27       	eor	r25, r25
    15a6:	87 fd       	sbrc	r24, 7
    15a8:	90 95       	com	r25
    15aa:	93 83       	std	Z+3, r25	; 0x03
    15ac:	82 83       	std	Z+2, r24	; 0x02
    15ae:	80 91 fb 81 	lds	r24, 0x81FB
    15b2:	99 27       	eor	r25, r25
    15b4:	87 fd       	sbrc	r24, 7
    15b6:	90 95       	com	r25
    15b8:	95 83       	std	Z+5, r25	; 0x05
    15ba:	84 83       	std	Z+4, r24	; 0x04
    15bc:	80 91 fd 81 	lds	r24, 0x81FD
    15c0:	99 27       	eor	r25, r25
    15c2:	87 fd       	sbrc	r24, 7
    15c4:	90 95       	com	r25
    15c6:	97 83       	std	Z+7, r25	; 0x07
    15c8:	86 83       	std	Z+6, r24	; 0x06
    15ca:	80 91 ff 81 	lds	r24, 0x81FF
    15ce:	99 27       	eor	r25, r25
    15d0:	87 fd       	sbrc	r24, 7
    15d2:	90 95       	com	r25
    15d4:	91 87       	std	Z+9, r25	; 0x09
    15d6:	80 87       	std	Z+8, r24	; 0x08
    15d8:	80 91 01 82 	lds	r24, 0x8201
    15dc:	99 27       	eor	r25, r25
    15de:	87 fd       	sbrc	r24, 7
    15e0:	90 95       	com	r25
    15e2:	93 87       	std	Z+11, r25	; 0x0b
    15e4:	82 87       	std	Z+10, r24	; 0x0a
    15e6:	80 91 03 82 	lds	r24, 0x8203
    15ea:	99 27       	eor	r25, r25
    15ec:	87 fd       	sbrc	r24, 7
    15ee:	90 95       	com	r25
    15f0:	95 87       	std	Z+13, r25	; 0x0d
    15f2:	84 87       	std	Z+12, r24	; 0x0c
    15f4:	80 91 05 82 	lds	r24, 0x8205
    15f8:	99 27       	eor	r25, r25
    15fa:	87 fd       	sbrc	r24, 7
    15fc:	90 95       	com	r25
    15fe:	97 87       	std	Z+15, r25	; 0x0f
    1600:	86 87       	std	Z+14, r24	; 0x0e
    1602:	80 91 07 82 	lds	r24, 0x8207
    1606:	99 27       	eor	r25, r25
    1608:	87 fd       	sbrc	r24, 7
    160a:	90 95       	com	r25
    160c:	91 8b       	std	Z+17, r25	; 0x11
    160e:	80 8b       	std	Z+16, r24	; 0x10
    1610:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				rxCommand.Tracecomand[0].AxisTrace,rxCommand.Tracecomand[1].AxisTrace,
				rxCommand.Tracecomand[2].AxisTrace,rxCommand.Tracecomand[3].AxisTrace,				
				rxCommand.Tracecomand[4].AxisTrace,rxCommand.Tracecomand[5].AxisTrace,			
				rxCommand.Tracecomand[6].AxisTrace,rxCommand.Tracecomand[7].AxisTrace);					
				Num_Variables_Trazar=rxCommand.Dato;
    1614:	80 91 f2 81 	lds	r24, 0x81F2
    1618:	80 93 96 7b 	sts	0x7B96, r24
				SetupAxisTrace(rxCommand);
    161c:	ed b7       	in	r30, 0x3d	; 61
    161e:	fe b7       	in	r31, 0x3e	; 62
    1620:	39 97       	sbiw	r30, 0x09	; 9
    1622:	0f b6       	in	r0, 0x3f	; 63
    1624:	f8 94       	cli
    1626:	fe bf       	out	0x3e, r31	; 62
    1628:	0f be       	out	0x3f, r0	; 63
    162a:	ed bf       	out	0x3d, r30	; 61
    162c:	ad b7       	in	r26, 0x3d	; 61
    162e:	be b7       	in	r27, 0x3e	; 62
    1630:	11 96       	adiw	r26, 0x01	; 1
    1632:	ee ee       	ldi	r30, 0xEE	; 238
    1634:	f1 e8       	ldi	r31, 0x81	; 129
    1636:	8b e1       	ldi	r24, 0x1B	; 27
    1638:	01 90       	ld	r0, Z+
    163a:	0d 92       	st	X+, r0
    163c:	81 50       	subi	r24, 0x01	; 1
    163e:	e1 f7       	brne	.-8      	; 0x1638 <work_out+0xd64>
    1640:	0e 94 68 32 	call	0x64d0	; 0x64d0 <SetupAxisTrace>
				//Bandera si se desea realizar el trazado sobre una trayectoria.
				TRACETrajFlag=rxCommand.TraceTraj;
    1644:	80 91 f8 81 	lds	r24, 0x81F8
    1648:	99 27       	eor	r25, r25
    164a:	87 fd       	sbrc	r24, 7
    164c:	90 95       	com	r25
    164e:	90 93 ba 80 	sts	0x80BA, r25
    1652:	80 93 b9 80 	sts	0x80B9, r24
				GetBufferFlag=1;
    1656:	81 e0       	ldi	r24, 0x01	; 1
    1658:	80 93 ac 80 	sts	0x80AC, r24
				printf("work_out=> Despues de configurar Num_Variables_Trazar = %d\n",Num_Variables_Trazar);
    165c:	2d b7       	in	r18, 0x3d	; 61
    165e:	3e b7       	in	r19, 0x3e	; 62
    1660:	29 5e       	subi	r18, 0xE9	; 233
    1662:	3f 4f       	sbci	r19, 0xFF	; 255
    1664:	0f b6       	in	r0, 0x3f	; 63
    1666:	f8 94       	cli
    1668:	3e bf       	out	0x3e, r19	; 62
    166a:	0f be       	out	0x3f, r0	; 63
    166c:	2d bf       	out	0x3d, r18	; 61
    166e:	86 ed       	ldi	r24, 0xD6	; 214
    1670:	98 e2       	ldi	r25, 0x28	; 40
    1672:	ad b7       	in	r26, 0x3d	; 61
    1674:	be b7       	in	r27, 0x3e	; 62
    1676:	12 96       	adiw	r26, 0x02	; 2
    1678:	9c 93       	st	X, r25
    167a:	8e 93       	st	-X, r24
    167c:	11 97       	sbiw	r26, 0x01	; 1
    167e:	80 91 96 7b 	lds	r24, 0x7B96
    1682:	99 27       	eor	r25, r25
    1684:	87 fd       	sbrc	r24, 7
    1686:	90 95       	com	r25
    1688:	14 96       	adiw	r26, 0x04	; 4
    168a:	9c 93       	st	X, r25
    168c:	8e 93       	st	-X, r24
    168e:	13 97       	sbiw	r26, 0x03	; 3
    1690:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				printf("work_out=> Deseo Trazar Una Trajectoria = %d\n",TRACETrajFlag);
    1694:	82 e1       	ldi	r24, 0x12	; 18
    1696:	99 e2       	ldi	r25, 0x29	; 41
    1698:	ed b7       	in	r30, 0x3d	; 61
    169a:	fe b7       	in	r31, 0x3e	; 62
    169c:	92 83       	std	Z+2, r25	; 0x02
    169e:	81 83       	std	Z+1, r24	; 0x01
    16a0:	80 91 b9 80 	lds	r24, 0x80B9
    16a4:	90 91 ba 80 	lds	r25, 0x80BA
    16a8:	94 83       	std	Z+4, r25	; 0x04
    16aa:	83 83       	std	Z+3, r24	; 0x03
    16ac:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    16b0:	0f 90       	pop	r0
    16b2:	0f 90       	pop	r0
    16b4:	0f 90       	pop	r0
    16b6:	0f 90       	pop	r0
				
			}
			if(rxCommand.CommandOP==CommandGetPMDTrace)
    16b8:	80 91 ee 81 	lds	r24, 0x81EE
    16bc:	90 91 ef 81 	lds	r25, 0x81EF
    16c0:	0c 97       	sbiw	r24, 0x0c	; 12
    16c2:	21 f5       	brne	.+72     	; 0x170c <work_out+0xe38>
			{   
			    printf("work_out=> Numero Variables a Trazar = %ld\n",rxCommand.Dato);
    16c4:	00 d0       	rcall	.+0      	; 0x16c6 <work_out+0xdf2>
    16c6:	00 d0       	rcall	.+0      	; 0x16c8 <work_out+0xdf4>
    16c8:	00 d0       	rcall	.+0      	; 0x16ca <work_out+0xdf6>
    16ca:	80 e4       	ldi	r24, 0x40	; 64
    16cc:	99 e2       	ldi	r25, 0x29	; 41
    16ce:	ad b7       	in	r26, 0x3d	; 61
    16d0:	be b7       	in	r27, 0x3e	; 62
    16d2:	12 96       	adiw	r26, 0x02	; 2
    16d4:	9c 93       	st	X, r25
    16d6:	8e 93       	st	-X, r24
    16d8:	11 97       	sbiw	r26, 0x01	; 1
    16da:	80 91 f2 81 	lds	r24, 0x81F2
    16de:	90 91 f3 81 	lds	r25, 0x81F3
    16e2:	a0 91 f4 81 	lds	r26, 0x81F4
    16e6:	b0 91 f5 81 	lds	r27, 0x81F5
    16ea:	ed b7       	in	r30, 0x3d	; 61
    16ec:	fe b7       	in	r31, 0x3e	; 62
    16ee:	83 83       	std	Z+3, r24	; 0x03
    16f0:	94 83       	std	Z+4, r25	; 0x04
    16f2:	a5 83       	std	Z+5, r26	; 0x05
    16f4:	b6 83       	std	Z+6, r27	; 0x06
    16f6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    16fa:	2d b7       	in	r18, 0x3d	; 61
    16fc:	3e b7       	in	r19, 0x3e	; 62
    16fe:	2a 5f       	subi	r18, 0xFA	; 250
    1700:	3f 4f       	sbci	r19, 0xFF	; 255
    1702:	0f b6       	in	r0, 0x3f	; 63
    1704:	f8 94       	cli
    1706:	3e bf       	out	0x3e, r19	; 62
    1708:	0f be       	out	0x3f, r0	; 63
    170a:	2d bf       	out	0x3d, r18	; 61
				/*Copia la informacion a Tracebufferdata*/
				//DisplayTraceResults(AxisWaist,rxCommand.Dato);
				//TraceResultstoBuffer(rxCommand,&GetBufferFlag);
				
			}			
			if(rxCommand.CommandOP==CommandGetMemory)
    170c:	80 91 ee 81 	lds	r24, 0x81EE
    1710:	90 91 ef 81 	lds	r25, 0x81EF
    1714:	0e 97       	sbiw	r24, 0x0e	; 14
    1716:	b1 f4       	brne	.+44     	; 0x1744 <work_out+0xe70>
			{
				i=maxavail();
    1718:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <maxavail>
				printf("work_out=> La cantidad de memoria ram disponible %d \n",i);
    171c:	00 d0       	rcall	.+0      	; 0x171e <work_out+0xe4a>
    171e:	00 d0       	rcall	.+0      	; 0x1720 <work_out+0xe4c>
    1720:	2c e6       	ldi	r18, 0x6C	; 108
    1722:	39 e2       	ldi	r19, 0x29	; 41
    1724:	ad b7       	in	r26, 0x3d	; 61
    1726:	be b7       	in	r27, 0x3e	; 62
    1728:	12 96       	adiw	r26, 0x02	; 2
    172a:	3c 93       	st	X, r19
    172c:	2e 93       	st	-X, r18
    172e:	11 97       	sbiw	r26, 0x01	; 1
    1730:	14 96       	adiw	r26, 0x04	; 4
    1732:	9c 93       	st	X, r25
    1734:	8e 93       	st	-X, r24
    1736:	13 97       	sbiw	r26, 0x03	; 3
    1738:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    173c:	0f 90       	pop	r0
    173e:	0f 90       	pop	r0
    1740:	0f 90       	pop	r0
    1742:	0f 90       	pop	r0
				//TEST_EJE=rxCommand.Dato;
			}
			if(rxCommand.CommandOP==CommandGoHome)
    1744:	80 91 ee 81 	lds	r24, 0x81EE
    1748:	90 91 ef 81 	lds	r25, 0x81EF
    174c:	01 97       	sbiw	r24, 0x01	; 1
    174e:	31 f4       	brne	.+12     	; 0x175c <work_out+0xe88>
			{
				printf("work_out=> Ejecutando Nest \n");
    1750:	82 ea       	ldi	r24, 0xA2	; 162
    1752:	99 e2       	ldi	r25, 0x29	; 41
    1754:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				go_home();
    1758:	0e 94 50 48 	call	0x90a0	; 0x90a0 <go_home>
			}
			//---NUEVO--- MAY 28 2010//
			if(rxCommand.CommandOP==CommandGetSensor)
    175c:	80 91 ee 81 	lds	r24, 0x81EE
    1760:	90 91 ef 81 	lds	r25, 0x81EF
    1764:	0f 97       	sbiw	r24, 0x0f	; 15
    1766:	11 f5       	brne	.+68     	; 0x17ac <work_out+0xed8>
			{
				printf("work_out=> Ejecutando Check_signal_Status \n");		
    1768:	8e eb       	ldi	r24, 0xBE	; 190
    176a:	99 e2       	ldi	r25, 0x29	; 41
    176c:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				printf("work_out=> En el eje %s el estado de los sensores es:\n" ,AxisName((tReturnCode)rxCommand.Axis));
    1770:	80 91 f0 81 	lds	r24, 0x81F0
    1774:	90 91 f1 81 	lds	r25, 0x81F1
    1778:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    177c:	00 d0       	rcall	.+0      	; 0x177e <work_out+0xeaa>
    177e:	00 d0       	rcall	.+0      	; 0x1780 <work_out+0xeac>
    1780:	29 ee       	ldi	r18, 0xE9	; 233
    1782:	39 e2       	ldi	r19, 0x29	; 41
    1784:	ed b7       	in	r30, 0x3d	; 61
    1786:	fe b7       	in	r31, 0x3e	; 62
    1788:	32 83       	std	Z+2, r19	; 0x02
    178a:	21 83       	std	Z+1, r18	; 0x01
    178c:	94 83       	std	Z+4, r25	; 0x04
    178e:	83 83       	std	Z+3, r24	; 0x03
    1790:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				PMDCheckSignalStatus(rxCommand.Axis,imprimir);  
    1794:	0f 90       	pop	r0
    1796:	0f 90       	pop	r0
    1798:	0f 90       	pop	r0
    179a:	0f 90       	pop	r0
    179c:	80 91 f0 81 	lds	r24, 0x81F0
    17a0:	90 91 f1 81 	lds	r25, 0x81F1
    17a4:	6e ee       	ldi	r22, 0xEE	; 238
    17a6:	7f ef       	ldi	r23, 0xFF	; 255
    17a8:	0e 94 a2 57 	call	0xaf44	; 0xaf44 <PMDCheckSignalStatus>
			}
			if(rxCommand.CommandOP==CommandGetEventStatus)
    17ac:	80 91 ee 81 	lds	r24, 0x81EE
    17b0:	90 91 ef 81 	lds	r25, 0x81EF
    17b4:	40 97       	sbiw	r24, 0x10	; 16
    17b6:	31 f5       	brne	.+76     	; 0x1804 <work_out+0xf30>
			{
				printf("work_out=> Ejecutando Check_Event_Status \n");
    17b8:	80 e2       	ldi	r24, 0x20	; 32
    17ba:	9a e2       	ldi	r25, 0x2A	; 42
    17bc:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				printf("work_out=> En el eje %s Event_status es:\n" ,AxisName((tReturnCode)rxCommand.Axis));
    17c0:	80 91 f0 81 	lds	r24, 0x81F0
    17c4:	90 91 f1 81 	lds	r25, 0x81F1
    17c8:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    17cc:	00 d0       	rcall	.+0      	; 0x17ce <work_out+0xefa>
    17ce:	00 d0       	rcall	.+0      	; 0x17d0 <work_out+0xefc>
    17d0:	2a e4       	ldi	r18, 0x4A	; 74
    17d2:	3a e2       	ldi	r19, 0x2A	; 42
    17d4:	ad b7       	in	r26, 0x3d	; 61
    17d6:	be b7       	in	r27, 0x3e	; 62
    17d8:	12 96       	adiw	r26, 0x02	; 2
    17da:	3c 93       	st	X, r19
    17dc:	2e 93       	st	-X, r18
    17de:	11 97       	sbiw	r26, 0x01	; 1
    17e0:	14 96       	adiw	r26, 0x04	; 4
    17e2:	9c 93       	st	X, r25
    17e4:	8e 93       	st	-X, r24
    17e6:	13 97       	sbiw	r26, 0x03	; 3
    17e8:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				PMDCheckEventStatus(rxCommand.Axis,imprimir);  
    17ec:	0f 90       	pop	r0
    17ee:	0f 90       	pop	r0
    17f0:	0f 90       	pop	r0
    17f2:	0f 90       	pop	r0
    17f4:	80 91 f0 81 	lds	r24, 0x81F0
    17f8:	90 91 f1 81 	lds	r25, 0x81F1
    17fc:	6e ee       	ldi	r22, 0xEE	; 238
    17fe:	7f ef       	ldi	r23, 0xFF	; 255
    1800:	0e 94 2a 5a 	call	0xb454	; 0xb454 <PMDCheckEventStatus>
			}
			if(rxCommand.CommandOP==CommandGetAvtivityStatus)
    1804:	80 91 ee 81 	lds	r24, 0x81EE
    1808:	90 91 ef 81 	lds	r25, 0x81EF
    180c:	41 97       	sbiw	r24, 0x11	; 17
    180e:	11 f5       	brne	.+68     	; 0x1854 <work_out+0xf80>
			{
				printf("work_out=> Ejecutando Check_Activity_Status \n");
    1810:	84 e7       	ldi	r24, 0x74	; 116
    1812:	9a e2       	ldi	r25, 0x2A	; 42
    1814:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				printf("work_out=> En el eje %s el Activity_Status es:\n" ,AxisName((tReturnCode)rxCommand.Axis));
    1818:	80 91 f0 81 	lds	r24, 0x81F0
    181c:	90 91 f1 81 	lds	r25, 0x81F1
    1820:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    1824:	00 d0       	rcall	.+0      	; 0x1826 <work_out+0xf52>
    1826:	00 d0       	rcall	.+0      	; 0x1828 <work_out+0xf54>
    1828:	21 ea       	ldi	r18, 0xA1	; 161
    182a:	3a e2       	ldi	r19, 0x2A	; 42
    182c:	ed b7       	in	r30, 0x3d	; 61
    182e:	fe b7       	in	r31, 0x3e	; 62
    1830:	32 83       	std	Z+2, r19	; 0x02
    1832:	21 83       	std	Z+1, r18	; 0x01
    1834:	94 83       	std	Z+4, r25	; 0x04
    1836:	83 83       	std	Z+3, r24	; 0x03
    1838:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				PMDCheckActivityStatus(rxCommand.Axis,imprimir);  
    183c:	0f 90       	pop	r0
    183e:	0f 90       	pop	r0
    1840:	0f 90       	pop	r0
    1842:	0f 90       	pop	r0
    1844:	80 91 f0 81 	lds	r24, 0x81F0
    1848:	90 91 f1 81 	lds	r25, 0x81F1
    184c:	6e ee       	ldi	r22, 0xEE	; 238
    184e:	7f ef       	ldi	r23, 0xFF	; 255
    1850:	0e 94 cf 58 	call	0xb19e	; 0xb19e <PMDCheckActivityStatus>
				
			}		
			if(rxCommand.CommandOP==CommandGetinfomov)
    1854:	80 91 ee 81 	lds	r24, 0x81EE
    1858:	90 91 ef 81 	lds	r25, 0x81EF
    185c:	42 97       	sbiw	r24, 0x12	; 18
    185e:	09 f0       	breq	.+2      	; 0x1862 <work_out+0xf8e>
    1860:	c2 c2       	rjmp	.+1412   	; 0x1de6 <work_out+0x1512>
			{
				infomov(rxCommand.Axis,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    1862:	00 d0       	rcall	.+0      	; 0x1864 <work_out+0xf90>
    1864:	00 d0       	rcall	.+0      	; 0x1866 <work_out+0xf92>
    1866:	00 d0       	rcall	.+0      	; 0x1868 <work_out+0xf94>
    1868:	ed b7       	in	r30, 0x3d	; 61
    186a:	fe b7       	in	r31, 0x3e	; 62
    186c:	31 96       	adiw	r30, 0x01	; 1
    186e:	80 91 f0 81 	lds	r24, 0x81F0
    1872:	90 91 f1 81 	lds	r25, 0x81F1
    1876:	2c e6       	ldi	r18, 0x6C	; 108
    1878:	3d e7       	ldi	r19, 0x7D	; 125
    187a:	ad b7       	in	r26, 0x3d	; 61
    187c:	be b7       	in	r27, 0x3e	; 62
    187e:	12 96       	adiw	r26, 0x02	; 2
    1880:	3c 93       	st	X, r19
    1882:	2e 93       	st	-X, r18
    1884:	11 97       	sbiw	r26, 0x01	; 1
    1886:	25 eb       	ldi	r18, 0xB5	; 181
    1888:	30 e8       	ldi	r19, 0x80	; 128
    188a:	33 83       	std	Z+3, r19	; 0x03
    188c:	22 83       	std	Z+2, r18	; 0x02
    188e:	2a e6       	ldi	r18, 0x6A	; 106
    1890:	3d e7       	ldi	r19, 0x7D	; 125
    1892:	35 83       	std	Z+5, r19	; 0x05
    1894:	24 83       	std	Z+4, r18	; 0x04
    1896:	6b ec       	ldi	r22, 0xCB	; 203
    1898:	70 e8       	ldi	r23, 0x80	; 128
    189a:	40 e7       	ldi	r20, 0x70	; 112
    189c:	5d e7       	ldi	r21, 0x7D	; 125
    189e:	21 eb       	ldi	r18, 0xB1	; 177
    18a0:	30 e8       	ldi	r19, 0x80	; 128
    18a2:	0d ea       	ldi	r16, 0xAD	; 173
    18a4:	10 e8       	ldi	r17, 0x80	; 128
    18a6:	f3 ec       	ldi	r31, 0xC3	; 195
    18a8:	ef 2e       	mov	r14, r31
    18aa:	f0 e8       	ldi	r31, 0x80	; 128
    18ac:	ff 2e       	mov	r15, r31
    18ae:	e7 ec       	ldi	r30, 0xC7	; 199
    18b0:	ce 2e       	mov	r12, r30
    18b2:	e0 e8       	ldi	r30, 0x80	; 128
    18b4:	de 2e       	mov	r13, r30
    18b6:	b8 ea       	ldi	r27, 0xA8	; 168
    18b8:	ab 2e       	mov	r10, r27
    18ba:	b0 e8       	ldi	r27, 0x80	; 128
    18bc:	bb 2e       	mov	r11, r27
    18be:	a0 e1       	ldi	r26, 0x10	; 16
    18c0:	8a 2e       	mov	r8, r26
    18c2:	ac e7       	ldi	r26, 0x7C	; 124
    18c4:	9a 2e       	mov	r9, r26
    18c6:	0e 94 70 56 	call	0xace0	; 0xace0 <infomov>
    18ca:	ed b7       	in	r30, 0x3d	; 61
    18cc:	fe b7       	in	r31, 0x3e	; 62
    18ce:	36 96       	adiw	r30, 0x06	; 6
    18d0:	b0 c1       	rjmp	.+864    	; 0x1c32 <work_out+0x135e>
		break;
		}
        case PacketTrajectory:
		{
		    #ifdef DEBUGPUNTO
			printf("work_out=> Tamano %X \n", rxTrajectory.size);
    18d2:	00 d0       	rcall	.+0      	; 0x18d4 <work_out+0x1000>
    18d4:	00 d0       	rcall	.+0      	; 0x18d6 <work_out+0x1002>
    18d6:	8d e4       	ldi	r24, 0x4D	; 77
    18d8:	97 e2       	ldi	r25, 0x27	; 39
    18da:	ad b7       	in	r26, 0x3d	; 61
    18dc:	be b7       	in	r27, 0x3e	; 62
    18de:	12 96       	adiw	r26, 0x02	; 2
    18e0:	9c 93       	st	X, r25
    18e2:	8e 93       	st	-X, r24
    18e4:	11 97       	sbiw	r26, 0x01	; 1
    18e6:	80 91 09 82 	lds	r24, 0x8209
    18ea:	90 91 0a 82 	lds	r25, 0x820A
    18ee:	14 96       	adiw	r26, 0x04	; 4
    18f0:	9c 93       	st	X, r25
    18f2:	8e 93       	st	-X, r24
    18f4:	13 97       	sbiw	r26, 0x03	; 3
    18f6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			printf("work_out=> Invalida Mask= %X \n", rxTrajectory.invalidmask);
    18fa:	8e e2       	ldi	r24, 0x2E	; 46
    18fc:	97 e2       	ldi	r25, 0x27	; 39
    18fe:	ed b7       	in	r30, 0x3d	; 61
    1900:	fe b7       	in	r31, 0x3e	; 62
    1902:	92 83       	std	Z+2, r25	; 0x02
    1904:	81 83       	std	Z+1, r24	; 0x01
    1906:	80 91 0b 82 	lds	r24, 0x820B
    190a:	90 91 0c 82 	lds	r25, 0x820C
    190e:	94 83       	std	Z+4, r25	; 0x04
    1910:	83 83       	std	Z+3, r24	; 0x03
    1912:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    1916:	aa 24       	eor	r10, r10
    1918:	bb 24       	eor	r11, r11
    191a:	88 24       	eor	r8, r8
    191c:	99 24       	eor	r9, r9
    191e:	0f 90       	pop	r0
    1920:	0f 90       	pop	r0
    1922:	0f 90       	pop	r0
    1924:	0f 90       	pop	r0
			for(punto=0;punto<rxTrajectory.size;punto++)		  		
			{
				printf("work_out=> Imprimiendo el punto %d \n" ,punto);
    1926:	f1 ed       	ldi	r31, 0xD1	; 209
    1928:	2f 2e       	mov	r2, r31
    192a:	fa e2       	ldi	r31, 0x2A	; 42
    192c:	3f 2e       	mov	r3, r31
		         for(eje=0;eje<DOF;eje++)
		        {	
		         printf("work_out=>  El eje es  %s y su pos es %ld \n" ,AxisName((tReturnCode)eje),rxTrajectory.point[punto].axis[eje].position);
    192e:	ed ed       	ldi	r30, 0xDD	; 221
    1930:	4e 2e       	mov	r4, r30
    1932:	e6 e2       	ldi	r30, 0x26	; 38
    1934:	5e 2e       	mov	r5, r30
			     printf("work_out=>  vel  %ld  y su ac  %ld \n" ,rxTrajectory.point[punto].axis[eje].velocity,rxTrajectory.point[punto].axis[eje].acceleration);
    1936:	79 e0       	ldi	r23, 0x09	; 9
    1938:	67 2e       	mov	r6, r23
    193a:	77 e2       	ldi	r23, 0x27	; 39
    193c:	77 2e       	mov	r7, r23
    193e:	95 c0       	rjmp	.+298    	; 0x1a6a <work_out+0x1196>
		    #ifdef DEBUGPUNTO
			printf("work_out=> Tamano %X \n", rxTrajectory.size);
			printf("work_out=> Invalida Mask= %X \n", rxTrajectory.invalidmask);
			for(punto=0;punto<rxTrajectory.size;punto++)		  		
			{
				printf("work_out=> Imprimiendo el punto %d \n" ,punto);
    1940:	00 d0       	rcall	.+0      	; 0x1942 <work_out+0x106e>
    1942:	00 d0       	rcall	.+0      	; 0x1944 <work_out+0x1070>
    1944:	ad b7       	in	r26, 0x3d	; 61
    1946:	be b7       	in	r27, 0x3e	; 62
    1948:	12 96       	adiw	r26, 0x02	; 2
    194a:	3c 92       	st	X, r3
    194c:	2e 92       	st	-X, r2
    194e:	11 97       	sbiw	r26, 0x01	; 1
    1950:	14 96       	adiw	r26, 0x04	; 4
    1952:	bc 92       	st	X, r11
    1954:	ae 92       	st	-X, r10
    1956:	13 97       	sbiw	r26, 0x03	; 3
    1958:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    195c:	cc 24       	eor	r12, r12
    195e:	dd 24       	eor	r13, r13
    1960:	0f 90       	pop	r0
    1962:	0f 90       	pop	r0
    1964:	0f 90       	pop	r0
    1966:	0f 90       	pop	r0
		         for(eje=0;eje<DOF;eje++)
		        {	
		         printf("work_out=>  El eje es  %s y su pos es %ld \n" ,AxisName((tReturnCode)eje),rxTrajectory.point[punto].axis[eje].position);
    1968:	c6 01       	movw	r24, r12
    196a:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    196e:	ed b7       	in	r30, 0x3d	; 61
    1970:	fe b7       	in	r31, 0x3e	; 62
    1972:	38 97       	sbiw	r30, 0x08	; 8
    1974:	0f b6       	in	r0, 0x3f	; 63
    1976:	f8 94       	cli
    1978:	fe bf       	out	0x3e, r31	; 62
    197a:	0f be       	out	0x3f, r0	; 63
    197c:	ed bf       	out	0x3d, r30	; 61
    197e:	2d b7       	in	r18, 0x3d	; 61
    1980:	3e b7       	in	r19, 0x3e	; 62
    1982:	2f 5f       	subi	r18, 0xFF	; 255
    1984:	3f 4f       	sbci	r19, 0xFF	; 255
    1986:	52 82       	std	Z+2, r5	; 0x02
    1988:	41 82       	std	Z+1, r4	; 0x01
    198a:	d9 01       	movw	r26, r18
    198c:	13 96       	adiw	r26, 0x03	; 3
    198e:	9c 93       	st	X, r25
    1990:	8e 93       	st	-X, r24
    1992:	12 97       	sbiw	r26, 0x02	; 2
    1994:	e0 91 0d 82 	lds	r30, 0x820D
    1998:	f0 91 0e 82 	lds	r31, 0x820E
    199c:	e8 0d       	add	r30, r8
    199e:	f9 1d       	adc	r31, r9
    19a0:	86 01       	movw	r16, r12
    19a2:	00 0f       	add	r16, r16
    19a4:	11 1f       	adc	r17, r17
    19a6:	0c 0d       	add	r16, r12
    19a8:	1d 1d       	adc	r17, r13
    19aa:	78 01       	movw	r14, r16
    19ac:	ee 0c       	add	r14, r14
    19ae:	ff 1c       	adc	r15, r15
    19b0:	ee 0c       	add	r14, r14
    19b2:	ff 1c       	adc	r15, r15
    19b4:	ee 0d       	add	r30, r14
    19b6:	ff 1d       	adc	r31, r15
    19b8:	80 81       	ld	r24, Z
    19ba:	91 81       	ldd	r25, Z+1	; 0x01
    19bc:	a2 81       	ldd	r26, Z+2	; 0x02
    19be:	b3 81       	ldd	r27, Z+3	; 0x03
    19c0:	f9 01       	movw	r30, r18
    19c2:	84 83       	std	Z+4, r24	; 0x04
    19c4:	95 83       	std	Z+5, r25	; 0x05
    19c6:	a6 83       	std	Z+6, r26	; 0x06
    19c8:	b7 83       	std	Z+7, r27	; 0x07
    19ca:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			     printf("work_out=>  vel  %ld  y su ac  %ld \n" ,rxTrajectory.point[punto].axis[eje].velocity,rxTrajectory.point[punto].axis[eje].acceleration);
    19ce:	e0 91 0d 82 	lds	r30, 0x820D
    19d2:	f0 91 0e 82 	lds	r31, 0x820E
    19d6:	e8 0d       	add	r30, r8
    19d8:	f9 1d       	adc	r31, r9
    19da:	00 d0       	rcall	.+0      	; 0x19dc <work_out+0x1108>
    19dc:	2d b7       	in	r18, 0x3d	; 61
    19de:	3e b7       	in	r19, 0x3e	; 62
    19e0:	2f 5f       	subi	r18, 0xFF	; 255
    19e2:	3f 4f       	sbci	r19, 0xFF	; 255
    19e4:	ad b7       	in	r26, 0x3d	; 61
    19e6:	be b7       	in	r27, 0x3e	; 62
    19e8:	12 96       	adiw	r26, 0x02	; 2
    19ea:	7c 92       	st	X, r7
    19ec:	6e 92       	st	-X, r6
    19ee:	11 97       	sbiw	r26, 0x01	; 1
    19f0:	0f 5f       	subi	r16, 0xFF	; 255
    19f2:	1f 4f       	sbci	r17, 0xFF	; 255
    19f4:	00 0f       	add	r16, r16
    19f6:	11 1f       	adc	r17, r17
    19f8:	00 0f       	add	r16, r16
    19fa:	11 1f       	adc	r17, r17
    19fc:	0e 0f       	add	r16, r30
    19fe:	1f 1f       	adc	r17, r31
    1a00:	d8 01       	movw	r26, r16
    1a02:	4d 91       	ld	r20, X+
    1a04:	5d 91       	ld	r21, X+
    1a06:	6d 91       	ld	r22, X+
    1a08:	7c 91       	ld	r23, X
    1a0a:	d9 01       	movw	r26, r18
    1a0c:	12 96       	adiw	r26, 0x02	; 2
    1a0e:	4d 93       	st	X+, r20
    1a10:	5d 93       	st	X+, r21
    1a12:	6d 93       	st	X+, r22
    1a14:	7c 93       	st	X, r23
    1a16:	15 97       	sbiw	r26, 0x05	; 5
    1a18:	ee 0d       	add	r30, r14
    1a1a:	ff 1d       	adc	r31, r15
    1a1c:	80 85       	ldd	r24, Z+8	; 0x08
    1a1e:	91 85       	ldd	r25, Z+9	; 0x09
    1a20:	a2 85       	ldd	r26, Z+10	; 0x0a
    1a22:	b3 85       	ldd	r27, Z+11	; 0x0b
    1a24:	f9 01       	movw	r30, r18
    1a26:	86 83       	std	Z+6, r24	; 0x06
    1a28:	97 83       	std	Z+7, r25	; 0x07
    1a2a:	a0 87       	std	Z+8, r26	; 0x08
    1a2c:	b1 87       	std	Z+9, r27	; 0x09
    1a2e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			printf("work_out=> Tamano %X \n", rxTrajectory.size);
			printf("work_out=> Invalida Mask= %X \n", rxTrajectory.invalidmask);
			for(punto=0;punto<rxTrajectory.size;punto++)		  		
			{
				printf("work_out=> Imprimiendo el punto %d \n" ,punto);
		         for(eje=0;eje<DOF;eje++)
    1a32:	08 94       	sec
    1a34:	c1 1c       	adc	r12, r1
    1a36:	d1 1c       	adc	r13, r1
    1a38:	2d b7       	in	r18, 0x3d	; 61
    1a3a:	3e b7       	in	r19, 0x3e	; 62
    1a3c:	26 5f       	subi	r18, 0xF6	; 246
    1a3e:	3f 4f       	sbci	r19, 0xFF	; 255
    1a40:	0f b6       	in	r0, 0x3f	; 63
    1a42:	f8 94       	cli
    1a44:	3e bf       	out	0x3e, r19	; 62
    1a46:	0f be       	out	0x3f, r0	; 63
    1a48:	2d bf       	out	0x3d, r18	; 61
    1a4a:	35 e0       	ldi	r19, 0x05	; 5
    1a4c:	c3 16       	cp	r12, r19
    1a4e:	d1 04       	cpc	r13, r1
    1a50:	09 f0       	breq	.+2      	; 0x1a54 <work_out+0x1180>
    1a52:	8a cf       	rjmp	.-236    	; 0x1968 <work_out+0x1094>
    1a54:	8d e3       	ldi	r24, 0x3D	; 61
    1a56:	90 e0       	ldi	r25, 0x00	; 0
    1a58:	88 0e       	add	r8, r24
    1a5a:	99 1e       	adc	r9, r25
		        {	
		         printf("work_out=>  El eje es  %s y su pos es %ld \n" ,AxisName((tReturnCode)eje),rxTrajectory.point[punto].axis[eje].position);
			     printf("work_out=>  vel  %ld  y su ac  %ld \n" ,rxTrajectory.point[punto].axis[eje].velocity,rxTrajectory.point[punto].axis[eje].acceleration);
		        }
				if(punto>10)
    1a5c:	9b e0       	ldi	r25, 0x0B	; 11
    1a5e:	a9 16       	cp	r10, r25
    1a60:	b1 04       	cpc	r11, r1
    1a62:	59 f0       	breq	.+22     	; 0x1a7a <work_out+0x11a6>
        case PacketTrajectory:
		{
		    #ifdef DEBUGPUNTO
			printf("work_out=> Tamano %X \n", rxTrajectory.size);
			printf("work_out=> Invalida Mask= %X \n", rxTrajectory.invalidmask);
			for(punto=0;punto<rxTrajectory.size;punto++)		  		
    1a64:	08 94       	sec
    1a66:	a1 1c       	adc	r10, r1
    1a68:	b1 1c       	adc	r11, r1
    1a6a:	80 91 09 82 	lds	r24, 0x8209
    1a6e:	90 91 0a 82 	lds	r25, 0x820A
    1a72:	a8 16       	cp	r10, r24
    1a74:	b9 06       	cpc	r11, r25
    1a76:	0c f4       	brge	.+2      	; 0x1a7a <work_out+0x11a6>
    1a78:	63 cf       	rjmp	.-314    	; 0x1940 <work_out+0x106c>
		        }
				if(punto>10)
				break;
			}
			#endif
			printf("work_out=> Procesando la trayectoria recibida desde robomosp \n");
    1a7a:	86 ef       	ldi	r24, 0xF6	; 246
    1a7c:	9a e2       	ldi	r25, 0x2A	; 42
    1a7e:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
			PMDprocessTrajectory(&rxTrajectory,TRACETrajFlag);		  
    1a82:	60 91 b9 80 	lds	r22, 0x80B9
    1a86:	70 91 ba 80 	lds	r23, 0x80BA
    1a8a:	89 e0       	ldi	r24, 0x09	; 9
    1a8c:	92 e8       	ldi	r25, 0x82	; 130
    1a8e:	5e c0       	rjmp	.+188    	; 0x1b4c <work_out+0x1278>
		break;
		}
		case PacketPosesvector:
		{	
			maxdata=rxvector[0];
    1a90:	e0 91 d2 80 	lds	r30, 0x80D2
    1a94:	f0 91 d3 80 	lds	r31, 0x80D3
    1a98:	e0 80       	ld	r14, Z
    1a9a:	f1 80       	ldd	r15, Z+1	; 0x01
			#ifdef DEBUGPOSE
			printf("work_out=> maxdata=> %d\n",maxdata);
    1a9c:	00 d0       	rcall	.+0      	; 0x1a9e <work_out+0x11ca>
    1a9e:	00 d0       	rcall	.+0      	; 0x1aa0 <work_out+0x11cc>
    1aa0:	84 e3       	ldi	r24, 0x34	; 52
    1aa2:	9b e2       	ldi	r25, 0x2B	; 43
    1aa4:	ad b7       	in	r26, 0x3d	; 61
    1aa6:	be b7       	in	r27, 0x3e	; 62
    1aa8:	12 96       	adiw	r26, 0x02	; 2
    1aaa:	9c 93       	st	X, r25
    1aac:	8e 93       	st	-X, r24
    1aae:	11 97       	sbiw	r26, 0x01	; 1
    1ab0:	14 96       	adiw	r26, 0x04	; 4
    1ab2:	fc 92       	st	X, r15
    1ab4:	ee 92       	st	-X, r14
    1ab6:	13 97       	sbiw	r26, 0x03	; 3
    1ab8:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    1abc:	00 e0       	ldi	r16, 0x00	; 0
    1abe:	10 e0       	ldi	r17, 0x00	; 0
    1ac0:	0f 90       	pop	r0
    1ac2:	0f 90       	pop	r0
    1ac4:	0f 90       	pop	r0
    1ac6:	0f 90       	pop	r0
			
			for(i=0;i<maxdata;i++)
				printf("work_out=> rxvector[%d]=> %d\n",i,rxvector[i]);
    1ac8:	3d e4       	ldi	r19, 0x4D	; 77
    1aca:	c3 2e       	mov	r12, r19
    1acc:	3b e2       	ldi	r19, 0x2B	; 43
    1ace:	d3 2e       	mov	r13, r19
    1ad0:	2a c0       	rjmp	.+84     	; 0x1b26 <work_out+0x1252>
    1ad2:	00 d0       	rcall	.+0      	; 0x1ad4 <work_out+0x1200>
    1ad4:	00 d0       	rcall	.+0      	; 0x1ad6 <work_out+0x1202>
    1ad6:	00 d0       	rcall	.+0      	; 0x1ad8 <work_out+0x1204>
    1ad8:	ad b7       	in	r26, 0x3d	; 61
    1ada:	be b7       	in	r27, 0x3e	; 62
    1adc:	11 96       	adiw	r26, 0x01	; 1
    1ade:	ed b7       	in	r30, 0x3d	; 61
    1ae0:	fe b7       	in	r31, 0x3e	; 62
    1ae2:	d2 82       	std	Z+2, r13	; 0x02
    1ae4:	c1 82       	std	Z+1, r12	; 0x01
    1ae6:	13 96       	adiw	r26, 0x03	; 3
    1ae8:	1c 93       	st	X, r17
    1aea:	0e 93       	st	-X, r16
    1aec:	12 97       	sbiw	r26, 0x02	; 2
    1aee:	c8 01       	movw	r24, r16
    1af0:	88 0f       	add	r24, r24
    1af2:	99 1f       	adc	r25, r25
    1af4:	e0 91 d2 80 	lds	r30, 0x80D2
    1af8:	f0 91 d3 80 	lds	r31, 0x80D3
    1afc:	e8 0f       	add	r30, r24
    1afe:	f9 1f       	adc	r31, r25
    1b00:	80 81       	ld	r24, Z
    1b02:	91 81       	ldd	r25, Z+1	; 0x01
    1b04:	15 96       	adiw	r26, 0x05	; 5
    1b06:	9c 93       	st	X, r25
    1b08:	8e 93       	st	-X, r24
    1b0a:	14 97       	sbiw	r26, 0x04	; 4
    1b0c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		{	
			maxdata=rxvector[0];
			#ifdef DEBUGPOSE
			printf("work_out=> maxdata=> %d\n",maxdata);
			
			for(i=0;i<maxdata;i++)
    1b10:	0f 5f       	subi	r16, 0xFF	; 255
    1b12:	1f 4f       	sbci	r17, 0xFF	; 255
    1b14:	2d b7       	in	r18, 0x3d	; 61
    1b16:	3e b7       	in	r19, 0x3e	; 62
    1b18:	2a 5f       	subi	r18, 0xFA	; 250
    1b1a:	3f 4f       	sbci	r19, 0xFF	; 255
    1b1c:	0f b6       	in	r0, 0x3f	; 63
    1b1e:	f8 94       	cli
    1b20:	3e bf       	out	0x3e, r19	; 62
    1b22:	0f be       	out	0x3f, r0	; 63
    1b24:	2d bf       	out	0x3d, r18	; 61
    1b26:	0e 15       	cp	r16, r14
    1b28:	1f 05       	cpc	r17, r15
    1b2a:	9c f2       	brlt	.-90     	; 0x1ad2 <work_out+0x11fe>
				printf("work_out=> rxvector[%d]=> %d\n",i,rxvector[i]);
			#endif
			Vector2Trajectory(rxvector);
    1b2c:	80 91 d2 80 	lds	r24, 0x80D2
    1b30:	90 91 d3 80 	lds	r25, 0x80D3
    1b34:	0e 94 53 75 	call	0xeaa6	; 0xeaa6 <Vector2Trajectory>
			
			printf("work_out=> Procesando la trayectoria recivida con rxvector \n");
    1b38:	8b e6       	ldi	r24, 0x6B	; 107
    1b3a:	9b e2       	ldi	r25, 0x2B	; 43
    1b3c:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
			PMDprocessTrajectory(&Trajectoryvector,TRACETrajFlag);			
    1b40:	60 91 b9 80 	lds	r22, 0x80B9
    1b44:	70 91 ba 80 	lds	r23, 0x80BA
    1b48:	85 e2       	ldi	r24, 0x25	; 37
    1b4a:	92 e8       	ldi	r25, 0x82	; 130
    1b4c:	0e 94 96 54 	call	0xa92c	; 0xa92c <PMDprocessTrajectory>
    1b50:	4a c1       	rjmp	.+660    	; 0x1de6 <work_out+0x1512>
			printf("work_out=> rxFecha.mo %x \n",rxFecha.mo);
			printf("work_out=> rxFecha.yr %x \n",rxFecha.yr);
			printf("work_out=> rxFecha.dw %x \n",rxFecha.dw);
			printf("work_out=> rxFecha.y2k %x \n",rxFecha.y2k);
			#endif
			printf("work_out=> Ejecutando  write_Fecha \n");			
    1b52:	87 ea       	ldi	r24, 0xA7	; 167
    1b54:	9b e2       	ldi	r25, 0x2B	; 43
    1b56:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		    write_Fecha(rxFecha);
    1b5a:	20 91 dc 81 	lds	r18, 0x81DC
    1b5e:	30 91 dd 81 	lds	r19, 0x81DD
    1b62:	40 91 de 81 	lds	r20, 0x81DE
    1b66:	50 91 df 81 	lds	r21, 0x81DF
    1b6a:	60 91 e0 81 	lds	r22, 0x81E0
    1b6e:	70 91 e1 81 	lds	r23, 0x81E1
    1b72:	80 91 e2 81 	lds	r24, 0x81E2
    1b76:	90 91 e3 81 	lds	r25, 0x81E3
    1b7a:	0e 94 a2 72 	call	0xe544	; 0xe544 <write_Fecha>
			printf("work_out=> Fecha enviada = Hoy es el dia %s %x de %s de 200%x. \n",Dayname(rxFecha.dw),rxFecha.dt,Monthname(rxFecha.mo),rxFecha.yr);						
    1b7e:	80 91 e2 81 	lds	r24, 0x81E2
    1b82:	0e 94 ba 24 	call	0x4974	; 0x4974 <Dayname>
    1b86:	8c 01       	movw	r16, r24
    1b88:	f0 90 df 81 	lds	r15, 0x81DF
    1b8c:	80 91 e0 81 	lds	r24, 0x81E0
    1b90:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <Monthname>
    1b94:	ad b7       	in	r26, 0x3d	; 61
    1b96:	be b7       	in	r27, 0x3e	; 62
    1b98:	1a 97       	sbiw	r26, 0x0a	; 10
    1b9a:	0f b6       	in	r0, 0x3f	; 63
    1b9c:	f8 94       	cli
    1b9e:	be bf       	out	0x3e, r27	; 62
    1ba0:	0f be       	out	0x3f, r0	; 63
    1ba2:	ad bf       	out	0x3d, r26	; 61
    1ba4:	ed b7       	in	r30, 0x3d	; 61
    1ba6:	fe b7       	in	r31, 0x3e	; 62
    1ba8:	31 96       	adiw	r30, 0x01	; 1
    1baa:	2b ec       	ldi	r18, 0xCB	; 203
    1bac:	3b e2       	ldi	r19, 0x2B	; 43
    1bae:	12 96       	adiw	r26, 0x02	; 2
    1bb0:	3c 93       	st	X, r19
    1bb2:	2e 93       	st	-X, r18
    1bb4:	11 97       	sbiw	r26, 0x01	; 1
    1bb6:	13 83       	std	Z+3, r17	; 0x03
    1bb8:	02 83       	std	Z+2, r16	; 0x02
    1bba:	f4 82       	std	Z+4, r15	; 0x04
    1bbc:	15 82       	std	Z+5, r1	; 0x05
    1bbe:	97 83       	std	Z+7, r25	; 0x07
    1bc0:	86 83       	std	Z+6, r24	; 0x06
    1bc2:	80 91 e1 81 	lds	r24, 0x81E1
    1bc6:	80 87       	std	Z+8, r24	; 0x08
    1bc8:	11 86       	std	Z+9, r1	; 0x09
    1bca:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			if((rxFecha.hr & 0x20) != 0)			
    1bce:	80 91 de 81 	lds	r24, 0x81DE
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	ed b7       	in	r30, 0x3d	; 61
    1bd6:	fe b7       	in	r31, 0x3e	; 62
    1bd8:	3a 96       	adiw	r30, 0x0a	; 10
    1bda:	0f b6       	in	r0, 0x3f	; 63
    1bdc:	f8 94       	cli
    1bde:	fe bf       	out	0x3e, r31	; 62
    1be0:	0f be       	out	0x3f, r0	; 63
    1be2:	ed bf       	out	0x3d, r30	; 61
    1be4:	9c 01       	movw	r18, r24
    1be6:	2f 71       	andi	r18, 0x1F	; 31
    1be8:	30 70       	andi	r19, 0x00	; 0
    1bea:	85 ff       	sbrs	r24, 5
    1bec:	28 c0       	rjmp	.+80     	; 0x1c3e <work_out+0x136a>
				printf("work_out=> Son las %x:%x:%x PM \n",(rxFecha.hr & 0x1F),rxFecha.mn,rxFecha.sc);
    1bee:	8d b7       	in	r24, 0x3d	; 61
    1bf0:	9e b7       	in	r25, 0x3e	; 62
    1bf2:	08 97       	sbiw	r24, 0x08	; 8
    1bf4:	0f b6       	in	r0, 0x3f	; 63
    1bf6:	f8 94       	cli
    1bf8:	9e bf       	out	0x3e, r25	; 62
    1bfa:	0f be       	out	0x3f, r0	; 63
    1bfc:	8d bf       	out	0x3d, r24	; 61
    1bfe:	ed b7       	in	r30, 0x3d	; 61
    1c00:	fe b7       	in	r31, 0x3e	; 62
    1c02:	31 96       	adiw	r30, 0x01	; 1
    1c04:	8b e0       	ldi	r24, 0x0B	; 11
    1c06:	98 e2       	ldi	r25, 0x28	; 40
    1c08:	ad b7       	in	r26, 0x3d	; 61
    1c0a:	be b7       	in	r27, 0x3e	; 62
    1c0c:	12 96       	adiw	r26, 0x02	; 2
    1c0e:	9c 93       	st	X, r25
    1c10:	8e 93       	st	-X, r24
    1c12:	11 97       	sbiw	r26, 0x01	; 1
    1c14:	33 83       	std	Z+3, r19	; 0x03
    1c16:	22 83       	std	Z+2, r18	; 0x02
    1c18:	80 91 dd 81 	lds	r24, 0x81DD
    1c1c:	84 83       	std	Z+4, r24	; 0x04
    1c1e:	15 82       	std	Z+5, r1	; 0x05
    1c20:	80 91 dc 81 	lds	r24, 0x81DC
    1c24:	86 83       	std	Z+6, r24	; 0x06
    1c26:	17 82       	std	Z+7, r1	; 0x07
    1c28:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    1c2c:	ed b7       	in	r30, 0x3d	; 61
    1c2e:	fe b7       	in	r31, 0x3e	; 62
    1c30:	38 96       	adiw	r30, 0x08	; 8
    1c32:	0f b6       	in	r0, 0x3f	; 63
    1c34:	f8 94       	cli
    1c36:	fe bf       	out	0x3e, r31	; 62
    1c38:	0f be       	out	0x3f, r0	; 63
    1c3a:	ed bf       	out	0x3d, r30	; 61
    1c3c:	d4 c0       	rjmp	.+424    	; 0x1de6 <work_out+0x1512>
			else 
				printf("work_out=> Son las %x:%x:%x AM \n",(rxFecha.hr & 0x1F),rxFecha.mn,rxFecha.sc);
    1c3e:	8d b7       	in	r24, 0x3d	; 61
    1c40:	9e b7       	in	r25, 0x3e	; 62
    1c42:	08 97       	sbiw	r24, 0x08	; 8
    1c44:	0f b6       	in	r0, 0x3f	; 63
    1c46:	f8 94       	cli
    1c48:	9e bf       	out	0x3e, r25	; 62
    1c4a:	0f be       	out	0x3f, r0	; 63
    1c4c:	8d bf       	out	0x3d, r24	; 61
    1c4e:	ed b7       	in	r30, 0x3d	; 61
    1c50:	fe b7       	in	r31, 0x3e	; 62
    1c52:	31 96       	adiw	r30, 0x01	; 1
    1c54:	8c e2       	ldi	r24, 0x2C	; 44
    1c56:	98 e2       	ldi	r25, 0x28	; 40
    1c58:	d7 cf       	rjmp	.-82     	; 0x1c08 <work_out+0x1334>
			printf("work_out=> rxAlarma.HRA0 %x \n",rxAlarma.HRA0);
			printf("work_out=> rxAlarma.DTA0 %x \n",rxAlarma.DTA0);
			printf("work_out=> rxAlarma.MOA0 %x \n",rxAlarma.MOA0);
			printf("work_out=> rxAlarma.PER %x \n",rxAlarma.PER);
			#endif
			printf("work_out=> Tarea programada => rxAlarma.TASK = %x \n",rxAlarma.TASK);
    1c5a:	00 d0       	rcall	.+0      	; 0x1c5c <work_out+0x1388>
    1c5c:	00 d0       	rcall	.+0      	; 0x1c5e <work_out+0x138a>
    1c5e:	ed b7       	in	r30, 0x3d	; 61
    1c60:	fe b7       	in	r31, 0x3e	; 62
    1c62:	31 96       	adiw	r30, 0x01	; 1
    1c64:	8c e0       	ldi	r24, 0x0C	; 12
    1c66:	9c e2       	ldi	r25, 0x2C	; 44
    1c68:	ad b7       	in	r26, 0x3d	; 61
    1c6a:	be b7       	in	r27, 0x3e	; 62
    1c6c:	12 96       	adiw	r26, 0x02	; 2
    1c6e:	9c 93       	st	X, r25
    1c70:	8e 93       	st	-X, r24
    1c72:	11 97       	sbiw	r26, 0x01	; 1
    1c74:	80 91 15 82 	lds	r24, 0x8215
    1c78:	82 83       	std	Z+2, r24	; 0x02
    1c7a:	13 82       	std	Z+3, r1	; 0x03
    1c7c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		    write_alarm(rxAlarma);
    1c80:	0f 90       	pop	r0
    1c82:	0f 90       	pop	r0
    1c84:	0f 90       	pop	r0
    1c86:	0f 90       	pop	r0
    1c88:	20 91 0f 82 	lds	r18, 0x820F
    1c8c:	30 91 10 82 	lds	r19, 0x8210
    1c90:	40 91 11 82 	lds	r20, 0x8211
    1c94:	50 91 12 82 	lds	r21, 0x8212
    1c98:	60 91 13 82 	lds	r22, 0x8213
    1c9c:	70 91 14 82 	lds	r23, 0x8214
    1ca0:	80 91 15 82 	lds	r24, 0x8215
    1ca4:	0e 94 1d 72 	call	0xe43a	; 0xe43a <write_alarm>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1ca8:	00 e4       	ldi	r16, 0x40	; 64
    1caa:	1c e9       	ldi	r17, 0x9C	; 156
    1cac:	c8 01       	movw	r24, r16
    1cae:	01 97       	sbiw	r24, 0x01	; 1
    1cb0:	f1 f7       	brne	.-4      	; 0x1cae <work_out+0x13da>
			_delay_ms(20);
			read_control(&ctr);
    1cb2:	ce 01       	movw	r24, r28
    1cb4:	01 96       	adiw	r24, 0x01	; 1
    1cb6:	0e 94 c8 71 	call	0xe390	; 0xe390 <read_control>
    1cba:	c8 01       	movw	r24, r16
    1cbc:	01 97       	sbiw	r24, 0x01	; 1
    1cbe:	f1 f7       	brne	.-4      	; 0x1cbc <work_out+0x13e8>
			_delay_ms(20);
			if(rxAlarma.PER)
    1cc0:	80 91 14 82 	lds	r24, 0x8214
    1cc4:	88 23       	and	r24, r24
    1cc6:	11 f0       	breq	.+4      	; 0x1ccc <work_out+0x13f8>
			{
				ctr.INT=RTC_INT(1,1);//PERIODICA
    1cc8:	80 ea       	ldi	r24, 0xA0	; 160
    1cca:	01 c0       	rjmp	.+2      	; 0x1cce <work_out+0x13fa>
				activo_alarma=1;
			}
			else
			{	
				ctr.INT=RTC_INT(1,0);//nO PERIODICA
    1ccc:	80 e2       	ldi	r24, 0x20	; 32
    1cce:	8a 83       	std	Y+2, r24	; 0x02
				activo_alarma=1;
    1cd0:	81 e0       	ldi	r24, 0x01	; 1
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
    1cd4:	90 93 91 7b 	sts	0x7B91, r25
    1cd8:	80 93 90 7b 	sts	0x7B90, r24
			}	
			write_control(ctr);
    1cdc:	49 81       	ldd	r20, Y+1	; 0x01
    1cde:	5a 81       	ldd	r21, Y+2	; 0x02
    1ce0:	6b 81       	ldd	r22, Y+3	; 0x03
    1ce2:	7c 81       	ldd	r23, Y+4	; 0x04
    1ce4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ce6:	0e 94 54 72 	call	0xe4a8	; 0xe4a8 <write_control>
    1cea:	7d c0       	rjmp	.+250    	; 0x1de6 <work_out+0x1512>
		{	//Debo de reconfigurar los PMDs usando la variable rxAxisSettings[DOF]
			//rxAxisSettings tiene las configuraciones de default con algunos campos cambiados 
			//Segun el usuario
			//Tengo que copiar rxAxisSettings a hAxis[0].axisSettings
			for(i=0; i<DOF; i++) 
				printf("work_out=>  rxAxisSettings[%d].ustepsPerStep= %d \n",i,rxAxisSettings[i].ustepsPerStep);
    1cec:	00 d0       	rcall	.+0      	; 0x1cee <work_out+0x141a>
    1cee:	00 d0       	rcall	.+0      	; 0x1cf0 <work_out+0x141c>
    1cf0:	00 d0       	rcall	.+0      	; 0x1cf2 <work_out+0x141e>
    1cf2:	ed b7       	in	r30, 0x3d	; 61
    1cf4:	fe b7       	in	r31, 0x3e	; 62
    1cf6:	31 96       	adiw	r30, 0x01	; 1
    1cf8:	00 e4       	ldi	r16, 0x40	; 64
    1cfa:	1c e2       	ldi	r17, 0x2C	; 44
    1cfc:	ad b7       	in	r26, 0x3d	; 61
    1cfe:	be b7       	in	r27, 0x3e	; 62
    1d00:	12 96       	adiw	r26, 0x02	; 2
    1d02:	1c 93       	st	X, r17
    1d04:	0e 93       	st	-X, r16
    1d06:	11 97       	sbiw	r26, 0x01	; 1
    1d08:	13 82       	std	Z+3, r1	; 0x03
    1d0a:	12 82       	std	Z+2, r1	; 0x02
    1d0c:	80 91 5e 7f 	lds	r24, 0x7F5E
    1d10:	90 91 5f 7f 	lds	r25, 0x7F5F
    1d14:	95 83       	std	Z+5, r25	; 0x05
    1d16:	84 83       	std	Z+4, r24	; 0x04
    1d18:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    1d1c:	ed b7       	in	r30, 0x3d	; 61
    1d1e:	fe b7       	in	r31, 0x3e	; 62
    1d20:	31 96       	adiw	r30, 0x01	; 1
    1d22:	ad b7       	in	r26, 0x3d	; 61
    1d24:	be b7       	in	r27, 0x3e	; 62
    1d26:	12 96       	adiw	r26, 0x02	; 2
    1d28:	1c 93       	st	X, r17
    1d2a:	0e 93       	st	-X, r16
    1d2c:	11 97       	sbiw	r26, 0x01	; 1
    1d2e:	81 e0       	ldi	r24, 0x01	; 1
    1d30:	90 e0       	ldi	r25, 0x00	; 0
    1d32:	93 83       	std	Z+3, r25	; 0x03
    1d34:	82 83       	std	Z+2, r24	; 0x02
    1d36:	80 91 a2 7f 	lds	r24, 0x7FA2
    1d3a:	90 91 a3 7f 	lds	r25, 0x7FA3
    1d3e:	95 83       	std	Z+5, r25	; 0x05
    1d40:	84 83       	std	Z+4, r24	; 0x04
    1d42:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    1d46:	ed b7       	in	r30, 0x3d	; 61
    1d48:	fe b7       	in	r31, 0x3e	; 62
    1d4a:	31 96       	adiw	r30, 0x01	; 1
    1d4c:	ad b7       	in	r26, 0x3d	; 61
    1d4e:	be b7       	in	r27, 0x3e	; 62
    1d50:	12 96       	adiw	r26, 0x02	; 2
    1d52:	1c 93       	st	X, r17
    1d54:	0e 93       	st	-X, r16
    1d56:	11 97       	sbiw	r26, 0x01	; 1
    1d58:	82 e0       	ldi	r24, 0x02	; 2
    1d5a:	90 e0       	ldi	r25, 0x00	; 0
    1d5c:	93 83       	std	Z+3, r25	; 0x03
    1d5e:	82 83       	std	Z+2, r24	; 0x02
    1d60:	80 91 e6 7f 	lds	r24, 0x7FE6
    1d64:	90 91 e7 7f 	lds	r25, 0x7FE7
    1d68:	95 83       	std	Z+5, r25	; 0x05
    1d6a:	84 83       	std	Z+4, r24	; 0x04
    1d6c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    1d70:	ed b7       	in	r30, 0x3d	; 61
    1d72:	fe b7       	in	r31, 0x3e	; 62
    1d74:	31 96       	adiw	r30, 0x01	; 1
    1d76:	ad b7       	in	r26, 0x3d	; 61
    1d78:	be b7       	in	r27, 0x3e	; 62
    1d7a:	12 96       	adiw	r26, 0x02	; 2
    1d7c:	1c 93       	st	X, r17
    1d7e:	0e 93       	st	-X, r16
    1d80:	11 97       	sbiw	r26, 0x01	; 1
    1d82:	83 e0       	ldi	r24, 0x03	; 3
    1d84:	90 e0       	ldi	r25, 0x00	; 0
    1d86:	93 83       	std	Z+3, r25	; 0x03
    1d88:	82 83       	std	Z+2, r24	; 0x02
    1d8a:	80 91 2a 80 	lds	r24, 0x802A
    1d8e:	90 91 2b 80 	lds	r25, 0x802B
    1d92:	95 83       	std	Z+5, r25	; 0x05
    1d94:	84 83       	std	Z+4, r24	; 0x04
    1d96:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    1d9a:	ed b7       	in	r30, 0x3d	; 61
    1d9c:	fe b7       	in	r31, 0x3e	; 62
    1d9e:	31 96       	adiw	r30, 0x01	; 1
    1da0:	ad b7       	in	r26, 0x3d	; 61
    1da2:	be b7       	in	r27, 0x3e	; 62
    1da4:	12 96       	adiw	r26, 0x02	; 2
    1da6:	1c 93       	st	X, r17
    1da8:	0e 93       	st	-X, r16
    1daa:	11 97       	sbiw	r26, 0x01	; 1
    1dac:	84 e0       	ldi	r24, 0x04	; 4
    1dae:	90 e0       	ldi	r25, 0x00	; 0
    1db0:	93 83       	std	Z+3, r25	; 0x03
    1db2:	82 83       	std	Z+2, r24	; 0x02
    1db4:	80 91 6e 80 	lds	r24, 0x806E
    1db8:	90 91 6f 80 	lds	r25, 0x806F
    1dbc:	95 83       	std	Z+5, r25	; 0x05
    1dbe:	84 83       	std	Z+4, r24	; 0x04
    1dc0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			//Copio la informacion a la eeprom si es diferente y luego la copia a  hAxis[0].axisSettings
			if(Axissetting2hAxisHandle((uint8*)rxAxisSettings))
    1dc4:	ed b7       	in	r30, 0x3d	; 61
    1dc6:	fe b7       	in	r31, 0x3e	; 62
    1dc8:	36 96       	adiw	r30, 0x06	; 6
    1dca:	0f b6       	in	r0, 0x3f	; 63
    1dcc:	f8 94       	cli
    1dce:	fe bf       	out	0x3e, r31	; 62
    1dd0:	0f be       	out	0x3f, r0	; 63
    1dd2:	ed bf       	out	0x3d, r30	; 61
    1dd4:	84 e5       	ldi	r24, 0x54	; 84
    1dd6:	9f e7       	ldi	r25, 0x7F	; 127
    1dd8:	0e 94 a6 29 	call	0x534c	; 0x534c <Axissetting2hAxisHandle>
    1ddc:	89 2b       	or	r24, r25
    1dde:	19 f0       	breq	.+6      	; 0x1de6 <work_out+0x1512>
			{
				//Reconfiguro con la nueva informacion 
			PMDsetupChipsets_USB(PMDTrapezoidalProfile); 
    1de0:	80 e0       	ldi	r24, 0x00	; 0
    1de2:	0e 94 ed 2a 	call	0x55da	; 0x55da <PMDsetupChipsets_USB>
			}
		break;
		}
	} // switch rxPacket

} // work
    1de6:	0f 90       	pop	r0
    1de8:	0f 90       	pop	r0
    1dea:	0f 90       	pop	r0
    1dec:	0f 90       	pop	r0
    1dee:	0f 90       	pop	r0
    1df0:	cf 91       	pop	r28
    1df2:	df 91       	pop	r29
    1df4:	1f 91       	pop	r17
    1df6:	0f 91       	pop	r16
    1df8:	ff 90       	pop	r15
    1dfa:	ef 90       	pop	r14
    1dfc:	df 90       	pop	r13
    1dfe:	cf 90       	pop	r12
    1e00:	bf 90       	pop	r11
    1e02:	af 90       	pop	r10
    1e04:	9f 90       	pop	r9
    1e06:	8f 90       	pop	r8
    1e08:	7f 90       	pop	r7
    1e0a:	6f 90       	pop	r6
    1e0c:	5f 90       	pop	r5
    1e0e:	4f 90       	pop	r4
    1e10:	3f 90       	pop	r3
    1e12:	2f 90       	pop	r2
    1e14:	08 95       	ret

00001e16 <main>:
FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);
FILE lcd_str = FDEV_SETUP_STREAM(lcd_putchar, NULL, _FDEV_SETUP_WRITE);


int main(void)
{
    1e16:	2f 92       	push	r2
    1e18:	3f 92       	push	r3
    1e1a:	4f 92       	push	r4
    1e1c:	5f 92       	push	r5
    1e1e:	6f 92       	push	r6
    1e20:	7f 92       	push	r7
    1e22:	8f 92       	push	r8
    1e24:	9f 92       	push	r9
    1e26:	af 92       	push	r10
    1e28:	bf 92       	push	r11
    1e2a:	cf 92       	push	r12
    1e2c:	df 92       	push	r13
    1e2e:	ef 92       	push	r14
    1e30:	ff 92       	push	r15
    1e32:	0f 93       	push	r16
    1e34:	1f 93       	push	r17
    1e36:	df 93       	push	r29
    1e38:	cf 93       	push	r28
    1e3a:	cd b7       	in	r28, 0x3d	; 61
    1e3c:	de b7       	in	r29, 0x3e	; 62
    1e3e:	29 97       	sbiw	r28, 0x09	; 9
    1e40:	0f b6       	in	r0, 0x3f	; 63
    1e42:	f8 94       	cli
    1e44:	de bf       	out	0x3e, r29	; 62
    1e46:	0f be       	out	0x3f, r0	; 63
    1e48:	cd bf       	out	0x3d, r28	; 61
	//Variables Fecha
	tFecha Fecha;
	uint8 SR_RTC;
	int16 cont_alarma=0;
	//Inicializacion de las Banderas de Interrupcion;
	intflags.USB_int		=	1;
    1e4a:	80 91 cf 80 	lds	r24, 0x80CF
    1e4e:	81 60       	ori	r24, 0x01	; 1
    1e50:	80 93 cf 80 	sts	0x80CF, r24
	intflags.flag_read		=	1;
    1e54:	80 91 cf 80 	lds	r24, 0x80CF
    1e58:	82 60       	ori	r24, 0x02	; 2
    1e5a:	80 93 cf 80 	sts	0x80CF, r24
	intflags.flag_write		=	1;
    1e5e:	80 91 cf 80 	lds	r24, 0x80CF
    1e62:	84 60       	ori	r24, 0x04	; 4
    1e64:	80 93 cf 80 	sts	0x80CF, r24
	intflags.Timer1_int	    =   1;
    1e68:	80 91 cf 80 	lds	r24, 0x80CF
    1e6c:	88 60       	ori	r24, 0x08	; 8
    1e6e:	80 93 cf 80 	sts	0x80CF, r24
	intflags.Timer3_int	    =   1;
    1e72:	80 91 cf 80 	lds	r24, 0x80CF
    1e76:	80 61       	ori	r24, 0x10	; 16
    1e78:	80 93 cf 80 	sts	0x80CF, r24
	
	
	initCard();							//inicializa el Atmega 1280.
    1e7c:	0e 94 2d 25 	call	0x4a5a	; 0x4a5a <initCard>
	uart_init();						//Inicializa la UART a 9600 Bd, tx/rx, 8N1.	
    1e80:	0e 94 a7 6d 	call	0xdb4e	; 0xdb4e <uart_init>
	lcd_init();
    1e84:	0e 94 4b 6f 	call	0xde96	; 0xde96 <lcd_init>
	rtc_init();							//Inicializacion RTC
    1e88:	0e 94 85 72 	call	0xe50a	; 0xe50a <rtc_init>
	stdout = stdin = &uart_str;
    1e8c:	86 e5       	ldi	r24, 0x56	; 86
    1e8e:	9e e2       	ldi	r25, 0x2E	; 46
    1e90:	90 93 30 82 	sts	0x8230, r25
    1e94:	80 93 2f 82 	sts	0x822F, r24
    1e98:	90 93 32 82 	sts	0x8232, r25
    1e9c:	80 93 31 82 	sts	0x8231, r24
	stderr = &lcd_str;
    1ea0:	84 e6       	ldi	r24, 0x64	; 100
    1ea2:	9e e2       	ldi	r25, 0x2E	; 46
    1ea4:	90 93 34 82 	sts	0x8234, r25
    1ea8:	80 93 33 82 	sts	0x8233, r24
	//Secuencia de pruebas
	//Test_perifericos();
	
	//Led
	Led_on(Amarillo);
    1eac:	82 e0       	ldi	r24, 0x02	; 2
    1eae:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
	delay_1s();	
    1eb2:	0e 94 e1 76 	call	0xedc2	; 0xedc2 <delay_1s>
	Led_on(Verde);	
    1eb6:	80 e0       	ldi	r24, 0x00	; 0
    1eb8:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
	delay_1s();	
    1ebc:	0e 94 e1 76 	call	0xedc2	; 0xedc2 <delay_1s>
	Led_on(Rojo);	
    1ec0:	81 e0       	ldi	r24, 0x01	; 1
    1ec2:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
	delay_1s();	
    1ec6:	0e 94 e1 76 	call	0xedc2	; 0xedc2 <delay_1s>
	Led_off(Rojo);
    1eca:	81 e0       	ldi	r24, 0x01	; 1
    1ecc:	90 e0       	ldi	r25, 0x00	; 0
    1ece:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
	Led_off(Verde);
    1ed2:	80 e0       	ldi	r24, 0x00	; 0
    1ed4:	90 e0       	ldi	r25, 0x00	; 0
    1ed6:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
	Led_off(Amarillo);
    1eda:	82 e0       	ldi	r24, 0x02	; 2
    1edc:	90 e0       	ldi	r25, 0x00	; 0
    1ede:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
	
	//Verificacion Tarjetas Controladores de Motores.
	
	fprintf_P(stderr,PSTR("Verificando Tarjetas PMDs \n"));
    1ee2:	00 d0       	rcall	.+0      	; 0x1ee4 <main+0xce>
    1ee4:	00 d0       	rcall	.+0      	; 0x1ee6 <main+0xd0>
    1ee6:	80 91 33 82 	lds	r24, 0x8233
    1eea:	90 91 34 82 	lds	r25, 0x8234
    1eee:	ad b7       	in	r26, 0x3d	; 61
    1ef0:	be b7       	in	r27, 0x3e	; 62
    1ef2:	12 96       	adiw	r26, 0x02	; 2
    1ef4:	9c 93       	st	X, r25
    1ef6:	8e 93       	st	-X, r24
    1ef8:	11 97       	sbiw	r26, 0x01	; 1
    1efa:	81 e9       	ldi	r24, 0x91	; 145
    1efc:	93 e0       	ldi	r25, 0x03	; 3
    1efe:	14 96       	adiw	r26, 0x04	; 4
    1f00:	9c 93       	st	X, r25
    1f02:	8e 93       	st	-X, r24
    1f04:	13 97       	sbiw	r26, 0x03	; 3
    1f06:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
	if(selftestPMD()!=rcOK)
    1f0a:	0f 90       	pop	r0
    1f0c:	0f 90       	pop	r0
    1f0e:	0f 90       	pop	r0
    1f10:	0f 90       	pop	r0
    1f12:	0e 94 61 2e 	call	0x5cc2	; 0x5cc2 <selftestPMD>
    1f16:	89 2b       	or	r24, r25
    1f18:	69 f0       	breq	.+26     	; 0x1f34 <main+0x11e>
	{
		fprintf_P(stderr,PSTR("Apague el controlador \n"));
    1f1a:	00 d0       	rcall	.+0      	; 0x1f1c <main+0x106>
    1f1c:	00 d0       	rcall	.+0      	; 0x1f1e <main+0x108>
    1f1e:	80 91 33 82 	lds	r24, 0x8233
    1f22:	90 91 34 82 	lds	r25, 0x8234
    1f26:	ed b7       	in	r30, 0x3d	; 61
    1f28:	fe b7       	in	r31, 0x3e	; 62
    1f2a:	92 83       	std	Z+2, r25	; 0x02
    1f2c:	81 83       	std	Z+1, r24	; 0x01
    1f2e:	89 e7       	ldi	r24, 0x79	; 121
    1f30:	93 e0       	ldi	r25, 0x03	; 3
    1f32:	34 c0       	rjmp	.+104    	; 0x1f9c <main+0x186>
		exit(0);
	}
	
	//Configuracion de los PMDs con Valores de Defecto.
	PMDsetupChipSets(PMDTrapezoidalProfile);
    1f34:	80 e0       	ldi	r24, 0x00	; 0
    1f36:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <PMDsetupChipSets>
	Led_off(Verde);	
    1f3a:	80 e0       	ldi	r24, 0x00	; 0
    1f3c:	90 e0       	ldi	r25, 0x00	; 0
    1f3e:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
	
	//Configuracion de la Memoria RAM externa de los PMDs
	Memoryconfig();
    1f42:	0e 94 45 32 	call	0x648a	; 0x648a <Memoryconfig>
	
	
	//Verificacion de los Cables de los Sensores y del cable
	//del Boton de Parada de Emergencia
	Led_on(Amarillo);
    1f46:	82 e0       	ldi	r24, 0x02	; 2
    1f48:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
	fprintf_P(stderr,PSTR("Verificando Conexiones de Cables \n"));
    1f4c:	00 d0       	rcall	.+0      	; 0x1f4e <main+0x138>
    1f4e:	00 d0       	rcall	.+0      	; 0x1f50 <main+0x13a>
    1f50:	80 91 33 82 	lds	r24, 0x8233
    1f54:	90 91 34 82 	lds	r25, 0x8234
    1f58:	ad b7       	in	r26, 0x3d	; 61
    1f5a:	be b7       	in	r27, 0x3e	; 62
    1f5c:	12 96       	adiw	r26, 0x02	; 2
    1f5e:	9c 93       	st	X, r25
    1f60:	8e 93       	st	-X, r24
    1f62:	11 97       	sbiw	r26, 0x01	; 1
    1f64:	86 e5       	ldi	r24, 0x56	; 86
    1f66:	93 e0       	ldi	r25, 0x03	; 3
    1f68:	14 96       	adiw	r26, 0x04	; 4
    1f6a:	9c 93       	st	X, r25
    1f6c:	8e 93       	st	-X, r24
    1f6e:	13 97       	sbiw	r26, 0x03	; 3
    1f70:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
	if(checkconnect()!=rcOK)
    1f74:	0f 90       	pop	r0
    1f76:	0f 90       	pop	r0
    1f78:	0f 90       	pop	r0
    1f7a:	0f 90       	pop	r0
    1f7c:	0e 94 fd 54 	call	0xa9fa	; 0xa9fa <checkconnect>
    1f80:	89 2b       	or	r24, r25
    1f82:	c1 f0       	breq	.+48     	; 0x1fb4 <main+0x19e>
	{
		fprintf_P(stderr,PSTR("Apague el controlador \n"));
    1f84:	00 d0       	rcall	.+0      	; 0x1f86 <main+0x170>
    1f86:	00 d0       	rcall	.+0      	; 0x1f88 <main+0x172>
    1f88:	80 91 33 82 	lds	r24, 0x8233
    1f8c:	90 91 34 82 	lds	r25, 0x8234
    1f90:	ed b7       	in	r30, 0x3d	; 61
    1f92:	fe b7       	in	r31, 0x3e	; 62
    1f94:	92 83       	std	Z+2, r25	; 0x02
    1f96:	81 83       	std	Z+1, r24	; 0x01
    1f98:	8e e3       	ldi	r24, 0x3E	; 62
    1f9a:	93 e0       	ldi	r25, 0x03	; 3
    1f9c:	94 83       	std	Z+4, r25	; 0x04
    1f9e:	83 83       	std	Z+3, r24	; 0x03
    1fa0:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
		exit(0);
    1fa4:	0f 90       	pop	r0
    1fa6:	0f 90       	pop	r0
    1fa8:	0f 90       	pop	r0
    1faa:	0f 90       	pop	r0
    1fac:	80 e0       	ldi	r24, 0x00	; 0
    1fae:	90 e0       	ldi	r25, 0x00	; 0
    1fb0:	0e 94 0e 8a 	call	0x1141c	; 0x1141c <_exit>
	}	
	Led_off(Amarillo);
    1fb4:	82 e0       	ldi	r24, 0x02	; 2
    1fb6:	90 e0       	ldi	r25, 0x00	; 0
    1fb8:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
	
	Led_on(Rojo);
    1fbc:	81 e0       	ldi	r24, 0x01	; 1
    1fbe:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
	fprintf_P(stderr,PSTR("Secuencia de HOME \n"));
    1fc2:	00 d0       	rcall	.+0      	; 0x1fc4 <main+0x1ae>
    1fc4:	00 d0       	rcall	.+0      	; 0x1fc6 <main+0x1b0>
    1fc6:	80 91 33 82 	lds	r24, 0x8233
    1fca:	90 91 34 82 	lds	r25, 0x8234
    1fce:	ad b7       	in	r26, 0x3d	; 61
    1fd0:	be b7       	in	r27, 0x3e	; 62
    1fd2:	12 96       	adiw	r26, 0x02	; 2
    1fd4:	9c 93       	st	X, r25
    1fd6:	8e 93       	st	-X, r24
    1fd8:	11 97       	sbiw	r26, 0x01	; 1
    1fda:	8a e2       	ldi	r24, 0x2A	; 42
    1fdc:	93 e0       	ldi	r25, 0x03	; 3
    1fde:	14 96       	adiw	r26, 0x04	; 4
    1fe0:	9c 93       	st	X, r25
    1fe2:	8e 93       	st	-X, r24
    1fe4:	13 97       	sbiw	r26, 0x03	; 3
    1fe6:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
	go_home();
    1fea:	0f 90       	pop	r0
    1fec:	0f 90       	pop	r0
    1fee:	0f 90       	pop	r0
    1ff0:	0f 90       	pop	r0
    1ff2:	0e 94 50 48 	call	0x90a0	; 0x90a0 <go_home>
	Led_off(Rojo);
    1ff6:	81 e0       	ldi	r24, 0x01	; 1
    1ff8:	90 e0       	ldi	r25, 0x00	; 0
    1ffa:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
	return_id_vector(); /*Obtengo las Poses de la eeprom*/
    1ffe:	0e 94 31 74 	call	0xe862	; 0xe862 <return_id_vector>
    numdata=id_vector[0];
    2002:	e0 91 23 82 	lds	r30, 0x8223
    2006:	f0 91 24 82 	lds	r31, 0x8224
    200a:	e0 80       	ld	r14, Z
    200c:	f1 80       	ldd	r15, Z+1	; 0x01
    if(numdata)
    200e:	e1 14       	cp	r14, r1
    2010:	f1 04       	cpc	r15, r1
    2012:	99 f1       	breq	.+102    	; 0x207a <main+0x264>
    2014:	00 e0       	ldi	r16, 0x00	; 0
    2016:	10 e0       	ldi	r17, 0x00	; 0
    {	
		for(i=0;i<numdata;i++)
			printf("main=> vector de poses, id_vector[%d] = %d \n",i,id_vector[i]);		  
    2018:	33 e7       	ldi	r19, 0x73	; 115
    201a:	c3 2e       	mov	r12, r19
    201c:	3c e2       	ldi	r19, 0x2C	; 44
    201e:	d3 2e       	mov	r13, r19
    2020:	29 c0       	rjmp	.+82     	; 0x2074 <main+0x25e>
    2022:	00 d0       	rcall	.+0      	; 0x2024 <main+0x20e>
    2024:	00 d0       	rcall	.+0      	; 0x2026 <main+0x210>
    2026:	00 d0       	rcall	.+0      	; 0x2028 <main+0x212>
    2028:	ad b7       	in	r26, 0x3d	; 61
    202a:	be b7       	in	r27, 0x3e	; 62
    202c:	11 96       	adiw	r26, 0x01	; 1
    202e:	ed b7       	in	r30, 0x3d	; 61
    2030:	fe b7       	in	r31, 0x3e	; 62
    2032:	d2 82       	std	Z+2, r13	; 0x02
    2034:	c1 82       	std	Z+1, r12	; 0x01
    2036:	13 96       	adiw	r26, 0x03	; 3
    2038:	1c 93       	st	X, r17
    203a:	0e 93       	st	-X, r16
    203c:	12 97       	sbiw	r26, 0x02	; 2
    203e:	c8 01       	movw	r24, r16
    2040:	88 0f       	add	r24, r24
    2042:	99 1f       	adc	r25, r25
    2044:	e0 91 23 82 	lds	r30, 0x8223
    2048:	f0 91 24 82 	lds	r31, 0x8224
    204c:	e8 0f       	add	r30, r24
    204e:	f9 1f       	adc	r31, r25
    2050:	80 81       	ld	r24, Z
    2052:	91 81       	ldd	r25, Z+1	; 0x01
    2054:	15 96       	adiw	r26, 0x05	; 5
    2056:	9c 93       	st	X, r25
    2058:	8e 93       	st	-X, r24
    205a:	14 97       	sbiw	r26, 0x04	; 4
    205c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	Led_off(Rojo);
	return_id_vector(); /*Obtengo las Poses de la eeprom*/
    numdata=id_vector[0];
    if(numdata)
    {	
		for(i=0;i<numdata;i++)
    2060:	0f 5f       	subi	r16, 0xFF	; 255
    2062:	1f 4f       	sbci	r17, 0xFF	; 255
    2064:	8d b7       	in	r24, 0x3d	; 61
    2066:	9e b7       	in	r25, 0x3e	; 62
    2068:	06 96       	adiw	r24, 0x06	; 6
    206a:	0f b6       	in	r0, 0x3f	; 63
    206c:	f8 94       	cli
    206e:	9e bf       	out	0x3e, r25	; 62
    2070:	0f be       	out	0x3f, r0	; 63
    2072:	8d bf       	out	0x3d, r24	; 61
    2074:	0e 15       	cp	r16, r14
    2076:	1f 05       	cpc	r17, r15
    2078:	a4 f2       	brlt	.-88     	; 0x2022 <main+0x20c>
			printf("main=> vector de poses, id_vector[%d] = %d \n",i,id_vector[i]);		  
	}
	
	EIFR=0xFF;  /*Borro falsas interrupciones al inizializar PMDs, ver pag 79 del manual atemega1280*/   
    207a:	8f ef       	ldi	r24, 0xFF	; 255
    207c:	8c bb       	out	0x1c, r24	; 28
	HostInterruptEnable();
    207e:	0e 94 21 5f 	call	0xbe42	; 0xbe42 <HostInterruptEnable>

	sei();		/* enable interrupts */									
    2082:	78 94       	sei
	printf("main=> Programa Jarboter Controller. \n");
    2084:	80 ea       	ldi	r24, 0xA0	; 160
    2086:	9c e2       	ldi	r25, 0x2C	; 44
    2088:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	fprintf(stderr, "Robot Jarboter Controller.\n");
    208c:	60 91 33 82 	lds	r22, 0x8233
    2090:	70 91 34 82 	lds	r23, 0x8234
    2094:	86 ec       	ldi	r24, 0xC6	; 198
    2096:	9c e2       	ldi	r25, 0x2C	; 44
    2098:	0e 94 d0 88 	call	0x111a0	; 0x111a0 <fputs>
	Led_on(Verde);
    209c:	80 e0       	ldi	r24, 0x00	; 0
    209e:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
    20a2:	ee 24       	eor	r14, r14
    20a4:	ff 24       	eor	r15, r15
    20a6:	00 e0       	ldi	r16, 0x00	; 0
    20a8:	10 e0       	ldi	r17, 0x00	; 0
			intflags.Timer1_int=1;	
			conta=conta+1;
			if (conta==35)  //5min
			{
				fprintf(stderr, "Robot Jarboter Controller.\n");
				Read_Fecha(&Fecha);
    20aa:	92 e0       	ldi	r25, 0x02	; 2
    20ac:	c9 2e       	mov	r12, r25
    20ae:	d1 2c       	mov	r13, r1
    20b0:	cc 0e       	add	r12, r28
    20b2:	dd 1e       	adc	r13, r29
				if((Fecha.hr & 0x20) != 0)	
					fprintf(stderr,"Son las %x:%x:%x PM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
				else 
					fprintf(stderr,"Son las %x:%x:%x AM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    20b4:	88 ef       	ldi	r24, 0xF8	; 248
    20b6:	28 2e       	mov	r2, r24
    20b8:	8c e2       	ldi	r24, 0x2C	; 44
    20ba:	38 2e       	mov	r3, r24
			if (conta==35)  //5min
			{
				fprintf(stderr, "Robot Jarboter Controller.\n");
				Read_Fecha(&Fecha);
				if((Fecha.hr & 0x20) != 0)	
					fprintf(stderr,"Son las %x:%x:%x PM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    20bc:	b2 ee       	ldi	r27, 0xE2	; 226
    20be:	4b 2e       	mov	r4, r27
    20c0:	bc e2       	ldi	r27, 0x2C	; 44
    20c2:	5b 2e       	mov	r5, r27
				cont_alarma++;
				
				if(cont_alarma==3) //25.165 seg
				{
					cont_alarma=0;
					Read_SR(&SR_RTC);
    20c4:	3e 01       	movw	r6, r28
    20c6:	08 94       	sec
    20c8:	61 1c       	adc	r6, r1
    20ca:	71 1c       	adc	r7, r1
						RCT_task(rxAlarma.TASK);												
						fprintf(stderr,"Se produjo Alarma \n");							
						if((Fecha.hr & 0x20) != 0)	
							fprintf(stderr,"a las %x:%x:%x PM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
						else 
							fprintf(stderr,"a las %x:%x:%x AM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    20cc:	ad e6       	ldi	r26, 0x6D	; 109
    20ce:	8a 2e       	mov	r8, r26
    20d0:	ad e2       	ldi	r26, 0x2D	; 45
    20d2:	9a 2e       	mov	r9, r26
						buzzer(1); 
						printf("main=> Se produjo Alarma=> Ejecutando Tarea programada\n");
						RCT_task(rxAlarma.TASK);												
						fprintf(stderr,"Se produjo Alarma \n");							
						if((Fecha.hr & 0x20) != 0)	
							fprintf(stderr,"a las %x:%x:%x PM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    20d4:	f9 e5       	ldi	r31, 0x59	; 89
    20d6:	af 2e       	mov	r10, r31
    20d8:	fd e2       	ldi	r31, 0x2D	; 45
    20da:	bf 2e       	mov	r11, r31
    20dc:	02 c0       	rjmp	.+4      	; 0x20e2 <main+0x2cc>
	HostInterruptEnable();

	sei();		/* enable interrupts */									
	printf("main=> Programa Jarboter Controller. \n");
	fprintf(stderr, "Robot Jarboter Controller.\n");
	Led_on(Verde);
    20de:	00 e0       	ldi	r16, 0x00	; 0
    20e0:	10 e0       	ldi	r17, 0x00	; 0
	
	
	for (;;)
	{		
		if(!intflags.USB_int)
    20e2:	80 91 cf 80 	lds	r24, 0x80CF
    20e6:	80 fd       	sbrc	r24, 0
    20e8:	39 c0       	rjmp	.+114    	; 0x215c <main+0x346>
		{
		    
			intflags.USB_int	= 1;                     	
    20ea:	80 91 cf 80 	lds	r24, 0x80CF
    20ee:	81 60       	ori	r24, 0x01	; 1
    20f0:	80 93 cf 80 	sts	0x80CF, r24
			
			if(!intflags.flag_read)			/*llego dato hacia el uC*/
    20f4:	80 91 cf 80 	lds	r24, 0x80CF
    20f8:	81 fd       	sbrc	r24, 1
    20fa:	15 c0       	rjmp	.+42     	; 0x2126 <main+0x310>
			{
				intflags.flag_read	= 1;	
    20fc:	80 91 cf 80 	lds	r24, 0x80CF
    2100:	82 60       	ori	r24, 0x02	; 2
    2102:	80 93 cf 80 	sts	0x80CF, r24
				Led_off(Verde);								
    2106:	80 e0       	ldi	r24, 0x00	; 0
    2108:	90 e0       	ldi	r25, 0x00	; 0
    210a:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
				Led_on(Amarillo);			/*Amarillo Prendido*/										
    210e:	82 e0       	ldi	r24, 0x02	; 2
    2110:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
			   	work_out(); 
    2114:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <work_out>
				Led_off(Amarillo);								
    2118:	82 e0       	ldi	r24, 0x02	; 2
    211a:	90 e0       	ldi	r25, 0x00	; 0
    211c:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
				Led_on(Verde);								
    2120:	80 e0       	ldi	r24, 0x00	; 0
    2122:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
				
			}
			if(!intflags.flag_write)		/*El PC pide datos del uC*/						
    2126:	80 91 cf 80 	lds	r24, 0x80CF
    212a:	82 fd       	sbrc	r24, 2
    212c:	17 c0       	rjmp	.+46     	; 0x215c <main+0x346>
			{
				intflags.flag_write	= 1;						
    212e:	80 91 cf 80 	lds	r24, 0x80CF
    2132:	84 60       	ori	r24, 0x04	; 4
    2134:	80 93 cf 80 	sts	0x80CF, r24
				Led_off(Verde);								
    2138:	80 e0       	ldi	r24, 0x00	; 0
    213a:	90 e0       	ldi	r25, 0x00	; 0
    213c:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
				Led_on(Rojo);				/*Rojo Prendido*/
    2140:	81 e0       	ldi	r24, 0x01	; 1
    2142:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
				work_in(); 
    2146:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <work_in>
				delay_1s();
    214a:	0e 94 e1 76 	call	0xedc2	; 0xedc2 <delay_1s>
				Led_off(Rojo);
    214e:	81 e0       	ldi	r24, 0x01	; 1
    2150:	90 e0       	ldi	r25, 0x00	; 0
    2152:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
				Led_on(Verde);								
    2156:	80 e0       	ldi	r24, 0x00	; 0
    2158:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
			}
		}
		if(!intflags.Timer1_int)
    215c:	80 91 cf 80 	lds	r24, 0x80CF
    2160:	83 fd       	sbrc	r24, 3
    2162:	5c c0       	rjmp	.+184    	; 0x221c <__stack+0x1d>
		{
			intflags.Timer1_int=1;	
    2164:	80 91 cf 80 	lds	r24, 0x80CF
    2168:	88 60       	ori	r24, 0x08	; 8
    216a:	80 93 cf 80 	sts	0x80CF, r24
			conta=conta+1;
    216e:	08 94       	sec
    2170:	e1 1c       	adc	r14, r1
    2172:	f1 1c       	adc	r15, r1
			if (conta==35)  //5min
    2174:	93 e2       	ldi	r25, 0x23	; 35
    2176:	e9 16       	cp	r14, r25
    2178:	f1 04       	cpc	r15, r1
    217a:	09 f0       	breq	.+2      	; 0x217e <main+0x368>
    217c:	4f c0       	rjmp	.+158    	; 0x221c <__stack+0x1d>
			{
				fprintf(stderr, "Robot Jarboter Controller.\n");
    217e:	60 91 33 82 	lds	r22, 0x8233
    2182:	70 91 34 82 	lds	r23, 0x8234
    2186:	86 ec       	ldi	r24, 0xC6	; 198
    2188:	9c e2       	ldi	r25, 0x2C	; 44
    218a:	0e 94 d0 88 	call	0x111a0	; 0x111a0 <fputs>
				Read_Fecha(&Fecha);
    218e:	c6 01       	movw	r24, r12
    2190:	0e 94 e6 71 	call	0xe3cc	; 0xe3cc <Read_Fecha>
				if((Fecha.hr & 0x20) != 0)	
    2194:	8c 81       	ldd	r24, Y+4	; 0x04
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	20 91 33 82 	lds	r18, 0x8233
    219c:	30 91 34 82 	lds	r19, 0x8234
    21a0:	ac 01       	movw	r20, r24
    21a2:	4f 71       	andi	r20, 0x1F	; 31
    21a4:	50 70       	andi	r21, 0x00	; 0
    21a6:	85 ff       	sbrs	r24, 5
    21a8:	12 c0       	rjmp	.+36     	; 0x21ce <main+0x3b8>
					fprintf(stderr,"Son las %x:%x:%x PM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    21aa:	ad b7       	in	r26, 0x3d	; 61
    21ac:	be b7       	in	r27, 0x3e	; 62
    21ae:	1a 97       	sbiw	r26, 0x0a	; 10
    21b0:	0f b6       	in	r0, 0x3f	; 63
    21b2:	f8 94       	cli
    21b4:	be bf       	out	0x3e, r27	; 62
    21b6:	0f be       	out	0x3f, r0	; 63
    21b8:	ad bf       	out	0x3d, r26	; 61
    21ba:	ed b7       	in	r30, 0x3d	; 61
    21bc:	fe b7       	in	r31, 0x3e	; 62
    21be:	31 96       	adiw	r30, 0x01	; 1
    21c0:	12 96       	adiw	r26, 0x02	; 2
    21c2:	3c 93       	st	X, r19
    21c4:	2e 93       	st	-X, r18
    21c6:	11 97       	sbiw	r26, 0x01	; 1
    21c8:	53 82       	std	Z+3, r5	; 0x03
    21ca:	42 82       	std	Z+2, r4	; 0x02
    21cc:	13 c0       	rjmp	.+38     	; 0x21f4 <main+0x3de>
				else 
					fprintf(stderr,"Son las %x:%x:%x AM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    21ce:	8d b7       	in	r24, 0x3d	; 61
    21d0:	9e b7       	in	r25, 0x3e	; 62
    21d2:	0a 97       	sbiw	r24, 0x0a	; 10
    21d4:	0f b6       	in	r0, 0x3f	; 63
    21d6:	f8 94       	cli
    21d8:	9e bf       	out	0x3e, r25	; 62
    21da:	0f be       	out	0x3f, r0	; 63
    21dc:	8d bf       	out	0x3d, r24	; 61
    21de:	ed b7       	in	r30, 0x3d	; 61
    21e0:	fe b7       	in	r31, 0x3e	; 62
    21e2:	31 96       	adiw	r30, 0x01	; 1
    21e4:	ad b7       	in	r26, 0x3d	; 61
    21e6:	be b7       	in	r27, 0x3e	; 62
    21e8:	12 96       	adiw	r26, 0x02	; 2
    21ea:	3c 93       	st	X, r19
    21ec:	2e 93       	st	-X, r18
    21ee:	11 97       	sbiw	r26, 0x01	; 1
    21f0:	33 82       	std	Z+3, r3	; 0x03
    21f2:	22 82       	std	Z+2, r2	; 0x02
    21f4:	55 83       	std	Z+5, r21	; 0x05
    21f6:	44 83       	std	Z+4, r20	; 0x04
    21f8:	8b 81       	ldd	r24, Y+3	; 0x03
    21fa:	86 83       	std	Z+6, r24	; 0x06
    21fc:	17 82       	std	Z+7, r1	; 0x07
    21fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2200:	80 87       	std	Z+8, r24	; 0x08
    2202:	11 86       	std	Z+9, r1	; 0x09
    2204:	0e 94 75 88 	call	0x110ea	; 0x110ea <fprintf>
    2208:	ee 24       	eor	r14, r14
    220a:	ff 24       	eor	r15, r15
    220c:	ed b7       	in	r30, 0x3d	; 61
    220e:	fe b7       	in	r31, 0x3e	; 62
    2210:	3a 96       	adiw	r30, 0x0a	; 10
    2212:	0f b6       	in	r0, 0x3f	; 63
    2214:	f8 94       	cli
    2216:	fe bf       	out	0x3e, r31	; 62
    2218:	0f be       	out	0x3f, r0	; 63
    221a:	ed bf       	out	0x3d, r30	; 61
				conta=0;
			}
			
		}
		
		if(!intflags.Timer3_int)
    221c:	80 91 cf 80 	lds	r24, 0x80CF
    2220:	84 fd       	sbrc	r24, 4
    2222:	5f cf       	rjmp	.-322    	; 0x20e2 <main+0x2cc>
		{
			intflags.Timer3_int=1;
    2224:	80 91 cf 80 	lds	r24, 0x80CF
    2228:	80 61       	ori	r24, 0x10	; 16
    222a:	80 93 cf 80 	sts	0x80CF, r24
			
			if (activo_alarma)
    222e:	80 91 90 7b 	lds	r24, 0x7B90
    2232:	90 91 91 7b 	lds	r25, 0x7B91
    2236:	89 2b       	or	r24, r25
    2238:	09 f4       	brne	.+2      	; 0x223c <__stack+0x3d>
    223a:	53 cf       	rjmp	.-346    	; 0x20e2 <main+0x2cc>
			{
				
				cont_alarma++;
    223c:	0f 5f       	subi	r16, 0xFF	; 255
    223e:	1f 4f       	sbci	r17, 0xFF	; 255
				
				if(cont_alarma==3) //25.165 seg
    2240:	03 30       	cpi	r16, 0x03	; 3
    2242:	11 05       	cpc	r17, r1
    2244:	09 f0       	breq	.+2      	; 0x2248 <__stack+0x49>
    2246:	4d cf       	rjmp	.-358    	; 0x20e2 <main+0x2cc>
				{
					cont_alarma=0;
					Read_SR(&SR_RTC);
    2248:	c3 01       	movw	r24, r6
    224a:	0e 94 d7 71 	call	0xe3ae	; 0xe3ae <Read_SR>
					if((SR_RTC & AL0Mask)!=0)
    224e:	89 81       	ldd	r24, Y+1	; 0x01
    2250:	85 ff       	sbrs	r24, 5
    2252:	45 cf       	rjmp	.-374    	; 0x20de <main+0x2c8>
					{
						Read_Fecha(&Fecha);						
    2254:	c6 01       	movw	r24, r12
    2256:	0e 94 e6 71 	call	0xe3cc	; 0xe3cc <Read_Fecha>
						activo_alarma=0;
    225a:	10 92 91 7b 	sts	0x7B91, r1
    225e:	10 92 90 7b 	sts	0x7B90, r1
						buzzer(1); 
    2262:	81 e0       	ldi	r24, 0x01	; 1
    2264:	90 e0       	ldi	r25, 0x00	; 0
    2266:	0e 94 eb 76 	call	0xedd6	; 0xedd6 <buzzer>
						printf("main=> Se produjo Alarma=> Ejecutando Tarea programada\n");
    226a:	8e e0       	ldi	r24, 0x0E	; 14
    226c:	9d e2       	ldi	r25, 0x2D	; 45
    226e:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
						RCT_task(rxAlarma.TASK);												
    2272:	80 91 15 82 	lds	r24, 0x8215
    2276:	0e 94 90 71 	call	0xe320	; 0xe320 <RCT_task>
						fprintf(stderr,"Se produjo Alarma \n");							
    227a:	60 91 33 82 	lds	r22, 0x8233
    227e:	70 91 34 82 	lds	r23, 0x8234
    2282:	85 e4       	ldi	r24, 0x45	; 69
    2284:	9d e2       	ldi	r25, 0x2D	; 45
    2286:	0e 94 d0 88 	call	0x111a0	; 0x111a0 <fputs>
						if((Fecha.hr & 0x20) != 0)	
    228a:	8c 81       	ldd	r24, Y+4	; 0x04
    228c:	90 e0       	ldi	r25, 0x00	; 0
    228e:	20 91 33 82 	lds	r18, 0x8233
    2292:	30 91 34 82 	lds	r19, 0x8234
    2296:	ac 01       	movw	r20, r24
    2298:	4f 71       	andi	r20, 0x1F	; 31
    229a:	50 70       	andi	r21, 0x00	; 0
    229c:	85 ff       	sbrs	r24, 5
    229e:	14 c0       	rjmp	.+40     	; 0x22c8 <__stack+0xc9>
							fprintf(stderr,"a las %x:%x:%x PM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    22a0:	8d b7       	in	r24, 0x3d	; 61
    22a2:	9e b7       	in	r25, 0x3e	; 62
    22a4:	0a 97       	sbiw	r24, 0x0a	; 10
    22a6:	0f b6       	in	r0, 0x3f	; 63
    22a8:	f8 94       	cli
    22aa:	9e bf       	out	0x3e, r25	; 62
    22ac:	0f be       	out	0x3f, r0	; 63
    22ae:	8d bf       	out	0x3d, r24	; 61
    22b0:	ed b7       	in	r30, 0x3d	; 61
    22b2:	fe b7       	in	r31, 0x3e	; 62
    22b4:	31 96       	adiw	r30, 0x01	; 1
    22b6:	ad b7       	in	r26, 0x3d	; 61
    22b8:	be b7       	in	r27, 0x3e	; 62
    22ba:	12 96       	adiw	r26, 0x02	; 2
    22bc:	3c 93       	st	X, r19
    22be:	2e 93       	st	-X, r18
    22c0:	11 97       	sbiw	r26, 0x01	; 1
    22c2:	b3 82       	std	Z+3, r11	; 0x03
    22c4:	a2 82       	std	Z+2, r10	; 0x02
    22c6:	13 c0       	rjmp	.+38     	; 0x22ee <__stack+0xef>
						else 
							fprintf(stderr,"a las %x:%x:%x AM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    22c8:	8d b7       	in	r24, 0x3d	; 61
    22ca:	9e b7       	in	r25, 0x3e	; 62
    22cc:	0a 97       	sbiw	r24, 0x0a	; 10
    22ce:	0f b6       	in	r0, 0x3f	; 63
    22d0:	f8 94       	cli
    22d2:	9e bf       	out	0x3e, r25	; 62
    22d4:	0f be       	out	0x3f, r0	; 63
    22d6:	8d bf       	out	0x3d, r24	; 61
    22d8:	ed b7       	in	r30, 0x3d	; 61
    22da:	fe b7       	in	r31, 0x3e	; 62
    22dc:	31 96       	adiw	r30, 0x01	; 1
    22de:	ad b7       	in	r26, 0x3d	; 61
    22e0:	be b7       	in	r27, 0x3e	; 62
    22e2:	12 96       	adiw	r26, 0x02	; 2
    22e4:	3c 93       	st	X, r19
    22e6:	2e 93       	st	-X, r18
    22e8:	11 97       	sbiw	r26, 0x01	; 1
    22ea:	93 82       	std	Z+3, r9	; 0x03
    22ec:	82 82       	std	Z+2, r8	; 0x02
    22ee:	55 83       	std	Z+5, r21	; 0x05
    22f0:	44 83       	std	Z+4, r20	; 0x04
    22f2:	8b 81       	ldd	r24, Y+3	; 0x03
    22f4:	86 83       	std	Z+6, r24	; 0x06
    22f6:	17 82       	std	Z+7, r1	; 0x07
    22f8:	8a 81       	ldd	r24, Y+2	; 0x02
    22fa:	80 87       	std	Z+8, r24	; 0x08
    22fc:	11 86       	std	Z+9, r1	; 0x09
    22fe:	0e 94 75 88 	call	0x110ea	; 0x110ea <fprintf>
    2302:	00 e0       	ldi	r16, 0x00	; 0
    2304:	10 e0       	ldi	r17, 0x00	; 0
    2306:	ed b7       	in	r30, 0x3d	; 61
    2308:	fe b7       	in	r31, 0x3e	; 62
    230a:	3a 96       	adiw	r30, 0x0a	; 10
    230c:	0f b6       	in	r0, 0x3f	; 63
    230e:	f8 94       	cli
    2310:	fe bf       	out	0x3e, r31	; 62
    2312:	0f be       	out	0x3f, r0	; 63
    2314:	ed bf       	out	0x3d, r30	; 61
    2316:	e5 ce       	rjmp	.-566    	; 0x20e2 <main+0x2cc>

00002318 <__vector_6>:
	InterruptHandling_chipset1(); 
}

//Interrupcion Causada por el PMD2
ISR(INT5_vect)
{
    2318:	1f 92       	push	r1
    231a:	0f 92       	push	r0
    231c:	0f b6       	in	r0, 0x3f	; 63
    231e:	0f 92       	push	r0
    2320:	0b b6       	in	r0, 0x3b	; 59
    2322:	0f 92       	push	r0
    2324:	11 24       	eor	r1, r1
    2326:	2f 93       	push	r18
    2328:	3f 93       	push	r19
    232a:	4f 93       	push	r20
    232c:	5f 93       	push	r21
    232e:	6f 93       	push	r22
    2330:	7f 93       	push	r23
    2332:	8f 93       	push	r24
    2334:	9f 93       	push	r25
    2336:	af 93       	push	r26
    2338:	bf 93       	push	r27
    233a:	ef 93       	push	r30
    233c:	ff 93       	push	r31
	printf("PMD2 PRODUJO INTERRUPCION \n"); 
    233e:	81 e8       	ldi	r24, 0x81	; 129
    2340:	9d e2       	ldi	r25, 0x2D	; 45
    2342:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	InterruptHandling_chipset2(); 
    2346:	0e 94 5d 5e 	call	0xbcba	; 0xbcba <InterruptHandling_chipset2>
}
    234a:	ff 91       	pop	r31
    234c:	ef 91       	pop	r30
    234e:	bf 91       	pop	r27
    2350:	af 91       	pop	r26
    2352:	9f 91       	pop	r25
    2354:	8f 91       	pop	r24
    2356:	7f 91       	pop	r23
    2358:	6f 91       	pop	r22
    235a:	5f 91       	pop	r21
    235c:	4f 91       	pop	r20
    235e:	3f 91       	pop	r19
    2360:	2f 91       	pop	r18
    2362:	0f 90       	pop	r0
    2364:	0b be       	out	0x3b, r0	; 59
    2366:	0f 90       	pop	r0
    2368:	0f be       	out	0x3f, r0	; 63
    236a:	0f 90       	pop	r0
    236c:	1f 90       	pop	r1
    236e:	18 95       	reti

00002370 <__vector_5>:
	}
}

//Interrupcion Causada por el PMD1
ISR(INT4_vect)
{
    2370:	1f 92       	push	r1
    2372:	0f 92       	push	r0
    2374:	0f b6       	in	r0, 0x3f	; 63
    2376:	0f 92       	push	r0
    2378:	0b b6       	in	r0, 0x3b	; 59
    237a:	0f 92       	push	r0
    237c:	11 24       	eor	r1, r1
    237e:	2f 93       	push	r18
    2380:	3f 93       	push	r19
    2382:	4f 93       	push	r20
    2384:	5f 93       	push	r21
    2386:	6f 93       	push	r22
    2388:	7f 93       	push	r23
    238a:	8f 93       	push	r24
    238c:	9f 93       	push	r25
    238e:	af 93       	push	r26
    2390:	bf 93       	push	r27
    2392:	ef 93       	push	r30
    2394:	ff 93       	push	r31
	printf("PMD1 PRODUJO INTERRUPCION \n");
    2396:	8c e9       	ldi	r24, 0x9C	; 156
    2398:	9d e2       	ldi	r25, 0x2D	; 45
    239a:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	InterruptHandling_chipset1(); 
    239e:	0e 94 bf 5e 	call	0xbd7e	; 0xbd7e <InterruptHandling_chipset1>
}
    23a2:	ff 91       	pop	r31
    23a4:	ef 91       	pop	r30
    23a6:	bf 91       	pop	r27
    23a8:	af 91       	pop	r26
    23aa:	9f 91       	pop	r25
    23ac:	8f 91       	pop	r24
    23ae:	7f 91       	pop	r23
    23b0:	6f 91       	pop	r22
    23b2:	5f 91       	pop	r21
    23b4:	4f 91       	pop	r20
    23b6:	3f 91       	pop	r19
    23b8:	2f 91       	pop	r18
    23ba:	0f 90       	pop	r0
    23bc:	0b be       	out	0x3b, r0	; 59
    23be:	0f 90       	pop	r0
    23c0:	0f be       	out	0x3f, r0	; 63
    23c2:	0f 90       	pop	r0
    23c4:	1f 90       	pop	r1
    23c6:	18 95       	reti

000023c8 <__vector_4>:
	exit(1);
}

//Interrupcion Causada por La interfaz USB
ISR(INT3_vect)
{	  
    23c8:	1f 92       	push	r1
    23ca:	0f 92       	push	r0
    23cc:	0f b6       	in	r0, 0x3f	; 63
    23ce:	0f 92       	push	r0
    23d0:	0b b6       	in	r0, 0x3b	; 59
    23d2:	0f 92       	push	r0
    23d4:	11 24       	eor	r1, r1
    23d6:	2f 93       	push	r18
    23d8:	3f 93       	push	r19
    23da:	4f 93       	push	r20
    23dc:	5f 93       	push	r21
    23de:	6f 93       	push	r22
    23e0:	7f 93       	push	r23
    23e2:	8f 93       	push	r24
    23e4:	9f 93       	push	r25
    23e6:	af 93       	push	r26
    23e8:	bf 93       	push	r27
    23ea:	ef 93       	push	r30
    23ec:	ff 93       	push	r31
    //Solo se pueden atender nuevas interrupciones IN/OUT/PARADA, 
	//si no hay e curso un proceso de comunicacion de datos IN.
	if(ATENDER_INT_IN==1)
    23ee:	80 91 52 2e 	lds	r24, 0x2E52
    23f2:	90 91 53 2e 	lds	r25, 0x2E53
    23f6:	01 97       	sbiw	r24, 0x01	; 1
    23f8:	d9 f5       	brne	.+118    	; 0x2470 <__vector_4+0xa8>
	{
		buzzer_ms(50); 
    23fa:	62 e3       	ldi	r22, 0x32	; 50
    23fc:	70 e0       	ldi	r23, 0x00	; 0
    23fe:	80 e0       	ldi	r24, 0x00	; 0
    2400:	90 e0       	ldi	r25, 0x00	; 0
    2402:	0e 94 00 77 	call	0xee00	; 0xee00 <buzzer_ms>
		intflags.USB_int	= 0;
    2406:	80 91 cf 80 	lds	r24, 0x80CF
    240a:	8e 7f       	andi	r24, 0xFE	; 254
    240c:	80 93 cf 80 	sts	0x80CF, r24
		
		//Comando de Parada de Emergencia		
		if (bit_is_clear(PINH, USB_FLAG_WRITE) && bit_is_clear(PINH, USB_FLAG_READ))
    2410:	80 91 00 01 	lds	r24, 0x0100
    2414:	86 fd       	sbrc	r24, 6
    2416:	1a c0       	rjmp	.+52     	; 0x244c <__vector_4+0x84>
    2418:	80 91 00 01 	lds	r24, 0x0100
    241c:	85 fd       	sbrc	r24, 5
    241e:	16 c0       	rjmp	.+44     	; 0x244c <__vector_4+0x84>
		{			
			abruptstop();
    2420:	0e 94 c0 36 	call	0x6d80	; 0x6d80 <abruptstop>
			buzzer(1); 
    2424:	81 e0       	ldi	r24, 0x01	; 1
    2426:	90 e0       	ldi	r25, 0x00	; 0
    2428:	0e 94 eb 76 	call	0xedd6	; 0xedd6 <buzzer>
			printf("SE ha efectudado una parada Abrupta en los motores. \n");
    242c:	87 eb       	ldi	r24, 0xB7	; 183
    242e:	9d e2       	ldi	r25, 0x2D	; 45
    2430:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
			fprintf(stderr,"Se ha efectudado una parada Abrupta en los motores. \n"); 
    2434:	60 91 33 82 	lds	r22, 0x8233
    2438:	70 91 34 82 	lds	r23, 0x8234
    243c:	8c ee       	ldi	r24, 0xEC	; 236
    243e:	9d e2       	ldi	r25, 0x2D	; 45
    2440:	0e 94 d0 88 	call	0x111a0	; 0x111a0 <fputs>
			exit(1);			
    2444:	81 e0       	ldi	r24, 0x01	; 1
    2446:	90 e0       	ldi	r25, 0x00	; 0
    2448:	0e 94 0e 8a 	call	0x1141c	; 0x1141c <_exit>
		}	
		
		//Comando de Lectura al uControlador
		
		if (bit_is_clear(PINH, USB_FLAG_READ))
    244c:	80 91 00 01 	lds	r24, 0x0100
    2450:	85 fd       	sbrc	r24, 5
    2452:	05 c0       	rjmp	.+10     	; 0x245e <__vector_4+0x96>
		{
			intflags.flag_read=0;		
    2454:	80 91 cf 80 	lds	r24, 0x80CF
    2458:	8d 7f       	andi	r24, 0xFD	; 253
    245a:	80 93 cf 80 	sts	0x80CF, r24
		}
		
		//Comando de Escritura Sobre el uContralador
		
		if (bit_is_clear(PINH, USB_FLAG_WRITE))
    245e:	80 91 00 01 	lds	r24, 0x0100
    2462:	86 fd       	sbrc	r24, 6
    2464:	05 c0       	rjmp	.+10     	; 0x2470 <__vector_4+0xa8>
		{
			intflags.flag_write=0;			
    2466:	80 91 cf 80 	lds	r24, 0x80CF
    246a:	8b 7f       	andi	r24, 0xFB	; 251
    246c:	80 93 cf 80 	sts	0x80CF, r24
		}		
	}
}
    2470:	ff 91       	pop	r31
    2472:	ef 91       	pop	r30
    2474:	bf 91       	pop	r27
    2476:	af 91       	pop	r26
    2478:	9f 91       	pop	r25
    247a:	8f 91       	pop	r24
    247c:	7f 91       	pop	r23
    247e:	6f 91       	pop	r22
    2480:	5f 91       	pop	r21
    2482:	4f 91       	pop	r20
    2484:	3f 91       	pop	r19
    2486:	2f 91       	pop	r18
    2488:	0f 90       	pop	r0
    248a:	0b be       	out	0x3b, r0	; 59
    248c:	0f 90       	pop	r0
    248e:	0f be       	out	0x3f, r0	; 63
    2490:	0f 90       	pop	r0
    2492:	1f 90       	pop	r1
    2494:	18 95       	reti

00002496 <__vector_3>:
  uint8_t Timer3_int	    : 1;
}intflags;

//Interrupcion Causada por el Boton de Parada de Emergencia
ISR(INT2_vect)
{
    2496:	1f 92       	push	r1
    2498:	0f 92       	push	r0
    249a:	0f b6       	in	r0, 0x3f	; 63
    249c:	0f 92       	push	r0
    249e:	0b b6       	in	r0, 0x3b	; 59
    24a0:	0f 92       	push	r0
    24a2:	11 24       	eor	r1, r1
    24a4:	2f 93       	push	r18
    24a6:	3f 93       	push	r19
    24a8:	4f 93       	push	r20
    24aa:	5f 93       	push	r21
    24ac:	6f 93       	push	r22
    24ae:	7f 93       	push	r23
    24b0:	8f 93       	push	r24
    24b2:	9f 93       	push	r25
    24b4:	af 93       	push	r26
    24b6:	bf 93       	push	r27
    24b8:	ef 93       	push	r30
    24ba:	ff 93       	push	r31
	abruptstop(); 
    24bc:	0e 94 c0 36 	call	0x6d80	; 0x6d80 <abruptstop>
	buzzer(1); 
    24c0:	81 e0       	ldi	r24, 0x01	; 1
    24c2:	90 e0       	ldi	r25, 0x00	; 0
    24c4:	0e 94 eb 76 	call	0xedd6	; 0xedd6 <buzzer>
	Led_on(Rojo);
    24c8:	81 e0       	ldi	r24, 0x01	; 1
    24ca:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
	printf("SE ha activo el Boton de Parada de Emergencia. \n");
    24ce:	82 e2       	ldi	r24, 0x22	; 34
    24d0:	9e e2       	ldi	r25, 0x2E	; 46
    24d2:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	fprintf_P(stderr,PSTR("Boton de Parada de Emergencia Activo \n"));
    24d6:	00 d0       	rcall	.+0      	; 0x24d8 <__vector_3+0x42>
    24d8:	00 d0       	rcall	.+0      	; 0x24da <__vector_3+0x44>
    24da:	80 91 33 82 	lds	r24, 0x8233
    24de:	90 91 34 82 	lds	r25, 0x8234
    24e2:	ed b7       	in	r30, 0x3d	; 61
    24e4:	fe b7       	in	r31, 0x3e	; 62
    24e6:	92 83       	std	Z+2, r25	; 0x02
    24e8:	81 83       	std	Z+1, r24	; 0x01
    24ea:	8d ea       	ldi	r24, 0xAD	; 173
    24ec:	93 e0       	ldi	r25, 0x03	; 3
    24ee:	94 83       	std	Z+4, r25	; 0x04
    24f0:	83 83       	std	Z+3, r24	; 0x03
    24f2:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
	exit(1);
    24f6:	0f 90       	pop	r0
    24f8:	0f 90       	pop	r0
    24fa:	0f 90       	pop	r0
    24fc:	0f 90       	pop	r0
    24fe:	81 e0       	ldi	r24, 0x01	; 1
    2500:	90 e0       	ldi	r25, 0x00	; 0
    2502:	0e 94 0e 8a 	call	0x1141c	; 0x1141c <_exit>

00002506 <rad2usteps>:


/*****************************************************************************************/
// convert angle in rad into microsteps
double rad2usteps(tAxisSettings *paxisSettings, double rad) 
{
    2506:	8f 92       	push	r8
    2508:	9f 92       	push	r9
    250a:	af 92       	push	r10
    250c:	bf 92       	push	r11
    250e:	cf 92       	push	r12
    2510:	df 92       	push	r13
    2512:	ef 92       	push	r14
    2514:	ff 92       	push	r15
    2516:	0f 93       	push	r16
    2518:	1f 93       	push	r17
    251a:	6c 01       	movw	r12, r24
    251c:	4a 01       	movw	r8, r20
    251e:	5b 01       	movw	r10, r22
    2520:	fc 01       	movw	r30, r24
    2522:	64 8d       	ldd	r22, Z+28	; 0x1c
    2524:	75 8d       	ldd	r23, Z+29	; 0x1d
    2526:	88 27       	eor	r24, r24
    2528:	77 fd       	sbrc	r23, 7
    252a:	80 95       	com	r24
    252c:	98 2f       	mov	r25, r24
    252e:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    2532:	7b 01       	movw	r14, r22
    2534:	8c 01       	movw	r16, r24
    2536:	f6 01       	movw	r30, r12
    2538:	66 8d       	ldd	r22, Z+30	; 0x1e
    253a:	77 8d       	ldd	r23, Z+31	; 0x1f
    253c:	88 27       	eor	r24, r24
    253e:	77 fd       	sbrc	r23, 7
    2540:	80 95       	com	r24
    2542:	98 2f       	mov	r25, r24
    2544:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    2548:	9b 01       	movw	r18, r22
    254a:	ac 01       	movw	r20, r24
    254c:	c8 01       	movw	r24, r16
    254e:	b7 01       	movw	r22, r14
    2550:	0e 94 69 83 	call	0x106d2	; 0x106d2 <__divsf3>
    2554:	7b 01       	movw	r14, r22
    2556:	8c 01       	movw	r16, r24
    2558:	c5 01       	movw	r24, r10
    255a:	b4 01       	movw	r22, r8
    255c:	2b ed       	ldi	r18, 0xDB	; 219
    255e:	3f e0       	ldi	r19, 0x0F	; 15
    2560:	49 ec       	ldi	r20, 0xC9	; 201
    2562:	50 e4       	ldi	r21, 0x40	; 64
    2564:	0e 94 69 83 	call	0x106d2	; 0x106d2 <__divsf3>
    2568:	9b 01       	movw	r18, r22
    256a:	ac 01       	movw	r20, r24
    256c:	c8 01       	movw	r24, r16
    256e:	b7 01       	movw	r22, r14
    2570:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    2574:	4b 01       	movw	r8, r22
    2576:	5c 01       	movw	r10, r24
    2578:	f6 01       	movw	r30, r12
    257a:	64 85       	ldd	r22, Z+12	; 0x0c
    257c:	75 85       	ldd	r23, Z+13	; 0x0d
    257e:	88 27       	eor	r24, r24
    2580:	77 fd       	sbrc	r23, 7
    2582:	80 95       	com	r24
    2584:	98 2f       	mov	r25, r24
    2586:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    258a:	7b 01       	movw	r14, r22
    258c:	8c 01       	movw	r16, r24
    258e:	f6 01       	movw	r30, r12
    2590:	62 85       	ldd	r22, Z+10	; 0x0a
    2592:	73 85       	ldd	r23, Z+11	; 0x0b
    2594:	88 27       	eor	r24, r24
    2596:	77 fd       	sbrc	r23, 7
    2598:	80 95       	com	r24
    259a:	98 2f       	mov	r25, r24
    259c:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    25a0:	9b 01       	movw	r18, r22
    25a2:	ac 01       	movw	r20, r24
    25a4:	c8 01       	movw	r24, r16
    25a6:	b7 01       	movw	r22, r14
    25a8:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    25ac:	9b 01       	movw	r18, r22
    25ae:	ac 01       	movw	r20, r24
    25b0:	c5 01       	movw	r24, r10
    25b2:	b4 01       	movw	r22, r8
    25b4:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
	x=(double) paxisSettings->gearNominator/(double)paxisSettings->gearDenominator;
	y=(rad/(2*M_PI));
	z=(double)paxisSettings->motorStepsPerRevolution* (double)paxisSettings->ustepsPerStep;
	resul= x*y*z;
	return resul; 
} // rad2usteps
    25b8:	1f 91       	pop	r17
    25ba:	0f 91       	pop	r16
    25bc:	ff 90       	pop	r15
    25be:	ef 90       	pop	r14
    25c0:	df 90       	pop	r13
    25c2:	cf 90       	pop	r12
    25c4:	bf 90       	pop	r11
    25c6:	af 90       	pop	r10
    25c8:	9f 90       	pop	r9
    25ca:	8f 90       	pop	r8
    25cc:	08 95       	ret

000025ce <ustep2rad>:

/*****************************************************************************************/
// convert microsteps into angle in rad
double ustep2rad(tAxisSettings *paxisSettings, double usteps) 
{
    25ce:	8f 92       	push	r8
    25d0:	9f 92       	push	r9
    25d2:	af 92       	push	r10
    25d4:	bf 92       	push	r11
    25d6:	cf 92       	push	r12
    25d8:	df 92       	push	r13
    25da:	ef 92       	push	r14
    25dc:	ff 92       	push	r15
    25de:	0f 93       	push	r16
    25e0:	1f 93       	push	r17
    25e2:	6c 01       	movw	r12, r24
    25e4:	9a 01       	movw	r18, r20
    25e6:	ab 01       	movw	r20, r22
    25e8:	ca 01       	movw	r24, r20
    25ea:	b9 01       	movw	r22, r18
    25ec:	0e 94 01 83 	call	0x10602	; 0x10602 <__addsf3>
    25f0:	2b ed       	ldi	r18, 0xDB	; 219
    25f2:	3f e0       	ldi	r19, 0x0F	; 15
    25f4:	49 e4       	ldi	r20, 0x49	; 73
    25f6:	50 e4       	ldi	r21, 0x40	; 64
    25f8:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    25fc:	4b 01       	movw	r8, r22
    25fe:	5c 01       	movw	r10, r24
    2600:	f6 01       	movw	r30, r12
    2602:	66 8d       	ldd	r22, Z+30	; 0x1e
    2604:	77 8d       	ldd	r23, Z+31	; 0x1f
    2606:	88 27       	eor	r24, r24
    2608:	77 fd       	sbrc	r23, 7
    260a:	80 95       	com	r24
    260c:	98 2f       	mov	r25, r24
    260e:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    2612:	7b 01       	movw	r14, r22
    2614:	8c 01       	movw	r16, r24
    2616:	f6 01       	movw	r30, r12
    2618:	64 8d       	ldd	r22, Z+28	; 0x1c
    261a:	75 8d       	ldd	r23, Z+29	; 0x1d
    261c:	88 27       	eor	r24, r24
    261e:	77 fd       	sbrc	r23, 7
    2620:	80 95       	com	r24
    2622:	98 2f       	mov	r25, r24
    2624:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    2628:	9b 01       	movw	r18, r22
    262a:	ac 01       	movw	r20, r24
    262c:	c8 01       	movw	r24, r16
    262e:	b7 01       	movw	r22, r14
    2630:	0e 94 69 83 	call	0x106d2	; 0x106d2 <__divsf3>
    2634:	9b 01       	movw	r18, r22
    2636:	ac 01       	movw	r20, r24
    2638:	c5 01       	movw	r24, r10
    263a:	b4 01       	movw	r22, r8
    263c:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    2640:	4b 01       	movw	r8, r22
    2642:	5c 01       	movw	r10, r24
    2644:	f6 01       	movw	r30, r12
    2646:	62 85       	ldd	r22, Z+10	; 0x0a
    2648:	73 85       	ldd	r23, Z+11	; 0x0b
    264a:	88 27       	eor	r24, r24
    264c:	77 fd       	sbrc	r23, 7
    264e:	80 95       	com	r24
    2650:	98 2f       	mov	r25, r24
    2652:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    2656:	7b 01       	movw	r14, r22
    2658:	8c 01       	movw	r16, r24
    265a:	f6 01       	movw	r30, r12
    265c:	64 85       	ldd	r22, Z+12	; 0x0c
    265e:	75 85       	ldd	r23, Z+13	; 0x0d
    2660:	88 27       	eor	r24, r24
    2662:	77 fd       	sbrc	r23, 7
    2664:	80 95       	com	r24
    2666:	98 2f       	mov	r25, r24
    2668:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    266c:	9b 01       	movw	r18, r22
    266e:	ac 01       	movw	r20, r24
    2670:	c8 01       	movw	r24, r16
    2672:	b7 01       	movw	r22, r14
    2674:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    2678:	9b 01       	movw	r18, r22
    267a:	ac 01       	movw	r20, r24
    267c:	60 e0       	ldi	r22, 0x00	; 0
    267e:	70 e0       	ldi	r23, 0x00	; 0
    2680:	80 e8       	ldi	r24, 0x80	; 128
    2682:	9f e3       	ldi	r25, 0x3F	; 63
    2684:	0e 94 69 83 	call	0x106d2	; 0x106d2 <__divsf3>
    2688:	9b 01       	movw	r18, r22
    268a:	ac 01       	movw	r20, r24
    268c:	c5 01       	movw	r24, r10
    268e:	b4 01       	movw	r22, r8
    2690:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>

	x=(double)paxisSettings->gearDenominator/(double)paxisSettings->gearNominator;
	y=1/( (double)paxisSettings->ustepsPerStep*(double)paxisSettings->motorStepsPerRevolution );
	resul=usteps*2*M_PI*x*y;
	return resul;
} // ustep2rad
    2694:	1f 91       	pop	r17
    2696:	0f 91       	pop	r16
    2698:	ff 90       	pop	r15
    269a:	ef 90       	pop	r14
    269c:	df 90       	pop	r13
    269e:	cf 90       	pop	r12
    26a0:	bf 90       	pop	r11
    26a2:	af 90       	pop	r10
    26a4:	9f 90       	pop	r9
    26a6:	8f 90       	pop	r8
    26a8:	08 95       	ret

000026aa <grados2rad>:

/*****************************************************************************************/
double grados2rad(double deg)
{
    26aa:	25 e3       	ldi	r18, 0x35	; 53
    26ac:	3a ef       	ldi	r19, 0xFA	; 250
    26ae:	4e e8       	ldi	r20, 0x8E	; 142
    26b0:	5c e3       	ldi	r21, 0x3C	; 60
    26b2:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
	double rad;

	rad=deg*(M_PI/180);
	return rad;
}
    26b6:	08 95       	ret

000026b8 <rad2grados>:

/*****************************************************************************************/
double rad2grados(double rad)
{
    26b8:	25 e3       	ldi	r18, 0x35	; 53
    26ba:	3a ef       	ldi	r19, 0xFA	; 250
    26bc:	4e e8       	ldi	r20, 0x8E	; 142
    26be:	5c e3       	ldi	r21, 0x3C	; 60
    26c0:	0e 94 69 83 	call	0x106d2	; 0x106d2 <__divsf3>
	double grad;

	grad=rad/(M_PI/180);
	return grad;
}
    26c4:	08 95       	ret

000026c6 <bcd2int>:

/*****************************************************************************************/
uint8 bcd2int(uint8 bcd_format)
{
    26c6:	28 2f       	mov	r18, r24
    26c8:	22 95       	swap	r18
    26ca:	2f 70       	andi	r18, 0x0F	; 15
    26cc:	9a e0       	ldi	r25, 0x0A	; 10
    26ce:	29 9f       	mul	r18, r25
    26d0:	90 01       	movw	r18, r0
    26d2:	11 24       	eor	r1, r1
    26d4:	8f 70       	andi	r24, 0x0F	; 15
	uint8 integer;
	
	integer= (((bcd_format >>4)*10) + (bcd_format%16));
	
	return integer;
}
    26d6:	82 0f       	add	r24, r18
    26d8:	08 95       	ret

000026da <int2bcd>:

/*****************************************************************************************/
uint8 int2bcd(uint8 integer)
{
    26da:	28 2f       	mov	r18, r24
    26dc:	6a e0       	ldi	r22, 0x0A	; 10
    26de:	0e 94 8d 85 	call	0x10b1a	; 0x10b1a <__udivmodqi4>
    26e2:	38 2f       	mov	r19, r24
    26e4:	32 95       	swap	r19
    26e6:	30 7f       	andi	r19, 0xF0	; 240
    26e8:	82 2f       	mov	r24, r18
    26ea:	0e 94 8d 85 	call	0x10b1a	; 0x10b1a <__udivmodqi4>
	uint8 bcd_format;
	
	bcd_format= ((integer/10)<<4) + (integer%10);
	
	return bcd_format;
}
    26ee:	83 2f       	mov	r24, r19
    26f0:	89 0f       	add	r24, r25
    26f2:	08 95       	ret

000026f4 <uPasosTOgradros>:

//paxisSettings apuntador a las caracteristicas de la acticulacion a convertir. 

/*****************************************************************************************/
double uPasosTOgradros(tAxisSettings *paxisSettings,int32 Valor,int tipo)
{
    26f4:	cf 93       	push	r28
    26f6:	df 93       	push	r29
    26f8:	ec 01       	movw	r28, r24

	double result,Data;

	result=-1;
	
	switch(tipo) 
    26fa:	21 30       	cpi	r18, 0x01	; 1
    26fc:	31 05       	cpc	r19, r1
    26fe:	a1 f0       	breq	.+40     	; 0x2728 <uPasosTOgradros+0x34>
    2700:	22 30       	cpi	r18, 0x02	; 2
    2702:	31 05       	cpc	r19, r1
    2704:	69 f1       	breq	.+90     	; 0x2760 <uPasosTOgradros+0x6c>
    2706:	23 2b       	or	r18, r19
    2708:	29 f0       	breq	.+10     	; 0x2714 <uPasosTOgradros+0x20>
    270a:	60 e0       	ldi	r22, 0x00	; 0
    270c:	70 e0       	ldi	r23, 0x00	; 0
    270e:	80 e8       	ldi	r24, 0x80	; 128
    2710:	9f eb       	ldi	r25, 0xBF	; 191
    2712:	43 c0       	rjmp	.+134    	; 0x279a <uPasosTOgradros+0xa6>
	{
		case POSICION_TYPE:
			Data=Valor;
			/*De uPasos A radianes*/
			result=ustep2rad(paxisSettings,(double)Data);
    2714:	cb 01       	movw	r24, r22
    2716:	ba 01       	movw	r22, r20
    2718:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    271c:	ab 01       	movw	r20, r22
    271e:	bc 01       	movw	r22, r24
    2720:	ce 01       	movw	r24, r28
    2722:	0e 94 e7 12 	call	0x25ce	; 0x25ce <ustep2rad>
    2726:	37 c0       	rjmp	.+110    	; 0x2796 <uPasosTOgradros+0xa2>
			/*De Radianes A grados*/
			result=rad2grados((double)result);
		break;
		case VELOCIDAD_TYPE:
			Data=Valor-0.5;
    2728:	cb 01       	movw	r24, r22
    272a:	ba 01       	movw	r22, r20
    272c:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    2730:	20 e0       	ldi	r18, 0x00	; 0
    2732:	30 e0       	ldi	r19, 0x00	; 0
    2734:	40 e0       	ldi	r20, 0x00	; 0
    2736:	5f e3       	ldi	r21, 0x3F	; 63
    2738:	0e 94 00 83 	call	0x10600	; 0x10600 <__subsf3>
			Data=Data/65536.0;
    273c:	20 e0       	ldi	r18, 0x00	; 0
    273e:	30 e0       	ldi	r19, 0x00	; 0
    2740:	40 e8       	ldi	r20, 0x80	; 128
    2742:	57 e3       	ldi	r21, 0x37	; 55
    2744:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
			Data=Data/SAMPLETIME;
			/*De uPasos A radianes*/
			result=ustep2rad(paxisSettings,(double)Data);
    2748:	22 e5       	ldi	r18, 0x52	; 82
    274a:	39 e4       	ldi	r19, 0x49	; 73
    274c:	4d e1       	ldi	r20, 0x1D	; 29
    274e:	5a e3       	ldi	r21, 0x3A	; 58
    2750:	0e 94 69 83 	call	0x106d2	; 0x106d2 <__divsf3>
    2754:	ab 01       	movw	r20, r22
    2756:	bc 01       	movw	r22, r24
    2758:	ce 01       	movw	r24, r28
    275a:	0e 94 e7 12 	call	0x25ce	; 0x25ce <ustep2rad>
    275e:	1b c0       	rjmp	.+54     	; 0x2796 <uPasosTOgradros+0xa2>
			/*De Radianes A grados*/
			result=rad2grados((double)result);
		break;
		case ACELERACION_TYPE:
			Data=Valor-0.5;
    2760:	cb 01       	movw	r24, r22
    2762:	ba 01       	movw	r22, r20
    2764:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    2768:	20 e0       	ldi	r18, 0x00	; 0
    276a:	30 e0       	ldi	r19, 0x00	; 0
    276c:	40 e0       	ldi	r20, 0x00	; 0
    276e:	5f e3       	ldi	r21, 0x3F	; 63
    2770:	0e 94 00 83 	call	0x10600	; 0x10600 <__subsf3>
			Data=Data/65536.0;
    2774:	20 e0       	ldi	r18, 0x00	; 0
    2776:	30 e0       	ldi	r19, 0x00	; 0
    2778:	40 e8       	ldi	r20, 0x80	; 128
    277a:	57 e3       	ldi	r21, 0x37	; 55
    277c:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
			Data=Data/(SAMPLETIME*SAMPLETIME);
			/*De uPasos A radianes*/
			result=ustep2rad(paxisSettings,(double)Data);
    2780:	27 e0       	ldi	r18, 0x07	; 7
    2782:	36 e4       	ldi	r19, 0x46	; 70
    2784:	41 ec       	ldi	r20, 0xC1	; 193
    2786:	54 e3       	ldi	r21, 0x34	; 52
    2788:	0e 94 69 83 	call	0x106d2	; 0x106d2 <__divsf3>
    278c:	ab 01       	movw	r20, r22
    278e:	bc 01       	movw	r22, r24
    2790:	ce 01       	movw	r24, r28
    2792:	0e 94 e7 12 	call	0x25ce	; 0x25ce <ustep2rad>
			/*De Radianes A grados*/
			result=rad2grados((double)result);
    2796:	0e 94 5c 13 	call	0x26b8	; 0x26b8 <rad2grados>
		break;
	}
 
	return result;
}
    279a:	df 91       	pop	r29
    279c:	cf 91       	pop	r28
    279e:	08 95       	ret

000027a0 <accelerationPCtoUC>:
int32 accelerationPCtoUC(double f) 
{
	double temp=0;
	
	temp=f*SAMPLETIME*SAMPLETIME; //De segundos a sampletime 
	temp=0.50+(65536.0*temp);
    27a0:	22 e5       	ldi	r18, 0x52	; 82
    27a2:	39 e4       	ldi	r19, 0x49	; 73
    27a4:	4d e1       	ldi	r20, 0x1D	; 29
    27a6:	5a e3       	ldi	r21, 0x3A	; 58
    27a8:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    27ac:	22 e5       	ldi	r18, 0x52	; 82
    27ae:	39 e4       	ldi	r19, 0x49	; 73
    27b0:	4d e1       	ldi	r20, 0x1D	; 29
    27b2:	5a e3       	ldi	r21, 0x3A	; 58
    27b4:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    27b8:	20 e0       	ldi	r18, 0x00	; 0
    27ba:	30 e0       	ldi	r19, 0x00	; 0
    27bc:	40 e8       	ldi	r20, 0x80	; 128
    27be:	57 e4       	ldi	r21, 0x47	; 71
    27c0:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    27c4:	20 e0       	ldi	r18, 0x00	; 0
    27c6:	30 e0       	ldi	r19, 0x00	; 0
    27c8:	40 e0       	ldi	r20, 0x00	; 0
    27ca:	5f e3       	ldi	r21, 0x3F	; 63
    27cc:	0e 94 01 83 	call	0x10602	; 0x10602 <__addsf3>
    temp=floor(temp);
    27d0:	0e 94 3f 84 	call	0x1087e	; 0x1087e <floor>
    27d4:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    27d8:	9b 01       	movw	r18, r22
    27da:	ac 01       	movw	r20, r24
	return (int32)temp;  // 16.16 format
} // accelerationPCtoUC
    27dc:	ca 01       	movw	r24, r20
    27de:	08 95       	ret

000027e0 <velocityPCtoUC>:
int32 velocityPCtoUC(double f) 
{
	double temp=0;
	
	temp=f*SAMPLETIME; //De segundos a sampletime 
	temp=0.50+65536.0*temp;
    27e0:	22 e5       	ldi	r18, 0x52	; 82
    27e2:	39 e4       	ldi	r19, 0x49	; 73
    27e4:	4d e1       	ldi	r20, 0x1D	; 29
    27e6:	5a e3       	ldi	r21, 0x3A	; 58
    27e8:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    27ec:	20 e0       	ldi	r18, 0x00	; 0
    27ee:	30 e0       	ldi	r19, 0x00	; 0
    27f0:	40 e8       	ldi	r20, 0x80	; 128
    27f2:	57 e4       	ldi	r21, 0x47	; 71
    27f4:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    27f8:	20 e0       	ldi	r18, 0x00	; 0
    27fa:	30 e0       	ldi	r19, 0x00	; 0
    27fc:	40 e0       	ldi	r20, 0x00	; 0
    27fe:	5f e3       	ldi	r21, 0x3F	; 63
    2800:	0e 94 01 83 	call	0x10602	; 0x10602 <__addsf3>
	temp=floor(temp);
    2804:	0e 94 3f 84 	call	0x1087e	; 0x1087e <floor>
    2808:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    280c:	9b 01       	movw	r18, r22
    280e:	ac 01       	movw	r20, r24
	return (int32)temp;  // 16.16 format
} // velocityPCtoUC
    2810:	ca 01       	movw	r24, r20
    2812:	08 95       	ret

00002814 <positionPCtoUC>:


/*****************************************************************************************/
int32 positionPCtoUC(double f) 
{
	return (int32)floor(0.50+f);  // 32.0 format
    2814:	20 e0       	ldi	r18, 0x00	; 0
    2816:	30 e0       	ldi	r19, 0x00	; 0
    2818:	40 e0       	ldi	r20, 0x00	; 0
    281a:	5f e3       	ldi	r21, 0x3F	; 63
    281c:	0e 94 01 83 	call	0x10602	; 0x10602 <__addsf3>
    2820:	0e 94 3f 84 	call	0x1087e	; 0x1087e <floor>
    2824:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    2828:	9b 01       	movw	r18, r22
    282a:	ac 01       	movw	r20, r24
} // positionPCtoUC
    282c:	ca 01       	movw	r24, r20
    282e:	08 95       	ret

00002830 <gradrosTOuPasos>:
	return result;
}


int32 gradrosTOuPasos(tAxisSettings *paxisSettings,double angulo,int tipo)
{
    2830:	0f 93       	push	r16
    2832:	1f 93       	push	r17
    2834:	cf 93       	push	r28
    2836:	df 93       	push	r29
    2838:	8c 01       	movw	r16, r24
    283a:	e9 01       	movw	r28, r18
	int32 result;

	result=-1;
	
	Radianes=grados2rad(angulo);
	uPasos=rad2usteps(paxisSettings,Radianes);
    283c:	cb 01       	movw	r24, r22
    283e:	ba 01       	movw	r22, r20
    2840:	25 e3       	ldi	r18, 0x35	; 53
    2842:	3a ef       	ldi	r19, 0xFA	; 250
    2844:	4e e8       	ldi	r20, 0x8E	; 142
    2846:	5c e3       	ldi	r21, 0x3C	; 60
    2848:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    284c:	ab 01       	movw	r20, r22
    284e:	bc 01       	movw	r22, r24
    2850:	c8 01       	movw	r24, r16
    2852:	0e 94 83 12 	call	0x2506	; 0x2506 <rad2usteps>
	
	switch(tipo) 
    2856:	c1 30       	cpi	r28, 0x01	; 1
    2858:	d1 05       	cpc	r29, r1
    285a:	69 f0       	breq	.+26     	; 0x2876 <gradrosTOuPasos+0x46>
    285c:	c2 30       	cpi	r28, 0x02	; 2
    285e:	d1 05       	cpc	r29, r1
    2860:	69 f0       	breq	.+26     	; 0x287c <gradrosTOuPasos+0x4c>
    2862:	cd 2b       	or	r28, r29
    2864:	29 f0       	breq	.+10     	; 0x2870 <gradrosTOuPasos+0x40>
    2866:	2f ef       	ldi	r18, 0xFF	; 255
    2868:	3f ef       	ldi	r19, 0xFF	; 255
    286a:	4f ef       	ldi	r20, 0xFF	; 255
    286c:	5f ef       	ldi	r21, 0xFF	; 255
    286e:	0a c0       	rjmp	.+20     	; 0x2884 <gradrosTOuPasos+0x54>
	{
		case POSICION_TYPE:		
			result=positionPCtoUC(uPasos);  
    2870:	0e 94 0a 14 	call	0x2814	; 0x2814 <positionPCtoUC>
    2874:	05 c0       	rjmp	.+10     	; 0x2880 <gradrosTOuPasos+0x50>
		break;
		case VELOCIDAD_TYPE:
			result=velocityPCtoUC(uPasos);  
    2876:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <velocityPCtoUC>
    287a:	02 c0       	rjmp	.+4      	; 0x2880 <gradrosTOuPasos+0x50>
		break;
		case ACELERACION_TYPE:
			result=accelerationPCtoUC(uPasos);  
    287c:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <accelerationPCtoUC>
    2880:	9b 01       	movw	r18, r22
    2882:	ac 01       	movw	r20, r24
		break;
	}
 
	return result;
}
    2884:	b9 01       	movw	r22, r18
    2886:	ca 01       	movw	r24, r20
    2888:	df 91       	pop	r29
    288a:	cf 91       	pop	r28
    288c:	1f 91       	pop	r17
    288e:	0f 91       	pop	r16
    2890:	08 95       	ret

00002892 <usb_read>:


/*---------------------------Funciones Interface PC-uControlador---------------------------*/

int16 usb_read(uint8 *dato_h,uint8 *dato_l)
{
    2892:	fc 01       	movw	r30, r24
    2894:	db 01       	movw	r26, r22
	uint32 timeout=0xFFFF;
	
	CONTROL_USB_HIGH		=		0x00;					 	//Coloco el puerto L como lectura
    2896:	10 92 07 01 	sts	0x0107, r1
	CONTROL_USB_LOW		=		0x00;					  	//Coloco el puerto K como lectura
    289a:	10 92 0a 01 	sts	0x010A, r1
	
	PORTH		&= ~(_BV(USB_EN));						  	//Habilito el Controlador USB
    289e:	80 91 02 01 	lds	r24, 0x0102
    28a2:	8b 7f       	andi	r24, 0xFB	; 251
    28a4:	80 93 02 01 	sts	0x0102, r24
    28a8:	20 e0       	ldi	r18, 0x00	; 0
    28aa:	30 e0       	ldi	r19, 0x00	; 0
    28ac:	07 c0       	rjmp	.+14     	; 0x28bc <usb_read+0x2a>
	/** Espero a que la seal USB_READY est en Bajo.*/	 
//	loop_until_bit_is_clear(PINH,USB_READY);									
	do
	{
		timeout--;
		if (timeout==0)
    28ae:	8f ef       	ldi	r24, 0xFF	; 255
    28b0:	2e 3f       	cpi	r18, 0xFE	; 254
    28b2:	38 07       	cpc	r19, r24
    28b4:	19 f4       	brne	.+6      	; 0x28bc <usb_read+0x2a>
    28b6:	2a e0       	ldi	r18, 0x0A	; 10
    28b8:	30 e0       	ldi	r19, 0x00	; 0
    28ba:	22 c0       	rjmp	.+68     	; 0x2900 <usb_read+0x6e>
			return rcTimeoutReadingData;
	}
	while(bit_is_set(PINH,USB_READY));	
    28bc:	80 91 00 01 	lds	r24, 0x0100
    28c0:	2f 5f       	subi	r18, 0xFF	; 255
    28c2:	3f 4f       	sbci	r19, 0xFF	; 255
    28c4:	87 fd       	sbrc	r24, 7
    28c6:	f3 cf       	rjmp	.-26     	; 0x28ae <usb_read+0x1c>
	
	PORTH			&= ~(_BV(USB_READ));				  	//Realiza Lectura
    28c8:	80 91 02 01 	lds	r24, 0x0102
    28cc:	8f 7e       	andi	r24, 0xEF	; 239
    28ce:	80 93 02 01 	sts	0x0102, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    28d2:	85 e0       	ldi	r24, 0x05	; 5
    28d4:	8a 95       	dec	r24
    28d6:	f1 f7       	brne	.-4      	; 0x28d4 <usb_read+0x42>
	_delay_us(2);
	
	if(dato_h!=NULL)
    28d8:	30 97       	sbiw	r30, 0x00	; 0
    28da:	19 f0       	breq	.+6      	; 0x28e2 <usb_read+0x50>
	*dato_h	=	DATA_USB_READ_HIGH;         		//leo dato ms significativo en el Puerto
    28dc:	80 91 06 01 	lds	r24, 0x0106
    28e0:	80 83       	st	Z, r24
	*dato_l	=	DATA_USB_READ_LOW;             	//leo dato menos significativo	
    28e2:	80 91 09 01 	lds	r24, 0x0109
    28e6:	8c 93       	st	X, r24
	PORTH 	 		|= _BV(USB_READ);				 	 	//coloco la seal de read en alto	
    28e8:	80 91 02 01 	lds	r24, 0x0102
    28ec:	80 61       	ori	r24, 0x10	; 16
    28ee:	80 93 02 01 	sts	0x0102, r24
	PORTH 	 		|= _BV(USB_EN);					 	//coloco la seal de chip select en alto
    28f2:	80 91 02 01 	lds	r24, 0x0102
    28f6:	84 60       	ori	r24, 0x04	; 4
    28f8:	80 93 02 01 	sts	0x0102, r24
    28fc:	20 e0       	ldi	r18, 0x00	; 0
    28fe:	30 e0       	ldi	r19, 0x00	; 0
	
	return rcOK;
} 
    2900:	c9 01       	movw	r24, r18
    2902:	08 95       	ret

00002904 <usb_write>:
/*----------------------------------------------------------------------------------------------------*/
int16 usb_write(uint8 datoh,uint8 datol)
{
    2904:	98 2f       	mov	r25, r24
	DDRL	=		0xFF;											//Coloco el puerto L como Salida
    2906:	8f ef       	ldi	r24, 0xFF	; 255
    2908:	80 93 0a 01 	sts	0x010A, r24
	DDRK	=		0xFF;											//Coloco el puerto K como Salida
    290c:	80 93 07 01 	sts	0x0107, r24
	//uint32 timeout=0xFFFF;
	
	PORTH		&= ~(_BV(USB_EN));							//Habilito el Controlador USB
    2910:	80 91 02 01 	lds	r24, 0x0102
    2914:	8b 7f       	andi	r24, 0xFB	; 251
    2916:	80 93 02 01 	sts	0x0102, r24
	
	/* Espero a que la seal USB_READY est en Bajo.*/
	
  loop_until_bit_is_clear(PINH,USB_READY);
    291a:	80 91 00 01 	lds	r24, 0x0100
    291e:	87 fd       	sbrc	r24, 7
    2920:	fc cf       	rjmp	.-8      	; 0x291a <usb_write+0x16>
	   if (timeout==0)
	       return rcTimeoutSendingData;
	}while(bit_is_set(PINH,USB_READY));
*/	
	
	DATA_USB_WRITE_HIGH	=	datoh;						//Coloco el Dato mas significativo en el Puerto
    2922:	90 93 08 01 	sts	0x0108, r25
	DATA_USB_WRITE_LOW	=	datol;						//Coloco el Dato menos significativo en el Puerto
    2926:	60 93 0b 01 	sts	0x010B, r22
	PORTH		&= ~(_BV(USB_WRITE));						//Realizo una operacion de Escritura
    292a:	80 91 02 01 	lds	r24, 0x0102
    292e:	87 7f       	andi	r24, 0xF7	; 247
    2930:	80 93 02 01 	sts	0x0102, r24
    2934:	85 e0       	ldi	r24, 0x05	; 5
    2936:	8a 95       	dec	r24
    2938:	f1 f7       	brne	.-4      	; 0x2936 <usb_write+0x32>
	_delay_us(2);
	PORTH 		|= _BV(USB_WRITE);						//coloco la seal de read en alto	
    293a:	80 91 02 01 	lds	r24, 0x0102
    293e:	88 60       	ori	r24, 0x08	; 8
    2940:	80 93 02 01 	sts	0x0102, r24
	PORTH 		|= _BV(USB_EN);							//coloco la seal de chip select en alto
    2944:	80 91 02 01 	lds	r24, 0x0102
    2948:	84 60       	ori	r24, 0x04	; 4
    294a:	80 93 02 01 	sts	0x0102, r24
	return rcOK;
	
} 
    294e:	80 e0       	ldi	r24, 0x00	; 0
    2950:	90 e0       	ldi	r25, 0x00	; 0
    2952:	08 95       	ret

00002954 <Envio_USB>:
/*----------------------------------------------------------------------------------------------------*/  
//Esta funcion envia por los puertos del uC los datos
//Maneja tanto tamaos pares como inpares
 int16 Envio_USB(uint8* Buffer,int16 size)
{
    2954:	ef 92       	push	r14
    2956:	ff 92       	push	r15
    2958:	0f 93       	push	r16
    295a:	1f 93       	push	r17
    295c:	cf 93       	push	r28
    295e:	df 93       	push	r29
    2960:	7b 01       	movw	r14, r22
    2962:	8c 01       	movw	r16, r24
    2964:	c0 e0       	ldi	r28, 0x00	; 0
    2966:	d0 e0       	ldi	r29, 0x00	; 0
	for(j=0;j<size;j++)
		printf("Envio_USB => Buffer[%d]=%X \n",j,Buffer[j]);		   
	#endif
   do
	{
		templ=Buffer[i] ;
    2968:	f8 01       	movw	r30, r16
    296a:	60 81       	ld	r22, Z
		actual=i+1;                    					//actual tiene los impares
		if (actual==size)
    296c:	ce 01       	movw	r24, r28
    296e:	01 96       	adiw	r24, 0x01	; 1
    2970:	8e 15       	cp	r24, r14
    2972:	9f 05       	cpc	r25, r15
    2974:	11 f4       	brne	.+4      	; 0x297a <Envio_USB+0x26>
			rc=usb_write(0x00,templ);     				//he llegado a el final del 
    2976:	80 e0       	ldi	r24, 0x00	; 0
    2978:	02 c0       	rjmp	.+4      	; 0x297e <Envio_USB+0x2a>
														//arreglo donde el tamao es impar
		else
		{  	 
			temph=Buffer[i+1];			
			rc=usb_write(temph,templ);
    297a:	f8 01       	movw	r30, r16
    297c:	81 81       	ldd	r24, Z+1	; 0x01
    297e:	0e 94 82 14 	call	0x2904	; 0x2904 <usb_write>
		}
		i=i+2;
    2982:	22 96       	adiw	r28, 0x02	; 2
    2984:	0e 5f       	subi	r16, 0xFE	; 254
    2986:	1f 4f       	sbci	r17, 0xFF	; 255
		#ifdef DEBUGUSBLevel1
		printf("Envio_USB => i= %d \n",i);
		#endif
	}
	while (i<size); 
    2988:	ce 15       	cp	r28, r14
    298a:	df 05       	cpc	r29, r15
    298c:	6c f3       	brlt	.-38     	; 0x2968 <Envio_USB+0x14>
	#ifdef DEBUGUSBLevel0
		printf("Envio_USB => Saliendo\n");
	#endif
	return rc;
	
}
    298e:	df 91       	pop	r29
    2990:	cf 91       	pop	r28
    2992:	1f 91       	pop	r17
    2994:	0f 91       	pop	r16
    2996:	ff 90       	pop	r15
    2998:	ef 90       	pop	r14
    299a:	08 95       	ret

0000299c <Leo_USB>:
/*----------------------------------------------------------------------------------------------------*/
int16 Leo_USB(uint8* Buffer,int16 size)
{
    299c:	ef 92       	push	r14
    299e:	ff 92       	push	r15
    29a0:	0f 93       	push	r16
    29a2:	1f 93       	push	r17
    29a4:	cf 93       	push	r28
    29a6:	df 93       	push	r29
    29a8:	7b 01       	movw	r14, r22
    29aa:	ec 01       	movw	r28, r24
    29ac:	00 e0       	ldi	r16, 0x00	; 0
    29ae:	10 e0       	ldi	r17, 0x00	; 0
	printf("Leo_USB => Cantida de datos por leer %d \n",size);
	#endif
	do
	{	
		actual=i+1;                    					//actual tiene los impares
		if(actual==size)
    29b0:	c8 01       	movw	r24, r16
    29b2:	01 96       	adiw	r24, 0x01	; 1
    29b4:	8e 15       	cp	r24, r14
    29b6:	9f 05       	cpc	r25, r15
    29b8:	19 f4       	brne	.+6      	; 0x29c0 <Leo_USB+0x24>
			rc=usb_read(NULL,&Buffer[i]);     			//he llegado a el final del 
    29ba:	80 e0       	ldi	r24, 0x00	; 0
    29bc:	90 e0       	ldi	r25, 0x00	; 0
    29be:	02 c0       	rjmp	.+4      	; 0x29c4 <Leo_USB+0x28>
														//arreglo donde el tamao es impar
		else
		rc=usb_read(&Buffer[i+1],&Buffer[i]);				
    29c0:	ce 01       	movw	r24, r28
    29c2:	01 96       	adiw	r24, 0x01	; 1
    29c4:	be 01       	movw	r22, r28
    29c6:	0e 94 49 14 	call	0x2892	; 0x2892 <usb_read>
		i=i+2;
    29ca:	0e 5f       	subi	r16, 0xFE	; 254
    29cc:	1f 4f       	sbci	r17, 0xFF	; 255
    29ce:	22 96       	adiw	r28, 0x02	; 2
	}
	while (i<size); 
    29d0:	0e 15       	cp	r16, r14
    29d2:	1f 05       	cpc	r17, r15
    29d4:	6c f3       	brlt	.-38     	; 0x29b0 <Leo_USB+0x14>
	#ifdef DEBUGUSBLevel2
	for(i=0;i<size;i++)
	printf("Leo_USB => Buffer[%d]=%X \n",i,Buffer[i]);		   
	#endif	
	return rc;
}
    29d6:	df 91       	pop	r29
    29d8:	cf 91       	pop	r28
    29da:	1f 91       	pop	r17
    29dc:	0f 91       	pop	r16
    29de:	ff 90       	pop	r15
    29e0:	ef 90       	pop	r14
    29e2:	08 95       	ret

000029e4 <defaultAxisSettings>:

#endif


 void defaultAxisSettings(int16 axis, tAxisSettings *paxisSettings)
{
    29e4:	cf 93       	push	r28
    29e6:	df 93       	push	r29
    29e8:	9c 01       	movw	r18, r24
    29ea:	eb 01       	movw	r28, r22
//General Settings:
  paxisSettings->axisEnabled = TRUE;      
    29ec:	81 e0       	ldi	r24, 0x01	; 1
    29ee:	88 83       	st	Y, r24
  paxisSettings->interruptEnable=TRUE;
    29f0:	89 83       	std	Y+1, r24	; 0x01
  paxisSettings->switchEnable=TRUE;
    29f2:	41 e0       	ldi	r20, 0x01	; 1
    29f4:	50 e0       	ldi	r21, 0x00	; 0
    29f6:	5b 83       	std	Y+3, r21	; 0x03
    29f8:	4a 83       	std	Y+2, r20	; 0x02
  paxisSettings->encoderEnable=FALSE; 
    29fa:	1d 82       	std	Y+5, r1	; 0x05
    29fc:	1c 82       	std	Y+4, r1	; 0x04
  paxisSettings->ustepsPerStep = 32; //Quiere decir que 32 uP hacen un paso
    29fe:	60 e2       	ldi	r22, 0x20	; 32
    2a00:	70 e0       	ldi	r23, 0x00	; 0
    2a02:	7b 87       	std	Y+11, r23	; 0x0b
    2a04:	6a 87       	std	Y+10, r22	; 0x0a
  paxisSettings->motorStepsPerRevolution = 200;//El angulo de paso es 15 360/15 = 24, oseo que con 24 pasos se tiene una vuelta 
    2a06:	88 ec       	ldi	r24, 0xC8	; 200
    2a08:	90 e0       	ldi	r25, 0x00	; 0
    2a0a:	9d 87       	std	Y+13, r25	; 0x0d
    2a0c:	8c 87       	std	Y+12, r24	; 0x0c
  paxisSettings->encoderStepsPerRevolution = 480;
    2a0e:	80 ee       	ldi	r24, 0xE0	; 224
    2a10:	91 e0       	ldi	r25, 0x01	; 1
    2a12:	9f 87       	std	Y+15, r25	; 0x0f
    2a14:	8e 87       	std	Y+14, r24	; 0x0e
  paxisSettings->ErrorLimit=200;
    2a16:	88 ec       	ldi	r24, 0xC8	; 200
    2a18:	90 e0       	ldi	r25, 0x00	; 0
    2a1a:	a0 e0       	ldi	r26, 0x00	; 0
    2a1c:	b0 e0       	ldi	r27, 0x00	; 0
    2a1e:	88 a3       	std	Y+32, r24	; 0x20
    2a20:	99 a3       	std	Y+33, r25	; 0x21
    2a22:	aa a3       	std	Y+34, r26	; 0x22
    2a24:	bb a3       	std	Y+35, r27	; 0x23
  paxisSettings->TrackingWindow	= 30;
    2a26:	8e e1       	ldi	r24, 0x1E	; 30
    2a28:	90 e0       	ldi	r25, 0x00	; 0
    2a2a:	99 8b       	std	Y+17, r25	; 0x11
    2a2c:	88 8b       	std	Y+16, r24	; 0x10
  paxisSettings->SettleWindow = 22; //
    2a2e:	86 e1       	ldi	r24, 0x16	; 22
    2a30:	90 e0       	ldi	r25, 0x00	; 0
    2a32:	9b 8b       	std	Y+19, r25	; 0x13
    2a34:	8a 8b       	std	Y+18, r24	; 0x12
  paxisSettings->SettleTime	= 833; // 0.5 seg  
    2a36:	81 e4       	ldi	r24, 0x41	; 65
    2a38:	93 e0       	ldi	r25, 0x03	; 3
    2a3a:	9d 8b       	std	Y+21, r25	; 0x15
    2a3c:	8c 8b       	std	Y+20, r24	; 0x14
  paxisSettings->motorPower = 98; // % of full power
    2a3e:	82 e6       	ldi	r24, 0x62	; 98
    2a40:	90 e0       	ldi	r25, 0x00	; 0
    2a42:	9f 8b       	std	Y+23, r25	; 0x17
    2a44:	8e 8b       	std	Y+22, r24	; 0x16
  paxisSettings->numberPhases = 2;
    2a46:	82 e0       	ldi	r24, 0x02	; 2
    2a48:	90 e0       	ldi	r25, 0x00	; 0
    2a4a:	99 8f       	std	Y+25, r25	; 0x19
    2a4c:	88 8f       	std	Y+24, r24	; 0x18
  paxisSettings->limitVelocity = 1310720; //20*65536;    // (2500rpm/60s)*48spr*16usps/1623cycle/s) !! 2500 rmp is close to the limit of the numerical range
    2a4e:	80 e0       	ldi	r24, 0x00	; 0
    2a50:	90 e0       	ldi	r25, 0x00	; 0
    2a52:	a4 e1       	ldi	r26, 0x14	; 20
    2a54:	b0 e0       	ldi	r27, 0x00	; 0
    2a56:	88 a7       	std	Y+40, r24	; 0x28
    2a58:	99 a7       	std	Y+41, r25	; 0x29
    2a5a:	aa a7       	std	Y+42, r26	; 0x2a
    2a5c:	bb a7       	std	Y+43, r27	; 0x2b
  paxisSettings->limitAcceleration = 786; //0.012*65536;  // absolute maximum values which the hardware can do
    2a5e:	82 e1       	ldi	r24, 0x12	; 18
    2a60:	93 e0       	ldi	r25, 0x03	; 3
    2a62:	a0 e0       	ldi	r26, 0x00	; 0
    2a64:	b0 e0       	ldi	r27, 0x00	; 0
    2a66:	8c a3       	std	Y+36, r24	; 0x24
    2a68:	9d a3       	std	Y+37, r25	; 0x25
    2a6a:	ae a3       	std	Y+38, r26	; 0x26
    2a6c:	bf a3       	std	Y+39, r27	; 0x27
  paxisSettings->limitJerk = 128849; //0.00003*4294967296;  // default value for S-curve profile...400 acceleration cycles (0.25s)
    2a6e:	81 e5       	ldi	r24, 0x51	; 81
    2a70:	97 ef       	ldi	r25, 0xF7	; 247
    2a72:	a1 e0       	ldi	r26, 0x01	; 1
    2a74:	b0 e0       	ldi	r27, 0x00	; 0
    2a76:	8c a7       	std	Y+44, r24	; 0x2c
    2a78:	9d a7       	std	Y+45, r25	; 0x2d
    2a7a:	ae a7       	std	Y+46, r26	; 0x2e
    2a7c:	bf a7       	std	Y+47, r27	; 0x2f
  paxisSettings->maxVelocity = 327680; //0.25*paxisSettings->limitVelocity;  // 25% of maximum
    2a7e:	80 e0       	ldi	r24, 0x00	; 0
    2a80:	90 e0       	ldi	r25, 0x00	; 0
    2a82:	a5 e0       	ldi	r26, 0x05	; 5
    2a84:	b0 e0       	ldi	r27, 0x00	; 0
    2a86:	8c ab       	std	Y+52, r24	; 0x34
    2a88:	9d ab       	std	Y+53, r25	; 0x35
    2a8a:	ae ab       	std	Y+54, r26	; 0x36
    2a8c:	bf ab       	std	Y+55, r27	; 0x37
  paxisSettings->minVelocity = 13107; //0.01*paxisSettings->limitVelocity;  // 1%, for initial finding of the limit switches and home position
    2a8e:	83 e3       	ldi	r24, 0x33	; 51
    2a90:	93 e3       	ldi	r25, 0x33	; 51
    2a92:	a0 e0       	ldi	r26, 0x00	; 0
    2a94:	b0 e0       	ldi	r27, 0x00	; 0
    2a96:	88 af       	std	Y+56, r24	; 0x38
    2a98:	99 af       	std	Y+57, r25	; 0x39
    2a9a:	aa af       	std	Y+58, r26	; 0x3a
    2a9c:	bb af       	std	Y+59, r27	; 0x3b
  paxisSettings->maxAcceleration = 197; //0.25*paxisSettings->limitAcceleration; // 25% of maximum
    2a9e:	85 ec       	ldi	r24, 0xC5	; 197
    2aa0:	90 e0       	ldi	r25, 0x00	; 0
    2aa2:	a0 e0       	ldi	r26, 0x00	; 0
    2aa4:	b0 e0       	ldi	r27, 0x00	; 0
    2aa6:	88 ab       	std	Y+48, r24	; 0x30
    2aa8:	99 ab       	std	Y+49, r25	; 0x31
    2aaa:	aa ab       	std	Y+50, r26	; 0x32
    2aac:	bb ab       	std	Y+51, r27	; 0x33
  paxisSettings->homeSwitchHandling = 0; // 3 switches: for neg. limit, pos. limit and home
    2aae:	1b 8e       	std	Y+27, r1	; 0x1b
    2ab0:	1a 8e       	std	Y+26, r1	; 0x1a
  paxisSettings->gearNominator = 1;      // PC needs that to change rad into usteps
    2ab2:	5d 8f       	std	Y+29, r21	; 0x1d
    2ab4:	4c 8f       	std	Y+28, r20	; 0x1c
  paxisSettings->gearDenominator = 1;    // gear=Nominator/Denominator, step=rad*gear*other_stuff
    2ab6:	5f 8f       	std	Y+31, r21	; 0x1f
    2ab8:	4e 8f       	std	Y+30, r20	; 0x1e
  // specific settings:
  switch(axis) 
    2aba:	25 30       	cpi	r18, 0x05	; 5
    2abc:	31 05       	cpc	r19, r1
    2abe:	09 f4       	brne	.+2      	; 0x2ac2 <defaultAxisSettings+0xde>
    2ac0:	78 c1       	rjmp	.+752    	; 0x2db2 <defaultAxisSettings+0x3ce>
    2ac2:	26 30       	cpi	r18, 0x06	; 6
    2ac4:	31 05       	cpc	r19, r1
    2ac6:	c4 f4       	brge	.+48     	; 0x2af8 <defaultAxisSettings+0x114>
    2ac8:	22 30       	cpi	r18, 0x02	; 2
    2aca:	31 05       	cpc	r19, r1
    2acc:	09 f4       	brne	.+2      	; 0x2ad0 <defaultAxisSettings+0xec>
    2ace:	cb c0       	rjmp	.+406    	; 0x2c66 <defaultAxisSettings+0x282>
    2ad0:	23 30       	cpi	r18, 0x03	; 3
    2ad2:	31 05       	cpc	r19, r1
    2ad4:	44 f4       	brge	.+16     	; 0x2ae6 <defaultAxisSettings+0x102>
    2ad6:	21 15       	cp	r18, r1
    2ad8:	31 05       	cpc	r19, r1
    2ada:	59 f1       	breq	.+86     	; 0x2b32 <defaultAxisSettings+0x14e>
    2adc:	21 30       	cpi	r18, 0x01	; 1
    2ade:	31 05       	cpc	r19, r1
    2ae0:	09 f0       	breq	.+2      	; 0x2ae4 <defaultAxisSettings+0x100>
    2ae2:	6b c1       	rjmp	.+726    	; 0x2dba <defaultAxisSettings+0x3d6>
    2ae4:	73 c0       	rjmp	.+230    	; 0x2bcc <defaultAxisSettings+0x1e8>
    2ae6:	23 30       	cpi	r18, 0x03	; 3
    2ae8:	31 05       	cpc	r19, r1
    2aea:	09 f4       	brne	.+2      	; 0x2aee <defaultAxisSettings+0x10a>
    2aec:	05 c1       	rjmp	.+522    	; 0x2cf8 <defaultAxisSettings+0x314>
    2aee:	24 30       	cpi	r18, 0x04	; 4
    2af0:	31 05       	cpc	r19, r1
    2af2:	09 f0       	breq	.+2      	; 0x2af6 <defaultAxisSettings+0x112>
    2af4:	62 c1       	rjmp	.+708    	; 0x2dba <defaultAxisSettings+0x3d6>
    2af6:	2f c1       	rjmp	.+606    	; 0x2d56 <defaultAxisSettings+0x372>
    2af8:	28 30       	cpi	r18, 0x08	; 8
    2afa:	31 05       	cpc	r19, r1
    2afc:	09 f4       	brne	.+2      	; 0x2b00 <defaultAxisSettings+0x11c>
    2afe:	59 c1       	rjmp	.+690    	; 0x2db2 <defaultAxisSettings+0x3ce>
    2b00:	29 30       	cpi	r18, 0x09	; 9
    2b02:	31 05       	cpc	r19, r1
    2b04:	4c f4       	brge	.+18     	; 0x2b18 <defaultAxisSettings+0x134>
    2b06:	26 30       	cpi	r18, 0x06	; 6
    2b08:	31 05       	cpc	r19, r1
    2b0a:	09 f4       	brne	.+2      	; 0x2b0e <defaultAxisSettings+0x12a>
    2b0c:	52 c1       	rjmp	.+676    	; 0x2db2 <defaultAxisSettings+0x3ce>
    2b0e:	27 30       	cpi	r18, 0x07	; 7
    2b10:	31 05       	cpc	r19, r1
    2b12:	09 f0       	breq	.+2      	; 0x2b16 <defaultAxisSettings+0x132>
    2b14:	52 c1       	rjmp	.+676    	; 0x2dba <defaultAxisSettings+0x3d6>
    2b16:	4d c1       	rjmp	.+666    	; 0x2db2 <defaultAxisSettings+0x3ce>
    2b18:	2a 30       	cpi	r18, 0x0A	; 10
    2b1a:	31 05       	cpc	r19, r1
    2b1c:	09 f4       	brne	.+2      	; 0x2b20 <defaultAxisSettings+0x13c>
    2b1e:	49 c1       	rjmp	.+658    	; 0x2db2 <defaultAxisSettings+0x3ce>
    2b20:	2a 30       	cpi	r18, 0x0A	; 10
    2b22:	31 05       	cpc	r19, r1
    2b24:	0c f4       	brge	.+2      	; 0x2b28 <defaultAxisSettings+0x144>
    2b26:	45 c1       	rjmp	.+650    	; 0x2db2 <defaultAxisSettings+0x3ce>
    2b28:	2b 30       	cpi	r18, 0x0B	; 11
    2b2a:	31 05       	cpc	r19, r1
    2b2c:	09 f0       	breq	.+2      	; 0x2b30 <defaultAxisSettings+0x14c>
    2b2e:	45 c1       	rjmp	.+650    	; 0x2dba <defaultAxisSettings+0x3d6>
    2b30:	40 c1       	rjmp	.+640    	; 0x2db2 <defaultAxisSettings+0x3ce>
{
   case AxisWaist:
		paxisSettings->motorStepsPerRevolution = 32;
    2b32:	7d 87       	std	Y+13, r23	; 0x0d
    2b34:	6c 87       	std	Y+12, r22	; 0x0c
		paxisSettings->numberPhases = 3;
    2b36:	83 e0       	ldi	r24, 0x03	; 3
    2b38:	90 e0       	ldi	r25, 0x00	; 0
    2b3a:	99 8f       	std	Y+25, r25	; 0x19
    2b3c:	88 8f       	std	Y+24, r24	; 0x18
		paxisSettings->gearNominator = 9959;      // PC needs that to change rad into usteps
    2b3e:	87 ee       	ldi	r24, 0xE7	; 231
    2b40:	96 e2       	ldi	r25, 0x26	; 38
    2b42:	9d 8f       	std	Y+29, r25	; 0x1d
    2b44:	8c 8f       	std	Y+28, r24	; 0x1c
		paxisSettings->gearDenominator = 1000;	  
    2b46:	88 ee       	ldi	r24, 0xE8	; 232
    2b48:	93 e0       	ldi	r25, 0x03	; 3
    2b4a:	9f 8f       	std	Y+31, r25	; 0x1f
    2b4c:	8e 8f       	std	Y+30, r24	; 0x1e
		paxisSettings->maxVelocity = gradrosTOuPasos(paxisSettings,71.819,VELOCIDAD_TYPE);//80000; 
    2b4e:	ce 01       	movw	r24, r28
    2b50:	44 e5       	ldi	r20, 0x54	; 84
    2b52:	53 ea       	ldi	r21, 0xA3	; 163
    2b54:	6f e8       	ldi	r22, 0x8F	; 143
    2b56:	72 e4       	ldi	r23, 0x42	; 66
    2b58:	21 e0       	ldi	r18, 0x01	; 1
    2b5a:	30 e0       	ldi	r19, 0x00	; 0
    2b5c:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2b60:	6c ab       	std	Y+52, r22	; 0x34
    2b62:	7d ab       	std	Y+53, r23	; 0x35
    2b64:	8e ab       	std	Y+54, r24	; 0x36
    2b66:	9f ab       	std	Y+55, r25	; 0x37
		paxisSettings->minVelocity = gradrosTOuPasos(paxisSettings,53.864,VELOCIDAD_TYPE);//60000; 
    2b68:	ce 01       	movw	r24, r28
    2b6a:	4c eb       	ldi	r20, 0xBC	; 188
    2b6c:	54 e7       	ldi	r21, 0x74	; 116
    2b6e:	67 e5       	ldi	r22, 0x57	; 87
    2b70:	72 e4       	ldi	r23, 0x42	; 66
    2b72:	21 e0       	ldi	r18, 0x01	; 1
    2b74:	30 e0       	ldi	r19, 0x00	; 0
    2b76:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2b7a:	68 af       	std	Y+56, r22	; 0x38
    2b7c:	79 af       	std	Y+57, r23	; 0x39
    2b7e:	8a af       	std	Y+58, r24	; 0x3a
    2b80:	9b af       	std	Y+59, r25	; 0x3b
		paxisSettings->homeVelocity = gradrosTOuPasos(paxisSettings,70,VELOCIDAD_TYPE);//  89111?
    2b82:	ce 01       	movw	r24, r28
    2b84:	40 e0       	ldi	r20, 0x00	; 0
    2b86:	50 e0       	ldi	r21, 0x00	; 0
    2b88:	6c e8       	ldi	r22, 0x8C	; 140
    2b8a:	72 e4       	ldi	r23, 0x42	; 66
    2b8c:	21 e0       	ldi	r18, 0x01	; 1
    2b8e:	30 e0       	ldi	r19, 0x00	; 0
    2b90:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2b94:	6c af       	std	Y+60, r22	; 0x3c
    2b96:	7d af       	std	Y+61, r23	; 0x3d
    2b98:	8e af       	std	Y+62, r24	; 0x3e
    2b9a:	9f af       	std	Y+63, r25	; 0x3f
		paxisSettings->homeAcceleration= gradrosTOuPasos(paxisSettings,59.101,ACELERACION_TYPE); //40; 
    2b9c:	ce 01       	movw	r24, r28
    2b9e:	4d e6       	ldi	r20, 0x6D	; 109
    2ba0:	57 e6       	ldi	r21, 0x67	; 103
    2ba2:	6c e6       	ldi	r22, 0x6C	; 108
    2ba4:	72 e4       	ldi	r23, 0x42	; 66
    2ba6:	22 e0       	ldi	r18, 0x02	; 2
    2ba8:	30 e0       	ldi	r19, 0x00	; 0
    2baa:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2bae:	c0 5c       	subi	r28, 0xC0	; 192
    2bb0:	df 4f       	sbci	r29, 0xFF	; 255
    2bb2:	68 83       	st	Y, r22
    2bb4:	79 83       	std	Y+1, r23	; 0x01
    2bb6:	8a 83       	std	Y+2, r24	; 0x02
    2bb8:	9b 83       	std	Y+3, r25	; 0x03
    2bba:	c0 54       	subi	r28, 0x40	; 64
    2bbc:	d0 40       	sbci	r29, 0x00	; 0
		paxisSettings->maxAxisAngle=122;
    2bbe:	8a e7       	ldi	r24, 0x7A	; 122
    2bc0:	90 e0       	ldi	r25, 0x00	; 0
    2bc2:	9f 83       	std	Y+7, r25	; 0x07
    2bc4:	8e 83       	std	Y+6, r24	; 0x06
		paxisSettings->minAxisAngle=-136;
    2bc6:	88 e7       	ldi	r24, 0x78	; 120
    2bc8:	9f ef       	ldi	r25, 0xFF	; 255
    2bca:	4a c0       	rjmp	.+148    	; 0x2c60 <defaultAxisSettings+0x27c>

    break;
    case AxisShoulder://HOMBRO
		paxisSettings->homeSwitchHandling = -1; // home = neg. limit
    2bcc:	8f ef       	ldi	r24, 0xFF	; 255
    2bce:	9f ef       	ldi	r25, 0xFF	; 255
    2bd0:	9b 8f       	std	Y+27, r25	; 0x1b
    2bd2:	8a 8f       	std	Y+26, r24	; 0x1a
		paxisSettings->gearNominator = 11769;
    2bd4:	89 ef       	ldi	r24, 0xF9	; 249
    2bd6:	9d e2       	ldi	r25, 0x2D	; 45
    2bd8:	9d 8f       	std	Y+29, r25	; 0x1d
    2bda:	8c 8f       	std	Y+28, r24	; 0x1c
		paxisSettings->gearDenominator = 100;
    2bdc:	84 e6       	ldi	r24, 0x64	; 100
    2bde:	90 e0       	ldi	r25, 0x00	; 0
    2be0:	9f 8f       	std	Y+31, r25	; 0x1f
    2be2:	8e 8f       	std	Y+30, r24	; 0x1e
		paxisSettings->maxVelocity = gradrosTOuPasos(paxisSettings,2.6102,VELOCIDAD_TYPE);//214748; 
    2be4:	ce 01       	movw	r24, r28
    2be6:	44 e8       	ldi	r20, 0x84	; 132
    2be8:	5d e0       	ldi	r21, 0x0D	; 13
    2bea:	67 e2       	ldi	r22, 0x27	; 39
    2bec:	70 e4       	ldi	r23, 0x40	; 64
    2bee:	21 e0       	ldi	r18, 0x01	; 1
    2bf0:	30 e0       	ldi	r19, 0x00	; 0
    2bf2:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2bf6:	6c ab       	std	Y+52, r22	; 0x34
    2bf8:	7d ab       	std	Y+53, r23	; 0x35
    2bfa:	8e ab       	std	Y+54, r24	; 0x36
    2bfc:	9f ab       	std	Y+55, r25	; 0x37
		paxisSettings->minVelocity = gradrosTOuPasos(paxisSettings,0.8496,VELOCIDAD_TYPE);//69905; 
    2bfe:	ce 01       	movw	r24, r28
    2c00:	43 e6       	ldi	r20, 0x63	; 99
    2c02:	5f e7       	ldi	r21, 0x7F	; 127
    2c04:	69 e5       	ldi	r22, 0x59	; 89
    2c06:	7f e3       	ldi	r23, 0x3F	; 63
    2c08:	21 e0       	ldi	r18, 0x01	; 1
    2c0a:	30 e0       	ldi	r19, 0x00	; 0
    2c0c:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2c10:	68 af       	std	Y+56, r22	; 0x38
    2c12:	79 af       	std	Y+57, r23	; 0x39
    2c14:	8a af       	std	Y+58, r24	; 0x3a
    2c16:	9b af       	std	Y+59, r25	; 0x3b
	    paxisSettings->homeVelocity = gradrosTOuPasos(paxisSettings,20,VELOCIDAD_TYPE);//2468138?; 
    2c18:	ce 01       	movw	r24, r28
    2c1a:	40 e0       	ldi	r20, 0x00	; 0
    2c1c:	50 e0       	ldi	r21, 0x00	; 0
    2c1e:	60 ea       	ldi	r22, 0xA0	; 160
    2c20:	71 e4       	ldi	r23, 0x41	; 65
    2c22:	21 e0       	ldi	r18, 0x01	; 1
    2c24:	30 e0       	ldi	r19, 0x00	; 0
    2c26:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2c2a:	6c af       	std	Y+60, r22	; 0x3c
    2c2c:	7d af       	std	Y+61, r23	; 0x3d
    2c2e:	8e af       	std	Y+62, r24	; 0x3e
    2c30:	9f af       	std	Y+63, r25	; 0x3f
		paxisSettings->homeAcceleration= gradrosTOuPasos(paxisSettings,9.9974,ACELERACION_TYPE);//494;  
    2c32:	ce 01       	movw	r24, r28
    2c34:	4a e5       	ldi	r20, 0x5A	; 90
    2c36:	55 ef       	ldi	r21, 0xF5	; 245
    2c38:	6f e1       	ldi	r22, 0x1F	; 31
    2c3a:	71 e4       	ldi	r23, 0x41	; 65
    2c3c:	22 e0       	ldi	r18, 0x02	; 2
    2c3e:	30 e0       	ldi	r19, 0x00	; 0
    2c40:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2c44:	c0 5c       	subi	r28, 0xC0	; 192
    2c46:	df 4f       	sbci	r29, 0xFF	; 255
    2c48:	68 83       	st	Y, r22
    2c4a:	79 83       	std	Y+1, r23	; 0x01
    2c4c:	8a 83       	std	Y+2, r24	; 0x02
    2c4e:	9b 83       	std	Y+3, r25	; 0x03
    2c50:	c0 54       	subi	r28, 0x40	; 64
    2c52:	d0 40       	sbci	r29, 0x00	; 0
		paxisSettings->maxAxisAngle=10;
    2c54:	8a e0       	ldi	r24, 0x0A	; 10
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	9f 83       	std	Y+7, r25	; 0x07
    2c5a:	8e 83       	std	Y+6, r24	; 0x06
		paxisSettings->minAxisAngle=-140;
    2c5c:	84 e7       	ldi	r24, 0x74	; 116
    2c5e:	9f ef       	ldi	r25, 0xFF	; 255
    2c60:	99 87       	std	Y+9, r25	; 0x09
    2c62:	88 87       	std	Y+8, r24	; 0x08
    2c64:	aa c0       	rjmp	.+340    	; 0x2dba <defaultAxisSettings+0x3d6>
		
    break;
    case AxisElbow://CODO
		paxisSettings->homeSwitchHandling = 1; // home = rigth. limit
    2c66:	5b 8f       	std	Y+27, r21	; 0x1b
    2c68:	4a 8f       	std	Y+26, r20	; 0x1a
		paxisSettings->gearNominator = 11805;//11805//11768;//11955;  //12105;
    2c6a:	8d e1       	ldi	r24, 0x1D	; 29
    2c6c:	9e e2       	ldi	r25, 0x2E	; 46
    2c6e:	9d 8f       	std	Y+29, r25	; 0x1d
    2c70:	8c 8f       	std	Y+28, r24	; 0x1c
		paxisSettings->gearDenominator = 100;
    2c72:	84 e6       	ldi	r24, 0x64	; 100
    2c74:	90 e0       	ldi	r25, 0x00	; 0
    2c76:	9f 8f       	std	Y+31, r25	; 0x1f
    2c78:	8e 8f       	std	Y+30, r24	; 0x1e
		paxisSettings->maxVelocity = gradrosTOuPasos(paxisSettings,1.2117,VELOCIDAD_TYPE);//100000; 
    2c7a:	ce 01       	movw	r24, r28
    2c7c:	4c ef       	ldi	r20, 0xFC	; 252
    2c7e:	58 e1       	ldi	r21, 0x18	; 24
    2c80:	6b e9       	ldi	r22, 0x9B	; 155
    2c82:	7f e3       	ldi	r23, 0x3F	; 63
    2c84:	21 e0       	ldi	r18, 0x01	; 1
    2c86:	30 e0       	ldi	r19, 0x00	; 0
    2c88:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2c8c:	6c ab       	std	Y+52, r22	; 0x34
    2c8e:	7d ab       	std	Y+53, r23	; 0x35
    2c90:	8e ab       	std	Y+54, r24	; 0x36
    2c92:	9f ab       	std	Y+55, r25	; 0x37
		paxisSettings->minVelocity = gradrosTOuPasos(paxisSettings,0.5965,VELOCIDAD_TYPE);//49231; 
    2c94:	ce 01       	movw	r24, r28
    2c96:	49 e3       	ldi	r20, 0x39	; 57
    2c98:	54 eb       	ldi	r21, 0xB4	; 180
    2c9a:	68 e1       	ldi	r22, 0x18	; 24
    2c9c:	7f e3       	ldi	r23, 0x3F	; 63
    2c9e:	21 e0       	ldi	r18, 0x01	; 1
    2ca0:	30 e0       	ldi	r19, 0x00	; 0
    2ca2:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2ca6:	68 af       	std	Y+56, r22	; 0x38
    2ca8:	79 af       	std	Y+57, r23	; 0x39
    2caa:	8a af       	std	Y+58, r24	; 0x3a
    2cac:	9b af       	std	Y+59, r25	; 0x3b
		paxisSettings->homeVelocity = gradrosTOuPasos(paxisSettings,20,VELOCIDAD_TYPE);//2475688?; 
    2cae:	ce 01       	movw	r24, r28
    2cb0:	40 e0       	ldi	r20, 0x00	; 0
    2cb2:	50 e0       	ldi	r21, 0x00	; 0
    2cb4:	60 ea       	ldi	r22, 0xA0	; 160
    2cb6:	71 e4       	ldi	r23, 0x41	; 65
    2cb8:	21 e0       	ldi	r18, 0x01	; 1
    2cba:	30 e0       	ldi	r19, 0x00	; 0
    2cbc:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2cc0:	6c af       	std	Y+60, r22	; 0x3c
    2cc2:	7d af       	std	Y+61, r23	; 0x3d
    2cc4:	8e af       	std	Y+62, r24	; 0x3e
    2cc6:	9f af       	std	Y+63, r25	; 0x3f
		paxisSettings->homeAcceleration= gradrosTOuPasos(paxisSettings,9.9871,ACELERACION_TYPE);//495;  
    2cc8:	ce 01       	movw	r24, r28
    2cca:	49 e2       	ldi	r20, 0x29	; 41
    2ccc:	5b ec       	ldi	r21, 0xCB	; 203
    2cce:	6f e1       	ldi	r22, 0x1F	; 31
    2cd0:	71 e4       	ldi	r23, 0x41	; 65
    2cd2:	22 e0       	ldi	r18, 0x02	; 2
    2cd4:	30 e0       	ldi	r19, 0x00	; 0
    2cd6:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2cda:	c0 5c       	subi	r28, 0xC0	; 192
    2cdc:	df 4f       	sbci	r29, 0xFF	; 255
    2cde:	68 83       	st	Y, r22
    2ce0:	79 83       	std	Y+1, r23	; 0x01
    2ce2:	8a 83       	std	Y+2, r24	; 0x02
    2ce4:	9b 83       	std	Y+3, r25	; 0x03
    2ce6:	c0 54       	subi	r28, 0x40	; 64
    2ce8:	d0 40       	sbci	r29, 0x00	; 0
		paxisSettings->maxAxisAngle=120;
    2cea:	88 e7       	ldi	r24, 0x78	; 120
    2cec:	90 e0       	ldi	r25, 0x00	; 0
    2cee:	9f 83       	std	Y+7, r25	; 0x07
    2cf0:	8e 83       	std	Y+6, r24	; 0x06
		paxisSettings->minAxisAngle=-126;
    2cf2:	82 e8       	ldi	r24, 0x82	; 130
    2cf4:	9f ef       	ldi	r25, 0xFF	; 255
    2cf6:	b4 cf       	rjmp	.-152    	; 0x2c60 <defaultAxisSettings+0x27c>
		//paxisSettings->ustepsPerStep = 128;
		
    break;
    case AxisPitch://PITCH
		paxisSettings->homeSwitchHandling = 1; // home = rigth. limit
    2cf8:	5b 8f       	std	Y+27, r21	; 0x1b
    2cfa:	4a 8f       	std	Y+26, r20	; 0x1a
		paxisSettings->gearNominator = 20256;
    2cfc:	80 e2       	ldi	r24, 0x20	; 32
    2cfe:	9f e4       	ldi	r25, 0x4F	; 79
    2d00:	9d 8f       	std	Y+29, r25	; 0x1d
    2d02:	8c 8f       	std	Y+28, r24	; 0x1c
		paxisSettings->gearDenominator = 10000;// PC needs that to change rad into usteps
    2d04:	80 e1       	ldi	r24, 0x10	; 16
    2d06:	97 e2       	ldi	r25, 0x27	; 39
    2d08:	9f 8f       	std	Y+31, r25	; 0x1f
    2d0a:	8e 8f       	std	Y+30, r24	; 0x1e
		paxisSettings->homeVelocity = gradrosTOuPasos(paxisSettings,76.3825,VELOCIDAD_TYPE);//108158; // 20 deg/seg
    2d0c:	ce 01       	movw	r24, r28
    2d0e:	47 ed       	ldi	r20, 0xD7	; 215
    2d10:	53 ec       	ldi	r21, 0xC3	; 195
    2d12:	68 e9       	ldi	r22, 0x98	; 152
    2d14:	72 e4       	ldi	r23, 0x42	; 66
    2d16:	21 e0       	ldi	r18, 0x01	; 1
    2d18:	30 e0       	ldi	r19, 0x00	; 0
    2d1a:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2d1e:	6c af       	std	Y+60, r22	; 0x3c
    2d20:	7d af       	std	Y+61, r23	; 0x3d
    2d22:	8e af       	std	Y+62, r24	; 0x3e
    2d24:	9f af       	std	Y+63, r25	; 0x3f
		paxisSettings->homeAcceleration= gradrosTOuPasos(paxisSettings,57.0858,ACELERACION_TYPE);//49;  // 30 deg/seg2
    2d26:	ce 01       	movw	r24, r28
    2d28:	4c ed       	ldi	r20, 0xDC	; 220
    2d2a:	57 e5       	ldi	r21, 0x57	; 87
    2d2c:	64 e6       	ldi	r22, 0x64	; 100
    2d2e:	72 e4       	ldi	r23, 0x42	; 66
    2d30:	22 e0       	ldi	r18, 0x02	; 2
    2d32:	30 e0       	ldi	r19, 0x00	; 0
    2d34:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2d38:	c0 5c       	subi	r28, 0xC0	; 192
    2d3a:	df 4f       	sbci	r29, 0xFF	; 255
    2d3c:	68 83       	st	Y, r22
    2d3e:	79 83       	std	Y+1, r23	; 0x01
    2d40:	8a 83       	std	Y+2, r24	; 0x02
    2d42:	9b 83       	std	Y+3, r25	; 0x03
    2d44:	c0 54       	subi	r28, 0x40	; 64
    2d46:	d0 40       	sbci	r29, 0x00	; 0
		paxisSettings->maxAxisAngle=174;
    2d48:	8e ea       	ldi	r24, 0xAE	; 174
    2d4a:	90 e0       	ldi	r25, 0x00	; 0
    2d4c:	9f 83       	std	Y+7, r25	; 0x07
    2d4e:	8e 83       	std	Y+6, r24	; 0x06
		paxisSettings->minAxisAngle=-20;
    2d50:	8c ee       	ldi	r24, 0xEC	; 236
    2d52:	9f ef       	ldi	r25, 0xFF	; 255
    2d54:	85 cf       	rjmp	.-246    	; 0x2c60 <defaultAxisSettings+0x27c>
    break;
    case AxisRoll:
     	paxisSettings->interruptEnable= FALSE;
    2d56:	19 82       	std	Y+1, r1	; 0x01
		paxisSettings->gearNominator = 1327;
    2d58:	8f e2       	ldi	r24, 0x2F	; 47
    2d5a:	95 e0       	ldi	r25, 0x05	; 5
    2d5c:	9d 8f       	std	Y+29, r25	; 0x1d
    2d5e:	8c 8f       	std	Y+28, r24	; 0x1c
		paxisSettings->gearDenominator = 1000;// PC needs that to change rad into usteps
    2d60:	88 ee       	ldi	r24, 0xE8	; 232
    2d62:	93 e0       	ldi	r25, 0x03	; 3
    2d64:	9f 8f       	std	Y+31, r25	; 0x1f
    2d66:	8e 8f       	std	Y+30, r24	; 0x1e
		paxisSettings->homeVelocity = gradrosTOuPasos(paxisSettings,119.998,VELOCIDAD_TYPE);//111316; // 30 deg/seg
    2d68:	ce 01       	movw	r24, r28
    2d6a:	4a ef       	ldi	r20, 0xFA	; 250
    2d6c:	5e ef       	ldi	r21, 0xFE	; 254
    2d6e:	6f ee       	ldi	r22, 0xEF	; 239
    2d70:	72 e4       	ldi	r23, 0x42	; 66
    2d72:	21 e0       	ldi	r18, 0x01	; 1
    2d74:	30 e0       	ldi	r19, 0x00	; 0
    2d76:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2d7a:	6c af       	std	Y+60, r22	; 0x3c
    2d7c:	7d af       	std	Y+61, r23	; 0x3d
    2d7e:	8e af       	std	Y+62, r24	; 0x3e
    2d80:	9f af       	std	Y+63, r25	; 0x3f
		paxisSettings->homeAcceleration= gradrosTOuPasos(paxisSettings,58.3918,ACELERACION_TYPE);//33;  // 30 deg/seg2
    2d82:	ce 01       	movw	r24, r28
    2d84:	44 e3       	ldi	r20, 0x34	; 52
    2d86:	51 e9       	ldi	r21, 0x91	; 145
    2d88:	69 e6       	ldi	r22, 0x69	; 105
    2d8a:	72 e4       	ldi	r23, 0x42	; 66
    2d8c:	22 e0       	ldi	r18, 0x02	; 2
    2d8e:	30 e0       	ldi	r19, 0x00	; 0
    2d90:	0e 94 18 14 	call	0x2830	; 0x2830 <gradrosTOuPasos>
    2d94:	c0 5c       	subi	r28, 0xC0	; 192
    2d96:	df 4f       	sbci	r29, 0xFF	; 255
    2d98:	68 83       	st	Y, r22
    2d9a:	79 83       	std	Y+1, r23	; 0x01
    2d9c:	8a 83       	std	Y+2, r24	; 0x02
    2d9e:	9b 83       	std	Y+3, r25	; 0x03
    2da0:	c0 54       	subi	r28, 0x40	; 64
    2da2:	d0 40       	sbci	r29, 0x00	; 0
		paxisSettings->maxAxisAngle=360;
    2da4:	88 e6       	ldi	r24, 0x68	; 104
    2da6:	91 e0       	ldi	r25, 0x01	; 1
    2da8:	9f 83       	std	Y+7, r25	; 0x07
    2daa:	8e 83       	std	Y+6, r24	; 0x06
		paxisSettings->minAxisAngle=0;
    2dac:	19 86       	std	Y+9, r1	; 0x09
    2dae:	18 86       	std	Y+8, r1	; 0x08
    2db0:	04 c0       	rjmp	.+8      	; 0x2dba <defaultAxisSettings+0x3d6>
		paxisSettings->axisEnabled = FALSE;
		paxisSettings->interruptEnable= FALSE;
		paxisSettings->encoderEnable=FALSE; 
    break;
    case AxisAux7:
		paxisSettings->axisEnabled = FALSE;
    2db2:	18 82       	st	Y, r1
		paxisSettings->interruptEnable= FALSE;
    2db4:	19 82       	std	Y+1, r1	; 0x01
		paxisSettings->encoderEnable=FALSE; 
    2db6:	1d 82       	std	Y+5, r1	; 0x05
    2db8:	1c 82       	std	Y+4, r1	; 0x04
    break;
  } // switch
}// defaultAxisSettings
    2dba:	df 91       	pop	r29
    2dbc:	cf 91       	pop	r28
    2dbe:	08 95       	ret

00002dc0 <setupAxisSettings>:

/*****************************************************************************************/
void setupAxisSettings(tAxisSettings *axisSettings) 
{
    2dc0:	0f 93       	push	r16
    2dc2:	1f 93       	push	r17
    2dc4:	cf 93       	push	r28
    2dc6:	df 93       	push	r29
    2dc8:	8c 01       	movw	r16, r24
    2dca:	c0 e0       	ldi	r28, 0x00	; 0
    2dcc:	d0 e0       	ldi	r29, 0x00	; 0
  int16 i;

  for(i=0; i<DOF; i++) 
  {
    defaultAxisSettings(i,&(axisSettings[i]));
    2dce:	ce 01       	movw	r24, r28
    2dd0:	b8 01       	movw	r22, r16
    2dd2:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <defaultAxisSettings>
/*****************************************************************************************/
void setupAxisSettings(tAxisSettings *axisSettings) 
{
  int16 i;

  for(i=0; i<DOF; i++) 
    2dd6:	21 96       	adiw	r28, 0x01	; 1
    2dd8:	0c 5b       	subi	r16, 0xBC	; 188
    2dda:	1f 4f       	sbci	r17, 0xFF	; 255
    2ddc:	c5 30       	cpi	r28, 0x05	; 5
    2dde:	d1 05       	cpc	r29, r1
    2de0:	b1 f7       	brne	.-20     	; 0x2dce <setupAxisSettings+0xe>
  {
    defaultAxisSettings(i,&(axisSettings[i]));
  }
} // setupAxisHandles
    2de2:	df 91       	pop	r29
    2de4:	cf 91       	pop	r28
    2de6:	1f 91       	pop	r17
    2de8:	0f 91       	pop	r16
    2dea:	08 95       	ret

00002dec <initPacketIO>:

/*****************************************************************************************/
void initPacketIO(void) 
{
// initialize min and max fields for data tests (due to compiler problem with initialized structures)
	minPacketData[PacketNOP] = 0;
    2dec:	10 92 47 30 	sts	0x3047, r1
    2df0:	10 92 46 30 	sts	0x3046, r1
	minPacketData[PacketCommand] = sizeof(tCommand);
    2df4:	8b e1       	ldi	r24, 0x1B	; 27
    2df6:	90 e0       	ldi	r25, 0x00	; 0
    2df8:	90 93 49 30 	sts	0x3049, r25
    2dfc:	80 93 48 30 	sts	0x3048, r24
	minPacketData[PacketVector] = 0;
    2e00:	10 92 4b 30 	sts	0x304B, r1
    2e04:	10 92 4a 30 	sts	0x304A, r1
	minPacketData[PacketFecha] = 0;
    2e08:	10 92 5b 30 	sts	0x305B, r1
    2e0c:	10 92 5a 30 	sts	0x305A, r1
	minPacketData[PacketTrajectory] = sizeof(tTrajectory);
    2e10:	86 e0       	ldi	r24, 0x06	; 6
    2e12:	90 e0       	ldi	r25, 0x00	; 0
    2e14:	90 93 4d 30 	sts	0x304D, r25
    2e18:	80 93 4c 30 	sts	0x304C, r24
	minPacketData[PacketString] = 1;
    2e1c:	81 e0       	ldi	r24, 0x01	; 1
    2e1e:	90 e0       	ldi	r25, 0x00	; 0
    2e20:	90 93 51 30 	sts	0x3051, r25
    2e24:	80 93 50 30 	sts	0x3050, r24
	minPacketData[PacketAxisSettings] = sizeof(PacketAxisSettings);
    2e28:	22 e0       	ldi	r18, 0x02	; 2
    2e2a:	30 e0       	ldi	r19, 0x00	; 0
    2e2c:	30 93 53 30 	sts	0x3053, r19
    2e30:	20 93 52 30 	sts	0x3052, r18
	minPacketData[PacketAxisLimits] =sizeof(PacketAxisLimits);
    2e34:	30 93 55 30 	sts	0x3055, r19
    2e38:	20 93 54 30 	sts	0x3054, r18
	minPacketData[PacketHeader] =sizeof(tPacketHeader);
    2e3c:	88 e0       	ldi	r24, 0x08	; 8
    2e3e:	90 e0       	ldi	r25, 0x00	; 0
    2e40:	90 93 57 30 	sts	0x3057, r25
    2e44:	80 93 56 30 	sts	0x3056, r24
	minPacketData[Packetuint16] =sizeof(uint16);
    2e48:	30 93 61 30 	sts	0x3061, r19
    2e4c:	20 93 60 30 	sts	0x3060, r18
} // initPacketIO
    2e50:	08 95       	ret

00002e52 <calcChecksum>:

/*****************************************************************************************/
tDataChecksum calcChecksum(tDataLength length, uint8* pdata,tDataType dataType) 
{
    2e52:	0f 93       	push	r16
    2e54:	1f 93       	push	r17
    2e56:	cf 93       	push	r28
    2e58:	df 93       	push	r29
    2e5a:	8c 01       	movw	r16, r24
    2e5c:	eb 01       	movw	r28, r22
   tDataLength i;
   tDataChecksum sum = 0;
	tTrajectory *pTrajectory;
	int16 fin;

   if(dataType==PacketTrajectory || dataType==PacketTeachPendant)   
    2e5e:	ca 01       	movw	r24, r20
    2e60:	03 97       	sbiw	r24, 0x03	; 3
    2e62:	02 97       	sbiw	r24, 0x02	; 2
    2e64:	18 f5       	brcc	.+70     	; 0x2eac <calcChecksum+0x5a>
    2e66:	20 e0       	ldi	r18, 0x00	; 0
    2e68:	30 e0       	ldi	r19, 0x00	; 0
    2e6a:	a0 e0       	ldi	r26, 0x00	; 0
    2e6c:	b0 e0       	ldi	r27, 0x00	; 0
   {
        pTrajectory=(tTrajectory *)pdata;        
		//sumo los 4 primeros bytes osea los dos campos int16 (campos size e invalidMask).
		for(i=0; i<4; i++) 
			sum= sum+(tDataChecksum)pdata[i];      
    2e6e:	fe 01       	movw	r30, r28
    2e70:	e2 0f       	add	r30, r18
    2e72:	f3 1f       	adc	r31, r19
    2e74:	80 81       	ld	r24, Z
    2e76:	a8 0f       	add	r26, r24
    2e78:	b1 1d       	adc	r27, r1

   if(dataType==PacketTrajectory || dataType==PacketTeachPendant)   
   {
        pTrajectory=(tTrajectory *)pdata;        
		//sumo los 4 primeros bytes osea los dos campos int16 (campos size e invalidMask).
		for(i=0; i<4; i++) 
    2e7a:	2f 5f       	subi	r18, 0xFF	; 255
    2e7c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e7e:	24 30       	cpi	r18, 0x04	; 4
    2e80:	31 05       	cpc	r19, r1
    2e82:	a9 f7       	brne	.-22     	; 0x2e6e <calcChecksum+0x1c>
			sum= sum+(tDataChecksum)pdata[i];      
		//apunto al lo que apunta el apuntador point  
		pdata = (uint8*)pTrajectory->point;       
    2e84:	6c 81       	ldd	r22, Y+4	; 0x04
    2e86:	7d 81       	ldd	r23, Y+5	; 0x05
    2e88:	20 e0       	ldi	r18, 0x00	; 0
    2e8a:	30 e0       	ldi	r19, 0x00	; 0
		//sumo todos los bytes pero a la longitud length le resto 
		//los dos campos int16 osea cuatro bytes que ya sume
		for(i=0; i<(length-4); i++) 
    2e8c:	a8 01       	movw	r20, r16
    2e8e:	44 50       	subi	r20, 0x04	; 4
    2e90:	50 40       	sbci	r21, 0x00	; 0
    2e92:	08 c0       	rjmp	.+16     	; 0x2ea4 <calcChecksum+0x52>
			sum= sum+(tDataChecksum)pdata[i];     
    2e94:	fb 01       	movw	r30, r22
    2e96:	e2 0f       	add	r30, r18
    2e98:	f3 1f       	adc	r31, r19
    2e9a:	80 81       	ld	r24, Z
    2e9c:	a8 0f       	add	r26, r24
    2e9e:	b1 1d       	adc	r27, r1
			sum= sum+(tDataChecksum)pdata[i];      
		//apunto al lo que apunta el apuntador point  
		pdata = (uint8*)pTrajectory->point;       
		//sumo todos los bytes pero a la longitud length le resto 
		//los dos campos int16 osea cuatro bytes que ya sume
		for(i=0; i<(length-4); i++) 
    2ea0:	2f 5f       	subi	r18, 0xFF	; 255
    2ea2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ea4:	24 17       	cp	r18, r20
    2ea6:	35 07       	cpc	r19, r21
    2ea8:	ac f3       	brlt	.-22     	; 0x2e94 <calcChecksum+0x42>
    2eaa:	2a c0       	rjmp	.+84     	; 0x2f00 <calcChecksum+0xae>
			sum= sum+(tDataChecksum)pdata[i];     
		return sum;
	} 
	if(dataType==PacketHeader)
    2eac:	48 30       	cpi	r20, 0x08	; 8
    2eae:	51 05       	cpc	r21, r1
    2eb0:	29 f0       	breq	.+10     	; 0x2ebc <calcChecksum+0x6a>
    2eb2:	20 e0       	ldi	r18, 0x00	; 0
    2eb4:	30 e0       	ldi	r19, 0x00	; 0
    2eb6:	a0 e0       	ldi	r26, 0x00	; 0
    2eb8:	b0 e0       	ldi	r27, 0x00	; 0
    2eba:	18 c0       	rjmp	.+48     	; 0x2eec <calcChecksum+0x9a>
    2ebc:	20 e0       	ldi	r18, 0x00	; 0
    2ebe:	30 e0       	ldi	r19, 0x00	; 0
    2ec0:	a0 e0       	ldi	r26, 0x00	; 0
    2ec2:	b0 e0       	ldi	r27, 0x00	; 0
		da como resultado un numero mayor y DIFERENTE!
		sizeof(tHeaderChecksum) = 8 byte		
		por lo tanto se suma todo menos un byte (que es el que corresponde con el campo Checksum)*/
		fin=sizeof(tPacketHeader)-sizeof(tHeaderChecksum);
		for(i=0; i<fin; i++)   
			sum += (tHeaderChecksum)pdata[i];
    2ec4:	fe 01       	movw	r30, r28
    2ec6:	e2 0f       	add	r30, r18
    2ec8:	f3 1f       	adc	r31, r19
    2eca:	80 81       	ld	r24, Z
    2ecc:	a8 0f       	add	r26, r24
    2ece:	b1 1d       	adc	r27, r1
		cero. Por lo tanto cuando se recalcula este para la trama recibida 
		da como resultado un numero mayor y DIFERENTE!
		sizeof(tHeaderChecksum) = 8 byte		
		por lo tanto se suma todo menos un byte (que es el que corresponde con el campo Checksum)*/
		fin=sizeof(tPacketHeader)-sizeof(tHeaderChecksum);
		for(i=0; i<fin; i++)   
    2ed0:	2f 5f       	subi	r18, 0xFF	; 255
    2ed2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ed4:	26 30       	cpi	r18, 0x06	; 6
    2ed6:	31 05       	cpc	r19, r1
    2ed8:	a9 f7       	brne	.-22     	; 0x2ec4 <calcChecksum+0x72>
    2eda:	12 c0       	rjmp	.+36     	; 0x2f00 <calcChecksum+0xae>
			sum += (tHeaderChecksum)pdata[i];
		return sum; 
    }	
	//calquier otro paquete de datos	
      for(i=0; i<length; i++) 
          sum = sum + (tDataChecksum)pdata[i];  //calquier otro paquete de datos	
    2edc:	fe 01       	movw	r30, r28
    2ede:	e2 0f       	add	r30, r18
    2ee0:	f3 1f       	adc	r31, r19
    2ee2:	80 81       	ld	r24, Z
    2ee4:	a8 0f       	add	r26, r24
    2ee6:	b1 1d       	adc	r27, r1
		for(i=0; i<fin; i++)   
			sum += (tHeaderChecksum)pdata[i];
		return sum; 
    }	
	//calquier otro paquete de datos	
      for(i=0; i<length; i++) 
    2ee8:	2f 5f       	subi	r18, 0xFF	; 255
    2eea:	3f 4f       	sbci	r19, 0xFF	; 255
    2eec:	20 17       	cp	r18, r16
    2eee:	31 07       	cpc	r19, r17
    2ef0:	ac f3       	brlt	.-22     	; 0x2edc <calcChecksum+0x8a>
          printf("calcChecksum => (tDataChecksum)pdata[%d]=%X \n",i,(tDataChecksum)pdata[i]);
	#endif
	#ifdef DEBUGUSBLevel1
	printf("calcChecksum => cksum %X del paquete %s \n",sum,PacketMsg(dataType));							    
	#endif
	if(dataType==Packetuint16) //Este paquete puede contener como dato un cero, el significa pose no valida.
    2ef2:	4d 30       	cpi	r20, 0x0D	; 13
    2ef4:	51 05       	cpc	r21, r1
    2ef6:	21 f4       	brne	.+8      	; 0x2f00 <calcChecksum+0xae>
	{		
		if(sum==0)
    2ef8:	10 97       	sbiw	r26, 0x00	; 0
    2efa:	11 f4       	brne	.+4      	; 0x2f00 <calcChecksum+0xae>
    2efc:	a1 e0       	ldi	r26, 0x01	; 1
    2efe:	b0 e0       	ldi	r27, 0x00	; 0
			sum=1;
    }

	return sum;
} // calcChecksum
    2f00:	cd 01       	movw	r24, r26
    2f02:	df 91       	pop	r29
    2f04:	cf 91       	pop	r28
    2f06:	1f 91       	pop	r17
    2f08:	0f 91       	pop	r16
    2f0a:	08 95       	ret

00002f0c <checksumOk>:

/*****************************************************************************************/
int16 checksumOk (tDataLength length, uint8* data, tDataChecksum checksum,tDataType dataType) 
{
    2f0c:	cf 93       	push	r28
    2f0e:	df 93       	push	r29
    2f10:	ea 01       	movw	r28, r20
	tHeaderChecksum testh;
  
	if(dataType==PacketHeader)
    2f12:	28 30       	cpi	r18, 0x08	; 8
    2f14:	31 05       	cpc	r19, r1
    2f16:	19 f4       	brne	.+6      	; 0x2f1e <checksumOk+0x12>
	{
		testh=(tHeaderChecksum)calcChecksum(length,data,dataType);
    2f18:	48 e0       	ldi	r20, 0x08	; 8
    2f1a:	50 e0       	ldi	r21, 0x00	; 0
    2f1c:	01 c0       	rjmp	.+2      	; 0x2f20 <checksumOk+0x14>
			#endif  
			return TRUE;
		}
	}
	else
    if(calcChecksum(length,data,dataType) == checksum)
    2f1e:	a9 01       	movw	r20, r18
    2f20:	0e 94 29 17 	call	0x2e52	; 0x2e52 <calcChecksum>
    2f24:	20 e0       	ldi	r18, 0x00	; 0
    2f26:	30 e0       	ldi	r19, 0x00	; 0
    2f28:	8c 17       	cp	r24, r28
    2f2a:	9d 07       	cpc	r25, r29
    2f2c:	11 f4       	brne	.+4      	; 0x2f32 <checksumOk+0x26>
    2f2e:	21 e0       	ldi	r18, 0x01	; 1
    2f30:	30 e0       	ldi	r19, 0x00	; 0
    2f32:	c9 01       	movw	r24, r18
	}
	#ifdef DEBUGUSBLevel1
	printf("checksumOk=> Error CheckSum en PacketHeader = %X  \n",checksum);							    
	#endif  
	return FALSE;
} // checksumOk
    2f34:	df 91       	pop	r29
    2f36:	cf 91       	pop	r28
    2f38:	08 95       	ret

00002f3a <readPacketHeaderRX>:

/*****************************************************************************************/
// Nota: Se llama initPacketIO() antes de usar readPacketHeaderRX para inicializar 
// la longitud de minima para cada tipo de paquete
int16 readPacketHeaderRX(tPacketHeader *ppacketHeader) 
{
    2f3a:	cf 93       	push	r28
    2f3c:	df 93       	push	r29
    2f3e:	ec 01       	movw	r28, r24
	int16 i;
	uint8 *pdata;   
	
	pdata = (uint8*)ppacketHeader;					 
    2f40:	bc 01       	movw	r22, r24
    2f42:	20 e0       	ldi	r18, 0x00	; 0
    2f44:	30 e0       	ldi	r19, 0x00	; 0
    2f46:	0d c0       	rjmp	.+26     	; 0x2f62 <readPacketHeaderRX+0x28>
	//se lee 8 bytes del buffer de datos para obtener el header
	for(i=0; i<sizeof(tPacketHeader); i++) 	
		pdata[i]=RXBUFFER[i];						 
    2f48:	fe 01       	movw	r30, r28
    2f4a:	e2 0f       	add	r30, r18
    2f4c:	f3 1f       	adc	r31, r19
    2f4e:	a0 91 16 82 	lds	r26, 0x8216
    2f52:	b0 91 17 82 	lds	r27, 0x8217
    2f56:	a2 0f       	add	r26, r18
    2f58:	b3 1f       	adc	r27, r19
    2f5a:	8c 91       	ld	r24, X
    2f5c:	80 83       	st	Z, r24
	int16 i;
	uint8 *pdata;   
	
	pdata = (uint8*)ppacketHeader;					 
	//se lee 8 bytes del buffer de datos para obtener el header
	for(i=0; i<sizeof(tPacketHeader); i++) 	
    2f5e:	2f 5f       	subi	r18, 0xFF	; 255
    2f60:	3f 4f       	sbci	r19, 0xFF	; 255
    2f62:	28 30       	cpi	r18, 0x08	; 8
    2f64:	31 05       	cpc	r19, r1
    2f66:	81 f7       	brne	.-32     	; 0x2f48 <readPacketHeaderRX+0xe>
		pdata[i]=RXBUFFER[i];						 
	//deteccion de errores
	// A el tipo de paquete le corresponde un numero  
	// este tiene que estar dentro el rango PacketNOP = 0 y PacketHeader = 13
	if( ( (*ppacketHeader).dataType < 0 || (*ppacketHeader).dataType > lastPacket ) ) 	
    2f68:	e8 81       	ld	r30, Y
    2f6a:	f9 81       	ldd	r31, Y+1	; 0x01
    2f6c:	ee 30       	cpi	r30, 0x0E	; 14
    2f6e:	f1 05       	cpc	r31, r1
    2f70:	18 f0       	brcs	.+6      	; 0x2f78 <readPacketHeaderRX+0x3e>
    2f72:	23 e0       	ldi	r18, 0x03	; 3
    2f74:	30 e0       	ldi	r19, 0x00	; 0
    2f76:	24 c0       	rjmp	.+72     	; 0x2fc0 <readPacketHeaderRX+0x86>
		return rcInvalidPacket;
	if((*ppacketHeader).dataLength < minPacketData[(*ppacketHeader).dataType]) 
    2f78:	ee 0f       	add	r30, r30
    2f7a:	ff 1f       	adc	r31, r31
    2f7c:	ea 5b       	subi	r30, 0xBA	; 186
    2f7e:	ff 4c       	sbci	r31, 0xCF	; 207
    2f80:	2a 81       	ldd	r18, Y+2	; 0x02
    2f82:	3b 81       	ldd	r19, Y+3	; 0x03
    2f84:	80 81       	ld	r24, Z
    2f86:	91 81       	ldd	r25, Z+1	; 0x01
    2f88:	28 17       	cp	r18, r24
    2f8a:	39 07       	cpc	r19, r25
    2f8c:	1c f4       	brge	.+6      	; 0x2f94 <readPacketHeaderRX+0x5a>
    2f8e:	27 e0       	ldi	r18, 0x07	; 7
    2f90:	30 e0       	ldi	r19, 0x00	; 0
    2f92:	16 c0       	rjmp	.+44     	; 0x2fc0 <readPacketHeaderRX+0x86>
		return rcTooFewData;
	//Compara el valor de  (*ppacketHeader).headerChecksum
	//con el calculado con el header recivido por pdata que proviene RXBUFFER
	if (!checksumOk(sizeof(tPacketHeader),pdata,(*ppacketHeader).headerChecksum,PacketHeader))
    2f94:	4e 81       	ldd	r20, Y+6	; 0x06
    2f96:	5f 81       	ldd	r21, Y+7	; 0x07
    2f98:	88 e0       	ldi	r24, 0x08	; 8
    2f9a:	90 e0       	ldi	r25, 0x00	; 0
    2f9c:	28 e0       	ldi	r18, 0x08	; 8
    2f9e:	30 e0       	ldi	r19, 0x00	; 0
    2fa0:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <checksumOk>
    2fa4:	89 2b       	or	r24, r25
    2fa6:	19 f4       	brne	.+6      	; 0x2fae <readPacketHeaderRX+0x74>
    2fa8:	26 e0       	ldi	r18, 0x06	; 6
    2faa:	30 e0       	ldi	r19, 0x00	; 0
    2fac:	09 c0       	rjmp	.+18     	; 0x2fc0 <readPacketHeaderRX+0x86>
		return rcInvalidHeaderChecksum;
	//compruevo posible inconsistencia de paquete sin datos.
	/*Si el paquete es PacketTrace el *ppacketHeader).dataChecksum debe ser igual a 1 */
	if ((*ppacketHeader).dataChecksum==0)      //compruebo posible inconsistencia   
    2fae:	8c 81       	ldd	r24, Y+4	; 0x04
    2fb0:	9d 81       	ldd	r25, Y+5	; 0x05
    2fb2:	89 2b       	or	r24, r25
    2fb4:	19 f0       	breq	.+6      	; 0x2fbc <readPacketHeaderRX+0x82>
    2fb6:	20 e0       	ldi	r18, 0x00	; 0
    2fb8:	30 e0       	ldi	r19, 0x00	; 0
    2fba:	02 c0       	rjmp	.+4      	; 0x2fc0 <readPacketHeaderRX+0x86>
    2fbc:	25 e0       	ldi	r18, 0x05	; 5
    2fbe:	30 e0       	ldi	r19, 0x00	; 0
			return rcInvalidChecksum;    

	return rcOK; 
} // readPacketHeader
    2fc0:	c9 01       	movw	r24, r18
    2fc2:	df 91       	pop	r29
    2fc4:	cf 91       	pop	r28
    2fc6:	08 95       	ret

00002fc8 <readPacketDataRX>:
/*****************************************************************************************/
//pdata es un apuntador a RXbuffer donde pdata[0] coresponde a el primer
//byte de la variable que quiero leer sin el header
//Es utilizada por todos los tipos de paquetes menos trajectory o PacketTeachPendant
int16 readPacketDataRX(tPacketHeader *ppacketHeader, uint8 *pdata) 
{
    2fc8:	0f 93       	push	r16
    2fca:	1f 93       	push	r17
    2fcc:	cf 93       	push	r28
    2fce:	df 93       	push	r29
    2fd0:	ec 01       	movw	r28, r24
    2fd2:	8b 01       	movw	r16, r22

	int16 i;
	
	tDataLength longitud;
	
	if((*ppacketHeader).dataLength != 0)
    2fd4:	6a 81       	ldd	r22, Y+2	; 0x02
    2fd6:	7b 81       	ldd	r23, Y+3	; 0x03
    2fd8:	61 15       	cp	r22, r1
    2fda:	71 05       	cpc	r23, r1
    2fdc:	19 f4       	brne	.+6      	; 0x2fe4 <readPacketDataRX+0x1c>
    2fde:	22 e0       	ldi	r18, 0x02	; 2
    2fe0:	30 e0       	ldi	r19, 0x00	; 0
    2fe2:	29 c0       	rjmp	.+82     	; 0x3036 <readPacketDataRX+0x6e>
	{ 
		/*Si el paquete es PacketTrace su dataChecksum es igual a 1*/
		if((*ppacketHeader).dataChecksum != 0)
    2fe4:	8c 81       	ldd	r24, Y+4	; 0x04
    2fe6:	9d 81       	ldd	r25, Y+5	; 0x05
    2fe8:	89 2b       	or	r24, r25
    2fea:	19 f1       	breq	.+70     	; 0x3032 <readPacketDataRX+0x6a>
    2fec:	20 e0       	ldi	r18, 0x00	; 0
    2fee:	30 e0       	ldi	r19, 0x00	; 0
    2ff0:	0d c0       	rjmp	.+26     	; 0x300c <readPacketDataRX+0x44>
			for(i=0; i<longitud; i++) 
				printf("readPacketDataRX=> RXBUFFER[%d]=%X\n",i,RXBUFFER[i]);							       
			#endif
			
			for(i=0; i<longitud; i++) 
				pdata[i]=RXBUFFER[i];   //pdata[0] tiene el primer dato
    2ff2:	f8 01       	movw	r30, r16
    2ff4:	e2 0f       	add	r30, r18
    2ff6:	f3 1f       	adc	r31, r19
    2ff8:	a0 91 16 82 	lds	r26, 0x8216
    2ffc:	b0 91 17 82 	lds	r27, 0x8217
    3000:	a2 0f       	add	r26, r18
    3002:	b3 1f       	adc	r27, r19
    3004:	8c 91       	ld	r24, X
    3006:	80 83       	st	Z, r24
			#ifdef DEBUGUSBLevel2
			for(i=0; i<longitud; i++) 
				printf("readPacketDataRX=> RXBUFFER[%d]=%X\n",i,RXBUFFER[i]);							       
			#endif
			
			for(i=0; i<longitud; i++) 
    3008:	2f 5f       	subi	r18, 0xFF	; 255
    300a:	3f 4f       	sbci	r19, 0xFF	; 255
    300c:	26 17       	cp	r18, r22
    300e:	37 07       	cpc	r19, r23
    3010:	84 f3       	brlt	.-32     	; 0x2ff2 <readPacketDataRX+0x2a>
			for(i=0; i<longitud; i++) 
				printf("readPacketDataRX=> Actualizado en readPacketDataRX=> pdata[%d] =%X\n",i,pdata[i]);							       
			for(i=0; i<longitud; i++) 
				printf("readPacketDataRX=> Comprobado en readPacketDataRX=> RXBUFFER[%d]=%X\n",i,RXBUFFER[i]);							       		   
			#endif
			if((*ppacketHeader).dataType!=PacketTrace)
    3012:	28 81       	ld	r18, Y
    3014:	39 81       	ldd	r19, Y+1	; 0x01
    3016:	2c 30       	cpi	r18, 0x0C	; 12
    3018:	31 05       	cpc	r19, r1
    301a:	41 f0       	breq	.+16     	; 0x302c <readPacketDataRX+0x64>
			{
				if( checksumOk(longitud,pdata,(*ppacketHeader).dataChecksum,(*ppacketHeader).dataType)== TRUE ) 
    301c:	4c 81       	ldd	r20, Y+4	; 0x04
    301e:	5d 81       	ldd	r21, Y+5	; 0x05
    3020:	cb 01       	movw	r24, r22
    3022:	b8 01       	movw	r22, r16
    3024:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <checksumOk>
    3028:	01 97       	sbiw	r24, 0x01	; 1
    302a:	19 f4       	brne	.+6      	; 0x3032 <readPacketDataRX+0x6a>
    302c:	20 e0       	ldi	r18, 0x00	; 0
    302e:	30 e0       	ldi	r19, 0x00	; 0
    3030:	02 c0       	rjmp	.+4      	; 0x3036 <readPacketDataRX+0x6e>
    3032:	25 e0       	ldi	r18, 0x05	; 5
    3034:	30 e0       	ldi	r19, 0x00	; 0

		}
		return  rcInvalidChecksum;
	}   	
	return rcInvalidData;
} // readPacketData
    3036:	c9 01       	movw	r24, r18
    3038:	df 91       	pop	r29
    303a:	cf 91       	pop	r28
    303c:	1f 91       	pop	r17
    303e:	0f 91       	pop	r16
    3040:	08 95       	ret

00003042 <fillPacketHeader>:
/*-------------------------------------WRITE---------------------------------------------*/
// fill the header structure and calculate the data and header checksum. Return rc

int16 fillPacketHeader(tPacketHeader *ppacketHeader, tDataType dataType, tDataLength dataLength, 
					 uint8 *pdata) 
{
    3042:	cf 93       	push	r28
    3044:	df 93       	push	r29
    3046:	ec 01       	movw	r28, r24
    3048:	fb 01       	movw	r30, r22
	(*ppacketHeader).dataChecksum = 0;    // will stay so if the packet has no data attached
    304a:	1d 82       	std	Y+5, r1	; 0x05
    304c:	1c 82       	std	Y+4, r1	; 0x04
	(*ppacketHeader).headerChecksum = 0;  // necessary initializazion for the following calculation!
    304e:	1f 82       	std	Y+7, r1	; 0x07
    3050:	1e 82       	std	Y+6, r1	; 0x06
	(*ppacketHeader).dataType = dataType;
    3052:	79 83       	std	Y+1, r23	; 0x01
    3054:	68 83       	st	Y, r22
	(*ppacketHeader).dataLength = dataLength;
    3056:	5b 83       	std	Y+3, r21	; 0x03
    3058:	4a 83       	std	Y+2, r20	; 0x02
	if(dataType > lastPacket) 
    305a:	6e 30       	cpi	r22, 0x0E	; 14
    305c:	71 05       	cpc	r23, r1
    305e:	1c f0       	brlt	.+6      	; 0x3066 <fillPacketHeader+0x24>
    3060:	23 e0       	ldi	r18, 0x03	; 3
    3062:	30 e0       	ldi	r19, 0x00	; 0
    3064:	1e c0       	rjmp	.+60     	; 0x30a2 <fillPacketHeader+0x60>
		return rcInvalidPacket;  // ensure that we don't try to send invalid data:  
	if(dataLength > 0)                                 // calculate data checksum, if data is present
    3066:	14 16       	cp	r1, r20
    3068:	15 06       	cpc	r1, r21
    306a:	1c f0       	brlt	.+6      	; 0x3072 <fillPacketHeader+0x30>
    306c:	27 e0       	ldi	r18, 0x07	; 7
    306e:	30 e0       	ldi	r19, 0x00	; 0
    3070:	18 c0       	rjmp	.+48     	; 0x30a2 <fillPacketHeader+0x60>
	{
	    if((*ppacketHeader).dataType==PacketTrace)
    3072:	6c 30       	cpi	r22, 0x0C	; 12
    3074:	71 05       	cpc	r23, r1
    3076:	19 f4       	brne	.+6      	; 0x307e <fillPacketHeader+0x3c>
			/*No es posible calcular el dataChecksum debido a la forma de como de manda este tipo
			de dato, se coloca a 1 para no tener problemas a la hora de leer*/
			(*ppacketHeader).dataChecksum = 1;
    3078:	81 e0       	ldi	r24, 0x01	; 1
    307a:	90 e0       	ldi	r25, 0x00	; 0
    307c:	05 c0       	rjmp	.+10     	; 0x3088 <fillPacketHeader+0x46>
		else
			(*ppacketHeader).dataChecksum = calcChecksum(dataLength,pdata,dataType); 
    307e:	ca 01       	movw	r24, r20
    3080:	b9 01       	movw	r22, r18
    3082:	af 01       	movw	r20, r30
    3084:	0e 94 29 17 	call	0x2e52	; 0x2e52 <calcChecksum>
    3088:	9d 83       	std	Y+5, r25	; 0x05
    308a:	8c 83       	std	Y+4, r24	; 0x04
	}
	else
		return rcTooFewData;       
	(*ppacketHeader).headerChecksum=(tHeaderChecksum)calcChecksum(sizeof(tPacketHeader),(uint8*)ppacketHeader,PacketHeader);
    308c:	88 e0       	ldi	r24, 0x08	; 8
    308e:	90 e0       	ldi	r25, 0x00	; 0
    3090:	be 01       	movw	r22, r28
    3092:	48 e0       	ldi	r20, 0x08	; 8
    3094:	50 e0       	ldi	r21, 0x00	; 0
    3096:	0e 94 29 17 	call	0x2e52	; 0x2e52 <calcChecksum>
    309a:	9f 83       	std	Y+7, r25	; 0x07
    309c:	8e 83       	std	Y+6, r24	; 0x06
    309e:	20 e0       	ldi	r18, 0x00	; 0
    30a0:	30 e0       	ldi	r19, 0x00	; 0
    return rcOK;
}
    30a2:	c9 01       	movw	r24, r18
    30a4:	df 91       	pop	r29
    30a6:	cf 91       	pop	r28
    30a8:	08 95       	ret

000030aa <Esimpar>:

#endif
/*****************************************************************************************/

int Esimpar(int i)
{
    30aa:	62 e0       	ldi	r22, 0x02	; 2
    30ac:	70 e0       	ldi	r23, 0x00	; 0
    30ae:	0e 94 99 85 	call	0x10b32	; 0x10b32 <__divmodhi4>
    30b2:	9c 01       	movw	r18, r24
    30b4:	00 97       	sbiw	r24, 0x00	; 0
    30b6:	11 f0       	breq	.+4      	; 0x30bc <Esimpar+0x12>
    30b8:	21 e0       	ldi	r18, 0x01	; 1
    30ba:	30 e0       	ldi	r19, 0x00	; 0

	if(residuo==0)
		return FALSE;
		
	return TRUE;
}
    30bc:	c9 01       	movw	r24, r18
    30be:	08 95       	ret

000030c0 <Axis2AxisMask>:
/*****************************************************************************************/
#ifdef _AVR_IO_H_
// mapping which (logical) axis is to find on which MaskAxis corresponds to Axis:
AxisMask Axis2AxisMask(tAxis Axis)
{
	switch(Axis) 
    30c0:	83 30       	cpi	r24, 0x03	; 3
    30c2:	91 05       	cpc	r25, r1
    30c4:	09 f1       	breq	.+66     	; 0x3108 <Axis2AxisMask+0x48>
    30c6:	84 30       	cpi	r24, 0x04	; 4
    30c8:	91 05       	cpc	r25, r1
    30ca:	4c f4       	brge	.+18     	; 0x30de <Axis2AxisMask+0x1e>
    30cc:	81 30       	cpi	r24, 0x01	; 1
    30ce:	91 05       	cpc	r25, r1
    30d0:	91 f0       	breq	.+36     	; 0x30f6 <Axis2AxisMask+0x36>
    30d2:	82 30       	cpi	r24, 0x02	; 2
    30d4:	91 05       	cpc	r25, r1
    30d6:	ac f4       	brge	.+42     	; 0x3102 <Axis2AxisMask+0x42>
    30d8:	89 2b       	or	r24, r25
    30da:	81 f0       	breq	.+32     	; 0x30fc <Axis2AxisMask+0x3c>
    30dc:	24 c0       	rjmp	.+72     	; 0x3126 <Axis2AxisMask+0x66>
    30de:	85 30       	cpi	r24, 0x05	; 5
    30e0:	91 05       	cpc	r25, r1
    30e2:	c1 f0       	breq	.+48     	; 0x3114 <Axis2AxisMask+0x54>
    30e4:	85 30       	cpi	r24, 0x05	; 5
    30e6:	91 05       	cpc	r25, r1
    30e8:	94 f0       	brlt	.+36     	; 0x310e <Axis2AxisMask+0x4e>
    30ea:	86 30       	cpi	r24, 0x06	; 6
    30ec:	91 05       	cpc	r25, r1
    30ee:	a9 f0       	breq	.+42     	; 0x311a <Axis2AxisMask+0x5a>
    30f0:	07 97       	sbiw	r24, 0x07	; 7
    30f2:	c9 f4       	brne	.+50     	; 0x3126 <Axis2AxisMask+0x66>
    30f4:	15 c0       	rjmp	.+42     	; 0x3120 <Axis2AxisMask+0x60>
    30f6:	22 e0       	ldi	r18, 0x02	; 2
    30f8:	30 e0       	ldi	r19, 0x00	; 0
    30fa:	17 c0       	rjmp	.+46     	; 0x312a <Axis2AxisMask+0x6a>
    30fc:	21 e0       	ldi	r18, 0x01	; 1
    30fe:	30 e0       	ldi	r19, 0x00	; 0
    3100:	14 c0       	rjmp	.+40     	; 0x312a <Axis2AxisMask+0x6a>
    3102:	24 e0       	ldi	r18, 0x04	; 4
    3104:	30 e0       	ldi	r19, 0x00	; 0
    3106:	11 c0       	rjmp	.+34     	; 0x312a <Axis2AxisMask+0x6a>
	{
		case AxisWaist 		: 	return WaistMask; 
		case AxisShoulder 	: 	return ShoulderMask; 
		case AxisElbow 		:	return ElbowMask; 
    3108:	28 e0       	ldi	r18, 0x08	; 8
    310a:	30 e0       	ldi	r19, 0x00	; 0
    310c:	0e c0       	rjmp	.+28     	; 0x312a <Axis2AxisMask+0x6a>
		case AxisPitch 		: 	return PitchMask; 
    310e:	20 e1       	ldi	r18, 0x10	; 16
    3110:	30 e0       	ldi	r19, 0x00	; 0
    3112:	0b c0       	rjmp	.+22     	; 0x312a <Axis2AxisMask+0x6a>
		
		case AxisRoll 		: 	return RollMask;
    3114:	20 e2       	ldi	r18, 0x20	; 32
    3116:	30 e0       	ldi	r19, 0x00	; 0
    3118:	08 c0       	rjmp	.+16     	; 0x312a <Axis2AxisMask+0x6a>
		case AxisAux1 		: 	return Aux1Mask; 
    311a:	20 e4       	ldi	r18, 0x40	; 64
    311c:	30 e0       	ldi	r19, 0x00	; 0
    311e:	05 c0       	rjmp	.+10     	; 0x312a <Axis2AxisMask+0x6a>
		case AxisAux2 		: 	return Aux2Mask;    
    3120:	20 e8       	ldi	r18, 0x80	; 128
    3122:	30 e0       	ldi	r19, 0x00	; 0
    3124:	02 c0       	rjmp	.+4      	; 0x312a <Axis2AxisMask+0x6a>
		case AxisAux3 		: 	return Aux3Mask; 			
    3126:	20 e0       	ldi	r18, 0x00	; 0
    3128:	30 e0       	ldi	r19, 0x00	; 0
		
		default 			: 	return NOAxisMask;
	}
  return PMDAxis1;  // we must return something
} // Axis2AxisMask
    312a:	c9 01       	movw	r24, r18
    312c:	08 95       	ret

0000312e <BUFFERPacketDataTX>:
}

/*****************************************************************************************/
// if data is ready, Se prepara el buffer para ser mandado almacenando la informacion necesaria en este
void BUFFERPacketDataTX(tPacketHeader *ppacketHeader, uint8 *pdata, tDataType tipo) 
{ 
    312e:	af 92       	push	r10
    3130:	bf 92       	push	r11
    3132:	cf 92       	push	r12
    3134:	df 92       	push	r13
    3136:	ef 92       	push	r14
    3138:	ff 92       	push	r15
    313a:	0f 93       	push	r16
    313c:	1f 93       	push	r17
    313e:	cf 93       	push	r28
    3140:	df 93       	push	r29
    3142:	8c 01       	movw	r16, r24
    3144:	eb 01       	movw	r28, r22
    3146:	7a 01       	movw	r14, r20
  
	int16 i,j;
	tTrajectory *temp;
  
	switch (tipo)
    3148:	43 30       	cpi	r20, 0x03	; 3
    314a:	51 05       	cpc	r21, r1
    314c:	0c f4       	brge	.+2      	; 0x3150 <BUFFERPacketDataTX+0x22>
    314e:	42 c0       	rjmp	.+132    	; 0x31d4 <BUFFERPacketDataTX+0xa6>
    3150:	45 30       	cpi	r20, 0x05	; 5
    3152:	51 05       	cpc	r21, r1
    3154:	34 f0       	brlt	.+12     	; 0x3162 <BUFFERPacketDataTX+0x34>
    3156:	48 30       	cpi	r20, 0x08	; 8
    3158:	51 05       	cpc	r21, r1
    315a:	e1 f5       	brne	.+120    	; 0x31d4 <BUFFERPacketDataTX+0xa6>
    315c:	20 e0       	ldi	r18, 0x00	; 0
    315e:	30 e0       	ldi	r19, 0x00	; 0
    3160:	11 c0       	rjmp	.+34     	; 0x3184 <BUFFERPacketDataTX+0x56>
    3162:	db 01       	movw	r26, r22
    3164:	28 e0       	ldi	r18, 0x08	; 8
    3166:	30 e0       	ldi	r19, 0x00	; 0
    3168:	1b c0       	rjmp	.+54     	; 0x31a0 <BUFFERPacketDataTX+0x72>
	{
		case PacketHeader:  
			// Se guarda el Header al principio de TXBUFFER
			for(i=0; i<sizeof(tPacketHeader); i++)   
				TXBUFFER[i]=pdata[i]; 
    316a:	e0 91 18 82 	lds	r30, 0x8218
    316e:	f0 91 19 82 	lds	r31, 0x8219
    3172:	e2 0f       	add	r30, r18
    3174:	f3 1f       	adc	r31, r19
    3176:	de 01       	movw	r26, r28
    3178:	a2 0f       	add	r26, r18
    317a:	b3 1f       	adc	r27, r19
    317c:	8c 91       	ld	r24, X
    317e:	80 83       	st	Z, r24
  
	switch (tipo)
	{
		case PacketHeader:  
			// Se guarda el Header al principio de TXBUFFER
			for(i=0; i<sizeof(tPacketHeader); i++)   
    3180:	2f 5f       	subi	r18, 0xFF	; 255
    3182:	3f 4f       	sbci	r19, 0xFF	; 255
    3184:	28 30       	cpi	r18, 0x08	; 8
    3186:	31 05       	cpc	r19, r1
    3188:	81 f7       	brne	.-32     	; 0x316a <BUFFERPacketDataTX+0x3c>
    318a:	64 c0       	rjmp	.+200    	; 0x3254 <BUFFERPacketDataTX+0x126>
		case PacketTrajectory:	
		case PacketTeachPendant:
			//me desplazo 8 bytes en TXBUFFER porque deben de contener le header																
			//copio los 4 bytes de la trayectoria, 2 campos  int16 (dummy y size)
			for(i=sizeof(tPacketHeader); i<4+sizeof(tPacketHeader); i++)   
				TXBUFFER[i]=pdata[i-sizeof(tPacketHeader)]; 
    318c:	e0 91 18 82 	lds	r30, 0x8218
    3190:	f0 91 19 82 	lds	r31, 0x8219
    3194:	e2 0f       	add	r30, r18
    3196:	f3 1f       	adc	r31, r19
    3198:	8d 91       	ld	r24, X+
    319a:	80 83       	st	Z, r24
		break;
		case PacketTrajectory:	
		case PacketTeachPendant:
			//me desplazo 8 bytes en TXBUFFER porque deben de contener le header																
			//copio los 4 bytes de la trayectoria, 2 campos  int16 (dummy y size)
			for(i=sizeof(tPacketHeader); i<4+sizeof(tPacketHeader); i++)   
    319c:	2f 5f       	subi	r18, 0xFF	; 255
    319e:	3f 4f       	sbci	r19, 0xFF	; 255
    31a0:	2c 30       	cpi	r18, 0x0C	; 12
    31a2:	31 05       	cpc	r19, r1
    31a4:	99 f7       	brne	.-26     	; 0x318c <BUFFERPacketDataTX+0x5e>
    31a6:	ac 81       	ldd	r26, Y+4	; 0x04
    31a8:	bd 81       	ldd	r27, Y+5	; 0x05
    31aa:	2c e0       	ldi	r18, 0x0C	; 12
    31ac:	30 e0       	ldi	r19, 0x00	; 0
    31ae:	0a c0       	rjmp	.+20     	; 0x31c4 <BUFFERPacketDataTX+0x96>
			//copio los datos en una variable temporal  de tipo tTrajectory para poder 	
			//acceder a el campo point y asi extraer el apuntador a los  puntos
			temp=(tTrajectory *)pdata;		
			pdata = (uint8*)temp->point;		
			for(j=i; j<ppacketHeader->dataLength+i; j++) 
				TXBUFFER[j]=pdata[j-i]; 	        
    31b0:	e0 91 18 82 	lds	r30, 0x8218
    31b4:	f0 91 19 82 	lds	r31, 0x8219
    31b8:	e2 0f       	add	r30, r18
    31ba:	f3 1f       	adc	r31, r19
    31bc:	8d 91       	ld	r24, X+
    31be:	80 83       	st	Z, r24
				TXBUFFER[i]=pdata[i-sizeof(tPacketHeader)]; 
			//copio los datos en una variable temporal  de tipo tTrajectory para poder 	
			//acceder a el campo point y asi extraer el apuntador a los  puntos
			temp=(tTrajectory *)pdata;		
			pdata = (uint8*)temp->point;		
			for(j=i; j<ppacketHeader->dataLength+i; j++) 
    31c0:	2f 5f       	subi	r18, 0xFF	; 255
    31c2:	3f 4f       	sbci	r19, 0xFF	; 255
    31c4:	f8 01       	movw	r30, r16
    31c6:	82 81       	ldd	r24, Z+2	; 0x02
    31c8:	93 81       	ldd	r25, Z+3	; 0x03
    31ca:	0c 96       	adiw	r24, 0x0c	; 12
    31cc:	28 17       	cp	r18, r24
    31ce:	39 07       	cpc	r19, r25
    31d0:	7c f3       	brlt	.-34     	; 0x31b0 <BUFFERPacketDataTX+0x82>
    31d2:	40 c0       	rjmp	.+128    	; 0x3254 <BUFFERPacketDataTX+0x126>
				TXBUFFER[j]=pdata[j-i]; 	        
		break;
		default:								//para todos los demas paquetes
			j=(int16)ppacketHeader->dataLength;
			j=j+sizeof(tPacketHeader);
    31d4:	d8 01       	movw	r26, r16
    31d6:	12 96       	adiw	r26, 0x02	; 2
    31d8:	cd 90       	ld	r12, X+
    31da:	dc 90       	ld	r13, X
    31dc:	13 97       	sbiw	r26, 0x03	; 3
    31de:	e8 e0       	ldi	r30, 0x08	; 8
    31e0:	f0 e0       	ldi	r31, 0x00	; 0
    31e2:	ce 0e       	add	r12, r30
    31e4:	df 1e       	adc	r13, r31
    31e6:	8e 01       	movw	r16, r28
    31e8:	c8 e0       	ldi	r28, 0x08	; 8
    31ea:	d0 e0       	ldi	r29, 0x00	; 0
			for(i=sizeof(tPacketHeader);i<j;i++) 
			{
				TXBUFFER[i]=pdata[i-sizeof(tPacketHeader)]; //Coloca toda la informacion a enviar  
				if(tipo==Packetuint16)
				{
					printf("BUFFERPacketDataTX=> pdata[%d-sizeof(tPacketHeader)] = %d \n",i,pdata[i-sizeof(tPacketHeader)]);
    31ec:	92 e7       	ldi	r25, 0x72	; 114
    31ee:	a9 2e       	mov	r10, r25
    31f0:	9e e2       	ldi	r25, 0x2E	; 46
    31f2:	b9 2e       	mov	r11, r25
    31f4:	2c c0       	rjmp	.+88     	; 0x324e <BUFFERPacketDataTX+0x120>
		default:								//para todos los demas paquetes
			j=(int16)ppacketHeader->dataLength;
			j=j+sizeof(tPacketHeader);
			for(i=sizeof(tPacketHeader);i<j;i++) 
			{
				TXBUFFER[i]=pdata[i-sizeof(tPacketHeader)]; //Coloca toda la informacion a enviar  
    31f6:	e0 91 18 82 	lds	r30, 0x8218
    31fa:	f0 91 19 82 	lds	r31, 0x8219
    31fe:	ec 0f       	add	r30, r28
    3200:	fd 1f       	adc	r31, r29
    3202:	d8 01       	movw	r26, r16
    3204:	8c 91       	ld	r24, X
    3206:	80 83       	st	Z, r24
				if(tipo==Packetuint16)
    3208:	bd e0       	ldi	r27, 0x0D	; 13
    320a:	eb 16       	cp	r14, r27
    320c:	f1 04       	cpc	r15, r1
    320e:	e1 f4       	brne	.+56     	; 0x3248 <BUFFERPacketDataTX+0x11a>
				{
					printf("BUFFERPacketDataTX=> pdata[%d-sizeof(tPacketHeader)] = %d \n",i,pdata[i-sizeof(tPacketHeader)]);
    3210:	00 d0       	rcall	.+0      	; 0x3212 <BUFFERPacketDataTX+0xe4>
    3212:	00 d0       	rcall	.+0      	; 0x3214 <BUFFERPacketDataTX+0xe6>
    3214:	00 d0       	rcall	.+0      	; 0x3216 <BUFFERPacketDataTX+0xe8>
    3216:	ed b7       	in	r30, 0x3d	; 61
    3218:	fe b7       	in	r31, 0x3e	; 62
    321a:	31 96       	adiw	r30, 0x01	; 1
    321c:	ad b7       	in	r26, 0x3d	; 61
    321e:	be b7       	in	r27, 0x3e	; 62
    3220:	12 96       	adiw	r26, 0x02	; 2
    3222:	bc 92       	st	X, r11
    3224:	ae 92       	st	-X, r10
    3226:	11 97       	sbiw	r26, 0x01	; 1
    3228:	d3 83       	std	Z+3, r29	; 0x03
    322a:	c2 83       	std	Z+2, r28	; 0x02
    322c:	d8 01       	movw	r26, r16
    322e:	8c 91       	ld	r24, X
    3230:	84 83       	std	Z+4, r24	; 0x04
    3232:	15 82       	std	Z+5, r1	; 0x05
    3234:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    3238:	ed b7       	in	r30, 0x3d	; 61
    323a:	fe b7       	in	r31, 0x3e	; 62
    323c:	36 96       	adiw	r30, 0x06	; 6
    323e:	0f b6       	in	r0, 0x3f	; 63
    3240:	f8 94       	cli
    3242:	fe bf       	out	0x3e, r31	; 62
    3244:	0f be       	out	0x3f, r0	; 63
    3246:	ed bf       	out	0x3d, r30	; 61
				TXBUFFER[j]=pdata[j-i]; 	        
		break;
		default:								//para todos los demas paquetes
			j=(int16)ppacketHeader->dataLength;
			j=j+sizeof(tPacketHeader);
			for(i=sizeof(tPacketHeader);i<j;i++) 
    3248:	21 96       	adiw	r28, 0x01	; 1
    324a:	0f 5f       	subi	r16, 0xFF	; 255
    324c:	1f 4f       	sbci	r17, 0xFF	; 255
    324e:	cc 15       	cp	r28, r12
    3250:	dd 05       	cpc	r29, r13
    3252:	8c f2       	brlt	.-94     	; 0x31f6 <BUFFERPacketDataTX+0xc8>
				{
					printf("BUFFERPacketDataTX=> pdata[%d-sizeof(tPacketHeader)] = %d \n",i,pdata[i-sizeof(tPacketHeader)]);
				}
			}
	}  
} // sendPacketData
    3254:	df 91       	pop	r29
    3256:	cf 91       	pop	r28
    3258:	1f 91       	pop	r17
    325a:	0f 91       	pop	r16
    325c:	ff 90       	pop	r15
    325e:	ef 90       	pop	r14
    3260:	df 90       	pop	r13
    3262:	cf 90       	pop	r12
    3264:	bf 90       	pop	r11
    3266:	af 90       	pop	r10
    3268:	08 95       	ret

0000326a <Print_rxTrajectory>:
} // Axis2AxisMask


/*****************************************************************************************/
void Print_rxTrajectory(void)
{
    326a:	2f 92       	push	r2
    326c:	3f 92       	push	r3
    326e:	4f 92       	push	r4
    3270:	5f 92       	push	r5
    3272:	6f 92       	push	r6
    3274:	7f 92       	push	r7
    3276:	8f 92       	push	r8
    3278:	9f 92       	push	r9
    327a:	af 92       	push	r10
    327c:	bf 92       	push	r11
    327e:	cf 92       	push	r12
    3280:	df 92       	push	r13
    3282:	ef 92       	push	r14
    3284:	ff 92       	push	r15
    3286:	0f 93       	push	r16
    3288:	1f 93       	push	r17
    328a:	df 93       	push	r29
    328c:	cf 93       	push	r28
    328e:	00 d0       	rcall	.+0      	; 0x3290 <Print_rxTrajectory+0x26>
    3290:	cd b7       	in	r28, 0x3d	; 61
    3292:	de b7       	in	r29, 0x3e	; 62
	int16 pointIndex,axis,stop;
	
	printf("Print_rxTrajectory=> El Numero de puntos de la trayectoria es en packetIO.c => %d\n",rxTrajectory.size);
    3294:	00 d0       	rcall	.+0      	; 0x3296 <Print_rxTrajectory+0x2c>
    3296:	00 d0       	rcall	.+0      	; 0x3298 <Print_rxTrajectory+0x2e>
    3298:	8e ea       	ldi	r24, 0xAE	; 174
    329a:	9e e2       	ldi	r25, 0x2E	; 46
    329c:	ed b7       	in	r30, 0x3d	; 61
    329e:	fe b7       	in	r31, 0x3e	; 62
    32a0:	92 83       	std	Z+2, r25	; 0x02
    32a2:	81 83       	std	Z+1, r24	; 0x01
    32a4:	80 91 09 82 	lds	r24, 0x8209
    32a8:	90 91 0a 82 	lds	r25, 0x820A
    32ac:	94 83       	std	Z+4, r25	; 0x04
    32ae:	83 83       	std	Z+3, r24	; 0x03
    32b0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Print_rxTrajectory=> invalid mask en packetIO.c => %X\n",rxTrajectory.invalidmask);
    32b4:	81 e0       	ldi	r24, 0x01	; 1
    32b6:	9f e2       	ldi	r25, 0x2F	; 47
    32b8:	ed b7       	in	r30, 0x3d	; 61
    32ba:	fe b7       	in	r31, 0x3e	; 62
    32bc:	92 83       	std	Z+2, r25	; 0x02
    32be:	81 83       	std	Z+1, r24	; 0x01
    32c0:	80 91 0b 82 	lds	r24, 0x820B
    32c4:	90 91 0c 82 	lds	r25, 0x820C
    32c8:	94 83       	std	Z+4, r25	; 0x04
    32ca:	83 83       	std	Z+3, r24	; 0x03
    32cc:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    32d0:	88 24       	eor	r8, r8
    32d2:	99 24       	eor	r9, r9
    32d4:	aa 24       	eor	r10, r10
    32d6:	bb 24       	eor	r11, r11
    32d8:	0f 90       	pop	r0
    32da:	0f 90       	pop	r0
    32dc:	0f 90       	pop	r0
    32de:	0f 90       	pop	r0
		{
			printf("Print_rxTrajectory=> La posicion de %s es en packetIO.c => %ld\n",AxisName(axis),
				   rxTrajectory.point[pointIndex].axis[axis].position);
			printf("Print_rxTrajectory=> La velocidad de %s es en packetIO.c => %ld\n",AxisName(axis),
				   rxTrajectory.point[pointIndex].axis[axis].velocity);
			printf("Print_rxTrajectory=> La aceleracion de %s es en packetIO.c => %ld\n",AxisName(axis),
    32e0:	e0 e0       	ldi	r30, 0x00	; 0
    32e2:	2e 2e       	mov	r2, r30
    32e4:	e0 e3       	ldi	r30, 0x30	; 48
    32e6:	3e 2e       	mov	r3, r30
				   rxTrajectory.point[pointIndex].axis[axis].acceleration);
			scanf("%d",&stop);
    32e8:	73 e4       	ldi	r23, 0x43	; 67
    32ea:	47 2e       	mov	r4, r23
    32ec:	70 e3       	ldi	r23, 0x30	; 48
    32ee:	57 2e       	mov	r5, r23
    32f0:	3e 01       	movw	r6, r28
    32f2:	08 94       	sec
    32f4:	61 1c       	adc	r6, r1
    32f6:	71 1c       	adc	r7, r1
    32f8:	d5 c0       	rjmp	.+426    	; 0x34a4 <Print_rxTrajectory+0x23a>
	printf("Print_rxTrajectory=> invalid mask en packetIO.c => %X\n",rxTrajectory.invalidmask);
	
	
	for(pointIndex=0;pointIndex < rxTrajectory.size;pointIndex++)
	{
		printf("Print_rxTrajectory=> En el punto %d de la trayectoria....(packetIO.c)\n",pointIndex+1);
    32fa:	08 94       	sec
    32fc:	81 1c       	adc	r8, r1
    32fe:	91 1c       	adc	r9, r1
    3300:	00 d0       	rcall	.+0      	; 0x3302 <Print_rxTrajectory+0x98>
    3302:	00 d0       	rcall	.+0      	; 0x3304 <Print_rxTrajectory+0x9a>
    3304:	28 e3       	ldi	r18, 0x38	; 56
    3306:	3f e2       	ldi	r19, 0x2F	; 47
    3308:	ed b7       	in	r30, 0x3d	; 61
    330a:	fe b7       	in	r31, 0x3e	; 62
    330c:	32 83       	std	Z+2, r19	; 0x02
    330e:	21 83       	std	Z+1, r18	; 0x01
    3310:	94 82       	std	Z+4, r9	; 0x04
    3312:	83 82       	std	Z+3, r8	; 0x03
    3314:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    3318:	cc 24       	eor	r12, r12
    331a:	dd 24       	eor	r13, r13
    331c:	0f 90       	pop	r0
    331e:	0f 90       	pop	r0
    3320:	0f 90       	pop	r0
    3322:	0f 90       	pop	r0
			
		for(axis=0; axis < DOF; axis++) 
		{
			printf("Print_rxTrajectory=> La posicion de %s es en packetIO.c => %ld\n",AxisName(axis),
    3324:	c6 01       	movw	r24, r12
    3326:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    332a:	4d b7       	in	r20, 0x3d	; 61
    332c:	5e b7       	in	r21, 0x3e	; 62
    332e:	48 50       	subi	r20, 0x08	; 8
    3330:	50 40       	sbci	r21, 0x00	; 0
    3332:	0f b6       	in	r0, 0x3f	; 63
    3334:	f8 94       	cli
    3336:	5e bf       	out	0x3e, r21	; 62
    3338:	0f be       	out	0x3f, r0	; 63
    333a:	4d bf       	out	0x3d, r20	; 61
    333c:	2d b7       	in	r18, 0x3d	; 61
    333e:	3e b7       	in	r19, 0x3e	; 62
    3340:	2f 5f       	subi	r18, 0xFF	; 255
    3342:	3f 4f       	sbci	r19, 0xFF	; 255
    3344:	4f e7       	ldi	r20, 0x7F	; 127
    3346:	5f e2       	ldi	r21, 0x2F	; 47
    3348:	ed b7       	in	r30, 0x3d	; 61
    334a:	fe b7       	in	r31, 0x3e	; 62
    334c:	52 83       	std	Z+2, r21	; 0x02
    334e:	41 83       	std	Z+1, r20	; 0x01
    3350:	f9 01       	movw	r30, r18
    3352:	93 83       	std	Z+3, r25	; 0x03
    3354:	82 83       	std	Z+2, r24	; 0x02
    3356:	e0 91 0d 82 	lds	r30, 0x820D
    335a:	f0 91 0e 82 	lds	r31, 0x820E
    335e:	ea 0d       	add	r30, r10
    3360:	fb 1d       	adc	r31, r11
    3362:	86 01       	movw	r16, r12
    3364:	00 0f       	add	r16, r16
    3366:	11 1f       	adc	r17, r17
    3368:	0c 0d       	add	r16, r12
    336a:	1d 1d       	adc	r17, r13
    336c:	78 01       	movw	r14, r16
    336e:	ee 0c       	add	r14, r14
    3370:	ff 1c       	adc	r15, r15
    3372:	ee 0c       	add	r14, r14
    3374:	ff 1c       	adc	r15, r15
    3376:	ee 0d       	add	r30, r14
    3378:	ff 1d       	adc	r31, r15
    337a:	80 81       	ld	r24, Z
    337c:	91 81       	ldd	r25, Z+1	; 0x01
    337e:	a2 81       	ldd	r26, Z+2	; 0x02
    3380:	b3 81       	ldd	r27, Z+3	; 0x03
    3382:	f9 01       	movw	r30, r18
    3384:	84 83       	std	Z+4, r24	; 0x04
    3386:	95 83       	std	Z+5, r25	; 0x05
    3388:	a6 83       	std	Z+6, r26	; 0x06
    338a:	b7 83       	std	Z+7, r27	; 0x07
    338c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				   rxTrajectory.point[pointIndex].axis[axis].position);
			printf("Print_rxTrajectory=> La velocidad de %s es en packetIO.c => %ld\n",AxisName(axis),
    3390:	2d b7       	in	r18, 0x3d	; 61
    3392:	3e b7       	in	r19, 0x3e	; 62
    3394:	28 5f       	subi	r18, 0xF8	; 248
    3396:	3f 4f       	sbci	r19, 0xFF	; 255
    3398:	0f b6       	in	r0, 0x3f	; 63
    339a:	f8 94       	cli
    339c:	3e bf       	out	0x3e, r19	; 62
    339e:	0f be       	out	0x3f, r0	; 63
    33a0:	2d bf       	out	0x3d, r18	; 61
    33a2:	c6 01       	movw	r24, r12
    33a4:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    33a8:	4d b7       	in	r20, 0x3d	; 61
    33aa:	5e b7       	in	r21, 0x3e	; 62
    33ac:	48 50       	subi	r20, 0x08	; 8
    33ae:	50 40       	sbci	r21, 0x00	; 0
    33b0:	0f b6       	in	r0, 0x3f	; 63
    33b2:	f8 94       	cli
    33b4:	5e bf       	out	0x3e, r21	; 62
    33b6:	0f be       	out	0x3f, r0	; 63
    33b8:	4d bf       	out	0x3d, r20	; 61
    33ba:	2d b7       	in	r18, 0x3d	; 61
    33bc:	3e b7       	in	r19, 0x3e	; 62
    33be:	2f 5f       	subi	r18, 0xFF	; 255
    33c0:	3f 4f       	sbci	r19, 0xFF	; 255
    33c2:	4f eb       	ldi	r20, 0xBF	; 191
    33c4:	5f e2       	ldi	r21, 0x2F	; 47
    33c6:	ed b7       	in	r30, 0x3d	; 61
    33c8:	fe b7       	in	r31, 0x3e	; 62
    33ca:	52 83       	std	Z+2, r21	; 0x02
    33cc:	41 83       	std	Z+1, r20	; 0x01
    33ce:	f9 01       	movw	r30, r18
    33d0:	93 83       	std	Z+3, r25	; 0x03
    33d2:	82 83       	std	Z+2, r24	; 0x02
    33d4:	e0 91 0d 82 	lds	r30, 0x820D
    33d8:	f0 91 0e 82 	lds	r31, 0x820E
    33dc:	ea 0d       	add	r30, r10
    33de:	fb 1d       	adc	r31, r11
    33e0:	0f 5f       	subi	r16, 0xFF	; 255
    33e2:	1f 4f       	sbci	r17, 0xFF	; 255
    33e4:	00 0f       	add	r16, r16
    33e6:	11 1f       	adc	r17, r17
    33e8:	00 0f       	add	r16, r16
    33ea:	11 1f       	adc	r17, r17
    33ec:	e0 0f       	add	r30, r16
    33ee:	f1 1f       	adc	r31, r17
    33f0:	80 81       	ld	r24, Z
    33f2:	91 81       	ldd	r25, Z+1	; 0x01
    33f4:	a2 81       	ldd	r26, Z+2	; 0x02
    33f6:	b3 81       	ldd	r27, Z+3	; 0x03
    33f8:	f9 01       	movw	r30, r18
    33fa:	84 83       	std	Z+4, r24	; 0x04
    33fc:	95 83       	std	Z+5, r25	; 0x05
    33fe:	a6 83       	std	Z+6, r26	; 0x06
    3400:	b7 83       	std	Z+7, r27	; 0x07
    3402:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				   rxTrajectory.point[pointIndex].axis[axis].velocity);
			printf("Print_rxTrajectory=> La aceleracion de %s es en packetIO.c => %ld\n",AxisName(axis),
    3406:	2d b7       	in	r18, 0x3d	; 61
    3408:	3e b7       	in	r19, 0x3e	; 62
    340a:	28 5f       	subi	r18, 0xF8	; 248
    340c:	3f 4f       	sbci	r19, 0xFF	; 255
    340e:	0f b6       	in	r0, 0x3f	; 63
    3410:	f8 94       	cli
    3412:	3e bf       	out	0x3e, r19	; 62
    3414:	0f be       	out	0x3f, r0	; 63
    3416:	2d bf       	out	0x3d, r18	; 61
    3418:	c6 01       	movw	r24, r12
    341a:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    341e:	4d b7       	in	r20, 0x3d	; 61
    3420:	5e b7       	in	r21, 0x3e	; 62
    3422:	48 50       	subi	r20, 0x08	; 8
    3424:	50 40       	sbci	r21, 0x00	; 0
    3426:	0f b6       	in	r0, 0x3f	; 63
    3428:	f8 94       	cli
    342a:	5e bf       	out	0x3e, r21	; 62
    342c:	0f be       	out	0x3f, r0	; 63
    342e:	4d bf       	out	0x3d, r20	; 61
    3430:	2d b7       	in	r18, 0x3d	; 61
    3432:	3e b7       	in	r19, 0x3e	; 62
    3434:	2f 5f       	subi	r18, 0xFF	; 255
    3436:	3f 4f       	sbci	r19, 0xFF	; 255
    3438:	ed b7       	in	r30, 0x3d	; 61
    343a:	fe b7       	in	r31, 0x3e	; 62
    343c:	32 82       	std	Z+2, r3	; 0x02
    343e:	21 82       	std	Z+1, r2	; 0x01
    3440:	f9 01       	movw	r30, r18
    3442:	93 83       	std	Z+3, r25	; 0x03
    3444:	82 83       	std	Z+2, r24	; 0x02
    3446:	e0 91 0d 82 	lds	r30, 0x820D
    344a:	f0 91 0e 82 	lds	r31, 0x820E
    344e:	ea 0d       	add	r30, r10
    3450:	fb 1d       	adc	r31, r11
    3452:	ee 0d       	add	r30, r14
    3454:	ff 1d       	adc	r31, r15
    3456:	80 85       	ldd	r24, Z+8	; 0x08
    3458:	91 85       	ldd	r25, Z+9	; 0x09
    345a:	a2 85       	ldd	r26, Z+10	; 0x0a
    345c:	b3 85       	ldd	r27, Z+11	; 0x0b
    345e:	f9 01       	movw	r30, r18
    3460:	84 83       	std	Z+4, r24	; 0x04
    3462:	95 83       	std	Z+5, r25	; 0x05
    3464:	a6 83       	std	Z+6, r26	; 0x06
    3466:	b7 83       	std	Z+7, r27	; 0x07
    3468:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				   rxTrajectory.point[pointIndex].axis[axis].acceleration);
			scanf("%d",&stop);
    346c:	0f 90       	pop	r0
    346e:	0f 90       	pop	r0
    3470:	0f 90       	pop	r0
    3472:	0f 90       	pop	r0
    3474:	ed b7       	in	r30, 0x3d	; 61
    3476:	fe b7       	in	r31, 0x3e	; 62
    3478:	52 82       	std	Z+2, r5	; 0x02
    347a:	41 82       	std	Z+1, r4	; 0x01
    347c:	74 82       	std	Z+4, r7	; 0x04
    347e:	63 82       	std	Z+3, r6	; 0x03
    3480:	0e 94 49 89 	call	0x11292	; 0x11292 <scanf>
	
	for(pointIndex=0;pointIndex < rxTrajectory.size;pointIndex++)
	{
		printf("Print_rxTrajectory=> En el punto %d de la trayectoria....(packetIO.c)\n",pointIndex+1);
			
		for(axis=0; axis < DOF; axis++) 
    3484:	08 94       	sec
    3486:	c1 1c       	adc	r12, r1
    3488:	d1 1c       	adc	r13, r1
    348a:	0f 90       	pop	r0
    348c:	0f 90       	pop	r0
    348e:	0f 90       	pop	r0
    3490:	0f 90       	pop	r0
    3492:	f5 e0       	ldi	r31, 0x05	; 5
    3494:	cf 16       	cp	r12, r31
    3496:	d1 04       	cpc	r13, r1
    3498:	09 f0       	breq	.+2      	; 0x349c <Print_rxTrajectory+0x232>
    349a:	44 cf       	rjmp	.-376    	; 0x3324 <Print_rxTrajectory+0xba>
    349c:	2d e3       	ldi	r18, 0x3D	; 61
    349e:	30 e0       	ldi	r19, 0x00	; 0
    34a0:	a2 0e       	add	r10, r18
    34a2:	b3 1e       	adc	r11, r19
	
	printf("Print_rxTrajectory=> El Numero de puntos de la trayectoria es en packetIO.c => %d\n",rxTrajectory.size);
	printf("Print_rxTrajectory=> invalid mask en packetIO.c => %X\n",rxTrajectory.invalidmask);
	
	
	for(pointIndex=0;pointIndex < rxTrajectory.size;pointIndex++)
    34a4:	80 91 09 82 	lds	r24, 0x8209
    34a8:	90 91 0a 82 	lds	r25, 0x820A
    34ac:	88 16       	cp	r8, r24
    34ae:	99 06       	cpc	r9, r25
    34b0:	0c f4       	brge	.+2      	; 0x34b4 <Print_rxTrajectory+0x24a>
    34b2:	23 cf       	rjmp	.-442    	; 0x32fa <Print_rxTrajectory+0x90>
				   rxTrajectory.point[pointIndex].axis[axis].acceleration);
			scanf("%d",&stop);
			
		} 
	}	
}
    34b4:	0f 90       	pop	r0
    34b6:	0f 90       	pop	r0
    34b8:	cf 91       	pop	r28
    34ba:	df 91       	pop	r29
    34bc:	1f 91       	pop	r17
    34be:	0f 91       	pop	r16
    34c0:	ff 90       	pop	r15
    34c2:	ef 90       	pop	r14
    34c4:	df 90       	pop	r13
    34c6:	cf 90       	pop	r12
    34c8:	bf 90       	pop	r11
    34ca:	af 90       	pop	r10
    34cc:	9f 90       	pop	r9
    34ce:	8f 90       	pop	r8
    34d0:	7f 90       	pop	r7
    34d2:	6f 90       	pop	r6
    34d4:	5f 90       	pop	r5
    34d6:	4f 90       	pop	r4
    34d8:	3f 90       	pop	r3
    34da:	2f 90       	pop	r2
    34dc:	08 95       	ret

000034de <BUFFERunit16TX>:
}



int BUFFERunit16TX(uint8 * unit16TX) 
{
    34de:	cf 92       	push	r12
    34e0:	df 92       	push	r13
    34e2:	ef 92       	push	r14
    34e4:	ff 92       	push	r15
    34e6:	0f 93       	push	r16
    34e8:	1f 93       	push	r17
    34ea:	df 93       	push	r29
    34ec:	cf 93       	push	r28
    34ee:	cd b7       	in	r28, 0x3d	; 61
    34f0:	de b7       	in	r29, 0x3e	; 62
    34f2:	28 97       	sbiw	r28, 0x08	; 8
    34f4:	0f b6       	in	r0, 0x3f	; 63
    34f6:	f8 94       	cli
    34f8:	de bf       	out	0x3e, r29	; 62
    34fa:	0f be       	out	0x3f, r0	; 63
    34fc:	cd bf       	out	0x3d, r28	; 61
    34fe:	6c 01       	movw	r12, r24
	tPacketHeader packetHeader;
	int16 buffersize,Datasize;


	buffersize=sizeof(uint16) +sizeof(tPacketHeader);		   
	if(Esimpar(buffersize))
    3500:	8a e0       	ldi	r24, 0x0A	; 10
    3502:	90 e0       	ldi	r25, 0x00	; 0
    3504:	0e 94 55 18 	call	0x30aa	; 0x30aa <Esimpar>
    3508:	89 2b       	or	r24, r25
    350a:	21 f4       	brne	.+8      	; 0x3514 <BUFFERunit16TX+0x36>
    350c:	aa e0       	ldi	r26, 0x0A	; 10
    350e:	ea 2e       	mov	r14, r26
    3510:	f1 2c       	mov	r15, r1
    3512:	03 c0       	rjmp	.+6      	; 0x351a <BUFFERunit16TX+0x3c>
    3514:	fb e0       	ldi	r31, 0x0B	; 11
    3516:	ef 2e       	mov	r14, r31
    3518:	f1 2c       	mov	r15, r1
	else
	{
		Datasize=buffersize-8;	
	}
		
	TXBUFFER=(uint8*)declarar(buffersize);
    351a:	c7 01       	movw	r24, r14
    351c:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    3520:	90 93 19 82 	sts	0x8219, r25
    3524:	80 93 18 82 	sts	0x8218, r24
	printf("BUFFERunit16TX => cantidad a mandar al PC %X\n",buffersize);			
	printf("BUFFERunit16TX => Datasize de 8bit = %X\n",Datasize);	
	printf("BUFFERunit16TX => *unit16TX => %d\n",*unit16TX);	
				
	#endif		
	fillPacketHeader(&packetHeader,Packetuint16,Datasize,(uint8*)unit16TX);
    3528:	8e 01       	movw	r16, r28
    352a:	0f 5f       	subi	r16, 0xFF	; 255
    352c:	1f 4f       	sbci	r17, 0xFF	; 255
    352e:	c8 01       	movw	r24, r16
    3530:	6d e0       	ldi	r22, 0x0D	; 13
    3532:	70 e0       	ldi	r23, 0x00	; 0
    3534:	42 e0       	ldi	r20, 0x02	; 2
    3536:	50 e0       	ldi	r21, 0x00	; 0
    3538:	96 01       	movw	r18, r12
    353a:	0e 94 21 18 	call	0x3042	; 0x3042 <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    353e:	c8 01       	movw	r24, r16
    3540:	b8 01       	movw	r22, r16
    3542:	48 e0       	ldi	r20, 0x08	; 8
    3544:	50 e0       	ldi	r21, 0x00	; 0
    3546:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	// meto a Fecha en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,unit16TX,Packetuint16);    
    354a:	c8 01       	movw	r24, r16
    354c:	b6 01       	movw	r22, r12
    354e:	4d e0       	ldi	r20, 0x0D	; 13
    3550:	50 e0       	ldi	r21, 0x00	; 0
    3552:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	return buffersize;
}
    3556:	c7 01       	movw	r24, r14
    3558:	28 96       	adiw	r28, 0x08	; 8
    355a:	0f b6       	in	r0, 0x3f	; 63
    355c:	f8 94       	cli
    355e:	de bf       	out	0x3e, r29	; 62
    3560:	0f be       	out	0x3f, r0	; 63
    3562:	cd bf       	out	0x3d, r28	; 61
    3564:	cf 91       	pop	r28
    3566:	df 91       	pop	r29
    3568:	1f 91       	pop	r17
    356a:	0f 91       	pop	r16
    356c:	ff 90       	pop	r15
    356e:	ef 90       	pop	r14
    3570:	df 90       	pop	r13
    3572:	cf 90       	pop	r12
    3574:	08 95       	ret

00003576 <BUFFERTraceTX>:

/*****************************************************************************************/
/*TraceTX la direccion del apuntador del primer dato*/
/*Esta funcion mete en TXBUFFER los datos del trazador*/
int BUFFERTraceTX(uint8 * TraceTX) 
{
    3576:	af 92       	push	r10
    3578:	bf 92       	push	r11
    357a:	cf 92       	push	r12
    357c:	df 92       	push	r13
    357e:	ef 92       	push	r14
    3580:	ff 92       	push	r15
    3582:	0f 93       	push	r16
    3584:	1f 93       	push	r17
    3586:	df 93       	push	r29
    3588:	cf 93       	push	r28
    358a:	cd b7       	in	r28, 0x3d	; 61
    358c:	de b7       	in	r29, 0x3e	; 62
    358e:	28 97       	sbiw	r28, 0x08	; 8
    3590:	0f b6       	in	r0, 0x3f	; 63
    3592:	f8 94       	cli
    3594:	de bf       	out	0x3e, r29	; 62
    3596:	0f be       	out	0x3f, r0	; 63
    3598:	cd bf       	out	0x3d, r28	; 61
    359a:	5c 01       	movw	r10, r24
	int32     *pTraceBuffer;
	tPacketHeader packetHeader;
	int16 buffersize,Datasize;
	/*Estructuro el buffer a 32 bits*/
    pTraceBuffer=(int32*)TraceTX;
	buffersize=(  pTraceBuffer[0]*sizeof(int32)) +sizeof(tPacketHeader)+(sizeof(int32)*3);		   
    359c:	fc 01       	movw	r30, r24
    359e:	80 81       	ld	r24, Z
    35a0:	91 81       	ldd	r25, Z+1	; 0x01
    35a2:	a2 81       	ldd	r26, Z+2	; 0x02
    35a4:	b3 81       	ldd	r27, Z+3	; 0x03
    35a6:	05 96       	adiw	r24, 0x05	; 5
    35a8:	a1 1d       	adc	r26, r1
    35aa:	b1 1d       	adc	r27, r1
    35ac:	02 e0       	ldi	r16, 0x02	; 2
    35ae:	88 0f       	add	r24, r24
    35b0:	99 1f       	adc	r25, r25
    35b2:	aa 1f       	adc	r26, r26
    35b4:	bb 1f       	adc	r27, r27
    35b6:	0a 95       	dec	r16
    35b8:	d1 f7       	brne	.-12     	; 0x35ae <BUFFERTraceTX+0x38>
    35ba:	7c 01       	movw	r14, r24
	if(Esimpar(buffersize))
    35bc:	0e 94 55 18 	call	0x30aa	; 0x30aa <Esimpar>
    35c0:	89 2b       	or	r24, r25
    35c2:	41 f0       	breq	.+16     	; 0x35d4 <BUFFERTraceTX+0x5e>
	{
		buffersize++;		
    35c4:	08 94       	sec
    35c6:	e1 1c       	adc	r14, r1
    35c8:	f1 1c       	adc	r15, r1
		Datasize=buffersize-(sizeof(tPacketHeader)+1);	
    35ca:	17 ef       	ldi	r17, 0xF7	; 247
    35cc:	c1 2e       	mov	r12, r17
    35ce:	1f ef       	ldi	r17, 0xFF	; 255
    35d0:	d1 2e       	mov	r13, r17
    35d2:	04 c0       	rjmp	.+8      	; 0x35dc <BUFFERTraceTX+0x66>
	}
	else
	{
		Datasize=buffersize-8;	
    35d4:	b8 ef       	ldi	r27, 0xF8	; 248
    35d6:	cb 2e       	mov	r12, r27
    35d8:	bf ef       	ldi	r27, 0xFF	; 255
    35da:	db 2e       	mov	r13, r27
    35dc:	ce 0c       	add	r12, r14
    35de:	df 1c       	adc	r13, r15
	}
		
	TXBUFFER=(uint8*)declarar(buffersize);
    35e0:	c7 01       	movw	r24, r14
    35e2:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    35e6:	90 93 19 82 	sts	0x8219, r25
    35ea:	80 93 18 82 	sts	0x8218, r24
	#ifdef DEBUGUSBLevel1
	printf("BUFFERTraceTX => cantidad a mandar al PC %X\n",buffersize);			
	printf("BUFFERTraceTX => Datasize de 8bit = %X\n",Datasize);			
	printf("BUFFERTraceTX => Cantidad de datos de 32bit = %lX\n",pTraceBuffer[0]);			
	#endif		
	fillPacketHeader(&packetHeader,PacketTrace,Datasize,(uint8*)TraceTX);
    35ee:	8e 01       	movw	r16, r28
    35f0:	0f 5f       	subi	r16, 0xFF	; 255
    35f2:	1f 4f       	sbci	r17, 0xFF	; 255
    35f4:	c8 01       	movw	r24, r16
    35f6:	6c e0       	ldi	r22, 0x0C	; 12
    35f8:	70 e0       	ldi	r23, 0x00	; 0
    35fa:	a6 01       	movw	r20, r12
    35fc:	95 01       	movw	r18, r10
    35fe:	0e 94 21 18 	call	0x3042	; 0x3042 <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    3602:	c8 01       	movw	r24, r16
    3604:	b8 01       	movw	r22, r16
    3606:	48 e0       	ldi	r20, 0x08	; 8
    3608:	50 e0       	ldi	r21, 0x00	; 0
    360a:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	// meto a Fecha en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,TraceTX,PacketTrace);    
    360e:	c8 01       	movw	r24, r16
    3610:	b5 01       	movw	r22, r10
    3612:	4c e0       	ldi	r20, 0x0C	; 12
    3614:	50 e0       	ldi	r21, 0x00	; 0
    3616:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	return buffersize;
}
    361a:	c7 01       	movw	r24, r14
    361c:	28 96       	adiw	r28, 0x08	; 8
    361e:	0f b6       	in	r0, 0x3f	; 63
    3620:	f8 94       	cli
    3622:	de bf       	out	0x3e, r29	; 62
    3624:	0f be       	out	0x3f, r0	; 63
    3626:	cd bf       	out	0x3d, r28	; 61
    3628:	cf 91       	pop	r28
    362a:	df 91       	pop	r29
    362c:	1f 91       	pop	r17
    362e:	0f 91       	pop	r16
    3630:	ff 90       	pop	r15
    3632:	ef 90       	pop	r14
    3634:	df 90       	pop	r13
    3636:	cf 90       	pop	r12
    3638:	bf 90       	pop	r11
    363a:	af 90       	pop	r10
    363c:	08 95       	ret

0000363e <BUFFERAlarmaTX>:
	return buffersize;
} 

/*****************************************************************************************/
int BUFFERAlarmaTX(uint8 * AlarmaTX) 
{
    363e:	cf 92       	push	r12
    3640:	df 92       	push	r13
    3642:	ef 92       	push	r14
    3644:	ff 92       	push	r15
    3646:	0f 93       	push	r16
    3648:	1f 93       	push	r17
    364a:	df 93       	push	r29
    364c:	cf 93       	push	r28
    364e:	cd b7       	in	r28, 0x3d	; 61
    3650:	de b7       	in	r29, 0x3e	; 62
    3652:	28 97       	sbiw	r28, 0x08	; 8
    3654:	0f b6       	in	r0, 0x3f	; 63
    3656:	f8 94       	cli
    3658:	de bf       	out	0x3e, r29	; 62
    365a:	0f be       	out	0x3f, r0	; 63
    365c:	cd bf       	out	0x3d, r28	; 61
    365e:	6c 01       	movw	r12, r24
	#ifdef DEBUGUSBLevel2
	int16 j;
	#endif		
    
	buffersize=sizeof(tAlarm)+sizeof(tPacketHeader);		   
	if(Esimpar(buffersize))
    3660:	8f e0       	ldi	r24, 0x0F	; 15
    3662:	90 e0       	ldi	r25, 0x00	; 0
    3664:	0e 94 55 18 	call	0x30aa	; 0x30aa <Esimpar>
    3668:	89 2b       	or	r24, r25
    366a:	21 f4       	brne	.+8      	; 0x3674 <BUFFERAlarmaTX+0x36>
    366c:	9f e0       	ldi	r25, 0x0F	; 15
    366e:	e9 2e       	mov	r14, r25
    3670:	f1 2c       	mov	r15, r1
    3672:	03 c0       	rjmp	.+6      	; 0x367a <BUFFERAlarmaTX+0x3c>
    3674:	80 e1       	ldi	r24, 0x10	; 16
    3676:	e8 2e       	mov	r14, r24
    3678:	f1 2c       	mov	r15, r1
	else
	{
		Datasize=buffersize-8;	
	}
		
	TXBUFFER=(uint8*)declarar(buffersize);
    367a:	c7 01       	movw	r24, r14
    367c:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    3680:	90 93 19 82 	sts	0x8219, r25
    3684:	80 93 18 82 	sts	0x8218, r24
	#endif		
	#ifdef DEBUGUSBLevel1
	printf("BUFFERFechaTX => cantidad a mandar al PC %X\n",buffersize);			
	printf("BUFFERFechaTX => Datasize = %X\n",Datasize);			
	#endif		
	fillPacketHeader(&packetHeader,PacketAlarma,Datasize,(uint8*)AlarmaTX);
    3688:	8e 01       	movw	r16, r28
    368a:	0f 5f       	subi	r16, 0xFF	; 255
    368c:	1f 4f       	sbci	r17, 0xFF	; 255
    368e:	c8 01       	movw	r24, r16
    3690:	6b e0       	ldi	r22, 0x0B	; 11
    3692:	70 e0       	ldi	r23, 0x00	; 0
    3694:	47 e0       	ldi	r20, 0x07	; 7
    3696:	50 e0       	ldi	r21, 0x00	; 0
    3698:	96 01       	movw	r18, r12
    369a:	0e 94 21 18 	call	0x3042	; 0x3042 <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    369e:	c8 01       	movw	r24, r16
    36a0:	b8 01       	movw	r22, r16
    36a2:	48 e0       	ldi	r20, 0x08	; 8
    36a4:	50 e0       	ldi	r21, 0x00	; 0
    36a6:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	// meto a Fecha en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,(uint8*)AlarmaTX,PacketAlarma);    
    36aa:	c8 01       	movw	r24, r16
    36ac:	b6 01       	movw	r22, r12
    36ae:	4b e0       	ldi	r20, 0x0B	; 11
    36b0:	50 e0       	ldi	r21, 0x00	; 0
    36b2:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	return buffersize;
} 
    36b6:	c7 01       	movw	r24, r14
    36b8:	28 96       	adiw	r28, 0x08	; 8
    36ba:	0f b6       	in	r0, 0x3f	; 63
    36bc:	f8 94       	cli
    36be:	de bf       	out	0x3e, r29	; 62
    36c0:	0f be       	out	0x3f, r0	; 63
    36c2:	cd bf       	out	0x3d, r28	; 61
    36c4:	cf 91       	pop	r28
    36c6:	df 91       	pop	r29
    36c8:	1f 91       	pop	r17
    36ca:	0f 91       	pop	r16
    36cc:	ff 90       	pop	r15
    36ce:	ef 90       	pop	r14
    36d0:	df 90       	pop	r13
    36d2:	cf 90       	pop	r12
    36d4:	08 95       	ret

000036d6 <BUFFERFechaTX>:
} 

/*****************************************************************************************/

int BUFFERFechaTX(uint8 * Fecha) 
{
    36d6:	cf 92       	push	r12
    36d8:	df 92       	push	r13
    36da:	ef 92       	push	r14
    36dc:	ff 92       	push	r15
    36de:	0f 93       	push	r16
    36e0:	1f 93       	push	r17
    36e2:	df 93       	push	r29
    36e4:	cf 93       	push	r28
    36e6:	cd b7       	in	r28, 0x3d	; 61
    36e8:	de b7       	in	r29, 0x3e	; 62
    36ea:	28 97       	sbiw	r28, 0x08	; 8
    36ec:	0f b6       	in	r0, 0x3f	; 63
    36ee:	f8 94       	cli
    36f0:	de bf       	out	0x3e, r29	; 62
    36f2:	0f be       	out	0x3f, r0	; 63
    36f4:	cd bf       	out	0x3d, r28	; 61
    36f6:	6c 01       	movw	r12, r24
	#ifdef DEBUGUSBLevel2
	int16 j;
	#endif		
    
	buffersize=sizeof(tFecha)+sizeof(tPacketHeader);		   
	if(Esimpar(buffersize))
    36f8:	80 e1       	ldi	r24, 0x10	; 16
    36fa:	90 e0       	ldi	r25, 0x00	; 0
    36fc:	0e 94 55 18 	call	0x30aa	; 0x30aa <Esimpar>
    3700:	89 2b       	or	r24, r25
    3702:	21 f4       	brne	.+8      	; 0x370c <BUFFERFechaTX+0x36>
    3704:	30 e1       	ldi	r19, 0x10	; 16
    3706:	e3 2e       	mov	r14, r19
    3708:	f1 2c       	mov	r15, r1
    370a:	03 c0       	rjmp	.+6      	; 0x3712 <BUFFERFechaTX+0x3c>
    370c:	21 e1       	ldi	r18, 0x11	; 17
    370e:	e2 2e       	mov	r14, r18
    3710:	f1 2c       	mov	r15, r1
	}
	else
	{
		Datasize=buffersize-sizeof(tPacketHeader);	
	}
	TXBUFFER=(uint8*)declarar(buffersize);
    3712:	c7 01       	movw	r24, r14
    3714:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    3718:	90 93 19 82 	sts	0x8219, r25
    371c:	80 93 18 82 	sts	0x8218, r24
	#endif		
	#ifdef DEBUGUSBLevel1
	printf("BUFFERFechaTX => cantidad a mandar al PC %X\n",buffersize);			
	printf("BUFFERFechaTX => Datasize = %X\n",Datasize);			
	#endif		
	fillPacketHeader(&packetHeader,PacketFecha,Datasize,(uint8*)Fecha);
    3720:	8e 01       	movw	r16, r28
    3722:	0f 5f       	subi	r16, 0xFF	; 255
    3724:	1f 4f       	sbci	r17, 0xFF	; 255
    3726:	c8 01       	movw	r24, r16
    3728:	6a e0       	ldi	r22, 0x0A	; 10
    372a:	70 e0       	ldi	r23, 0x00	; 0
    372c:	48 e0       	ldi	r20, 0x08	; 8
    372e:	50 e0       	ldi	r21, 0x00	; 0
    3730:	96 01       	movw	r18, r12
    3732:	0e 94 21 18 	call	0x3042	; 0x3042 <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    3736:	c8 01       	movw	r24, r16
    3738:	b8 01       	movw	r22, r16
    373a:	48 e0       	ldi	r20, 0x08	; 8
    373c:	50 e0       	ldi	r21, 0x00	; 0
    373e:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	// meto a Fecha en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,(uint8*)Fecha,PacketFecha);    
    3742:	c8 01       	movw	r24, r16
    3744:	b6 01       	movw	r22, r12
    3746:	4a e0       	ldi	r20, 0x0A	; 10
    3748:	50 e0       	ldi	r21, 0x00	; 0
    374a:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	return buffersize;
} 
    374e:	c7 01       	movw	r24, r14
    3750:	28 96       	adiw	r28, 0x08	; 8
    3752:	0f b6       	in	r0, 0x3f	; 63
    3754:	f8 94       	cli
    3756:	de bf       	out	0x3e, r29	; 62
    3758:	0f be       	out	0x3f, r0	; 63
    375a:	cd bf       	out	0x3d, r28	; 61
    375c:	cf 91       	pop	r28
    375e:	df 91       	pop	r29
    3760:	1f 91       	pop	r17
    3762:	0f 91       	pop	r16
    3764:	ff 90       	pop	r15
    3766:	ef 90       	pop	r14
    3768:	df 90       	pop	r13
    376a:	cf 90       	pop	r12
    376c:	08 95       	ret

0000376e <BUFFERVectorPoseTX>:
	return buffersize;
} // sendAxisLimits

/*****************************************************************************************/
int BUFFERVectorPoseTX(uint8 * pVectorpose) 
{
    376e:	af 92       	push	r10
    3770:	bf 92       	push	r11
    3772:	cf 92       	push	r12
    3774:	df 92       	push	r13
    3776:	ef 92       	push	r14
    3778:	ff 92       	push	r15
    377a:	0f 93       	push	r16
    377c:	1f 93       	push	r17
    377e:	df 93       	push	r29
    3780:	cf 93       	push	r28
    3782:	cd b7       	in	r28, 0x3d	; 61
    3784:	de b7       	in	r29, 0x3e	; 62
    3786:	28 97       	sbiw	r28, 0x08	; 8
    3788:	0f b6       	in	r0, 0x3f	; 63
    378a:	f8 94       	cli
    378c:	de bf       	out	0x3e, r29	; 62
    378e:	0f be       	out	0x3f, r0	; 63
    3790:	cd bf       	out	0x3d, r28	; 61
    3792:	5c 01       	movw	r10, r24
	pvectortemp=(int16*)pVectorpose;
    Num_data=pvectortemp[0];
	#ifdef DEBUGUSBLevel1
	printf("BUFFERVectorPoseTX => Numero de datos en pvectortemp[0] %X\n",Num_data);			
	#endif		
	buffersize=sizeof(int16)*Num_data+sizeof(tPacketHeader);		   
    3794:	fc 01       	movw	r30, r24
    3796:	e0 80       	ld	r14, Z
    3798:	f1 80       	ldd	r15, Z+1	; 0x01
    379a:	84 e0       	ldi	r24, 0x04	; 4
    379c:	90 e0       	ldi	r25, 0x00	; 0
    379e:	e8 0e       	add	r14, r24
    37a0:	f9 1e       	adc	r15, r25
    37a2:	ee 0c       	add	r14, r14
    37a4:	ff 1c       	adc	r15, r15
	if(Esimpar(buffersize))
    37a6:	c7 01       	movw	r24, r14
    37a8:	0e 94 55 18 	call	0x30aa	; 0x30aa <Esimpar>
    37ac:	89 2b       	or	r24, r25
    37ae:	41 f0       	breq	.+16     	; 0x37c0 <BUFFERVectorPoseTX+0x52>
	{
		buffersize++;		
    37b0:	08 94       	sec
    37b2:	e1 1c       	adc	r14, r1
    37b4:	f1 1c       	adc	r15, r1
		Datasize=buffersize-(sizeof(tPacketHeader)+1);
    37b6:	57 ef       	ldi	r21, 0xF7	; 247
    37b8:	c5 2e       	mov	r12, r21
    37ba:	5f ef       	ldi	r21, 0xFF	; 255
    37bc:	d5 2e       	mov	r13, r21
    37be:	04 c0       	rjmp	.+8      	; 0x37c8 <BUFFERVectorPoseTX+0x5a>
	}
	else
	{
		Datasize=buffersize-sizeof(tPacketHeader);
    37c0:	48 ef       	ldi	r20, 0xF8	; 248
    37c2:	c4 2e       	mov	r12, r20
    37c4:	4f ef       	ldi	r20, 0xFF	; 255
    37c6:	d4 2e       	mov	r13, r20
    37c8:	ce 0c       	add	r12, r14
    37ca:	df 1c       	adc	r13, r15
	}
	TXBUFFER=(uint8*)declarar(buffersize);
    37cc:	c7 01       	movw	r24, r14
    37ce:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    37d2:	90 93 19 82 	sts	0x8219, r25
    37d6:	80 93 18 82 	sts	0x8218, r24
	#ifdef DEBUGUSBLevel1
	printf("BUFFERVectorPoseTX => cantidad a mandar al PC %X\n",buffersize);			
	printf("BUFFERVectorPoseTX => Datasize = %X\n",Datasize);			
	#endif		
	fillPacketHeader(&packetHeader,PacketPosesvector,Datasize,(uint8*)pVectorpose);
    37da:	8e 01       	movw	r16, r28
    37dc:	0f 5f       	subi	r16, 0xFF	; 255
    37de:	1f 4f       	sbci	r17, 0xFF	; 255
    37e0:	c8 01       	movw	r24, r16
    37e2:	69 e0       	ldi	r22, 0x09	; 9
    37e4:	70 e0       	ldi	r23, 0x00	; 0
    37e6:	a6 01       	movw	r20, r12
    37e8:	95 01       	movw	r18, r10
    37ea:	0e 94 21 18 	call	0x3042	; 0x3042 <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    37ee:	c8 01       	movw	r24, r16
    37f0:	b8 01       	movw	r22, r16
    37f2:	48 e0       	ldi	r20, 0x08	; 8
    37f4:	50 e0       	ldi	r21, 0x00	; 0
    37f6:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	// meto el tAxisLimits en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,(uint8*)pVectorpose,PacketPosesvector);    
    37fa:	c8 01       	movw	r24, r16
    37fc:	b5 01       	movw	r22, r10
    37fe:	49 e0       	ldi	r20, 0x09	; 9
    3800:	50 e0       	ldi	r21, 0x00	; 0
    3802:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	return buffersize;
} 
    3806:	c7 01       	movw	r24, r14
    3808:	28 96       	adiw	r28, 0x08	; 8
    380a:	0f b6       	in	r0, 0x3f	; 63
    380c:	f8 94       	cli
    380e:	de bf       	out	0x3e, r29	; 62
    3810:	0f be       	out	0x3f, r0	; 63
    3812:	cd bf       	out	0x3d, r28	; 61
    3814:	cf 91       	pop	r28
    3816:	df 91       	pop	r29
    3818:	1f 91       	pop	r17
    381a:	0f 91       	pop	r16
    381c:	ff 90       	pop	r15
    381e:	ef 90       	pop	r14
    3820:	df 90       	pop	r13
    3822:	cf 90       	pop	r12
    3824:	bf 90       	pop	r11
    3826:	af 90       	pop	r10
    3828:	08 95       	ret

0000382a <BUFFERAxisLimitsTX>:
} // sendAxisSettings

/*****************************************************************************************/
// send axis limits information
int BUFFERAxisLimitsTX(tAxisLimits *paxisLimits) 
{
    382a:	cf 92       	push	r12
    382c:	df 92       	push	r13
    382e:	ef 92       	push	r14
    3830:	ff 92       	push	r15
    3832:	0f 93       	push	r16
    3834:	1f 93       	push	r17
    3836:	df 93       	push	r29
    3838:	cf 93       	push	r28
    383a:	cd b7       	in	r28, 0x3d	; 61
    383c:	de b7       	in	r29, 0x3e	; 62
    383e:	28 97       	sbiw	r28, 0x08	; 8
    3840:	0f b6       	in	r0, 0x3f	; 63
    3842:	f8 94       	cli
    3844:	de bf       	out	0x3e, r29	; 62
    3846:	0f be       	out	0x3f, r0	; 63
    3848:	cd bf       	out	0x3d, r28	; 61
    384a:	d8 2e       	mov	r13, r24
    384c:	c9 2e       	mov	r12, r25

	tPacketHeader packetHeader;
	int16 buffersize,Datasize;
	
	buffersize=sizeof(tAxisLimits)+sizeof(tPacketHeader);	
	if(Esimpar(buffersize))
    384e:	80 e1       	ldi	r24, 0x10	; 16
    3850:	90 e0       	ldi	r25, 0x00	; 0
    3852:	0e 94 55 18 	call	0x30aa	; 0x30aa <Esimpar>
    3856:	89 2b       	or	r24, r25
    3858:	21 f4       	brne	.+8      	; 0x3862 <BUFFERAxisLimitsTX+0x38>
    385a:	e0 e1       	ldi	r30, 0x10	; 16
    385c:	ee 2e       	mov	r14, r30
    385e:	f1 2c       	mov	r15, r1
    3860:	03 c0       	rjmp	.+6      	; 0x3868 <BUFFERAxisLimitsTX+0x3e>
    3862:	71 e1       	ldi	r23, 0x11	; 17
    3864:	e7 2e       	mov	r14, r23
    3866:	f1 2c       	mov	r15, r1
	}
	else
	{
		Datasize=buffersize-8;						  	
	}		
	TXBUFFER=(uint8*)declarar(buffersize);
    3868:	c7 01       	movw	r24, r14
    386a:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    386e:	90 93 19 82 	sts	0x8219, r25
    3872:	80 93 18 82 	sts	0x8218, r24
	//sizeof(tAxisLimits)
	fillPacketHeader(&packetHeader,PacketAxisLimits,Datasize,(uint8*)paxisLimits);
    3876:	8e 01       	movw	r16, r28
    3878:	0f 5f       	subi	r16, 0xFF	; 255
    387a:	1f 4f       	sbci	r17, 0xFF	; 255
    387c:	c8 01       	movw	r24, r16
    387e:	67 e0       	ldi	r22, 0x07	; 7
    3880:	70 e0       	ldi	r23, 0x00	; 0
    3882:	48 e0       	ldi	r20, 0x08	; 8
    3884:	50 e0       	ldi	r21, 0x00	; 0
    3886:	2d 2d       	mov	r18, r13
    3888:	3c 2d       	mov	r19, r12
    388a:	0e 94 21 18 	call	0x3042	; 0x3042 <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    388e:	c8 01       	movw	r24, r16
    3890:	b8 01       	movw	r22, r16
    3892:	48 e0       	ldi	r20, 0x08	; 8
    3894:	50 e0       	ldi	r21, 0x00	; 0
    3896:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	// meto el tAxisLimits en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,(uint8*)paxisLimits,PacketAxisLimits);    
    389a:	c8 01       	movw	r24, r16
    389c:	6d 2d       	mov	r22, r13
    389e:	7c 2d       	mov	r23, r12
    38a0:	47 e0       	ldi	r20, 0x07	; 7
    38a2:	50 e0       	ldi	r21, 0x00	; 0
    38a4:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	return buffersize;
} // sendAxisLimits
    38a8:	c7 01       	movw	r24, r14
    38aa:	28 96       	adiw	r28, 0x08	; 8
    38ac:	0f b6       	in	r0, 0x3f	; 63
    38ae:	f8 94       	cli
    38b0:	de bf       	out	0x3e, r29	; 62
    38b2:	0f be       	out	0x3f, r0	; 63
    38b4:	cd bf       	out	0x3d, r28	; 61
    38b6:	cf 91       	pop	r28
    38b8:	df 91       	pop	r29
    38ba:	1f 91       	pop	r17
    38bc:	0f 91       	pop	r16
    38be:	ff 90       	pop	r15
    38c0:	ef 90       	pop	r14
    38c2:	df 90       	pop	r13
    38c4:	cf 90       	pop	r12
    38c6:	08 95       	ret

000038c8 <BUFFERAxisSettingsTX>:
} // sendTrajectory

/*****************************************************************************************/
// send axis limits information PC-uC uC-Pc
int BUFFERAxisSettingsTX(tAxisSettings *paxisSettings) 
{
    38c8:	cf 92       	push	r12
    38ca:	df 92       	push	r13
    38cc:	ef 92       	push	r14
    38ce:	ff 92       	push	r15
    38d0:	0f 93       	push	r16
    38d2:	1f 93       	push	r17
    38d4:	df 93       	push	r29
    38d6:	cf 93       	push	r28
    38d8:	cd b7       	in	r28, 0x3d	; 61
    38da:	de b7       	in	r29, 0x3e	; 62
    38dc:	28 97       	sbiw	r28, 0x08	; 8
    38de:	0f b6       	in	r0, 0x3f	; 63
    38e0:	f8 94       	cli
    38e2:	de bf       	out	0x3e, r29	; 62
    38e4:	0f be       	out	0x3f, r0	; 63
    38e6:	cd bf       	out	0x3d, r28	; 61
    38e8:	d8 2e       	mov	r13, r24
    38ea:	c9 2e       	mov	r12, r25
	tPacketHeader packetHeader;
	int16 buffersize,Datasize;
	
	buffersize=sizeof(tAxisSettings)*DOF+sizeof(tPacketHeader);		   
	if(Esimpar(buffersize))
    38ec:	8c e5       	ldi	r24, 0x5C	; 92
    38ee:	91 e0       	ldi	r25, 0x01	; 1
    38f0:	0e 94 55 18 	call	0x30aa	; 0x30aa <Esimpar>
    38f4:	89 2b       	or	r24, r25
    38f6:	29 f4       	brne	.+10     	; 0x3902 <BUFFERAxisSettingsTX+0x3a>
    38f8:	ac e5       	ldi	r26, 0x5C	; 92
    38fa:	ea 2e       	mov	r14, r26
    38fc:	a1 e0       	ldi	r26, 0x01	; 1
    38fe:	fa 2e       	mov	r15, r26
    3900:	04 c0       	rjmp	.+8      	; 0x390a <BUFFERAxisSettingsTX+0x42>
    3902:	fd e5       	ldi	r31, 0x5D	; 93
    3904:	ef 2e       	mov	r14, r31
    3906:	f1 e0       	ldi	r31, 0x01	; 1
    3908:	ff 2e       	mov	r15, r31
	}
	else
	{
		Datasize=buffersize-8;						  	
	}		
	TXBUFFER=(uint8*)declarar(buffersize);
    390a:	c7 01       	movw	r24, r14
    390c:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    3910:	90 93 19 82 	sts	0x8219, r25
    3914:	80 93 18 82 	sts	0x8218, r24
	//sizeof(tAxisSettings)
	fillPacketHeader(&packetHeader,PacketAxisSettings,Datasize,(uint8*)paxisSettings);
    3918:	8e 01       	movw	r16, r28
    391a:	0f 5f       	subi	r16, 0xFF	; 255
    391c:	1f 4f       	sbci	r17, 0xFF	; 255
    391e:	c8 01       	movw	r24, r16
    3920:	66 e0       	ldi	r22, 0x06	; 6
    3922:	70 e0       	ldi	r23, 0x00	; 0
    3924:	44 e5       	ldi	r20, 0x54	; 84
    3926:	51 e0       	ldi	r21, 0x01	; 1
    3928:	2d 2d       	mov	r18, r13
    392a:	3c 2d       	mov	r19, r12
    392c:	0e 94 21 18 	call	0x3042	; 0x3042 <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);        
    3930:	c8 01       	movw	r24, r16
    3932:	b8 01       	movw	r22, r16
    3934:	48 e0       	ldi	r20, 0x08	; 8
    3936:	50 e0       	ldi	r21, 0x00	; 0
    3938:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	// meto el tAxisSttings en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)paxisSettings,PacketAxisSettings);  
    393c:	c8 01       	movw	r24, r16
    393e:	6d 2d       	mov	r22, r13
    3940:	7c 2d       	mov	r23, r12
    3942:	46 e0       	ldi	r20, 0x06	; 6
    3944:	50 e0       	ldi	r21, 0x00	; 0
    3946:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	return buffersize;
} // sendAxisSettings
    394a:	c7 01       	movw	r24, r14
    394c:	28 96       	adiw	r28, 0x08	; 8
    394e:	0f b6       	in	r0, 0x3f	; 63
    3950:	f8 94       	cli
    3952:	de bf       	out	0x3e, r29	; 62
    3954:	0f be       	out	0x3f, r0	; 63
    3956:	cd bf       	out	0x3d, r28	; 61
    3958:	cf 91       	pop	r28
    395a:	df 91       	pop	r29
    395c:	1f 91       	pop	r17
    395e:	0f 91       	pop	r16
    3960:	ff 90       	pop	r15
    3962:	ef 90       	pop	r14
    3964:	df 90       	pop	r13
    3966:	cf 90       	pop	r12
    3968:	08 95       	ret

0000396a <BUFFERTrajectoryTX>:
	
/*****************************************************************************************/
//Coloca la trayectoria + el header en TXBUFFER para luego ser enviada
//tipo puede ser PacketTeachPendant o PacketTrajectory 
int BUFFERTrajectoryTX(tTrajectory *pTrajectory,int16 puntos,tPacket tipo) 
{
    396a:	8f 92       	push	r8
    396c:	9f 92       	push	r9
    396e:	af 92       	push	r10
    3970:	bf 92       	push	r11
    3972:	cf 92       	push	r12
    3974:	df 92       	push	r13
    3976:	ef 92       	push	r14
    3978:	ff 92       	push	r15
    397a:	0f 93       	push	r16
    397c:	1f 93       	push	r17
    397e:	df 93       	push	r29
    3980:	cf 93       	push	r28
    3982:	cd b7       	in	r28, 0x3d	; 61
    3984:	de b7       	in	r29, 0x3e	; 62
    3986:	28 97       	sbiw	r28, 0x08	; 8
    3988:	0f b6       	in	r0, 0x3f	; 63
    398a:	f8 94       	cli
    398c:	de bf       	out	0x3e, r29	; 62
    398e:	0f be       	out	0x3f, r0	; 63
    3990:	cd bf       	out	0x3d, r28	; 61
    3992:	98 2e       	mov	r9, r24
    3994:	89 2e       	mov	r8, r25
    3996:	5a 01       	movw	r10, r20
	tPacketHeader packetHeader;
	//asigno memoria para guardar la trayectoria, 
	//3 de  campos: una estructura tpoint * numero de puntos 
	//+ 2 campos  int16 (dummy y size) 
	//mas el tamao del header
	buffersize=sizeof(tpoint)*puntos+2*sizeof(int16)+sizeof(tPacketHeader); 
    3998:	8d e3       	ldi	r24, 0x3D	; 61
    399a:	90 e0       	ldi	r25, 0x00	; 0
    399c:	68 9f       	mul	r22, r24
    399e:	80 01       	movw	r16, r0
    39a0:	69 9f       	mul	r22, r25
    39a2:	10 0d       	add	r17, r0
    39a4:	78 9f       	mul	r23, r24
    39a6:	10 0d       	add	r17, r0
    39a8:	11 24       	eor	r1, r1
    39aa:	8c e0       	ldi	r24, 0x0C	; 12
    39ac:	e8 2e       	mov	r14, r24
    39ae:	f1 2c       	mov	r15, r1
    39b0:	e0 0e       	add	r14, r16
    39b2:	f1 1e       	adc	r15, r17
	if(Esimpar(buffersize))
    39b4:	c7 01       	movw	r24, r14
    39b6:	0e 94 55 18 	call	0x30aa	; 0x30aa <Esimpar>
    39ba:	b4 e0       	ldi	r27, 0x04	; 4
    39bc:	cb 2e       	mov	r12, r27
    39be:	d1 2c       	mov	r13, r1
    39c0:	c0 0e       	add	r12, r16
    39c2:	d1 1e       	adc	r13, r17
    39c4:	89 2b       	or	r24, r25
    39c6:	29 f0       	breq	.+10     	; 0x39d2 <BUFFERTrajectoryTX+0x68>
	{
		buffersize++;		
    39c8:	78 01       	movw	r14, r16
    39ca:	8d e0       	ldi	r24, 0x0D	; 13
    39cc:	90 e0       	ldi	r25, 0x00	; 0
    39ce:	e8 0e       	add	r14, r24
    39d0:	f9 1e       	adc	r15, r25
	else
	{
		Datasize=buffersize-8;						  	
	}
	
	TXBUFFER=(uint8*)declarar(buffersize);    
    39d2:	c7 01       	movw	r24, r14
    39d4:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    39d8:	90 93 19 82 	sts	0x8219, r25
    39dc:	80 93 18 82 	sts	0x8218, r24
	//Resto el numero de bytes del header pues este es la cantidad de datos 
	//que se quieren enviar	   	    
	//
	
	fillPacketHeader(&packetHeader,tipo,(tDataLength)Datasize,(uint8*)pTrajectory);
    39e0:	8e 01       	movw	r16, r28
    39e2:	0f 5f       	subi	r16, 0xFF	; 255
    39e4:	1f 4f       	sbci	r17, 0xFF	; 255
    39e6:	c8 01       	movw	r24, r16
    39e8:	b5 01       	movw	r22, r10
    39ea:	a6 01       	movw	r20, r12
    39ec:	29 2d       	mov	r18, r9
    39ee:	38 2d       	mov	r19, r8
    39f0:	0e 94 21 18 	call	0x3042	; 0x3042 <fillPacketHeader>
	printf("BUFFERTrajectoryTX=> header.datalength en BUFFERCommandTX=> %x\n", packetHeader.dataLength);
	printf("BUFFERTrajectoryTX=> packetHeader.dataChecksum en BUFFERCommandTX=> %x\n",packetHeader.dataChecksum);
	printf("BUFFERTrajectoryTX=> packetHeader.headerChecksum en BUFFERCommandTX=> %d\n",packetHeader.headerChecksum);	
	#endif
	//coloco el packet Header en el TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader); 
    39f4:	c8 01       	movw	r24, r16
    39f6:	b8 01       	movw	r22, r16
    39f8:	48 e0       	ldi	r20, 0x08	; 8
    39fa:	50 e0       	ldi	r21, 0x00	; 0
    39fc:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	 //coloco los datos en el TXBUFFER independiente si es de tipo PacketTeachPendant 
	//o PacketTrajectory uso PacketTrajectory  
	BUFFERPacketDataTX(&packetHeader,(uint8*)pTrajectory,PacketTrajectory); 
    3a00:	c8 01       	movw	r24, r16
    3a02:	69 2d       	mov	r22, r9
    3a04:	78 2d       	mov	r23, r8
    3a06:	43 e0       	ldi	r20, 0x03	; 3
    3a08:	50 e0       	ldi	r21, 0x00	; 0
    3a0a:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	return buffersize;
} // sendTrajectory
    3a0e:	c7 01       	movw	r24, r14
    3a10:	28 96       	adiw	r28, 0x08	; 8
    3a12:	0f b6       	in	r0, 0x3f	; 63
    3a14:	f8 94       	cli
    3a16:	de bf       	out	0x3e, r29	; 62
    3a18:	0f be       	out	0x3f, r0	; 63
    3a1a:	cd bf       	out	0x3d, r28	; 61
    3a1c:	cf 91       	pop	r28
    3a1e:	df 91       	pop	r29
    3a20:	1f 91       	pop	r17
    3a22:	0f 91       	pop	r16
    3a24:	ff 90       	pop	r15
    3a26:	ef 90       	pop	r14
    3a28:	df 90       	pop	r13
    3a2a:	cf 90       	pop	r12
    3a2c:	bf 90       	pop	r11
    3a2e:	af 90       	pop	r10
    3a30:	9f 90       	pop	r9
    3a32:	8f 90       	pop	r8
    3a34:	08 95       	ret

00003a36 <BUFFERCommandTX>:
} // sendPacketData

/*****************************************************************************************/
// a short way to send a command byte
int BUFFERCommandTX(tCommand* command) 
{
    3a36:	cf 92       	push	r12
    3a38:	df 92       	push	r13
    3a3a:	ef 92       	push	r14
    3a3c:	ff 92       	push	r15
    3a3e:	0f 93       	push	r16
    3a40:	1f 93       	push	r17
    3a42:	df 93       	push	r29
    3a44:	cf 93       	push	r28
    3a46:	cd b7       	in	r28, 0x3d	; 61
    3a48:	de b7       	in	r29, 0x3e	; 62
    3a4a:	28 97       	sbiw	r28, 0x08	; 8
    3a4c:	0f b6       	in	r0, 0x3f	; 63
    3a4e:	f8 94       	cli
    3a50:	de bf       	out	0x3e, r29	; 62
    3a52:	0f be       	out	0x3f, r0	; 63
    3a54:	cd bf       	out	0x3d, r28	; 61
    3a56:	d8 2e       	mov	r13, r24
    3a58:	c9 2e       	mov	r12, r25
	tPacketHeader packetHeader;
	int16 buffersize;	
	
	buffersize=sizeof(tCommand)+sizeof(tPacketHeader);
	if(Esimpar(buffersize))
    3a5a:	83 e2       	ldi	r24, 0x23	; 35
    3a5c:	90 e0       	ldi	r25, 0x00	; 0
    3a5e:	0e 94 55 18 	call	0x30aa	; 0x30aa <Esimpar>
    3a62:	89 2b       	or	r24, r25
    3a64:	21 f0       	breq	.+8      	; 0x3a6e <BUFFERCommandTX+0x38>
    3a66:	24 e2       	ldi	r18, 0x24	; 36
    3a68:	e2 2e       	mov	r14, r18
    3a6a:	f1 2c       	mov	r15, r1
    3a6c:	03 c0       	rjmp	.+6      	; 0x3a74 <BUFFERCommandTX+0x3e>
    3a6e:	93 e2       	ldi	r25, 0x23	; 35
    3a70:	e9 2e       	mov	r14, r25
    3a72:	f1 2c       	mov	r15, r1
		buffersize++;		
	TXBUFFER=(uint8*)declarar(buffersize);
    3a74:	c7 01       	movw	r24, r14
    3a76:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    3a7a:	90 93 19 82 	sts	0x8219, r25
    3a7e:	80 93 18 82 	sts	0x8218, r24
	//sizeof(tCommand)
	fillPacketHeader(&packetHeader,PacketCommand,sizeof(tCommand),(uint8*)command);
    3a82:	8e 01       	movw	r16, r28
    3a84:	0f 5f       	subi	r16, 0xFF	; 255
    3a86:	1f 4f       	sbci	r17, 0xFF	; 255
    3a88:	c8 01       	movw	r24, r16
    3a8a:	61 e0       	ldi	r22, 0x01	; 1
    3a8c:	70 e0       	ldi	r23, 0x00	; 0
    3a8e:	4b e1       	ldi	r20, 0x1B	; 27
    3a90:	50 e0       	ldi	r21, 0x00	; 0
    3a92:	2d 2d       	mov	r18, r13
    3a94:	3c 2d       	mov	r19, r12
    3a96:	0e 94 21 18 	call	0x3042	; 0x3042 <fillPacketHeader>
	// meto el header en TXBUFFER	
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader); 
    3a9a:	c8 01       	movw	r24, r16
    3a9c:	b8 01       	movw	r22, r16
    3a9e:	48 e0       	ldi	r20, 0x08	; 8
    3aa0:	50 e0       	ldi	r21, 0x00	; 0
    3aa2:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	printf("BUFFERCommandTX=> header.datalength en BUFFERCommandTX=> %x\n", packetHeader.dataLength);
	printf("BUFFERCommandTX=> packetHeader.dataChecksum en BUFFERCommandTX=> %x\n",packetHeader.dataChecksum);
	printf("BUFFERCommandTX=> packetHeader.headerChecksum en BUFFERCommandTX=> %d\n",packetHeader.headerChecksum);	
	#endif
	//meto el command en TXBUFFER despues del header 
	BUFFERPacketDataTX(&packetHeader,(uint8*)command,PacketCommand);     
    3aa6:	c8 01       	movw	r24, r16
    3aa8:	6d 2d       	mov	r22, r13
    3aaa:	7c 2d       	mov	r23, r12
    3aac:	41 e0       	ldi	r20, 0x01	; 1
    3aae:	50 e0       	ldi	r21, 0x00	; 0
    3ab0:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	return buffersize;
} // sendCommand
    3ab4:	c7 01       	movw	r24, r14
    3ab6:	28 96       	adiw	r28, 0x08	; 8
    3ab8:	0f b6       	in	r0, 0x3f	; 63
    3aba:	f8 94       	cli
    3abc:	de bf       	out	0x3e, r29	; 62
    3abe:	0f be       	out	0x3f, r0	; 63
    3ac0:	cd bf       	out	0x3d, r28	; 61
    3ac2:	cf 91       	pop	r28
    3ac4:	df 91       	pop	r29
    3ac6:	1f 91       	pop	r17
    3ac8:	0f 91       	pop	r16
    3aca:	ff 90       	pop	r15
    3acc:	ef 90       	pop	r14
    3ace:	df 90       	pop	r13
    3ad0:	cf 90       	pop	r12
    3ad2:	08 95       	ret

00003ad4 <readTrajectoryRX>:

/*****************************************************************************************/
//pTrajectory es la trayectoria destino
//RXBUFFER[0] tiene la estructura trayectoria no el header	
int16 readTrajectoryRX(tTrajectory *pTrajectory,tPacketHeader packetHeader) 
{
    3ad4:	cf 92       	push	r12
    3ad6:	df 92       	push	r13
    3ad8:	ef 92       	push	r14
    3ada:	ff 92       	push	r15
    3adc:	0f 93       	push	r16
    3ade:	1f 93       	push	r17
    3ae0:	df 93       	push	r29
    3ae2:	cf 93       	push	r28
    3ae4:	cd b7       	in	r28, 0x3d	; 61
    3ae6:	de b7       	in	r29, 0x3e	; 62
    3ae8:	28 97       	sbiw	r28, 0x08	; 8
    3aea:	0f b6       	in	r0, 0x3f	; 63
    3aec:	f8 94       	cli
    3aee:	de bf       	out	0x3e, r29	; 62
    3af0:	0f be       	out	0x3f, r0	; 63
    3af2:	cd bf       	out	0x3d, r28	; 61
    3af4:	7c 01       	movw	r14, r24
    3af6:	09 83       	std	Y+1, r16	; 0x01
    3af8:	1a 83       	std	Y+2, r17	; 0x02
    3afa:	2b 83       	std	Y+3, r18	; 0x03
    3afc:	3c 83       	std	Y+4, r19	; 0x04
    3afe:	4d 83       	std	Y+5, r20	; 0x05
    3b00:	5e 83       	std	Y+6, r21	; 0x06
    3b02:	6f 83       	std	Y+7, r22	; 0x07
    3b04:	78 87       	std	Y+8, r23	; 0x08
    3b06:	0b 81       	ldd	r16, Y+3	; 0x03
    3b08:	1c 81       	ldd	r17, Y+4	; 0x04
    3b0a:	cd 80       	ldd	r12, Y+5	; 0x05
    3b0c:	de 80       	ldd	r13, Y+6	; 0x06
  
	
	pdata = (uint8*)pTrajectory;				
	//Leemos  4 bytes  del RXBUFFER los 3 campos: puntos,dummy,*tpont 
	for(i=0; i<4; i++) 
		pdata[i]=RXBUFFER[i];
    3b0e:	e0 91 16 82 	lds	r30, 0x8216
    3b12:	f0 91 17 82 	lds	r31, 0x8217
    3b16:	80 81       	ld	r24, Z
    3b18:	f7 01       	movw	r30, r14
    3b1a:	80 83       	st	Z, r24
    3b1c:	e0 91 16 82 	lds	r30, 0x8216
    3b20:	f0 91 17 82 	lds	r31, 0x8217
    3b24:	81 81       	ldd	r24, Z+1	; 0x01
    3b26:	f7 01       	movw	r30, r14
    3b28:	81 83       	std	Z+1, r24	; 0x01
    3b2a:	e0 91 16 82 	lds	r30, 0x8216
    3b2e:	f0 91 17 82 	lds	r31, 0x8217
    3b32:	82 81       	ldd	r24, Z+2	; 0x02
    3b34:	f7 01       	movw	r30, r14
    3b36:	82 83       	std	Z+2, r24	; 0x02
    3b38:	e0 91 16 82 	lds	r30, 0x8216
    3b3c:	f0 91 17 82 	lds	r31, 0x8217
    3b40:	83 81       	ldd	r24, Z+3	; 0x03
    3b42:	f7 01       	movw	r30, r14
    3b44:	83 83       	std	Z+3, r24	; 0x03
	#endif
	//pTrajectory->size es la cantidad de puntos de la trayectoria, 
	//cada punto tiene un tamao tpoint 
    j=(pTrajectory->size)*sizeof(tpoint);       
	//Reservo espacio para guardar toda esa informacion que viene desde el USB
	pTrajectory->point=(tpoint *)declarar(j); 
    3b46:	20 81       	ld	r18, Z
    3b48:	31 81       	ldd	r19, Z+1	; 0x01
    3b4a:	8d e3       	ldi	r24, 0x3D	; 61
    3b4c:	90 e0       	ldi	r25, 0x00	; 0
    3b4e:	ac 01       	movw	r20, r24
    3b50:	24 9f       	mul	r18, r20
    3b52:	c0 01       	movw	r24, r0
    3b54:	25 9f       	mul	r18, r21
    3b56:	90 0d       	add	r25, r0
    3b58:	34 9f       	mul	r19, r20
    3b5a:	90 0d       	add	r25, r0
    3b5c:	11 24       	eor	r1, r1
    3b5e:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    3b62:	f7 01       	movw	r30, r14
    3b64:	84 83       	std	Z+4, r24	; 0x04
    3b66:	95 83       	std	Z+5, r25	; 0x05
    3b68:	dc 01       	movw	r26, r24
    3b6a:	24 e0       	ldi	r18, 0x04	; 4
    3b6c:	30 e0       	ldi	r19, 0x00	; 0
    3b6e:	0a c0       	rjmp	.+20     	; 0x3b84 <readTrajectoryRX+0xb0>
	//En el siguiente  for pdata[0] corresponde a los datos a los que apunta pTrajectory->point
	//RXBUFFER[j] = tiene la informacion de los puntos que llegaron desde USB
	//i = 3, 3 campos puntos,dummy,y apuntador a tpont que ya incluido
	//j tiene que llegar hasta el final de los datos
	for(j=i; j<packetHeader.dataLength;j++) 
		pdata[j-i]=RXBUFFER[j]; 
    3b70:	e0 91 16 82 	lds	r30, 0x8216
    3b74:	f0 91 17 82 	lds	r31, 0x8217
    3b78:	e2 0f       	add	r30, r18
    3b7a:	f3 1f       	adc	r31, r19
    3b7c:	80 81       	ld	r24, Z
    3b7e:	8d 93       	st	X+, r24
	pdata = (uint8*)pTrajectory->point;        
	//En el siguiente  for pdata[0] corresponde a los datos a los que apunta pTrajectory->point
	//RXBUFFER[j] = tiene la informacion de los puntos que llegaron desde USB
	//i = 3, 3 campos puntos,dummy,y apuntador a tpont que ya incluido
	//j tiene que llegar hasta el final de los datos
	for(j=i; j<packetHeader.dataLength;j++) 
    3b80:	2f 5f       	subi	r18, 0xFF	; 255
    3b82:	3f 4f       	sbci	r19, 0xFF	; 255
    3b84:	20 17       	cp	r18, r16
    3b86:	31 07       	cpc	r19, r17
    3b88:	9c f3       	brlt	.-26     	; 0x3b70 <readTrajectoryRX+0x9c>
	    printf("readTrajectoryRX => RXBUFFER[%d]=%X pdata[%d]=%X \n",k+i,RXBUFFER[k+i],k,pdata[k]);							       
	}
	printf("readTrajectoryRX => Addr pTrajectory->point = %X \n",(int16)pTrajectory->point);							    
    #endif
	//checksumOk calcula el cheksum con los datos recibidos
	if(!checksumOk (packetHeader.dataLength,(uint8*)pTrajectory,packetHeader.dataChecksum,PacketTrajectory))
    3b8a:	c8 01       	movw	r24, r16
    3b8c:	b7 01       	movw	r22, r14
    3b8e:	a6 01       	movw	r20, r12
    3b90:	23 e0       	ldi	r18, 0x03	; 3
    3b92:	30 e0       	ldi	r19, 0x00	; 0
    3b94:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <checksumOk>
    3b98:	89 2b       	or	r24, r25
    3b9a:	19 f0       	breq	.+6      	; 0x3ba2 <readTrajectoryRX+0xce>
    3b9c:	20 e0       	ldi	r18, 0x00	; 0
    3b9e:	30 e0       	ldi	r19, 0x00	; 0
    3ba0:	02 c0       	rjmp	.+4      	; 0x3ba6 <readTrajectoryRX+0xd2>
    3ba2:	25 e0       	ldi	r18, 0x05	; 5
    3ba4:	30 e0       	ldi	r19, 0x00	; 0
		return rcInvalidChecksum;
return rc;
} 
    3ba6:	c9 01       	movw	r24, r18
    3ba8:	28 96       	adiw	r28, 0x08	; 8
    3baa:	0f b6       	in	r0, 0x3f	; 63
    3bac:	f8 94       	cli
    3bae:	de bf       	out	0x3e, r29	; 62
    3bb0:	0f be       	out	0x3f, r0	; 63
    3bb2:	cd bf       	out	0x3d, r28	; 61
    3bb4:	cf 91       	pop	r28
    3bb6:	df 91       	pop	r29
    3bb8:	1f 91       	pop	r17
    3bba:	0f 91       	pop	r16
    3bbc:	ff 90       	pop	r15
    3bbe:	ef 90       	pop	r14
    3bc0:	df 90       	pop	r13
    3bc2:	cf 90       	pop	r12
    3bc4:	08 95       	ret

00003bc6 <BUFFERStringTX>:
	return buffersize;
} // sendCommand

/*****************************************************************************************/
int BUFFERStringTX(uint8 *string) 
{  
    3bc6:	cf 92       	push	r12
    3bc8:	df 92       	push	r13
    3bca:	ef 92       	push	r14
    3bcc:	ff 92       	push	r15
    3bce:	0f 93       	push	r16
    3bd0:	1f 93       	push	r17
    3bd2:	df 93       	push	r29
    3bd4:	cf 93       	push	r28
    3bd6:	cd b7       	in	r28, 0x3d	; 61
    3bd8:	de b7       	in	r29, 0x3e	; 62
    3bda:	28 97       	sbiw	r28, 0x08	; 8
    3bdc:	0f b6       	in	r0, 0x3f	; 63
    3bde:	f8 94       	cli
    3be0:	de bf       	out	0x3e, r29	; 62
    3be2:	0f be       	out	0x3f, r0	; 63
    3be4:	cd bf       	out	0x3d, r28	; 61
    3be6:	d8 2e       	mov	r13, r24
    3be8:	c9 2e       	mov	r12, r25
	int16 buffersize= 0;
	int16 Datasize= 0;
	tPacketHeader packetHeader;
    
	info=(uint8*)string;
	buffersize=strlen((char*)info)+sizeof(tPacketHeader);
    3bea:	e8 2f       	mov	r30, r24
    3bec:	f9 2f       	mov	r31, r25
    3bee:	df 01       	movw	r26, r30
    3bf0:	0d 90       	ld	r0, X+
    3bf2:	00 20       	and	r0, r0
    3bf4:	e9 f7       	brne	.-6      	; 0x3bf0 <BUFFERStringTX+0x2a>
    3bf6:	8d 01       	movw	r16, r26
    3bf8:	01 50       	subi	r16, 0x01	; 1
    3bfa:	10 40       	sbci	r17, 0x00	; 0
    3bfc:	0e 1b       	sub	r16, r30
    3bfe:	1f 0b       	sbc	r17, r31
    3c00:	48 e0       	ldi	r20, 0x08	; 8
    3c02:	e4 2e       	mov	r14, r20
    3c04:	f1 2c       	mov	r15, r1
    3c06:	e0 0e       	add	r14, r16
    3c08:	f1 1e       	adc	r15, r17
	if(Esimpar(buffersize))
    3c0a:	c7 01       	movw	r24, r14
    3c0c:	0e 94 55 18 	call	0x30aa	; 0x30aa <Esimpar>
    3c10:	89 2b       	or	r24, r25
    3c12:	29 f0       	breq	.+10     	; 0x3c1e <BUFFERStringTX+0x58>
		buffersize++;		
    3c14:	39 e0       	ldi	r19, 0x09	; 9
    3c16:	e3 2e       	mov	r14, r19
    3c18:	f1 2c       	mov	r15, r1
    3c1a:	e0 0e       	add	r14, r16
    3c1c:	f1 1e       	adc	r15, r17
	TXBUFFER=(uint8*)declarar(buffersize);
    3c1e:	c7 01       	movw	r24, r14
    3c20:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    3c24:	90 93 19 82 	sts	0x8219, r25
    3c28:	80 93 18 82 	sts	0x8218, r24
	//Datasize tiene la logitud de la informacion en bytes
	Datasize=strlen((char*)info);
    3c2c:	ed 2d       	mov	r30, r13
    3c2e:	fc 2d       	mov	r31, r12
    3c30:	df 01       	movw	r26, r30
    3c32:	0d 90       	ld	r0, X+
    3c34:	00 20       	and	r0, r0
    3c36:	e9 f7       	brne	.-6      	; 0x3c32 <BUFFERStringTX+0x6c>
    3c38:	11 97       	sbiw	r26, 0x01	; 1
    3c3a:	ae 1b       	sub	r26, r30
    3c3c:	bf 0b       	sbc	r27, r31
	fillPacketHeader(&packetHeader,PacketString,(tDataLength)Datasize,string);  
    3c3e:	8e 01       	movw	r16, r28
    3c40:	0f 5f       	subi	r16, 0xFF	; 255
    3c42:	1f 4f       	sbci	r17, 0xFF	; 255
    3c44:	c8 01       	movw	r24, r16
    3c46:	65 e0       	ldi	r22, 0x05	; 5
    3c48:	70 e0       	ldi	r23, 0x00	; 0
    3c4a:	ad 01       	movw	r20, r26
    3c4c:	2d 2d       	mov	r18, r13
    3c4e:	3c 2d       	mov	r19, r12
    3c50:	0e 94 21 18 	call	0x3042	; 0x3042 <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);     
    3c54:	c8 01       	movw	r24, r16
    3c56:	b8 01       	movw	r22, r16
    3c58:	48 e0       	ldi	r20, 0x08	; 8
    3c5a:	50 e0       	ldi	r21, 0x00	; 0
    3c5c:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	// meto el string en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,string,PacketString);                   
    3c60:	c8 01       	movw	r24, r16
    3c62:	6d 2d       	mov	r22, r13
    3c64:	7c 2d       	mov	r23, r12
    3c66:	45 e0       	ldi	r20, 0x05	; 5
    3c68:	50 e0       	ldi	r21, 0x00	; 0
    3c6a:	0e 94 97 18 	call	0x312e	; 0x312e <BUFFERPacketDataTX>
	return buffersize;
} // sendString
    3c6e:	c7 01       	movw	r24, r14
    3c70:	28 96       	adiw	r28, 0x08	; 8
    3c72:	0f b6       	in	r0, 0x3f	; 63
    3c74:	f8 94       	cli
    3c76:	de bf       	out	0x3e, r29	; 62
    3c78:	0f be       	out	0x3f, r0	; 63
    3c7a:	cd bf       	out	0x3d, r28	; 61
    3c7c:	cf 91       	pop	r28
    3c7e:	df 91       	pop	r29
    3c80:	1f 91       	pop	r17
    3c82:	0f 91       	pop	r16
    3c84:	ff 90       	pop	r15
    3c86:	ef 90       	pop	r14
    3c88:	df 90       	pop	r13
    3c8a:	cf 90       	pop	r12
    3c8c:	08 95       	ret

00003c8e <dispatchPacket>:
#endif

/*****************************************************************************************/
#ifdef _AVR_IO_H_
int16 dispatchPacket(tPacket tipodato,uint8* datos)
{
    3c8e:	cf 93       	push	r28
    3c90:	df 93       	push	r29
    3c92:	ac 01       	movw	r20, r24
	tTrajectory * Traytemp;//Trayectoria temporal para poder acceder a el campo size,
    int16 puntos;
    //Variables Transmicion 
	int16 rc,buffersize=0;       

	txPacket=tipodato;
    3c94:	90 93 ed 81 	sts	0x81ED, r25
    3c98:	80 93 ec 81 	sts	0x81EC, r24
	if(txPacket == PacketNOP || txPacket > lastPacket) 
    3c9c:	00 97       	sbiw	r24, 0x00	; 0
    3c9e:	09 f4       	brne	.+2      	; 0x3ca2 <dispatchPacket+0x14>
    3ca0:	6b c0       	rjmp	.+214    	; 0x3d78 <dispatchPacket+0xea>
    3ca2:	8e 30       	cpi	r24, 0x0E	; 14
    3ca4:	91 05       	cpc	r25, r1
    3ca6:	0c f0       	brlt	.+2      	; 0x3caa <dispatchPacket+0x1c>
    3ca8:	67 c0       	rjmp	.+206    	; 0x3d78 <dispatchPacket+0xea>
		return rcInvalidPacket;   

	switch(txPacket)  
    3caa:	87 30       	cpi	r24, 0x07	; 7
    3cac:	91 05       	cpc	r25, r1
    3cae:	f1 f1       	breq	.+124    	; 0x3d2c <dispatchPacket+0x9e>
    3cb0:	88 30       	cpi	r24, 0x08	; 8
    3cb2:	91 05       	cpc	r25, r1
    3cb4:	9c f4       	brge	.+38     	; 0x3cdc <dispatchPacket+0x4e>
    3cb6:	85 30       	cpi	r24, 0x05	; 5
    3cb8:	91 05       	cpc	r25, r1
    3cba:	44 f4       	brge	.+16     	; 0x3ccc <dispatchPacket+0x3e>
    3cbc:	83 30       	cpi	r24, 0x03	; 3
    3cbe:	91 05       	cpc	r25, r1
    3cc0:	14 f5       	brge	.+68     	; 0x3d06 <dispatchPacket+0x78>
    3cc2:	81 30       	cpi	r24, 0x01	; 1
    3cc4:	91 05       	cpc	r25, r1
    3cc6:	09 f0       	breq	.+2      	; 0x3cca <dispatchPacket+0x3c>
    3cc8:	57 c0       	rjmp	.+174    	; 0x3d78 <dispatchPacket+0xea>
    3cca:	24 c0       	rjmp	.+72     	; 0x3d14 <dispatchPacket+0x86>
    3ccc:	85 30       	cpi	r24, 0x05	; 5
    3cce:	91 05       	cpc	r25, r1
    3cd0:	29 f1       	breq	.+74     	; 0x3d1c <dispatchPacket+0x8e>
    3cd2:	86 30       	cpi	r24, 0x06	; 6
    3cd4:	91 05       	cpc	r25, r1
    3cd6:	09 f0       	breq	.+2      	; 0x3cda <dispatchPacket+0x4c>
    3cd8:	4f c0       	rjmp	.+158    	; 0x3d78 <dispatchPacket+0xea>
    3cda:	24 c0       	rjmp	.+72     	; 0x3d24 <dispatchPacket+0x96>
    3cdc:	8b 30       	cpi	r24, 0x0B	; 11
    3cde:	91 05       	cpc	r25, r1
    3ce0:	89 f1       	breq	.+98     	; 0x3d44 <dispatchPacket+0xb6>
    3ce2:	8c 30       	cpi	r24, 0x0C	; 12
    3ce4:	91 05       	cpc	r25, r1
    3ce6:	44 f4       	brge	.+16     	; 0x3cf8 <dispatchPacket+0x6a>
    3ce8:	89 30       	cpi	r24, 0x09	; 9
    3cea:	91 05       	cpc	r25, r1
    3cec:	19 f1       	breq	.+70     	; 0x3d34 <dispatchPacket+0xa6>
    3cee:	8a 30       	cpi	r24, 0x0A	; 10
    3cf0:	91 05       	cpc	r25, r1
    3cf2:	09 f0       	breq	.+2      	; 0x3cf6 <dispatchPacket+0x68>
    3cf4:	41 c0       	rjmp	.+130    	; 0x3d78 <dispatchPacket+0xea>
    3cf6:	22 c0       	rjmp	.+68     	; 0x3d3c <dispatchPacket+0xae>
    3cf8:	8c 30       	cpi	r24, 0x0C	; 12
    3cfa:	91 05       	cpc	r25, r1
    3cfc:	39 f1       	breq	.+78     	; 0x3d4c <dispatchPacket+0xbe>
    3cfe:	8d 30       	cpi	r24, 0x0D	; 13
    3d00:	91 05       	cpc	r25, r1
    3d02:	d1 f5       	brne	.+116    	; 0x3d78 <dispatchPacket+0xea>
    3d04:	27 c0       	rjmp	.+78     	; 0x3d54 <dispatchPacket+0xc6>
	{  
		case PacketTeachPendant:
		case PacketTrajectory :
			// Como dispatchPacket es una funcion generica los datos vienen en bytes   
			Traytemp=(tTrajectory *)datos;  
    3d06:	fb 01       	movw	r30, r22
			//Con puntos puedo calcular el numero de bytes que necesito								  
			puntos=Traytemp->size;          
			//4 bytes por los dos campos int16 de la estructura trayectoria			
			buffersize=BUFFERTrajectoryTX(Traytemp,puntos,txPacket); 
    3d08:	60 81       	ld	r22, Z
    3d0a:	71 81       	ldd	r23, Z+1	; 0x01
    3d0c:	cf 01       	movw	r24, r30
    3d0e:	0e 94 b5 1c 	call	0x396a	; 0x396a <BUFFERTrajectoryTX>
    3d12:	23 c0       	rjmp	.+70     	; 0x3d5a <dispatchPacket+0xcc>
        break;
		case PacketCommand:
			buffersize=BUFFERCommandTX((tCommand*)datos);
    3d14:	cb 01       	movw	r24, r22
    3d16:	0e 94 1b 1d 	call	0x3a36	; 0x3a36 <BUFFERCommandTX>
    3d1a:	1f c0       	rjmp	.+62     	; 0x3d5a <dispatchPacket+0xcc>
			for(k=0; k<buffersize;k++) 
            printf("dispatchPacket => TXBUFFER[%d]=%X\n",k,TXBUFFER[k]);							    
			#endif		   
		break;
		case PacketString:    // send \0-terminated string, such as copyright or debug info   
			buffersize=BUFFERStringTX(datos);
    3d1c:	cb 01       	movw	r24, r22
    3d1e:	0e 94 e3 1d 	call	0x3bc6	; 0x3bc6 <BUFFERStringTX>
    3d22:	1b c0       	rjmp	.+54     	; 0x3d5a <dispatchPacket+0xcc>
			printf("dispatchPacket=> strlen(info) en dispatchPacket=>%d \n",j);		   
			printf("dispatchPacket=> Tamao de los datos en dispatchPacket=>%d \n",buffersize);
			#endif
		break;
		case PacketAxisSettings:
			buffersize=BUFFERAxisSettingsTX((tAxisSettings*)datos);		   
    3d24:	cb 01       	movw	r24, r22
    3d26:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <BUFFERAxisSettingsTX>
    3d2a:	17 c0       	rjmp	.+46     	; 0x3d5a <dispatchPacket+0xcc>
		break;
		case PacketAxisLimits:
			buffersize=BUFFERAxisLimitsTX((tAxisLimits*)datos);
    3d2c:	cb 01       	movw	r24, r22
    3d2e:	0e 94 15 1c 	call	0x382a	; 0x382a <BUFFERAxisLimitsTX>
    3d32:	13 c0       	rjmp	.+38     	; 0x3d5a <dispatchPacket+0xcc>
		break;
		case PacketPosesvector:
		    buffersize=BUFFERVectorPoseTX(datos); 
    3d34:	cb 01       	movw	r24, r22
    3d36:	0e 94 b7 1b 	call	0x376e	; 0x376e <BUFFERVectorPoseTX>
    3d3a:	0f c0       	rjmp	.+30     	; 0x3d5a <dispatchPacket+0xcc>
		break;
		case PacketFecha:   // 14
			buffersize=BUFFERFechaTX(datos); 
    3d3c:	cb 01       	movw	r24, r22
    3d3e:	0e 94 6b 1b 	call	0x36d6	; 0x36d6 <BUFFERFechaTX>
    3d42:	0b c0       	rjmp	.+22     	; 0x3d5a <dispatchPacket+0xcc>
		break;
		case PacketAlarma:
			buffersize=BUFFERAlarmaTX(datos); 
    3d44:	cb 01       	movw	r24, r22
    3d46:	0e 94 1f 1b 	call	0x363e	; 0x363e <BUFFERAlarmaTX>
    3d4a:	07 c0       	rjmp	.+14     	; 0x3d5a <dispatchPacket+0xcc>
		break;
		case PacketTrace:
			buffersize=BUFFERTraceTX(datos);
    3d4c:	cb 01       	movw	r24, r22
    3d4e:	0e 94 bb 1a 	call	0x3576	; 0x3576 <BUFFERTraceTX>
    3d52:	03 c0       	rjmp	.+6      	; 0x3d5a <dispatchPacket+0xcc>
		break;
		case Packetuint16:
			buffersize=BUFFERunit16TX(datos);
    3d54:	cb 01       	movw	r24, r22
    3d56:	0e 94 6f 1a 	call	0x34de	; 0x34de <BUFFERunit16TX>
    3d5a:	bc 01       	movw	r22, r24
			return rcInvalidPacket;
    } // switch txPacket
	//buffersize solo es par, es decir siempre el buffer es par. Aunque el dato a enviar 
	//tenga una longitud de bytes impar. Internamente tPacketHeader.dataLength siempre
	//tiene la cantidad de bytes correcta del dato.
	rc=Envio_USB(TXBUFFER,buffersize);  
    3d5c:	80 91 18 82 	lds	r24, 0x8218
    3d60:	90 91 19 82 	lds	r25, 0x8219
    3d64:	0e 94 aa 14 	call	0x2954	; 0x2954 <Envio_USB>
    3d68:	ec 01       	movw	r28, r24
	free(TXBUFFER);
    3d6a:	80 91 18 82 	lds	r24, 0x8218
    3d6e:	90 91 19 82 	lds	r25, 0x8219
    3d72:	0e 94 aa 86 	call	0x10d54	; 0x10d54 <free>
    3d76:	02 c0       	rjmp	.+4      	; 0x3d7c <dispatchPacket+0xee>
return rc;
    3d78:	c3 e0       	ldi	r28, 0x03	; 3
    3d7a:	d0 e0       	ldi	r29, 0x00	; 0
} // dispatchPacket
    3d7c:	ce 01       	movw	r24, r28
    3d7e:	df 91       	pop	r29
    3d80:	cf 91       	pop	r28
    3d82:	08 95       	ret

00003d84 <receiptPacket>:
// 4. Se lee el campo rxHeader.dataType del header recibido y se copia a rxPacket
// 5. Dependiendo del tipo de paquete se guarda en su respectiva variable

#ifdef _AVR_IO_H_
int16 receiptPacket(void)  
{
    3d84:	0f 93       	push	r16
    3d86:	1f 93       	push	r17
	uint16 spacefree;
	#endif
   	int16 rc;
	tDataLength longitud;    
   //Creo un Buffer para almacenar el header
	RXBUFFER=(uint8 *)declarar(8);                    
    3d88:	88 e0       	ldi	r24, 0x08	; 8
    3d8a:	90 e0       	ldi	r25, 0x00	; 0
    3d8c:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    3d90:	80 93 16 82 	sts	0x8216, r24
    3d94:	90 93 17 82 	sts	0x8217, r25
	printf("receiptPacket=> Addr RXBUFFER para almacenar los datos Header = %X \n",(int16)RXBUFFER);							    
	#endif
	
	//Siempre se manda primero el header y luego los dato
	//En esta funcin el uC recibe los datos desde la fifo, la cual es controlada por el GPIF
	rc = Leo_USB(RXBUFFER,8);
    3d98:	68 e0       	ldi	r22, 0x08	; 8
    3d9a:	70 e0       	ldi	r23, 0x00	; 0
    3d9c:	0e 94 ce 14 	call	0x299c	; 0x299c <Leo_USB>
    3da0:	8c 01       	movw	r16, r24
	if(rc!=rcOK)
    3da2:	00 97       	sbiw	r24, 0x00	; 0
    3da4:	09 f0       	breq	.+2      	; 0x3da8 <receiptPacket+0x24>
    3da6:	0b c1       	rjmp	.+534    	; 0x3fbe <receiptPacket+0x23a>
		return rc;				
	//Se lee el Header de RXBUFFER
	rc = readPacketHeaderRX(&rxHeader);				    
    3da8:	84 ed       	ldi	r24, 0xD4	; 212
    3daa:	90 e8       	ldi	r25, 0x80	; 128
    3dac:	0e 94 9d 17 	call	0x2f3a	; 0x2f3a <readPacketHeaderRX>
    3db0:	8c 01       	movw	r16, r24
	free(RXBUFFER); 
    3db2:	80 91 16 82 	lds	r24, 0x8216
    3db6:	90 91 17 82 	lds	r25, 0x8217
    3dba:	0e 94 aa 86 	call	0x10d54	; 0x10d54 <free>
	if(rc != rcOK) 
    3dbe:	01 15       	cp	r16, r1
    3dc0:	11 05       	cpc	r17, r1
    3dc2:	09 f0       	breq	.+2      	; 0x3dc6 <receiptPacket+0x42>
    3dc4:	fc c0       	rjmp	.+504    	; 0x3fbe <receiptPacket+0x23a>
		printf("receipPacket=> Error al leer el Header\n");							    
		#endif
		return rc;                       
	}
	// Reservo memoria a los datos
	longitud=rxHeader.dataLength;		
    3dc6:	00 91 d6 80 	lds	r16, 0x80D6
    3dca:	10 91 d7 80 	lds	r17, 0x80D7
	/*tengo que crear un buffer siempre de datos pares pues USB siempre manda par*/
	if(Esimpar(longitud))
    3dce:	c8 01       	movw	r24, r16
    3dd0:	0e 94 55 18 	call	0x30aa	; 0x30aa <Esimpar>
    3dd4:	89 2b       	or	r24, r25
    3dd6:	11 f0       	breq	.+4      	; 0x3ddc <receiptPacket+0x58>
		longitud++;
    3dd8:	0f 5f       	subi	r16, 0xFF	; 255
    3dda:	1f 4f       	sbci	r17, 0xFF	; 255
	#ifdef DEBUGUSBLevel1
	spacefree=maxavail();
	printf("receiptPacket=> La cantidad de memoria ram disponible SIN rxbuffer declarado %d \n",spacefree);
	#endif	
		
	RXBUFFER=(uint8 *)declarar(longitud);    
    3ddc:	c8 01       	movw	r24, r16
    3dde:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    3de2:	80 93 16 82 	sts	0x8216, r24
    3de6:	90 93 17 82 	sts	0x8217, r25
	#ifdef DEBUGUSBLevel1
	spacefree=maxavail();
	printf("receiptPacket=> La cantidad de memoria ram disponible CON rxbuffer declarado %d , con una log de %d\n",spacefree,longitud);
	#endif
	//En esta funcin el uC recibe los datos desde la fifo, la cual es controlada por el GPIF
	rc=Leo_USB(RXBUFFER,longitud); 
    3dea:	b8 01       	movw	r22, r16
    3dec:	0e 94 ce 14 	call	0x299c	; 0x299c <Leo_USB>
    3df0:	8c 01       	movw	r16, r24
	if(rc!=rcOK)
    3df2:	00 97       	sbiw	r24, 0x00	; 0
    3df4:	09 f0       	breq	.+2      	; 0x3df8 <receiptPacket+0x74>
    3df6:	e3 c0       	rjmp	.+454    	; 0x3fbe <receiptPacket+0x23a>
		printf("receipPacket=> Error al leer los datos\n");							    
		#endif
		return rc;				
	}
	
	rxPacket = rxHeader.dataType;	
    3df8:	80 91 d4 80 	lds	r24, 0x80D4
    3dfc:	90 91 d5 80 	lds	r25, 0x80D5
    3e00:	90 93 d1 80 	sts	0x80D1, r25
    3e04:	80 93 d0 80 	sts	0x80D0, r24
		{
			printf("receipPacket=> RXBUFFER[%d] = %X \n",i,RXBUFFER[i]);							    
		}
	#endif	
	
	switch(rxPacket)
    3e08:	87 30       	cpi	r24, 0x07	; 7
    3e0a:	91 05       	cpc	r25, r1
    3e0c:	09 f4       	brne	.+2      	; 0x3e10 <receiptPacket+0x8c>
    3e0e:	75 c0       	rjmp	.+234    	; 0x3efa <receiptPacket+0x176>
    3e10:	88 30       	cpi	r24, 0x08	; 8
    3e12:	91 05       	cpc	r25, r1
    3e14:	94 f4       	brge	.+36     	; 0x3e3a <receiptPacket+0xb6>
    3e16:	85 30       	cpi	r24, 0x05	; 5
    3e18:	91 05       	cpc	r25, r1
    3e1a:	3c f4       	brge	.+14     	; 0x3e2a <receiptPacket+0xa6>
    3e1c:	83 30       	cpi	r24, 0x03	; 3
    3e1e:	91 05       	cpc	r25, r1
    3e20:	1c f5       	brge	.+70     	; 0x3e68 <receiptPacket+0xe4>
    3e22:	01 97       	sbiw	r24, 0x01	; 1
    3e24:	09 f0       	breq	.+2      	; 0x3e28 <receiptPacket+0xa4>
    3e26:	c5 c0       	rjmp	.+394    	; 0x3fb2 <receiptPacket+0x22e>
    3e28:	47 c0       	rjmp	.+142    	; 0x3eb8 <receiptPacket+0x134>
    3e2a:	85 30       	cpi	r24, 0x05	; 5
    3e2c:	91 05       	cpc	r25, r1
    3e2e:	09 f4       	brne	.+2      	; 0x3e32 <receiptPacket+0xae>
    3e30:	58 c0       	rjmp	.+176    	; 0x3ee2 <receiptPacket+0x15e>
    3e32:	06 97       	sbiw	r24, 0x06	; 6
    3e34:	09 f0       	breq	.+2      	; 0x3e38 <receiptPacket+0xb4>
    3e36:	bd c0       	rjmp	.+378    	; 0x3fb2 <receiptPacket+0x22e>
    3e38:	59 c0       	rjmp	.+178    	; 0x3eec <receiptPacket+0x168>
    3e3a:	8b 30       	cpi	r24, 0x0B	; 11
    3e3c:	91 05       	cpc	r25, r1
    3e3e:	09 f4       	brne	.+2      	; 0x3e42 <receiptPacket+0xbe>
    3e40:	8c c0       	rjmp	.+280    	; 0x3f5a <receiptPacket+0x1d6>
    3e42:	8c 30       	cpi	r24, 0x0C	; 12
    3e44:	91 05       	cpc	r25, r1
    3e46:	44 f4       	brge	.+16     	; 0x3e58 <receiptPacket+0xd4>
    3e48:	89 30       	cpi	r24, 0x09	; 9
    3e4a:	91 05       	cpc	r25, r1
    3e4c:	09 f4       	brne	.+2      	; 0x3e50 <receiptPacket+0xcc>
    3e4e:	5d c0       	rjmp	.+186    	; 0x3f0a <receiptPacket+0x186>
    3e50:	0a 97       	sbiw	r24, 0x0a	; 10
    3e52:	09 f0       	breq	.+2      	; 0x3e56 <receiptPacket+0xd2>
    3e54:	ae c0       	rjmp	.+348    	; 0x3fb2 <receiptPacket+0x22e>
    3e56:	7c c0       	rjmp	.+248    	; 0x3f50 <receiptPacket+0x1cc>
    3e58:	8c 30       	cpi	r24, 0x0C	; 12
    3e5a:	91 05       	cpc	r25, r1
    3e5c:	09 f4       	brne	.+2      	; 0x3e60 <receiptPacket+0xdc>
    3e5e:	87 c0       	rjmp	.+270    	; 0x3f6e <receiptPacket+0x1ea>
    3e60:	0d 97       	sbiw	r24, 0x0d	; 13
    3e62:	09 f0       	breq	.+2      	; 0x3e66 <receiptPacket+0xe2>
    3e64:	a6 c0       	rjmp	.+332    	; 0x3fb2 <receiptPacket+0x22e>
    3e66:	7e c0       	rjmp	.+252    	; 0x3f64 <receiptPacket+0x1e0>
		case PacketTeachPendant:
		case PacketTrajectory:	
			#ifdef DEBUGUSBLevel0
			printf("receipPacket=> FlagTrayectoryok = %d\n",FlagTrayectoryok);							    
			#endif
			if(FlagTrayectoryok)				
    3e68:	80 91 b0 7b 	lds	r24, 0x7BB0
    3e6c:	90 91 b1 7b 	lds	r25, 0x7BB1
    3e70:	89 2b       	or	r24, r25
    3e72:	31 f0       	breq	.+12     	; 0x3e80 <receiptPacket+0xfc>
				#ifdef DEBUGUSBLevel0
				spacefree=maxavail();
				printf("receipPacket=> La cantidad de memoria ram disponible %d \n",spacefree);
				printf("receipPacket=> rxTrajectory.point = %X\n",(int16)rxTrajectory.point);
				#endif
				free(rxTrajectory.point); 
    3e74:	80 91 0d 82 	lds	r24, 0x820D
    3e78:	90 91 0e 82 	lds	r25, 0x820E
    3e7c:	0e 94 aa 86 	call	0x10d54	; 0x10d54 <free>
				spacefree=maxavail();
				printf("receipPacket=> rxTrajectory.point  free...\n");	
				printf("receipPacket=> La cantidad de memoria ram disponible %d \n",spacefree);						    
				#endif		
			}
			rc=readTrajectoryRX(&rxTrajectory,rxHeader); 
    3e80:	89 e0       	ldi	r24, 0x09	; 9
    3e82:	92 e8       	ldi	r25, 0x82	; 130
    3e84:	00 91 d4 80 	lds	r16, 0x80D4
    3e88:	10 91 d5 80 	lds	r17, 0x80D5
    3e8c:	20 91 d6 80 	lds	r18, 0x80D6
    3e90:	30 91 d7 80 	lds	r19, 0x80D7
    3e94:	40 91 d8 80 	lds	r20, 0x80D8
    3e98:	50 91 d9 80 	lds	r21, 0x80D9
    3e9c:	60 91 da 80 	lds	r22, 0x80DA
    3ea0:	70 91 db 80 	lds	r23, 0x80DB
    3ea4:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <readTrajectoryRX>
    3ea8:	8c 01       	movw	r16, r24
			#ifdef DEBUGUSBLevel0
			printf("receipPacket=> He ejecutado readTrajectoryRX ...\n");							    
			#endif 
			FlagTrayectoryok=1;
    3eaa:	81 e0       	ldi	r24, 0x01	; 1
    3eac:	90 e0       	ldi	r25, 0x00	; 0
    3eae:	90 93 b1 7b 	sts	0x7BB1, r25
    3eb2:	80 93 b0 7b 	sts	0x7BB0, r24
    3eb6:	7d c0       	rjmp	.+250    	; 0x3fb2 <receiptPacket+0x22e>
		break;		
		case PacketCommand:
			rc = readPacketDataRX(&rxHeader, (uint8*)&rxCommand);
    3eb8:	84 ed       	ldi	r24, 0xD4	; 212
    3eba:	90 e8       	ldi	r25, 0x80	; 128
    3ebc:	6e ee       	ldi	r22, 0xEE	; 238
    3ebe:	71 e8       	ldi	r23, 0x81	; 129
    3ec0:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <readPacketDataRX>
    3ec4:	8c 01       	movw	r16, r24
			if(rxCommand.CommandOP > lastCommand) 
    3ec6:	80 91 ee 81 	lds	r24, 0x81EE
    3eca:	90 91 ef 81 	lds	r25, 0x81EF
    3ece:	43 97       	sbiw	r24, 0x13	; 19
    3ed0:	0c f4       	brge	.+2      	; 0x3ed4 <receiptPacket+0x150>
    3ed2:	6f c0       	rjmp	.+222    	; 0x3fb2 <receiptPacket+0x22e>
			{
				rxCommand.CommandOP = CommandNOP;     // make access to CommandMsg[rxCommand] safe
    3ed4:	10 92 ef 81 	sts	0x81EF, r1
    3ed8:	10 92 ee 81 	sts	0x81EE, r1
    3edc:	04 e0       	ldi	r16, 0x04	; 4
    3ede:	10 e0       	ldi	r17, 0x00	; 0
    3ee0:	6e c0       	rjmp	.+220    	; 0x3fbe <receiptPacket+0x23a>
				return rcInvalidCommand;
			}
        break;   
		case PacketString:			 
			rc = readPacketDataRX(&rxHeader,(uint8*)rxString); //Max 255 char
    3ee2:	84 ed       	ldi	r24, 0xD4	; 212
    3ee4:	90 e8       	ldi	r25, 0x80	; 128
    3ee6:	6c ed       	ldi	r22, 0xDC	; 220
    3ee8:	70 e8       	ldi	r23, 0x80	; 128
    3eea:	0b c0       	rjmp	.+22     	; 0x3f02 <receiptPacket+0x17e>
				
			}
			printf("receipPacket=>  rxHeader.dataLength = %d\n",rxHeader.dataLength);
			printf("receipPacket=>  sizeof(tAxisSettings) = %d\n",sizeof(tAxisSettings));
			#endif
			readPacketDataRX(&rxHeader, (uint8*)&(rxAxisSettings[0]) ); 
    3eec:	84 ed       	ldi	r24, 0xD4	; 212
    3eee:	90 e8       	ldi	r25, 0x80	; 128
    3ef0:	64 e5       	ldi	r22, 0x54	; 84
    3ef2:	7f e7       	ldi	r23, 0x7F	; 127
    3ef4:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <readPacketDataRX>
    3ef8:	5c c0       	rjmp	.+184    	; 0x3fb2 <receiptPacket+0x22e>
			printf("receiptPacket => rxAxisSettings[%d].ustepsPerStep= %d \n",i,rxAxisSettings[i].ustepsPerStep);
			#endif
			
		break;	 
		case PacketAxisLimits:
			rc = readPacketDataRX(&rxHeader, (uint8*)&rxAxisLimits); 
    3efa:	84 ed       	ldi	r24, 0xD4	; 212
    3efc:	90 e8       	ldi	r25, 0x80	; 128
    3efe:	64 ee       	ldi	r22, 0xE4	; 228
    3f00:	71 e8       	ldi	r23, 0x81	; 129
    3f02:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <readPacketDataRX>
    3f06:	8c 01       	movw	r16, r24
    3f08:	54 c0       	rjmp	.+168    	; 0x3fb2 <receiptPacket+0x22e>
		break;	 
		case PacketPosesvector:
			#ifdef DEBUGUSBLevel0
			printf("receipPacket=>  FlagrxVectorok = %d\n",FlagrxVectorok);							    
			#endif
			if(FlagrxVectorok)					
    3f0a:	80 91 b2 7b 	lds	r24, 0x7BB2
    3f0e:	90 91 b3 7b 	lds	r25, 0x7BB3
    3f12:	89 2b       	or	r24, r25
    3f14:	31 f0       	breq	.+12     	; 0x3f22 <receiptPacket+0x19e>
				free(rxvector); /*Liberamos a rxVector*/
    3f16:	80 91 d2 80 	lds	r24, 0x80D2
    3f1a:	90 91 d3 80 	lds	r25, 0x80D3
    3f1e:	0e 94 aa 86 	call	0x10d54	; 0x10d54 <free>
			/*Creamos uno nuevo*/
		    rxvector=(int16*)declarar(rxHeader.dataLength);
    3f22:	80 91 d6 80 	lds	r24, 0x80D6
    3f26:	90 91 d7 80 	lds	r25, 0x80D7
    3f2a:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    3f2e:	bc 01       	movw	r22, r24
    3f30:	80 93 d2 80 	sts	0x80D2, r24
    3f34:	70 93 d3 80 	sts	0x80D3, r23
		    rc = readPacketDataRX(&rxHeader, (uint8*)rxvector); 
    3f38:	84 ed       	ldi	r24, 0xD4	; 212
    3f3a:	90 e8       	ldi	r25, 0x80	; 128
    3f3c:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <readPacketDataRX>
    3f40:	8c 01       	movw	r16, r24
			FlagrxVectorok=1;
    3f42:	81 e0       	ldi	r24, 0x01	; 1
    3f44:	90 e0       	ldi	r25, 0x00	; 0
    3f46:	90 93 b3 7b 	sts	0x7BB3, r25
    3f4a:	80 93 b2 7b 	sts	0x7BB2, r24
    3f4e:	31 c0       	rjmp	.+98     	; 0x3fb2 <receiptPacket+0x22e>
		break;
		case PacketFecha:
			rc = readPacketDataRX(&rxHeader, (uint8*)&rxFecha); 
    3f50:	84 ed       	ldi	r24, 0xD4	; 212
    3f52:	90 e8       	ldi	r25, 0x80	; 128
    3f54:	6c ed       	ldi	r22, 0xDC	; 220
    3f56:	71 e8       	ldi	r23, 0x81	; 129
    3f58:	d4 cf       	rjmp	.-88     	; 0x3f02 <receiptPacket+0x17e>
		break;
		case PacketAlarma:
			rc = readPacketDataRX(&rxHeader, (uint8*)&rxAlarma); 
    3f5a:	84 ed       	ldi	r24, 0xD4	; 212
    3f5c:	90 e8       	ldi	r25, 0x80	; 128
    3f5e:	6f e0       	ldi	r22, 0x0F	; 15
    3f60:	72 e8       	ldi	r23, 0x82	; 130
    3f62:	cf cf       	rjmp	.-98     	; 0x3f02 <receiptPacket+0x17e>
		break;
		case Packetuint16:
			rc = readPacketDataRX(&rxHeader, (uint8*)&rxPosesActual); 
    3f64:	84 ed       	ldi	r24, 0xD4	; 212
    3f66:	90 e8       	ldi	r25, 0x80	; 128
    3f68:	68 e6       	ldi	r22, 0x68	; 104
    3f6a:	7d e7       	ldi	r23, 0x7D	; 125
    3f6c:	ca cf       	rjmp	.-108    	; 0x3f02 <receiptPacket+0x17e>
		break;
		case PacketTrace:
			#ifdef DEBUGUSBLevel0
			printf("receipPacket=> FlagTraceOK = %d\n",FlagTraceok);							    
			#endif
			if(FlagTraceok)					
    3f6e:	80 91 b4 7b 	lds	r24, 0x7BB4
    3f72:	90 91 b5 7b 	lds	r25, 0x7BB5
    3f76:	89 2b       	or	r24, r25
    3f78:	31 f0       	breq	.+12     	; 0x3f86 <receiptPacket+0x202>
				free(rxTraceBuffer); 
    3f7a:	80 91 b7 80 	lds	r24, 0x80B7
    3f7e:	90 91 b8 80 	lds	r25, 0x80B8
    3f82:	0e 94 aa 86 	call	0x10d54	; 0x10d54 <free>
			/*Creamos un buffer dinamico de la cantidad de datos de 8bits 
			presentes en la cantidad de datos de 32 bits enviados*/
			rxTraceBuffer=(int32*)declarar(rxHeader.dataLength);
    3f86:	80 91 d6 80 	lds	r24, 0x80D6
    3f8a:	90 91 d7 80 	lds	r25, 0x80D7
    3f8e:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    3f92:	bc 01       	movw	r22, r24
    3f94:	80 93 b7 80 	sts	0x80B7, r24
    3f98:	70 93 b8 80 	sts	0x80B8, r23
			rc = readPacketDataRX(&rxHeader, (uint8*)rxTraceBuffer); 
    3f9c:	84 ed       	ldi	r24, 0xD4	; 212
    3f9e:	90 e8       	ldi	r25, 0x80	; 128
    3fa0:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <readPacketDataRX>
    3fa4:	8c 01       	movw	r16, r24
			FlagTraceok=1;
    3fa6:	81 e0       	ldi	r24, 0x01	; 1
    3fa8:	90 e0       	ldi	r25, 0x00	; 0
    3faa:	90 93 b5 7b 	sts	0x7BB5, r25
    3fae:	80 93 b4 7b 	sts	0x7BB4, r24
		break;
	}//end case
	free(RXBUFFER);//libero el RXbuffer para poder recibir la siguiente	
    3fb2:	80 91 16 82 	lds	r24, 0x8216
    3fb6:	90 91 17 82 	lds	r25, 0x8217
    3fba:	0e 94 aa 86 	call	0x10d54	; 0x10d54 <free>
	#ifdef DEBUGUSBLevel1
	spacefree=maxavail();
	printf("receipPacket=> La cantidad de memoria ram disponible CON rxbuffer LIBERADO.. %d \n",spacefree);
	#endif
	return rc;
} // receiptPacket
    3fbe:	c8 01       	movw	r24, r16
    3fc0:	1f 91       	pop	r17
    3fc2:	0f 91       	pop	r16
    3fc4:	08 95       	ret

00003fc6 <maxavail>:
}

/*****************************************************************************************/
#ifdef _AVR_IO_H_
uint16 maxavail(void) 
{
    3fc6:	cf 93       	push	r28
    3fc8:	df 93       	push	r29
    3fca:	c0 e0       	ldi	r28, 0x00	; 0
    3fcc:	d0 e0       	ldi	r29, 0x00	; 0
	uint8 *ptr;                // pointer to allocated memory
	uint16 testsize;    // what we guess
	
	for(testsize=0; testsize < 65536;testsize++) //64K
	{ 
		ptr = (uint8*)malloc(testsize);
    3fce:	ce 01       	movw	r24, r28
    3fd0:	0e 94 fd 85 	call	0x10bfa	; 0x10bfa <malloc>
		if(ptr==NULL)  // failed, not enough memory... 
    3fd4:	00 97       	sbiw	r24, 0x00	; 0
    3fd6:	21 f0       	breq	.+8      	; 0x3fe0 <maxavail+0x1a>
		{
			break;
		}
		else 
		{
		free(ptr);
    3fd8:	0e 94 aa 86 	call	0x10d54	; 0x10d54 <free>
uint16 maxavail(void) 
{
	uint8 *ptr;                // pointer to allocated memory
	uint16 testsize;    // what we guess
	
	for(testsize=0; testsize < 65536;testsize++) //64K
    3fdc:	21 96       	adiw	r28, 0x01	; 1
    3fde:	f7 cf       	rjmp	.-18     	; 0x3fce <maxavail+0x8>
		{
		free(ptr);
		}
	}
	return testsize;  // the previous value was ok...
} // maxavail
    3fe0:	ce 01       	movw	r24, r28
    3fe2:	df 91       	pop	r29
    3fe4:	cf 91       	pop	r28
    3fe6:	08 95       	ret

00003fe8 <declarar>:
#endif


/*****************************************************************************************/
void* declarar(size_t x)
{
    3fe8:	0f 93       	push	r16
    3fea:	1f 93       	push	r17
    3fec:	cf 93       	push	r28
    3fee:	df 93       	push	r29
    3ff0:	18 2f       	mov	r17, r24
    3ff2:	09 2f       	mov	r16, r25
  void* p = malloc(x);
    3ff4:	0e 94 fd 85 	call	0x10bfa	; 0x10bfa <malloc>
    3ff8:	ec 01       	movw	r28, r24
  if(p==NULL)
    3ffa:	00 97       	sbiw	r24, 0x00	; 0
    3ffc:	29 f4       	brne	.+10     	; 0x4008 <declarar+0x20>
  {
	#ifdef _AVR_IO_H_
		printf("declarar=> ERROR NO HAY MEMORIA\n");
    3ffe:	8c e6       	ldi	r24, 0x6C	; 108
    4000:	90 e3       	ldi	r25, 0x30	; 48
    4002:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    4006:	06 c0       	rjmp	.+12     	; 0x4014 <declarar+0x2c>
	#endif
  }
  else						    
   memset(p, 0,x);
    4008:	60 e0       	ldi	r22, 0x00	; 0
    400a:	70 e0       	ldi	r23, 0x00	; 0
    400c:	41 2f       	mov	r20, r17
    400e:	50 2f       	mov	r21, r16
    4010:	0e 94 00 88 	call	0x11000	; 0x11000 <memset>
  
 return p;
}
    4014:	ce 01       	movw	r24, r28
    4016:	df 91       	pop	r29
    4018:	cf 91       	pop	r28
    401a:	1f 91       	pop	r17
    401c:	0f 91       	pop	r16
    401e:	08 95       	ret

00004020 <AxisName>:

/*****************************************************************************************/
uint8 * AxisName(tAxis Axis)
{

   switch(Axis) 
    4020:	85 30       	cpi	r24, 0x05	; 5
    4022:	91 05       	cpc	r25, r1
    4024:	c9 f1       	breq	.+114    	; 0x4098 <AxisName+0x78>
    4026:	86 30       	cpi	r24, 0x06	; 6
    4028:	91 05       	cpc	r25, r1
    402a:	94 f4       	brge	.+36     	; 0x4050 <AxisName+0x30>
    402c:	82 30       	cpi	r24, 0x02	; 2
    402e:	91 05       	cpc	r25, r1
    4030:	51 f1       	breq	.+84     	; 0x4086 <AxisName+0x66>
    4032:	83 30       	cpi	r24, 0x03	; 3
    4034:	91 05       	cpc	r25, r1
    4036:	34 f4       	brge	.+12     	; 0x4044 <AxisName+0x24>
    4038:	00 97       	sbiw	r24, 0x00	; 0
    403a:	11 f1       	breq	.+68     	; 0x4080 <AxisName+0x60>
    403c:	01 97       	sbiw	r24, 0x01	; 1
    403e:	09 f0       	breq	.+2      	; 0x4042 <AxisName+0x22>
    4040:	40 c0       	rjmp	.+128    	; 0x40c2 <AxisName+0xa2>
    4042:	1b c0       	rjmp	.+54     	; 0x407a <AxisName+0x5a>
    4044:	83 30       	cpi	r24, 0x03	; 3
    4046:	91 05       	cpc	r25, r1
    4048:	09 f1       	breq	.+66     	; 0x408c <AxisName+0x6c>
    404a:	04 97       	sbiw	r24, 0x04	; 4
    404c:	d1 f5       	brne	.+116    	; 0x40c2 <AxisName+0xa2>
    404e:	21 c0       	rjmp	.+66     	; 0x4092 <AxisName+0x72>
    4050:	88 30       	cpi	r24, 0x08	; 8
    4052:	91 05       	cpc	r25, r1
    4054:	51 f1       	breq	.+84     	; 0x40aa <AxisName+0x8a>
    4056:	89 30       	cpi	r24, 0x09	; 9
    4058:	91 05       	cpc	r25, r1
    405a:	34 f4       	brge	.+12     	; 0x4068 <AxisName+0x48>
    405c:	86 30       	cpi	r24, 0x06	; 6
    405e:	91 05       	cpc	r25, r1
    4060:	f1 f0       	breq	.+60     	; 0x409e <AxisName+0x7e>
    4062:	07 97       	sbiw	r24, 0x07	; 7
    4064:	71 f5       	brne	.+92     	; 0x40c2 <AxisName+0xa2>
    4066:	1e c0       	rjmp	.+60     	; 0x40a4 <AxisName+0x84>
    4068:	8a 30       	cpi	r24, 0x0A	; 10
    406a:	91 05       	cpc	r25, r1
    406c:	21 f1       	breq	.+72     	; 0x40b6 <AxisName+0x96>
    406e:	8a 30       	cpi	r24, 0x0A	; 10
    4070:	91 05       	cpc	r25, r1
    4072:	f4 f0       	brlt	.+60     	; 0x40b0 <AxisName+0x90>
    4074:	0b 97       	sbiw	r24, 0x0b	; 11
    4076:	29 f5       	brne	.+74     	; 0x40c2 <AxisName+0xa2>
    4078:	21 c0       	rjmp	.+66     	; 0x40bc <AxisName+0x9c>
    407a:	2c e8       	ldi	r18, 0x8C	; 140
    407c:	30 e3       	ldi	r19, 0x30	; 48
    407e:	23 c0       	rjmp	.+70     	; 0x40c6 <AxisName+0xa6>
    4080:	23 e9       	ldi	r18, 0x93	; 147
    4082:	30 e3       	ldi	r19, 0x30	; 48
    4084:	20 c0       	rjmp	.+64     	; 0x40c6 <AxisName+0xa6>
    4086:	2b e9       	ldi	r18, 0x9B	; 155
    4088:	30 e3       	ldi	r19, 0x30	; 48
    408a:	1d c0       	rjmp	.+58     	; 0x40c6 <AxisName+0xa6>
  {
    case (AxisWaist) 					: return (uint8*)"Cintura"; break;
    case (AxisShoulder) 				: return (uint8*)"Hombro"; break;
    case (AxisElbow) 					: return (uint8*)"Codo"; break;
    408c:	20 ea       	ldi	r18, 0xA0	; 160
    408e:	30 e3       	ldi	r19, 0x30	; 48
    4090:	1a c0       	rjmp	.+52     	; 0x40c6 <AxisName+0xa6>
    case (AxisPitch) 					: return (uint8*)"Pitch"; break;
    4092:	26 ea       	ldi	r18, 0xA6	; 166
    4094:	30 e3       	ldi	r19, 0x30	; 48
    4096:	17 c0       	rjmp	.+46     	; 0x40c6 <AxisName+0xa6>
    case (AxisRoll) 					: return (uint8*)"Roll"; break;
    4098:	2b ea       	ldi	r18, 0xAB	; 171
    409a:	30 e3       	ldi	r19, 0x30	; 48
    409c:	14 c0       	rjmp	.+40     	; 0x40c6 <AxisName+0xa6>
    case (AxisAux1) 					: return (uint8*)"aux1"; break;
    409e:	20 eb       	ldi	r18, 0xB0	; 176
    40a0:	30 e3       	ldi	r19, 0x30	; 48
    40a2:	11 c0       	rjmp	.+34     	; 0x40c6 <AxisName+0xa6>
    case (AxisAux2) 					: return (uint8*)"aux2"; break;
    40a4:	25 eb       	ldi	r18, 0xB5	; 181
    40a6:	30 e3       	ldi	r19, 0x30	; 48
    40a8:	0e c0       	rjmp	.+28     	; 0x40c6 <AxisName+0xa6>
    case (AxisAux3) 					: return (uint8*)"aux3"; break;
    40aa:	2a eb       	ldi	r18, 0xBA	; 186
    40ac:	30 e3       	ldi	r19, 0x30	; 48
    40ae:	0b c0       	rjmp	.+22     	; 0x40c6 <AxisName+0xa6>
    case (AxisAux4) 					: return (uint8*)"aux4"; break;
    40b0:	2f eb       	ldi	r18, 0xBF	; 191
    40b2:	30 e3       	ldi	r19, 0x30	; 48
    40b4:	08 c0       	rjmp	.+16     	; 0x40c6 <AxisName+0xa6>
	case (AxisAux5) 					: return (uint8*)"aux5"; break;
    40b6:	24 ec       	ldi	r18, 0xC4	; 196
    40b8:	30 e3       	ldi	r19, 0x30	; 48
    40ba:	05 c0       	rjmp	.+10     	; 0x40c6 <AxisName+0xa6>
    case (AxisAux6) 					: return (uint8*)"aux6"; break;
    40bc:	29 ec       	ldi	r18, 0xC9	; 201
    40be:	30 e3       	ldi	r19, 0x30	; 48
    40c0:	02 c0       	rjmp	.+4      	; 0x40c6 <AxisName+0xa6>
    case (AxisAux7) 					: return (uint8*)"aux7"; break;    
    40c2:	2e ec       	ldi	r18, 0xCE	; 206
    40c4:	30 e3       	ldi	r19, 0x30	; 48
    
	default 							: return (uint8*)"invalid axis";
  }
} // AxisName
    40c6:	c9 01       	movw	r24, r18
    40c8:	08 95       	ret

000040ca <TraceName>:

/*****************************************************************************************/
uint8 * TraceName(PMDTraceVariable Trace)
{

	switch(Trace) 
    40ca:	86 30       	cpi	r24, 0x06	; 6
    40cc:	79 f1       	breq	.+94     	; 0x412c <TraceName+0x62>
    40ce:	87 30       	cpi	r24, 0x07	; 7
    40d0:	70 f4       	brcc	.+28     	; 0x40ee <TraceName+0x24>
    40d2:	83 30       	cpi	r24, 0x03	; 3
    40d4:	11 f1       	breq	.+68     	; 0x411a <TraceName+0x50>
    40d6:	84 30       	cpi	r24, 0x04	; 4
    40d8:	28 f4       	brcc	.+10     	; 0x40e4 <TraceName+0x1a>
    40da:	81 30       	cpi	r24, 0x01	; 1
    40dc:	d9 f0       	breq	.+54     	; 0x4114 <TraceName+0x4a>
    40de:	82 30       	cpi	r24, 0x02	; 2
    40e0:	d1 f5       	brne	.+116    	; 0x4156 <TraceName+0x8c>
    40e2:	15 c0       	rjmp	.+42     	; 0x410e <TraceName+0x44>
    40e4:	84 30       	cpi	r24, 0x04	; 4
    40e6:	e1 f0       	breq	.+56     	; 0x4120 <TraceName+0x56>
    40e8:	85 30       	cpi	r24, 0x05	; 5
    40ea:	a9 f5       	brne	.+106    	; 0x4156 <TraceName+0x8c>
    40ec:	1c c0       	rjmp	.+56     	; 0x4126 <TraceName+0x5c>
    40ee:	89 30       	cpi	r24, 0x09	; 9
    40f0:	31 f1       	breq	.+76     	; 0x413e <TraceName+0x74>
    40f2:	8a 30       	cpi	r24, 0x0A	; 10
    40f4:	28 f4       	brcc	.+10     	; 0x4100 <TraceName+0x36>
    40f6:	87 30       	cpi	r24, 0x07	; 7
    40f8:	e1 f0       	breq	.+56     	; 0x4132 <TraceName+0x68>
    40fa:	88 30       	cpi	r24, 0x08	; 8
    40fc:	61 f5       	brne	.+88     	; 0x4156 <TraceName+0x8c>
    40fe:	1c c0       	rjmp	.+56     	; 0x4138 <TraceName+0x6e>
    4100:	8d 30       	cpi	r24, 0x0D	; 13
    4102:	01 f1       	breq	.+64     	; 0x4144 <TraceName+0x7a>
    4104:	8e 30       	cpi	r24, 0x0E	; 14
    4106:	09 f1       	breq	.+66     	; 0x414a <TraceName+0x80>
    4108:	8c 30       	cpi	r24, 0x0C	; 12
    410a:	29 f5       	brne	.+74     	; 0x4156 <TraceName+0x8c>
    410c:	21 c0       	rjmp	.+66     	; 0x4150 <TraceName+0x86>
    410e:	2b ed       	ldi	r18, 0xDB	; 219
    4110:	30 e3       	ldi	r19, 0x30	; 48
    4112:	23 c0       	rjmp	.+70     	; 0x415a <TraceName+0x90>
    4114:	2e ee       	ldi	r18, 0xEE	; 238
    4116:	30 e3       	ldi	r19, 0x30	; 48
    4118:	20 c0       	rjmp	.+64     	; 0x415a <TraceName+0x90>
    411a:	20 e0       	ldi	r18, 0x00	; 0
    411c:	31 e3       	ldi	r19, 0x31	; 49
    411e:	1d c0       	rjmp	.+58     	; 0x415a <TraceName+0x90>
	{
    case (PMDTracePositionError) 			: return (uint8*)"Error de Posicin"; break;
    case (PMDTraceCommandedPosition) 		: return (uint8*)"Posicion Comandada"; break;
    case (PMDTraceCommandedVelocity) 		: return (uint8*)"Velocidad Comandada"; break;
    4120:	24 e1       	ldi	r18, 0x14	; 20
    4122:	31 e3       	ldi	r19, 0x31	; 49
    4124:	1a c0       	rjmp	.+52     	; 0x415a <TraceName+0x90>
    case (PMDTraceCommandedAcceleration) 	: return (uint8*)"Acceleracion Comandada"; break;
    4126:	2b e2       	ldi	r18, 0x2B	; 43
    4128:	31 e3       	ldi	r19, 0x31	; 49
    412a:	17 c0       	rjmp	.+46     	; 0x415a <TraceName+0x90>
    case (PMDTraceActualPosition) 			: return (uint8*)"Posicion Censada"; break;
    412c:	2c e3       	ldi	r18, 0x3C	; 60
    412e:	31 e3       	ldi	r19, 0x31	; 49
    4130:	14 c0       	rjmp	.+40     	; 0x415a <TraceName+0x90>
    case (PMDTraceActualVelocity) 			: return (uint8*)"Velocidad Censada"; break;
    4132:	2e e4       	ldi	r18, 0x4E	; 78
    4134:	31 e3       	ldi	r19, 0x31	; 49
    4136:	11 c0       	rjmp	.+34     	; 0x415a <TraceName+0x90>
    case (PMDTraceCurrentMotorCommand) 		: return (uint8*)"Registro MotorCommand"; break;
    4138:	24 e6       	ldi	r18, 0x64	; 100
    413a:	31 e3       	ldi	r19, 0x31	; 49
    413c:	0e c0       	rjmp	.+28     	; 0x415a <TraceName+0x90>
    case (PMDTraceTime) 					: return (uint8*)"Tiempo de Muestreo"; break;
    413e:	27 e7       	ldi	r18, 0x77	; 119
    4140:	31 e3       	ldi	r19, 0x31	; 49
    4142:	0b c0       	rjmp	.+22     	; 0x415a <TraceName+0x90>
	case (PMDTraceCaptureValue) 			: return (uint8*)"Registro de Captura"; break;
    4144:	2b e8       	ldi	r18, 0x8B	; 139
    4146:	31 e3       	ldi	r19, 0x31	; 49
    4148:	08 c0       	rjmp	.+16     	; 0x415a <TraceName+0x90>
    case (PMDTraceActivityStatus) 			: return (uint8*)"Registro ActivityStatus"; break;
    414a:	23 ea       	ldi	r18, 0xA3	; 163
    414c:	31 e3       	ldi	r19, 0x31	; 49
    414e:	05 c0       	rjmp	.+10     	; 0x415a <TraceName+0x90>
    case (PMDTraceSignalStatus) 			: return (uint8*)"Registro SignalStatus"; break;
    4150:	29 eb       	ldi	r18, 0xB9	; 185
    4152:	31 e3       	ldi	r19, 0x31	; 49
    4154:	02 c0       	rjmp	.+4      	; 0x415a <TraceName+0x90>
	case (PMDTraceEventStatus) 				: return (uint8*)"Registro EventStatus"; break;
    4156:	2e ec       	ldi	r18, 0xCE	; 206
    4158:	31 e3       	ldi	r19, 0x31	; 49
    default 								: return (uint8*)"invalid Var";
  }
} // AxisName
    415a:	c9 01       	movw	r24, r18
    415c:	08 95       	ret

0000415e <Tracetype>:

/*****************************************************************************************/
uint8 * Tracetype(PMDTraceVariable Trace)
{
	switch(Trace) 
    415e:	86 30       	cpi	r24, 0x06	; 6
    4160:	d9 f0       	breq	.+54     	; 0x4198 <Tracetype+0x3a>
    4162:	87 30       	cpi	r24, 0x07	; 7
    4164:	60 f4       	brcc	.+24     	; 0x417e <Tracetype+0x20>
    4166:	83 30       	cpi	r24, 0x03	; 3
    4168:	b9 f0       	breq	.+46     	; 0x4198 <Tracetype+0x3a>
    416a:	84 30       	cpi	r24, 0x04	; 4
    416c:	18 f4       	brcc	.+6      	; 0x4174 <Tracetype+0x16>
    416e:	81 30       	cpi	r24, 0x01	; 1
    4170:	10 f1       	brcs	.+68     	; 0x41b6 <Tracetype+0x58>
    4172:	15 c0       	rjmp	.+42     	; 0x419e <Tracetype+0x40>
    4174:	84 30       	cpi	r24, 0x04	; 4
    4176:	b1 f0       	breq	.+44     	; 0x41a4 <Tracetype+0x46>
    4178:	85 30       	cpi	r24, 0x05	; 5
    417a:	e9 f4       	brne	.+58     	; 0x41b6 <Tracetype+0x58>
    417c:	10 c0       	rjmp	.+32     	; 0x419e <Tracetype+0x40>
    417e:	89 30       	cpi	r24, 0x09	; 9
    4180:	b9 f0       	breq	.+46     	; 0x41b0 <Tracetype+0x52>
    4182:	8a 30       	cpi	r24, 0x0A	; 10
    4184:	28 f4       	brcc	.+10     	; 0x4190 <Tracetype+0x32>
    4186:	87 30       	cpi	r24, 0x07	; 7
    4188:	99 f0       	breq	.+38     	; 0x41b0 <Tracetype+0x52>
    418a:	88 30       	cpi	r24, 0x08	; 8
    418c:	a1 f4       	brne	.+40     	; 0x41b6 <Tracetype+0x58>
    418e:	0d c0       	rjmp	.+26     	; 0x41aa <Tracetype+0x4c>
    4190:	8c 50       	subi	r24, 0x0C	; 12
    4192:	83 30       	cpi	r24, 0x03	; 3
    4194:	80 f4       	brcc	.+32     	; 0x41b6 <Tracetype+0x58>
    4196:	0c c0       	rjmp	.+24     	; 0x41b0 <Tracetype+0x52>
    4198:	2a ed       	ldi	r18, 0xDA	; 218
    419a:	31 e3       	ldi	r19, 0x31	; 49
    419c:	0e c0       	rjmp	.+28     	; 0x41ba <Tracetype+0x5c>
    419e:	23 ee       	ldi	r18, 0xE3	; 227
    41a0:	31 e3       	ldi	r19, 0x31	; 49
    41a2:	0b c0       	rjmp	.+22     	; 0x41ba <Tracetype+0x5c>
    41a4:	2a ee       	ldi	r18, 0xEA	; 234
    41a6:	31 e3       	ldi	r19, 0x31	; 49
    41a8:	08 c0       	rjmp	.+16     	; 0x41ba <Tracetype+0x5c>
		case (PMDTracePositionError): 		
		case (PMDTraceCommandedPosition): 	
		case (PMDTraceActualPosition) 			: return (uint8*)"Grados"; break;
		case (PMDTraceCommandedVelocity): 
		case (PMDTraceActualVelocity) 			: return (uint8*)"Grados/s"; break;
		case (PMDTraceCommandedAcceleration) 	: return (uint8*)"Grados/s^2"; break;
    41aa:	25 ef       	ldi	r18, 0xF5	; 245
    41ac:	31 e3       	ldi	r19, 0x31	; 49
    41ae:	05 c0       	rjmp	.+10     	; 0x41ba <Tracetype+0x5c>
		case (PMDTraceTime) 					: return (uint8*)"ms"; break;
    41b0:	28 ef       	ldi	r18, 0xF8	; 248
    41b2:	31 e3       	ldi	r19, 0x31	; 49
    41b4:	02 c0       	rjmp	.+4      	; 0x41ba <Tracetype+0x5c>
		case (PMDTraceCaptureValue): 			
		case (PMDTraceCurrentMotorCommand): 		
		case (PMDTraceEventStatus): 				
		case (PMDTraceActivityStatus): 			
		case (PMDTraceSignalStatus) 			: return (uint8*)"HEX"; break;
    41b6:	2c ef       	ldi	r18, 0xFC	; 252
    41b8:	31 e3       	ldi	r19, 0x31	; 49
		default 								: return (uint8*)"invalid";
	}
  }
    41ba:	c9 01       	movw	r24, r18
    41bc:	08 95       	ret

000041be <CommandMsg>:

/*****************************************************************************************/
uint8 *CommandMsg(tCommand command)
 {
    41be:	df 93       	push	r29
    41c0:	cf 93       	push	r28
    41c2:	cd b7       	in	r28, 0x3d	; 61
    41c4:	de b7       	in	r29, 0x3e	; 62
  switch(command.CommandOP)
    41c6:	ed 81       	ldd	r30, Y+5	; 0x05
    41c8:	fe 81       	ldd	r31, Y+6	; 0x06
    41ca:	e3 31       	cpi	r30, 0x13	; 19
    41cc:	f1 05       	cpc	r31, r1
    41ce:	08 f0       	brcs	.+2      	; 0x41d2 <CommandMsg+0x14>
    41d0:	41 c0       	rjmp	.+130    	; 0x4254 <CommandMsg+0x96>
    41d2:	ee 58       	subi	r30, 0x8E	; 142
    41d4:	ff 4f       	sbci	r31, 0xFF	; 255
    41d6:	ee 0f       	add	r30, r30
    41d8:	ff 1f       	adc	r31, r31
    41da:	05 90       	lpm	r0, Z+
    41dc:	f4 91       	lpm	r31, Z+
    41de:	e0 2d       	mov	r30, r0
    41e0:	09 94       	ijmp
    41e2:	24 e0       	ldi	r18, 0x04	; 4
    41e4:	32 e3       	ldi	r19, 0x32	; 50
    41e6:	38 c0       	rjmp	.+112    	; 0x4258 <CommandMsg+0x9a>
    41e8:	20 e1       	ldi	r18, 0x10	; 16
    41ea:	32 e3       	ldi	r19, 0x32	; 50
    41ec:	35 c0       	rjmp	.+106    	; 0x4258 <CommandMsg+0x9a>
    41ee:	2b e1       	ldi	r18, 0x1B	; 27
    41f0:	32 e3       	ldi	r19, 0x32	; 50
    41f2:	32 c0       	rjmp	.+100    	; 0x4258 <CommandMsg+0x9a>
 {
 
    case (CommandNOP) 					: return (uint8*)"no command"; break;
	case (CommandGoHome)			 	: return (uint8*)"go home cmd"; break;
	case (CommandGetAxisSettings) 		: return (uint8*)"get axis settings"; break;
    41f4:	2d e2       	ldi	r18, 0x2D	; 45
    41f6:	32 e3       	ldi	r19, 0x32	; 50
    41f8:	2f c0       	rjmp	.+94     	; 0x4258 <CommandMsg+0x9a>
    case (CommandOpenGripper) 			: return (uint8*)"open gripper cmd"; break;
    41fa:	2e e3       	ldi	r18, 0x3E	; 62
    41fc:	32 e3       	ldi	r19, 0x32	; 50
    41fe:	2c c0       	rjmp	.+88     	; 0x4258 <CommandMsg+0x9a>
    case (CommandCloseGripper) 			: return (uint8*)"close gripper cmd"; break;
    4200:	20 e5       	ldi	r18, 0x50	; 80
    4202:	32 e3       	ldi	r19, 0x32	; 50
    4204:	29 c0       	rjmp	.+82     	; 0x4258 <CommandMsg+0x9a>
	case (CommandSetPoseEEPROM)			: return (uint8*)"Set Pose EEPROM cmd"; break;
    4206:	24 e6       	ldi	r18, 0x64	; 100
    4208:	32 e3       	ldi	r19, 0x32	; 50
    420a:	26 c0       	rjmp	.+76     	; 0x4258 <CommandMsg+0x9a>
	case (CommandReSetPoseEEPROM)		: return (uint8*)"Reset Pose EEPROM cmd"; break;
    420c:	2a e7       	ldi	r18, 0x7A	; 122
    420e:	32 e3       	ldi	r19, 0x32	; 50
    4210:	23 c0       	rjmp	.+70     	; 0x4258 <CommandMsg+0x9a>
	case (CommandGetPoseEEPROM)			: return (uint8*)"Get Pose EEPROM cmd"; break;
    4212:	2e e8       	ldi	r18, 0x8E	; 142
    4214:	32 e3       	ldi	r19, 0x32	; 50
    4216:	20 c0       	rjmp	.+64     	; 0x4258 <CommandMsg+0x9a>
	case (CommandGetPoseActual)			: return (uint8*)"Get Pose Actual cmd"; break;
    4218:	22 ea       	ldi	r18, 0xA2	; 162
    421a:	32 e3       	ldi	r19, 0x32	; 50
    421c:	1d c0       	rjmp	.+58     	; 0x4258 <CommandMsg+0x9a>
	case (CommandEraseEEPROM)			: return (uint8*)"Erase EEPROM cmd"; break;
    421e:	23 eb       	ldi	r18, 0xB3	; 179
    4220:	32 e3       	ldi	r19, 0x32	; 50
    4222:	1a c0       	rjmp	.+52     	; 0x4258 <CommandMsg+0x9a>
	case (CommandGetPosesID)			: return (uint8*)"Get Poses ID cmd"; break;
    4224:	24 ec       	ldi	r18, 0xC4	; 196
    4226:	32 e3       	ldi	r19, 0x32	; 50
    4228:	17 c0       	rjmp	.+46     	; 0x4258 <CommandMsg+0x9a>
	case (CommandSetPMDTrace)			: return (uint8*)"Set PMD trace"; break;
    422a:	22 ed       	ldi	r18, 0xD2	; 210
    422c:	32 e3       	ldi	r19, 0x32	; 50
    422e:	14 c0       	rjmp	.+40     	; 0x4258 <CommandMsg+0x9a>
	case (CommandGetPMDTrace)			: return (uint8*)"Get PMD Trace"; break;
    4230:	20 ee       	ldi	r18, 0xE0	; 224
    4232:	32 e3       	ldi	r19, 0x32	; 50
    4234:	11 c0       	rjmp	.+34     	; 0x4258 <CommandMsg+0x9a>
	case (CommandGetFecha)				: return (uint8*)"Get Fecha"; break;
    4236:	2a ee       	ldi	r18, 0xEA	; 234
    4238:	32 e3       	ldi	r19, 0x32	; 50
    423a:	0e c0       	rjmp	.+28     	; 0x4258 <CommandMsg+0x9a>
	case (CommandGetMemory)				: return (uint8*)"Get Memory"; break;
    423c:	25 ef       	ldi	r18, 0xF5	; 245
    423e:	32 e3       	ldi	r19, 0x32	; 50
    4240:	0b c0       	rjmp	.+22     	; 0x4258 <CommandMsg+0x9a>
	case (CommandGetSensor)				: return (uint8*)"Get PMD Sensor"; break;
    4242:	24 e0       	ldi	r18, 0x04	; 4
    4244:	33 e3       	ldi	r19, 0x33	; 51
    4246:	08 c0       	rjmp	.+16     	; 0x4258 <CommandMsg+0x9a>
	case (CommandGetEventStatus)		: return (uint8*)"Get PMD EventStatus"; break;
    4248:	28 e1       	ldi	r18, 0x18	; 24
    424a:	33 e3       	ldi	r19, 0x33	; 51
    424c:	05 c0       	rjmp	.+10     	; 0x4258 <CommandMsg+0x9a>
	case (CommandGetAvtivityStatus)		: return (uint8*)"Get PMD AvtivityStatus"; break;
    424e:	2f e2       	ldi	r18, 0x2F	; 47
    4250:	33 e3       	ldi	r19, 0x33	; 51
    4252:	02 c0       	rjmp	.+4      	; 0x4258 <CommandMsg+0x9a>
	case (CommandGetinfomov)			: return (uint8*)"Get PMD infomov"; break;
    4254:	2f e3       	ldi	r18, 0x3F	; 63
    4256:	33 e3       	ldi	r19, 0x33	; 51
	default 							: return (uint8*)"unknown cmd";
  }

//  return (uint8*)"CommandMsg";   // avoid compiler warning
} // CommandMsg
    4258:	c9 01       	movw	r24, r18
    425a:	cf 91       	pop	r28
    425c:	df 91       	pop	r29
    425e:	08 95       	ret

00004260 <PacketMsg>:

/*****************************************************************************************/
uint8 *PacketMsg(tPacket packet) 
{

  switch(packet) {
    4260:	84 30       	cpi	r24, 0x04	; 4
    4262:	91 05       	cpc	r25, r1
    4264:	51 f1       	breq	.+84     	; 0x42ba <PacketMsg+0x5a>
    4266:	85 30       	cpi	r24, 0x05	; 5
    4268:	91 05       	cpc	r25, r1
    426a:	7c f4       	brge	.+30     	; 0x428a <PacketMsg+0x2a>
    426c:	81 30       	cpi	r24, 0x01	; 1
    426e:	91 05       	cpc	r25, r1
    4270:	c1 f0       	breq	.+48     	; 0x42a2 <PacketMsg+0x42>
    4272:	82 30       	cpi	r24, 0x02	; 2
    4274:	91 05       	cpc	r25, r1
    4276:	1c f4       	brge	.+6      	; 0x427e <PacketMsg+0x1e>
    4278:	89 2b       	or	r24, r25
    427a:	b1 f0       	breq	.+44     	; 0x42a8 <PacketMsg+0x48>
    427c:	2d c0       	rjmp	.+90     	; 0x42d8 <PacketMsg+0x78>
    427e:	82 30       	cpi	r24, 0x02	; 2
    4280:	91 05       	cpc	r25, r1
    4282:	a9 f0       	breq	.+42     	; 0x42ae <PacketMsg+0x4e>
    4284:	03 97       	sbiw	r24, 0x03	; 3
    4286:	41 f5       	brne	.+80     	; 0x42d8 <PacketMsg+0x78>
    4288:	15 c0       	rjmp	.+42     	; 0x42b4 <PacketMsg+0x54>
    428a:	86 30       	cpi	r24, 0x06	; 6
    428c:	91 05       	cpc	r25, r1
    428e:	d9 f0       	breq	.+54     	; 0x42c6 <PacketMsg+0x66>
    4290:	86 30       	cpi	r24, 0x06	; 6
    4292:	91 05       	cpc	r25, r1
    4294:	ac f0       	brlt	.+42     	; 0x42c0 <PacketMsg+0x60>
    4296:	87 30       	cpi	r24, 0x07	; 7
    4298:	91 05       	cpc	r25, r1
    429a:	c1 f0       	breq	.+48     	; 0x42cc <PacketMsg+0x6c>
    429c:	08 97       	sbiw	r24, 0x08	; 8
    429e:	e1 f4       	brne	.+56     	; 0x42d8 <PacketMsg+0x78>
    42a0:	18 c0       	rjmp	.+48     	; 0x42d2 <PacketMsg+0x72>
    42a2:	2b e4       	ldi	r18, 0x4B	; 75
    42a4:	33 e3       	ldi	r19, 0x33	; 51
    42a6:	1a c0       	rjmp	.+52     	; 0x42dc <PacketMsg+0x7c>
    42a8:	26 e5       	ldi	r18, 0x56	; 86
    42aa:	33 e3       	ldi	r19, 0x33	; 51
    42ac:	17 c0       	rjmp	.+46     	; 0x42dc <PacketMsg+0x7c>
    42ae:	20 e6       	ldi	r18, 0x60	; 96
    42b0:	33 e3       	ldi	r19, 0x33	; 51
    42b2:	14 c0       	rjmp	.+40     	; 0x42dc <PacketMsg+0x7c>
    case (PacketNOP) 					:  return (uint8*)"no packet"; break;
    case (PacketCommand)				:  return (uint8*)"cmd packet"; break;
    case (PacketVector) 				:  return (uint8*)"vector packet"; break;
    42b4:	2e e6       	ldi	r18, 0x6E	; 110
    42b6:	33 e3       	ldi	r19, 0x33	; 51
    42b8:	11 c0       	rjmp	.+34     	; 0x42dc <PacketMsg+0x7c>
    case (PacketTrajectory) 			:  return (uint8*)"trajectory packet"; break;
    42ba:	20 e8       	ldi	r18, 0x80	; 128
    42bc:	33 e3       	ldi	r19, 0x33	; 51
    42be:	0e c0       	rjmp	.+28     	; 0x42dc <PacketMsg+0x7c>
	case (PacketTeachPendant) 			:  return (uint8*)"TeachPendant packet"; break;
    42c0:	24 e9       	ldi	r18, 0x94	; 148
    42c2:	33 e3       	ldi	r19, 0x33	; 51
    42c4:	0b c0       	rjmp	.+22     	; 0x42dc <PacketMsg+0x7c>
    case (PacketString) 				:  return (uint8*)"string packet"; break;
    42c6:	22 ea       	ldi	r18, 0xA2	; 162
    42c8:	33 e3       	ldi	r19, 0x33	; 51
    42ca:	08 c0       	rjmp	.+16     	; 0x42dc <PacketMsg+0x7c>
    case (PacketAxisSettings) 			: return (uint8*)"axis settings packet"; break;
    42cc:	27 eb       	ldi	r18, 0xB7	; 183
    42ce:	33 e3       	ldi	r19, 0x33	; 51
    42d0:	05 c0       	rjmp	.+10     	; 0x42dc <PacketMsg+0x7c>
    case (PacketAxisLimits) 			: return (uint8*)"axis limits packet"; break;
    42d2:	2a ec       	ldi	r18, 0xCA	; 202
    42d4:	33 e3       	ldi	r19, 0x33	; 51
    42d6:	02 c0       	rjmp	.+4      	; 0x42dc <PacketMsg+0x7c>
	case (PacketHeader) 				: return (uint8*)"packet Header"; break;
    42d8:	28 ed       	ldi	r18, 0xD8	; 216
    42da:	33 e3       	ldi	r19, 0x33	; 51
    
	default : return (uint8*)"unknown packet"; break;
  }

//  return (uint8*)"PacketMsg";    // avoid compiler warning
} // PacketMsg
    42dc:	c9 01       	movw	r24, r18
    42de:	08 95       	ret

000042e0 <rcMsg>:

/*****************************************************************************************/
uint8 *rcMsg(tReturnCode rc) 
{

  switch(rc) {
    42e0:	fc 01       	movw	r30, r24
    42e2:	87 31       	cpi	r24, 0x17	; 23
    42e4:	91 05       	cpc	r25, r1
    42e6:	08 f0       	brcs	.+2      	; 0x42ea <rcMsg+0xa>
    42e8:	44 c0       	rjmp	.+136    	; 0x4372 <rcMsg+0x92>
    42ea:	eb 57       	subi	r30, 0x7B	; 123
    42ec:	ff 4f       	sbci	r31, 0xFF	; 255
    42ee:	ee 0f       	add	r30, r30
    42f0:	ff 1f       	adc	r31, r31
    42f2:	05 90       	lpm	r0, Z+
    42f4:	f4 91       	lpm	r31, Z+
    42f6:	e0 2d       	mov	r30, r0
    42f8:	09 94       	ijmp
    42fa:	27 ee       	ldi	r18, 0xE7	; 231
    42fc:	33 e3       	ldi	r19, 0x33	; 51
    42fe:	3b c0       	rjmp	.+118    	; 0x4376 <rcMsg+0x96>
    4300:	26 ef       	ldi	r18, 0xF6	; 246
    4302:	33 e3       	ldi	r19, 0x33	; 51
    4304:	38 c0       	rjmp	.+112    	; 0x4376 <rcMsg+0x96>
    4306:	2d ef       	ldi	r18, 0xFD	; 253
    4308:	33 e3       	ldi	r19, 0x33	; 51
    430a:	35 c0       	rjmp	.+106    	; 0x4376 <rcMsg+0x96>
    case (rcOK) 						: return (uint8*)"all ok"; break;

// packet related:
    case (rcInvalidHeader) 				: return (uint8*)"invalid Header"; break;
    case (rcInvalidData) 				: return (uint8*)"invalid data"; break;
    430c:	2a e0       	ldi	r18, 0x0A	; 10
    430e:	34 e3       	ldi	r19, 0x34	; 52
    4310:	32 c0       	rjmp	.+100    	; 0x4376 <rcMsg+0x96>
    case (rcInvalidPacket) 				: return (uint8*)"invalid Packet"; break;
    4312:	29 e1       	ldi	r18, 0x19	; 25
    4314:	34 e3       	ldi	r19, 0x34	; 52
    4316:	2f c0       	rjmp	.+94     	; 0x4376 <rcMsg+0x96>
    case (rcInvalidCommand) 			: return (uint8*)"invalid Command"; break;
    4318:	29 e2       	ldi	r18, 0x29	; 41
    431a:	34 e3       	ldi	r19, 0x34	; 52
    431c:	2c c0       	rjmp	.+88     	; 0x4376 <rcMsg+0x96>
 //   case (rcInvalidError) 				: return (uint8*)"invalid Error"; break;
    case (rcInvalidChecksum) 			: return (uint8*)"invalidChecksum"; break;
    431e:	29 e3       	ldi	r18, 0x39	; 57
    4320:	34 e3       	ldi	r19, 0x34	; 52
    4322:	29 c0       	rjmp	.+82     	; 0x4376 <rcMsg+0x96>
    case (rcInvalidHeaderChecksum) 		: return (uint8*)"invalidHeaderChecksum"; break;
    4324:	2f e4       	ldi	r18, 0x4F	; 79
    4326:	34 e3       	ldi	r19, 0x34	; 52
    4328:	26 c0       	rjmp	.+76     	; 0x4376 <rcMsg+0x96>
    case (rcTooFewData) 				: return (uint8*)"too few data"; break;
    432a:	2c e5       	ldi	r18, 0x5C	; 92
    432c:	34 e3       	ldi	r19, 0x34	; 52
    432e:	23 c0       	rjmp	.+70     	; 0x4376 <rcMsg+0x96>
//    case (rcTooMuchData) 				: return (uint8*)"too much data"; break;
    case (rcNoMemory) 					: return (uint8*)"no memory"; break;
    4330:	26 e6       	ldi	r18, 0x66	; 102
    4332:	34 e3       	ldi	r19, 0x34	; 52
    4334:	20 c0       	rjmp	.+64     	; 0x4376 <rcMsg+0x96>

// USB communication related:   
    case (rcTimeoutSendingData) 		: return (uint8*)"timeout sending data"; break;
    4336:	2b e7       	ldi	r18, 0x7B	; 123
    4338:	34 e3       	ldi	r19, 0x34	; 52
    433a:	1d c0       	rjmp	.+58     	; 0x4376 <rcMsg+0x96>
    case (rcTimeoutReadingData) 		: return (uint8*)"timeout reading data"; break;
    433c:	20 e9       	ldi	r18, 0x90	; 144
    433e:	34 e3       	ldi	r19, 0x34	; 52
    4340:	1a c0       	rjmp	.+52     	; 0x4376 <rcMsg+0x96>
    case (rcCommunicationError) 		: return (uint8*)"communication error"; break;
    4342:	24 ea       	ldi	r18, 0xA4	; 164
    4344:	34 e3       	ldi	r19, 0x34	; 52
    4346:	17 c0       	rjmp	.+46     	; 0x4376 <rcMsg+0x96>
//    case (rcUnexpectedResponse) 		: return (uint8*)"unexpected response"; break;
    case (rcUnexpectedState) 			: return (uint8*)"unexpected ISA interface state"; break;
    4348:	23 ec       	ldi	r18, 0xC3	; 195
    434a:	34 e3       	ldi	r19, 0x34	; 52
    434c:	14 c0       	rjmp	.+40     	; 0x4376 <rcMsg+0x96>
//    case (rcUCisBusy) 					: return (uint8*)"uC is busy"; break;
//    case (rcUCNeedsReset) 				: return (uint8*)"uC needs reset"; break;
//    case (rcUCNeedsInitialization) 		: return (uint8*)"uC needs initialisation"; break;

// robot related:
    case (rcHardwareFailure) 			: return (uint8*)"hardware failure"; break;
    434e:	24 ed       	ldi	r18, 0xD4	; 212
    4350:	34 e3       	ldi	r19, 0x34	; 52
    4352:	11 c0       	rjmp	.+34     	; 0x4376 <rcMsg+0x96>
//    case (rcVelocityLimitExceeded) 		: return (uint8*)"velocity too high"; break;
 //   case (rcAccelerationLimitExceeded) 	: return (uint8*)"acceleration too high"; break;
	
// for the PMD reset:
    case (rcPMDChipsetResetError) 		: return (uint8*)"PMD chipset reset error"; break;
    4354:	2c ee       	ldi	r18, 0xEC	; 236
    4356:	34 e3       	ldi	r19, 0x34	; 52
    4358:	0e c0       	rjmp	.+28     	; 0x4376 <rcMsg+0x96>
//    case (rcPMDCommandError) 			: return (uint8*)"PMD cmd error"; break;
    case (rcPMDchecksumError) 			: return (uint8*)"PMD checksum wrong"; break;
    435a:	2f ef       	ldi	r18, 0xFF	; 255
    435c:	34 e3       	ldi	r19, 0x34	; 52
    435e:	0b c0       	rjmp	.+22     	; 0x4376 <rcMsg+0x96>
//    case (rcPMDstuckBit1) 				: return (uint8*)"PMD data line stuck at 1"; break;
 //   case (rcPMDtimeout) 				: return (uint8*)"PMD communication timeout"; break;
//    case (rcOtherError) 				: return (uint8*)"unspecified rc code"; break;
	
// file procecing related	
	case (rcFileOpenError) 				: return (uint8*)"Open File Error"; break;
    4360:	2f e0       	ldi	r18, 0x0F	; 15
    4362:	35 e3       	ldi	r19, 0x35	; 53
    4364:	08 c0       	rjmp	.+16     	; 0x4376 <rcMsg+0x96>
	case (rcFileOpenOK) 				: return (uint8*)"Open File OK"; break;
    4366:	2c e1       	ldi	r18, 0x1C	; 28
    4368:	35 e3       	ldi	r19, 0x35	; 53
    436a:	05 c0       	rjmp	.+10     	; 0x4376 <rcMsg+0x96>
	case (rcFileReadOK) 				: return (uint8*)"Read File OK"; break;
    436c:	29 e2       	ldi	r18, 0x29	; 41
    436e:	35 e3       	ldi	r19, 0x35	; 53
    4370:	02 c0       	rjmp	.+4      	; 0x4376 <rcMsg+0x96>
	case (rcFileReadError) 				: return (uint8*)"Read File Error"; break;
    4372:	29 e3       	ldi	r18, 0x39	; 57
    4374:	35 e3       	ldi	r19, 0x35	; 53
    
	default : return (uint8*)"unknown rc code"; break;
  }

 // return (uint8*)"rcMsg";    // avoid compiler warning
} // rcMsg
    4376:	c9 01       	movw	r24, r18
    4378:	08 95       	ret

0000437a <PMDGetOpcodeText>:
//*****************************************************************************
uint8 *PMDGetOpcodeText(PMDuint16 opCode)
{
	opCode=opCode & 0xff;

	switch(opCode) {
    437a:	a0 e0       	ldi	r26, 0x00	; 0
    437c:	b0 e0       	ldi	r27, 0x00	; 0
    437e:	90 70       	andi	r25, 0x00	; 0
    4380:	a0 70       	andi	r26, 0x00	; 0
    4382:	b0 70       	andi	r27, 0x00	; 0
    4384:	fc 01       	movw	r30, r24
    4386:	89 3f       	cpi	r24, 0xF9	; 249
    4388:	91 05       	cpc	r25, r1
    438a:	08 f0       	brcs	.+2      	; 0x438e <PMDGetOpcodeText+0x14>
    438c:	f4 c1       	rjmp	.+1000   	; 0x4776 <PMDGetOpcodeText+0x3fc>
    438e:	e4 56       	subi	r30, 0x64	; 100
    4390:	ff 4f       	sbci	r31, 0xFF	; 255
    4392:	ee 0f       	add	r30, r30
    4394:	ff 1f       	adc	r31, r31
    4396:	05 90       	lpm	r0, Z+
    4398:	f4 91       	lpm	r31, Z+
    439a:	e0 2d       	mov	r30, r0
    439c:	09 94       	ijmp
    439e:	29 e4       	ldi	r18, 0x49	; 73
    43a0:	35 e3       	ldi	r19, 0x35	; 53
    43a2:	eb c1       	rjmp	.+982    	; 0x477a <PMDGetOpcodeText+0x400>
    43a4:	27 e5       	ldi	r18, 0x57	; 87
    43a6:	35 e3       	ldi	r19, 0x35	; 53
    43a8:	e8 c1       	rjmp	.+976    	; 0x477a <PMDGetOpcodeText+0x400>
    43aa:	2b e5       	ldi	r18, 0x5B	; 91
    43ac:	35 e3       	ldi	r19, 0x35	; 53
    43ae:	e5 c1       	rjmp	.+970    	; 0x477a <PMDGetOpcodeText+0x400>
	
	case (PMDOPNoOperation)				: return (uint8*)"Nop"; break;
	case (PMDOPSetMotorLimit) 			: return (uint8*)"SetMotorLimit"; break;
	case (PMDOPGetMotorLimit) 			: return (uint8*)"GetMotorLimit"; break;
    43b0:	29 e6       	ldi	r18, 0x69	; 105
    43b2:	35 e3       	ldi	r19, 0x35	; 53
    43b4:	e2 c1       	rjmp	.+964    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetMotorBias) 			: return (uint8*)"SetMotorBias"	; break;
    43b6:	26 e7       	ldi	r18, 0x76	; 118
    43b8:	35 e3       	ldi	r19, 0x35	; 53
    43ba:	df c1       	rjmp	.+958    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetPosition) 			: return (uint8*)"SetPosition"	; break;
    43bc:	22 e8       	ldi	r18, 0x82	; 130
    43be:	35 e3       	ldi	r19, 0x35	; 53
    43c0:	dc c1       	rjmp	.+952    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetVelocity) 			: return (uint8*)"SetVelocity"; break;
    43c2:	2e e8       	ldi	r18, 0x8E	; 142
    43c4:	35 e3       	ldi	r19, 0x35	; 53
    43c6:	d9 c1       	rjmp	.+946    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetJerk) 				: return (uint8*)"SetJerk"	; break;
    43c8:	26 e9       	ldi	r18, 0x96	; 150
    43ca:	35 e3       	ldi	r19, 0x35	; 53
    43cc:	d6 c1       	rjmp	.+940    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetGearRatio) 			: return (uint8*)"SetGearRatio"	; break;
    43ce:	23 ea       	ldi	r18, 0xA3	; 163
    43d0:	35 e3       	ldi	r19, 0x35	; 53
    43d2:	d3 c1       	rjmp	.+934    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPUpdate) 					: return (uint8*)"Update"; break;
    43d4:	2a ea       	ldi	r18, 0xAA	; 170
    43d6:	35 e3       	ldi	r19, 0x35	; 53
    43d8:	d0 c1       	rjmp	.+928    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetCommandedPosition)	: return (uint8*)"GetCommandedPosition"	; break;
    43da:	2f eb       	ldi	r18, 0xBF	; 191
    43dc:	35 e3       	ldi	r19, 0x35	; 53
    43de:	cd c1       	rjmp	.+922    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetCommandedVelocity) 	: return (uint8*)"GetCommandedVelocity"	; break;
    43e0:	24 ed       	ldi	r18, 0xD4	; 212
    43e2:	35 e3       	ldi	r19, 0x35	; 53
    43e4:	ca c1       	rjmp	.+916    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetKp) 					: return (uint8*)"SetKp"; break;
    43e6:	2a ed       	ldi	r18, 0xDA	; 218
    43e8:	35 e3       	ldi	r19, 0x35	; 53
    43ea:	c7 c1       	rjmp	.+910    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetKi) 					: return (uint8*)"SetKi"; break;
    43ec:	20 ee       	ldi	r18, 0xE0	; 224
    43ee:	35 e3       	ldi	r19, 0x35	; 53
    43f0:	c4 c1       	rjmp	.+904    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetKd) 					: return (uint8*)"SetKd"; break;
    43f2:	26 ee       	ldi	r18, 0xE6	; 230
    43f4:	35 e3       	ldi	r19, 0x35	; 53
    43f6:	c1 c1       	rjmp	.+898    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetKvff) 				: return (uint8*)"SetKvff"; break;
    43f8:	2e ee       	ldi	r18, 0xEE	; 238
    43fa:	35 e3       	ldi	r19, 0x35	; 53
    43fc:	be c1       	rjmp	.+892    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseAngle) 			: return (uint8*)"GetPhaseAngle"; break;
    43fe:	2c ef       	ldi	r18, 0xFC	; 252
    4400:	35 e3       	ldi	r19, 0x35	; 53
    4402:	bb c1       	rjmp	.+886    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetMotorBias) 			: return (uint8*)"GetMotorBias"	; break;
    4404:	29 e0       	ldi	r18, 0x09	; 9
    4406:	36 e3       	ldi	r19, 0x36	; 54
    4408:	b8 c1       	rjmp	.+880    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetInterruptMask) 		: return (uint8*)"SetInterruptMask"	; break;
    440a:	2a e1       	ldi	r18, 0x1A	; 26
    440c:	36 e3       	ldi	r19, 0x36	; 54
    440e:	b5 c1       	rjmp	.+874    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetEventStatus) 			: return (uint8*)"GetEventStatus"; break;
    4410:	29 e2       	ldi	r18, 0x29	; 41
    4412:	36 e3       	ldi	r19, 0x36	; 54
    4414:	b2 c1       	rjmp	.+868    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPResetEventStatus) 		: return (uint8*)"ResetEventStatus"	; break;
    4416:	2a e3       	ldi	r18, 0x3A	; 58
    4418:	36 e3       	ldi	r19, 0x36	; 54
    441a:	af c1       	rjmp	.+862    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetCaptureValue) 		: return (uint8*)"GetCaptureValue"; break;
    441c:	2a e4       	ldi	r18, 0x4A	; 74
    441e:	36 e3       	ldi	r19, 0x36	; 54
    4420:	ac c1       	rjmp	.+856    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetActualPosition) 		: return (uint8*)"GetActualPosition"; break;
    4422:	2c e5       	ldi	r18, 0x5C	; 92
    4424:	36 e3       	ldi	r19, 0x36	; 54
    4426:	a9 c1       	rjmp	.+850    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetSampleTime) 			: return (uint8*)"SetSampleTime"; break;
    4428:	2a e6       	ldi	r18, 0x6A	; 106
    442a:	36 e3       	ldi	r19, 0x36	; 54
    442c:	a6 c1       	rjmp	.+844    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPReset) 					: return (uint8*)"Reset"; break;
    442e:	20 e7       	ldi	r18, 0x70	; 112
    4430:	36 e3       	ldi	r19, 0x36	; 54
    4432:	a3 c1       	rjmp	.+838    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetCurrentMotorCommand)	: return (uint8*)"GetCurrentMotorCommand"; break;
    4434:	27 e8       	ldi	r18, 0x87	; 135
    4436:	36 e3       	ldi	r19, 0x36	; 54
    4438:	a0 c1       	rjmp	.+832    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetTime) 				: return (uint8*)"GetTime"; break;
    443a:	2f e8       	ldi	r18, 0x8F	; 143
    443c:	36 e3       	ldi	r19, 0x36	; 54
    443e:	9d c1       	rjmp	.+826    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPClearPositionError) 		: return (uint8*)"ClearPositionError"; break;
    4440:	22 ea       	ldi	r18, 0xA2	; 162
    4442:	36 e3       	ldi	r19, 0x36	; 54
    4444:	9a c1       	rjmp	.+820    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetPosition) 			: return (uint8*)"GetPosition"; break;
    4446:	2e ea       	ldi	r18, 0xAE	; 174
    4448:	36 e3       	ldi	r19, 0x36	; 54
    444a:	97 c1       	rjmp	.+814    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetVelocity) 			: return (uint8*)"GetVelocity"; break;
    444c:	2a eb       	ldi	r18, 0xBA	; 186
    444e:	36 e3       	ldi	r19, 0x36	; 54
    4450:	94 c1       	rjmp	.+808    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetAcceleration) 		: return (uint8*)"GetAcceleration"; break;
    4452:	2a ec       	ldi	r18, 0xCA	; 202
    4454:	36 e3       	ldi	r19, 0x36	; 54
    4456:	91 c1       	rjmp	.+802    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetActualPosition) 		: return (uint8*)"SetActualPosition"; break;
    4458:	2c ed       	ldi	r18, 0xDC	; 220
    445a:	36 e3       	ldi	r19, 0x36	; 54
    445c:	8e c1       	rjmp	.+796    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetKp) 					: return (uint8*)"GetKp"; break;
    445e:	22 ee       	ldi	r18, 0xE2	; 226
    4460:	36 e3       	ldi	r19, 0x36	; 54
    4462:	8b c1       	rjmp	.+790    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetKi) 					: return (uint8*)"GetKi"; break;
    4464:	28 ee       	ldi	r18, 0xE8	; 232
    4466:	36 e3       	ldi	r19, 0x36	; 54
    4468:	88 c1       	rjmp	.+784    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetKd) 					: return (uint8*)"GetKd"; break;
    446a:	2e ee       	ldi	r18, 0xEE	; 238
    446c:	36 e3       	ldi	r19, 0x36	; 54
    446e:	85 c1       	rjmp	.+778    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetKvff) 				: return (uint8*)"GetKvff"; break;
    4470:	26 ef       	ldi	r18, 0xF6	; 246
    4472:	36 e3       	ldi	r19, 0x36	; 54
    4474:	82 c1       	rjmp	.+772    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetInterruptMask)		: return (uint8*)"GetInterruptMask"	; break;
    4476:	27 e0       	ldi	r18, 0x07	; 7
    4478:	37 e3       	ldi	r19, 0x37	; 55
    447a:	7f c1       	rjmp	.+766    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetJerk) 				: return (uint8*)"GetJerk"; break;
    447c:	2f e0       	ldi	r18, 0x0F	; 15
    447e:	37 e3       	ldi	r19, 0x37	; 55
    4480:	7c c1       	rjmp	.+760    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetGearRatio)			: return (uint8*)"GetGearRatio"	; break;
    4482:	2c e1       	ldi	r18, 0x1C	; 28
    4484:	37 e3       	ldi	r19, 0x37	; 55
    4486:	79 c1       	rjmp	.+754    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPMultiUpdate) 			: return (uint8*)"MultiUpdate"; break;
    4488:	28 e2       	ldi	r18, 0x28	; 40
    448a:	37 e3       	ldi	r19, 0x37	; 55
    448c:	76 c1       	rjmp	.+748    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetSampleTime) 			: return (uint8*)"GetSampleTime"; break;
    448e:	26 e3       	ldi	r18, 0x36	; 54
    4490:	37 e3       	ldi	r19, 0x37	; 55
    4492:	73 c1       	rjmp	.+742    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetMotorCommand) 		: return (uint8*)"GetMotorCommand"; break;
    4494:	26 e4       	ldi	r18, 0x46	; 70
    4496:	37 e3       	ldi	r19, 0x37	; 55
    4498:	70 c1       	rjmp	.+736    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetStartVelocity) 		: return (uint8*)"SetStartVelocity"; break;
    449a:	27 e5       	ldi	r18, 0x57	; 87
    449c:	37 e3       	ldi	r19, 0x37	; 55
    449e:	6d c1       	rjmp	.+730    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetStartVelocity) 		: return (uint8*)"GetStartVelocity"; break;
    44a0:	28 e6       	ldi	r18, 0x68	; 104
    44a2:	37 e3       	ldi	r19, 0x37	; 55
    44a4:	6a c1       	rjmp	.+724    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetOutputMode) 			: return (uint8*)"GetOutputMode"; break;
    44a6:	26 e7       	ldi	r18, 0x76	; 118
    44a8:	37 e3       	ldi	r19, 0x37	; 55
    44aa:	67 c1       	rjmp	.+718    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseInitializeTime)	: return (uint8*)"SetPhaseInitializeTime"; break;
    44ac:	2d e8       	ldi	r18, 0x8D	; 141
    44ae:	37 e3       	ldi	r19, 0x37	; 55
    44b0:	64 c1       	rjmp	.+712    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseCounts) 			: return (uint8*)"SetPhaseCounts"; break;
    44b2:	2c e9       	ldi	r18, 0x9C	; 156
    44b4:	37 e3       	ldi	r19, 0x37	; 55
    44b6:	61 c1       	rjmp	.+706    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseOffset) 			: return (uint8*)"SetPhaseOffset"; break;
    44b8:	2b ea       	ldi	r18, 0xAB	; 171
    44ba:	37 e3       	ldi	r19, 0x37	; 55
    44bc:	5e c1       	rjmp	.+700    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetMotorCommand) 		: return (uint8*)"SetMotorCommand"; break;
    44be:	2b eb       	ldi	r18, 0xBB	; 187
    44c0:	37 e3       	ldi	r19, 0x37	; 55
    44c2:	5b c1       	rjmp	.+694    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPInitializePhase) 		: return (uint8*)"InitializePhase"; break;
    44c4:	2b ec       	ldi	r18, 0xCB	; 203
    44c6:	37 e3       	ldi	r19, 0x37	; 55
    44c8:	58 c1       	rjmp	.+688    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseOffset) 			: return (uint8*)"GetPhaseOffset"; break;
    44ca:	2a ed       	ldi	r18, 0xDA	; 218
    44cc:	37 e3       	ldi	r19, 0x37	; 55
    44ce:	55 c1       	rjmp	.+682    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseInitializeTime)	: return (uint8*)"GetPhaseInitializeTime"; break;
    44d0:	21 ef       	ldi	r18, 0xF1	; 241
    44d2:	37 e3       	ldi	r19, 0x37	; 55
    44d4:	52 c1       	rjmp	.+676    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseCounts) 			: return (uint8*)"GetPhaseCounts"; break;
    44d6:	20 e0       	ldi	r18, 0x00	; 0
    44d8:	38 e3       	ldi	r19, 0x38	; 56
    44da:	4f c1       	rjmp	.+670    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetLimitSwitchMode) 		: return (uint8*)"SetLimitSwitchMode"; break;
    44dc:	23 e1       	ldi	r18, 0x13	; 19
    44de:	38 e3       	ldi	r19, 0x38	; 56
    44e0:	4c c1       	rjmp	.+664    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetLimitSwitchMode) 		: return (uint8*)"GetLimitSwitchMode"; break;
    44e2:	26 e2       	ldi	r18, 0x26	; 38
    44e4:	38 e3       	ldi	r19, 0x38	; 56
    44e6:	49 c1       	rjmp	.+658    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPWriteIO) 				: return (uint8*)"WriteIO"; break;
    44e8:	2e e2       	ldi	r18, 0x2E	; 46
    44ea:	38 e3       	ldi	r19, 0x38	; 56
    44ec:	46 c1       	rjmp	.+652    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPReadIO) 					: return (uint8*)"ReadIO"; break;
    44ee:	25 e3       	ldi	r18, 0x35	; 53
    44f0:	38 e3       	ldi	r19, 0x38	; 56
    44f2:	43 c1       	rjmp	.+646    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseAngle) 			: return (uint8*)"SetPhaseAngle"; break;
    44f4:	23 e4       	ldi	r18, 0x43	; 67
    44f6:	38 e3       	ldi	r19, 0x38	; 56
    44f8:	40 c1       	rjmp	.+640    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetNumberPhases) 		: return (uint8*)"SetNumberPhases"; break;
    44fa:	23 e5       	ldi	r18, 0x53	; 83
    44fc:	38 e3       	ldi	r19, 0x38	; 56
    44fe:	3d c1       	rjmp	.+634    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetNumberPhases) 		: return (uint8*)"GetNumberPhases"; break;
    4500:	23 e6       	ldi	r18, 0x63	; 99
    4502:	38 e3       	ldi	r19, 0x38	; 56
    4504:	3a c1       	rjmp	.+628    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetAxisMode) 			: return (uint8*)"SetAxisMode"	; break;
    4506:	2f e6       	ldi	r18, 0x6F	; 111
    4508:	38 e3       	ldi	r19, 0x38	; 56
    450a:	37 c1       	rjmp	.+622    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetAxisMode) 			: return (uint8*)"GetAxisMode"; break;
    450c:	2b e7       	ldi	r18, 0x7B	; 123
    450e:	38 e3       	ldi	r19, 0x38	; 56
    4510:	34 c1       	rjmp	.+616    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetDiagnosticPortMode)	: return (uint8*)"SetDiagnosticPortMode"; break;
    4512:	21 e9       	ldi	r18, 0x91	; 145
    4514:	38 e3       	ldi	r19, 0x38	; 56
    4516:	31 c1       	rjmp	.+610    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetDiagnosticPortMode)	: return (uint8*)"GetDiagnosticPortMode"; break;
    4518:	27 ea       	ldi	r18, 0xA7	; 167
    451a:	38 e3       	ldi	r19, 0x38	; 56
    451c:	2e c1       	rjmp	.+604    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetSerialPortMode) 		: return (uint8*)"SetSerialPortMode"; break;
    451e:	29 eb       	ldi	r18, 0xB9	; 185
    4520:	38 e3       	ldi	r19, 0x38	; 56
    4522:	2b c1       	rjmp	.+598    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetSerialPortMode)		: return (uint8*)"GetSerialPortMode"; break;
    4524:	2b ec       	ldi	r18, 0xCB	; 203
    4526:	38 e3       	ldi	r19, 0x38	; 56
    4528:	28 c1       	rjmp	.+592    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetEncoderModulus) 		: return (uint8*)"SetEncoderModulus"; break;
    452a:	2d ed       	ldi	r18, 0xDD	; 221
    452c:	38 e3       	ldi	r19, 0x38	; 56
    452e:	25 c1       	rjmp	.+586    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetEncoderModulus) 		: return (uint8*)"GetEncoderModulus"; break;
    4530:	2f ee       	ldi	r18, 0xEF	; 239
    4532:	38 e3       	ldi	r19, 0x38	; 56
    4534:	22 c1       	rjmp	.+580    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetVersion) 				: return (uint8*)"GetVersion"; break;
    4536:	2a ef       	ldi	r18, 0xFA	; 250
    4538:	38 e3       	ldi	r19, 0x38	; 56
    453a:	1f c1       	rjmp	.+574    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetAcceleration)			: return (uint8*)"SetAcceleration"; break;
    453c:	2a e0       	ldi	r18, 0x0A	; 10
    453e:	39 e3       	ldi	r19, 0x39	; 57
    4540:	1c c1       	rjmp	.+568    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetDeceleration) 		: return (uint8*)"SetDeceleration"; break;
    4542:	2a e1       	ldi	r18, 0x1A	; 26
    4544:	39 e3       	ldi	r19, 0x39	; 57
    4546:	19 c1       	rjmp	.+562    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetDeceleration) 		: return (uint8*)"GetDeceleration"; break;
    4548:	2a e2       	ldi	r18, 0x2A	; 42
    454a:	39 e3       	ldi	r19, 0x39	; 57
    454c:	16 c1       	rjmp	.+556    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetKaff) 				: return (uint8*)"SetKaff"; break;
    454e:	22 e3       	ldi	r18, 0x32	; 50
    4550:	39 e3       	ldi	r19, 0x39	; 57
    4552:	13 c1       	rjmp	.+550    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetKaff) 				: return (uint8*)"GetKaff"; break;
    4554:	2a e3       	ldi	r18, 0x3A	; 58
    4556:	39 e3       	ldi	r19, 0x39	; 57
    4558:	10 c1       	rjmp	.+544    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetIntegrationLimit)		: return (uint8*)"SetIntegrationLimit"; break;
    455a:	2e e4       	ldi	r18, 0x4E	; 78
    455c:	39 e3       	ldi	r19, 0x39	; 57
    455e:	0d c1       	rjmp	.+538    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetIntegrationLimit) 	: return (uint8*)"GetIntegrationLimit"; break;
    4560:	22 e6       	ldi	r18, 0x62	; 98
    4562:	39 e3       	ldi	r19, 0x39	; 57
    4564:	0a c1       	rjmp	.+532    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetPositionErrorLimit) 	: return (uint8*)"SetPositionErrorLimit"; break;
    4566:	28 e7       	ldi	r18, 0x78	; 120
    4568:	39 e3       	ldi	r19, 0x39	; 57
    456a:	07 c1       	rjmp	.+526    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetPositionErrorLimit)	: return (uint8*)"GetPositionErrorLimit"; break;
    456c:	2e e8       	ldi	r18, 0x8E	; 142
    456e:	39 e3       	ldi	r19, 0x39	; 57
    4570:	04 c1       	rjmp	.+520    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetPositionError) 		: return (uint8*)"GetPositionError"	; break;
    4572:	2f e9       	ldi	r18, 0x9F	; 159
    4574:	39 e3       	ldi	r19, 0x39	; 57
    4576:	01 c1       	rjmp	.+514    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetIntegral) 			: return (uint8*)"GetIntegral"; break;
    4578:	2b ea       	ldi	r18, 0xAB	; 171
    457a:	39 e3       	ldi	r19, 0x39	; 57
    457c:	fe c0       	rjmp	.+508    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetDerivative) 			: return (uint8*)"GetDerivative"; break;
    457e:	29 eb       	ldi	r18, 0xB9	; 185
    4580:	39 e3       	ldi	r19, 0x39	; 57
    4582:	fb c0       	rjmp	.+502    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetDerivativeTime) 		: return (uint8*)"SetDerivativeTime"; break;
    4584:	2b ec       	ldi	r18, 0xCB	; 203
    4586:	39 e3       	ldi	r19, 0x39	; 57
    4588:	f8 c0       	rjmp	.+496    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetDerivativeTime) 		: return (uint8*)"GetDerivativeTime"; break;
    458a:	2d ed       	ldi	r18, 0xDD	; 221
    458c:	39 e3       	ldi	r19, 0x39	; 57
    458e:	f5 c0       	rjmp	.+490    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetKout) 				: return (uint8*)"SetKout"; break;
    4590:	25 ee       	ldi	r18, 0xE5	; 229
    4592:	39 e3       	ldi	r19, 0x39	; 57
    4594:	f2 c0       	rjmp	.+484    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetKout) 				: return (uint8*)"GetKout"; break;
    4596:	2d ee       	ldi	r18, 0xED	; 237
    4598:	39 e3       	ldi	r19, 0x39	; 57
    459a:	ef c0       	rjmp	.+478    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetProfileMode)			: return (uint8*)"SetProfileMode"; break;
    459c:	2c ef       	ldi	r18, 0xFC	; 252
    459e:	39 e3       	ldi	r19, 0x39	; 57
    45a0:	ec c0       	rjmp	.+472    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetProfileMode) 			: return (uint8*)"GetProfileMode"; break;
    45a2:	2b e0       	ldi	r18, 0x0B	; 11
    45a4:	3a e3       	ldi	r19, 0x3A	; 58
    45a6:	e9 c0       	rjmp	.+466    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetSignalSense) 			: return (uint8*)"SetSignalSense"; break;
    45a8:	2a e1       	ldi	r18, 0x1A	; 26
    45aa:	3a e3       	ldi	r19, 0x3A	; 58
    45ac:	e6 c0       	rjmp	.+460    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetSignalSense) 			: return (uint8*)"GetSignalSense"; break;
    45ae:	29 e2       	ldi	r18, 0x29	; 41
    45b0:	3a e3       	ldi	r19, 0x3A	; 58
    45b2:	e3 c0       	rjmp	.+454    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetSignalStatus) 		: return (uint8*)"GetSignalStatus"; break;
    45b4:	29 e3       	ldi	r18, 0x39	; 57
    45b6:	3a e3       	ldi	r19, 0x3A	; 58
    45b8:	e0 c0       	rjmp	.+448    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetHostIOError) 			: return (uint8*)"GetHostIOError"; break;
    45ba:	28 e4       	ldi	r18, 0x48	; 72
    45bc:	3a e3       	ldi	r19, 0x3A	; 58
    45be:	dd c0       	rjmp	.+442    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetActivityStatus) 		: return (uint8*)"GetActivityStatus"; break;
    45c0:	2a e5       	ldi	r18, 0x5A	; 90
    45c2:	3a e3       	ldi	r19, 0x3A	; 58
    45c4:	da c0       	rjmp	.+436    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetCommandedAcceleration): return (uint8*)"GetCommandedAcceleration"; break;
    45c6:	23 e7       	ldi	r18, 0x73	; 115
    45c8:	3a e3       	ldi	r19, 0x3A	; 58
    45ca:	d7 c0       	rjmp	.+430    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetTrackingWindow) 		: return (uint8*)"SetTrackingWindow"; break;
    45cc:	25 e8       	ldi	r18, 0x85	; 133
    45ce:	3a e3       	ldi	r19, 0x3A	; 58
    45d0:	d4 c0       	rjmp	.+424    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetTrackingWindow) 		: return (uint8*)"GetTrackingWindow"; break;
    45d2:	27 e9       	ldi	r18, 0x97	; 151
    45d4:	3a e3       	ldi	r19, 0x3A	; 58
    45d6:	d1 c0       	rjmp	.+418    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetSettleTime) 			: return (uint8*)"SetSettleTime"; break;
    45d8:	25 ea       	ldi	r18, 0xA5	; 165
    45da:	3a e3       	ldi	r19, 0x3A	; 58
    45dc:	ce c0       	rjmp	.+412    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetSettleTime) 			: return (uint8*)"GetSettleTime"; break;
    45de:	23 eb       	ldi	r18, 0xB3	; 179
    45e0:	3a e3       	ldi	r19, 0x3A	; 58
    45e2:	cb c0       	rjmp	.+406    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPClearInterrupt) 			: return (uint8*)"ClearInterrupt"; break;
    45e4:	22 ec       	ldi	r18, 0xC2	; 194
    45e6:	3a e3       	ldi	r19, 0x3A	; 58
    45e8:	c8 c0       	rjmp	.+400    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetActualVelocity) 		: return (uint8*)"GetActualVelocity"; break;
    45ea:	24 ed       	ldi	r18, 0xD4	; 212
    45ec:	3a e3       	ldi	r19, 0x3A	; 58
    45ee:	c5 c0       	rjmp	.+394    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetGearMaster) 			: return (uint8*)"SetGearMaster"; break;
    45f0:	22 ee       	ldi	r18, 0xE2	; 226
    45f2:	3a e3       	ldi	r19, 0x3A	; 58
    45f4:	c2 c0       	rjmp	.+388    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetGearMaster) 			: return (uint8*)"GetGearMaster"; break;
    45f6:	20 ef       	ldi	r18, 0xF0	; 240
    45f8:	3a e3       	ldi	r19, 0x3A	; 58
    45fa:	bf c0       	rjmp	.+382    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetTraceMode) 			: return (uint8*)"SetTraceMode"	; break;
    45fc:	2d ef       	ldi	r18, 0xFD	; 253
    45fe:	3a e3       	ldi	r19, 0x3A	; 58
    4600:	bc c0       	rjmp	.+376    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceMode) 			: return (uint8*)"GetTraceMode"	; break;
    4602:	2a e0       	ldi	r18, 0x0A	; 10
    4604:	3b e3       	ldi	r19, 0x3B	; 59
    4606:	b9 c0       	rjmp	.+370    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetTraceStart) 			: return (uint8*)"SetTraceStart"; break;
    4608:	28 e1       	ldi	r18, 0x18	; 24
    460a:	3b e3       	ldi	r19, 0x3B	; 59
    460c:	b6 c0       	rjmp	.+364    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceStart) 			: return (uint8*)"GetTraceStart"; break;
    460e:	26 e2       	ldi	r18, 0x26	; 38
    4610:	3b e3       	ldi	r19, 0x3B	; 59
    4612:	b3 c0       	rjmp	.+358    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetTraceStop) 			: return (uint8*)"SetTraceStop"	; break;
    4614:	23 e3       	ldi	r18, 0x33	; 51
    4616:	3b e3       	ldi	r19, 0x3B	; 59
    4618:	b0 c0       	rjmp	.+352    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceStop) 			: return (uint8*)"GetTraceStop"	; break;
    461a:	20 e4       	ldi	r18, 0x40	; 64
    461c:	3b e3       	ldi	r19, 0x3B	; 59
    461e:	ad c0       	rjmp	.+346    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetTraceVariable) 		: return (uint8*)"SetTraceVariable"; break;
    4620:	21 e5       	ldi	r18, 0x51	; 81
    4622:	3b e3       	ldi	r19, 0x3B	; 59
    4624:	aa c0       	rjmp	.+340    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceVariable) 		: return (uint8*)"GetTraceVariable"; break;
    4626:	22 e6       	ldi	r18, 0x62	; 98
    4628:	3b e3       	ldi	r19, 0x3B	; 59
    462a:	a7 c0       	rjmp	.+334    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetTracePeriod) 			: return (uint8*)"SetTracePeriod"; break;
    462c:	21 e7       	ldi	r18, 0x71	; 113
    462e:	3b e3       	ldi	r19, 0x3B	; 59
    4630:	a4 c0       	rjmp	.+328    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetTracePeriod) 			: return (uint8*)"GetTracePeriod"; break;
    4632:	20 e8       	ldi	r18, 0x80	; 128
    4634:	3b e3       	ldi	r19, 0x3B	; 59
    4636:	a1 c0       	rjmp	.+322    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceStatus) 			: return (uint8*)"GetTraceStatus"; break;
    4638:	2f e8       	ldi	r18, 0x8F	; 143
    463a:	3b e3       	ldi	r19, 0x3B	; 59
    463c:	9e c0       	rjmp	.+316    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceCount) 			: return (uint8*)"GetTraceCount"; break;
    463e:	2d e9       	ldi	r18, 0x9D	; 157
    4640:	3b e3       	ldi	r19, 0x3B	; 59
    4642:	9b c0       	rjmp	.+310    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetSettleWindow) 		: return (uint8*)"SetSettleWindow"; break;
    4644:	2d ea       	ldi	r18, 0xAD	; 173
    4646:	3b e3       	ldi	r19, 0x3B	; 59
    4648:	98 c0       	rjmp	.+304    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetSettleWindow) 		: return (uint8*)"GetSettleWindow"; break;
    464a:	2d eb       	ldi	r18, 0xBD	; 189
    464c:	3b e3       	ldi	r19, 0x3B	; 59
    464e:	95 c0       	rjmp	.+298    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetActualPositionUnits)	: return (uint8*)"SetActualPositionUnits"; break;
    4650:	24 ed       	ldi	r18, 0xD4	; 212
    4652:	3b e3       	ldi	r19, 0x3B	; 59
    4654:	92 c0       	rjmp	.+292    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetActualPositionUnits)	: return (uint8*)"GetActualPositionUnits"; break;
    4656:	2b ee       	ldi	r18, 0xEB	; 235
    4658:	3b e3       	ldi	r19, 0x3B	; 59
    465a:	8f c0       	rjmp	.+286    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetBufferStart) 			: return (uint8*)"SetBufferStart"; break;
    465c:	2a ef       	ldi	r18, 0xFA	; 250
    465e:	3b e3       	ldi	r19, 0x3B	; 59
    4660:	8c c0       	rjmp	.+280    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetBufferStart) 			: return (uint8*)"GetBufferStart"; break;
    4662:	29 e0       	ldi	r18, 0x09	; 9
    4664:	3c e3       	ldi	r19, 0x3C	; 60
    4666:	89 c0       	rjmp	.+274    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetBufferLength) 		: return (uint8*)"SetBufferLength"; break;
    4668:	29 e1       	ldi	r18, 0x19	; 25
    466a:	3c e3       	ldi	r19, 0x3C	; 60
    466c:	86 c0       	rjmp	.+268    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetBufferLength) 		: return (uint8*)"GetBufferLength"; break;
    466e:	29 e2       	ldi	r18, 0x29	; 41
    4670:	3c e3       	ldi	r19, 0x3C	; 60
    4672:	83 c0       	rjmp	.+262    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetBufferWriteIndex) 	: return (uint8*)"SetBufferWriteIndex"; break;
    4674:	2d e3       	ldi	r18, 0x3D	; 61
    4676:	3c e3       	ldi	r19, 0x3C	; 60
    4678:	80 c0       	rjmp	.+256    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetBufferWriteIndex) 	: return (uint8*)"GetBufferWriteIndex"; break;
    467a:	21 e5       	ldi	r18, 0x51	; 81
    467c:	3c e3       	ldi	r19, 0x3C	; 60
    467e:	7d c0       	rjmp	.+250    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetBufferReadIndex) 		: return (uint8*)"SetBufferReadIndex"; break;
    4680:	24 e6       	ldi	r18, 0x64	; 100
    4682:	3c e3       	ldi	r19, 0x3C	; 60
    4684:	7a c0       	rjmp	.+244    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetBufferReadIndex) 		: return (uint8*)"GetBufferReadIndex"; break;
    4686:	27 e7       	ldi	r18, 0x77	; 119
    4688:	3c e3       	ldi	r19, 0x3C	; 60
    468a:	77 c0       	rjmp	.+238    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPWriteBuffer) 			: return (uint8*)"WriteBuffer"; break;
    468c:	23 e8       	ldi	r18, 0x83	; 131
    468e:	3c e3       	ldi	r19, 0x3C	; 60
    4690:	74 c0       	rjmp	.+232    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPReadBuffer) 				: return (uint8*)"ReadBuffer"; break;
    4692:	2e e8       	ldi	r18, 0x8E	; 142
    4694:	3c e3       	ldi	r19, 0x3C	; 60
    4696:	71 c0       	rjmp	.+226    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetBufferFunction) 		: return (uint8*)"SetBufferFunction"; break;
    4698:	20 ea       	ldi	r18, 0xA0	; 160
    469a:	3c e3       	ldi	r19, 0x3C	; 60
    469c:	6e c0       	rjmp	.+220    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetBufferFunction) 		: return (uint8*)"GetBufferFunction"; break;
    469e:	22 eb       	ldi	r18, 0xB2	; 178
    46a0:	3c e3       	ldi	r19, 0x3C	; 60
    46a2:	6b c0       	rjmp	.+214    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetStepRange) 			: return (uint8*)"GetStepRange"	; break;
    46a4:	2f eb       	ldi	r18, 0xBF	; 191
    46a6:	3c e3       	ldi	r19, 0x3C	; 60
    46a8:	68 c0       	rjmp	.+208    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetStepRange) 			: return (uint8*)"SetStepRange"; break;
    46aa:	2c ec       	ldi	r18, 0xCC	; 204
    46ac:	3c e3       	ldi	r19, 0x3C	; 60
    46ae:	65 c0       	rjmp	.+202    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetStopMode) 			: return (uint8*)"SetStopMode"; break;
    46b0:	28 ed       	ldi	r18, 0xD8	; 216
    46b2:	3c e3       	ldi	r19, 0x3C	; 60
    46b4:	62 c0       	rjmp	.+196    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetStopMode) 			: return (uint8*)"GetStopMode"; break;
    46b6:	24 ee       	ldi	r18, 0xE4	; 228
    46b8:	3c e3       	ldi	r19, 0x3C	; 60
    46ba:	5f c0       	rjmp	.+190    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetAutoStopMode) 		: return (uint8*)"SetAutoStopMode"; break;
    46bc:	24 ef       	ldi	r18, 0xF4	; 244
    46be:	3c e3       	ldi	r19, 0x3C	; 60
    46c0:	5c c0       	rjmp	.+184    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetAutoStopMode) 		: return (uint8*)"GetAutoStopMode"; break;
    46c2:	24 e0       	ldi	r18, 0x04	; 4
    46c4:	3d e3       	ldi	r19, 0x3D	; 61
    46c6:	59 c0       	rjmp	.+178    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetBreakpoint) 			: return (uint8*)"SetBreakpoint"; break;
    46c8:	22 e1       	ldi	r18, 0x12	; 18
    46ca:	3d e3       	ldi	r19, 0x3D	; 61
    46cc:	56 c0       	rjmp	.+172    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetBreakpoint) 			: return (uint8*)"GetBreakpoint"; break;
    46ce:	20 e2       	ldi	r18, 0x20	; 32
    46d0:	3d e3       	ldi	r19, 0x3D	; 61
    46d2:	53 c0       	rjmp	.+166    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetBreakpointValue) 		: return (uint8*)"SetBreakpointValue"; break;
    46d4:	23 e3       	ldi	r18, 0x33	; 51
    46d6:	3d e3       	ldi	r19, 0x3D	; 61
    46d8:	50 c0       	rjmp	.+160    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetBreakpointValue) 		: return (uint8*)"GetBreakpointValue"; break;
    46da:	26 e4       	ldi	r18, 0x46	; 70
    46dc:	3d e3       	ldi	r19, 0x3D	; 61
    46de:	4d c0       	rjmp	.+154    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetCaptureSource) 		: return (uint8*)"SetCaptureSource"	; break;
    46e0:	27 e5       	ldi	r18, 0x57	; 87
    46e2:	3d e3       	ldi	r19, 0x3D	; 61
    46e4:	4a c0       	rjmp	.+148    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetCaptureSource) 		: return (uint8*)"GetCaptureSource"	; break;
    46e6:	28 e6       	ldi	r18, 0x68	; 104
    46e8:	3d e3       	ldi	r19, 0x3D	; 61
    46ea:	47 c0       	rjmp	.+142    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetEncoderSource) 		: return (uint8*)"SetEncoderSource"	; break;
    46ec:	29 e7       	ldi	r18, 0x79	; 121
    46ee:	3d e3       	ldi	r19, 0x3D	; 61
    46f0:	44 c0       	rjmp	.+136    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetEncoderSource) 		: return (uint8*)"GetEncoderSource"	; break;
    46f2:	2a e8       	ldi	r18, 0x8A	; 138
    46f4:	3d e3       	ldi	r19, 0x3D	; 61
    46f6:	41 c0       	rjmp	.+130    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetMotorMode) 			: return (uint8*)"SetMotorMode"	; break;
    46f8:	27 e9       	ldi	r18, 0x97	; 151
    46fa:	3d e3       	ldi	r19, 0x3D	; 61
    46fc:	3e c0       	rjmp	.+124    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetMotorMode) 			: return (uint8*)"GetMotorMode"	; break;
    46fe:	24 ea       	ldi	r18, 0xA4	; 164
    4700:	3d e3       	ldi	r19, 0x3D	; 61
    4702:	3b c0       	rjmp	.+118    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetEncoderToStepRatio) 	: return (uint8*)"SetEncoderToStepRatio"; break;
    4704:	2a eb       	ldi	r18, 0xBA	; 186
    4706:	3d e3       	ldi	r19, 0x3D	; 61
    4708:	38 c0       	rjmp	.+112    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetEncoderToStepRatio) 	: return (uint8*)"GetEncoderToStepRatio"; break;
    470a:	20 ed       	ldi	r18, 0xD0	; 208
    470c:	3d e3       	ldi	r19, 0x3D	; 61
    470e:	35 c0       	rjmp	.+106    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetOutputMode) 			: return (uint8*)"SetOutputMode"; break;
    4710:	2e ed       	ldi	r18, 0xDE	; 222
    4712:	3d e3       	ldi	r19, 0x3D	; 61
    4714:	32 c0       	rjmp	.+100    	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetInterruptAxis) 		: return (uint8*)"GetInterruptAxis"	; break;
    4716:	2f ee       	ldi	r18, 0xEF	; 239
    4718:	3d e3       	ldi	r19, 0x3D	; 61
    471a:	2f c0       	rjmp	.+94     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetCommutationMode) 		: return (uint8*)"SetCommutationMode"; break;
    471c:	22 e0       	ldi	r18, 0x02	; 2
    471e:	3e e3       	ldi	r19, 0x3E	; 62
    4720:	2c c0       	rjmp	.+88     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetCommutationMode) 		: return (uint8*)"GetCommutationMode"; break;
    4722:	25 e1       	ldi	r18, 0x15	; 21
    4724:	3e e3       	ldi	r19, 0x3E	; 62
    4726:	29 c0       	rjmp	.+82     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseInitializeMode) 	: return (uint8*)"SetPhaseInitializeMode"; break;
    4728:	2c e2       	ldi	r18, 0x2C	; 44
    472a:	3e e3       	ldi	r19, 0x3E	; 62
    472c:	26 c0       	rjmp	.+76     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseInitializeMode) 	: return (uint8*)"GetPhaseInitializeMode"; break;
    472e:	23 e4       	ldi	r18, 0x43	; 67
    4730:	3e e3       	ldi	r19, 0x3E	; 62
    4732:	23 c0       	rjmp	.+70     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhasePrescale) 		: return (uint8*)"SetPhasePrescale"; break;
    4734:	24 e5       	ldi	r18, 0x54	; 84
    4736:	3e e3       	ldi	r19, 0x3E	; 62
    4738:	20 c0       	rjmp	.+64     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhasePrescale) 		: return (uint8*)"GetPhasePrescale"; break;
    473a:	25 e6       	ldi	r18, 0x65	; 101
    473c:	3e e3       	ldi	r19, 0x3E	; 62
    473e:	1d c0       	rjmp	.+58     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseCorrectionMode) 	: return (uint8*)"SetPhaseCorrectionMode"; break;
    4740:	2c e7       	ldi	r18, 0x7C	; 124
    4742:	3e e3       	ldi	r19, 0x3E	; 62
    4744:	1a c0       	rjmp	.+52     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseCorrectionMode) 	: return (uint8*)"GetPhaseCorrectionMode"; break;
    4746:	23 e9       	ldi	r18, 0x93	; 147
    4748:	3e e3       	ldi	r19, 0x3E	; 62
    474a:	17 c0       	rjmp	.+46     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseCommand) 		: return (uint8*)"GetPhaseCommand"; break;
    474c:	23 ea       	ldi	r18, 0xA3	; 163
    474e:	3e e3       	ldi	r19, 0x3E	; 62
    4750:	14 c0       	rjmp	.+40     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetMotionCompleteMode) 	: return (uint8*)"SetMotionCompleteMode"; break;
    4752:	29 eb       	ldi	r18, 0xB9	; 185
    4754:	3e e3       	ldi	r19, 0x3E	; 62
    4756:	11 c0       	rjmp	.+34     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetMotionCompleteMode) 	: return (uint8*)"GetMotionCompleteMode"; break;
    4758:	2f ec       	ldi	r18, 0xCF	; 207
    475a:	3e e3       	ldi	r19, 0x3E	; 62
    475c:	0e c0       	rjmp	.+28     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPSetAxisOutSource) 		: return (uint8*)"SetAxisOutSource"	; break;
    475e:	20 ee       	ldi	r18, 0xE0	; 224
    4760:	3e e3       	ldi	r19, 0x3E	; 62
    4762:	0b c0       	rjmp	.+22     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetAxisOutSource) 		: return (uint8*)"GetAxisOutSource"	; break;
    4764:	21 ef       	ldi	r18, 0xF1	; 241
    4766:	3e e3       	ldi	r19, 0x3E	; 62
    4768:	08 c0       	rjmp	.+16     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPReadAnalog) 				: return (uint8*)"ReadAnalog"; break;
    476a:	2c ef       	ldi	r18, 0xFC	; 252
    476c:	3e e3       	ldi	r19, 0x3E	; 62
    476e:	05 c0       	rjmp	.+10     	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPAdjustActualPosition)	: return (uint8*)"AdjustActualPosition"; break;
    4770:	21 e1       	ldi	r18, 0x11	; 17
    4772:	3f e3       	ldi	r19, 0x3F	; 63
    4774:	02 c0       	rjmp	.+4      	; 0x477a <PMDGetOpcodeText+0x400>
	case (PMDOPGetChecksum) 			: return (uint8*)"GetChecksum"; break;
    4776:	2d e1       	ldi	r18, 0x1D	; 29
    4778:	3f e3       	ldi	r19, 0x3F	; 63
	
	default 							: return (uint8*)"Invalid opcode!"; break;
	}
}
    477a:	c9 01       	movw	r24, r18
    477c:	08 95       	ret

0000477e <PMDGetErrorMessage>:

/*****************************************************************************************/
uint8 *PMDGetErrorMessage(PMDuint16 errorCode) 
{

  switch(errorCode) {
    477e:	8f 30       	cpi	r24, 0x0F	; 15
    4780:	91 05       	cpc	r25, r1
    4782:	09 f4       	brne	.+2      	; 0x4786 <PMDGetErrorMessage+0x8>
    4784:	c0 c0       	rjmp	.+384    	; 0x4906 <PMDGetErrorMessage+0x188>
    4786:	80 31       	cpi	r24, 0x10	; 16
    4788:	91 05       	cpc	r25, r1
    478a:	a8 f5       	brcc	.+106    	; 0x47f6 <PMDGetErrorMessage+0x78>
    478c:	87 30       	cpi	r24, 0x07	; 7
    478e:	91 05       	cpc	r25, r1
    4790:	09 f4       	brne	.+2      	; 0x4794 <PMDGetErrorMessage+0x16>
    4792:	a1 c0       	rjmp	.+322    	; 0x48d6 <PMDGetErrorMessage+0x158>
    4794:	88 30       	cpi	r24, 0x08	; 8
    4796:	91 05       	cpc	r25, r1
    4798:	b8 f4       	brcc	.+46     	; 0x47c8 <PMDGetErrorMessage+0x4a>
    479a:	83 30       	cpi	r24, 0x03	; 3
    479c:	91 05       	cpc	r25, r1
    479e:	09 f4       	brne	.+2      	; 0x47a2 <PMDGetErrorMessage+0x24>
    47a0:	8e c0       	rjmp	.+284    	; 0x48be <PMDGetErrorMessage+0x140>
    47a2:	84 30       	cpi	r24, 0x04	; 4
    47a4:	91 05       	cpc	r25, r1
    47a6:	40 f4       	brcc	.+16     	; 0x47b8 <PMDGetErrorMessage+0x3a>
    47a8:	81 30       	cpi	r24, 0x01	; 1
    47aa:	91 05       	cpc	r25, r1
    47ac:	09 f4       	brne	.+2      	; 0x47b0 <PMDGetErrorMessage+0x32>
    47ae:	7e c0       	rjmp	.+252    	; 0x48ac <PMDGetErrorMessage+0x12e>
    47b0:	02 97       	sbiw	r24, 0x02	; 2
    47b2:	08 f0       	brcs	.+2      	; 0x47b6 <PMDGetErrorMessage+0x38>
    47b4:	81 c0       	rjmp	.+258    	; 0x48b8 <PMDGetErrorMessage+0x13a>
    47b6:	7d c0       	rjmp	.+250    	; 0x48b2 <PMDGetErrorMessage+0x134>
    47b8:	85 30       	cpi	r24, 0x05	; 5
    47ba:	91 05       	cpc	r25, r1
    47bc:	09 f4       	brne	.+2      	; 0x47c0 <PMDGetErrorMessage+0x42>
    47be:	85 c0       	rjmp	.+266    	; 0x48ca <PMDGetErrorMessage+0x14c>
    47c0:	06 97       	sbiw	r24, 0x06	; 6
    47c2:	08 f0       	brcs	.+2      	; 0x47c6 <PMDGetErrorMessage+0x48>
    47c4:	85 c0       	rjmp	.+266    	; 0x48d0 <PMDGetErrorMessage+0x152>
    47c6:	7e c0       	rjmp	.+252    	; 0x48c4 <PMDGetErrorMessage+0x146>
    47c8:	8b 30       	cpi	r24, 0x0B	; 11
    47ca:	91 05       	cpc	r25, r1
    47cc:	09 f4       	brne	.+2      	; 0x47d0 <PMDGetErrorMessage+0x52>
    47ce:	8f c0       	rjmp	.+286    	; 0x48ee <PMDGetErrorMessage+0x170>
    47d0:	8c 30       	cpi	r24, 0x0C	; 12
    47d2:	91 05       	cpc	r25, r1
    47d4:	40 f4       	brcc	.+16     	; 0x47e6 <PMDGetErrorMessage+0x68>
    47d6:	89 30       	cpi	r24, 0x09	; 9
    47d8:	91 05       	cpc	r25, r1
    47da:	09 f4       	brne	.+2      	; 0x47de <PMDGetErrorMessage+0x60>
    47dc:	82 c0       	rjmp	.+260    	; 0x48e2 <PMDGetErrorMessage+0x164>
    47de:	0a 97       	sbiw	r24, 0x0a	; 10
    47e0:	08 f0       	brcs	.+2      	; 0x47e4 <PMDGetErrorMessage+0x66>
    47e2:	82 c0       	rjmp	.+260    	; 0x48e8 <PMDGetErrorMessage+0x16a>
    47e4:	7b c0       	rjmp	.+246    	; 0x48dc <PMDGetErrorMessage+0x15e>
    47e6:	8d 30       	cpi	r24, 0x0D	; 13
    47e8:	91 05       	cpc	r25, r1
    47ea:	09 f4       	brne	.+2      	; 0x47ee <PMDGetErrorMessage+0x70>
    47ec:	86 c0       	rjmp	.+268    	; 0x48fa <PMDGetErrorMessage+0x17c>
    47ee:	0e 97       	sbiw	r24, 0x0e	; 14
    47f0:	08 f0       	brcs	.+2      	; 0x47f4 <PMDGetErrorMessage+0x76>
    47f2:	86 c0       	rjmp	.+268    	; 0x4900 <PMDGetErrorMessage+0x182>
    47f4:	7f c0       	rjmp	.+254    	; 0x48f4 <PMDGetErrorMessage+0x176>
    47f6:	2f e7       	ldi	r18, 0x7F	; 127
    47f8:	8d 3d       	cpi	r24, 0xDD	; 221
    47fa:	92 07       	cpc	r25, r18
    47fc:	09 f4       	brne	.+2      	; 0x4800 <PMDGetErrorMessage+0x82>
    47fe:	9b c0       	rjmp	.+310    	; 0x4936 <PMDGetErrorMessage+0x1b8>
    4800:	2f e7       	ldi	r18, 0x7F	; 127
    4802:	8e 3d       	cpi	r24, 0xDE	; 222
    4804:	92 07       	cpc	r25, r18
    4806:	38 f5       	brcc	.+78     	; 0x4856 <PMDGetErrorMessage+0xd8>
    4808:	2f e7       	ldi	r18, 0x7F	; 127
    480a:	83 3d       	cpi	r24, 0xD3	; 211
    480c:	92 07       	cpc	r25, r18
    480e:	09 f4       	brne	.+2      	; 0x4812 <PMDGetErrorMessage+0x94>
    4810:	86 c0       	rjmp	.+268    	; 0x491e <PMDGetErrorMessage+0x1a0>
    4812:	2f e7       	ldi	r18, 0x7F	; 127
    4814:	84 3d       	cpi	r24, 0xD4	; 212
    4816:	92 07       	cpc	r25, r18
    4818:	78 f4       	brcc	.+30     	; 0x4838 <PMDGetErrorMessage+0xba>
    481a:	2f e7       	ldi	r18, 0x7F	; 127
    481c:	81 3d       	cpi	r24, 0xD1	; 209
    481e:	92 07       	cpc	r25, r18
    4820:	09 f4       	brne	.+2      	; 0x4824 <PMDGetErrorMessage+0xa6>
    4822:	77 c0       	rjmp	.+238    	; 0x4912 <PMDGetErrorMessage+0x194>
    4824:	2f e7       	ldi	r18, 0x7F	; 127
    4826:	82 3d       	cpi	r24, 0xD2	; 210
    4828:	92 07       	cpc	r25, r18
    482a:	08 f0       	brcs	.+2      	; 0x482e <PMDGetErrorMessage+0xb0>
    482c:	75 c0       	rjmp	.+234    	; 0x4918 <PMDGetErrorMessage+0x19a>
    482e:	80 5d       	subi	r24, 0xD0	; 208
    4830:	9f 47       	sbci	r25, 0x7F	; 127
    4832:	09 f0       	breq	.+2      	; 0x4836 <PMDGetErrorMessage+0xb8>
    4834:	9b c0       	rjmp	.+310    	; 0x496c <PMDGetErrorMessage+0x1ee>
    4836:	6a c0       	rjmp	.+212    	; 0x490c <PMDGetErrorMessage+0x18e>
    4838:	2f e7       	ldi	r18, 0x7F	; 127
    483a:	8b 3d       	cpi	r24, 0xDB	; 219
    483c:	92 07       	cpc	r25, r18
    483e:	09 f4       	brne	.+2      	; 0x4842 <PMDGetErrorMessage+0xc4>
    4840:	74 c0       	rjmp	.+232    	; 0x492a <PMDGetErrorMessage+0x1ac>
    4842:	2f e7       	ldi	r18, 0x7F	; 127
    4844:	8c 3d       	cpi	r24, 0xDC	; 220
    4846:	92 07       	cpc	r25, r18
    4848:	08 f0       	brcs	.+2      	; 0x484c <PMDGetErrorMessage+0xce>
    484a:	72 c0       	rjmp	.+228    	; 0x4930 <PMDGetErrorMessage+0x1b2>
    484c:	84 5d       	subi	r24, 0xD4	; 212
    484e:	9f 47       	sbci	r25, 0x7F	; 127
    4850:	09 f0       	breq	.+2      	; 0x4854 <PMDGetErrorMessage+0xd6>
    4852:	8c c0       	rjmp	.+280    	; 0x496c <PMDGetErrorMessage+0x1ee>
    4854:	67 c0       	rjmp	.+206    	; 0x4924 <PMDGetErrorMessage+0x1a6>
    4856:	2f e7       	ldi	r18, 0x7F	; 127
    4858:	81 3e       	cpi	r24, 0xE1	; 225
    485a:	92 07       	cpc	r25, r18
    485c:	09 f4       	brne	.+2      	; 0x4860 <PMDGetErrorMessage+0xe2>
    485e:	77 c0       	rjmp	.+238    	; 0x494e <PMDGetErrorMessage+0x1d0>
    4860:	2f e7       	ldi	r18, 0x7F	; 127
    4862:	82 3e       	cpi	r24, 0xE2	; 226
    4864:	92 07       	cpc	r25, r18
    4866:	50 f4       	brcc	.+20     	; 0x487c <PMDGetErrorMessage+0xfe>
    4868:	2f e7       	ldi	r18, 0x7F	; 127
    486a:	8f 3d       	cpi	r24, 0xDF	; 223
    486c:	92 07       	cpc	r25, r18
    486e:	09 f4       	brne	.+2      	; 0x4872 <PMDGetErrorMessage+0xf4>
    4870:	68 c0       	rjmp	.+208    	; 0x4942 <PMDGetErrorMessage+0x1c4>
    4872:	80 5e       	subi	r24, 0xE0	; 224
    4874:	9f 47       	sbci	r25, 0x7F	; 127
    4876:	08 f0       	brcs	.+2      	; 0x487a <PMDGetErrorMessage+0xfc>
    4878:	67 c0       	rjmp	.+206    	; 0x4948 <PMDGetErrorMessage+0x1ca>
    487a:	60 c0       	rjmp	.+192    	; 0x493c <PMDGetErrorMessage+0x1be>
    487c:	2f e7       	ldi	r18, 0x7F	; 127
    487e:	8d 3f       	cpi	r24, 0xFD	; 253
    4880:	92 07       	cpc	r25, r18
    4882:	09 f4       	brne	.+2      	; 0x4886 <PMDGetErrorMessage+0x108>
    4884:	6a c0       	rjmp	.+212    	; 0x495a <PMDGetErrorMessage+0x1dc>
    4886:	2f e7       	ldi	r18, 0x7F	; 127
    4888:	8e 3f       	cpi	r24, 0xFE	; 254
    488a:	92 07       	cpc	r25, r18
    488c:	28 f4       	brcc	.+10     	; 0x4898 <PMDGetErrorMessage+0x11a>
    488e:	8c 5f       	subi	r24, 0xFC	; 252
    4890:	9f 47       	sbci	r25, 0x7F	; 127
    4892:	09 f0       	breq	.+2      	; 0x4896 <PMDGetErrorMessage+0x118>
    4894:	6b c0       	rjmp	.+214    	; 0x496c <PMDGetErrorMessage+0x1ee>
    4896:	5e c0       	rjmp	.+188    	; 0x4954 <PMDGetErrorMessage+0x1d6>
    4898:	2f e7       	ldi	r18, 0x7F	; 127
    489a:	8e 3f       	cpi	r24, 0xFE	; 254
    489c:	92 07       	cpc	r25, r18
    489e:	09 f4       	brne	.+2      	; 0x48a2 <PMDGetErrorMessage+0x124>
    48a0:	5f c0       	rjmp	.+190    	; 0x4960 <PMDGetErrorMessage+0x1e2>
    48a2:	8f 5f       	subi	r24, 0xFF	; 255
    48a4:	9f 47       	sbci	r25, 0x7F	; 127
    48a6:	09 f0       	breq	.+2      	; 0x48aa <PMDGetErrorMessage+0x12c>
    48a8:	61 c0       	rjmp	.+194    	; 0x496c <PMDGetErrorMessage+0x1ee>
    48aa:	5d c0       	rjmp	.+186    	; 0x4966 <PMDGetErrorMessage+0x1e8>
    48ac:	2d e2       	ldi	r18, 0x2D	; 45
    48ae:	3f e3       	ldi	r19, 0x3F	; 63
    48b0:	5f c0       	rjmp	.+190    	; 0x4970 <PMDGetErrorMessage+0x1f2>
    48b2:	2c e3       	ldi	r18, 0x3C	; 60
    48b4:	3f e3       	ldi	r19, 0x3F	; 63
    48b6:	5c c0       	rjmp	.+184    	; 0x4970 <PMDGetErrorMessage+0x1f2>
    48b8:	25 e4       	ldi	r18, 0x45	; 69
    48ba:	3f e3       	ldi	r19, 0x3F	; 63
    48bc:	59 c0       	rjmp	.+178    	; 0x4970 <PMDGetErrorMessage+0x1f2>
    
	// MC2400 Chipset error codes
	
	case ( PMD_ERR_OK) 						: return (uint8*)  "NO Error"; break;
	case ( PMD_ERR_ChipsetReset)  			: return (uint8*)  "Chipset Reset "; break;
    case ( PMD_ERR_InvalidInstruction)  	: return (uint8*)  "Invalid Instruction"; break;
    48be:	29 e5       	ldi	r18, 0x59	; 89
    48c0:	3f e3       	ldi	r19, 0x3F	; 63
    48c2:	56 c0       	rjmp	.+172    	; 0x4970 <PMDGetErrorMessage+0x1f2>
    case ( PMD_ERR_InvalidAxis)  			: return (uint8*)  "Invalid Axis"; break;
    48c4:	26 e6       	ldi	r18, 0x66	; 102
    48c6:	3f e3       	ldi	r19, 0x3F	; 63
    48c8:	53 c0       	rjmp	.+166    	; 0x4970 <PMDGetErrorMessage+0x1f2>
    case ( PMD_ERR_InvalidParameter)  		: return (uint8*)  "Invalid Data Parameter"; break;
    48ca:	2d e7       	ldi	r18, 0x7D	; 125
    48cc:	3f e3       	ldi	r19, 0x3F	; 63
    48ce:	50 c0       	rjmp	.+160    	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_TraceRunning)			: return (uint8*)  "Trace Currently Running" ;break;
    48d0:	25 e9       	ldi	r18, 0x95	; 149
    48d2:	3f e3       	ldi	r19, 0x3F	; 63
    48d4:	4d c0       	rjmp	.+154    	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_Flash)					: return (uint8*)  "Flash Error" ;break;
    48d6:	21 ea       	ldi	r18, 0xA1	; 161
    48d8:	3f e3       	ldi	r19, 0x3F	; 63
    48da:	4a c0       	rjmp	.+148    	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_BlockOutOfBounds)		: return (uint8*)  "Block Out of Bounds" ;break;
    48dc:	25 eb       	ldi	r18, 0xB5	; 181
    48de:	3f e3       	ldi	r19, 0x3F	; 63
    48e0:	47 c0       	rjmp	.+142    	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_TraceBufferZero)			: return (uint8*)  "Zero Length Trace Buffer" ;break;
    48e2:	2e ec       	ldi	r18, 0xCE	; 206
    48e4:	3f e3       	ldi	r19, 0x3F	; 63
    48e6:	44 c0       	rjmp	.+136    	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_BadSerialChecksum)		: return (uint8*)  "Invalid Checksum" ;break;
    48e8:	2f ed       	ldi	r18, 0xDF	; 223
    48ea:	3f e3       	ldi	r19, 0x3F	; 63
    48ec:	41 c0       	rjmp	.+130    	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_NotPrimaryPort)			: return (uint8*)  "Invalid Instruction For Diagnostic Port" ;break;
    48ee:	27 e0       	ldi	r18, 0x07	; 7
    48f0:	30 e4       	ldi	r19, 0x40	; 64
    48f2:	3e c0       	rjmp	.+124    	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidNegativeValue)	: return (uint8*)  "Invalid Negative Value for Profile Mode" ;break;
    48f4:	2f e2       	ldi	r18, 0x2F	; 47
    48f6:	30 e4       	ldi	r19, 0x40	; 64
    48f8:	3b c0       	rjmp	.+118    	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidParameterChange) 	: return (uint8*)  "Invalid Parameter Change for Profile Mode" ;break;
    48fa:	29 e5       	ldi	r18, 0x59	; 89
    48fc:	30 e4       	ldi	r19, 0x40	; 64
    48fe:	38 c0       	rjmp	.+112    	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_LimitEventPending)		: return (uint8*)  "Invalid Move with Limit Event Pending" ;break;
    4900:	2f e7       	ldi	r18, 0x7F	; 127
    4902:	30 e4       	ldi	r19, 0x40	; 64
    4904:	35 c0       	rjmp	.+106    	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidMoveIntoLimit)	: return (uint8*)  "Invalid Move into Limit" ;break;
    4906:	27 e9       	ldi	r18, 0x97	; 151
    4908:	30 e4       	ldi	r19, 0x40	; 64
    490a:	32 c0       	rjmp	.+100    	; 0x4970 <PMDGetErrorMessage+0x1f2>
    case ( PMD_ERR_InvalidClearInterrupt)	: return (uint8*)  "Invalid Clear Interrupt" ;break;
    490c:	2f ea       	ldi	r18, 0xAF	; 175
    490e:	30 e4       	ldi	r19, 0x40	; 64
    4910:	2f c0       	rjmp	.+94     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	
	// DK2000 initialization errors
	case ( PMD_ERR_InvalidOperation)		: return (uint8*)  "Invalid Operation" ;break;
    4912:	21 ec       	ldi	r18, 0xC1	; 193
    4914:	30 e4       	ldi	r19, 0x40	; 64
    4916:	2c c0       	rjmp	.+88     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_NotConnected)			: return (uint8*)  "Not Connected" ;break;
    4918:	2f ec       	ldi	r18, 0xCF	; 207
    491a:	30 e4       	ldi	r19, 0x40	; 64
    491c:	29 c0       	rjmp	.+82     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_ChipsetNotResponding)	: return (uint8*)  "Chipset Not Responding" ;break;
    491e:	26 ee       	ldi	r18, 0xE6	; 230
    4920:	30 e4       	ldi	r19, 0x40	; 64
    4922:	26 c0       	rjmp	.+76     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_CommPortRead)			: return (uint8*)  "Comm Port Read" ;break;
    4924:	25 ef       	ldi	r18, 0xF5	; 245
    4926:	30 e4       	ldi	r19, 0x40	; 64
    4928:	23 c0       	rjmp	.+70     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_CommPortWrite)			: return (uint8*)  "Comm Port Write" ;break;
    492a:	25 e0       	ldi	r18, 0x05	; 5
    492c:	31 e4       	ldi	r19, 0x41	; 65
    492e:	20 c0       	rjmp	.+64     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidSerialPort)		: return (uint8*)  "Invalid Serial Port" ;break;
    4930:	29 e1       	ldi	r18, 0x19	; 25
    4932:	31 e4       	ldi	r19, 0x41	; 65
    4934:	1d c0       	rjmp	.+58     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidDK2000IOBase)		: return (uint8*)  "Invalid DK2000 IO Base" ;break;
    4936:	20 e3       	ldi	r18, 0x30	; 48
    4938:	31 e4       	ldi	r19, 0x41	; 65
    493a:	1a c0       	rjmp	.+52     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidDK2000IRQ)		: return (uint8*)  "Invalid DK2000 IRQ" ;break;
    493c:	23 e4       	ldi	r18, 0x43	; 67
    493e:	31 e4       	ldi	r19, 0x41	; 65
    4940:	17 c0       	rjmp	.+46     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidDK2000IOMode)		: return (uint8*)  "Invalid DK2000 IO Mode" ;break;
    4942:	2a e5       	ldi	r18, 0x5A	; 90
    4944:	31 e4       	ldi	r19, 0x41	; 65
    4946:	14 c0       	rjmp	.+40     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_PMDNotInitialized)		: return (uint8*)  "PMD Not Initialized" ;break;
    4948:	2e e6       	ldi	r18, 0x6E	; 110
    494a:	31 e4       	ldi	r19, 0x41	; 65
    494c:	11 c0       	rjmp	.+34     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_OpeningWindowsDriver)	: return (uint8*)  "Cannot Open Windows Driver" ;break;
    494e:	29 e8       	ldi	r18, 0x89	; 137
    4950:	31 e4       	ldi	r19, 0x41	; 65
    4952:	0e c0       	rjmp	.+28     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	
	// run-time errors
	case ( PMD_ERR_Driver)					: return (uint8*)  "Windows Driver Error" ;break;
    4954:	2e e9       	ldi	r18, 0x9E	; 158
    4956:	31 e4       	ldi	r19, 0x41	; 65
    4958:	0b c0       	rjmp	.+22     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_CommunicationsError)		: return (uint8*)  "Communication Error" ;break;
    495a:	22 eb       	ldi	r18, 0xB2	; 178
    495c:	31 e4       	ldi	r19, 0x41	; 65
    495e:	08 c0       	rjmp	.+16     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_CommTimeoutError)		: return (uint8*)  "Communication Timeout Error" ;break;
    4960:	2e ec       	ldi	r18, 0xCE	; 206
    4962:	31 e4       	ldi	r19, 0x41	; 65
    4964:	05 c0       	rjmp	.+10     	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_ChecksumError)			: return (uint8*)  "Checksum Error" ;break;
    4966:	2d ed       	ldi	r18, 0xDD	; 221
    4968:	31 e4       	ldi	r19, 0x41	; 65
    496a:	02 c0       	rjmp	.+4      	; 0x4970 <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_CommandError)			: return (uint8*)  "Command Error" ;break;
    496c:	2b ee       	ldi	r18, 0xEB	; 235
    496e:	31 e4       	ldi	r19, 0x41	; 65
    
	default: return (uint8*)"Undefined error occurred";
  }

 // return (uint8*)"Undefined error occurred";    // avoid compiler warning
} // PMDGetErrorMessage
    4970:	c9 01       	movw	r24, r18
    4972:	08 95       	ret

00004974 <Dayname>:

/*****************************************************************************************/
uint8 *Dayname(tdia dia)
{

	switch(dia) 
    4974:	83 30       	cpi	r24, 0x03	; 3
    4976:	b9 f0       	breq	.+46     	; 0x49a6 <Dayname+0x32>
    4978:	84 30       	cpi	r24, 0x04	; 4
    497a:	28 f4       	brcc	.+10     	; 0x4986 <Dayname+0x12>
    497c:	81 30       	cpi	r24, 0x01	; 1
    497e:	51 f0       	breq	.+20     	; 0x4994 <Dayname+0x20>
    4980:	82 30       	cpi	r24, 0x02	; 2
    4982:	70 f4       	brcc	.+28     	; 0x49a0 <Dayname+0x2c>
    4984:	0a c0       	rjmp	.+20     	; 0x499a <Dayname+0x26>
    4986:	85 30       	cpi	r24, 0x05	; 5
    4988:	a1 f0       	breq	.+40     	; 0x49b2 <Dayname+0x3e>
    498a:	85 30       	cpi	r24, 0x05	; 5
    498c:	78 f0       	brcs	.+30     	; 0x49ac <Dayname+0x38>
    498e:	86 30       	cpi	r24, 0x06	; 6
    4990:	b1 f4       	brne	.+44     	; 0x49be <Dayname+0x4a>
    4992:	12 c0       	rjmp	.+36     	; 0x49b8 <Dayname+0x44>
    4994:	24 e0       	ldi	r18, 0x04	; 4
    4996:	32 e4       	ldi	r19, 0x42	; 66
    4998:	14 c0       	rjmp	.+40     	; 0x49c2 <Dayname+0x4e>
    499a:	2a e0       	ldi	r18, 0x0A	; 10
    499c:	32 e4       	ldi	r19, 0x42	; 66
    499e:	11 c0       	rjmp	.+34     	; 0x49c2 <Dayname+0x4e>
    49a0:	22 e1       	ldi	r18, 0x12	; 18
    49a2:	32 e4       	ldi	r19, 0x42	; 66
    49a4:	0e c0       	rjmp	.+28     	; 0x49c2 <Dayname+0x4e>
	{
		case (Domingo) 					: return (uint8*)"Domingo"; break;
		case (Lunes) 					: return (uint8*)"Lunes"; break;
		case (Martes) 					: return (uint8*)"Martes"; break;
    49a6:	29 e1       	ldi	r18, 0x19	; 25
    49a8:	32 e4       	ldi	r19, 0x42	; 66
    49aa:	0b c0       	rjmp	.+22     	; 0x49c2 <Dayname+0x4e>
		case (Miercoles) 				: return (uint8*)"Miercoles"; break;
    49ac:	23 e2       	ldi	r18, 0x23	; 35
    49ae:	32 e4       	ldi	r19, 0x42	; 66
    49b0:	08 c0       	rjmp	.+16     	; 0x49c2 <Dayname+0x4e>
		case (Jueves) 					: return (uint8*)"Jueves"; break;
    49b2:	2a e2       	ldi	r18, 0x2A	; 42
    49b4:	32 e4       	ldi	r19, 0x42	; 66
    49b6:	05 c0       	rjmp	.+10     	; 0x49c2 <Dayname+0x4e>
		case (Viernes) 					: return (uint8*)"Viernes"; break;
    49b8:	22 e3       	ldi	r18, 0x32	; 50
    49ba:	32 e4       	ldi	r19, 0x42	; 66
    49bc:	02 c0       	rjmp	.+4      	; 0x49c2 <Dayname+0x4e>
		case (Sabado) 					: return (uint8*)"Sabado"; break;
    49be:	29 e3       	ldi	r18, 0x39	; 57
    49c0:	32 e4       	ldi	r19, 0x42	; 66
		   
		default 						: return (uint8*)"invalid day";
	}

} // Dayname
    49c2:	c9 01       	movw	r24, r18
    49c4:	08 95       	ret

000049c6 <Monthname>:

/*****************************************************************************************/
uint8 *Monthname(tmes mes)
{

	switch(mes) 
    49c6:	86 30       	cpi	r24, 0x06	; 6
    49c8:	79 f1       	breq	.+94     	; 0x4a28 <Monthname+0x62>
    49ca:	87 30       	cpi	r24, 0x07	; 7
    49cc:	70 f4       	brcc	.+28     	; 0x49ea <Monthname+0x24>
    49ce:	83 30       	cpi	r24, 0x03	; 3
    49d0:	11 f1       	breq	.+68     	; 0x4a16 <Monthname+0x50>
    49d2:	84 30       	cpi	r24, 0x04	; 4
    49d4:	28 f4       	brcc	.+10     	; 0x49e0 <Monthname+0x1a>
    49d6:	81 30       	cpi	r24, 0x01	; 1
    49d8:	d9 f0       	breq	.+54     	; 0x4a10 <Monthname+0x4a>
    49da:	82 30       	cpi	r24, 0x02	; 2
    49dc:	d1 f5       	brne	.+116    	; 0x4a52 <Monthname+0x8c>
    49de:	15 c0       	rjmp	.+42     	; 0x4a0a <Monthname+0x44>
    49e0:	84 30       	cpi	r24, 0x04	; 4
    49e2:	e1 f0       	breq	.+56     	; 0x4a1c <Monthname+0x56>
    49e4:	85 30       	cpi	r24, 0x05	; 5
    49e6:	a9 f5       	brne	.+106    	; 0x4a52 <Monthname+0x8c>
    49e8:	1c c0       	rjmp	.+56     	; 0x4a22 <Monthname+0x5c>
    49ea:	89 30       	cpi	r24, 0x09	; 9
    49ec:	31 f1       	breq	.+76     	; 0x4a3a <Monthname+0x74>
    49ee:	8a 30       	cpi	r24, 0x0A	; 10
    49f0:	28 f4       	brcc	.+10     	; 0x49fc <Monthname+0x36>
    49f2:	87 30       	cpi	r24, 0x07	; 7
    49f4:	e1 f0       	breq	.+56     	; 0x4a2e <Monthname+0x68>
    49f6:	88 30       	cpi	r24, 0x08	; 8
    49f8:	61 f5       	brne	.+88     	; 0x4a52 <Monthname+0x8c>
    49fa:	1c c0       	rjmp	.+56     	; 0x4a34 <Monthname+0x6e>
    49fc:	81 31       	cpi	r24, 0x11	; 17
    49fe:	19 f1       	breq	.+70     	; 0x4a46 <Monthname+0x80>
    4a00:	82 31       	cpi	r24, 0x12	; 18
    4a02:	21 f1       	breq	.+72     	; 0x4a4c <Monthname+0x86>
    4a04:	80 31       	cpi	r24, 0x10	; 16
    4a06:	29 f5       	brne	.+74     	; 0x4a52 <Monthname+0x8c>
    4a08:	1b c0       	rjmp	.+54     	; 0x4a40 <Monthname+0x7a>
    4a0a:	25 e4       	ldi	r18, 0x45	; 69
    4a0c:	32 e4       	ldi	r19, 0x42	; 66
    4a0e:	23 c0       	rjmp	.+70     	; 0x4a56 <Monthname+0x90>
    4a10:	2d e4       	ldi	r18, 0x4D	; 77
    4a12:	32 e4       	ldi	r19, 0x42	; 66
    4a14:	20 c0       	rjmp	.+64     	; 0x4a56 <Monthname+0x90>
    4a16:	23 e5       	ldi	r18, 0x53	; 83
    4a18:	32 e4       	ldi	r19, 0x42	; 66
    4a1a:	1d c0       	rjmp	.+58     	; 0x4a56 <Monthname+0x90>
	{
		case (Enero) 					: return (uint8*)"Enero"; break;
		case (Febrero) 					: return (uint8*)"Febrero"; break;
		case (Marzo) 					: return (uint8*)"Marzo"; break;
    4a1c:	29 e5       	ldi	r18, 0x59	; 89
    4a1e:	32 e4       	ldi	r19, 0x42	; 66
    4a20:	1a c0       	rjmp	.+52     	; 0x4a56 <Monthname+0x90>
		case (Abril) 					: return (uint8*)"Abril"; break;
    4a22:	2f e5       	ldi	r18, 0x5F	; 95
    4a24:	32 e4       	ldi	r19, 0x42	; 66
    4a26:	17 c0       	rjmp	.+46     	; 0x4a56 <Monthname+0x90>
		case (Mayo) 					: return (uint8*)"Mayo"; break;
    4a28:	24 e6       	ldi	r18, 0x64	; 100
    4a2a:	32 e4       	ldi	r19, 0x42	; 66
    4a2c:	14 c0       	rjmp	.+40     	; 0x4a56 <Monthname+0x90>
		case (Junio) 					: return (uint8*)"Junio"; break;
    4a2e:	2a e6       	ldi	r18, 0x6A	; 106
    4a30:	32 e4       	ldi	r19, 0x42	; 66
    4a32:	11 c0       	rjmp	.+34     	; 0x4a56 <Monthname+0x90>
		case (Julio) 					: return (uint8*)"Julio"; break;
    4a34:	20 e7       	ldi	r18, 0x70	; 112
    4a36:	32 e4       	ldi	r19, 0x42	; 66
    4a38:	0e c0       	rjmp	.+28     	; 0x4a56 <Monthname+0x90>
		case (Agosto) 					: return (uint8*)"Agosto"; break;
    4a3a:	27 e7       	ldi	r18, 0x77	; 119
    4a3c:	32 e4       	ldi	r19, 0x42	; 66
    4a3e:	0b c0       	rjmp	.+22     	; 0x4a56 <Monthname+0x90>
		case (Septiembre) 				: return (uint8*)"Septiembre"; break;
    4a40:	22 e8       	ldi	r18, 0x82	; 130
    4a42:	32 e4       	ldi	r19, 0x42	; 66
    4a44:	08 c0       	rjmp	.+16     	; 0x4a56 <Monthname+0x90>
		case (Octubre) 					: return (uint8*)"Octubre"; break;
    4a46:	2a e8       	ldi	r18, 0x8A	; 138
    4a48:	32 e4       	ldi	r19, 0x42	; 66
    4a4a:	05 c0       	rjmp	.+10     	; 0x4a56 <Monthname+0x90>
		case (Noviembre) 				: return (uint8*)"Noviembre"; break;
    4a4c:	24 e9       	ldi	r18, 0x94	; 148
    4a4e:	32 e4       	ldi	r19, 0x42	; 66
    4a50:	02 c0       	rjmp	.+4      	; 0x4a56 <Monthname+0x90>
		case (Diciembre) 				: return (uint8*)"Diciembre"; break;
    4a52:	2e e9       	ldi	r18, 0x9E	; 158
    4a54:	32 e4       	ldi	r19, 0x42	; 66
		
		default 						: return (uint8*)"invalid month";
	}

  //return (uint8*)"Monthname";  // avoid compiler warning
    4a56:	c9 01       	movw	r24, r18
    4a58:	08 95       	ret

00004a5a <initCard>:

/****************************************************************************************/ 
void initCard(void)
{
 /////////////LED
 DDRE		=	_BV(LED1) | _BV(LED2) | _BV(Reset);				//Salidas
    4a5a:	2c e8       	ldi	r18, 0x8C	; 140
    4a5c:	2d b9       	out	0x0d, r18	; 13
 PORTE		=	_BV(LED1) | _BV(LED2);				                //Condiciones Iniciales							
    4a5e:	84 e8       	ldi	r24, 0x84	; 132
    4a60:	8e b9       	out	0x0e, r24	; 14
 

 DDRB		=	_BV(LED0);
    4a62:	80 e8       	ldi	r24, 0x80	; 128
    4a64:	84 b9       	out	0x04, r24	; 4
 PORTB		=	_BV(LED0);											//Condiciones Iniciales
    4a66:	85 b9       	out	0x05, r24	; 5
 
 //////////////PMDS
 PORTE      &= 	~(_BV(Reset));						                //Mantenido reset
    4a68:	73 98       	cbi	0x0e, 3	; 14
 DDRD		=	_BV(HostSlct1) | _BV(HostSlct2) | _BV(HostSlct3) | _BV(Alarma); // Salidas.
    4a6a:	90 ef       	ldi	r25, 0xF0	; 240
    4a6c:	9a b9       	out	0x0a, r25	; 10
 PORTD		=	_BV(HostSlct1) | _BV(HostSlct2) | _BV(HostSlct3);	//Condiciones Iniciales
    4a6e:	80 e7       	ldi	r24, 0x70	; 112
    4a70:	8b b9       	out	0x0b, r24	; 11

 
 
 DDRG 		= 	_BV(HostCmd) | _BV(HostWrite) | _BV(HostRead); 			// HostCmd,HostWrite,HostRead,Reset Salidas
    4a72:	88 e3       	ldi	r24, 0x38	; 56
    4a74:	83 bb       	out	0x13, r24	; 19
 PORTG		= 	_BV(HostWrite) | _BV(HostRead);							//Condiciones Iniciales
    4a76:	80 e3       	ldi	r24, 0x30	; 48
    4a78:	84 bb       	out	0x14, r24	; 20


 DDRH		=	_BV(USB_EN) | _BV(USB_WRITE) | _BV(USB_READ);		//Salidas
    4a7a:	8c e1       	ldi	r24, 0x1C	; 28
    4a7c:	80 93 01 01 	sts	0x0101, r24
 PORTH		=	_BV(USB_EN) | _BV(USB_WRITE) | _BV(USB_READ);   	//Condiciones Iniciales
    4a80:	80 93 02 01 	sts	0x0102, r24
 
 
  
  
  //Mantener el motor apadado y coloca resistencias de Pull up en FINDER E FINDIZQ
  PORTF     =	_BV(DER) | _BV(IZQ) | _BV(FINDER) | _BV(FINIZQ);
    4a84:	83 ec       	ldi	r24, 0xC3	; 195
    4a86:	81 bb       	out	0x11, r24	; 17
  
   //Solo Salidas DER y IQZ 
  DDRF		=	_BV(DER) | _BV(IZQ);
    4a88:	83 e0       	ldi	r24, 0x03	; 3
    4a8a:	80 bb       	out	0x10, r24	; 16
/****************************** oTROS***************************************/

/** La interrupcion 3 (INT3) se activa en flanco de SUBIDA y la Interrupcion 2 (INT2)
	 se activa en flanco de Subida.*/

	EICRA		=	_BV(ISC31) | _BV(ISC30) | _BV(ISC21) | _BV(ISC20);
    4a8c:	90 93 69 00 	sts	0x0069, r25

/** Las interrupciones INT4 E INT5 ( PMD1 y PMD2) se activan en flanco de Bajada.*/	
	
	EICRB		=	_BV(ISC51) | _BV(ISC41);
    4a90:	8a e0       	ldi	r24, 0x0A	; 10
    4a92:	80 93 6a 00 	sts	0x006A, r24
/**Habilito la Interrupcion Externa 2 (interrupcin Botn Parada Emergencia)
			la Interrupcion Externa 3 (interrupcin USB)
			la Interrupcion Externa 4 (interrupcin PMD1)
			la Interrupcion Externa 5 (interrupcin PMD2)*/
		
	EIMSK		=	_BV(INT5) | _BV(INT4) | _BV(INT3) | _BV(INT2);
    4a96:	8c e3       	ldi	r24, 0x3C	; 60
    4a98:	8d bb       	out	0x1d, r24	; 29

/** Habilito la Memoria RAM Externa con las siguientes caractersticas:
	-Toda la Memoria Ocupa un solo sector: SRL2, SRL1, y SRL0 estn en Cero.
	-con dos ciclos de espera: SRW11 y SRW10 bits estn en ALTO.  */
	
	XMCRA		=	_BV(SRE) | _BV(SRW11) | _BV(SRW10);
    4a9a:	20 93 74 00 	sts	0x0074, r18

/** Timer/ Counter 1 Interrrupt Mask Register. Activo el Bit Timer/Counter1, Overflow
    interrupt Enable*/


	TIMSK1		=	_BV(TOIE1);	
    4a9e:	91 e0       	ldi	r25, 0x01	; 1
    4aa0:	90 93 6f 00 	sts	0x006F, r25
	
/** Modo de Operacion Normal, con un prescaler de CLK/1024 osea que trabaja con un reloj 
de 7.8125Khz por lo tanto cada 0,000128 seg aumenta se desborda cada 8,38848 seg*/	

	TCCR1B 		=	_BV(CS12) | _BV(CS10);
    4aa4:	85 e0       	ldi	r24, 0x05	; 5
    4aa6:	80 93 81 00 	sts	0x0081, r24

/** Timer/ Counter 3 Interrrupt Mask Register. Activo el Bit Timer/Counter3, Overflow
    interrupt Enable*/


	TIMSK3		=	_BV(TOIE3);	
    4aaa:	90 93 71 00 	sts	0x0071, r25
	
/** Modo de Operacion Normal, con un prescaler de CLK/1024*/	

	TCCR3B 		=	_BV(CS32) | _BV(CS30);
    4aae:	80 93 91 00 	sts	0x0091, r24
	
	

 }
    4ab2:	08 95       	ret

00004ab4 <TIM16_ReadTCNTn>:
{
	unsigned char sreg;
	unsigned int i;
	
	/* Save global interrupt flag */
	sreg = SREG;
    4ab4:	8f b7       	in	r24, 0x3f	; 63
	/* Disable interrupts */
	cli();
    4ab6:	f8 94       	cli
	/* Read TCNTn into i */
	i = TCNT1;
    4ab8:	e4 e8       	ldi	r30, 0x84	; 132
    4aba:	f0 e0       	ldi	r31, 0x00	; 0
    4abc:	20 81       	ld	r18, Z
    4abe:	31 81       	ldd	r19, Z+1	; 0x01
	TCNT1=0;
    4ac0:	11 82       	std	Z+1, r1	; 0x01
    4ac2:	10 82       	st	Z, r1
	/* Restore global interrupt flag */
	SREG = sreg;
    4ac4:	8f bf       	out	0x3f, r24	; 63
	sei();
    4ac6:	78 94       	sei
	return i;
}
    4ac8:	c9 01       	movw	r24, r18
    4aca:	08 95       	ret

00004acc <writePMDcommand>:
/*-----------------------Funciones Interface uControlador-PMDs--------------------------*/

void writePMDcommand(PMDuint16 PMDChipSet, PMDuint16 dataword)
{

	if(PMDChipSet==PMDChipSet1)
    4acc:	00 97       	sbiw	r24, 0x00	; 0
    4ace:	d9 f4       	brne	.+54     	; 0x4b06 <writePMDcommand+0x3a>
	{
		PORTD			|=	_BV(HostSlct1);
    4ad0:	5c 9a       	sbi	0x0b, 4	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    4ad2:	84 b3       	in	r24, 0x14	; 20
    4ad4:	80 63       	ori	r24, 0x30	; 48
    4ad6:	84 bb       	out	0x14, r24	; 20
	
		HostControl 	&= 	~(_BV(HostCmd));						//HostCmd Bajo, Condiciones iniciales
    4ad8:	a3 98       	cbi	0x14, 3	; 20
		Control_Port	=	0xFF;	  								//Coloco como salida el puerto 
    4ada:	8f ef       	ldi	r24, 0xFF	; 255
    4adc:	80 93 04 01 	sts	0x0104, r24
		PORTD		 	&= 	~(_BV(HostSlct1));						//Selecciono el Chipset 
    4ae0:	5c 98       	cbi	0x0b, 4	; 11
		HostControl 	|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto
    4ae2:	a3 9a       	sbi	0x14, 3	; 20
	
		HostData		= 	(PMDuint8)((dataword>>8) & 0xFF);		//Envo por el puerto de datos el byte mas 
    4ae4:	70 93 05 01 	sts	0x0105, r23
																	//significativo  
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado.
    4ae8:	a4 98       	cbi	0x14, 4	; 20
    4aea:	85 e0       	ldi	r24, 0x05	; 5
    4aec:	98 2f       	mov	r25, r24
    4aee:	9a 95       	dec	r25
    4af0:	f1 f7       	brne	.-4      	; 0x4aee <writePMDcommand+0x22>
																	//Nota: trabajando a una velocidad de 8MHz se tiene 
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							//que el ciclo de cada instruccion del uC es de 125ns
    4af2:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura. 
		HostData		=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto De datos el Byte menos signiicativo 
    4af4:	60 93 05 01 	sts	0x0105, r22
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    4af8:	a4 98       	cbi	0x14, 4	; 20
    4afa:	8a 95       	dec	r24
    4afc:	f1 f7       	brne	.-4      	; 0x4afa <writePMDcommand+0x2e>
																	//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    4afe:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura.  
		
		HostControl 	&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel bajo
    4b00:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 	|= 	_BV(HostSlct1);							//Deselecciono el Chipset. NOta Para la version 
    4b02:	5c 9a       	sbi	0x0b, 4	; 11
    4b04:	08 95       	ret
																	//con varios chipset se debe utilizarel puerto con una
																	// mascara para selecion y deseleccion respectivamente
	}
	
	if(PMDChipSet==PMDChipSet2)
    4b06:	81 30       	cpi	r24, 0x01	; 1
    4b08:	91 05       	cpc	r25, r1
    4b0a:	d9 f4       	brne	.+54     	; 0x4b42 <writePMDcommand+0x76>
	{
		PORTD			|=	_BV(HostSlct2);
    4b0c:	5d 9a       	sbi	0x0b, 5	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    4b0e:	84 b3       	in	r24, 0x14	; 20
    4b10:	80 63       	ori	r24, 0x30	; 48
    4b12:	84 bb       	out	0x14, r24	; 20
	
		HostControl 	&= 	~(_BV(HostCmd));						//HostCmd Bajo, Condiciones iniciales
    4b14:	a3 98       	cbi	0x14, 3	; 20
		Control_Port	=	0xFF;	  								//Coloco como salida el puerto 
    4b16:	8f ef       	ldi	r24, 0xFF	; 255
    4b18:	80 93 04 01 	sts	0x0104, r24
		PORTD		 	&= 	~(_BV(HostSlct2));						//Selecciono el Chipset 
    4b1c:	5d 98       	cbi	0x0b, 5	; 11
		HostControl 	|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto
    4b1e:	a3 9a       	sbi	0x14, 3	; 20
	
		HostData		= 	(PMDuint8)((dataword>>8) & 0xFF);		//Envo por el puerto de datos el byte mas 
    4b20:	70 93 05 01 	sts	0x0105, r23
																	//significativo  
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado.
    4b24:	a4 98       	cbi	0x14, 4	; 20
    4b26:	85 e0       	ldi	r24, 0x05	; 5
    4b28:	98 2f       	mov	r25, r24
    4b2a:	9a 95       	dec	r25
    4b2c:	f1 f7       	brne	.-4      	; 0x4b2a <writePMDcommand+0x5e>
																	//Nota: trabajando a una velocidad de 8MHz se tiene 
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							//que el ciclo de cada instruccion del uC es de 125ns
    4b2e:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura. 
		HostData		=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto De datos el Byte menos signiicativo 
    4b30:	60 93 05 01 	sts	0x0105, r22
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    4b34:	a4 98       	cbi	0x14, 4	; 20
    4b36:	8a 95       	dec	r24
    4b38:	f1 f7       	brne	.-4      	; 0x4b36 <writePMDcommand+0x6a>
																	//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    4b3a:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura.  
		
		HostControl 	&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel bajo
    4b3c:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 	|= 	_BV(HostSlct2);							//Deselecciono el Chipset. NOta Para la version 
    4b3e:	5d 9a       	sbi	0x0b, 5	; 11
    4b40:	08 95       	ret
																	//con varios chipset se debe utilizarel puerto con una
																	// mascara para selecion y deseleccion respectivamente
	}	
	
	if(PMDChipSet==PMDChipSet3)
    4b42:	02 97       	sbiw	r24, 0x02	; 2
    4b44:	d1 f4       	brne	.+52     	; 0x4b7a <writePMDcommand+0xae>
	{
		PORTD			|=	_BV(HostSlct3);
    4b46:	5e 9a       	sbi	0x0b, 6	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    4b48:	84 b3       	in	r24, 0x14	; 20
    4b4a:	80 63       	ori	r24, 0x30	; 48
    4b4c:	84 bb       	out	0x14, r24	; 20
	
		HostControl 	&= 	~(_BV(HostCmd));						//HostCmd Bajo, Condiciones iniciales
    4b4e:	a3 98       	cbi	0x14, 3	; 20
		Control_Port	=	0xFF;	  								//Coloco como salida el puerto 
    4b50:	8f ef       	ldi	r24, 0xFF	; 255
    4b52:	80 93 04 01 	sts	0x0104, r24
		PORTD		 	&= 	~(_BV(HostSlct3));						//Selecciono el Chipset 
    4b56:	5e 98       	cbi	0x0b, 6	; 11
		HostControl 	|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto
    4b58:	a3 9a       	sbi	0x14, 3	; 20
	
		HostData		= 	(PMDuint8)((dataword>>8) & 0xFF);		//Envo por el puerto de datos el byte mas 
    4b5a:	70 93 05 01 	sts	0x0105, r23
																	//significativo  
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado.
    4b5e:	a4 98       	cbi	0x14, 4	; 20
    4b60:	85 e0       	ldi	r24, 0x05	; 5
    4b62:	98 2f       	mov	r25, r24
    4b64:	9a 95       	dec	r25
    4b66:	f1 f7       	brne	.-4      	; 0x4b64 <writePMDcommand+0x98>
																	//Nota: trabajando a una velocidad de 8MHz se tiene 
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							//que el ciclo de cada instruccion del uC es de 125ns
    4b68:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura. 
		HostData		=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto De datos el Byte menos signiicativo 
    4b6a:	60 93 05 01 	sts	0x0105, r22
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    4b6e:	a4 98       	cbi	0x14, 4	; 20
    4b70:	8a 95       	dec	r24
    4b72:	f1 f7       	brne	.-4      	; 0x4b70 <writePMDcommand+0xa4>
																	//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    4b74:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura.  
		
		HostControl 	&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel bajo
    4b76:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 	|= 	_BV(HostSlct3);							//Deselecciono el Chipset. NOta Para la version 
    4b78:	5e 9a       	sbi	0x0b, 6	; 11
    4b7a:	08 95       	ret

00004b7c <writePMDdata>:
}
/*----------------------------------------------------------------------------------------------------*/
void writePMDdata(PMDuint16 PMDChipSet, PMDuint16 dataword)
{

	if(PMDChipSet==PMDChipSet1)
    4b7c:	00 97       	sbiw	r24, 0x00	; 0
    4b7e:	d9 f4       	brne	.+54     	; 0x4bb6 <writePMDdata+0x3a>
	{	
		PORTD				|=	_BV(HostSlct1);
    4b80:	5c 9a       	sbi	0x0b, 4	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    4b82:	84 b3       	in	r24, 0x14	; 20
    4b84:	80 63       	ori	r24, 0x30	; 48
    4b86:	84 bb       	out	0x14, r24	; 20

		Control_Port		=	0xFF;			  						//Coloco como salida el puerto 
    4b88:	8f ef       	ldi	r24, 0xFF	; 255
    4b8a:	80 93 04 01 	sts	0x0104, r24

		HostControl 		|= 	_BV(HostCmd);							//HostCmd Alto Condiciones iniciales
    4b8e:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct1));						//Selecciono el Chipset 
    4b90:	5c 98       	cbi	0x0b, 4	; 11
		HostControl 		&= 	~(_BV(HostCmd));			 			//Coloco la Seal HostCmd a Nivel bajo
    4b92:	a3 98       	cbi	0x14, 3	; 20
		HostData			= 	(PMDuint8)((dataword>>8)&0xFF);		//Envo por el puerto de datos el byte mas significativo  
    4b94:	70 93 05 01 	sts	0x0105, r23
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    4b98:	a4 98       	cbi	0x14, 4	; 20
    4b9a:	85 e0       	ldi	r24, 0x05	; 5
    4b9c:	98 2f       	mov	r25, r24
    4b9e:	9a 95       	dec	r25
    4ba0:	f1 f7       	brne	.-4      	; 0x4b9e <writePMDdata+0x22>
																		//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    4ba2:	a4 9a       	sbi	0x14, 4	; 20
																		// que es suficiente para relaizar el ciclo de escritura. 
		HostData			=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto e datos el Byte menos signiicativo 
    4ba4:	60 93 05 01 	sts	0x0105, r22
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. Nota: trabajando 
    4ba8:	a4 98       	cbi	0x14, 4	; 20
    4baa:	8a 95       	dec	r24
    4bac:	f1 f7       	brne	.-4      	; 0x4baa <writePMDdata+0x2e>
																		//a una velocidad de 8MHz se tiene que el ciclo de cada 
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							//instruccion del uC es de 125ns que es suficiente para
    4bae:	a4 9a       	sbi	0x14, 4	; 20
																		// relaizar el ciclo de escritura.  
	
		HostControl 		|= 	_BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    4bb0:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct1); 						//Deselecciono el Chipset. NOta Para la version con
    4bb2:	5c 9a       	sbi	0x0b, 4	; 11
    4bb4:	08 95       	ret
																		//varios chipset se debe utilizarel puerto con una mascara
																		// para sellecion y deseleccion respectivamente
	}

	if(PMDChipSet==PMDChipSet2)
    4bb6:	81 30       	cpi	r24, 0x01	; 1
    4bb8:	91 05       	cpc	r25, r1
    4bba:	d9 f4       	brne	.+54     	; 0x4bf2 <writePMDdata+0x76>
	{	
		PORTD				|=	_BV(HostSlct2);
    4bbc:	5d 9a       	sbi	0x0b, 5	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    4bbe:	84 b3       	in	r24, 0x14	; 20
    4bc0:	80 63       	ori	r24, 0x30	; 48
    4bc2:	84 bb       	out	0x14, r24	; 20

		Control_Port		=	0xFF;			  						//Coloco como salida el puerto 
    4bc4:	8f ef       	ldi	r24, 0xFF	; 255
    4bc6:	80 93 04 01 	sts	0x0104, r24

		HostControl 		|= 	_BV(HostCmd);							//HostCmd Alto Condiciones iniciales
    4bca:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct2));						//Selecciono el Chipset 
    4bcc:	5d 98       	cbi	0x0b, 5	; 11
		HostControl 		&= 	~(_BV(HostCmd));			 			//Coloco la Seal HostCmd a Nivel bajo
    4bce:	a3 98       	cbi	0x14, 3	; 20
		HostData			= 	(PMDuint8)((dataword>>8)&0xFF);		//Envo por el puerto de datos el byte mas significativo  
    4bd0:	70 93 05 01 	sts	0x0105, r23
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    4bd4:	a4 98       	cbi	0x14, 4	; 20
    4bd6:	85 e0       	ldi	r24, 0x05	; 5
    4bd8:	98 2f       	mov	r25, r24
    4bda:	9a 95       	dec	r25
    4bdc:	f1 f7       	brne	.-4      	; 0x4bda <writePMDdata+0x5e>
																		//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    4bde:	a4 9a       	sbi	0x14, 4	; 20
																		// que es suficiente para relaizar el ciclo de escritura. 
		HostData			=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto e datos el Byte menos signiicativo 
    4be0:	60 93 05 01 	sts	0x0105, r22
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. Nota: trabajando 
    4be4:	a4 98       	cbi	0x14, 4	; 20
    4be6:	8a 95       	dec	r24
    4be8:	f1 f7       	brne	.-4      	; 0x4be6 <writePMDdata+0x6a>
																		//a una velocidad de 8MHz se tiene que el ciclo de cada 
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							//instruccion del uC es de 125ns que es suficiente para
    4bea:	a4 9a       	sbi	0x14, 4	; 20
																		// relaizar el ciclo de escritura.  
	
		HostControl 		|= 	_BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    4bec:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct2); 						//Deselecciono el Chipset. NOta Para la version con
    4bee:	5d 9a       	sbi	0x0b, 5	; 11
    4bf0:	08 95       	ret
																		//varios chipset se debe utilizarel puerto con una mascara
																		// para sellecion y deseleccion respectivamente
	}	

	if(PMDChipSet==PMDChipSet3)
    4bf2:	02 97       	sbiw	r24, 0x02	; 2
    4bf4:	d1 f4       	brne	.+52     	; 0x4c2a <writePMDdata+0xae>
	{	
		PORTD				|=	_BV(HostSlct3);
    4bf6:	5e 9a       	sbi	0x0b, 6	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    4bf8:	84 b3       	in	r24, 0x14	; 20
    4bfa:	80 63       	ori	r24, 0x30	; 48
    4bfc:	84 bb       	out	0x14, r24	; 20

		Control_Port		=	0xFF;			  						//Coloco como salida el puerto 
    4bfe:	8f ef       	ldi	r24, 0xFF	; 255
    4c00:	80 93 04 01 	sts	0x0104, r24

		HostControl 		|= 	_BV(HostCmd);							//HostCmd Alto Condiciones iniciales
    4c04:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct3));						//Selecciono el Chipset 
    4c06:	5e 98       	cbi	0x0b, 6	; 11
		HostControl 		&= 	~(_BV(HostCmd));			 			//Coloco la Seal HostCmd a Nivel bajo
    4c08:	a3 98       	cbi	0x14, 3	; 20
		HostData			= 	(PMDuint8)((dataword>>8)&0xFF);		//Envo por el puerto de datos el byte mas significativo  
    4c0a:	70 93 05 01 	sts	0x0105, r23
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    4c0e:	a4 98       	cbi	0x14, 4	; 20
    4c10:	85 e0       	ldi	r24, 0x05	; 5
    4c12:	98 2f       	mov	r25, r24
    4c14:	9a 95       	dec	r25
    4c16:	f1 f7       	brne	.-4      	; 0x4c14 <writePMDdata+0x98>
																		//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    4c18:	a4 9a       	sbi	0x14, 4	; 20
																		// que es suficiente para relaizar el ciclo de escritura. 
		HostData			=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto e datos el Byte menos signiicativo 
    4c1a:	60 93 05 01 	sts	0x0105, r22
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. Nota: trabajando 
    4c1e:	a4 98       	cbi	0x14, 4	; 20
    4c20:	8a 95       	dec	r24
    4c22:	f1 f7       	brne	.-4      	; 0x4c20 <writePMDdata+0xa4>
																		//a una velocidad de 8MHz se tiene que el ciclo de cada 
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							//instruccion del uC es de 125ns que es suficiente para
    4c24:	a4 9a       	sbi	0x14, 4	; 20
																		// relaizar el ciclo de escritura.  
	
		HostControl 		|= 	_BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    4c26:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct3); 						//Deselecciono el Chipset. NOta Para la version con
    4c28:	5e 9a       	sbi	0x0b, 6	; 11
    4c2a:	08 95       	ret

00004c2c <readPMDdata>:
PMDuint16 readPMDdata(PMDuint16 PMDChipSet)
{
	PMDuint16 i			=	0;
	PMDuint16 j			=	0;

	if(PMDChipSet==PMDChipSet1)
    4c2c:	00 97       	sbiw	r24, 0x00	; 0
    4c2e:	21 f5       	brne	.+72     	; 0x4c78 <readPMDdata+0x4c>
	{
		PORTD			|=	_BV(HostSlct1);
    4c30:	5c 9a       	sbi	0x0b, 4	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);					// Condiciones Iniciales		
    4c32:	84 b3       	in	r24, 0x14	; 20
    4c34:	80 63       	ori	r24, 0x30	; 48
    4c36:	84 bb       	out	0x14, r24	; 20

	


		Control_Port		=	0x00;			  						//Coloco como entrada el puerto 
    4c38:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;									//Resistencias de Pullups ( averiguar mas esto)
    4c3c:	8f ef       	ldi	r24, 0xFF	; 255
    4c3e:	80 93 05 01 	sts	0x0105, r24

		HostControl 		|=	_BV(HostCmd);							//HostCmd Alto. Condiciones Iniciales
    4c42:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct1));						//Selecciono el Chipset 
    4c44:	5c 98       	cbi	0x0b, 4	; 11
		HostControl 		&= 	~(_BV(HostCmd));						//Coloco la Seal HostCmd a Nivel bajo 
    4c46:	a3 98       	cbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4c48:	a5 98       	cbi	0x14, 5	; 20
    4c4a:	95 e0       	ldi	r25, 0x05	; 5
    4c4c:	89 2f       	mov	r24, r25
    4c4e:	8a 95       	dec	r24
    4c50:	f1 f7       	brne	.-4      	; 0x4c4e <readPMDdata+0x22>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los
    4c52:	80 91 03 01 	lds	r24, 0x0103
    4c56:	58 2f       	mov	r21, r24
    4c58:	40 e0       	ldi	r20, 0x00	; 0
																		//datos ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    4c5a:	a5 9a       	sbi	0x14, 5	; 20
    4c5c:	89 2f       	mov	r24, r25
    4c5e:	8a 95       	dec	r24
    4c60:	f1 f7       	brne	.-4      	; 0x4c5e <readPMDdata+0x32>
		_delay_us(2);

		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4c62:	a5 98       	cbi	0x14, 5	; 20
    4c64:	9a 95       	dec	r25
    4c66:	f1 f7       	brne	.-4      	; 0x4c64 <readPMDdata+0x38>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    4c68:	80 91 03 01 	lds	r24, 0x0103
    4c6c:	28 2f       	mov	r18, r24
    4c6e:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    4c70:	a5 9a       	sbi	0x14, 5	; 20

	
		HostControl 		|= _BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    4c72:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= _BV(HostSlct1); 							//Deselecciono el Chipset.
    4c74:	5c 9a       	sbi	0x0b, 4	; 11
    4c76:	51 c0       	rjmp	.+162    	; 0x4d1a <readPMDdata+0xee>
	
	
		
	}

	if(PMDChipSet==PMDChipSet2)
    4c78:	81 30       	cpi	r24, 0x01	; 1
    4c7a:	91 05       	cpc	r25, r1
    4c7c:	21 f5       	brne	.+72     	; 0x4cc6 <readPMDdata+0x9a>
	{
		PORTD			|=	_BV(HostSlct2);
    4c7e:	5d 9a       	sbi	0x0b, 5	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);					// Condiciones Iniciales		
    4c80:	84 b3       	in	r24, 0x14	; 20
    4c82:	80 63       	ori	r24, 0x30	; 48
    4c84:	84 bb       	out	0x14, r24	; 20

	


		Control_Port		=	0x00;			  						//Coloco como entrada el puerto 
    4c86:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;									//Resistencias de Pullups ( averiguar mas esto)
    4c8a:	8f ef       	ldi	r24, 0xFF	; 255
    4c8c:	80 93 05 01 	sts	0x0105, r24

		HostControl 		|=	_BV(HostCmd);							//HostCmd Alto. Condiciones Iniciales
    4c90:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct2));						//Selecciono el Chipset 
    4c92:	5d 98       	cbi	0x0b, 5	; 11
		HostControl 		&= 	~(_BV(HostCmd));						//Coloco la Seal HostCmd a Nivel bajo 
    4c94:	a3 98       	cbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4c96:	a5 98       	cbi	0x14, 5	; 20
    4c98:	95 e0       	ldi	r25, 0x05	; 5
    4c9a:	89 2f       	mov	r24, r25
    4c9c:	8a 95       	dec	r24
    4c9e:	f1 f7       	brne	.-4      	; 0x4c9c <readPMDdata+0x70>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los
    4ca0:	80 91 03 01 	lds	r24, 0x0103
    4ca4:	58 2f       	mov	r21, r24
    4ca6:	40 e0       	ldi	r20, 0x00	; 0
																		//datos ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    4ca8:	a5 9a       	sbi	0x14, 5	; 20
    4caa:	89 2f       	mov	r24, r25
    4cac:	8a 95       	dec	r24
    4cae:	f1 f7       	brne	.-4      	; 0x4cac <readPMDdata+0x80>
		_delay_us(2);

		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4cb0:	a5 98       	cbi	0x14, 5	; 20
    4cb2:	9a 95       	dec	r25
    4cb4:	f1 f7       	brne	.-4      	; 0x4cb2 <readPMDdata+0x86>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    4cb6:	80 91 03 01 	lds	r24, 0x0103
    4cba:	28 2f       	mov	r18, r24
    4cbc:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    4cbe:	a5 9a       	sbi	0x14, 5	; 20

	
		HostControl 		|= _BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    4cc0:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= _BV(HostSlct2); 							//Deselecciono el Chipset.
    4cc2:	5d 9a       	sbi	0x0b, 5	; 11
    4cc4:	2a c0       	rjmp	.+84     	; 0x4d1a <readPMDdata+0xee>
	
	
		
	}
	
	if(PMDChipSet==PMDChipSet3)
    4cc6:	02 97       	sbiw	r24, 0x02	; 2
    4cc8:	29 f0       	breq	.+10     	; 0x4cd4 <readPMDdata+0xa8>
    4cca:	40 e0       	ldi	r20, 0x00	; 0
    4ccc:	50 e0       	ldi	r21, 0x00	; 0
    4cce:	20 e0       	ldi	r18, 0x00	; 0
    4cd0:	30 e0       	ldi	r19, 0x00	; 0
    4cd2:	23 c0       	rjmp	.+70     	; 0x4d1a <readPMDdata+0xee>
	{
		PORTD			|=	_BV(HostSlct3);
    4cd4:	5e 9a       	sbi	0x0b, 6	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);					// Condiciones Iniciales		
    4cd6:	84 b3       	in	r24, 0x14	; 20
    4cd8:	80 63       	ori	r24, 0x30	; 48
    4cda:	84 bb       	out	0x14, r24	; 20

	


		Control_Port		=	0x00;			  						//Coloco como entrada el puerto 
    4cdc:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;									//Resistencias de Pullups ( averiguar mas esto)
    4ce0:	8f ef       	ldi	r24, 0xFF	; 255
    4ce2:	80 93 05 01 	sts	0x0105, r24

		HostControl 		|=	_BV(HostCmd);							//HostCmd Alto. Condiciones Iniciales
    4ce6:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct3));						//Selecciono el Chipset 
    4ce8:	5e 98       	cbi	0x0b, 6	; 11
		HostControl 		&= 	~(_BV(HostCmd));						//Coloco la Seal HostCmd a Nivel bajo 
    4cea:	a3 98       	cbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4cec:	a5 98       	cbi	0x14, 5	; 20
    4cee:	95 e0       	ldi	r25, 0x05	; 5
    4cf0:	89 2f       	mov	r24, r25
    4cf2:	8a 95       	dec	r24
    4cf4:	f1 f7       	brne	.-4      	; 0x4cf2 <readPMDdata+0xc6>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los
    4cf6:	80 91 03 01 	lds	r24, 0x0103
    4cfa:	58 2f       	mov	r21, r24
    4cfc:	40 e0       	ldi	r20, 0x00	; 0
																		//datos ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    4cfe:	a5 9a       	sbi	0x14, 5	; 20
    4d00:	89 2f       	mov	r24, r25
    4d02:	8a 95       	dec	r24
    4d04:	f1 f7       	brne	.-4      	; 0x4d02 <readPMDdata+0xd6>
		_delay_us(2);

		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4d06:	a5 98       	cbi	0x14, 5	; 20
    4d08:	9a 95       	dec	r25
    4d0a:	f1 f7       	brne	.-4      	; 0x4d08 <readPMDdata+0xdc>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    4d0c:	80 91 03 01 	lds	r24, 0x0103
    4d10:	28 2f       	mov	r18, r24
    4d12:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    4d14:	a5 9a       	sbi	0x14, 5	; 20

	
		HostControl 		|= _BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    4d16:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= _BV(HostSlct3); 							//Deselecciono el Chipset.
    4d18:	5e 9a       	sbi	0x0b, 6	; 11
    4d1a:	24 2b       	or	r18, r20
    4d1c:	35 2b       	or	r19, r21
		
	}
	
	
	return i | j;
}  
    4d1e:	c9 01       	movw	r24, r18
    4d20:	08 95       	ret

00004d22 <readPMDstatus>:
PMDuint16 readPMDstatus(PMDuint16 PMDChipSet)
{
	PMDuint16 i			=	0;
	PMDuint16 j			=	0;
	
	if(PMDChipSet==PMDChipSet1)
    4d22:	00 97       	sbiw	r24, 0x00	; 0
    4d24:	21 f5       	brne	.+72     	; 0x4d6e <readPMDstatus+0x4c>
	{
		PORTD				|=	_BV(HostSlct1);
    4d26:	5c 9a       	sbi	0x0b, 4	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    4d28:	84 b3       	in	r24, 0x14	; 20
    4d2a:	80 63       	ori	r24, 0x30	; 48
    4d2c:	84 bb       	out	0x14, r24	; 20
	
		


		Control_Port		=	0x00;									//Coloco como entrada el puerto A
    4d2e:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;   								//Resistencias de Pullups ( averiguar mas esto)
    4d32:	8f ef       	ldi	r24, 0xFF	; 255
    4d34:	80 93 05 01 	sts	0x0105, r24
	
		HostControl 		&= 	~(_BV(HostCmd));						//HostCmd Bajo.Condiciones Iniciales
    4d38:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct1));						//Selecciono el Chipset 
    4d3a:	5c 98       	cbi	0x0b, 4	; 11
		HostControl 		|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto 
    4d3c:	a3 9a       	sbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4d3e:	a5 98       	cbi	0x14, 5	; 20
    4d40:	95 e0       	ldi	r25, 0x05	; 5
    4d42:	89 2f       	mov	r24, r25
    4d44:	8a 95       	dec	r24
    4d46:	f1 f7       	brne	.-4      	; 0x4d44 <readPMDstatus+0x22>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los datos
    4d48:	80 91 03 01 	lds	r24, 0x0103
    4d4c:	58 2f       	mov	r21, r24
    4d4e:	40 e0       	ldi	r20, 0x00	; 0
																		//ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    4d50:	a5 9a       	sbi	0x14, 5	; 20
    4d52:	9a 95       	dec	r25
    4d54:	f1 f7       	brne	.-4      	; 0x4d52 <readPMDstatus+0x30>
		_delay_us(2);
		
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4d56:	a5 98       	cbi	0x14, 5	; 20
    4d58:	82 e0       	ldi	r24, 0x02	; 2
    4d5a:	8a 95       	dec	r24
    4d5c:	f1 f7       	brne	.-4      	; 0x4d5a <readPMDstatus+0x38>
		_delay_us(1);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    4d5e:	80 91 03 01 	lds	r24, 0x0103
    4d62:	28 2f       	mov	r18, r24
    4d64:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead  
    4d66:	a5 9a       	sbi	0x14, 5	; 20
	
	
		HostControl 		&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel Bajo  
    4d68:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct1); 						//Deselecciono el Chipset
    4d6a:	5c 9a       	sbi	0x0b, 4	; 11
    4d6c:	51 c0       	rjmp	.+162    	; 0x4e10 <readPMDstatus+0xee>

		
	}
	
		if(PMDChipSet==PMDChipSet2)
    4d6e:	81 30       	cpi	r24, 0x01	; 1
    4d70:	91 05       	cpc	r25, r1
    4d72:	21 f5       	brne	.+72     	; 0x4dbc <readPMDstatus+0x9a>
	{
		PORTD				|=	_BV(HostSlct2);
    4d74:	5d 9a       	sbi	0x0b, 5	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    4d76:	84 b3       	in	r24, 0x14	; 20
    4d78:	80 63       	ori	r24, 0x30	; 48
    4d7a:	84 bb       	out	0x14, r24	; 20
	
		


		Control_Port		=	0x00;									//Coloco como entrada el puerto A
    4d7c:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;   								//Resistencias de Pullups ( averiguar mas esto)
    4d80:	8f ef       	ldi	r24, 0xFF	; 255
    4d82:	80 93 05 01 	sts	0x0105, r24
	
		HostControl 		&= 	~(_BV(HostCmd));						//HostCmd Bajo.Condiciones Iniciales
    4d86:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct2));						//Selecciono el Chipset 
    4d88:	5d 98       	cbi	0x0b, 5	; 11
		HostControl 		|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto 
    4d8a:	a3 9a       	sbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4d8c:	a5 98       	cbi	0x14, 5	; 20
    4d8e:	95 e0       	ldi	r25, 0x05	; 5
    4d90:	89 2f       	mov	r24, r25
    4d92:	8a 95       	dec	r24
    4d94:	f1 f7       	brne	.-4      	; 0x4d92 <readPMDstatus+0x70>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los datos
    4d96:	80 91 03 01 	lds	r24, 0x0103
    4d9a:	58 2f       	mov	r21, r24
    4d9c:	40 e0       	ldi	r20, 0x00	; 0
																		//ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    4d9e:	a5 9a       	sbi	0x14, 5	; 20
    4da0:	9a 95       	dec	r25
    4da2:	f1 f7       	brne	.-4      	; 0x4da0 <readPMDstatus+0x7e>
		_delay_us(2);
		
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4da4:	a5 98       	cbi	0x14, 5	; 20
    4da6:	82 e0       	ldi	r24, 0x02	; 2
    4da8:	8a 95       	dec	r24
    4daa:	f1 f7       	brne	.-4      	; 0x4da8 <readPMDstatus+0x86>
		_delay_us(1);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    4dac:	80 91 03 01 	lds	r24, 0x0103
    4db0:	28 2f       	mov	r18, r24
    4db2:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead  
    4db4:	a5 9a       	sbi	0x14, 5	; 20
	
	
		HostControl 		&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel Bajo  
    4db6:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct2); 						//Deselecciono el Chipset
    4db8:	5d 9a       	sbi	0x0b, 5	; 11
    4dba:	2a c0       	rjmp	.+84     	; 0x4e10 <readPMDstatus+0xee>

		
	}

	if(PMDChipSet==PMDChipSet3)
    4dbc:	02 97       	sbiw	r24, 0x02	; 2
    4dbe:	29 f0       	breq	.+10     	; 0x4dca <readPMDstatus+0xa8>
    4dc0:	40 e0       	ldi	r20, 0x00	; 0
    4dc2:	50 e0       	ldi	r21, 0x00	; 0
    4dc4:	20 e0       	ldi	r18, 0x00	; 0
    4dc6:	30 e0       	ldi	r19, 0x00	; 0
    4dc8:	23 c0       	rjmp	.+70     	; 0x4e10 <readPMDstatus+0xee>
	{
		PORTD				|=	_BV(HostSlct3);
    4dca:	5e 9a       	sbi	0x0b, 6	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    4dcc:	84 b3       	in	r24, 0x14	; 20
    4dce:	80 63       	ori	r24, 0x30	; 48
    4dd0:	84 bb       	out	0x14, r24	; 20
	
		


		Control_Port		=	0x00;									//Coloco como entrada el puerto A
    4dd2:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;   								//Resistencias de Pullups ( averiguar mas esto)
    4dd6:	8f ef       	ldi	r24, 0xFF	; 255
    4dd8:	80 93 05 01 	sts	0x0105, r24
	
		HostControl 		&= 	~(_BV(HostCmd));						//HostCmd Bajo.Condiciones Iniciales
    4ddc:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct3));						//Selecciono el Chipset 
    4dde:	5e 98       	cbi	0x0b, 6	; 11
		HostControl 		|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto 
    4de0:	a3 9a       	sbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4de2:	a5 98       	cbi	0x14, 5	; 20
    4de4:	95 e0       	ldi	r25, 0x05	; 5
    4de6:	89 2f       	mov	r24, r25
    4de8:	8a 95       	dec	r24
    4dea:	f1 f7       	brne	.-4      	; 0x4de8 <readPMDstatus+0xc6>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los datos
    4dec:	80 91 03 01 	lds	r24, 0x0103
    4df0:	58 2f       	mov	r21, r24
    4df2:	40 e0       	ldi	r20, 0x00	; 0
																		//ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    4df4:	a5 9a       	sbi	0x14, 5	; 20
    4df6:	9a 95       	dec	r25
    4df8:	f1 f7       	brne	.-4      	; 0x4df6 <readPMDstatus+0xd4>
		_delay_us(2);
		
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    4dfa:	a5 98       	cbi	0x14, 5	; 20
    4dfc:	82 e0       	ldi	r24, 0x02	; 2
    4dfe:	8a 95       	dec	r24
    4e00:	f1 f7       	brne	.-4      	; 0x4dfe <readPMDstatus+0xdc>
		_delay_us(1);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    4e02:	80 91 03 01 	lds	r24, 0x0103
    4e06:	28 2f       	mov	r18, r24
    4e08:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead  
    4e0a:	a5 9a       	sbi	0x14, 5	; 20
	
	
		HostControl 		&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel Bajo  
    4e0c:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct3); 						//Deselecciono el Chipset
    4e0e:	5e 9a       	sbi	0x0b, 6	; 11
    4e10:	24 2b       	or	r18, r20
    4e12:	35 2b       	or	r19, r21
		
	}
	

		return i | j;
}
    4e14:	c9 01       	movw	r24, r18
    4e16:	08 95       	ret

00004e18 <writePMDreset>:
/*----------------------------------------------------------------------------------------------------*/
void writePMDreset(void)  
{
	PORTE 	|= _BV(Reset);												//reset alto
    4e18:	73 9a       	sbi	0x0e, 3	; 14
	PORTE 	&= ~(_BV(Reset));											//bajo reset
    4e1a:	73 98       	cbi	0x0e, 3	; 14
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4e1c:	80 e9       	ldi	r24, 0x90	; 144
    4e1e:	91 e0       	ldi	r25, 0x01	; 1
    4e20:	01 97       	sbiw	r24, 0x01	; 1
    4e22:	f1 f7       	brne	.-4      	; 0x4e20 <writePMDreset+0x8>
	_delay_us(200);
	PORTE 	|= _BV(Reset);												//reset alto
    4e24:	73 9a       	sbi	0x0e, 3	; 14
    4e26:	80 e9       	ldi	r24, 0x90	; 144
    4e28:	91 e0       	ldi	r25, 0x01	; 1
    4e2a:	28 ec       	ldi	r18, 0xC8	; 200
    4e2c:	30 e0       	ldi	r19, 0x00	; 0
    4e2e:	f9 01       	movw	r30, r18
    4e30:	31 97       	sbiw	r30, 0x01	; 1
    4e32:	f1 f7       	brne	.-4      	; 0x4e30 <writePMDreset+0x18>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4e34:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4e36:	d9 f7       	brne	.-10     	; 0x4e2e <writePMDreset+0x16>
	_delay_ms(40);                     									//TIEMPO TOMADO DE C_MOTION ORIGINAL	 
	
}
    4e38:	08 95       	ret

00004e3a <GetAxissetting>:
	
	return Diferentes;
}
/**********************************************************************************************************************/
void GetAxissetting(uint8* TXAxissetting)
{
    4e3a:	ac 01       	movw	r20, r24
    4e3c:	20 e0       	ldi	r18, 0x00	; 0
    4e3e:	30 e0       	ldi	r19, 0x00	; 0
	    
		offset=Buffersize*Axis;
		#ifdef DEBUGSETUP
		printf("GethAxissetting=> Actualizando Axis %d con offset = %d\n",Axis,offset);
		#endif	
		pdata=(uint8*)&hAxis[Axis].axisSettings;
    4e40:	f9 01       	movw	r30, r18
    4e42:	ee 0f       	add	r30, r30
    4e44:	ff 1f       	adc	r31, r31
    4e46:	e2 0f       	add	r30, r18
    4e48:	f3 1f       	adc	r31, r19
    4e4a:	85 e0       	ldi	r24, 0x05	; 5
    4e4c:	ee 0f       	add	r30, r30
    4e4e:	ff 1f       	adc	r31, r31
    4e50:	8a 95       	dec	r24
    4e52:	e1 f7       	brne	.-8      	; 0x4e4c <GetAxissetting+0x12>
    4e54:	e8 58       	subi	r30, 0x88	; 136
    4e56:	f2 48       	sbci	r31, 0x82	; 130
    4e58:	da 01       	movw	r26, r20
		fin=Buffersize+offset;
		for(i=offset;i<fin;i++) 
    4e5a:	bf 01       	movw	r22, r30
    4e5c:	6c 5b       	subi	r22, 0xBC	; 188
    4e5e:	7f 4f       	sbci	r23, 0xFF	; 255
    4e60:	02 c0       	rjmp	.+4      	; 0x4e66 <GetAxissetting+0x2c>
			TXAxissetting[i]=pdata[i-offset];  //desde pdata[0] hasta pdata[buffersize]
    4e62:	81 91       	ld	r24, Z+
    4e64:	8d 93       	st	X+, r24
		#ifdef DEBUGSETUP
		printf("GethAxissetting=> Actualizando Axis %d con offset = %d\n",Axis,offset);
		#endif	
		pdata=(uint8*)&hAxis[Axis].axisSettings;
		fin=Buffersize+offset;
		for(i=offset;i<fin;i++) 
    4e66:	e6 17       	cp	r30, r22
    4e68:	f7 07       	cpc	r31, r23
    4e6a:	d9 f7       	brne	.-10     	; 0x4e62 <GetAxissetting+0x28>
	
	/*Obtengo el apuntador al primer dato, datos secuenciales, pero no son entre Axis*/
    
	Buffersize=sizeof(tAxisSettings);
	
    for(Axis=0;Axis<DOF;Axis++) 
    4e6c:	2f 5f       	subi	r18, 0xFF	; 255
    4e6e:	3f 4f       	sbci	r19, 0xFF	; 255
    4e70:	4c 5b       	subi	r20, 0xBC	; 188
    4e72:	5f 4f       	sbci	r21, 0xFF	; 255
    4e74:	25 30       	cpi	r18, 0x05	; 5
    4e76:	31 05       	cpc	r19, r1
    4e78:	19 f7       	brne	.-58     	; 0x4e40 <GetAxissetting+0x6>
		fin=Buffersize+offset;
		for(i=offset;i<fin;i++) 
			TXAxissetting[i]=pdata[i-offset];  //desde pdata[0] hasta pdata[buffersize]
	}

}
    4e7a:	08 95       	ret

00004e7c <PrintAxissetting>:



void PrintAxissetting(tAxisSettings axisSettings)
{
    4e7c:	2f 92       	push	r2
    4e7e:	3f 92       	push	r3
    4e80:	4f 92       	push	r4
    4e82:	5f 92       	push	r5
    4e84:	6f 92       	push	r6
    4e86:	7f 92       	push	r7
    4e88:	8f 92       	push	r8
    4e8a:	9f 92       	push	r9
    4e8c:	af 92       	push	r10
    4e8e:	bf 92       	push	r11
    4e90:	cf 92       	push	r12
    4e92:	df 92       	push	r13
    4e94:	ef 92       	push	r14
    4e96:	ff 92       	push	r15
    4e98:	0f 93       	push	r16
    4e9a:	1f 93       	push	r17
    4e9c:	df 93       	push	r29
    4e9e:	cf 93       	push	r28
    4ea0:	cd b7       	in	r28, 0x3d	; 61
    4ea2:	de b7       	in	r29, 0x3e	; 62
    4ea4:	ae 97       	sbiw	r28, 0x2e	; 46
    4ea6:	0f b6       	in	r0, 0x3f	; 63
    4ea8:	f8 94       	cli
    4eaa:	de bf       	out	0x3e, r29	; 62
    4eac:	0f be       	out	0x3f, r0	; 63
    4eae:	cd bf       	out	0x3d, r28	; 61
    4eb0:	2d 96       	adiw	r28, 0x0d	; 13
    4eb2:	ce ac       	ldd	r12, Y+62	; 0x3e
    4eb4:	df ac       	ldd	r13, Y+63	; 0x3f
    4eb6:	2d 97       	sbiw	r28, 0x0d	; 13
    4eb8:	24 96       	adiw	r28, 0x04	; 4
    4eba:	0f ad       	ldd	r16, Y+63	; 0x3f
    4ebc:	24 97       	sbiw	r28, 0x04	; 4
    4ebe:	25 96       	adiw	r28, 0x05	; 5
    4ec0:	ef ac       	ldd	r14, Y+63	; 0x3f
    4ec2:	25 97       	sbiw	r28, 0x05	; 5
    4ec4:	27 96       	adiw	r28, 0x07	; 7
    4ec6:	6e ac       	ldd	r6, Y+62	; 0x3e
    4ec8:	7f ac       	ldd	r7, Y+63	; 0x3f
    4eca:	27 97       	sbiw	r28, 0x07	; 7
    4ecc:	29 96       	adiw	r28, 0x09	; 9
    4ece:	8e ad       	ldd	r24, Y+62	; 0x3e
    4ed0:	9f ad       	ldd	r25, Y+63	; 0x3f
    4ed2:	29 97       	sbiw	r28, 0x09	; 9
    4ed4:	9e a7       	std	Y+46, r25	; 0x2e
    4ed6:	8d a7       	std	Y+45, r24	; 0x2d
    4ed8:	2f 96       	adiw	r28, 0x0f	; 15
    4eda:	ae ad       	ldd	r26, Y+62	; 0x3e
    4edc:	bf ad       	ldd	r27, Y+63	; 0x3f
    4ede:	2f 97       	sbiw	r28, 0x0f	; 15
    4ee0:	bc a7       	std	Y+44, r27	; 0x2c
    4ee2:	ab a7       	std	Y+43, r26	; 0x2b
    4ee4:	61 96       	adiw	r28, 0x11	; 17
    4ee6:	ee ad       	ldd	r30, Y+62	; 0x3e
    4ee8:	ff ad       	ldd	r31, Y+63	; 0x3f
    4eea:	61 97       	sbiw	r28, 0x11	; 17
    4eec:	fa a7       	std	Y+42, r31	; 0x2a
    4eee:	e9 a7       	std	Y+41, r30	; 0x29
    4ef0:	63 96       	adiw	r28, 0x13	; 19
    4ef2:	8e ad       	ldd	r24, Y+62	; 0x3e
    4ef4:	9f ad       	ldd	r25, Y+63	; 0x3f
    4ef6:	63 97       	sbiw	r28, 0x13	; 19
    4ef8:	98 a7       	std	Y+40, r25	; 0x28
    4efa:	8f a3       	std	Y+39, r24	; 0x27
    4efc:	65 96       	adiw	r28, 0x15	; 21
    4efe:	ae ad       	ldd	r26, Y+62	; 0x3e
    4f00:	bf ad       	ldd	r27, Y+63	; 0x3f
    4f02:	65 97       	sbiw	r28, 0x15	; 21
    4f04:	be a3       	std	Y+38, r27	; 0x26
    4f06:	ad a3       	std	Y+37, r26	; 0x25
    4f08:	67 96       	adiw	r28, 0x17	; 23
    4f0a:	ee ad       	ldd	r30, Y+62	; 0x3e
    4f0c:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f0e:	67 97       	sbiw	r28, 0x17	; 23
    4f10:	fc a3       	std	Y+36, r31	; 0x24
    4f12:	eb a3       	std	Y+35, r30	; 0x23
    4f14:	69 96       	adiw	r28, 0x19	; 25
    4f16:	8e ad       	ldd	r24, Y+62	; 0x3e
    4f18:	9f ad       	ldd	r25, Y+63	; 0x3f
    4f1a:	69 97       	sbiw	r28, 0x19	; 25
    4f1c:	9a a3       	std	Y+34, r25	; 0x22
    4f1e:	89 a3       	std	Y+33, r24	; 0x21
    4f20:	6b 96       	adiw	r28, 0x1b	; 27
    4f22:	ae ad       	ldd	r26, Y+62	; 0x3e
    4f24:	bf ad       	ldd	r27, Y+63	; 0x3f
    4f26:	6b 97       	sbiw	r28, 0x1b	; 27
    4f28:	b8 a3       	std	Y+32, r27	; 0x20
    4f2a:	af 8f       	std	Y+31, r26	; 0x1f
    4f2c:	6d 96       	adiw	r28, 0x1d	; 29
    4f2e:	ee ad       	ldd	r30, Y+62	; 0x3e
    4f30:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f32:	6d 97       	sbiw	r28, 0x1d	; 29
    4f34:	fe 8f       	std	Y+30, r31	; 0x1e
    4f36:	ed 8f       	std	Y+29, r30	; 0x1d
    4f38:	6f 96       	adiw	r28, 0x1f	; 31
    4f3a:	8e ad       	ldd	r24, Y+62	; 0x3e
    4f3c:	9f ad       	ldd	r25, Y+63	; 0x3f
    4f3e:	6f 97       	sbiw	r28, 0x1f	; 31
    4f40:	9c 8f       	std	Y+28, r25	; 0x1c
    4f42:	8b 8f       	std	Y+27, r24	; 0x1b
    4f44:	a1 96       	adiw	r28, 0x21	; 33
    4f46:	ae ad       	ldd	r26, Y+62	; 0x3e
    4f48:	bf ad       	ldd	r27, Y+63	; 0x3f
    4f4a:	a1 97       	sbiw	r28, 0x21	; 33
    4f4c:	ba 8f       	std	Y+26, r27	; 0x1a
    4f4e:	a9 8f       	std	Y+25, r26	; 0x19
    4f50:	a3 96       	adiw	r28, 0x23	; 35
    4f52:	ee ad       	ldd	r30, Y+62	; 0x3e
    4f54:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f56:	a3 97       	sbiw	r28, 0x23	; 35
    4f58:	f8 8f       	std	Y+24, r31	; 0x18
    4f5a:	ef 8b       	std	Y+23, r30	; 0x17
    4f5c:	a7 96       	adiw	r28, 0x27	; 39
    4f5e:	8c ac       	ldd	r8, Y+60	; 0x3c
    4f60:	9d ac       	ldd	r9, Y+61	; 0x3d
    4f62:	ae ac       	ldd	r10, Y+62	; 0x3e
    4f64:	bf ac       	ldd	r11, Y+63	; 0x3f
    4f66:	a7 97       	sbiw	r28, 0x27	; 39
    4f68:	ab 96       	adiw	r28, 0x2b	; 43
    4f6a:	2c ac       	ldd	r2, Y+60	; 0x3c
    4f6c:	3d ac       	ldd	r3, Y+61	; 0x3d
    4f6e:	4e ac       	ldd	r4, Y+62	; 0x3e
    4f70:	5f ac       	ldd	r5, Y+63	; 0x3f
    4f72:	ab 97       	sbiw	r28, 0x2b	; 43
    4f74:	af 96       	adiw	r28, 0x2f	; 47
    4f76:	8c ad       	ldd	r24, Y+60	; 0x3c
    4f78:	9d ad       	ldd	r25, Y+61	; 0x3d
    4f7a:	ae ad       	ldd	r26, Y+62	; 0x3e
    4f7c:	bf ad       	ldd	r27, Y+63	; 0x3f
    4f7e:	af 97       	sbiw	r28, 0x2f	; 47
    4f80:	8b 8b       	std	Y+19, r24	; 0x13
    4f82:	9c 8b       	std	Y+20, r25	; 0x14
    4f84:	ad 8b       	std	Y+21, r26	; 0x15
    4f86:	be 8b       	std	Y+22, r27	; 0x16
    4f88:	e3 96       	adiw	r28, 0x33	; 51
    4f8a:	8c ad       	ldd	r24, Y+60	; 0x3c
    4f8c:	9d ad       	ldd	r25, Y+61	; 0x3d
    4f8e:	ae ad       	ldd	r26, Y+62	; 0x3e
    4f90:	bf ad       	ldd	r27, Y+63	; 0x3f
    4f92:	e3 97       	sbiw	r28, 0x33	; 51
    4f94:	8f 87       	std	Y+15, r24	; 0x0f
    4f96:	98 8b       	std	Y+16, r25	; 0x10
    4f98:	a9 8b       	std	Y+17, r26	; 0x11
    4f9a:	ba 8b       	std	Y+18, r27	; 0x12
    4f9c:	e7 96       	adiw	r28, 0x37	; 55
    4f9e:	8c ad       	ldd	r24, Y+60	; 0x3c
    4fa0:	9d ad       	ldd	r25, Y+61	; 0x3d
    4fa2:	ae ad       	ldd	r26, Y+62	; 0x3e
    4fa4:	bf ad       	ldd	r27, Y+63	; 0x3f
    4fa6:	e7 97       	sbiw	r28, 0x37	; 55
    4fa8:	8b 87       	std	Y+11, r24	; 0x0b
    4faa:	9c 87       	std	Y+12, r25	; 0x0c
    4fac:	ad 87       	std	Y+13, r26	; 0x0d
    4fae:	be 87       	std	Y+14, r27	; 0x0e
    4fb0:	eb 96       	adiw	r28, 0x3b	; 59
    4fb2:	8c ad       	ldd	r24, Y+60	; 0x3c
    4fb4:	9d ad       	ldd	r25, Y+61	; 0x3d
    4fb6:	ae ad       	ldd	r26, Y+62	; 0x3e
    4fb8:	bf ad       	ldd	r27, Y+63	; 0x3f
    4fba:	eb 97       	sbiw	r28, 0x3b	; 59
    4fbc:	8f 83       	std	Y+7, r24	; 0x07
    4fbe:	98 87       	std	Y+8, r25	; 0x08
    4fc0:	a9 87       	std	Y+9, r26	; 0x09
    4fc2:	ba 87       	std	Y+10, r27	; 0x0a
    4fc4:	ef 96       	adiw	r28, 0x3f	; 63
    4fc6:	8c ad       	ldd	r24, Y+60	; 0x3c
    4fc8:	9d ad       	ldd	r25, Y+61	; 0x3d
    4fca:	ae ad       	ldd	r26, Y+62	; 0x3e
    4fcc:	bf ad       	ldd	r27, Y+63	; 0x3f
    4fce:	ef 97       	sbiw	r28, 0x3f	; 63
    4fd0:	8b 83       	std	Y+3, r24	; 0x03
    4fd2:	9c 83       	std	Y+4, r25	; 0x04
    4fd4:	ad 83       	std	Y+5, r26	; 0x05
    4fd6:	be 83       	std	Y+6, r27	; 0x06
	int test;
	
		printf("PrintAxissetting=> En  axisSettings.maxAxisAngle= %d \n",axisSettings.maxAxisAngle);
    4fd8:	00 d0       	rcall	.+0      	; 0x4fda <PrintAxissetting+0x15e>
    4fda:	00 d0       	rcall	.+0      	; 0x4fdc <PrintAxissetting+0x160>
    4fdc:	8c ea       	ldi	r24, 0xAC	; 172
    4fde:	92 e4       	ldi	r25, 0x42	; 66
    4fe0:	ad b7       	in	r26, 0x3d	; 61
    4fe2:	be b7       	in	r27, 0x3e	; 62
    4fe4:	12 96       	adiw	r26, 0x02	; 2
    4fe6:	9c 93       	st	X, r25
    4fe8:	8e 93       	st	-X, r24
    4fea:	11 97       	sbiw	r26, 0x01	; 1
    4fec:	2b 96       	adiw	r28, 0x0b	; 11
    4fee:	8e ad       	ldd	r24, Y+62	; 0x3e
    4ff0:	9f ad       	ldd	r25, Y+63	; 0x3f
    4ff2:	2b 97       	sbiw	r28, 0x0b	; 11
    4ff4:	14 96       	adiw	r26, 0x04	; 4
    4ff6:	9c 93       	st	X, r25
    4ff8:	8e 93       	st	-X, r24
    4ffa:	13 97       	sbiw	r26, 0x03	; 3
    4ffc:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.minAxisAngle= %d \n",axisSettings.minAxisAngle);
    5000:	83 ee       	ldi	r24, 0xE3	; 227
    5002:	92 e4       	ldi	r25, 0x42	; 66
    5004:	ed b7       	in	r30, 0x3d	; 61
    5006:	fe b7       	in	r31, 0x3e	; 62
    5008:	92 83       	std	Z+2, r25	; 0x02
    500a:	81 83       	std	Z+1, r24	; 0x01
    500c:	d4 82       	std	Z+4, r13	; 0x04
    500e:	c3 82       	std	Z+3, r12	; 0x03
    5010:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.axisEnabled= %d \n",axisSettings.axisEnabled);
    5014:	8a e1       	ldi	r24, 0x1A	; 26
    5016:	93 e4       	ldi	r25, 0x43	; 67
    5018:	ad b7       	in	r26, 0x3d	; 61
    501a:	be b7       	in	r27, 0x3e	; 62
    501c:	12 96       	adiw	r26, 0x02	; 2
    501e:	9c 93       	st	X, r25
    5020:	8e 93       	st	-X, r24
    5022:	11 97       	sbiw	r26, 0x01	; 1
    5024:	11 27       	eor	r17, r17
    5026:	07 fd       	sbrc	r16, 7
    5028:	10 95       	com	r17
    502a:	14 96       	adiw	r26, 0x04	; 4
    502c:	1c 93       	st	X, r17
    502e:	0e 93       	st	-X, r16
    5030:	13 97       	sbiw	r26, 0x03	; 3
    5032:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.interruptEnable= %d \n",axisSettings.interruptEnable);
    5036:	80 e5       	ldi	r24, 0x50	; 80
    5038:	93 e4       	ldi	r25, 0x43	; 67
    503a:	ed b7       	in	r30, 0x3d	; 61
    503c:	fe b7       	in	r31, 0x3e	; 62
    503e:	92 83       	std	Z+2, r25	; 0x02
    5040:	81 83       	std	Z+1, r24	; 0x01
    5042:	ff 24       	eor	r15, r15
    5044:	e7 fc       	sbrc	r14, 7
    5046:	f0 94       	com	r15
    5048:	f4 82       	std	Z+4, r15	; 0x04
    504a:	e3 82       	std	Z+3, r14	; 0x03
    504c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.switchEnable= %d \n",axisSettings.switchEnable);
    5050:	8a e8       	ldi	r24, 0x8A	; 138
    5052:	93 e4       	ldi	r25, 0x43	; 67
    5054:	ad b7       	in	r26, 0x3d	; 61
    5056:	be b7       	in	r27, 0x3e	; 62
    5058:	12 96       	adiw	r26, 0x02	; 2
    505a:	9c 93       	st	X, r25
    505c:	8e 93       	st	-X, r24
    505e:	11 97       	sbiw	r26, 0x01	; 1
    5060:	14 96       	adiw	r26, 0x04	; 4
    5062:	7c 92       	st	X, r7
    5064:	6e 92       	st	-X, r6
    5066:	13 97       	sbiw	r26, 0x03	; 3
    5068:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.encoderEnable= %d \n",axisSettings.encoderEnable);
    506c:	81 ec       	ldi	r24, 0xC1	; 193
    506e:	93 e4       	ldi	r25, 0x43	; 67
    5070:	ed b7       	in	r30, 0x3d	; 61
    5072:	fe b7       	in	r31, 0x3e	; 62
    5074:	92 83       	std	Z+2, r25	; 0x02
    5076:	81 83       	std	Z+1, r24	; 0x01
    5078:	8d a5       	ldd	r24, Y+45	; 0x2d
    507a:	9e a5       	ldd	r25, Y+46	; 0x2e
    507c:	94 83       	std	Z+4, r25	; 0x04
    507e:	83 83       	std	Z+3, r24	; 0x03
    5080:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.ustepsPerStep= %d \n",axisSettings.ustepsPerStep);
    5084:	89 ef       	ldi	r24, 0xF9	; 249
    5086:	93 e4       	ldi	r25, 0x43	; 67
    5088:	ad b7       	in	r26, 0x3d	; 61
    508a:	be b7       	in	r27, 0x3e	; 62
    508c:	12 96       	adiw	r26, 0x02	; 2
    508e:	9c 93       	st	X, r25
    5090:	8e 93       	st	-X, r24
    5092:	11 97       	sbiw	r26, 0x01	; 1
    5094:	eb a5       	ldd	r30, Y+43	; 0x2b
    5096:	fc a5       	ldd	r31, Y+44	; 0x2c
    5098:	14 96       	adiw	r26, 0x04	; 4
    509a:	fc 93       	st	X, r31
    509c:	ee 93       	st	-X, r30
    509e:	13 97       	sbiw	r26, 0x03	; 3
    50a0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.motorStepsPerRevolution= %d \n",axisSettings.motorStepsPerRevolution);
    50a4:	81 e3       	ldi	r24, 0x31	; 49
    50a6:	94 e4       	ldi	r25, 0x44	; 68
    50a8:	ad b7       	in	r26, 0x3d	; 61
    50aa:	be b7       	in	r27, 0x3e	; 62
    50ac:	12 96       	adiw	r26, 0x02	; 2
    50ae:	9c 93       	st	X, r25
    50b0:	8e 93       	st	-X, r24
    50b2:	11 97       	sbiw	r26, 0x01	; 1
    50b4:	e9 a5       	ldd	r30, Y+41	; 0x29
    50b6:	fa a5       	ldd	r31, Y+42	; 0x2a
    50b8:	14 96       	adiw	r26, 0x04	; 4
    50ba:	fc 93       	st	X, r31
    50bc:	ee 93       	st	-X, r30
    50be:	13 97       	sbiw	r26, 0x03	; 3
    50c0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.encoderStepsPerRevolution= %d \n",axisSettings.encoderStepsPerRevolution);
    50c4:	83 e7       	ldi	r24, 0x73	; 115
    50c6:	94 e4       	ldi	r25, 0x44	; 68
    50c8:	ad b7       	in	r26, 0x3d	; 61
    50ca:	be b7       	in	r27, 0x3e	; 62
    50cc:	12 96       	adiw	r26, 0x02	; 2
    50ce:	9c 93       	st	X, r25
    50d0:	8e 93       	st	-X, r24
    50d2:	11 97       	sbiw	r26, 0x01	; 1
    50d4:	ef a1       	ldd	r30, Y+39	; 0x27
    50d6:	f8 a5       	ldd	r31, Y+40	; 0x28
    50d8:	14 96       	adiw	r26, 0x04	; 4
    50da:	fc 93       	st	X, r31
    50dc:	ee 93       	st	-X, r30
    50de:	13 97       	sbiw	r26, 0x03	; 3
    50e0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.TrackingWindow= %d \n",axisSettings.TrackingWindow);
    50e4:	87 eb       	ldi	r24, 0xB7	; 183
    50e6:	94 e4       	ldi	r25, 0x44	; 68
    50e8:	ad b7       	in	r26, 0x3d	; 61
    50ea:	be b7       	in	r27, 0x3e	; 62
    50ec:	12 96       	adiw	r26, 0x02	; 2
    50ee:	9c 93       	st	X, r25
    50f0:	8e 93       	st	-X, r24
    50f2:	11 97       	sbiw	r26, 0x01	; 1
    50f4:	ed a1       	ldd	r30, Y+37	; 0x25
    50f6:	fe a1       	ldd	r31, Y+38	; 0x26
    50f8:	14 96       	adiw	r26, 0x04	; 4
    50fa:	fc 93       	st	X, r31
    50fc:	ee 93       	st	-X, r30
    50fe:	13 97       	sbiw	r26, 0x03	; 3
    5100:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.SettleWindow= %d \n",axisSettings.SettleWindow);
    5104:	80 ef       	ldi	r24, 0xF0	; 240
    5106:	94 e4       	ldi	r25, 0x44	; 68
    5108:	ad b7       	in	r26, 0x3d	; 61
    510a:	be b7       	in	r27, 0x3e	; 62
    510c:	12 96       	adiw	r26, 0x02	; 2
    510e:	9c 93       	st	X, r25
    5110:	8e 93       	st	-X, r24
    5112:	11 97       	sbiw	r26, 0x01	; 1
    5114:	eb a1       	ldd	r30, Y+35	; 0x23
    5116:	fc a1       	ldd	r31, Y+36	; 0x24
    5118:	14 96       	adiw	r26, 0x04	; 4
    511a:	fc 93       	st	X, r31
    511c:	ee 93       	st	-X, r30
    511e:	13 97       	sbiw	r26, 0x03	; 3
    5120:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.SettleTime= %d \n",axisSettings.SettleTime);
    5124:	87 e2       	ldi	r24, 0x27	; 39
    5126:	95 e4       	ldi	r25, 0x45	; 69
    5128:	ad b7       	in	r26, 0x3d	; 61
    512a:	be b7       	in	r27, 0x3e	; 62
    512c:	12 96       	adiw	r26, 0x02	; 2
    512e:	9c 93       	st	X, r25
    5130:	8e 93       	st	-X, r24
    5132:	11 97       	sbiw	r26, 0x01	; 1
    5134:	e9 a1       	ldd	r30, Y+33	; 0x21
    5136:	fa a1       	ldd	r31, Y+34	; 0x22
    5138:	14 96       	adiw	r26, 0x04	; 4
    513a:	fc 93       	st	X, r31
    513c:	ee 93       	st	-X, r30
    513e:	13 97       	sbiw	r26, 0x03	; 3
    5140:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.motorPower= %d \n",axisSettings.motorPower);
    5144:	8c e5       	ldi	r24, 0x5C	; 92
    5146:	95 e4       	ldi	r25, 0x45	; 69
    5148:	ad b7       	in	r26, 0x3d	; 61
    514a:	be b7       	in	r27, 0x3e	; 62
    514c:	12 96       	adiw	r26, 0x02	; 2
    514e:	9c 93       	st	X, r25
    5150:	8e 93       	st	-X, r24
    5152:	11 97       	sbiw	r26, 0x01	; 1
    5154:	ef 8d       	ldd	r30, Y+31	; 0x1f
    5156:	f8 a1       	ldd	r31, Y+32	; 0x20
    5158:	14 96       	adiw	r26, 0x04	; 4
    515a:	fc 93       	st	X, r31
    515c:	ee 93       	st	-X, r30
    515e:	13 97       	sbiw	r26, 0x03	; 3
    5160:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.numberPhases= %d \n",axisSettings.numberPhases);
    5164:	81 e9       	ldi	r24, 0x91	; 145
    5166:	95 e4       	ldi	r25, 0x45	; 69
    5168:	ad b7       	in	r26, 0x3d	; 61
    516a:	be b7       	in	r27, 0x3e	; 62
    516c:	12 96       	adiw	r26, 0x02	; 2
    516e:	9c 93       	st	X, r25
    5170:	8e 93       	st	-X, r24
    5172:	11 97       	sbiw	r26, 0x01	; 1
    5174:	ed 8d       	ldd	r30, Y+29	; 0x1d
    5176:	fe 8d       	ldd	r31, Y+30	; 0x1e
    5178:	14 96       	adiw	r26, 0x04	; 4
    517a:	fc 93       	st	X, r31
    517c:	ee 93       	st	-X, r30
    517e:	13 97       	sbiw	r26, 0x03	; 3
    5180:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.homeSwitchHandling= %d \n",axisSettings.homeSwitchHandling);
    5184:	88 ec       	ldi	r24, 0xC8	; 200
    5186:	95 e4       	ldi	r25, 0x45	; 69
    5188:	ad b7       	in	r26, 0x3d	; 61
    518a:	be b7       	in	r27, 0x3e	; 62
    518c:	12 96       	adiw	r26, 0x02	; 2
    518e:	9c 93       	st	X, r25
    5190:	8e 93       	st	-X, r24
    5192:	11 97       	sbiw	r26, 0x01	; 1
    5194:	eb 8d       	ldd	r30, Y+27	; 0x1b
    5196:	fc 8d       	ldd	r31, Y+28	; 0x1c
    5198:	14 96       	adiw	r26, 0x04	; 4
    519a:	fc 93       	st	X, r31
    519c:	ee 93       	st	-X, r30
    519e:	13 97       	sbiw	r26, 0x03	; 3
    51a0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.gearNominator= %d \n",axisSettings.gearNominator);
    51a4:	85 e0       	ldi	r24, 0x05	; 5
    51a6:	96 e4       	ldi	r25, 0x46	; 70
    51a8:	ad b7       	in	r26, 0x3d	; 61
    51aa:	be b7       	in	r27, 0x3e	; 62
    51ac:	12 96       	adiw	r26, 0x02	; 2
    51ae:	9c 93       	st	X, r25
    51b0:	8e 93       	st	-X, r24
    51b2:	11 97       	sbiw	r26, 0x01	; 1
    51b4:	e9 8d       	ldd	r30, Y+25	; 0x19
    51b6:	fa 8d       	ldd	r31, Y+26	; 0x1a
    51b8:	14 96       	adiw	r26, 0x04	; 4
    51ba:	fc 93       	st	X, r31
    51bc:	ee 93       	st	-X, r30
    51be:	13 97       	sbiw	r26, 0x03	; 3
    51c0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.gearDenominator= %d \n",axisSettings.gearDenominator);
    51c4:	8d e3       	ldi	r24, 0x3D	; 61
    51c6:	96 e4       	ldi	r25, 0x46	; 70
    51c8:	ad b7       	in	r26, 0x3d	; 61
    51ca:	be b7       	in	r27, 0x3e	; 62
    51cc:	12 96       	adiw	r26, 0x02	; 2
    51ce:	9c 93       	st	X, r25
    51d0:	8e 93       	st	-X, r24
    51d2:	11 97       	sbiw	r26, 0x01	; 1
    51d4:	ef 89       	ldd	r30, Y+23	; 0x17
    51d6:	f8 8d       	ldd	r31, Y+24	; 0x18
    51d8:	14 96       	adiw	r26, 0x04	; 4
    51da:	fc 93       	st	X, r31
    51dc:	ee 93       	st	-X, r30
    51de:	13 97       	sbiw	r26, 0x03	; 3
    51e0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.ErrorLimit= %ld \n",axisSettings.ErrorLimit);
    51e4:	00 d0       	rcall	.+0      	; 0x51e6 <PrintAxissetting+0x36a>
    51e6:	87 e7       	ldi	r24, 0x77	; 119
    51e8:	96 e4       	ldi	r25, 0x46	; 70
    51ea:	ad b7       	in	r26, 0x3d	; 61
    51ec:	be b7       	in	r27, 0x3e	; 62
    51ee:	12 96       	adiw	r26, 0x02	; 2
    51f0:	9c 93       	st	X, r25
    51f2:	8e 93       	st	-X, r24
    51f4:	11 97       	sbiw	r26, 0x01	; 1
    51f6:	ed b7       	in	r30, 0x3d	; 61
    51f8:	fe b7       	in	r31, 0x3e	; 62
    51fa:	83 82       	std	Z+3, r8	; 0x03
    51fc:	94 82       	std	Z+4, r9	; 0x04
    51fe:	a5 82       	std	Z+5, r10	; 0x05
    5200:	b6 82       	std	Z+6, r11	; 0x06
    5202:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.limitAcceleration= %ld \n",axisSettings.limitAcceleration);	  
    5206:	8d ea       	ldi	r24, 0xAD	; 173
    5208:	96 e4       	ldi	r25, 0x46	; 70
    520a:	ad b7       	in	r26, 0x3d	; 61
    520c:	be b7       	in	r27, 0x3e	; 62
    520e:	12 96       	adiw	r26, 0x02	; 2
    5210:	9c 93       	st	X, r25
    5212:	8e 93       	st	-X, r24
    5214:	11 97       	sbiw	r26, 0x01	; 1
    5216:	ed b7       	in	r30, 0x3d	; 61
    5218:	fe b7       	in	r31, 0x3e	; 62
    521a:	23 82       	std	Z+3, r2	; 0x03
    521c:	34 82       	std	Z+4, r3	; 0x04
    521e:	45 82       	std	Z+5, r4	; 0x05
    5220:	56 82       	std	Z+6, r5	; 0x06
    5222:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.limitVelocity= %ld \n",axisSettings.limitVelocity);
    5226:	8a ee       	ldi	r24, 0xEA	; 234
    5228:	96 e4       	ldi	r25, 0x46	; 70
    522a:	ad b7       	in	r26, 0x3d	; 61
    522c:	be b7       	in	r27, 0x3e	; 62
    522e:	12 96       	adiw	r26, 0x02	; 2
    5230:	9c 93       	st	X, r25
    5232:	8e 93       	st	-X, r24
    5234:	11 97       	sbiw	r26, 0x01	; 1
    5236:	8b 89       	ldd	r24, Y+19	; 0x13
    5238:	9c 89       	ldd	r25, Y+20	; 0x14
    523a:	ad 89       	ldd	r26, Y+21	; 0x15
    523c:	be 89       	ldd	r27, Y+22	; 0x16
    523e:	ed b7       	in	r30, 0x3d	; 61
    5240:	fe b7       	in	r31, 0x3e	; 62
    5242:	83 83       	std	Z+3, r24	; 0x03
    5244:	94 83       	std	Z+4, r25	; 0x04
    5246:	a5 83       	std	Z+5, r26	; 0x05
    5248:	b6 83       	std	Z+6, r27	; 0x06
    524a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.limitJerk= %ld \n",axisSettings.limitJerk);
    524e:	83 e2       	ldi	r24, 0x23	; 35
    5250:	97 e4       	ldi	r25, 0x47	; 71
    5252:	ad b7       	in	r26, 0x3d	; 61
    5254:	be b7       	in	r27, 0x3e	; 62
    5256:	12 96       	adiw	r26, 0x02	; 2
    5258:	9c 93       	st	X, r25
    525a:	8e 93       	st	-X, r24
    525c:	11 97       	sbiw	r26, 0x01	; 1
    525e:	8f 85       	ldd	r24, Y+15	; 0x0f
    5260:	98 89       	ldd	r25, Y+16	; 0x10
    5262:	a9 89       	ldd	r26, Y+17	; 0x11
    5264:	ba 89       	ldd	r27, Y+18	; 0x12
    5266:	ed b7       	in	r30, 0x3d	; 61
    5268:	fe b7       	in	r31, 0x3e	; 62
    526a:	83 83       	std	Z+3, r24	; 0x03
    526c:	94 83       	std	Z+4, r25	; 0x04
    526e:	a5 83       	std	Z+5, r26	; 0x05
    5270:	b6 83       	std	Z+6, r27	; 0x06
    5272:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.maxAcceleration= %ld \n",axisSettings.maxAcceleration);	 
    5276:	88 e5       	ldi	r24, 0x58	; 88
    5278:	97 e4       	ldi	r25, 0x47	; 71
    527a:	ad b7       	in	r26, 0x3d	; 61
    527c:	be b7       	in	r27, 0x3e	; 62
    527e:	12 96       	adiw	r26, 0x02	; 2
    5280:	9c 93       	st	X, r25
    5282:	8e 93       	st	-X, r24
    5284:	11 97       	sbiw	r26, 0x01	; 1
    5286:	8b 85       	ldd	r24, Y+11	; 0x0b
    5288:	9c 85       	ldd	r25, Y+12	; 0x0c
    528a:	ad 85       	ldd	r26, Y+13	; 0x0d
    528c:	be 85       	ldd	r27, Y+14	; 0x0e
    528e:	ed b7       	in	r30, 0x3d	; 61
    5290:	fe b7       	in	r31, 0x3e	; 62
    5292:	83 83       	std	Z+3, r24	; 0x03
    5294:	94 83       	std	Z+4, r25	; 0x04
    5296:	a5 83       	std	Z+5, r26	; 0x05
    5298:	b6 83       	std	Z+6, r27	; 0x06
    529a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.maxVelocity= %ld \n",axisSettings.maxVelocity);
    529e:	83 e9       	ldi	r24, 0x93	; 147
    52a0:	97 e4       	ldi	r25, 0x47	; 71
    52a2:	ad b7       	in	r26, 0x3d	; 61
    52a4:	be b7       	in	r27, 0x3e	; 62
    52a6:	12 96       	adiw	r26, 0x02	; 2
    52a8:	9c 93       	st	X, r25
    52aa:	8e 93       	st	-X, r24
    52ac:	11 97       	sbiw	r26, 0x01	; 1
    52ae:	8f 81       	ldd	r24, Y+7	; 0x07
    52b0:	98 85       	ldd	r25, Y+8	; 0x08
    52b2:	a9 85       	ldd	r26, Y+9	; 0x09
    52b4:	ba 85       	ldd	r27, Y+10	; 0x0a
    52b6:	ed b7       	in	r30, 0x3d	; 61
    52b8:	fe b7       	in	r31, 0x3e	; 62
    52ba:	83 83       	std	Z+3, r24	; 0x03
    52bc:	94 83       	std	Z+4, r25	; 0x04
    52be:	a5 83       	std	Z+5, r26	; 0x05
    52c0:	b6 83       	std	Z+6, r27	; 0x06
    52c2:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("PrintAxissetting=> En  axisSettings.minVelocity= %ld \n",axisSettings.minVelocity);	  
    52c6:	8a ec       	ldi	r24, 0xCA	; 202
    52c8:	97 e4       	ldi	r25, 0x47	; 71
    52ca:	ad b7       	in	r26, 0x3d	; 61
    52cc:	be b7       	in	r27, 0x3e	; 62
    52ce:	12 96       	adiw	r26, 0x02	; 2
    52d0:	9c 93       	st	X, r25
    52d2:	8e 93       	st	-X, r24
    52d4:	11 97       	sbiw	r26, 0x01	; 1
    52d6:	8b 81       	ldd	r24, Y+3	; 0x03
    52d8:	9c 81       	ldd	r25, Y+4	; 0x04
    52da:	ad 81       	ldd	r26, Y+5	; 0x05
    52dc:	be 81       	ldd	r27, Y+6	; 0x06
    52de:	ed b7       	in	r30, 0x3d	; 61
    52e0:	fe b7       	in	r31, 0x3e	; 62
    52e2:	83 83       	std	Z+3, r24	; 0x03
    52e4:	94 83       	std	Z+4, r25	; 0x04
    52e6:	a5 83       	std	Z+5, r26	; 0x05
    52e8:	b6 83       	std	Z+6, r27	; 0x06
    52ea:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		scanf("%d",&test);
    52ee:	0f 90       	pop	r0
    52f0:	0f 90       	pop	r0
    52f2:	81 e0       	ldi	r24, 0x01	; 1
    52f4:	98 e4       	ldi	r25, 0x48	; 72
    52f6:	ad b7       	in	r26, 0x3d	; 61
    52f8:	be b7       	in	r27, 0x3e	; 62
    52fa:	12 96       	adiw	r26, 0x02	; 2
    52fc:	9c 93       	st	X, r25
    52fe:	8e 93       	st	-X, r24
    5300:	11 97       	sbiw	r26, 0x01	; 1
    5302:	ce 01       	movw	r24, r28
    5304:	01 96       	adiw	r24, 0x01	; 1
    5306:	14 96       	adiw	r26, 0x04	; 4
    5308:	9c 93       	st	X, r25
    530a:	8e 93       	st	-X, r24
    530c:	13 97       	sbiw	r26, 0x03	; 3
    530e:	0e 94 49 89 	call	0x11292	; 0x11292 <scanf>
    5312:	0f 90       	pop	r0
    5314:	0f 90       	pop	r0
    5316:	0f 90       	pop	r0
    5318:	0f 90       	pop	r0
	
}
    531a:	ae 96       	adiw	r28, 0x2e	; 46
    531c:	0f b6       	in	r0, 0x3f	; 63
    531e:	f8 94       	cli
    5320:	de bf       	out	0x3e, r29	; 62
    5322:	0f be       	out	0x3f, r0	; 63
    5324:	cd bf       	out	0x3d, r28	; 61
    5326:	cf 91       	pop	r28
    5328:	df 91       	pop	r29
    532a:	1f 91       	pop	r17
    532c:	0f 91       	pop	r16
    532e:	ff 90       	pop	r15
    5330:	ef 90       	pop	r14
    5332:	df 90       	pop	r13
    5334:	cf 90       	pop	r12
    5336:	bf 90       	pop	r11
    5338:	af 90       	pop	r10
    533a:	9f 90       	pop	r9
    533c:	8f 90       	pop	r8
    533e:	7f 90       	pop	r7
    5340:	6f 90       	pop	r6
    5342:	5f 90       	pop	r5
    5344:	4f 90       	pop	r4
    5346:	3f 90       	pop	r3
    5348:	2f 90       	pop	r2
    534a:	08 95       	ret

0000534c <Axissetting2hAxisHandle>:
	PMDSetBreakpoint(&hAxis[Axis],(PMDuint16)breakpointID,(PMDAxis)breakAxis,(PMDuint8)action,(PMDuint8)trigger);

}
/**********************************************************************************************************************/
int Axissetting2hAxisHandle(uint8* rxAxissetting)
{
    534c:	6f 92       	push	r6
    534e:	7f 92       	push	r7
    5350:	8f 92       	push	r8
    5352:	9f 92       	push	r9
    5354:	af 92       	push	r10
    5356:	bf 92       	push	r11
    5358:	cf 92       	push	r12
    535a:	df 92       	push	r13
    535c:	ef 92       	push	r14
    535e:	ff 92       	push	r15
    5360:	0f 93       	push	r16
    5362:	1f 93       	push	r17
    5364:	df 93       	push	r29
    5366:	cf 93       	push	r28
    5368:	cd b7       	in	r28, 0x3d	; 61
    536a:	de b7       	in	r29, 0x3e	; 62
    536c:	c6 55       	subi	r28, 0x56	; 86
    536e:	d1 40       	sbci	r29, 0x01	; 1
    5370:	0f b6       	in	r0, 0x3f	; 63
    5372:	f8 94       	cli
    5374:	de bf       	out	0x3e, r29	; 62
    5376:	0f be       	out	0x3f, r0	; 63
    5378:	cd bf       	out	0x3d, r28	; 61
    537a:	4c 01       	movw	r8, r24
    537c:	00 e0       	ldi	r16, 0x00	; 0
    537e:	10 e0       	ldi	r17, 0x00	; 0
    5380:	aa 24       	eor	r10, r10
    5382:	bb 24       	eor	r11, r11
	#endif	
	for(Axis=0;Axis<DOF;Axis++) 
	{
		/* Leer la configuracion anterior para no reconfigurar lo mismo*/
		//Destino, Fuente.
		eeprom_read_block((void*)&Ram_axisSettings[Axis],(const void*)&EEprom_axisSettings[Axis],sizeof(tAxisSettings));
    5384:	64 e4       	ldi	r22, 0x44	; 68
    5386:	c6 2e       	mov	r12, r22
    5388:	d1 2c       	mov	r13, r1
    538a:	53 e0       	ldi	r21, 0x03	; 3
    538c:	65 2e       	mov	r6, r21
    538e:	71 2c       	mov	r7, r1
    5390:	6c 0e       	add	r6, r28
    5392:	7d 1e       	adc	r7, r29
    5394:	0c 9d       	mul	r16, r12
    5396:	b0 01       	movw	r22, r0
    5398:	0d 9d       	mul	r16, r13
    539a:	70 0d       	add	r23, r0
    539c:	1c 9d       	mul	r17, r12
    539e:	70 0d       	add	r23, r0
    53a0:	11 24       	eor	r1, r1
    53a2:	73 01       	movw	r14, r6
    53a4:	e6 0e       	add	r14, r22
    53a6:	f7 1e       	adc	r15, r23
    53a8:	6e 5f       	subi	r22, 0xFE	; 254
    53aa:	7f 4f       	sbci	r23, 0xFF	; 255
    53ac:	c7 01       	movw	r24, r14
    53ae:	44 e4       	ldi	r20, 0x44	; 68
    53b0:	50 e0       	ldi	r21, 0x00	; 0
    53b2:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
		pdataEEprom=(uint8*)&Ram_axisSettings[Axis];
    53b6:	20 e0       	ldi	r18, 0x00	; 0
    53b8:	30 e0       	ldi	r19, 0x00	; 0
    53ba:	1b c0       	rjmp	.+54     	; 0x53f2 <Axissetting2hAxisHandle+0xa6>
		//Comparo las configuraciones por eje
		for(i=0;i<sizeof(tAxisSettings);i++) 
		{
			//Utilizo el apuntador a bytes!
                        /*(sizeof(tAxisSettings)*Axis) significa la posicion inicial de cada eje*/
			if(pdataEEprom[i]!=rxAxissetting[(sizeof(tAxisSettings)*Axis)+i])
    53bc:	d7 01       	movw	r26, r14
    53be:	a2 0f       	add	r26, r18
    53c0:	b3 1f       	adc	r27, r19
    53c2:	0c 9d       	mul	r16, r12
    53c4:	f0 01       	movw	r30, r0
    53c6:	0d 9d       	mul	r16, r13
    53c8:	f0 0d       	add	r31, r0
    53ca:	1c 9d       	mul	r17, r12
    53cc:	f0 0d       	add	r31, r0
    53ce:	11 24       	eor	r1, r1
    53d0:	e2 0f       	add	r30, r18
    53d2:	f3 1f       	adc	r31, r19
    53d4:	e8 0d       	add	r30, r8
    53d6:	f9 1d       	adc	r31, r9
    53d8:	9c 91       	ld	r25, X
    53da:	80 81       	ld	r24, Z
    53dc:	98 17       	cp	r25, r24
    53de:	39 f0       	breq	.+14     	; 0x53ee <Axissetting2hAxisHandle+0xa2>
    53e0:	24 e4       	ldi	r18, 0x44	; 68
    53e2:	30 e0       	ldi	r19, 0x00	; 0
    53e4:	05 e0       	ldi	r16, 0x05	; 5
    53e6:	10 e0       	ldi	r17, 0x00	; 0
    53e8:	41 e0       	ldi	r20, 0x01	; 1
    53ea:	a4 2e       	mov	r10, r20
    53ec:	b1 2c       	mov	r11, r1
		
		PrintAxissetting(Ram_axisSettings[Axis]);
		#endif
		
		//Comparo las configuraciones por eje
		for(i=0;i<sizeof(tAxisSettings);i++) 
    53ee:	2f 5f       	subi	r18, 0xFF	; 255
    53f0:	3f 4f       	sbci	r19, 0xFF	; 255
    53f2:	24 34       	cpi	r18, 0x44	; 68
    53f4:	31 05       	cpc	r19, r1
    53f6:	10 f3       	brcs	.-60     	; 0x53bc <Axissetting2hAxisHandle+0x70>
	Diferentes=0;
	
	#ifdef DEBUGSETUP
	printf("CopiartohAxissetting=> Iniciando la Comparacion\n");
	#endif	
	for(Axis=0;Axis<DOF;Axis++) 
    53f8:	0f 5f       	subi	r16, 0xFF	; 255
    53fa:	1f 4f       	sbci	r17, 0xFF	; 255
    53fc:	05 30       	cpi	r16, 0x05	; 5
    53fe:	11 05       	cpc	r17, r1
    5400:	4c f2       	brlt	.-110    	; 0x5394 <Axissetting2hAxisHandle+0x48>
		
		
	}
	
	
	if(Diferentes==1)
    5402:	81 e0       	ldi	r24, 0x01	; 1
    5404:	a8 16       	cp	r10, r24
    5406:	b1 04       	cpc	r11, r1
    5408:	09 f0       	breq	.+2      	; 0x540c <Axissetting2hAxisHandle+0xc0>
    540a:	42 c0       	rjmp	.+132    	; 0x5490 <Axissetting2hAxisHandle+0x144>
	{
		//Activo el indicador de configuracion por EEprom pero primero leo el mismo
		//para ver si esta activado y no sobre escribirlo inecesariamente.
		eeprom_read_block((void*)&Ram_Reconf_Indicator,(const void*)&EEprom_Reconf_Indicator,sizeof(int16));
    540c:	8e 01       	movw	r16, r28
    540e:	0f 5f       	subi	r16, 0xFF	; 255
    5410:	1f 4f       	sbci	r17, 0xFF	; 255
    5412:	c8 01       	movw	r24, r16
    5414:	60 e0       	ldi	r22, 0x00	; 0
    5416:	70 e0       	ldi	r23, 0x00	; 0
    5418:	42 e0       	ldi	r20, 0x02	; 2
    541a:	50 e0       	ldi	r21, 0x00	; 0
    541c:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
		if(!Ram_Reconf_Indicator)
    5420:	89 81       	ldd	r24, Y+1	; 0x01
    5422:	9a 81       	ldd	r25, Y+2	; 0x02
    5424:	89 2b       	or	r24, r25
    5426:	49 f4       	brne	.+18     	; 0x543a <Axissetting2hAxisHandle+0xee>
		{
			Ram_Reconf_Indicator=1;
    5428:	ba 82       	std	Y+2, r11	; 0x02
    542a:	a9 82       	std	Y+1, r10	; 0x01
			//Actualizo a el indicador
			//Fuente,Destino
			eeprom_write_block((const void*)&Ram_Reconf_Indicator,(void*)&EEprom_Reconf_Indicator,sizeof(int16));
    542c:	c8 01       	movw	r24, r16
    542e:	60 e0       	ldi	r22, 0x00	; 0
    5430:	70 e0       	ldi	r23, 0x00	; 0
    5432:	42 e0       	ldi	r20, 0x02	; 2
    5434:	50 e0       	ldi	r21, 0x00	; 0
    5436:	0e 94 e3 89 	call	0x113c6	; 0x113c6 <__eewr_block_m1280>
    543a:	ee 24       	eor	r14, r14
    543c:	ff 24       	eor	r15, r15
    543e:	cc 24       	eor	r12, r12
    5440:	dd 24       	eor	r13, r13
    5442:	86 01       	movw	r16, r12
    5444:	0e 5f       	subi	r16, 0xFE	; 254
    5446:	1f 4f       	sbci	r17, 0xFF	; 255
			
			#ifdef DEBUGSETUP
			printf("CopiartohAxissetting=> Copiando la informacion en eeprom\n");
			#endif	
			//Copio la configuracion de ejes a la eepron
			eeprom_write_block((const void*)&prxAxissetting[Axis],(void*)&EEprom_axisSettings[Axis],sizeof(tAxisSettings));
    5448:	c4 01       	movw	r24, r8
    544a:	8c 0d       	add	r24, r12
    544c:	9d 1d       	adc	r25, r13
    544e:	b8 01       	movw	r22, r16
    5450:	44 e4       	ldi	r20, 0x44	; 68
    5452:	50 e0       	ldi	r21, 0x00	; 0
    5454:	0e 94 e3 89 	call	0x113c6	; 0x113c6 <__eewr_block_m1280>
			
			//Actualizo hAxis[Axis]..axisSettings a la estructura axisSettings en EEprom
			eeprom_read_block((void*)&hAxis[Axis].axisSettings,(const void*)&EEprom_axisSettings[Axis],sizeof(tAxisSettings));
    5458:	c7 01       	movw	r24, r14
    545a:	88 0f       	add	r24, r24
    545c:	99 1f       	adc	r25, r25
    545e:	8e 0d       	add	r24, r14
    5460:	9f 1d       	adc	r25, r15
    5462:	25 e0       	ldi	r18, 0x05	; 5
    5464:	88 0f       	add	r24, r24
    5466:	99 1f       	adc	r25, r25
    5468:	2a 95       	dec	r18
    546a:	e1 f7       	brne	.-8      	; 0x5464 <Axissetting2hAxisHandle+0x118>
    546c:	88 58       	subi	r24, 0x88	; 136
    546e:	92 48       	sbci	r25, 0x82	; 130
    5470:	b8 01       	movw	r22, r16
    5472:	44 e4       	ldi	r20, 0x44	; 68
    5474:	50 e0       	ldi	r21, 0x00	; 0
    5476:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
		Buffersize=sizeof(tAxisSettings);
		#ifdef DEBUGSETUP
		printf("CopiartohAxissetting=> Buffersize= %d\n",Buffersize);
		#endif	
		/*Copio la nueva configuracion a al eeprom y actualizo la configuracion en hAxis[Axis]..axisSetting */
		for(Axis=0;Axis<DOF;Axis++) 
    547a:	08 94       	sec
    547c:	e1 1c       	adc	r14, r1
    547e:	f1 1c       	adc	r15, r1
    5480:	84 e4       	ldi	r24, 0x44	; 68
    5482:	90 e0       	ldi	r25, 0x00	; 0
    5484:	c8 0e       	add	r12, r24
    5486:	d9 1e       	adc	r13, r25
    5488:	95 e0       	ldi	r25, 0x05	; 5
    548a:	e9 16       	cp	r14, r25
    548c:	f1 04       	cpc	r15, r1
    548e:	c9 f6       	brne	.-78     	; 0x5442 <Axissetting2hAxisHandle+0xf6>
		#endif		
		
	}
	
	return Diferentes;
}
    5490:	c5 01       	movw	r24, r10
    5492:	ca 5a       	subi	r28, 0xAA	; 170
    5494:	de 4f       	sbci	r29, 0xFE	; 254
    5496:	0f b6       	in	r0, 0x3f	; 63
    5498:	f8 94       	cli
    549a:	de bf       	out	0x3e, r29	; 62
    549c:	0f be       	out	0x3f, r0	; 63
    549e:	cd bf       	out	0x3d, r28	; 61
    54a0:	cf 91       	pop	r28
    54a2:	df 91       	pop	r29
    54a4:	1f 91       	pop	r17
    54a6:	0f 91       	pop	r16
    54a8:	ff 90       	pop	r15
    54aa:	ef 90       	pop	r14
    54ac:	df 90       	pop	r13
    54ae:	cf 90       	pop	r12
    54b0:	bf 90       	pop	r11
    54b2:	af 90       	pop	r10
    54b4:	9f 90       	pop	r9
    54b6:	8f 90       	pop	r8
    54b8:	7f 90       	pop	r7
    54ba:	6f 90       	pop	r6
    54bc:	08 95       	ret

000054be <Config_BreakPoint>:
}


/**********************************************************************************************************************/
void  Config_BreakPoint(int16 Axis, int16 breakpointID,int16 breakAxis, int16 action, int16 trigger, PMDint32 breakpointvalue)
{
    54be:	8f 92       	push	r8
    54c0:	9f 92       	push	r9
    54c2:	af 92       	push	r10
    54c4:	bf 92       	push	r11
    54c6:	cf 92       	push	r12
    54c8:	df 92       	push	r13
    54ca:	ef 92       	push	r14
    54cc:	ff 92       	push	r15
    54ce:	0f 93       	push	r16
    54d0:	1f 93       	push	r17
    54d2:	16 2f       	mov	r17, r22
    54d4:	97 2e       	mov	r9, r23
    54d6:	5a 01       	movw	r10, r20
    54d8:	82 2e       	mov	r8, r18
    54da:	a7 01       	movw	r20, r14
    54dc:	96 01       	movw	r18, r12

	PMDSetBreakpointValue(&hAxis[Axis], (PMDuint16)breakpointID, breakpointvalue);
    54de:	60 e6       	ldi	r22, 0x60	; 96
    54e0:	70 e0       	ldi	r23, 0x00	; 0
    54e2:	86 9f       	mul	r24, r22
    54e4:	70 01       	movw	r14, r0
    54e6:	87 9f       	mul	r24, r23
    54e8:	f0 0c       	add	r15, r0
    54ea:	96 9f       	mul	r25, r22
    54ec:	f0 0c       	add	r15, r0
    54ee:	11 24       	eor	r1, r1
    54f0:	84 e7       	ldi	r24, 0x74	; 116
    54f2:	9d e7       	ldi	r25, 0x7D	; 125
    54f4:	e8 0e       	add	r14, r24
    54f6:	f9 1e       	adc	r15, r25
    54f8:	c7 01       	movw	r24, r14
    54fa:	61 2f       	mov	r22, r17
    54fc:	79 2d       	mov	r23, r9
    54fe:	0e 94 a0 67 	call	0xcf40	; 0xcf40 <PMDSetBreakpointValue>
	
	PMDSetBreakpoint(&hAxis[Axis],(PMDuint16)breakpointID,(PMDAxis)breakAxis,(PMDuint8)action,(PMDuint8)trigger);
    5502:	c7 01       	movw	r24, r14
    5504:	61 2f       	mov	r22, r17
    5506:	79 2d       	mov	r23, r9
    5508:	a5 01       	movw	r20, r10
    550a:	28 2d       	mov	r18, r8
    550c:	0e 94 45 66 	call	0xcc8a	; 0xcc8a <PMDSetBreakpoint>

}
    5510:	1f 91       	pop	r17
    5512:	0f 91       	pop	r16
    5514:	ff 90       	pop	r15
    5516:	ef 90       	pop	r14
    5518:	df 90       	pop	r13
    551a:	cf 90       	pop	r12
    551c:	bf 90       	pop	r11
    551e:	af 90       	pop	r10
    5520:	9f 90       	pop	r9
    5522:	8f 90       	pop	r8
    5524:	08 95       	ret

00005526 <cargar_encoder>:
/**********************************************************************************************************************/
void cargar_encoder(int16 axis, PMDint32 posicion)
{


	PMDSetActualPosition(&hAxis[axis],posicion);
    5526:	20 e6       	ldi	r18, 0x60	; 96
    5528:	30 e0       	ldi	r19, 0x00	; 0
    552a:	fc 01       	movw	r30, r24
    552c:	e2 9f       	mul	r30, r18
    552e:	c0 01       	movw	r24, r0
    5530:	e3 9f       	mul	r30, r19
    5532:	90 0d       	add	r25, r0
    5534:	f2 9f       	mul	r31, r18
    5536:	90 0d       	add	r25, r0
    5538:	11 24       	eor	r1, r1
    553a:	8c 58       	subi	r24, 0x8C	; 140
    553c:	92 48       	sbci	r25, 0x82	; 130
    553e:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>

}
    5542:	08 95       	ret

00005544 <ajustar_posicion>:
/**********************************************************************************************************************/
void ajustar_posicion(int16 axis, PMDint32 posicion)
{


	PMDAdjustActualPosition(&hAxis[axis],posicion);
    5544:	20 e6       	ldi	r18, 0x60	; 96
    5546:	30 e0       	ldi	r19, 0x00	; 0
    5548:	fc 01       	movw	r30, r24
    554a:	e2 9f       	mul	r30, r18
    554c:	c0 01       	movw	r24, r0
    554e:	e3 9f       	mul	r30, r19
    5550:	90 0d       	add	r25, r0
    5552:	f2 9f       	mul	r31, r18
    5554:	90 0d       	add	r25, r0
    5556:	11 24       	eor	r1, r1
    5558:	8c 58       	subi	r24, 0x8C	; 140
    555a:	92 48       	sbci	r25, 0x82	; 130
    555c:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>

}
    5560:	08 95       	ret

00005562 <Clear_Position_Error>:
	}	
}

/**********************************************************************************************************************/
void Clear_Position_Error(void)
{
    5562:	0f 93       	push	r16
    5564:	1f 93       	push	r17
    5566:	cf 93       	push	r28
    5568:	df 93       	push	r29
    556a:	04 e7       	ldi	r16, 0x74	; 116
    556c:	1d e7       	ldi	r17, 0x7D	; 125
    556e:	e8 01       	movw	r28, r16
	int16 axis;
	
	for(axis=0; axis < DOF; axis++) 
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE))
    5570:	8c 81       	ldd	r24, Y+4	; 0x04
    5572:	81 30       	cpi	r24, 0x01	; 1
    5574:	19 f4       	brne	.+6      	; 0x557c <Clear_Position_Error+0x1a>
			PMDClearPositionError(&hAxis[axis]);
    5576:	ce 01       	movw	r24, r28
    5578:	0e 94 74 65 	call	0xcae8	; 0xcae8 <PMDClearPositionError>
    557c:	c0 5a       	subi	r28, 0xA0	; 160
    557e:	df 4f       	sbci	r29, 0xFF	; 255
/**********************************************************************************************************************/
void Clear_Position_Error(void)
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++) 
    5580:	8f e7       	ldi	r24, 0x7F	; 127
    5582:	c4 35       	cpi	r28, 0x54	; 84
    5584:	d8 07       	cpc	r29, r24
    5586:	a1 f7       	brne	.-24     	; 0x5570 <Clear_Position_Error+0xe>
			PMDClearPositionError(&hAxis[axis]);
	}
	
	for(axis=0; axis < DOF; axis++) 
	{ // for every chipset (all axis with axis number=1), call MultiUpdate once
		if(hAxis[axis].axis == 0) 
    5588:	f8 01       	movw	r30, r16
    558a:	82 81       	ldd	r24, Z+2	; 0x02
    558c:	93 81       	ldd	r25, Z+3	; 0x03
    558e:	89 2b       	or	r24, r25
    5590:	29 f4       	brne	.+10     	; 0x559c <Clear_Position_Error+0x3a>
		{
			// Stop the robot (all axis in parallel)
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
    5592:	c8 01       	movw	r24, r16
    5594:	6f e0       	ldi	r22, 0x0F	; 15
    5596:	70 e0       	ldi	r23, 0x00	; 0
    5598:	0e 94 b3 63 	call	0xc766	; 0xc766 <PMDMultiUpdate>
    559c:	00 5a       	subi	r16, 0xA0	; 160
    559e:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE))
			PMDClearPositionError(&hAxis[axis]);
	}
	
	for(axis=0; axis < DOF; axis++) 
    55a0:	0c 17       	cp	r16, r28
    55a2:	1d 07       	cpc	r17, r29
    55a4:	89 f7       	brne	.-30     	; 0x5588 <Clear_Position_Error+0x26>
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
		} 
	}

	
}
    55a6:	df 91       	pop	r29
    55a8:	cf 91       	pop	r28
    55aa:	1f 91       	pop	r17
    55ac:	0f 91       	pop	r16
    55ae:	08 95       	ret

000055b0 <Reset_Even_Status_Register>:
	return rcOK;
}

/**********************************************************************************************************************/
void Reset_Even_Status_Register(void)
{
    55b0:	cf 93       	push	r28
    55b2:	df 93       	push	r29
    55b4:	c4 e7       	ldi	r28, 0x74	; 116
    55b6:	dd e7       	ldi	r29, 0x7D	; 125
	int16 axis;
	
	for(axis=0; axis < DOF; axis++) 
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE))
    55b8:	8c 81       	ldd	r24, Y+4	; 0x04
    55ba:	81 30       	cpi	r24, 0x01	; 1
    55bc:	29 f4       	brne	.+10     	; 0x55c8 <Reset_Even_Status_Register+0x18>
			PMDResetEventStatus(&hAxis[axis],~PMDEventStatusMask); 
    55be:	ce 01       	movw	r24, r28
    55c0:	60 e0       	ldi	r22, 0x00	; 0
    55c2:	77 eb       	ldi	r23, 0xB7	; 183
    55c4:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
    55c8:	c0 5a       	subi	r28, 0xA0	; 160
    55ca:	df 4f       	sbci	r29, 0xFF	; 255
/**********************************************************************************************************************/
void Reset_Even_Status_Register(void)
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++) 
    55cc:	8f e7       	ldi	r24, 0x7F	; 127
    55ce:	c4 35       	cpi	r28, 0x54	; 84
    55d0:	d8 07       	cpc	r29, r24
    55d2:	91 f7       	brne	.-28     	; 0x55b8 <Reset_Even_Status_Register+0x8>
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE))
			PMDResetEventStatus(&hAxis[axis],~PMDEventStatusMask); 
	}	
}
    55d4:	df 91       	pop	r29
    55d6:	cf 91       	pop	r28
    55d8:	08 95       	ret

000055da <PMDsetupChipsets_USB>:
//-PMDSetEncoderSource
//-PMDSetEncoderToStepRatio
//-PMDSetAxisMode
//-PMDSetMotorMode
PMDresult PMDsetupChipsets_USB(PMDProfileMode Profile) 
{
    55da:	ef 92       	push	r14
    55dc:	ff 92       	push	r15
    55de:	0f 93       	push	r16
    55e0:	1f 93       	push	r17
    55e2:	cf 93       	push	r28
    55e4:	df 93       	push	r29
    55e6:	e8 2e       	mov	r14, r24
    55e8:	c4 e7       	ldi	r28, 0x74	; 116
    55ea:	dd e7       	ldi	r29, 0x7D	; 125
    55ec:	ff 24       	eor	r15, r15
    55ee:	1c 2f       	mov	r17, r28
    55f0:	0d 2f       	mov	r16, r29
  // look for a handle of every chipset to reset it...look for axis=1
	
	for(axis=0; axis < DOF; axis++)
	{
		//FIja la unidad del registo Actual position a uPasos
		PMDrc = PMDSetActualPositionUnits(&hAxis[axis],PMDSteps);     
    55f2:	ce 01       	movw	r24, r28
    55f4:	61 e0       	ldi	r22, 0x01	; 1
    55f6:	70 e0       	ldi	r23, 0x00	; 0
    55f8:	0e 94 9b 63 	call	0xc736	; 0xc736 <PMDSetActualPositionUnits>
		if(PMDrc != PMD_ERR_OK) 
    55fc:	89 2b       	or	r24, r25
    55fe:	19 f0       	breq	.+6      	; 0x5606 <PMDsetupChipsets_USB+0x2c>
    5600:	2d e0       	ldi	r18, 0x0D	; 13
    5602:	30 e0       	ldi	r19, 0x00	; 0
    5604:	a7 c0       	rjmp	.+334    	; 0x5754 <PMDsetupChipsets_USB+0x17a>
		{
			return rcHardwareFailure;  // PMD didn't answer... comment 
										// out if UC should continue!		
		}		
		
		switch (axis)
    5606:	82 e0       	ldi	r24, 0x02	; 2
    5608:	f8 16       	cp	r15, r24
    560a:	79 f0       	breq	.+30     	; 0x562a <PMDsetupChipsets_USB+0x50>
    560c:	8f 15       	cp	r24, r15
    560e:	30 f0       	brcs	.+12     	; 0x561c <PMDsetupChipsets_USB+0x42>
    5610:	ff 20       	and	r15, r15
    5612:	79 f0       	breq	.+30     	; 0x5632 <PMDsetupChipsets_USB+0x58>
    5614:	81 e0       	ldi	r24, 0x01	; 1
    5616:	f8 16       	cp	r15, r24
    5618:	71 f4       	brne	.+28     	; 0x5636 <PMDsetupChipsets_USB+0x5c>
    561a:	07 c0       	rjmp	.+14     	; 0x562a <PMDsetupChipsets_USB+0x50>
    561c:	83 e0       	ldi	r24, 0x03	; 3
    561e:	f8 16       	cp	r15, r24
    5620:	21 f0       	breq	.+8      	; 0x562a <PMDsetupChipsets_USB+0x50>
    5622:	84 e0       	ldi	r24, 0x04	; 4
    5624:	f8 16       	cp	r15, r24
    5626:	39 f4       	brne	.+14     	; 0x5636 <PMDsetupChipsets_USB+0x5c>
    5628:	04 c0       	rjmp	.+8      	; 0x5632 <PMDsetupChipsets_USB+0x58>
						PMDSignalEncoderHomeMask |PMDSignalPositiveLimitMask |
						PMDSignalNegativeLimitMask | PMDSignalMotorOutputInvertMask);
			break;
			
			case (AxisPitch):
				 PMDSetSignalSense(&hAxis[axis],
    562a:	ce 01       	movw	r24, r28
    562c:	68 e3       	ldi	r22, 0x38	; 56
    562e:	70 e1       	ldi	r23, 0x10	; 16
    5630:	06 c0       	rjmp	.+12     	; 0x563e <PMDsetupChipsets_USB+0x64>
						PMDSignalEncoderHomeMask | PMDSignalPositiveLimitMask |
						PMDSignalNegativeLimitMask |PMDSignalMotorOutputInvertMask);
			break;
			
			case (AxisRoll):
				 PMDSetSignalSense(&hAxis[axis],
    5632:	ce 01       	movw	r24, r28
    5634:	02 c0       	rjmp	.+4      	; 0x563a <PMDsetupChipsets_USB+0x60>
						PMDSignalPositiveLimitMask |PMDSignalNegativeLimitMask | PMDSignalMotorOutputInvertMask);
			break;
			
			default:
				 PMDSetSignalSense(&hAxis[axis],
    5636:	81 2f       	mov	r24, r17
    5638:	90 2f       	mov	r25, r16
    563a:	60 e3       	ldi	r22, 0x30	; 48
    563c:	70 e1       	ldi	r23, 0x10	; 16
    563e:	0e 94 a1 63 	call	0xc742	; 0xc742 <PMDSetSignalSense>
						PMDSignalPositiveLimitMask |PMDSignalNegativeLimitMask | PMDSignalMotorOutputInvertMask);
			break;
			
		}			
		if((hAxis[axis].axisSettings.switchEnable == TRUE) && 
    5642:	8e 81       	ldd	r24, Y+6	; 0x06
    5644:	9f 81       	ldd	r25, Y+7	; 0x07
    5646:	01 97       	sbiw	r24, 0x01	; 1
    5648:	41 f4       	brne	.+16     	; 0x565a <PMDsetupChipsets_USB+0x80>
    564a:	8c 81       	ldd	r24, Y+4	; 0x04
    564c:	81 30       	cpi	r24, 0x01	; 1
    564e:	29 f4       	brne	.+10     	; 0x565a <PMDsetupChipsets_USB+0x80>
		(hAxis[axis].axisSettings.axisEnabled==TRUE))
		{
			//Se Habilitan los Switches de Fin de Carrera
			PMDSetLimitSwitchMode(&hAxis[axis],PMDLimitEnabled);
    5650:	81 2f       	mov	r24, r17
    5652:	90 2f       	mov	r25, r16
    5654:	61 e0       	ldi	r22, 0x01	; 1
    5656:	70 e0       	ldi	r23, 0x00	; 0
    5658:	04 c0       	rjmp	.+8      	; 0x5662 <PMDsetupChipsets_USB+0x88>
		}
		else
		{
			////Se deshabilitan los Switches de Fin de Carrera
			PMDSetLimitSwitchMode(&hAxis[axis],PMDLimitDisabled);
    565a:	81 2f       	mov	r24, r17
    565c:	90 2f       	mov	r25, r16
    565e:	60 e0       	ldi	r22, 0x00	; 0
    5660:	70 e0       	ldi	r23, 0x00	; 0
    5662:	0e 94 ef 63 	call	0xc7de	; 0xc7de <PMDSetLimitSwitchMode>
		}
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config switch %d\n",axis);
		#endif
		PMDSetPhaseCounts(&hAxis[axis],(4*hAxis[axis].axisSettings.ustepsPerStep)); 
    5666:	6e 85       	ldd	r22, Y+14	; 0x0e
    5668:	7f 85       	ldd	r23, Y+15	; 0x0f
    566a:	66 0f       	add	r22, r22
    566c:	77 1f       	adc	r23, r23
    566e:	66 0f       	add	r22, r22
    5670:	77 1f       	adc	r23, r23
    5672:	81 2f       	mov	r24, r17
    5674:	90 2f       	mov	r25, r16
    5676:	0e 94 59 63 	call	0xc6b2	; 0xc6b2 <PMDSetPhaseCounts>
		//configuracion de Encoder
		PMDSetTrackingWindow(&hAxis[axis], hAxis[axis].axisSettings.TrackingWindow);
    567a:	6c 89       	ldd	r22, Y+20	; 0x14
    567c:	7d 89       	ldd	r23, Y+21	; 0x15
    567e:	81 2f       	mov	r24, r17
    5680:	90 2f       	mov	r25, r16
    5682:	0e 94 c5 63 	call	0xc78a	; 0xc78a <PMDSetTrackingWindow>
		printf("PMDsetupChipsets_dummy=> hAxis[%d].axisSettings.ustepsPerStep= %d\n",axis,hAxis[axis].axisSettings.ustepsPerStep);
		#endif

		
		//se habilitan las funciones de encoder
		if((hAxis[axis].axisSettings.encoderEnable == TRUE) && 
    5686:	88 85       	ldd	r24, Y+8	; 0x08
    5688:	99 85       	ldd	r25, Y+9	; 0x09
    568a:	01 97       	sbiw	r24, 0x01	; 1
    568c:	11 f5       	brne	.+68     	; 0x56d2 <PMDsetupChipsets_USB+0xf8>
    568e:	8c 81       	ldd	r24, Y+4	; 0x04
    5690:	81 30       	cpi	r24, 0x01	; 1
    5692:	f9 f4       	brne	.+62     	; 0x56d2 <PMDsetupChipsets_USB+0xf8>
                   (hAxis[axis].axisSettings.axisEnabled==TRUE))
		{
			PMDSetSettleWindow(&hAxis[axis], hAxis[axis].axisSettings.SettleWindow);
    5694:	6e 89       	ldd	r22, Y+22	; 0x16
    5696:	7f 89       	ldd	r23, Y+23	; 0x17
    5698:	81 2f       	mov	r24, r17
    569a:	90 2f       	mov	r25, r16
    569c:	0e 94 cb 63 	call	0xc796	; 0xc796 <PMDSetSettleWindow>
			PMDSetSettleTime(&hAxis[axis], hAxis[axis].axisSettings.SettleTime);
    56a0:	68 8d       	ldd	r22, Y+24	; 0x18
    56a2:	79 8d       	ldd	r23, Y+25	; 0x19
    56a4:	81 2f       	mov	r24, r17
    56a6:	90 2f       	mov	r25, r16
    56a8:	0e 94 d1 63 	call	0xc7a2	; 0xc7a2 <PMDSetSettleTime>
		    PMDSetMotionCompleteMode(&hAxis[axis],PMDMotionCompleteActualPosition); //  automatic correction of errors
    56ac:	81 2f       	mov	r24, r17
    56ae:	90 2f       	mov	r25, r16
    56b0:	61 e0       	ldi	r22, 0x01	; 1
    56b2:	70 e0       	ldi	r23, 0x00	; 0
    56b4:	0e 94 bf 63 	call	0xc77e	; 0xc77e <PMDSetMotionCompleteMode>
			//PMDSetPositionErrorLimit(&hAxis[axis],(30*hAxis[axis].axisSettings.ustepsPerStep
			//					 *hAxis[axis].axisSettings.motorStepsPerRevolution)/
			//					 hAxis[axis].axisSettings.encoderStepsPerRevolution);
			PMDSetPositionErrorLimit(&hAxis[axis],hAxis[axis].axisSettings.ErrorLimit);
    56b8:	4c a1       	ldd	r20, Y+36	; 0x24
    56ba:	5d a1       	ldd	r21, Y+37	; 0x25
    56bc:	6e a1       	ldd	r22, Y+38	; 0x26
    56be:	7f a1       	ldd	r23, Y+39	; 0x27
    56c0:	81 2f       	mov	r24, r17
    56c2:	90 2f       	mov	r25, r16
    56c4:	0e 94 bb 67 	call	0xcf76	; 0xcf76 <PMDSetPositionErrorLimit>
			
			PMDClearPositionError(&hAxis[axis]);
    56c8:	81 2f       	mov	r24, r17
    56ca:	90 2f       	mov	r25, r16
    56cc:	0e 94 74 65 	call	0xcae8	; 0xcae8 <PMDClearPositionError>
    56d0:	06 c0       	rjmp	.+12     	; 0x56de <PMDsetupChipsets_USB+0x104>
		}	
		else
		{
			PMDSetMotionCompleteMode(&hAxis[axis],PMDMotionCompleteCommandedPosition); // no automatic correction of errors
    56d2:	81 2f       	mov	r24, r17
    56d4:	90 2f       	mov	r25, r16
    56d6:	60 e0       	ldi	r22, 0x00	; 0
    56d8:	70 e0       	ldi	r23, 0x00	; 0
    56da:	0e 94 bf 63 	call	0xc77e	; 0xc77e <PMDSetMotionCompleteMode>
		}
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config SetSeetWindows,Settle time, Motion Complete,Pos. Error limit, Pos. error %d\n",axis);
		#endif
		//Fija la potencia del motor o torque
		PMDSetMotorCommand(&hAxis[axis],(hAxis[axis].axisSettings.motorPower*32768)/100);
    56de:	6a 8d       	ldd	r22, Y+26	; 0x1a
    56e0:	7b 8d       	ldd	r23, Y+27	; 0x1b
    56e2:	88 27       	eor	r24, r24
    56e4:	77 fd       	sbrc	r23, 7
    56e6:	80 95       	com	r24
    56e8:	98 2f       	mov	r25, r24
    56ea:	ef e0       	ldi	r30, 0x0F	; 15
    56ec:	66 0f       	add	r22, r22
    56ee:	77 1f       	adc	r23, r23
    56f0:	88 1f       	adc	r24, r24
    56f2:	99 1f       	adc	r25, r25
    56f4:	ea 95       	dec	r30
    56f6:	d1 f7       	brne	.-12     	; 0x56ec <PMDsetupChipsets_USB+0x112>
    56f8:	24 e6       	ldi	r18, 0x64	; 100
    56fa:	30 e0       	ldi	r19, 0x00	; 0
    56fc:	40 e0       	ldi	r20, 0x00	; 0
    56fe:	50 e0       	ldi	r21, 0x00	; 0
    5700:	0e 94 ac 85 	call	0x10b58	; 0x10b58 <__divmodsi4>
    5704:	81 2f       	mov	r24, r17
    5706:	90 2f       	mov	r25, r16
    5708:	b9 01       	movw	r22, r18
    570a:	0e 94 77 63 	call	0xc6ee	; 0xc6ee <PMDSetMotorCommand>
		//Se selecciona un tipo de perfil
		PMDSetProfileMode(&hAxis[axis],Profile);   // data interpretation mode
    570e:	81 2f       	mov	r24, r17
    5710:	90 2f       	mov	r25, r16
    5712:	6e 2d       	mov	r22, r14
    5714:	70 e0       	ldi	r23, 0x00	; 0
    5716:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
		//Detiene el motor cuando se produce un error en el movimiento (Motion Error).
		PMDSetAutoStopMode(&hAxis[axis],PMDAutoStopDisabled); 		
    571a:	81 2f       	mov	r24, r17
    571c:	90 2f       	mov	r25, r16
    571e:	60 e0       	ldi	r22, 0x00	; 0
    5720:	70 e0       	ldi	r23, 0x00	; 0
    5722:	0e 94 dd 63 	call	0xc7ba	; 0xc7ba <PMDSetAutoStopMode>
		
		PMDResetEventStatus(&hAxis[axis],~PMDEventStatusMask);
    5726:	81 2f       	mov	r24, r17
    5728:	90 2f       	mov	r25, r16
    572a:	60 e0       	ldi	r22, 0x00	; 0
    572c:	77 eb       	ldi	r23, 0xB7	; 183
    572e:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
		PMDClearInterrupt(&hAxis[axis]);
    5732:	81 2f       	mov	r24, r17
    5734:	90 2f       	mov	r25, r16
    5736:	0e 94 59 65 	call	0xcab2	; 0xcab2 <PMDClearInterrupt>
		PMDUpdate(&hAxis[axis]);
    573a:	81 2f       	mov	r24, r17
    573c:	90 2f       	mov	r25, r16
    573e:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
	uint8_t axis;
	PMDuint16 PMDrc;

  // look for a handle of every chipset to reset it...look for axis=1
	
	for(axis=0; axis < DOF; axis++)
    5742:	f3 94       	inc	r15
    5744:	c0 5a       	subi	r28, 0xA0	; 160
    5746:	df 4f       	sbci	r29, 0xFF	; 255
    5748:	85 e0       	ldi	r24, 0x05	; 5
    574a:	f8 16       	cp	r15, r24
    574c:	09 f0       	breq	.+2      	; 0x5750 <PMDsetupChipsets_USB+0x176>
    574e:	4f cf       	rjmp	.-354    	; 0x55ee <PMDsetupChipsets_USB+0x14>
    5750:	20 e0       	ldi	r18, 0x00	; 0
    5752:	30 e0       	ldi	r19, 0x00	; 0
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config AxisMode,Motor Mode, Motor power,Auto Stop, Reset Event, Clear INT,Update  %d\n",axis);
		#endif		
	}	
	return rcOK;
}
    5754:	c9 01       	movw	r24, r18
    5756:	df 91       	pop	r29
    5758:	cf 91       	pop	r28
    575a:	1f 91       	pop	r17
    575c:	0f 91       	pop	r16
    575e:	ff 90       	pop	r15
    5760:	ef 90       	pop	r14
    5762:	08 95       	ret

00005764 <PMDChipsetReset>:
	return rcOK;
} 

/*********************************************************************************************/
PMDresult PMDChipsetReset(PMDAxisHandle* handle)  //Queda igual
{
    5764:	0f 93       	push	r16
    5766:	1f 93       	push	r17
    5768:	df 93       	push	r29
    576a:	cf 93       	push	r28
    576c:	00 d0       	rcall	.+0      	; 0x576e <PMDChipsetReset+0xa>
    576e:	cd b7       	in	r28, 0x3d	; 61
    5770:	de b7       	in	r29, 0x3e	; 62
    5772:	8c 01       	movw	r16, r24
	PMDuint16 result;
	PMDuint16 status;
	 
   // reset the PMD chip set that this axis resides on
	// if more than one chip set is present, all of them should be reset here
	result = PMDReset(handle);
    5774:	0e 94 3e 65 	call	0xca7c	; 0xca7c <PMDReset>
	// with the parallel interface the result code will always be
	// PMD_ERR_CommandError since that bit is set whenever a reset
	// occurs.  If it ISN'T set then there is some other error
	if ( result == PMD_ERR_CommandError)
    5778:	8f 5f       	subi	r24, 0xFF	; 255
    577a:	9f 47       	sbci	r25, 0x7F	; 127
    577c:	99 f4       	brne	.+38     	; 0x57a4 <PMDChipsetReset+0x40>
	{
		result = PMDGetHostIOError(handle, &status);
    577e:	c8 01       	movw	r24, r16
    5780:	be 01       	movw	r22, r28
    5782:	6f 5f       	subi	r22, 0xFF	; 255
    5784:	7f 4f       	sbci	r23, 0xFF	; 255
    5786:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
	   if ((result == PMD_ERR_OK) && (status == PMD_ERR_ChipsetReset))			 
    578a:	89 2b       	or	r24, r25
    578c:	59 f4       	brne	.+22     	; 0x57a4 <PMDChipsetReset+0x40>
    578e:	89 81       	ldd	r24, Y+1	; 0x01
    5790:	9a 81       	ldd	r25, Y+2	; 0x02
    5792:	01 97       	sbiw	r24, 0x01	; 1
    5794:	39 f4       	brne	.+14     	; 0x57a4 <PMDChipsetReset+0x40>
		{
			printf("PMDChipsetReset => PMDreset ejecutado correctamente\n\n");
    5796:	84 e0       	ldi	r24, 0x04	; 4
    5798:	98 e4       	ldi	r25, 0x48	; 72
    579a:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    579e:	20 e0       	ldi	r18, 0x00	; 0
    57a0:	30 e0       	ldi	r19, 0x00	; 0
    57a2:	06 c0       	rjmp	.+12     	; 0x57b0 <PMDChipsetReset+0x4c>
			return rcOK;
		}
	}		 
	printf("PMDChipsetReset => PMDreset ejecutado INCORECTAMENTE!\n\n");
    57a4:	89 e3       	ldi	r24, 0x39	; 57
    57a6:	98 e4       	ldi	r25, 0x48	; 72
    57a8:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    57ac:	2e e0       	ldi	r18, 0x0E	; 14
    57ae:	30 e0       	ldi	r19, 0x00	; 0
  	return rcPMDChipsetResetError; //al main principal USAMOS rc........
} // PMDChipsetReset	
    57b0:	c9 01       	movw	r24, r18
    57b2:	0f 90       	pop	r0
    57b4:	0f 90       	pop	r0
    57b6:	cf 91       	pop	r28
    57b8:	df 91       	pop	r29
    57ba:	1f 91       	pop	r17
    57bc:	0f 91       	pop	r16
    57be:	08 95       	ret

000057c0 <PMDsetupChipSets>:
	return rc;

}
/*********************************************************************************************/
PMDresult PMDsetupChipSets(PMDProfileMode Profile) 
{
    57c0:	ef 92       	push	r14
    57c2:	ff 92       	push	r15
    57c4:	0f 93       	push	r16
    57c6:	1f 93       	push	r17
    57c8:	cf 93       	push	r28
    57ca:	df 93       	push	r29
    57cc:	e8 2e       	mov	r14, r24
    57ce:	c4 e7       	ldi	r28, 0x74	; 116
    57d0:	dd e7       	ldi	r29, 0x7D	; 125
	PMDuint16 PMDrc,EncodertoStepRatio;

  // look for a handle of every chipset to reset it...look for axis=1
  for(axis=0; axis < DOF; axis++)
	{
		if(hAxis[axis].axis == 0)  
    57d2:	8a 81       	ldd	r24, Y+2	; 0x02
    57d4:	9b 81       	ldd	r25, Y+3	; 0x03
    57d6:	89 2b       	or	r24, r25
    57d8:	41 f4       	brne	.+16     	; 0x57ea <PMDsetupChipSets+0x2a>
		{
			PMDChipsetReset(&hAxis[axis]);	
    57da:	ce 01       	movw	r24, r28
    57dc:	0e 94 b2 2b 	call	0x5764	; 0x5764 <PMDChipsetReset>
			/* "calibrate" the velocity and acceleration settings: adjust the sampling time (cycle time)
			minimum 4axis*154us/axis, max. value 65536us */
			PMDSetSampleTime(&hAxis[axis],4*150);			
    57e0:	ce 01       	movw	r24, r28
    57e2:	68 e5       	ldi	r22, 0x58	; 88
    57e4:	72 e0       	ldi	r23, 0x02	; 2
    57e6:	0e 94 b9 63 	call	0xc772	; 0xc772 <PMDSetSampleTime>
    57ea:	c0 5a       	subi	r28, 0xA0	; 160
    57ec:	df 4f       	sbci	r29, 0xFF	; 255
{
	uint8_t axis;
	PMDuint16 PMDrc,EncodertoStepRatio;

  // look for a handle of every chipset to reset it...look for axis=1
  for(axis=0; axis < DOF; axis++)
    57ee:	8f e7       	ldi	r24, 0x7F	; 127
    57f0:	c4 35       	cpi	r28, 0x54	; 84
    57f2:	d8 07       	cpc	r29, r24
    57f4:	71 f7       	brne	.-36     	; 0x57d2 <PMDsetupChipSets+0x12>
    57f6:	08 e7       	ldi	r16, 0x78	; 120
    57f8:	1d e7       	ldi	r17, 0x7D	; 125
    57fa:	ff 24       	eor	r15, r15
    57fc:	e8 01       	movw	r28, r16
    57fe:	24 97       	sbiw	r28, 0x04	; 4
	
	for(axis=0; axis < DOF; axis++)
	{
		
		//FIja la unidad del registo Actual position a uPasos
		PMDrc = PMDSetActualPositionUnits(&hAxis[axis],PMDSteps);     
    5800:	ce 01       	movw	r24, r28
    5802:	61 e0       	ldi	r22, 0x01	; 1
    5804:	70 e0       	ldi	r23, 0x00	; 0
    5806:	0e 94 9b 63 	call	0xc736	; 0xc736 <PMDSetActualPositionUnits>
		if(PMDrc != PMD_ERR_OK) 
    580a:	89 2b       	or	r24, r25
    580c:	19 f0       	breq	.+6      	; 0x5814 <PMDsetupChipSets+0x54>
    580e:	2d e0       	ldi	r18, 0x0D	; 13
    5810:	30 e0       	ldi	r19, 0x00	; 0
    5812:	db c0       	rjmp	.+438    	; 0x59ca <PMDsetupChipSets+0x20a>
		{
			return rcHardwareFailure;  // PMD didn't answer... comment 
										// out if UC should continue!		
		}		
		
		switch (axis)
    5814:	e2 e0       	ldi	r30, 0x02	; 2
    5816:	fe 16       	cp	r15, r30
    5818:	79 f0       	breq	.+30     	; 0x5838 <PMDsetupChipSets+0x78>
    581a:	ef 15       	cp	r30, r15
    581c:	30 f0       	brcs	.+12     	; 0x582a <PMDsetupChipSets+0x6a>
    581e:	ff 20       	and	r15, r15
    5820:	b9 f0       	breq	.+46     	; 0x5850 <PMDsetupChipSets+0x90>
    5822:	f1 e0       	ldi	r31, 0x01	; 1
    5824:	ff 16       	cp	r15, r31
    5826:	a1 f4       	brne	.+40     	; 0x5850 <PMDsetupChipSets+0x90>
    5828:	07 c0       	rjmp	.+14     	; 0x5838 <PMDsetupChipSets+0x78>
    582a:	83 e0       	ldi	r24, 0x03	; 3
    582c:	f8 16       	cp	r15, r24
    582e:	41 f0       	breq	.+16     	; 0x5840 <PMDsetupChipSets+0x80>
    5830:	e4 e0       	ldi	r30, 0x04	; 4
    5832:	fe 16       	cp	r15, r30
    5834:	69 f4       	brne	.+26     	; 0x5850 <PMDsetupChipSets+0x90>
    5836:	08 c0       	rjmp	.+16     	; 0x5848 <PMDsetupChipSets+0x88>
						PMDSignalEncoderHomeMask | PMDSignalPositiveLimitMask |
						PMDSignalNegativeLimitMask | PMDSignalMotorOutputInvertMask);
			break;
			
			case (AxisElbow):
				 PMDSetSignalSense(&hAxis[axis],
    5838:	ce 01       	movw	r24, r28
    583a:	68 e3       	ldi	r22, 0x38	; 56
    583c:	70 e1       	ldi	r23, 0x10	; 16
    583e:	0b c0       	rjmp	.+22     	; 0x5856 <PMDsetupChipSets+0x96>
						PMDSignalEncoderHomeMask |PMDSignalPositiveLimitMask |
						PMDSignalNegativeLimitMask | PMDSignalMotorOutputInvertMask);
			break;
			
			case (AxisPitch):
				 PMDSetSignalSense(&hAxis[axis],
    5840:	ce 01       	movw	r24, r28
    5842:	68 e3       	ldi	r22, 0x38	; 56
    5844:	70 e0       	ldi	r23, 0x00	; 0
    5846:	07 c0       	rjmp	.+14     	; 0x5856 <PMDsetupChipSets+0x96>
						PMDSignalEncoderHomeMask |PMDSignalPositiveLimitMask |
						PMDSignalNegativeLimitMask);
			break;
			
			case (AxisRoll):
				 PMDSetSignalSense(&hAxis[axis],
    5848:	ce 01       	movw	r24, r28
    584a:	60 e3       	ldi	r22, 0x30	; 48
    584c:	70 e0       	ldi	r23, 0x00	; 0
    584e:	03 c0       	rjmp	.+6      	; 0x5856 <PMDsetupChipSets+0x96>
						PMDSignalPositiveLimitMask |PMDSignalNegativeLimitMask);
			break;
			
			default:
				 PMDSetSignalSense(&hAxis[axis],
    5850:	ce 01       	movw	r24, r28
    5852:	60 e3       	ldi	r22, 0x30	; 48
    5854:	70 e1       	ldi	r23, 0x10	; 16
    5856:	0e 94 a1 63 	call	0xc742	; 0xc742 <PMDSetSignalSense>
			
		}	
		
		
		
		if((hAxis[axis].axisSettings.switchEnable == TRUE) && 
    585a:	f8 01       	movw	r30, r16
    585c:	82 81       	ldd	r24, Z+2	; 0x02
    585e:	93 81       	ldd	r25, Z+3	; 0x03
    5860:	01 97       	sbiw	r24, 0x01	; 1
    5862:	39 f4       	brne	.+14     	; 0x5872 <PMDsetupChipSets+0xb2>
    5864:	80 81       	ld	r24, Z
    5866:	81 30       	cpi	r24, 0x01	; 1
    5868:	21 f4       	brne	.+8      	; 0x5872 <PMDsetupChipSets+0xb2>
		(hAxis[axis].axisSettings.axisEnabled==TRUE))
		{
			//Se Habilitan los Switches de Fin de Carrera
			PMDSetLimitSwitchMode(&hAxis[axis],PMDLimitEnabled);
    586a:	ce 01       	movw	r24, r28
    586c:	61 e0       	ldi	r22, 0x01	; 1
    586e:	70 e0       	ldi	r23, 0x00	; 0
    5870:	03 c0       	rjmp	.+6      	; 0x5878 <PMDsetupChipSets+0xb8>
		}
		else
		{
			////Se deshabilitan los Switches de Fin de Carrera
			PMDSetLimitSwitchMode(&hAxis[axis],PMDLimitDisabled);
    5872:	ce 01       	movw	r24, r28
    5874:	60 e0       	ldi	r22, 0x00	; 0
    5876:	70 e0       	ldi	r23, 0x00	; 0
    5878:	0e 94 ef 63 	call	0xc7de	; 0xc7de <PMDSetLimitSwitchMode>
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config switch %d\n",axis);
		#endif

		// Tipo de salida PWM 50/50
		PMDSetOutputMode(&hAxis[axis],PMDMotorOutputPWM5050Magnitude);  
    587c:	ce 01       	movw	r24, r28
    587e:	62 e0       	ldi	r22, 0x02	; 2
    5880:	70 e0       	ldi	r23, 0x00	; 0
    5882:	0e 94 83 63 	call	0xc706	; 0xc706 <PMDSetOutputMode>
		//numero de fasese del motor 3
		PMDSetNumberPhases(&hAxis[axis],hAxis[axis].axisSettings.numberPhases);
    5886:	f8 01       	movw	r30, r16
    5888:	60 8d       	ldd	r22, Z+24	; 0x18
    588a:	71 8d       	ldd	r23, Z+25	; 0x19
    588c:	ce 01       	movw	r24, r28
    588e:	0e 94 6b 63 	call	0xc6d6	; 0xc6d6 <PMDSetNumberPhases>
		//numero de pasos por upaso, esta funcion esta en Counts. 1 Counts = 4 uPasos
		PMDSetPhaseCounts(&hAxis[axis],(4*hAxis[axis].axisSettings.ustepsPerStep)); 
    5892:	f8 01       	movw	r30, r16
    5894:	62 85       	ldd	r22, Z+10	; 0x0a
    5896:	73 85       	ldd	r23, Z+11	; 0x0b
    5898:	66 0f       	add	r22, r22
    589a:	77 1f       	adc	r23, r23
    589c:	66 0f       	add	r22, r22
    589e:	77 1f       	adc	r23, r23
    58a0:	ce 01       	movw	r24, r28
    58a2:	0e 94 59 63 	call	0xc6b2	; 0xc6b2 <PMDSetPhaseCounts>
		//configuracion de Encoder
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> uPasos = %d \n",hAxis[axis].axisSettings.ustepsPerStep);
		#endif
		
		PMDSetEncoderSource(&hAxis[axis],PMDEncoderSourceIncremental);  // incremental quadrature encoder
    58a6:	ce 01       	movw	r24, r28
    58a8:	60 e0       	ldi	r22, 0x00	; 0
    58aa:	70 e0       	ldi	r23, 0x00	; 0
    58ac:	0e 94 8f 63 	call	0xc71e	; 0xc71e <PMDSetEncoderSource>
			//(pulses per round), (microsteps per step)*(steps per round)
		
		EncodertoStepRatio=hAxis[axis].axisSettings.ustepsPerStep*
										hAxis[axis].axisSettings.motorStepsPerRevolution;
		
			PMDSetEncoderToStepRatio(&hAxis[axis],hAxis[axis].axisSettings.encoderStepsPerRevolution
    58b0:	f8 01       	movw	r30, r16
    58b2:	66 85       	ldd	r22, Z+14	; 0x0e
    58b4:	77 85       	ldd	r23, Z+15	; 0x0f
    58b6:	24 85       	ldd	r18, Z+12	; 0x0c
    58b8:	35 85       	ldd	r19, Z+13	; 0x0d
    58ba:	82 85       	ldd	r24, Z+10	; 0x0a
    58bc:	93 85       	ldd	r25, Z+11	; 0x0b
    58be:	28 9f       	mul	r18, r24
    58c0:	a0 01       	movw	r20, r0
    58c2:	29 9f       	mul	r18, r25
    58c4:	50 0d       	add	r21, r0
    58c6:	38 9f       	mul	r19, r24
    58c8:	50 0d       	add	r21, r0
    58ca:	11 24       	eor	r1, r1
    58cc:	ce 01       	movw	r24, r28
    58ce:	0e 94 3d 66 	call	0xcc7a	; 0xcc7a <PMDSetEncoderToStepRatio>
									,EncodertoStepRatio);
	 	
		PMDSetTrackingWindow(&hAxis[axis], hAxis[axis].axisSettings.TrackingWindow);
    58d2:	f8 01       	movw	r30, r16
    58d4:	60 89       	ldd	r22, Z+16	; 0x10
    58d6:	71 89       	ldd	r23, Z+17	; 0x11
    58d8:	ce 01       	movw	r24, r28
    58da:	0e 94 c5 63 	call	0xc78a	; 0xc78a <PMDSetTrackingWindow>
		printf("PMDsetupChipsets_dummy=> config Outputmode, #Phases, PhaseCounts,Encoder Source, EncoderRatio %d\n",axis);
		#endif

		
		//se habilitan las funciones de encoder
		if((hAxis[axis].axisSettings.encoderEnable == TRUE) && 
    58de:	f8 01       	movw	r30, r16
    58e0:	84 81       	ldd	r24, Z+4	; 0x04
    58e2:	95 81       	ldd	r25, Z+5	; 0x05
    58e4:	01 97       	sbiw	r24, 0x01	; 1
    58e6:	f9 f4       	brne	.+62     	; 0x5926 <PMDsetupChipSets+0x166>
    58e8:	80 81       	ld	r24, Z
    58ea:	81 30       	cpi	r24, 0x01	; 1
    58ec:	e1 f4       	brne	.+56     	; 0x5926 <PMDsetupChipSets+0x166>
			(hAxis[axis].axisSettings.axisEnabled==TRUE))
		{
			PMDSetSettleWindow(&hAxis[axis], hAxis[axis].axisSettings.SettleWindow);
    58ee:	62 89       	ldd	r22, Z+18	; 0x12
    58f0:	73 89       	ldd	r23, Z+19	; 0x13
    58f2:	ce 01       	movw	r24, r28
    58f4:	0e 94 cb 63 	call	0xc796	; 0xc796 <PMDSetSettleWindow>
			PMDSetSettleTime(&hAxis[axis], hAxis[axis].axisSettings.SettleTime);
    58f8:	f8 01       	movw	r30, r16
    58fa:	64 89       	ldd	r22, Z+20	; 0x14
    58fc:	75 89       	ldd	r23, Z+21	; 0x15
    58fe:	ce 01       	movw	r24, r28
    5900:	0e 94 d1 63 	call	0xc7a2	; 0xc7a2 <PMDSetSettleTime>
		    PMDSetMotionCompleteMode(&hAxis[axis],PMDMotionCompleteActualPosition); //  automatic correction of errors
    5904:	ce 01       	movw	r24, r28
    5906:	61 e0       	ldi	r22, 0x01	; 1
    5908:	70 e0       	ldi	r23, 0x00	; 0
    590a:	0e 94 bf 63 	call	0xc77e	; 0xc77e <PMDSetMotionCompleteMode>
			//PMDSetPositionErrorLimit(&hAxis[axis],(30*hAxis[axis].axisSettings.ustepsPerStep
			//					 *hAxis[axis].axisSettings.motorStepsPerRevolution)/
			//					 hAxis[axis].axisSettings.encoderStepsPerRevolution);
			PMDSetPositionErrorLimit(&hAxis[axis],hAxis[axis].axisSettings.ErrorLimit);
    590e:	f8 01       	movw	r30, r16
    5910:	40 a1       	ldd	r20, Z+32	; 0x20
    5912:	51 a1       	ldd	r21, Z+33	; 0x21
    5914:	62 a1       	ldd	r22, Z+34	; 0x22
    5916:	73 a1       	ldd	r23, Z+35	; 0x23
    5918:	ce 01       	movw	r24, r28
    591a:	0e 94 bb 67 	call	0xcf76	; 0xcf76 <PMDSetPositionErrorLimit>
			
			PMDClearPositionError(&hAxis[axis]);
    591e:	ce 01       	movw	r24, r28
    5920:	0e 94 74 65 	call	0xcae8	; 0xcae8 <PMDClearPositionError>
    5924:	05 c0       	rjmp	.+10     	; 0x5930 <PMDsetupChipSets+0x170>
		}	
		else
		{
			PMDSetMotionCompleteMode(&hAxis[axis],PMDMotionCompleteCommandedPosition); // no automatic correction of errors
    5926:	ce 01       	movw	r24, r28
    5928:	60 e0       	ldi	r22, 0x00	; 0
    592a:	70 e0       	ldi	r23, 0x00	; 0
    592c:	0e 94 bf 63 	call	0xc77e	; 0xc77e <PMDSetMotionCompleteMode>
			
		}
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config SetSeetWindows,Settle time, Motion Complete,Pos. Error limit, Pos. error %d\n",axis);
		#endif
		if(hAxis[axis].axisSettings.axisEnabled==TRUE) 
    5930:	f8 01       	movw	r30, r16
    5932:	80 81       	ld	r24, Z
    5934:	81 30       	cpi	r24, 0x01	; 1
    5936:	49 f4       	brne	.+18     	; 0x594a <PMDsetupChipSets+0x18a>
		{
			PMDSetAxisMode(&hAxis[axis],PMDAxisOn);              // enable Axis
    5938:	ce 01       	movw	r24, r28
    593a:	61 e0       	ldi	r22, 0x01	; 1
    593c:	70 e0       	ldi	r23, 0x00	; 0
    593e:	0e 94 a5 62 	call	0xc54a	; 0xc54a <PMDSetAxisMode>
			PMDSetMotorMode(&hAxis[axis],PMDMotorOn);            // enable trajectory generator
    5942:	ce 01       	movw	r24, r28
    5944:	61 e0       	ldi	r22, 0x01	; 1
    5946:	70 e0       	ldi	r23, 0x00	; 0
    5948:	08 c0       	rjmp	.+16     	; 0x595a <PMDsetupChipSets+0x19a>
		} 
		else 
		{
			PMDSetAxisMode(&hAxis[axis],PMDAxisOff);             // disable Axis
    594a:	ce 01       	movw	r24, r28
    594c:	60 e0       	ldi	r22, 0x00	; 0
    594e:	70 e0       	ldi	r23, 0x00	; 0
    5950:	0e 94 a5 62 	call	0xc54a	; 0xc54a <PMDSetAxisMode>
			PMDSetMotorMode(&hAxis[axis],PMDMotorOff);           // disable trajectory generator
    5954:	ce 01       	movw	r24, r28
    5956:	60 e0       	ldi	r22, 0x00	; 0
    5958:	70 e0       	ldi	r23, 0x00	; 0
    595a:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
		}
		//Fija la potencia del motor o torque
		PMDSetMotorCommand(&hAxis[axis],(hAxis[axis].axisSettings.motorPower*32768)/100);
    595e:	f8 01       	movw	r30, r16
    5960:	66 89       	ldd	r22, Z+22	; 0x16
    5962:	77 89       	ldd	r23, Z+23	; 0x17
    5964:	88 27       	eor	r24, r24
    5966:	77 fd       	sbrc	r23, 7
    5968:	80 95       	com	r24
    596a:	98 2f       	mov	r25, r24
    596c:	af e0       	ldi	r26, 0x0F	; 15
    596e:	66 0f       	add	r22, r22
    5970:	77 1f       	adc	r23, r23
    5972:	88 1f       	adc	r24, r24
    5974:	99 1f       	adc	r25, r25
    5976:	aa 95       	dec	r26
    5978:	d1 f7       	brne	.-12     	; 0x596e <PMDsetupChipSets+0x1ae>
    597a:	24 e6       	ldi	r18, 0x64	; 100
    597c:	30 e0       	ldi	r19, 0x00	; 0
    597e:	40 e0       	ldi	r20, 0x00	; 0
    5980:	50 e0       	ldi	r21, 0x00	; 0
    5982:	0e 94 ac 85 	call	0x10b58	; 0x10b58 <__divmodsi4>
    5986:	ce 01       	movw	r24, r28
    5988:	b9 01       	movw	r22, r18
    598a:	0e 94 77 63 	call	0xc6ee	; 0xc6ee <PMDSetMotorCommand>
		//Se selecciona un tipo de perfil
		PMDSetProfileMode(&hAxis[axis],Profile);   // data interpretation mode
    598e:	ce 01       	movw	r24, r28
    5990:	6e 2d       	mov	r22, r14
    5992:	70 e0       	ldi	r23, 0x00	; 0
    5994:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
		//Detiene el motor cuando se produce un error en el movimiento (Motion Error).
		PMDSetAutoStopMode(&hAxis[axis],PMDAutoStopDisabled); 		
    5998:	ce 01       	movw	r24, r28
    599a:	60 e0       	ldi	r22, 0x00	; 0
    599c:	70 e0       	ldi	r23, 0x00	; 0
    599e:	0e 94 dd 63 	call	0xc7ba	; 0xc7ba <PMDSetAutoStopMode>
		
		PMDResetEventStatus(&hAxis[axis],~PMDEventStatusMask);
    59a2:	ce 01       	movw	r24, r28
    59a4:	60 e0       	ldi	r22, 0x00	; 0
    59a6:	77 eb       	ldi	r23, 0xB7	; 183
    59a8:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
		PMDClearInterrupt(&hAxis[axis]);
    59ac:	ce 01       	movw	r24, r28
    59ae:	0e 94 59 65 	call	0xcab2	; 0xcab2 <PMDClearInterrupt>
		PMDUpdate(&hAxis[axis]);
    59b2:	ce 01       	movw	r24, r28
    59b4:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			#endif
		}
		
	}	
	
	for(axis=0; axis < DOF; axis++)
    59b8:	f3 94       	inc	r15
    59ba:	00 5a       	subi	r16, 0xA0	; 160
    59bc:	1f 4f       	sbci	r17, 0xFF	; 255
    59be:	f5 e0       	ldi	r31, 0x05	; 5
    59c0:	ff 16       	cp	r15, r31
    59c2:	09 f0       	breq	.+2      	; 0x59c6 <PMDsetupChipSets+0x206>
    59c4:	1b cf       	rjmp	.-458    	; 0x57fc <PMDsetupChipSets+0x3c>
    59c6:	20 e0       	ldi	r18, 0x00	; 0
    59c8:	30 e0       	ldi	r19, 0x00	; 0
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config AxisMode,Motor Mode, Motor power,Auto Stop, Reset Event, Clear INT,Update  %d\n",axis);
		#endif		
	}	
	return rcOK;
}
    59ca:	c9 01       	movw	r24, r18
    59cc:	df 91       	pop	r29
    59ce:	cf 91       	pop	r28
    59d0:	1f 91       	pop	r17
    59d2:	0f 91       	pop	r16
    59d4:	ff 90       	pop	r15
    59d6:	ef 90       	pop	r14
    59d8:	08 95       	ret

000059da <PMDchipsetOK>:
  	return rcPMDChipsetResetError; //al main principal USAMOS rc........
} // PMDChipsetReset	

/*********************************************************************************************/
PMDresult PMDchipsetOK(PMDuint16 PMDChipSet) // Le quite el parametro PMDAxisHandle* hAxis
{
    59da:	8f 92       	push	r8
    59dc:	9f 92       	push	r9
    59de:	af 92       	push	r10
    59e0:	bf 92       	push	r11
    59e2:	cf 92       	push	r12
    59e4:	df 92       	push	r13
    59e6:	ef 92       	push	r14
    59e8:	ff 92       	push	r15
    59ea:	0f 93       	push	r16
    59ec:	1f 93       	push	r17
    59ee:	df 93       	push	r29
    59f0:	cf 93       	push	r28
    59f2:	00 d0       	rcall	.+0      	; 0x59f4 <PMDchipsetOK+0x1a>
    59f4:	00 d0       	rcall	.+0      	; 0x59f6 <PMDchipsetOK+0x1c>
    59f6:	cd b7       	in	r28, 0x3d	; 61
    59f8:	de b7       	in	r29, 0x3e	; 62
    59fa:	6c 01       	movw	r12, r24
   PMDuint32 checksum=0;
    59fc:	19 82       	std	Y+1, r1	; 0x01
    59fe:	1a 82       	std	Y+2, r1	; 0x02
    5a00:	1b 82       	std	Y+3, r1	; 0x03
    5a02:	1c 82       	std	Y+4, r1	; 0x04
    5a04:	00 e0       	ldi	r16, 0x00	; 0
    5a06:	10 e0       	ldi	r17, 0x00	; 0
    5a08:	ee 24       	eor	r14, r14
    5a0a:	ff 24       	eor	r15, r15
	// before reading from the PMD, we must reset the chipsets  
  
	for(axis=0; axis < DOF; axis++) 
	{

      if(hAxis[axis].chipset == PMDChipSet) //Buscamos un AxisHandle para ese chipset
    5a0c:	90 e6       	ldi	r25, 0x60	; 96
    5a0e:	89 2e       	mov	r8, r25
    5a10:	91 2c       	mov	r9, r1
				return result;
			}
		  else
		   { 
				axistemp=axis;			 
				printf("PMDchipsetOK => Se ha reseteado el chipset %i con Axis %d\n",PMDChipSet,axis);	 
    5a12:	8f ea       	ldi	r24, 0xAF	; 175
    5a14:	a8 2e       	mov	r10, r24
    5a16:	88 e4       	ldi	r24, 0x48	; 72
    5a18:	b8 2e       	mov	r11, r24
	// before reading from the PMD, we must reset the chipsets  
  
	for(axis=0; axis < DOF; axis++) 
	{

      if(hAxis[axis].chipset == PMDChipSet) //Buscamos un AxisHandle para ese chipset
    5a1a:	08 9d       	mul	r16, r8
    5a1c:	f0 01       	movw	r30, r0
    5a1e:	09 9d       	mul	r16, r9
    5a20:	f0 0d       	add	r31, r0
    5a22:	18 9d       	mul	r17, r8
    5a24:	f0 0d       	add	r31, r0
    5a26:	11 24       	eor	r1, r1
    5a28:	ec 58       	subi	r30, 0x8C	; 140
    5a2a:	f2 48       	sbci	r31, 0x82	; 130
    5a2c:	80 81       	ld	r24, Z
    5a2e:	91 81       	ldd	r25, Z+1	; 0x01
    5a30:	8c 15       	cp	r24, r12
    5a32:	9d 05       	cpc	r25, r13
    5a34:	e9 f5       	brne	.+122    	; 0x5ab0 <PMDchipsetOK+0xd6>
	   {  
			result = PMDChipsetReset(&hAxis[axis]);
    5a36:	cf 01       	movw	r24, r30
    5a38:	0e 94 b2 2b 	call	0x5764	; 0x5764 <PMDChipsetReset>
    5a3c:	7c 01       	movw	r14, r24
	      if(result != rcOK)
    5a3e:	00 97       	sbiw	r24, 0x00	; 0
    5a40:	c9 f0       	breq	.+50     	; 0x5a74 <PMDchipsetOK+0x9a>
			{
				printf("PMDchipsetOK => No se pudo resetear el chipset %i con Axis %d\n",PMDChipSet,axis);
    5a42:	00 d0       	rcall	.+0      	; 0x5a44 <PMDchipsetOK+0x6a>
    5a44:	00 d0       	rcall	.+0      	; 0x5a46 <PMDchipsetOK+0x6c>
    5a46:	00 d0       	rcall	.+0      	; 0x5a48 <PMDchipsetOK+0x6e>
    5a48:	ed b7       	in	r30, 0x3d	; 61
    5a4a:	fe b7       	in	r31, 0x3e	; 62
    5a4c:	31 96       	adiw	r30, 0x01	; 1
    5a4e:	80 e7       	ldi	r24, 0x70	; 112
    5a50:	98 e4       	ldi	r25, 0x48	; 72
    5a52:	ad b7       	in	r26, 0x3d	; 61
    5a54:	be b7       	in	r27, 0x3e	; 62
    5a56:	12 96       	adiw	r26, 0x02	; 2
    5a58:	9c 93       	st	X, r25
    5a5a:	8e 93       	st	-X, r24
    5a5c:	11 97       	sbiw	r26, 0x01	; 1
    5a5e:	d3 82       	std	Z+3, r13	; 0x03
    5a60:	c2 82       	std	Z+2, r12	; 0x02
    5a62:	15 83       	std	Z+5, r17	; 0x05
    5a64:	04 83       	std	Z+4, r16	; 0x04
    5a66:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    5a6a:	2d b7       	in	r18, 0x3d	; 61
    5a6c:	3e b7       	in	r19, 0x3e	; 62
    5a6e:	2a 5f       	subi	r18, 0xFA	; 250
    5a70:	3f 4f       	sbci	r19, 0xFF	; 255
    5a72:	88 c0       	rjmp	.+272    	; 0x5b84 <PMDchipsetOK+0x1aa>
				return result;
			}
		  else
		   { 
				axistemp=axis;			 
				printf("PMDchipsetOK => Se ha reseteado el chipset %i con Axis %d\n",PMDChipSet,axis);	 
    5a74:	00 d0       	rcall	.+0      	; 0x5a76 <PMDchipsetOK+0x9c>
    5a76:	00 d0       	rcall	.+0      	; 0x5a78 <PMDchipsetOK+0x9e>
    5a78:	00 d0       	rcall	.+0      	; 0x5a7a <PMDchipsetOK+0xa0>
    5a7a:	ed b7       	in	r30, 0x3d	; 61
    5a7c:	fe b7       	in	r31, 0x3e	; 62
    5a7e:	31 96       	adiw	r30, 0x01	; 1
    5a80:	ad b7       	in	r26, 0x3d	; 61
    5a82:	be b7       	in	r27, 0x3e	; 62
    5a84:	12 96       	adiw	r26, 0x02	; 2
    5a86:	bc 92       	st	X, r11
    5a88:	ae 92       	st	-X, r10
    5a8a:	11 97       	sbiw	r26, 0x01	; 1
    5a8c:	d3 82       	std	Z+3, r13	; 0x03
    5a8e:	c2 82       	std	Z+2, r12	; 0x02
    5a90:	15 83       	std	Z+5, r17	; 0x05
    5a92:	04 83       	std	Z+4, r16	; 0x04
    5a94:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    5a98:	78 01       	movw	r14, r16
    5a9a:	05 e0       	ldi	r16, 0x05	; 5
    5a9c:	10 e0       	ldi	r17, 0x00	; 0
    5a9e:	2d b7       	in	r18, 0x3d	; 61
    5aa0:	3e b7       	in	r19, 0x3e	; 62
    5aa2:	2a 5f       	subi	r18, 0xFA	; 250
    5aa4:	3f 4f       	sbci	r19, 0xFF	; 255
    5aa6:	0f b6       	in	r0, 0x3f	; 63
    5aa8:	f8 94       	cli
    5aaa:	3e bf       	out	0x3e, r19	; 62
    5aac:	0f be       	out	0x3f, r0	; 63
    5aae:	2d bf       	out	0x3d, r18	; 61
   PMDresult result;
   int16 axis,axistemp=0;  
  
	// before reading from the PMD, we must reset the chipsets  
  
	for(axis=0; axis < DOF; axis++) 
    5ab0:	0f 5f       	subi	r16, 0xFF	; 255
    5ab2:	1f 4f       	sbci	r17, 0xFF	; 255
    5ab4:	05 30       	cpi	r16, 0x05	; 5
    5ab6:	11 05       	cpc	r17, r1
    5ab8:	0c f4       	brge	.+2      	; 0x5abc <PMDchipsetOK+0xe2>
    5aba:	af cf       	rjmp	.-162    	; 0x5a1a <PMDchipsetOK+0x40>
		   }
      }
	}
  
	// Leer el checksum del Chipset y comparar con 0x12345678
	printf("PMDchipsetOK =>Comprobando Checksum...\n");	
    5abc:	8a ee       	ldi	r24, 0xEA	; 234
    5abe:	98 e4       	ldi	r25, 0x48	; 72
    5ac0:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	result=PMDGetChecksum(&hAxis[axistemp],&checksum); 
    5ac4:	80 e6       	ldi	r24, 0x60	; 96
    5ac6:	90 e0       	ldi	r25, 0x00	; 0
    5ac8:	dc 01       	movw	r26, r24
    5aca:	ea 9e       	mul	r14, r26
    5acc:	c0 01       	movw	r24, r0
    5ace:	eb 9e       	mul	r14, r27
    5ad0:	90 0d       	add	r25, r0
    5ad2:	fa 9e       	mul	r15, r26
    5ad4:	90 0d       	add	r25, r0
    5ad6:	11 24       	eor	r1, r1
    5ad8:	8c 58       	subi	r24, 0x8C	; 140
    5ada:	92 48       	sbci	r25, 0x82	; 130
    5adc:	be 01       	movw	r22, r28
    5ade:	6f 5f       	subi	r22, 0xFF	; 255
    5ae0:	7f 4f       	sbci	r23, 0xFF	; 255
    5ae2:	0e 94 33 64 	call	0xc866	; 0xc866 <PMDGetChecksum>
	if(checksum != 0x12345678) //Esto esta definido en el manual de programacion .
    5ae6:	29 81       	ldd	r18, Y+1	; 0x01
    5ae8:	3a 81       	ldd	r19, Y+2	; 0x02
    5aea:	4b 81       	ldd	r20, Y+3	; 0x03
    5aec:	5c 81       	ldd	r21, Y+4	; 0x04
    5aee:	b6 01       	movw	r22, r12
    5af0:	6f 5f       	subi	r22, 0xFF	; 255
    5af2:	7f 4f       	sbci	r23, 0xFF	; 255
    5af4:	28 37       	cpi	r18, 0x78	; 120
    5af6:	b6 e5       	ldi	r27, 0x56	; 86
    5af8:	3b 07       	cpc	r19, r27
    5afa:	b4 e3       	ldi	r27, 0x34	; 52
    5afc:	4b 07       	cpc	r20, r27
    5afe:	b2 e1       	ldi	r27, 0x12	; 18
    5b00:	5b 07       	cpc	r21, r27
    5b02:	f9 f0       	breq	.+62     	; 0x5b42 <PMDchipsetOK+0x168>
	{
		printf("PMDchipsetOK =>PMD %i PMDchipset checksum test error: 0x12345678=>%lx\n",PMDChipSet+1,checksum);
    5b04:	8d b7       	in	r24, 0x3d	; 61
    5b06:	9e b7       	in	r25, 0x3e	; 62
    5b08:	08 97       	sbiw	r24, 0x08	; 8
    5b0a:	0f b6       	in	r0, 0x3f	; 63
    5b0c:	f8 94       	cli
    5b0e:	9e bf       	out	0x3e, r25	; 62
    5b10:	0f be       	out	0x3f, r0	; 63
    5b12:	8d bf       	out	0x3d, r24	; 61
    5b14:	ed b7       	in	r30, 0x3d	; 61
    5b16:	fe b7       	in	r31, 0x3e	; 62
    5b18:	31 96       	adiw	r30, 0x01	; 1
    5b1a:	81 e1       	ldi	r24, 0x11	; 17
    5b1c:	99 e4       	ldi	r25, 0x49	; 73
    5b1e:	ad b7       	in	r26, 0x3d	; 61
    5b20:	be b7       	in	r27, 0x3e	; 62
    5b22:	12 96       	adiw	r26, 0x02	; 2
    5b24:	9c 93       	st	X, r25
    5b26:	8e 93       	st	-X, r24
    5b28:	11 97       	sbiw	r26, 0x01	; 1
    5b2a:	73 83       	std	Z+3, r23	; 0x03
    5b2c:	62 83       	std	Z+2, r22	; 0x02
    5b2e:	24 83       	std	Z+4, r18	; 0x04
    5b30:	35 83       	std	Z+5, r19	; 0x05
    5b32:	46 83       	std	Z+6, r20	; 0x06
    5b34:	57 83       	std	Z+7, r21	; 0x07
    5b36:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    5b3a:	1f e0       	ldi	r17, 0x0F	; 15
    5b3c:	e1 2e       	mov	r14, r17
    5b3e:	f1 2c       	mov	r15, r1
    5b40:	1d c0       	rjmp	.+58     	; 0x5b7c <PMDchipsetOK+0x1a2>
		return rcPMDchecksumError;  // we got a wrong answer
	}
	printf("PMDchipsetOK =>PMD %i test succeeded %lx \n",PMDChipSet+1,checksum);
    5b42:	8d b7       	in	r24, 0x3d	; 61
    5b44:	9e b7       	in	r25, 0x3e	; 62
    5b46:	08 97       	sbiw	r24, 0x08	; 8
    5b48:	0f b6       	in	r0, 0x3f	; 63
    5b4a:	f8 94       	cli
    5b4c:	9e bf       	out	0x3e, r25	; 62
    5b4e:	0f be       	out	0x3f, r0	; 63
    5b50:	8d bf       	out	0x3d, r24	; 61
    5b52:	ed b7       	in	r30, 0x3d	; 61
    5b54:	fe b7       	in	r31, 0x3e	; 62
    5b56:	31 96       	adiw	r30, 0x01	; 1
    5b58:	88 e5       	ldi	r24, 0x58	; 88
    5b5a:	99 e4       	ldi	r25, 0x49	; 73
    5b5c:	ad b7       	in	r26, 0x3d	; 61
    5b5e:	be b7       	in	r27, 0x3e	; 62
    5b60:	12 96       	adiw	r26, 0x02	; 2
    5b62:	9c 93       	st	X, r25
    5b64:	8e 93       	st	-X, r24
    5b66:	11 97       	sbiw	r26, 0x01	; 1
    5b68:	73 83       	std	Z+3, r23	; 0x03
    5b6a:	62 83       	std	Z+2, r22	; 0x02
    5b6c:	24 83       	std	Z+4, r18	; 0x04
    5b6e:	35 83       	std	Z+5, r19	; 0x05
    5b70:	46 83       	std	Z+6, r20	; 0x06
    5b72:	57 83       	std	Z+7, r21	; 0x07
    5b74:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    5b78:	ee 24       	eor	r14, r14
    5b7a:	ff 24       	eor	r15, r15
    5b7c:	2d b7       	in	r18, 0x3d	; 61
    5b7e:	3e b7       	in	r19, 0x3e	; 62
    5b80:	28 5f       	subi	r18, 0xF8	; 248
    5b82:	3f 4f       	sbci	r19, 0xFF	; 255
    5b84:	0f b6       	in	r0, 0x3f	; 63
    5b86:	f8 94       	cli
    5b88:	3e bf       	out	0x3e, r19	; 62
    5b8a:	0f be       	out	0x3f, r0	; 63
    5b8c:	2d bf       	out	0x3d, r18	; 61
	return rcOK;
} 
    5b8e:	c7 01       	movw	r24, r14
    5b90:	0f 90       	pop	r0
    5b92:	0f 90       	pop	r0
    5b94:	0f 90       	pop	r0
    5b96:	0f 90       	pop	r0
    5b98:	cf 91       	pop	r28
    5b9a:	df 91       	pop	r29
    5b9c:	1f 91       	pop	r17
    5b9e:	0f 91       	pop	r16
    5ba0:	ff 90       	pop	r15
    5ba2:	ef 90       	pop	r14
    5ba4:	df 90       	pop	r13
    5ba6:	cf 90       	pop	r12
    5ba8:	bf 90       	pop	r11
    5baa:	af 90       	pop	r10
    5bac:	9f 90       	pop	r9
    5bae:	8f 90       	pop	r8
    5bb0:	08 95       	ret

00005bb2 <initAxisHandles>:


/******************************DEFINICION DE LAS FUNCIONES***********************************/

PMDresult initAxisHandles(void) 
{
    5bb2:	cf 92       	push	r12
    5bb4:	df 92       	push	r13
    5bb6:	ef 92       	push	r14
    5bb8:	ff 92       	push	r15
    5bba:	0f 93       	push	r16
    5bbc:	1f 93       	push	r17
    5bbe:	df 93       	push	r29
    5bc0:	cf 93       	push	r28
    5bc2:	00 d0       	rcall	.+0      	; 0x5bc4 <initAxisHandles+0x12>
    5bc4:	cd b7       	in	r28, 0x3d	; 61
    5bc6:	de b7       	in	r29, 0x3e	; 62
    5bc8:	64 e7       	ldi	r22, 0x74	; 116
    5bca:	e6 2e       	mov	r14, r22
    5bcc:	6d e7       	ldi	r22, 0x7D	; 125
    5bce:	f6 2e       	mov	r15, r22
    5bd0:	cc 24       	eor	r12, r12
    5bd2:	dd 24       	eor	r13, r13
	int16 Axis,rc;
	int16 Reconf_Enable;

	for(Axis=0; Axis<DOF; Axis++) 
	{  
		if(hAxis[Axis].transport_data == NULL) //Si no ha sido definida
    5bd4:	2e e5       	ldi	r18, 0x5E	; 94
    5bd6:	30 e0       	ldi	r19, 0x00	; 0
    5bd8:	e2 0e       	add	r14, r18
    5bda:	f3 1e       	adc	r15, r19
    5bdc:	f7 01       	movw	r30, r14
    5bde:	80 81       	ld	r24, Z
    5be0:	91 81       	ldd	r25, Z+1	; 0x01
    5be2:	22 ea       	ldi	r18, 0xA2	; 162
    5be4:	3f ef       	ldi	r19, 0xFF	; 255
    5be6:	e2 0e       	add	r14, r18
    5be8:	f3 1e       	adc	r15, r19
    5bea:	89 2b       	or	r24, r25
    5bec:	81 f4       	brne	.+32     	; 0x5c0e <initAxisHandles+0x5c>
		{		
			rc = PMDSetupAxisInterface_Parallel(&hAxis[Axis], Axis2PMDAxis(Axis), Axis2PMDChipset(Axis));
    5bee:	c6 01       	movw	r24, r12
    5bf0:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    5bf4:	8c 01       	movw	r16, r24
    5bf6:	c6 01       	movw	r24, r12
    5bf8:	0e 94 fa 67 	call	0xcff4	; 0xcff4 <Axis2PMDChipset>
    5bfc:	ac 01       	movw	r20, r24
    5bfe:	c7 01       	movw	r24, r14
    5c00:	b8 01       	movw	r22, r16
    5c02:	0e 94 f5 68 	call	0xd1ea	; 0xd1ea <PMDSetupAxisInterface_Parallel>
    5c06:	9c 01       	movw	r18, r24
			if(rc != rcOK) 
    5c08:	00 97       	sbiw	r24, 0x00	; 0
    5c0a:	09 f0       	breq	.+2      	; 0x5c0e <initAxisHandles+0x5c>
    5c0c:	4e c0       	rjmp	.+156    	; 0x5caa <initAxisHandles+0xf8>
PMDresult initAxisHandles(void) 
{
	int16 Axis,rc;
	int16 Reconf_Enable;

	for(Axis=0; Axis<DOF; Axis++) 
    5c0e:	08 94       	sec
    5c10:	c1 1c       	adc	r12, r1
    5c12:	d1 1c       	adc	r13, r1
    5c14:	80 e6       	ldi	r24, 0x60	; 96
    5c16:	90 e0       	ldi	r25, 0x00	; 0
    5c18:	e8 0e       	add	r14, r24
    5c1a:	f9 1e       	adc	r15, r25
    5c1c:	95 e0       	ldi	r25, 0x05	; 5
    5c1e:	c9 16       	cp	r12, r25
    5c20:	d1 04       	cpc	r13, r1
    5c22:	c1 f6       	brne	.-80     	; 0x5bd4 <initAxisHandles+0x22>
		}
	}	
   
	
	/* Leer el indicado de reconfiguracion*/
	eeprom_read_block((void*)&Reconf_Enable,(const void*)&EEprom_Reconf_Indicator,sizeof(int16));
    5c24:	ce 01       	movw	r24, r28
    5c26:	01 96       	adiw	r24, 0x01	; 1
    5c28:	60 e0       	ldi	r22, 0x00	; 0
    5c2a:	70 e0       	ldi	r23, 0x00	; 0
    5c2c:	42 e0       	ldi	r20, 0x02	; 2
    5c2e:	50 e0       	ldi	r21, 0x00	; 0
    5c30:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
    5c34:	52 e0       	ldi	r21, 0x02	; 2
    5c36:	c5 2e       	mov	r12, r21
    5c38:	50 e0       	ldi	r21, 0x00	; 0
    5c3a:	d5 2e       	mov	r13, r21
    5c3c:	ee 24       	eor	r14, r14
    5c3e:	ff 24       	eor	r15, r15
	for(Axis=0; Axis<DOF; Axis++)
	{
		//Configura la structura tAxisSettings
		//limites de velocidad entre ostras cosas definidas en robotdata.c 
		/*Si no he reconfigurado utilizsr por defecto*/
                if(!Reconf_Enable)
    5c40:	89 81       	ldd	r24, Y+1	; 0x01
    5c42:	9a 81       	ldd	r25, Y+2	; 0x02
    5c44:	87 01       	movw	r16, r14
    5c46:	00 0f       	add	r16, r16
    5c48:	11 1f       	adc	r17, r17
    5c4a:	89 2b       	or	r24, r25
    5c4c:	71 f4       	brne	.+28     	; 0x5c6a <initAxisHandles+0xb8>
			defaultAxisSettings(Axis,&hAxis[Axis].axisSettings); 		
    5c4e:	0e 0d       	add	r16, r14
    5c50:	1f 1d       	adc	r17, r15
    5c52:	35 e0       	ldi	r19, 0x05	; 5
    5c54:	00 0f       	add	r16, r16
    5c56:	11 1f       	adc	r17, r17
    5c58:	3a 95       	dec	r19
    5c5a:	e1 f7       	brne	.-8      	; 0x5c54 <initAxisHandles+0xa2>
    5c5c:	08 58       	subi	r16, 0x88	; 136
    5c5e:	12 48       	sbci	r17, 0x82	; 130
    5c60:	c7 01       	movw	r24, r14
    5c62:	b8 01       	movw	r22, r16
    5c64:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <defaultAxisSettings>
    5c68:	13 c0       	rjmp	.+38     	; 0x5c90 <initAxisHandles+0xde>
		else
		{
			printf("initAxisHandles=> Configurando usando la eeprom\n");
    5c6a:	83 e8       	ldi	r24, 0x83	; 131
    5c6c:	99 e4       	ldi	r25, 0x49	; 73
    5c6e:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
			//Configuro Usando la eeprom
			//Actualizo rxAxissetting a la estructura PMDAxisHandle hAxis	
			eeprom_read_block((void*)&hAxis[Axis].axisSettings,(const void*)&EEprom_axisSettings[Axis],sizeof(tAxisSettings));
    5c72:	0e 0d       	add	r16, r14
    5c74:	1f 1d       	adc	r17, r15
    5c76:	25 e0       	ldi	r18, 0x05	; 5
    5c78:	00 0f       	add	r16, r16
    5c7a:	11 1f       	adc	r17, r17
    5c7c:	2a 95       	dec	r18
    5c7e:	e1 f7       	brne	.-8      	; 0x5c78 <initAxisHandles+0xc6>
    5c80:	c8 01       	movw	r24, r16
    5c82:	88 58       	subi	r24, 0x88	; 136
    5c84:	92 48       	sbci	r25, 0x82	; 130
    5c86:	b6 01       	movw	r22, r12
    5c88:	44 e4       	ldi	r20, 0x44	; 68
    5c8a:	50 e0       	ldi	r21, 0x00	; 0
    5c8c:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
	
	/* Leer el indicado de reconfiguracion*/
	eeprom_read_block((void*)&Reconf_Enable,(const void*)&EEprom_Reconf_Indicator,sizeof(int16));
	
     
	for(Axis=0; Axis<DOF; Axis++)
    5c90:	08 94       	sec
    5c92:	e1 1c       	adc	r14, r1
    5c94:	f1 1c       	adc	r15, r1
    5c96:	e4 e4       	ldi	r30, 0x44	; 68
    5c98:	f0 e0       	ldi	r31, 0x00	; 0
    5c9a:	ce 0e       	add	r12, r30
    5c9c:	df 1e       	adc	r13, r31
    5c9e:	f5 e0       	ldi	r31, 0x05	; 5
    5ca0:	ef 16       	cp	r14, r31
    5ca2:	f1 04       	cpc	r15, r1
    5ca4:	69 f6       	brne	.-102    	; 0x5c40 <initAxisHandles+0x8e>
    5ca6:	20 e0       	ldi	r18, 0x00	; 0
    5ca8:	30 e0       	ldi	r19, 0x00	; 0
		}
	}

	
	return rcOK;
} 
    5caa:	c9 01       	movw	r24, r18
    5cac:	0f 90       	pop	r0
    5cae:	0f 90       	pop	r0
    5cb0:	cf 91       	pop	r28
    5cb2:	df 91       	pop	r29
    5cb4:	1f 91       	pop	r17
    5cb6:	0f 91       	pop	r16
    5cb8:	ff 90       	pop	r15
    5cba:	ef 90       	pop	r14
    5cbc:	df 90       	pop	r13
    5cbe:	cf 90       	pop	r12
    5cc0:	08 95       	ret

00005cc2 <selftestPMD>:
	return rcOK;
} 

/*********************************************************************************************/
PMDresult selftestPMD(void)  //Le quite el parametro PMDAxisHandle* hAxis
{
    5cc2:	0f 93       	push	r16
    5cc4:	1f 93       	push	r17
    5cc6:	cf 93       	push	r28
    5cc8:	df 93       	push	r29
	int16 rc1= rcOK;                // return code
	int16 rc2 = rcOK; 
	int16 rc;
   
   rc1 = initAxisHandles();        //inicializamos todos los ejes hAxis
    5cca:	0e 94 d9 2d 	call	0x5bb2	; 0x5bb2 <initAxisHandles>
   if(rc1!=rcOK)
    5cce:	89 2b       	or	r24, r25
    5cd0:	59 f0       	breq	.+22     	; 0x5ce8 <selftestPMD+0x26>
   { //Enviar Codigo de ERRoR por Leds , por Buzzer y Por Display.
		buzzer(2);
    5cd2:	82 e0       	ldi	r24, 0x02	; 2
    5cd4:	90 e0       	ldi	r25, 0x00	; 0
    5cd6:	0e 94 eb 76 	call	0xedd6	; 0xedd6 <buzzer>
		delay_1s();
    5cda:	0e 94 e1 76 	call	0xedc2	; 0xedc2 <delay_1s>
		buzzer(1); 
    5cde:	81 e0       	ldi	r24, 0x01	; 1
    5ce0:	90 e0       	ldi	r25, 0x00	; 0
    5ce2:	0e 94 eb 76 	call	0xedd6	; 0xedd6 <buzzer>
    5ce6:	70 c0       	rjmp	.+224    	; 0x5dc8 <selftestPMD+0x106>
	}    
	
	else
	{
		
		printf("selftestPMD => Hard reset\n");	
    5ce8:	83 eb       	ldi	r24, 0xB3	; 179
    5cea:	99 e4       	ldi	r25, 0x49	; 73
    5cec:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		PMDHardReset(&hAxis[0]); 			//hacemos reset por hardware a PMD1 y PMD2
    5cf0:	84 e7       	ldi	r24, 0x74	; 116
    5cf2:	9d e7       	ldi	r25, 0x7D	; 125
    5cf4:	0e 94 85 5f 	call	0xbf0a	; 0xbf0a <PMDHardReset>
		rc1 = PMDchipsetOK(PMDChipSet1); 	//COmprobamos el Checksum despus de reset
    5cf8:	80 e0       	ldi	r24, 0x00	; 0
    5cfa:	90 e0       	ldi	r25, 0x00	; 0
    5cfc:	0e 94 ed 2c 	call	0x59da	; 0x59da <PMDchipsetOK>
    5d00:	8c 01       	movw	r16, r24
		if(rc1 != rcOK)						// Error de Checksum para Chipset 1
    5d02:	00 97       	sbiw	r24, 0x00	; 0
    5d04:	49 f1       	breq	.+82     	; 0x5d58 <selftestPMD+0x96>
		{
			Led_on(Amarillo);    
    5d06:	82 e0       	ldi	r24, 0x02	; 2
    5d08:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
			buzzer(1);
    5d0c:	81 e0       	ldi	r24, 0x01	; 1
    5d0e:	90 e0       	ldi	r25, 0x00	; 0
    5d10:	0e 94 eb 76 	call	0xedd6	; 0xedd6 <buzzer>
			fprintf_P(stderr,PSTR("Error en Controlador 1 \n"));
    5d14:	00 d0       	rcall	.+0      	; 0x5d16 <selftestPMD+0x54>
    5d16:	00 d0       	rcall	.+0      	; 0x5d18 <selftestPMD+0x56>
    5d18:	80 91 33 82 	lds	r24, 0x8233
    5d1c:	90 91 34 82 	lds	r25, 0x8234
    5d20:	ed b7       	in	r30, 0x3d	; 61
    5d22:	fe b7       	in	r31, 0x3e	; 62
    5d24:	92 83       	std	Z+2, r25	; 0x02
    5d26:	81 83       	std	Z+1, r24	; 0x01
    5d28:	83 e4       	ldi	r24, 0x43	; 67
    5d2a:	94 e0       	ldi	r25, 0x04	; 4
    5d2c:	94 83       	std	Z+4, r25	; 0x04
    5d2e:	83 83       	std	Z+3, r24	; 0x03
    5d30:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
			fprintf_P(stdout,PSTR("Error en el Controlador de motores No. 1 \n"));			
    5d34:	80 91 31 82 	lds	r24, 0x8231
    5d38:	90 91 32 82 	lds	r25, 0x8232
    5d3c:	ed b7       	in	r30, 0x3d	; 61
    5d3e:	fe b7       	in	r31, 0x3e	; 62
    5d40:	92 83       	std	Z+2, r25	; 0x02
    5d42:	81 83       	std	Z+1, r24	; 0x01
    5d44:	88 e1       	ldi	r24, 0x18	; 24
    5d46:	94 e0       	ldi	r25, 0x04	; 4
    5d48:	94 83       	std	Z+4, r25	; 0x04
    5d4a:	83 83       	std	Z+3, r24	; 0x03
    5d4c:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
    5d50:	0f 90       	pop	r0
    5d52:	0f 90       	pop	r0
    5d54:	0f 90       	pop	r0
    5d56:	0f 90       	pop	r0
		}
		// Chipset1 OK
		
		rc2 = PMDchipsetOK(PMDChipSet2);//COmprobamos el Checksum despues de reset
    5d58:	81 e0       	ldi	r24, 0x01	; 1
    5d5a:	90 e0       	ldi	r25, 0x00	; 0
    5d5c:	0e 94 ed 2c 	call	0x59da	; 0x59da <PMDchipsetOK>
    5d60:	ec 01       	movw	r28, r24
		if(rc2 != rcOK)					 // Error de Checksum para Chipset 2
    5d62:	00 97       	sbiw	r24, 0x00	; 0
    5d64:	49 f1       	breq	.+82     	; 0x5db8 <selftestPMD+0xf6>
		{ //Enviar Codigo de ERRoR por Leds , por Buzzer y por Display.y salir del programa
		  
			Led_on(Rojo);    //
    5d66:	81 e0       	ldi	r24, 0x01	; 1
    5d68:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
			buzzer(1);
    5d6c:	81 e0       	ldi	r24, 0x01	; 1
    5d6e:	90 e0       	ldi	r25, 0x00	; 0
    5d70:	0e 94 eb 76 	call	0xedd6	; 0xedd6 <buzzer>
			fprintf_P(stderr,PSTR("Error en Controlador 2 \n"));
    5d74:	00 d0       	rcall	.+0      	; 0x5d76 <selftestPMD+0xb4>
    5d76:	00 d0       	rcall	.+0      	; 0x5d78 <selftestPMD+0xb6>
    5d78:	80 91 33 82 	lds	r24, 0x8233
    5d7c:	90 91 34 82 	lds	r25, 0x8234
    5d80:	ed b7       	in	r30, 0x3d	; 61
    5d82:	fe b7       	in	r31, 0x3e	; 62
    5d84:	92 83       	std	Z+2, r25	; 0x02
    5d86:	81 83       	std	Z+1, r24	; 0x01
    5d88:	8f ef       	ldi	r24, 0xFF	; 255
    5d8a:	93 e0       	ldi	r25, 0x03	; 3
    5d8c:	94 83       	std	Z+4, r25	; 0x04
    5d8e:	83 83       	std	Z+3, r24	; 0x03
    5d90:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
			fprintf_P(stdout,PSTR("Error en el Controlador de motores No. 2 \n"));			
    5d94:	80 91 31 82 	lds	r24, 0x8231
    5d98:	90 91 32 82 	lds	r25, 0x8232
    5d9c:	ed b7       	in	r30, 0x3d	; 61
    5d9e:	fe b7       	in	r31, 0x3e	; 62
    5da0:	92 83       	std	Z+2, r25	; 0x02
    5da2:	81 83       	std	Z+1, r24	; 0x01
    5da4:	84 ed       	ldi	r24, 0xD4	; 212
    5da6:	93 e0       	ldi	r25, 0x03	; 3
    5da8:	94 83       	std	Z+4, r25	; 0x04
    5daa:	83 83       	std	Z+3, r24	; 0x03
    5dac:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
    5db0:	0f 90       	pop	r0
    5db2:	0f 90       	pop	r0
    5db4:	0f 90       	pop	r0
    5db6:	0f 90       	pop	r0
		}
		
		if((rc1 == rcOK) && (rc2 == rcOK))		//  Exito en ambos Checksum
    5db8:	01 2b       	or	r16, r17
    5dba:	31 f4       	brne	.+12     	; 0x5dc8 <selftestPMD+0x106>
    5dbc:	20 97       	sbiw	r28, 0x00	; 0
    5dbe:	61 f4       	brne	.+24     	; 0x5dd8 <selftestPMD+0x116>
		{
			
			Led_on(Verde);							
    5dc0:	80 e0       	ldi	r24, 0x00	; 0
    5dc2:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
    5dc6:	08 c0       	rjmp	.+16     	; 0x5dd8 <selftestPMD+0x116>
    5dc8:	21 e0       	ldi	r18, 0x01	; 1
    5dca:	30 e0       	ldi	r19, 0x00	; 0

	rc= rc1 || rc2;
	
	return rc;

}
    5dcc:	c9 01       	movw	r24, r18
    5dce:	df 91       	pop	r29
    5dd0:	cf 91       	pop	r28
    5dd2:	1f 91       	pop	r17
    5dd4:	0f 91       	pop	r16
    5dd6:	08 95       	ret
		}
		
		if((rc1 == rcOK) && (rc2 == rcOK))		//  Exito en ambos Checksum
		{
			
			Led_on(Verde);							
    5dd8:	ce 01       	movw	r24, r28
    5dda:	20 97       	sbiw	r28, 0x00	; 0
    5ddc:	11 f0       	breq	.+4      	; 0x5de2 <selftestPMD+0x120>
    5dde:	81 e0       	ldi	r24, 0x01	; 1
    5de0:	90 e0       	ldi	r25, 0x00	; 0
    5de2:	9c 01       	movw	r18, r24
    5de4:	f3 cf       	rjmp	.-26     	; 0x5dcc <selftestPMD+0x10a>

00005de6 <Tracevar2PMDVar>:
	}
	while (readindex < (total_data - nVariables));	
} 

int8 Tracevar2PMDVar(tCommand VisualTrace,int8 TracevarIndex)
{
    5de6:	df 93       	push	r29
    5de8:	cf 93       	push	r28
    5dea:	cd b7       	in	r28, 0x3d	; 61
    5dec:	de b7       	in	r29, 0x3e	; 62
	int8 Result,Axis;
	
	
	Axis=VisualTrace.Tracecomand[TracevarIndex].AxisTrace;
	if(Axis==AxisRoll) 
    5dee:	e8 a1       	ldd	r30, Y+32	; 0x20
    5df0:	ff 27       	eor	r31, r31
    5df2:	e7 fd       	sbrc	r30, 7
    5df4:	f0 95       	com	r31
    5df6:	ee 0f       	add	r30, r30
    5df8:	ff 1f       	adc	r31, r31
    5dfa:	85 e0       	ldi	r24, 0x05	; 5
    5dfc:	90 e0       	ldi	r25, 0x00	; 0
    5dfe:	8c 0f       	add	r24, r28
    5e00:	9d 1f       	adc	r25, r29
    5e02:	e8 0f       	add	r30, r24
    5e04:	f9 1f       	adc	r31, r25
    5e06:	83 85       	ldd	r24, Z+11	; 0x0b
    5e08:	84 30       	cpi	r24, 0x04	; 4
    5e0a:	31 f4       	brne	.+12     	; 0x5e18 <Tracevar2PMDVar+0x32>
	{
		Result=PMD2NVariables;
    5e0c:	80 91 1b 82 	lds	r24, 0x821B
		PMD2NVariables++;
    5e10:	8f 5f       	subi	r24, 0xFF	; 255
    5e12:	80 93 1b 82 	sts	0x821B, r24
    5e16:	05 c0       	rjmp	.+10     	; 0x5e22 <Tracevar2PMDVar+0x3c>
	}
	else
	{
		Result=PMD1NVariables;
    5e18:	80 91 1a 82 	lds	r24, 0x821A
		PMD1NVariables++;
    5e1c:	8f 5f       	subi	r24, 0xFF	; 255
    5e1e:	80 93 1a 82 	sts	0x821A, r24
    5e22:	81 50       	subi	r24, 0x01	; 1
	}
	
	return Result;

}
    5e24:	cf 91       	pop	r28
    5e26:	df 91       	pop	r29
    5e28:	08 95       	ret

00005e2a <DisableVariable>:
	printf("EnvioTrazado2PC=> total_data=  %ld\n ",total_data);
	printf("EnvioTrazado2PC=> Saliendo readbuffer\n ");
} 

void DisableVariable(void)
{
    5e2a:	0f 93       	push	r16
    5e2c:	1f 93       	push	r17

	PMDSetTraceVariable(&hAxis[AxisWaist], PMDTrace1, Axis2PMDAxis(AxisWaist), PMDTraceNoVariable);
    5e2e:	80 e0       	ldi	r24, 0x00	; 0
    5e30:	90 e0       	ldi	r25, 0x00	; 0
    5e32:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    5e36:	ac 01       	movw	r20, r24
    5e38:	04 e7       	ldi	r16, 0x74	; 116
    5e3a:	1d e7       	ldi	r17, 0x7D	; 125
    5e3c:	c8 01       	movw	r24, r16
    5e3e:	60 e0       	ldi	r22, 0x00	; 0
    5e40:	70 e0       	ldi	r23, 0x00	; 0
    5e42:	20 e0       	ldi	r18, 0x00	; 0
    5e44:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisWaist], PMDTrace2, Axis2PMDAxis(AxisWaist), PMDTraceNoVariable);
    5e48:	80 e0       	ldi	r24, 0x00	; 0
    5e4a:	90 e0       	ldi	r25, 0x00	; 0
    5e4c:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    5e50:	ac 01       	movw	r20, r24
    5e52:	c8 01       	movw	r24, r16
    5e54:	61 e0       	ldi	r22, 0x01	; 1
    5e56:	70 e0       	ldi	r23, 0x00	; 0
    5e58:	20 e0       	ldi	r18, 0x00	; 0
    5e5a:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisWaist], PMDTrace3, Axis2PMDAxis(AxisWaist), PMDTraceNoVariable);
    5e5e:	80 e0       	ldi	r24, 0x00	; 0
    5e60:	90 e0       	ldi	r25, 0x00	; 0
    5e62:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    5e66:	ac 01       	movw	r20, r24
    5e68:	c8 01       	movw	r24, r16
    5e6a:	62 e0       	ldi	r22, 0x02	; 2
    5e6c:	70 e0       	ldi	r23, 0x00	; 0
    5e6e:	20 e0       	ldi	r18, 0x00	; 0
    5e70:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisWaist], PMDTrace4, Axis2PMDAxis(AxisWaist), PMDTraceNoVariable);	
    5e74:	80 e0       	ldi	r24, 0x00	; 0
    5e76:	90 e0       	ldi	r25, 0x00	; 0
    5e78:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    5e7c:	ac 01       	movw	r20, r24
    5e7e:	c8 01       	movw	r24, r16
    5e80:	63 e0       	ldi	r22, 0x03	; 3
    5e82:	70 e0       	ldi	r23, 0x00	; 0
    5e84:	20 e0       	ldi	r18, 0x00	; 0
    5e86:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisRoll], PMDTrace1, Axis2PMDAxis(AxisRoll), PMDTraceNoVariable);
    5e8a:	84 e0       	ldi	r24, 0x04	; 4
    5e8c:	90 e0       	ldi	r25, 0x00	; 0
    5e8e:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    5e92:	ac 01       	movw	r20, r24
    5e94:	04 ef       	ldi	r16, 0xF4	; 244
    5e96:	1e e7       	ldi	r17, 0x7E	; 126
    5e98:	c8 01       	movw	r24, r16
    5e9a:	60 e0       	ldi	r22, 0x00	; 0
    5e9c:	70 e0       	ldi	r23, 0x00	; 0
    5e9e:	20 e0       	ldi	r18, 0x00	; 0
    5ea0:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisRoll], PMDTrace2, Axis2PMDAxis(AxisRoll), PMDTraceNoVariable);
    5ea4:	84 e0       	ldi	r24, 0x04	; 4
    5ea6:	90 e0       	ldi	r25, 0x00	; 0
    5ea8:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    5eac:	ac 01       	movw	r20, r24
    5eae:	c8 01       	movw	r24, r16
    5eb0:	61 e0       	ldi	r22, 0x01	; 1
    5eb2:	70 e0       	ldi	r23, 0x00	; 0
    5eb4:	20 e0       	ldi	r18, 0x00	; 0
    5eb6:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisRoll], PMDTrace3, Axis2PMDAxis(AxisRoll), PMDTraceNoVariable);
    5eba:	84 e0       	ldi	r24, 0x04	; 4
    5ebc:	90 e0       	ldi	r25, 0x00	; 0
    5ebe:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    5ec2:	ac 01       	movw	r20, r24
    5ec4:	c8 01       	movw	r24, r16
    5ec6:	62 e0       	ldi	r22, 0x02	; 2
    5ec8:	70 e0       	ldi	r23, 0x00	; 0
    5eca:	20 e0       	ldi	r18, 0x00	; 0
    5ecc:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisRoll], PMDTrace4, Axis2PMDAxis(AxisRoll), PMDTraceNoVariable);	
    5ed0:	84 e0       	ldi	r24, 0x04	; 4
    5ed2:	90 e0       	ldi	r25, 0x00	; 0
    5ed4:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    5ed8:	ac 01       	movw	r20, r24
    5eda:	c8 01       	movw	r24, r16
    5edc:	63 e0       	ldi	r22, 0x03	; 3
    5ede:	70 e0       	ldi	r23, 0x00	; 0
    5ee0:	20 e0       	ldi	r18, 0x00	; 0
    5ee2:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
    5ee6:	1f 91       	pop	r17
    5ee8:	0f 91       	pop	r16
    5eea:	08 95       	ret

00005eec <EnvioTrazado2PC>:
}


/*****************************************************************************************/
void EnvioTrazado2PC(uint8 N_traceVariable)
{
    5eec:	6f 92       	push	r6
    5eee:	7f 92       	push	r7
    5ef0:	8f 92       	push	r8
    5ef2:	9f 92       	push	r9
    5ef4:	af 92       	push	r10
    5ef6:	bf 92       	push	r11
    5ef8:	cf 92       	push	r12
    5efa:	df 92       	push	r13
    5efc:	ef 92       	push	r14
    5efe:	ff 92       	push	r15
    5f00:	0f 93       	push	r16
    5f02:	1f 93       	push	r17
    5f04:	df 93       	push	r29
    5f06:	cf 93       	push	r28
    5f08:	cd b7       	in	r28, 0x3d	; 61
    5f0a:	de b7       	in	r29, 0x3e	; 62
    5f0c:	a0 97       	sbiw	r28, 0x20	; 32
    5f0e:	0f b6       	in	r0, 0x3f	; 63
    5f10:	f8 94       	cli
    5f12:	de bf       	out	0x3e, r29	; 62
    5f14:	0f be       	out	0x3f, r0	; 63
    5f16:	cd bf       	out	0x3d, r28	; 61
    5f18:	18 2f       	mov	r17, r24
	uint8 Axis=0;
	PMDuint32 total_data_Chipset2=0;
    5f1a:	19 82       	std	Y+1, r1	; 0x01
    5f1c:	1a 82       	std	Y+2, r1	; 0x02
    5f1e:	1b 82       	std	Y+3, r1	; 0x03
    5f20:	1c 82       	std	Y+4, r1	; 0x04
	PMDuint32 total_data_Chipset1=0;
    5f22:	1d 82       	std	Y+5, r1	; 0x05
    5f24:	1e 82       	std	Y+6, r1	; 0x06
    5f26:	1f 82       	std	Y+7, r1	; 0x07
    5f28:	18 86       	std	Y+8, r1	; 0x08
	#ifdef DEBUGUSBLevel1
	uint16 spacefree;
	#endif
	total_data=0;
	
	PMDGetTraceCount(&hAxis[AxisWaist], &total_data_Chipset1);		
    5f2a:	84 e7       	ldi	r24, 0x74	; 116
    5f2c:	9d e7       	ldi	r25, 0x7D	; 125
    5f2e:	be 01       	movw	r22, r28
    5f30:	6b 5f       	subi	r22, 0xFB	; 251
    5f32:	7f 4f       	sbci	r23, 0xFF	; 255
    5f34:	0e 94 3f 64 	call	0xc87e	; 0xc87e <PMDGetTraceCount>
	printf("EnvioTrazado2PC=> total_data_Chipset1=  %ld\n",total_data_Chipset1);
    5f38:	00 d0       	rcall	.+0      	; 0x5f3a <EnvioTrazado2PC+0x4e>
    5f3a:	00 d0       	rcall	.+0      	; 0x5f3c <EnvioTrazado2PC+0x50>
    5f3c:	00 d0       	rcall	.+0      	; 0x5f3e <EnvioTrazado2PC+0x52>
    5f3e:	8d ec       	ldi	r24, 0xCD	; 205
    5f40:	99 e4       	ldi	r25, 0x49	; 73
    5f42:	ad b7       	in	r26, 0x3d	; 61
    5f44:	be b7       	in	r27, 0x3e	; 62
    5f46:	12 96       	adiw	r26, 0x02	; 2
    5f48:	9c 93       	st	X, r25
    5f4a:	8e 93       	st	-X, r24
    5f4c:	11 97       	sbiw	r26, 0x01	; 1
    5f4e:	8d 81       	ldd	r24, Y+5	; 0x05
    5f50:	9e 81       	ldd	r25, Y+6	; 0x06
    5f52:	af 81       	ldd	r26, Y+7	; 0x07
    5f54:	b8 85       	ldd	r27, Y+8	; 0x08
    5f56:	ed b7       	in	r30, 0x3d	; 61
    5f58:	fe b7       	in	r31, 0x3e	; 62
    5f5a:	83 83       	std	Z+3, r24	; 0x03
    5f5c:	94 83       	std	Z+4, r25	; 0x04
    5f5e:	a5 83       	std	Z+5, r26	; 0x05
    5f60:	b6 83       	std	Z+6, r27	; 0x06
    5f62:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	PMDGetTraceCount(&hAxis[AxisRoll], &total_data_Chipset2);
    5f66:	8d b7       	in	r24, 0x3d	; 61
    5f68:	9e b7       	in	r25, 0x3e	; 62
    5f6a:	06 96       	adiw	r24, 0x06	; 6
    5f6c:	0f b6       	in	r0, 0x3f	; 63
    5f6e:	f8 94       	cli
    5f70:	9e bf       	out	0x3e, r25	; 62
    5f72:	0f be       	out	0x3f, r0	; 63
    5f74:	8d bf       	out	0x3d, r24	; 61
    5f76:	84 ef       	ldi	r24, 0xF4	; 244
    5f78:	9e e7       	ldi	r25, 0x7E	; 126
    5f7a:	be 01       	movw	r22, r28
    5f7c:	6f 5f       	subi	r22, 0xFF	; 255
    5f7e:	7f 4f       	sbci	r23, 0xFF	; 255
    5f80:	0e 94 3f 64 	call	0xc87e	; 0xc87e <PMDGetTraceCount>
	printf("EnvioTrazado2PC=> total_data_Chipset2=  %ld\n",total_data_Chipset2);
    5f84:	00 d0       	rcall	.+0      	; 0x5f86 <EnvioTrazado2PC+0x9a>
    5f86:	00 d0       	rcall	.+0      	; 0x5f88 <EnvioTrazado2PC+0x9c>
    5f88:	00 d0       	rcall	.+0      	; 0x5f8a <EnvioTrazado2PC+0x9e>
    5f8a:	8a ef       	ldi	r24, 0xFA	; 250
    5f8c:	99 e4       	ldi	r25, 0x49	; 73
    5f8e:	ad b7       	in	r26, 0x3d	; 61
    5f90:	be b7       	in	r27, 0x3e	; 62
    5f92:	12 96       	adiw	r26, 0x02	; 2
    5f94:	9c 93       	st	X, r25
    5f96:	8e 93       	st	-X, r24
    5f98:	11 97       	sbiw	r26, 0x01	; 1
    5f9a:	89 81       	ldd	r24, Y+1	; 0x01
    5f9c:	9a 81       	ldd	r25, Y+2	; 0x02
    5f9e:	ab 81       	ldd	r26, Y+3	; 0x03
    5fa0:	bc 81       	ldd	r27, Y+4	; 0x04
    5fa2:	ed b7       	in	r30, 0x3d	; 61
    5fa4:	fe b7       	in	r31, 0x3e	; 62
    5fa6:	83 83       	std	Z+3, r24	; 0x03
    5fa8:	94 83       	std	Z+4, r25	; 0x04
    5faa:	a5 83       	std	Z+5, r26	; 0x05
    5fac:	b6 83       	std	Z+6, r27	; 0x06
    5fae:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	
	PMDSetBufferReadIndex(&hAxis[AxisWaist], BUFFER_ID,0);
    5fb2:	8d b7       	in	r24, 0x3d	; 61
    5fb4:	9e b7       	in	r25, 0x3e	; 62
    5fb6:	06 96       	adiw	r24, 0x06	; 6
    5fb8:	0f b6       	in	r0, 0x3f	; 63
    5fba:	f8 94       	cli
    5fbc:	9e bf       	out	0x3e, r25	; 62
    5fbe:	0f be       	out	0x3f, r0	; 63
    5fc0:	8d bf       	out	0x3d, r24	; 61
    5fc2:	84 e7       	ldi	r24, 0x74	; 116
    5fc4:	9d e7       	ldi	r25, 0x7D	; 125
    5fc6:	60 e0       	ldi	r22, 0x00	; 0
    5fc8:	70 e0       	ldi	r23, 0x00	; 0
    5fca:	20 e0       	ldi	r18, 0x00	; 0
    5fcc:	30 e0       	ldi	r19, 0x00	; 0
    5fce:	40 e0       	ldi	r20, 0x00	; 0
    5fd0:	50 e0       	ldi	r21, 0x00	; 0
    5fd2:	0e 94 f6 66 	call	0xcdec	; 0xcdec <PMDSetBufferReadIndex>
	PMDSetBufferReadIndex(&hAxis[AxisRoll], BUFFER_ID,0);
    5fd6:	84 ef       	ldi	r24, 0xF4	; 244
    5fd8:	9e e7       	ldi	r25, 0x7E	; 126
    5fda:	60 e0       	ldi	r22, 0x00	; 0
    5fdc:	70 e0       	ldi	r23, 0x00	; 0
    5fde:	20 e0       	ldi	r18, 0x00	; 0
    5fe0:	30 e0       	ldi	r19, 0x00	; 0
    5fe2:	40 e0       	ldi	r20, 0x00	; 0
    5fe4:	50 e0       	ldi	r21, 0x00	; 0
    5fe6:	0e 94 f6 66 	call	0xcdec	; 0xcdec <PMDSetBufferReadIndex>
	

	total_data=total_data_Chipset1+total_data_Chipset2;
    5fea:	2d 81       	ldd	r18, Y+5	; 0x05
    5fec:	3e 81       	ldd	r19, Y+6	; 0x06
    5fee:	4f 81       	ldd	r20, Y+7	; 0x07
    5ff0:	58 85       	ldd	r21, Y+8	; 0x08
    5ff2:	89 81       	ldd	r24, Y+1	; 0x01
    5ff4:	9a 81       	ldd	r25, Y+2	; 0x02
    5ff6:	ab 81       	ldd	r26, Y+3	; 0x03
    5ff8:	bc 81       	ldd	r27, Y+4	; 0x04
    5ffa:	5c 01       	movw	r10, r24
    5ffc:	6d 01       	movw	r12, r26
    5ffe:	a2 0e       	add	r10, r18
    6000:	b3 1e       	adc	r11, r19
    6002:	c4 1e       	adc	r12, r20
    6004:	d5 1e       	adc	r13, r21
	/*He configurado alguna variable para trazar*/
	if(N_traceVariable>0 && N_traceVariable<=8)
    6006:	11 50       	subi	r17, 0x01	; 1
    6008:	18 30       	cpi	r17, 0x08	; 8
    600a:	08 f0       	brcs	.+2      	; 0x600e <EnvioTrazado2PC+0x122>
    600c:	b9 c0       	rjmp	.+370    	; 0x6180 <EnvioTrazado2PC+0x294>
	{
		/*total_data = Numero de datos de 32 bists del trazado*/			
		Tracebufferdata[0]=total_data;
    600e:	a9 8a       	std	Y+17, r10	; 0x11
    6010:	ba 8a       	std	Y+18, r11	; 0x12
    6012:	cb 8a       	std	Y+19, r12	; 0x13
    6014:	dc 8a       	std	Y+20, r13	; 0x14
		Tracebufferdata[1]=total_data_Chipset1;
    6016:	2d 8b       	std	Y+21, r18	; 0x15
    6018:	3e 8b       	std	Y+22, r19	; 0x16
    601a:	4f 8b       	std	Y+23, r20	; 0x17
    601c:	58 8f       	std	Y+24, r21	; 0x18
		Tracebufferdata[2]=total_data_Chipset2;
    601e:	89 8f       	std	Y+25, r24	; 0x19
    6020:	9a 8f       	std	Y+26, r25	; 0x1a
    6022:	ab 8f       	std	Y+27, r26	; 0x1b
    6024:	bc 8f       	std	Y+28, r27	; 0x1c
		printf("EnvioTrazado2PC=> Tracebufferdata[0]=  %ld\n",Tracebufferdata[0]);
    6026:	00 d0       	rcall	.+0      	; 0x6028 <EnvioTrazado2PC+0x13c>
    6028:	00 d0       	rcall	.+0      	; 0x602a <EnvioTrazado2PC+0x13e>
    602a:	00 d0       	rcall	.+0      	; 0x602c <EnvioTrazado2PC+0x140>
    602c:	ed b7       	in	r30, 0x3d	; 61
    602e:	fe b7       	in	r31, 0x3e	; 62
    6030:	31 96       	adiw	r30, 0x01	; 1
    6032:	87 e2       	ldi	r24, 0x27	; 39
    6034:	9a e4       	ldi	r25, 0x4A	; 74
    6036:	ad b7       	in	r26, 0x3d	; 61
    6038:	be b7       	in	r27, 0x3e	; 62
    603a:	12 96       	adiw	r26, 0x02	; 2
    603c:	9c 93       	st	X, r25
    603e:	8e 93       	st	-X, r24
    6040:	11 97       	sbiw	r26, 0x01	; 1
    6042:	a2 82       	std	Z+2, r10	; 0x02
    6044:	b3 82       	std	Z+3, r11	; 0x03
    6046:	c4 82       	std	Z+4, r12	; 0x04
    6048:	d5 82       	std	Z+5, r13	; 0x05
    604a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		if(total_data_Chipset1>0)
			Axis=AxisWaist;
		/*Solo tamao de los datos, 4N+12 siempre es par*/
		buffersize=(Tracebufferdata[0]*sizeof(int32))+(sizeof(int32)*3);
		fillPacketHeader(&PacketHeader,PacketTrace,buffersize,NULL); 
    604e:	ed b7       	in	r30, 0x3d	; 61
    6050:	fe b7       	in	r31, 0x3e	; 62
    6052:	36 96       	adiw	r30, 0x06	; 6
    6054:	0f b6       	in	r0, 0x3f	; 63
    6056:	f8 94       	cli
    6058:	fe bf       	out	0x3e, r31	; 62
    605a:	0f be       	out	0x3f, r0	; 63
    605c:	ed bf       	out	0x3d, r30	; 61
    605e:	8e 01       	movw	r16, r28
    6060:	07 5f       	subi	r16, 0xF7	; 247
    6062:	1f 4f       	sbci	r17, 0xFF	; 255
    6064:	29 89       	ldd	r18, Y+17	; 0x11
    6066:	3a 89       	ldd	r19, Y+18	; 0x12
    6068:	4b 89       	ldd	r20, Y+19	; 0x13
    606a:	5c 89       	ldd	r21, Y+20	; 0x14
    606c:	2d 5f       	subi	r18, 0xFD	; 253
    606e:	3f 4f       	sbci	r19, 0xFF	; 255
    6070:	4f 4f       	sbci	r20, 0xFF	; 255
    6072:	5f 4f       	sbci	r21, 0xFF	; 255
    6074:	62 e0       	ldi	r22, 0x02	; 2
    6076:	22 0f       	add	r18, r18
    6078:	33 1f       	adc	r19, r19
    607a:	44 1f       	adc	r20, r20
    607c:	55 1f       	adc	r21, r21
    607e:	6a 95       	dec	r22
    6080:	d1 f7       	brne	.-12     	; 0x6076 <EnvioTrazado2PC+0x18a>
    6082:	c8 01       	movw	r24, r16
    6084:	6c e0       	ldi	r22, 0x0C	; 12
    6086:	70 e0       	ldi	r23, 0x00	; 0
    6088:	a9 01       	movw	r20, r18
    608a:	20 e0       	ldi	r18, 0x00	; 0
    608c:	30 e0       	ldi	r19, 0x00	; 0
    608e:	0e 94 21 18 	call	0x3042	; 0x3042 <fillPacketHeader>
		BufferData=(uint8*)&PacketHeader;
		Envio_USB(BufferData,sizeof(tPacketHeader));
    6092:	c8 01       	movw	r24, r16
    6094:	68 e0       	ldi	r22, 0x08	; 8
    6096:	70 e0       	ldi	r23, 0x00	; 0
    6098:	0e 94 aa 14 	call	0x2954	; 0x2954 <Envio_USB>
		/*Mando el Tracebufferdata[0] */
		BufferData=(uint8*)&Tracebufferdata[0];
		Envio_USB(BufferData,sizeof(int32));
    609c:	ce 01       	movw	r24, r28
    609e:	41 96       	adiw	r24, 0x11	; 17
    60a0:	64 e0       	ldi	r22, 0x04	; 4
    60a2:	70 e0       	ldi	r23, 0x00	; 0
    60a4:	0e 94 aa 14 	call	0x2954	; 0x2954 <Envio_USB>
		/*Mando el Tracebufferdata[1] */
		BufferData=(uint8*)&Tracebufferdata[1];
		Envio_USB(BufferData,sizeof(int32));
    60a8:	ce 01       	movw	r24, r28
    60aa:	45 96       	adiw	r24, 0x15	; 21
    60ac:	64 e0       	ldi	r22, 0x04	; 4
    60ae:	70 e0       	ldi	r23, 0x00	; 0
    60b0:	0e 94 aa 14 	call	0x2954	; 0x2954 <Envio_USB>
		/*Mando el Tracebufferdata[2] */
		BufferData=(uint8*)&Tracebufferdata[2];
		Envio_USB(BufferData,sizeof(int32));
    60b4:	ce 01       	movw	r24, r28
    60b6:	49 96       	adiw	r24, 0x19	; 25
    60b8:	64 e0       	ldi	r22, 0x04	; 4
    60ba:	70 e0       	ldi	r23, 0x00	; 0
    60bc:	0e 94 aa 14 	call	0x2954	; 0x2954 <Envio_USB>
		/*Grabo todos los datos*/
		printf("EnvioTrazado2PC=> Iniciando envio de trazado... \n");
    60c0:	83 e5       	ldi	r24, 0x53	; 83
    60c2:	9a e4       	ldi	r25, 0x4A	; 74
    60c4:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    60c8:	77 24       	eor	r7, r7
    60ca:	ee 24       	eor	r14, r14
    60cc:	ff 24       	eor	r15, r15
    60ce:	87 01       	movw	r16, r14
		{
			/*Estoy en el PMD2*/
			if(i>=(total_data_Chipset1))
				Axis=AxisRoll;
			/*Leo el dato*/
			PMDReadBuffer(&hAxis[Axis], BUFFER_ID,&Tracebufferdata[3]);	
    60d0:	30 e6       	ldi	r19, 0x60	; 96
    60d2:	63 2e       	mov	r6, r19
    60d4:	2d e1       	ldi	r18, 0x1D	; 29
    60d6:	82 2e       	mov	r8, r18
    60d8:	91 2c       	mov	r9, r1
    60da:	8c 0e       	add	r8, r28
    60dc:	9d 1e       	adc	r9, r29
    60de:	1f c0       	rjmp	.+62     	; 0x611e <EnvioTrazado2PC+0x232>
		/*Grabo todos los datos*/
		printf("EnvioTrazado2PC=> Iniciando envio de trazado... \n");
		for(i=0;i<total_data;i++)
		{
			/*Estoy en el PMD2*/
			if(i>=(total_data_Chipset1))
    60e0:	8d 81       	ldd	r24, Y+5	; 0x05
    60e2:	9e 81       	ldd	r25, Y+6	; 0x06
    60e4:	af 81       	ldd	r26, Y+7	; 0x07
    60e6:	b8 85       	ldd	r27, Y+8	; 0x08
    60e8:	e8 16       	cp	r14, r24
    60ea:	f9 06       	cpc	r15, r25
    60ec:	0a 07       	cpc	r16, r26
    60ee:	1b 07       	cpc	r17, r27
    60f0:	10 f0       	brcs	.+4      	; 0x60f6 <EnvioTrazado2PC+0x20a>
    60f2:	94 e0       	ldi	r25, 0x04	; 4
    60f4:	79 2e       	mov	r7, r25
				Axis=AxisRoll;
			/*Leo el dato*/
			PMDReadBuffer(&hAxis[Axis], BUFFER_ID,&Tracebufferdata[3]);	
    60f6:	76 9c       	mul	r7, r6
    60f8:	c0 01       	movw	r24, r0
    60fa:	11 24       	eor	r1, r1
    60fc:	8c 58       	subi	r24, 0x8C	; 140
    60fe:	92 48       	sbci	r25, 0x82	; 130
    6100:	60 e0       	ldi	r22, 0x00	; 0
    6102:	70 e0       	ldi	r23, 0x00	; 0
    6104:	a4 01       	movw	r20, r8
    6106:	0e 94 97 66 	call	0xcd2e	; 0xcd2e <PMDReadBuffer>
			/*Mando el Tracebufferdata[3], dato lleido de la memoria del PMD */
			BufferData=(uint8*)&Tracebufferdata[3];
			Envio_USB(BufferData,sizeof(int32));
    610a:	c4 01       	movw	r24, r8
    610c:	64 e0       	ldi	r22, 0x04	; 4
    610e:	70 e0       	ldi	r23, 0x00	; 0
    6110:	0e 94 aa 14 	call	0x2954	; 0x2954 <Envio_USB>
    6114:	08 94       	sec
    6116:	e1 1c       	adc	r14, r1
    6118:	f1 1c       	adc	r15, r1
    611a:	01 1d       	adc	r16, r1
    611c:	11 1d       	adc	r17, r1
		/*Mando el Tracebufferdata[2] */
		BufferData=(uint8*)&Tracebufferdata[2];
		Envio_USB(BufferData,sizeof(int32));
		/*Grabo todos los datos*/
		printf("EnvioTrazado2PC=> Iniciando envio de trazado... \n");
		for(i=0;i<total_data;i++)
    611e:	ea 14       	cp	r14, r10
    6120:	fb 04       	cpc	r15, r11
    6122:	0c 05       	cpc	r16, r12
    6124:	1d 05       	cpc	r17, r13
    6126:	e0 f2       	brcs	.-72     	; 0x60e0 <EnvioTrazado2PC+0x1f4>
			/*Mando el Tracebufferdata[3], dato lleido de la memoria del PMD */
			BufferData=(uint8*)&Tracebufferdata[3];
			Envio_USB(BufferData,sizeof(int32));
			//printf("Tracebufferdata[3]=  %ld, Index %d \n",(int32)Tracebufferdata[3],i);
		}
		printf("EnvioTrazado2PC=> Envio de trazado finalizado... \n");
    6128:	84 e8       	ldi	r24, 0x84	; 132
    612a:	9a e4       	ldi	r25, 0x4A	; 74
    612c:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		PMDSetBufferReadIndex(&hAxis[AxisWaist], BUFFER_ID,0);
    6130:	84 e7       	ldi	r24, 0x74	; 116
    6132:	9d e7       	ldi	r25, 0x7D	; 125
    6134:	60 e0       	ldi	r22, 0x00	; 0
    6136:	70 e0       	ldi	r23, 0x00	; 0
    6138:	20 e0       	ldi	r18, 0x00	; 0
    613a:	30 e0       	ldi	r19, 0x00	; 0
    613c:	40 e0       	ldi	r20, 0x00	; 0
    613e:	50 e0       	ldi	r21, 0x00	; 0
    6140:	0e 94 f6 66 	call	0xcdec	; 0xcdec <PMDSetBufferReadIndex>
		PMDSetBufferWriteIndex(&hAxis[AxisWaist], BUFFER_ID,0);
    6144:	84 e7       	ldi	r24, 0x74	; 116
    6146:	9d e7       	ldi	r25, 0x7D	; 125
    6148:	60 e0       	ldi	r22, 0x00	; 0
    614a:	70 e0       	ldi	r23, 0x00	; 0
    614c:	20 e0       	ldi	r18, 0x00	; 0
    614e:	30 e0       	ldi	r19, 0x00	; 0
    6150:	40 e0       	ldi	r20, 0x00	; 0
    6152:	50 e0       	ldi	r21, 0x00	; 0
    6154:	0e 94 18 67 	call	0xce30	; 0xce30 <PMDSetBufferWriteIndex>
		PMDSetBufferReadIndex(&hAxis[AxisRoll], BUFFER_ID,0);
    6158:	84 ef       	ldi	r24, 0xF4	; 244
    615a:	9e e7       	ldi	r25, 0x7E	; 126
    615c:	60 e0       	ldi	r22, 0x00	; 0
    615e:	70 e0       	ldi	r23, 0x00	; 0
    6160:	20 e0       	ldi	r18, 0x00	; 0
    6162:	30 e0       	ldi	r19, 0x00	; 0
    6164:	40 e0       	ldi	r20, 0x00	; 0
    6166:	50 e0       	ldi	r21, 0x00	; 0
    6168:	0e 94 f6 66 	call	0xcdec	; 0xcdec <PMDSetBufferReadIndex>
		PMDSetBufferWriteIndex(&hAxis[AxisRoll], BUFFER_ID,0);
    616c:	84 ef       	ldi	r24, 0xF4	; 244
    616e:	9e e7       	ldi	r25, 0x7E	; 126
    6170:	60 e0       	ldi	r22, 0x00	; 0
    6172:	70 e0       	ldi	r23, 0x00	; 0
    6174:	20 e0       	ldi	r18, 0x00	; 0
    6176:	30 e0       	ldi	r19, 0x00	; 0
    6178:	40 e0       	ldi	r20, 0x00	; 0
    617a:	50 e0       	ldi	r21, 0x00	; 0
    617c:	0e 94 18 67 	call	0xce30	; 0xce30 <PMDSetBufferWriteIndex>
	}
	printf("EnvioTrazado2PC=> total_data=  %ld\n ",total_data);
    6180:	00 d0       	rcall	.+0      	; 0x6182 <EnvioTrazado2PC+0x296>
    6182:	00 d0       	rcall	.+0      	; 0x6184 <EnvioTrazado2PC+0x298>
    6184:	00 d0       	rcall	.+0      	; 0x6186 <EnvioTrazado2PC+0x29a>
    6186:	86 eb       	ldi	r24, 0xB6	; 182
    6188:	9a e4       	ldi	r25, 0x4A	; 74
    618a:	ad b7       	in	r26, 0x3d	; 61
    618c:	be b7       	in	r27, 0x3e	; 62
    618e:	12 96       	adiw	r26, 0x02	; 2
    6190:	9c 93       	st	X, r25
    6192:	8e 93       	st	-X, r24
    6194:	11 97       	sbiw	r26, 0x01	; 1
    6196:	ed b7       	in	r30, 0x3d	; 61
    6198:	fe b7       	in	r31, 0x3e	; 62
    619a:	a3 82       	std	Z+3, r10	; 0x03
    619c:	b4 82       	std	Z+4, r11	; 0x04
    619e:	c5 82       	std	Z+5, r12	; 0x05
    61a0:	d6 82       	std	Z+6, r13	; 0x06
    61a2:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("EnvioTrazado2PC=> Saliendo readbuffer\n ");
    61a6:	0f 90       	pop	r0
    61a8:	0f 90       	pop	r0
    61aa:	0f 90       	pop	r0
    61ac:	0f 90       	pop	r0
    61ae:	8b ed       	ldi	r24, 0xDB	; 219
    61b0:	9a e4       	ldi	r25, 0x4A	; 74
    61b2:	ad b7       	in	r26, 0x3d	; 61
    61b4:	be b7       	in	r27, 0x3e	; 62
    61b6:	12 96       	adiw	r26, 0x02	; 2
    61b8:	9c 93       	st	X, r25
    61ba:	8e 93       	st	-X, r24
    61bc:	11 97       	sbiw	r26, 0x01	; 1
    61be:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    61c2:	0f 90       	pop	r0
    61c4:	0f 90       	pop	r0
} 
    61c6:	a0 96       	adiw	r28, 0x20	; 32
    61c8:	0f b6       	in	r0, 0x3f	; 63
    61ca:	f8 94       	cli
    61cc:	de bf       	out	0x3e, r29	; 62
    61ce:	0f be       	out	0x3f, r0	; 63
    61d0:	cd bf       	out	0x3d, r28	; 61
    61d2:	cf 91       	pop	r28
    61d4:	df 91       	pop	r29
    61d6:	1f 91       	pop	r17
    61d8:	0f 91       	pop	r16
    61da:	ff 90       	pop	r15
    61dc:	ef 90       	pop	r14
    61de:	df 90       	pop	r13
    61e0:	cf 90       	pop	r12
    61e2:	bf 90       	pop	r11
    61e4:	af 90       	pop	r10
    61e6:	9f 90       	pop	r9
    61e8:	8f 90       	pop	r8
    61ea:	7f 90       	pop	r7
    61ec:	6f 90       	pop	r6
    61ee:	08 95       	ret

000061f0 <DisplayTraceResults>:
	}
}

/*****************************************************************************************/
void DisplayTraceResults(int Chipset,PMDuint8 nVariables)
{
    61f0:	2f 92       	push	r2
    61f2:	3f 92       	push	r3
    61f4:	4f 92       	push	r4
    61f6:	5f 92       	push	r5
    61f8:	6f 92       	push	r6
    61fa:	7f 92       	push	r7
    61fc:	8f 92       	push	r8
    61fe:	9f 92       	push	r9
    6200:	af 92       	push	r10
    6202:	bf 92       	push	r11
    6204:	cf 92       	push	r12
    6206:	df 92       	push	r13
    6208:	ef 92       	push	r14
    620a:	ff 92       	push	r15
    620c:	0f 93       	push	r16
    620e:	1f 93       	push	r17
    6210:	df 93       	push	r29
    6212:	cf 93       	push	r28
    6214:	cd b7       	in	r28, 0x3d	; 61
    6216:	de b7       	in	r29, 0x3e	; 62
    6218:	2c 97       	sbiw	r28, 0x0c	; 12
    621a:	0f b6       	in	r0, 0x3f	; 63
    621c:	f8 94       	cli
    621e:	de bf       	out	0x3e, r29	; 62
    6220:	0f be       	out	0x3f, r0	; 63
    6222:	cd bf       	out	0x3d, r28	; 61
    6224:	16 2f       	mov	r17, r22
	PMDlong32 bufferdata ;
    int Axis;

	
	Axis = AxisWaist;
	if(Chipset==2) 
    6226:	02 97       	sbiw	r24, 0x02	; 2
    6228:	19 f4       	brne	.+6      	; 0x6230 <DisplayTraceResults+0x40>
    622a:	24 e0       	ldi	r18, 0x04	; 4
    622c:	30 e0       	ldi	r19, 0x00	; 0
    622e:	02 c0       	rjmp	.+4      	; 0x6234 <DisplayTraceResults+0x44>
    6230:	20 e0       	ldi	r18, 0x00	; 0
    6232:	30 e0       	ldi	r19, 0x00	; 0
		Axis = AxisRoll;
	PMDGetTraceCount(&hAxis[Axis], &total_data);
    6234:	80 e6       	ldi	r24, 0x60	; 96
    6236:	90 e0       	ldi	r25, 0x00	; 0
    6238:	28 9f       	mul	r18, r24
    623a:	60 01       	movw	r12, r0
    623c:	29 9f       	mul	r18, r25
    623e:	d0 0c       	add	r13, r0
    6240:	38 9f       	mul	r19, r24
    6242:	d0 0c       	add	r13, r0
    6244:	11 24       	eor	r1, r1
    6246:	84 e7       	ldi	r24, 0x74	; 116
    6248:	9d e7       	ldi	r25, 0x7D	; 125
    624a:	c8 0e       	add	r12, r24
    624c:	d9 1e       	adc	r13, r25
    624e:	c6 01       	movw	r24, r12
    6250:	be 01       	movw	r22, r28
    6252:	6f 5f       	subi	r22, 0xFF	; 255
    6254:	7f 4f       	sbci	r23, 0xFF	; 255
    6256:	0e 94 3f 64 	call	0xc87e	; 0xc87e <PMDGetTraceCount>
	printf("DisplayTraceResults=> Total de Datos= %ld \n", total_data);
    625a:	00 d0       	rcall	.+0      	; 0x625c <DisplayTraceResults+0x6c>
    625c:	00 d0       	rcall	.+0      	; 0x625e <DisplayTraceResults+0x6e>
    625e:	00 d0       	rcall	.+0      	; 0x6260 <DisplayTraceResults+0x70>
    6260:	83 e0       	ldi	r24, 0x03	; 3
    6262:	9b e4       	ldi	r25, 0x4B	; 75
    6264:	ed b7       	in	r30, 0x3d	; 61
    6266:	fe b7       	in	r31, 0x3e	; 62
    6268:	92 83       	std	Z+2, r25	; 0x02
    626a:	81 83       	std	Z+1, r24	; 0x01
    626c:	89 81       	ldd	r24, Y+1	; 0x01
    626e:	9a 81       	ldd	r25, Y+2	; 0x02
    6270:	ab 81       	ldd	r26, Y+3	; 0x03
    6272:	bc 81       	ldd	r27, Y+4	; 0x04
    6274:	83 83       	std	Z+3, r24	; 0x03
    6276:	94 83       	std	Z+4, r25	; 0x04
    6278:	a5 83       	std	Z+5, r26	; 0x05
    627a:	b6 83       	std	Z+6, r27	; 0x06
    627c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    6280:	8d b7       	in	r24, 0x3d	; 61
    6282:	9e b7       	in	r25, 0x3e	; 62
    6284:	06 96       	adiw	r24, 0x06	; 6
    6286:	0f b6       	in	r0, 0x3f	; 63
    6288:	f8 94       	cli
    628a:	9e bf       	out	0x3e, r25	; 62
    628c:	0f be       	out	0x3f, r0	; 63
    628e:	8d bf       	out	0x3d, r24	; 61
	do
	{
		PMDGetBufferReadIndex(&hAxis[Axis], BUFFER_ID, &readindex);
		printf("DisplayTraceResults=> readindex= %ld",readindex);
		
		for(i=0 ; i<nVariables; i++)
    6290:	81 2e       	mov	r8, r17
    6292:	99 24       	eor	r9, r9
    6294:	aa 24       	eor	r10, r10
    6296:	bb 24       	eor	r11, r11
		{
			PMDReadBuffer(&hAxis[Axis], BUFFER_ID, &bufferdata);	
    6298:	f9 e0       	ldi	r31, 0x09	; 9
    629a:	2f 2e       	mov	r2, r31
    629c:	31 2c       	mov	r3, r1
    629e:	2c 0e       	add	r2, r28
    62a0:	3d 1e       	adc	r3, r29
			if(i==3)			
				printf("DisplayTraceResults=> \t%#lX", bufferdata);
			else 
				printf("DisplayTraceResults=> \t%ld", bufferdata);
    62a2:	e0 e7       	ldi	r30, 0x70	; 112
    62a4:	4e 2e       	mov	r4, r30
    62a6:	eb e4       	ldi	r30, 0x4B	; 75
    62a8:	5e 2e       	mov	r5, r30
		
		for(i=0 ; i<nVariables; i++)
		{
			PMDReadBuffer(&hAxis[Axis], BUFFER_ID, &bufferdata);	
			if(i==3)			
				printf("DisplayTraceResults=> \t%#lX", bufferdata);
    62aa:	74 e5       	ldi	r23, 0x54	; 84
    62ac:	67 2e       	mov	r6, r23
    62ae:	7b e4       	ldi	r23, 0x4B	; 75
    62b0:	77 2e       	mov	r7, r23
	PMDGetTraceCount(&hAxis[Axis], &total_data);
	printf("DisplayTraceResults=> Total de Datos= %ld \n", total_data);
	
	do
	{
		PMDGetBufferReadIndex(&hAxis[Axis], BUFFER_ID, &readindex);
    62b2:	c6 01       	movw	r24, r12
    62b4:	60 e0       	ldi	r22, 0x00	; 0
    62b6:	70 e0       	ldi	r23, 0x00	; 0
    62b8:	ae 01       	movw	r20, r28
    62ba:	4b 5f       	subi	r20, 0xFB	; 251
    62bc:	5f 4f       	sbci	r21, 0xFF	; 255
    62be:	0e 94 5d 66 	call	0xccba	; 0xccba <PMDGetBufferReadIndex>
		printf("DisplayTraceResults=> readindex= %ld",readindex);
    62c2:	00 d0       	rcall	.+0      	; 0x62c4 <DisplayTraceResults+0xd4>
    62c4:	00 d0       	rcall	.+0      	; 0x62c6 <DisplayTraceResults+0xd6>
    62c6:	00 d0       	rcall	.+0      	; 0x62c8 <DisplayTraceResults+0xd8>
    62c8:	8f e2       	ldi	r24, 0x2F	; 47
    62ca:	9b e4       	ldi	r25, 0x4B	; 75
    62cc:	ed b7       	in	r30, 0x3d	; 61
    62ce:	fe b7       	in	r31, 0x3e	; 62
    62d0:	92 83       	std	Z+2, r25	; 0x02
    62d2:	81 83       	std	Z+1, r24	; 0x01
    62d4:	8d 81       	ldd	r24, Y+5	; 0x05
    62d6:	9e 81       	ldd	r25, Y+6	; 0x06
    62d8:	af 81       	ldd	r26, Y+7	; 0x07
    62da:	b8 85       	ldd	r27, Y+8	; 0x08
    62dc:	83 83       	std	Z+3, r24	; 0x03
    62de:	94 83       	std	Z+4, r25	; 0x04
    62e0:	a5 83       	std	Z+5, r26	; 0x05
    62e2:	b6 83       	std	Z+6, r27	; 0x06
    62e4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    62e8:	ee 24       	eor	r14, r14
    62ea:	ff 24       	eor	r15, r15
    62ec:	87 01       	movw	r16, r14
    62ee:	8d b7       	in	r24, 0x3d	; 61
    62f0:	9e b7       	in	r25, 0x3e	; 62
    62f2:	06 96       	adiw	r24, 0x06	; 6
    62f4:	0f b6       	in	r0, 0x3f	; 63
    62f6:	f8 94       	cli
    62f8:	9e bf       	out	0x3e, r25	; 62
    62fa:	0f be       	out	0x3f, r0	; 63
    62fc:	8d bf       	out	0x3d, r24	; 61
    62fe:	32 c0       	rjmp	.+100    	; 0x6364 <DisplayTraceResults+0x174>
		
		for(i=0 ; i<nVariables; i++)
		{
			PMDReadBuffer(&hAxis[Axis], BUFFER_ID, &bufferdata);	
    6300:	c6 01       	movw	r24, r12
    6302:	60 e0       	ldi	r22, 0x00	; 0
    6304:	70 e0       	ldi	r23, 0x00	; 0
    6306:	a1 01       	movw	r20, r2
    6308:	0e 94 97 66 	call	0xcd2e	; 0xcd2e <PMDReadBuffer>
			if(i==3)			
    630c:	93 e0       	ldi	r25, 0x03	; 3
    630e:	e9 16       	cp	r14, r25
    6310:	f1 04       	cpc	r15, r1
    6312:	01 05       	cpc	r16, r1
    6314:	11 05       	cpc	r17, r1
    6316:	41 f4       	brne	.+16     	; 0x6328 <DisplayTraceResults+0x138>
				printf("DisplayTraceResults=> \t%#lX", bufferdata);
    6318:	00 d0       	rcall	.+0      	; 0x631a <DisplayTraceResults+0x12a>
    631a:	00 d0       	rcall	.+0      	; 0x631c <DisplayTraceResults+0x12c>
    631c:	00 d0       	rcall	.+0      	; 0x631e <DisplayTraceResults+0x12e>
    631e:	ed b7       	in	r30, 0x3d	; 61
    6320:	fe b7       	in	r31, 0x3e	; 62
    6322:	72 82       	std	Z+2, r7	; 0x02
    6324:	61 82       	std	Z+1, r6	; 0x01
    6326:	07 c0       	rjmp	.+14     	; 0x6336 <DisplayTraceResults+0x146>
			else 
				printf("DisplayTraceResults=> \t%ld", bufferdata);
    6328:	00 d0       	rcall	.+0      	; 0x632a <DisplayTraceResults+0x13a>
    632a:	00 d0       	rcall	.+0      	; 0x632c <DisplayTraceResults+0x13c>
    632c:	00 d0       	rcall	.+0      	; 0x632e <DisplayTraceResults+0x13e>
    632e:	ed b7       	in	r30, 0x3d	; 61
    6330:	fe b7       	in	r31, 0x3e	; 62
    6332:	52 82       	std	Z+2, r5	; 0x02
    6334:	41 82       	std	Z+1, r4	; 0x01
    6336:	89 85       	ldd	r24, Y+9	; 0x09
    6338:	9a 85       	ldd	r25, Y+10	; 0x0a
    633a:	ab 85       	ldd	r26, Y+11	; 0x0b
    633c:	bc 85       	ldd	r27, Y+12	; 0x0c
    633e:	83 83       	std	Z+3, r24	; 0x03
    6340:	94 83       	std	Z+4, r25	; 0x04
    6342:	a5 83       	std	Z+5, r26	; 0x05
    6344:	b6 83       	std	Z+6, r27	; 0x06
    6346:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    634a:	8d b7       	in	r24, 0x3d	; 61
    634c:	9e b7       	in	r25, 0x3e	; 62
    634e:	06 96       	adiw	r24, 0x06	; 6
    6350:	0f b6       	in	r0, 0x3f	; 63
    6352:	f8 94       	cli
    6354:	9e bf       	out	0x3e, r25	; 62
    6356:	0f be       	out	0x3f, r0	; 63
    6358:	8d bf       	out	0x3d, r24	; 61
	do
	{
		PMDGetBufferReadIndex(&hAxis[Axis], BUFFER_ID, &readindex);
		printf("DisplayTraceResults=> readindex= %ld",readindex);
		
		for(i=0 ; i<nVariables; i++)
    635a:	08 94       	sec
    635c:	e1 1c       	adc	r14, r1
    635e:	f1 1c       	adc	r15, r1
    6360:	01 1d       	adc	r16, r1
    6362:	11 1d       	adc	r17, r1
    6364:	e8 14       	cp	r14, r8
    6366:	f9 04       	cpc	r15, r9
    6368:	0a 05       	cpc	r16, r10
    636a:	1b 05       	cpc	r17, r11
    636c:	48 f2       	brcs	.-110    	; 0x6300 <DisplayTraceResults+0x110>
				printf("DisplayTraceResults=> \t%#lX", bufferdata);
			else 
				printf("DisplayTraceResults=> \t%ld", bufferdata);
		}
		
		printf("\n");
    636e:	8a e0       	ldi	r24, 0x0A	; 10
    6370:	90 e0       	ldi	r25, 0x00	; 0
    6372:	0e 94 0d 89 	call	0x1121a	; 0x1121a <putchar>
	}
	while (readindex < (total_data - nVariables));	
    6376:	89 81       	ldd	r24, Y+1	; 0x01
    6378:	9a 81       	ldd	r25, Y+2	; 0x02
    637a:	ab 81       	ldd	r26, Y+3	; 0x03
    637c:	bc 81       	ldd	r27, Y+4	; 0x04
    637e:	88 19       	sub	r24, r8
    6380:	99 09       	sbc	r25, r9
    6382:	aa 09       	sbc	r26, r10
    6384:	bb 09       	sbc	r27, r11
    6386:	2d 81       	ldd	r18, Y+5	; 0x05
    6388:	3e 81       	ldd	r19, Y+6	; 0x06
    638a:	4f 81       	ldd	r20, Y+7	; 0x07
    638c:	58 85       	ldd	r21, Y+8	; 0x08
    638e:	28 17       	cp	r18, r24
    6390:	39 07       	cpc	r19, r25
    6392:	4a 07       	cpc	r20, r26
    6394:	5b 07       	cpc	r21, r27
    6396:	08 f4       	brcc	.+2      	; 0x639a <DisplayTraceResults+0x1aa>
    6398:	8c cf       	rjmp	.-232    	; 0x62b2 <DisplayTraceResults+0xc2>
} 
    639a:	2c 96       	adiw	r28, 0x0c	; 12
    639c:	0f b6       	in	r0, 0x3f	; 63
    639e:	f8 94       	cli
    63a0:	de bf       	out	0x3e, r29	; 62
    63a2:	0f be       	out	0x3f, r0	; 63
    63a4:	cd bf       	out	0x3d, r28	; 61
    63a6:	cf 91       	pop	r28
    63a8:	df 91       	pop	r29
    63aa:	1f 91       	pop	r17
    63ac:	0f 91       	pop	r16
    63ae:	ff 90       	pop	r15
    63b0:	ef 90       	pop	r14
    63b2:	df 90       	pop	r13
    63b4:	cf 90       	pop	r12
    63b6:	bf 90       	pop	r11
    63b8:	af 90       	pop	r10
    63ba:	9f 90       	pop	r9
    63bc:	8f 90       	pop	r8
    63be:	7f 90       	pop	r7
    63c0:	6f 90       	pop	r6
    63c2:	5f 90       	pop	r5
    63c4:	4f 90       	pop	r4
    63c6:	3f 90       	pop	r3
    63c8:	2f 90       	pop	r2
    63ca:	08 95       	ret

000063cc <SetupSingleAxisTrace>:
	}
}

/*****************************************************************************************/
void SetupSingleAxisTrace(tAxis Axis)
{
    63cc:	cf 92       	push	r12
    63ce:	df 92       	push	r13
    63d0:	ef 92       	push	r14
    63d2:	ff 92       	push	r15
    63d4:	0f 93       	push	r16
    63d6:	6c 01       	movw	r12, r24
	
	PMDSetTraceVariable(&hAxis[Axis], PMDTrace1, Axis2PMDAxis(Axis), PMDTraceCommandedPosition );
    63d8:	80 e6       	ldi	r24, 0x60	; 96
    63da:	90 e0       	ldi	r25, 0x00	; 0
    63dc:	c8 9e       	mul	r12, r24
    63de:	70 01       	movw	r14, r0
    63e0:	c9 9e       	mul	r12, r25
    63e2:	f0 0c       	add	r15, r0
    63e4:	d8 9e       	mul	r13, r24
    63e6:	f0 0c       	add	r15, r0
    63e8:	11 24       	eor	r1, r1
    63ea:	84 e7       	ldi	r24, 0x74	; 116
    63ec:	9d e7       	ldi	r25, 0x7D	; 125
    63ee:	e8 0e       	add	r14, r24
    63f0:	f9 1e       	adc	r15, r25
    63f2:	c6 01       	movw	r24, r12
    63f4:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    63f8:	ac 01       	movw	r20, r24
    63fa:	c7 01       	movw	r24, r14
    63fc:	60 e0       	ldi	r22, 0x00	; 0
    63fe:	70 e0       	ldi	r23, 0x00	; 0
    6400:	22 e0       	ldi	r18, 0x02	; 2
    6402:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[Axis], PMDTrace2, Axis2PMDAxis(Axis), PMDTraceActualPosition);
    6406:	c6 01       	movw	r24, r12
    6408:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    640c:	ac 01       	movw	r20, r24
    640e:	c7 01       	movw	r24, r14
    6410:	61 e0       	ldi	r22, 0x01	; 1
    6412:	70 e0       	ldi	r23, 0x00	; 0
    6414:	25 e0       	ldi	r18, 0x05	; 5
    6416:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[Axis], PMDTrace3, Axis2PMDAxis(Axis), PMDTracePositionError);
    641a:	c6 01       	movw	r24, r12
    641c:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    6420:	ac 01       	movw	r20, r24
    6422:	c7 01       	movw	r24, r14
    6424:	62 e0       	ldi	r22, 0x02	; 2
    6426:	70 e0       	ldi	r23, 0x00	; 0
    6428:	21 e0       	ldi	r18, 0x01	; 1
    642a:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[Axis], PMDTrace4, Axis2PMDAxis(Axis), PMDTraceEventStatus);
    642e:	c6 01       	movw	r24, r12
    6430:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    6434:	ac 01       	movw	r20, r24
    6436:	c7 01       	movw	r24, r14
    6438:	63 e0       	ldi	r22, 0x03	; 3
    643a:	70 e0       	ldi	r23, 0x00	; 0
    643c:	2c e0       	ldi	r18, 0x0C	; 12
    643e:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
	
	PMDSetTracePeriod(&hAxis[Axis],200);				//120ms
    6442:	c7 01       	movw	r24, r14
    6444:	68 ec       	ldi	r22, 0xC8	; 200
    6446:	70 e0       	ldi	r23, 0x00	; 0
    6448:	0e 94 13 63 	call	0xc626	; 0xc626 <PMDSetTracePeriod>
	PMDSetTraceMode(&hAxis[Axis],PMDTraceOneTime);	
    644c:	c7 01       	movw	r24, r14
    644e:	60 e0       	ldi	r22, 0x00	; 0
    6450:	70 e0       	ldi	r23, 0x00	; 0
    6452:	0e 94 2a 63 	call	0xc654	; 0xc654 <PMDSetTraceMode>
	PMDSetTraceStop(&hAxis[Axis], Axis2PMDAxis(Axis),  PMDTraceConditionEventStatus, PMDEventMotionCompleteBit, PMDTraceTriggerStateHigh );
    6456:	c6 01       	movw	r24, r12
    6458:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    645c:	bc 01       	movw	r22, r24
    645e:	c7 01       	movw	r24, r14
    6460:	42 e0       	ldi	r20, 0x02	; 2
    6462:	20 e0       	ldi	r18, 0x00	; 0
    6464:	01 e0       	ldi	r16, 0x01	; 1
    6466:	0e 94 ab 62 	call	0xc556	; 0xc556 <PMDSetTraceStop>
	PMDSetTraceStart( &hAxis[Axis], Axis2PMDAxis(Axis), PMDTraceConditionUpdate, 0, 0);
    646a:	c6 01       	movw	r24, r12
    646c:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    6470:	bc 01       	movw	r22, r24
    6472:	c7 01       	movw	r24, r14
    6474:	41 e0       	ldi	r20, 0x01	; 1
    6476:	20 e0       	ldi	r18, 0x00	; 0
    6478:	00 e0       	ldi	r16, 0x00	; 0
    647a:	0e 94 df 62 	call	0xc5be	; 0xc5be <PMDSetTraceStart>
	
}
    647e:	0f 91       	pop	r16
    6480:	ff 90       	pop	r15
    6482:	ef 90       	pop	r14
    6484:	df 90       	pop	r13
    6486:	cf 90       	pop	r12
    6488:	08 95       	ret

0000648a <Memoryconfig>:



/*****************************************************************************************/
void Memoryconfig(void)
{
    648a:	cf 93       	push	r28
    648c:	df 93       	push	r29
    648e:	c4 e7       	ldi	r28, 0x74	; 116
    6490:	dd e7       	ldi	r29, 0x7D	; 125
	
	//Defino el Comienzo y la longitud del Buffer de memoria para ambos chipsets
	
	for(axis=0; axis < DOF; axis++)
	{
		if(hAxis[axis].axis == 0)  
    6492:	8a 81       	ldd	r24, Y+2	; 0x02
    6494:	9b 81       	ldd	r25, Y+3	; 0x03
    6496:	89 2b       	or	r24, r25
    6498:	91 f4       	brne	.+36     	; 0x64be <Memoryconfig+0x34>
		{
			PMDSetBufferStart(&hAxis[axis],BUFFER_ID,BUFFER_START);
    649a:	ce 01       	movw	r24, r28
    649c:	60 e0       	ldi	r22, 0x00	; 0
    649e:	70 e0       	ldi	r23, 0x00	; 0
    64a0:	20 e0       	ldi	r18, 0x00	; 0
    64a2:	32 e0       	ldi	r19, 0x02	; 2
    64a4:	40 e0       	ldi	r20, 0x00	; 0
    64a6:	50 e0       	ldi	r21, 0x00	; 0
    64a8:	0e 94 7e 67 	call	0xcefc	; 0xcefc <PMDSetBufferStart>
			PMDSetBufferLength(&hAxis[axis],BUFFER_ID,BUFFER_LENGTH);
    64ac:	ce 01       	movw	r24, r28
    64ae:	60 e0       	ldi	r22, 0x00	; 0
    64b0:	70 e0       	ldi	r23, 0x00	; 0
    64b2:	2c ef       	ldi	r18, 0xFC	; 252
    64b4:	3f e3       	ldi	r19, 0x3F	; 63
    64b6:	40 e0       	ldi	r20, 0x00	; 0
    64b8:	50 e0       	ldi	r21, 0x00	; 0
    64ba:	0e 94 5c 67 	call	0xceb8	; 0xceb8 <PMDSetBufferLength>
    64be:	c0 5a       	subi	r28, 0xA0	; 160
    64c0:	df 4f       	sbci	r29, 0xFF	; 255
{
	uint8 axis;
	
	//Defino el Comienzo y la longitud del Buffer de memoria para ambos chipsets
	
	for(axis=0; axis < DOF; axis++)
    64c2:	8f e7       	ldi	r24, 0x7F	; 127
    64c4:	c4 35       	cpi	r28, 0x54	; 84
    64c6:	d8 07       	cpc	r29, r24
    64c8:	21 f7       	brne	.-56     	; 0x6492 <Memoryconfig+0x8>
		{
			PMDSetBufferStart(&hAxis[axis],BUFFER_ID,BUFFER_START);
			PMDSetBufferLength(&hAxis[axis],BUFFER_ID,BUFFER_LENGTH);
		}
	}
}
    64ca:	df 91       	pop	r29
    64cc:	cf 91       	pop	r28
    64ce:	08 95       	ret

000064d0 <SetupAxisTrace>:
	PMDSetTraceStart( &hAxis[Axis], Axis2PMDAxis(Axis), PMDTraceConditionUpdate, 0, 0);
	
}
/*****************************************************************************************/
void SetupAxisTrace(tCommand VisualTrace)
{
    64d0:	2f 92       	push	r2
    64d2:	3f 92       	push	r3
    64d4:	4f 92       	push	r4
    64d6:	5f 92       	push	r5
    64d8:	6f 92       	push	r6
    64da:	7f 92       	push	r7
    64dc:	8f 92       	push	r8
    64de:	9f 92       	push	r9
    64e0:	af 92       	push	r10
    64e2:	bf 92       	push	r11
    64e4:	cf 92       	push	r12
    64e6:	df 92       	push	r13
    64e8:	ef 92       	push	r14
    64ea:	ff 92       	push	r15
    64ec:	0f 93       	push	r16
    64ee:	1f 93       	push	r17
    64f0:	df 93       	push	r29
    64f2:	cf 93       	push	r28
    64f4:	cd b7       	in	r28, 0x3d	; 61
    64f6:	de b7       	in	r29, 0x3e	; 62
    64f8:	a0 97       	sbiw	r28, 0x20	; 32
    64fa:	0f b6       	in	r0, 0x3f	; 63
    64fc:	f8 94       	cli
    64fe:	de bf       	out	0x3e, r29	; 62
    6500:	0f be       	out	0x3f, r0	; 63
    6502:	cd bf       	out	0x3d, r28	; 61
    6504:	39 ac       	ldd	r3, Y+57	; 0x39
    6506:	2a ad       	ldd	r18, Y+58	; 0x3a
    6508:	2c 8f       	std	Y+28, r18	; 0x1c
    650a:	3b ad       	ldd	r19, Y+59	; 0x3b
    650c:	3d 8f       	std	Y+29, r19	; 0x1d
    650e:	8c ad       	ldd	r24, Y+60	; 0x3c
    6510:	8e 8f       	std	Y+30, r24	; 0x1e
    6512:	4d ac       	ldd	r4, Y+61	; 0x3d
    6514:	5e ac       	ldd	r5, Y+62	; 0x3e
    6516:	2f ac       	ldd	r2, Y+63	; 0x3f
	int8 i,Axis,NvaribleVisual,VariableConf;
	
	NvaribleVisual=VisualTrace.Dato;
	printf("SetupAxisTrace=> Numero de variables a configurar %d \n",NvaribleVisual);
    6518:	00 d0       	rcall	.+0      	; 0x651a <SetupAxisTrace+0x4a>
    651a:	00 d0       	rcall	.+0      	; 0x651c <SetupAxisTrace+0x4c>
    651c:	8b e8       	ldi	r24, 0x8B	; 139
    651e:	9b e4       	ldi	r25, 0x4B	; 75
    6520:	ad b7       	in	r26, 0x3d	; 61
    6522:	be b7       	in	r27, 0x3e	; 62
    6524:	12 96       	adiw	r26, 0x02	; 2
    6526:	9c 93       	st	X, r25
    6528:	8e 93       	st	-X, r24
    652a:	11 97       	sbiw	r26, 0x01	; 1
    652c:	83 2d       	mov	r24, r3
    652e:	99 27       	eor	r25, r25
    6530:	87 fd       	sbrc	r24, 7
    6532:	90 95       	com	r25
    6534:	14 96       	adiw	r26, 0x04	; 4
    6536:	9c 93       	st	X, r25
    6538:	8e 93       	st	-X, r24
    653a:	13 97       	sbiw	r26, 0x03	; 3
    653c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	Memoryconfig();
    6540:	0f 90       	pop	r0
    6542:	0f 90       	pop	r0
    6544:	0f 90       	pop	r0
    6546:	0f 90       	pop	r0
    6548:	0e 94 45 32 	call	0x648a	; 0x648a <Memoryconfig>
	printf("SetupAxisTrace=> Ejecute Memoryconfig \n");
    654c:	82 ec       	ldi	r24, 0xC2	; 194
    654e:	9b e4       	ldi	r25, 0x4B	; 75
    6550:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	DisableVariable();
    6554:	0e 94 15 2f 	call	0x5e2a	; 0x5e2a <DisableVariable>
	printf("SetupAxisTrace=> Ejecute DisableVariable \n");
    6558:	89 ee       	ldi	r24, 0xE9	; 233
    655a:	9b e4       	ldi	r25, 0x4B	; 75
    655c:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	if(NvaribleVisual>0 && NvaribleVisual <= 8) 
    6560:	83 2d       	mov	r24, r3
    6562:	81 50       	subi	r24, 0x01	; 1
    6564:	88 30       	cpi	r24, 0x08	; 8
    6566:	08 f0       	brcs	.+2      	; 0x656a <SetupAxisTrace+0x9a>
    6568:	bf c0       	rjmp	.+382    	; 0x66e8 <SetupAxisTrace+0x218>
	{
		/*Reiniciamos el contreo de variables configuradas (son globales)*/
		PMD1NVariables=0;
    656a:	10 92 1a 82 	sts	0x821A, r1
		PMD2NVariables=0;
    656e:	10 92 1b 82 	sts	0x821B, r1
    6572:	b0 e4       	ldi	r27, 0x40	; 64
    6574:	8b 2e       	mov	r8, r27
    6576:	91 2c       	mov	r9, r1
    6578:	8c 0e       	add	r8, r28
    657a:	9d 1e       	adc	r9, r29
    657c:	ac e0       	ldi	r26, 0x0C	; 12
    657e:	6a 2e       	mov	r6, r26
    6580:	71 2c       	mov	r7, r1
    6582:	6c 0e       	add	r6, r28
    6584:	7d 1e       	adc	r7, r29
    6586:	ee 24       	eor	r14, r14
		for(i=0;i<NvaribleVisual;i++)
		{
			//Obtenemos el eje a configurar
			Axis=VisualTrace.Tracecomand[i].AxisTrace;
			//Obtenemos a que PMD pertenece, y llevamos la cuenta de la varialies configuradas para cada PMD
			VariableConf=Tracevar2PMDVar(VisualTrace,i);
    6588:	e5 e3       	ldi	r30, 0x35	; 53
    658a:	f0 e0       	ldi	r31, 0x00	; 0
    658c:	ec 0f       	add	r30, r28
    658e:	fd 1f       	adc	r31, r29
    6590:	ef 8f       	std	Y+31, r30	; 0x1f
    6592:	f8 a3       	std	Y+32, r31	; 0x20
    6594:	a6 c0       	rjmp	.+332    	; 0x66e2 <SetupAxisTrace+0x212>
		PMD1NVariables=0;
		PMD2NVariables=0;
		for(i=0;i<NvaribleVisual;i++)
		{
			//Obtenemos el eje a configurar
			Axis=VisualTrace.Tracecomand[i].AxisTrace;
    6596:	d4 01       	movw	r26, r8
    6598:	dc 90       	ld	r13, X
			//Obtenemos a que PMD pertenece, y llevamos la cuenta de la varialies configuradas para cada PMD
			VariableConf=Tracevar2PMDVar(VisualTrace,i);
    659a:	39 ae       	std	Y+57, r3	; 0x39
    659c:	bc 8d       	ldd	r27, Y+28	; 0x1c
    659e:	ba af       	std	Y+58, r27	; 0x3a
    65a0:	ed 8d       	ldd	r30, Y+29	; 0x1d
    65a2:	eb af       	std	Y+59, r30	; 0x3b
    65a4:	fe 8d       	ldd	r31, Y+30	; 0x1e
    65a6:	fc af       	std	Y+60, r31	; 0x3c
    65a8:	5e ae       	std	Y+62, r5	; 0x3e
    65aa:	4d ae       	std	Y+61, r4	; 0x3d
    65ac:	2f ae       	std	Y+63, r2	; 0x3f
    65ae:	de 01       	movw	r26, r28
    65b0:	11 96       	adiw	r26, 0x01	; 1
    65b2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    65b4:	98 a1       	ldd	r25, Y+32	; 0x20
    65b6:	fc 01       	movw	r30, r24
    65b8:	8b e1       	ldi	r24, 0x1B	; 27
    65ba:	01 90       	ld	r0, Z+
    65bc:	0d 92       	st	X+, r0
    65be:	81 50       	subi	r24, 0x01	; 1
    65c0:	e1 f7       	brne	.-8      	; 0x65ba <SetupAxisTrace+0xea>
{
	int8 Result,Axis;
	
	
	Axis=VisualTrace.Tracecomand[TracevarIndex].AxisTrace;
	if(Axis==AxisRoll) 
    65c2:	d3 01       	movw	r26, r6
    65c4:	8c 91       	ld	r24, X
    65c6:	84 30       	cpi	r24, 0x04	; 4
    65c8:	31 f4       	brne	.+12     	; 0x65d6 <SetupAxisTrace+0x106>
	{
		Result=PMD2NVariables;
    65ca:	00 91 1b 82 	lds	r16, 0x821B
		PMD2NVariables++;
    65ce:	0f 5f       	subi	r16, 0xFF	; 255
    65d0:	00 93 1b 82 	sts	0x821B, r16
    65d4:	05 c0       	rjmp	.+10     	; 0x65e0 <SetupAxisTrace+0x110>
	}
	else
	{
		Result=PMD1NVariables;
    65d6:	00 91 1a 82 	lds	r16, 0x821A
		PMD1NVariables++;
    65da:	0f 5f       	subi	r16, 0xFF	; 255
    65dc:	00 93 1a 82 	sts	0x821A, r16
    65e0:	01 50       	subi	r16, 0x01	; 1
		{
			//Obtenemos el eje a configurar
			Axis=VisualTrace.Tracecomand[i].AxisTrace;
			//Obtenemos a que PMD pertenece, y llevamos la cuenta de la varialies configuradas para cada PMD
			VariableConf=Tracevar2PMDVar(VisualTrace,i);
			printf("SetupAxisTrace=> Configurando la variable %d = al CMD # %d en el EJE %s \n",VariableConf,VisualTrace.Tracecomand[i].TraceVar,AxisName(Axis));
    65e2:	f4 01       	movw	r30, r8
    65e4:	f1 80       	ldd	r15, Z+1	; 0x01
    65e6:	ad 2c       	mov	r10, r13
    65e8:	bb 24       	eor	r11, r11
    65ea:	a7 fc       	sbrc	r10, 7
    65ec:	b0 94       	com	r11
    65ee:	c5 01       	movw	r24, r10
    65f0:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    65f4:	2d b7       	in	r18, 0x3d	; 61
    65f6:	3e b7       	in	r19, 0x3e	; 62
    65f8:	28 50       	subi	r18, 0x08	; 8
    65fa:	30 40       	sbci	r19, 0x00	; 0
    65fc:	0f b6       	in	r0, 0x3f	; 63
    65fe:	f8 94       	cli
    6600:	3e bf       	out	0x3e, r19	; 62
    6602:	0f be       	out	0x3f, r0	; 63
    6604:	2d bf       	out	0x3d, r18	; 61
    6606:	ed b7       	in	r30, 0x3d	; 61
    6608:	fe b7       	in	r31, 0x3e	; 62
    660a:	31 96       	adiw	r30, 0x01	; 1
    660c:	23 e1       	ldi	r18, 0x13	; 19
    660e:	3c e4       	ldi	r19, 0x4C	; 76
    6610:	ad b7       	in	r26, 0x3d	; 61
    6612:	be b7       	in	r27, 0x3e	; 62
    6614:	12 96       	adiw	r26, 0x02	; 2
    6616:	3c 93       	st	X, r19
    6618:	2e 93       	st	-X, r18
    661a:	11 97       	sbiw	r26, 0x01	; 1
    661c:	11 27       	eor	r17, r17
    661e:	07 fd       	sbrc	r16, 7
    6620:	10 95       	com	r17
    6622:	13 83       	std	Z+3, r17	; 0x03
    6624:	02 83       	std	Z+2, r16	; 0x02
    6626:	2f 2d       	mov	r18, r15
    6628:	33 27       	eor	r19, r19
    662a:	27 fd       	sbrc	r18, 7
    662c:	30 95       	com	r19
    662e:	35 83       	std	Z+5, r19	; 0x05
    6630:	24 83       	std	Z+4, r18	; 0x04
    6632:	97 83       	std	Z+7, r25	; 0x07
    6634:	86 83       	std	Z+6, r24	; 0x06
    6636:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDSetTraceVariable(&hAxis[Axis],VariableConf,Axis2PMDAxis(Axis),VisualTrace.Tracecomand[i].TraceVar); 
    663a:	3d 2d       	mov	r19, r13
    663c:	80 e6       	ldi	r24, 0x60	; 96
    663e:	38 02       	muls	r19, r24
    6640:	60 01       	movw	r12, r0
    6642:	11 24       	eor	r1, r1
    6644:	a4 e7       	ldi	r26, 0x74	; 116
    6646:	bd e7       	ldi	r27, 0x7D	; 125
    6648:	ca 0e       	add	r12, r26
    664a:	db 1e       	adc	r13, r27
    664c:	ed b7       	in	r30, 0x3d	; 61
    664e:	fe b7       	in	r31, 0x3e	; 62
    6650:	38 96       	adiw	r30, 0x08	; 8
    6652:	0f b6       	in	r0, 0x3f	; 63
    6654:	f8 94       	cli
    6656:	fe bf       	out	0x3e, r31	; 62
    6658:	0f be       	out	0x3f, r0	; 63
    665a:	ed bf       	out	0x3d, r30	; 61
    665c:	c5 01       	movw	r24, r10
    665e:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    6662:	ac 01       	movw	r20, r24
    6664:	c6 01       	movw	r24, r12
    6666:	b8 01       	movw	r22, r16
    6668:	2f 2d       	mov	r18, r15
    666a:	0e 94 11 66 	call	0xcc22	; 0xcc22 <PMDSetTraceVariable>
			printf("SetupAxisTrace=> Configurando  Sample Trace_time %d \n",VisualTrace.TraceTime);		
    666e:	00 d0       	rcall	.+0      	; 0x6670 <SetupAxisTrace+0x1a0>
    6670:	00 d0       	rcall	.+0      	; 0x6672 <SetupAxisTrace+0x1a2>
    6672:	ed e5       	ldi	r30, 0x5D	; 93
    6674:	fc e4       	ldi	r31, 0x4C	; 76
    6676:	ad b7       	in	r26, 0x3d	; 61
    6678:	be b7       	in	r27, 0x3e	; 62
    667a:	12 96       	adiw	r26, 0x02	; 2
    667c:	fc 93       	st	X, r31
    667e:	ee 93       	st	-X, r30
    6680:	11 97       	sbiw	r26, 0x01	; 1
    6682:	14 96       	adiw	r26, 0x04	; 4
    6684:	5c 92       	st	X, r5
    6686:	4e 92       	st	-X, r4
    6688:	13 97       	sbiw	r26, 0x03	; 3
    668a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDSetTracePeriod(&hAxis[Axis],VisualTrace.TraceTime);
    668e:	0f 90       	pop	r0
    6690:	0f 90       	pop	r0
    6692:	0f 90       	pop	r0
    6694:	0f 90       	pop	r0
    6696:	c6 01       	movw	r24, r12
    6698:	b2 01       	movw	r22, r4
    669a:	0e 94 13 63 	call	0xc626	; 0xc626 <PMDSetTracePeriod>
			PMDSetTraceMode(&hAxis[Axis],PMDTraceOneTime);	
    669e:	c6 01       	movw	r24, r12
    66a0:	60 e0       	ldi	r22, 0x00	; 0
    66a2:	70 e0       	ldi	r23, 0x00	; 0
    66a4:	0e 94 2a 63 	call	0xc654	; 0xc654 <PMDSetTraceMode>
			if(VisualTrace.TraceTraj==0)
    66a8:	22 20       	and	r2, r2
    66aa:	51 f4       	brne	.+20     	; 0x66c0 <SetupAxisTrace+0x1f0>
				PMDSetTraceStop(&hAxis[Axis], Axis2PMDAxis(Axis),  PMDTraceConditionEventStatus, PMDEventMotionCompleteBit, PMDTraceTriggerStateHigh );
    66ac:	c5 01       	movw	r24, r10
    66ae:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    66b2:	bc 01       	movw	r22, r24
    66b4:	c6 01       	movw	r24, r12
    66b6:	42 e0       	ldi	r20, 0x02	; 2
    66b8:	20 e0       	ldi	r18, 0x00	; 0
    66ba:	01 e0       	ldi	r16, 0x01	; 1
    66bc:	0e 94 ab 62 	call	0xc556	; 0xc556 <PMDSetTraceStop>
			PMDSetTraceStart( &hAxis[Axis], Axis2PMDAxis(Axis), PMDTraceConditionUpdate, BUFFER_ID, PMDTraceTriggerStateHigh );
    66c0:	c5 01       	movw	r24, r10
    66c2:	0e 94 0d 68 	call	0xd01a	; 0xd01a <Axis2PMDAxis>
    66c6:	bc 01       	movw	r22, r24
    66c8:	c6 01       	movw	r24, r12
    66ca:	41 e0       	ldi	r20, 0x01	; 1
    66cc:	20 e0       	ldi	r18, 0x00	; 0
    66ce:	01 e0       	ldi	r16, 0x01	; 1
    66d0:	0e 94 df 62 	call	0xc5be	; 0xc5be <PMDSetTraceStart>
	if(NvaribleVisual>0 && NvaribleVisual <= 8) 
	{
		/*Reiniciamos el contreo de variables configuradas (son globales)*/
		PMD1NVariables=0;
		PMD2NVariables=0;
		for(i=0;i<NvaribleVisual;i++)
    66d4:	e3 94       	inc	r14
    66d6:	22 e0       	ldi	r18, 0x02	; 2
    66d8:	30 e0       	ldi	r19, 0x00	; 0
    66da:	82 0e       	add	r8, r18
    66dc:	93 1e       	adc	r9, r19
    66de:	62 0e       	add	r6, r18
    66e0:	73 1e       	adc	r7, r19
    66e2:	e3 14       	cp	r14, r3
    66e4:	0c f4       	brge	.+2      	; 0x66e8 <SetupAxisTrace+0x218>
    66e6:	57 cf       	rjmp	.-338    	; 0x6596 <SetupAxisTrace+0xc6>
				PMDSetTraceStop(&hAxis[Axis], Axis2PMDAxis(Axis),  PMDTraceConditionEventStatus, PMDEventMotionCompleteBit, PMDTraceTriggerStateHigh );
			PMDSetTraceStart( &hAxis[Axis], Axis2PMDAxis(Axis), PMDTraceConditionUpdate, BUFFER_ID, PMDTraceTriggerStateHigh );
		}
		
	}
}
    66e8:	a0 96       	adiw	r28, 0x20	; 32
    66ea:	0f b6       	in	r0, 0x3f	; 63
    66ec:	f8 94       	cli
    66ee:	de bf       	out	0x3e, r29	; 62
    66f0:	0f be       	out	0x3f, r0	; 63
    66f2:	cd bf       	out	0x3d, r28	; 61
    66f4:	cf 91       	pop	r28
    66f6:	df 91       	pop	r29
    66f8:	1f 91       	pop	r17
    66fa:	0f 91       	pop	r16
    66fc:	ff 90       	pop	r15
    66fe:	ef 90       	pop	r14
    6700:	df 90       	pop	r13
    6702:	cf 90       	pop	r12
    6704:	bf 90       	pop	r11
    6706:	af 90       	pop	r10
    6708:	9f 90       	pop	r9
    670a:	8f 90       	pop	r8
    670c:	7f 90       	pop	r7
    670e:	6f 90       	pop	r6
    6710:	5f 90       	pop	r5
    6712:	4f 90       	pop	r4
    6714:	3f 90       	pop	r3
    6716:	2f 90       	pop	r2
    6718:	08 95       	ret

0000671a <max>:
	
}

/**********************************************************************************************************************/
PMDint32 max(PMDint32 a, PMDint32 b)
{
    671a:	ef 92       	push	r14
    671c:	ff 92       	push	r15
    671e:	0f 93       	push	r16
    6720:	1f 93       	push	r17
    6722:	7b 01       	movw	r14, r22
    6724:	8c 01       	movw	r16, r24
    6726:	c9 01       	movw	r24, r18
    6728:	da 01       	movw	r26, r20
    672a:	9c 01       	movw	r18, r24
    672c:	ad 01       	movw	r20, r26
    672e:	2e 15       	cp	r18, r14
    6730:	3f 05       	cpc	r19, r15
    6732:	40 07       	cpc	r20, r16
    6734:	51 07       	cpc	r21, r17
    6736:	14 f4       	brge	.+4      	; 0x673c <max+0x22>
    6738:	a8 01       	movw	r20, r16
    673a:	97 01       	movw	r18, r14
	if (a > b) 
		return a;
	else
		return b;
}
    673c:	b9 01       	movw	r22, r18
    673e:	ca 01       	movw	r24, r20
    6740:	1f 91       	pop	r17
    6742:	0f 91       	pop	r16
    6744:	ff 90       	pop	r15
    6746:	ef 90       	pop	r14
    6748:	08 95       	ret

0000674a <min>:

/**********************************************************************************************************************/
PMDint32 min(PMDint32 a, PMDint32 b)
{
    674a:	ef 92       	push	r14
    674c:	ff 92       	push	r15
    674e:	0f 93       	push	r16
    6750:	1f 93       	push	r17
    6752:	7b 01       	movw	r14, r22
    6754:	8c 01       	movw	r16, r24
    6756:	c9 01       	movw	r24, r18
    6758:	da 01       	movw	r26, r20
    675a:	9c 01       	movw	r18, r24
    675c:	ad 01       	movw	r20, r26
    675e:	e2 16       	cp	r14, r18
    6760:	f3 06       	cpc	r15, r19
    6762:	04 07       	cpc	r16, r20
    6764:	15 07       	cpc	r17, r21
    6766:	14 f4       	brge	.+4      	; 0x676c <min+0x22>
    6768:	a8 01       	movw	r20, r16
    676a:	97 01       	movw	r18, r14
	if (a < b) 
		return a;
	else
		return b;
}
    676c:	b9 01       	movw	r22, r18
    676e:	ca 01       	movw	r24, r20
    6770:	1f 91       	pop	r17
    6772:	0f 91       	pop	r16
    6774:	ff 90       	pop	r15
    6776:	ef 90       	pop	r14
    6778:	08 95       	ret

0000677a <AjustarPosicionActual>:
	
}

/**********************************************************************************************************************/
void AjustarPosicionActual(tAxis Axis, PMDint32 AJUSTE)
{
    677a:	cf 92       	push	r12
    677c:	df 92       	push	r13
    677e:	ef 92       	push	r14
    6780:	ff 92       	push	r15
    6782:	0f 93       	push	r16
    6784:	1f 93       	push	r17
    6786:	df 93       	push	r29
    6788:	cf 93       	push	r28
    678a:	cd b7       	in	r28, 0x3d	; 61
    678c:	de b7       	in	r29, 0x3e	; 62
    678e:	28 97       	sbiw	r28, 0x08	; 8
    6790:	0f b6       	in	r0, 0x3f	; 63
    6792:	f8 94       	cli
    6794:	de bf       	out	0x3e, r29	; 62
    6796:	0f be       	out	0x3f, r0	; 63
    6798:	cd bf       	out	0x3d, r28	; 61
    679a:	6a 01       	movw	r12, r20
    679c:	7b 01       	movw	r14, r22
	PMDint32 registro_posicion, registro_encoder, AJUSTE_MODIFICADO;
	
	PMDGetPosition(&hAxis[Axis], &registro_posicion);
    679e:	20 e6       	ldi	r18, 0x60	; 96
    67a0:	30 e0       	ldi	r19, 0x00	; 0
    67a2:	82 9f       	mul	r24, r18
    67a4:	80 01       	movw	r16, r0
    67a6:	83 9f       	mul	r24, r19
    67a8:	10 0d       	add	r17, r0
    67aa:	92 9f       	mul	r25, r18
    67ac:	10 0d       	add	r17, r0
    67ae:	11 24       	eor	r1, r1
    67b0:	0c 58       	subi	r16, 0x8C	; 140
    67b2:	12 48       	sbci	r17, 0x82	; 130
    67b4:	c8 01       	movw	r24, r16
    67b6:	be 01       	movw	r22, r28
    67b8:	6f 5f       	subi	r22, 0xFF	; 255
    67ba:	7f 4f       	sbci	r23, 0xFF	; 255
    67bc:	0e 94 b6 64 	call	0xc96c	; 0xc96c <PMDGetPosition>
	//Se halla el nuevo valor de AJUSTE.
	PMDGetActualPosition(&hAxis[Axis],&registro_encoder);
    67c0:	c8 01       	movw	r24, r16
    67c2:	be 01       	movw	r22, r28
    67c4:	6b 5f       	subi	r22, 0xFB	; 251
    67c6:	7f 4f       	sbci	r23, 0xFF	; 255
    67c8:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
	
	if(registro_posicion >  0)	  //no pasa nada							
    67cc:	89 81       	ldd	r24, Y+1	; 0x01
    67ce:	9a 81       	ldd	r25, Y+2	; 0x02
    67d0:	ab 81       	ldd	r26, Y+3	; 0x03
    67d2:	bc 81       	ldd	r27, Y+4	; 0x04
    67d4:	18 16       	cp	r1, r24
    67d6:	19 06       	cpc	r1, r25
    67d8:	1a 06       	cpc	r1, r26
    67da:	1b 06       	cpc	r1, r27
    67dc:	24 f4       	brge	.+8      	; 0x67e6 <AjustarPosicionActual+0x6c>
	{
		
		//Ajustar el registro de posicin actual con el valor de AJUSTE.
		PMDAdjustActualPosition(&hAxis[Axis],AJUSTE);
    67de:	c8 01       	movw	r24, r16
    67e0:	b7 01       	movw	r22, r14
    67e2:	a6 01       	movw	r20, r12
    67e4:	10 c0       	rjmp	.+32     	; 0x6806 <AjustarPosicionActual+0x8c>
	}
	else //El movimiento anterior fu negativo.
	{
		//Cargar el registro de posicin actual con cero.
		PMDSetActualPosition(&hAxis[Axis],0);
    67e6:	c8 01       	movw	r24, r16
    67e8:	40 e0       	ldi	r20, 0x00	; 0
    67ea:	50 e0       	ldi	r21, 0x00	; 0
    67ec:	60 e0       	ldi	r22, 0x00	; 0
    67ee:	70 e0       	ldi	r23, 0x00	; 0
    67f0:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>
		
		AJUSTE_MODIFICADO = AJUSTE + registro_encoder;
		
		
		//Ajustar el registro de posicin actual con el valor de AJUSTE_MODIFICADO.
		PMDAdjustActualPosition(&hAxis[Axis],AJUSTE_MODIFICADO);		
    67f4:	4d 81       	ldd	r20, Y+5	; 0x05
    67f6:	5e 81       	ldd	r21, Y+6	; 0x06
    67f8:	6f 81       	ldd	r22, Y+7	; 0x07
    67fa:	78 85       	ldd	r23, Y+8	; 0x08
    67fc:	4c 0d       	add	r20, r12
    67fe:	5d 1d       	adc	r21, r13
    6800:	6e 1d       	adc	r22, r14
    6802:	7f 1d       	adc	r23, r15
    6804:	c8 01       	movw	r24, r16
    6806:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>
		
	}
	
	
}
    680a:	28 96       	adiw	r28, 0x08	; 8
    680c:	0f b6       	in	r0, 0x3f	; 63
    680e:	f8 94       	cli
    6810:	de bf       	out	0x3e, r29	; 62
    6812:	0f be       	out	0x3f, r0	; 63
    6814:	cd bf       	out	0x3d, r28	; 61
    6816:	cf 91       	pop	r28
    6818:	df 91       	pop	r29
    681a:	1f 91       	pop	r17
    681c:	0f 91       	pop	r16
    681e:	ff 90       	pop	r15
    6820:	ef 90       	pop	r14
    6822:	df 90       	pop	r13
    6824:	cf 90       	pop	r12
    6826:	08 95       	ret

00006828 <SetPosicionActual>:
	}
}
 
/**********************************************************************************************************************/
void SetPosicionActual(tAxis Axis, PMDint32 AJUSTE)
{
    6828:	cf 92       	push	r12
    682a:	df 92       	push	r13
    682c:	ef 92       	push	r14
    682e:	ff 92       	push	r15
    6830:	0f 93       	push	r16
    6832:	1f 93       	push	r17
    6834:	9c 01       	movw	r18, r24
    6836:	6a 01       	movw	r12, r20
    6838:	7b 01       	movw	r14, r22
	if(AJUSTE >=  0)								
    683a:	77 fd       	sbrc	r23, 7
    683c:	11 c0       	rjmp	.+34     	; 0x6860 <SetPosicionActual+0x38>
	{
		
		PMDSetActualPosition(&hAxis[Axis],AJUSTE);
    683e:	80 e6       	ldi	r24, 0x60	; 96
    6840:	90 e0       	ldi	r25, 0x00	; 0
    6842:	ac 01       	movw	r20, r24
    6844:	24 9f       	mul	r18, r20
    6846:	c0 01       	movw	r24, r0
    6848:	25 9f       	mul	r18, r21
    684a:	90 0d       	add	r25, r0
    684c:	34 9f       	mul	r19, r20
    684e:	90 0d       	add	r25, r0
    6850:	11 24       	eor	r1, r1
    6852:	8c 58       	subi	r24, 0x8C	; 140
    6854:	92 48       	sbci	r25, 0x82	; 130
    6856:	b7 01       	movw	r22, r14
    6858:	a6 01       	movw	r20, r12
    685a:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>
    685e:	17 c0       	rjmp	.+46     	; 0x688e <SetPosicionActual+0x66>
	}
	else //Valor a cargar es negativo.
	{
		//Cargar el registro de posicin actual con cero.
		PMDSetActualPosition(&hAxis[Axis],0);
    6860:	80 e6       	ldi	r24, 0x60	; 96
    6862:	90 e0       	ldi	r25, 0x00	; 0
    6864:	28 9f       	mul	r18, r24
    6866:	80 01       	movw	r16, r0
    6868:	29 9f       	mul	r18, r25
    686a:	10 0d       	add	r17, r0
    686c:	38 9f       	mul	r19, r24
    686e:	10 0d       	add	r17, r0
    6870:	11 24       	eor	r1, r1
    6872:	0c 58       	subi	r16, 0x8C	; 140
    6874:	12 48       	sbci	r17, 0x82	; 130
    6876:	c8 01       	movw	r24, r16
    6878:	40 e0       	ldi	r20, 0x00	; 0
    687a:	50 e0       	ldi	r21, 0x00	; 0
    687c:	60 e0       	ldi	r22, 0x00	; 0
    687e:	70 e0       	ldi	r23, 0x00	; 0
    6880:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>
		
		//Ajustar el registro de posicin actual con el valor de AJUSTE.
		PMDAdjustActualPosition(&hAxis[Axis],AJUSTE);		
    6884:	c8 01       	movw	r24, r16
    6886:	b7 01       	movw	r22, r14
    6888:	a6 01       	movw	r20, r12
    688a:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>
		
	}
	
	
}
    688e:	1f 91       	pop	r17
    6890:	0f 91       	pop	r16
    6892:	ff 90       	pop	r15
    6894:	ef 90       	pop	r14
    6896:	df 90       	pop	r13
    6898:	cf 90       	pop	r12
    689a:	08 95       	ret

0000689c <No_limit_switch>:
	
}

/**********************************************************************************************************************/
void No_limit_switch(int Ini_Axis)
{
    689c:	4f 92       	push	r4
    689e:	5f 92       	push	r5
    68a0:	6f 92       	push	r6
    68a2:	7f 92       	push	r7
    68a4:	8f 92       	push	r8
    68a6:	9f 92       	push	r9
    68a8:	af 92       	push	r10
    68aa:	bf 92       	push	r11
    68ac:	cf 92       	push	r12
    68ae:	df 92       	push	r13
    68b0:	ef 92       	push	r14
    68b2:	ff 92       	push	r15
    68b4:	0f 93       	push	r16
    68b6:	1f 93       	push	r17
    68b8:	df 93       	push	r29
    68ba:	cf 93       	push	r28
    68bc:	00 d0       	rcall	.+0      	; 0x68be <No_limit_switch+0x22>
    68be:	cd b7       	in	r28, 0x3d	; 61
    68c0:	de b7       	in	r29, 0x3e	; 62
	PMDuint16 Axis,Limit_switch;
	
	//No se toma en cuenta roll ya que carese de sentido
	if(Ini_Axis!=AxisRoll)
    68c2:	84 30       	cpi	r24, 0x04	; 4
    68c4:	91 05       	cpc	r25, r1
    68c6:	09 f4       	brne	.+2      	; 0x68ca <No_limit_switch+0x2e>
    68c8:	92 c0       	rjmp	.+292    	; 0x69ee <No_limit_switch+0x152>
	{
		for(Axis=(Ini_Axis);Axis<DOF;Axis++)
    68ca:	8c 01       	movw	r16, r24
    68cc:	80 e6       	ldi	r24, 0x60	; 96
    68ce:	90 e0       	ldi	r25, 0x00	; 0
    68d0:	08 9f       	mul	r16, r24
    68d2:	70 01       	movw	r14, r0
    68d4:	09 9f       	mul	r16, r25
    68d6:	f0 0c       	add	r15, r0
    68d8:	18 9f       	mul	r17, r24
    68da:	f0 0c       	add	r15, r0
    68dc:	11 24       	eor	r1, r1
    68de:	24 e7       	ldi	r18, 0x74	; 116
    68e0:	3d e7       	ldi	r19, 0x7D	; 125
    68e2:	e2 0e       	add	r14, r18
    68e4:	f3 1e       	adc	r15, r19
		{
			PMDGetSignalStatus(&hAxis[Axis],&Limit_switch); 
    68e6:	2e 01       	movw	r4, r28
    68e8:	08 94       	sec
    68ea:	41 1c       	adc	r4, r1
    68ec:	51 1c       	adc	r5, r1
			printf("No_limit_switch=> sensando de limites eje %s  en No_limit_switch = %x\n ",AxisName(Axis),Limit_switch);
    68ee:	23 e9       	ldi	r18, 0x93	; 147
    68f0:	62 2e       	mov	r6, r18
    68f2:	2c e4       	ldi	r18, 0x4C	; 76
    68f4:	72 2e       	mov	r7, r18
			if(!((Limit_switch & PMDSignalPositiveLimitMask)!=0))//El lmite positivo est activo (presionado).
			{
				if(Axis!=AxisRoll)
				{
					printf("No_limit_switch=> Limites Positivo activado por el  eje %s\n ",AxisName(Axis));
    68f6:	9b ed       	ldi	r25, 0xDB	; 219
    68f8:	89 2e       	mov	r8, r25
    68fa:	9c e4       	ldi	r25, 0x4C	; 76
    68fc:	99 2e       	mov	r9, r25
			}		
			if(!((Limit_switch & PMDSignalNegativeLimitMask)!=0))
			{
				if(Axis!=AxisRoll)
				{
					printf("No_limit_switch=> Limites Negativo activado por el  eje %s\n ",AxisName(Axis));
    68fe:	8c e6       	ldi	r24, 0x6C	; 108
    6900:	a8 2e       	mov	r10, r24
    6902:	8d e4       	ldi	r24, 0x4D	; 77
    6904:	b8 2e       	mov	r11, r24
    6906:	6f c0       	rjmp	.+222    	; 0x69e6 <No_limit_switch+0x14a>
	//No se toma en cuenta roll ya que carese de sentido
	if(Ini_Axis!=AxisRoll)
	{
		for(Axis=(Ini_Axis);Axis<DOF;Axis++)
		{
			PMDGetSignalStatus(&hAxis[Axis],&Limit_switch); 
    6908:	c7 01       	movw	r24, r14
    690a:	b2 01       	movw	r22, r4
    690c:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
    6910:	d0 2e       	mov	r13, r16
    6912:	c1 2e       	mov	r12, r17
			printf("No_limit_switch=> sensando de limites eje %s  en No_limit_switch = %x\n ",AxisName(Axis),Limit_switch);
    6914:	c8 01       	movw	r24, r16
    6916:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    691a:	00 d0       	rcall	.+0      	; 0x691c <No_limit_switch+0x80>
    691c:	00 d0       	rcall	.+0      	; 0x691e <No_limit_switch+0x82>
    691e:	00 d0       	rcall	.+0      	; 0x6920 <No_limit_switch+0x84>
    6920:	ed b7       	in	r30, 0x3d	; 61
    6922:	fe b7       	in	r31, 0x3e	; 62
    6924:	31 96       	adiw	r30, 0x01	; 1
    6926:	ad b7       	in	r26, 0x3d	; 61
    6928:	be b7       	in	r27, 0x3e	; 62
    692a:	12 96       	adiw	r26, 0x02	; 2
    692c:	7c 92       	st	X, r7
    692e:	6e 92       	st	-X, r6
    6930:	11 97       	sbiw	r26, 0x01	; 1
    6932:	93 83       	std	Z+3, r25	; 0x03
    6934:	82 83       	std	Z+2, r24	; 0x02
    6936:	89 81       	ldd	r24, Y+1	; 0x01
    6938:	9a 81       	ldd	r25, Y+2	; 0x02
    693a:	95 83       	std	Z+5, r25	; 0x05
    693c:	84 83       	std	Z+4, r24	; 0x04
    693e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			if(!((Limit_switch & PMDSignalPositiveLimitMask)!=0))//El lmite positivo est activo (presionado).
    6942:	89 81       	ldd	r24, Y+1	; 0x01
    6944:	ed b7       	in	r30, 0x3d	; 61
    6946:	fe b7       	in	r31, 0x3e	; 62
    6948:	36 96       	adiw	r30, 0x06	; 6
    694a:	0f b6       	in	r0, 0x3f	; 63
    694c:	f8 94       	cli
    694e:	fe bf       	out	0x3e, r31	; 62
    6950:	0f be       	out	0x3f, r0	; 63
    6952:	ed bf       	out	0x3d, r30	; 61
    6954:	84 fd       	sbrc	r24, 4
    6956:	20 c0       	rjmp	.+64     	; 0x6998 <No_limit_switch+0xfc>
			{
				if(Axis!=AxisRoll)
    6958:	04 30       	cpi	r16, 0x04	; 4
    695a:	11 05       	cpc	r17, r1
    695c:	c9 f0       	breq	.+50     	; 0x6990 <No_limit_switch+0xf4>
				{
					printf("No_limit_switch=> Limites Positivo activado por el  eje %s\n ",AxisName(Axis));
    695e:	c8 01       	movw	r24, r16
    6960:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    6964:	00 d0       	rcall	.+0      	; 0x6966 <No_limit_switch+0xca>
    6966:	00 d0       	rcall	.+0      	; 0x6968 <No_limit_switch+0xcc>
    6968:	ad b7       	in	r26, 0x3d	; 61
    696a:	be b7       	in	r27, 0x3e	; 62
    696c:	12 96       	adiw	r26, 0x02	; 2
    696e:	9c 92       	st	X, r9
    6970:	8e 92       	st	-X, r8
    6972:	11 97       	sbiw	r26, 0x01	; 1
    6974:	14 96       	adiw	r26, 0x04	; 4
    6976:	9c 93       	st	X, r25
    6978:	8e 93       	st	-X, r24
    697a:	13 97       	sbiw	r26, 0x03	; 3
    697c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
					Positivehandling(Axis);	
    6980:	0f 90       	pop	r0
    6982:	0f 90       	pop	r0
    6984:	0f 90       	pop	r0
    6986:	0f 90       	pop	r0
    6988:	c8 01       	movw	r24, r16
    698a:	0e 94 b8 5c 	call	0xb970	; 0xb970 <Positivehandling>
    698e:	04 c0       	rjmp	.+8      	; 0x6998 <No_limit_switch+0xfc>
				}
				else
				{	
					//Tiene que estar desconectado o hubo un error con el movimiento de pitch, pues pitch tiene los
					//mismo interuptores.
					printf("No_limit_switch=> Cable #2 de Sensores esta DESCONECTADO! limite positivo activado \n");
    6990:	88 e1       	ldi	r24, 0x18	; 24
    6992:	9d e4       	ldi	r25, 0x4D	; 77
    6994:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				}
			}		
			if(!((Limit_switch & PMDSignalNegativeLimitMask)!=0))
    6998:	89 81       	ldd	r24, Y+1	; 0x01
    699a:	85 fd       	sbrc	r24, 5
    699c:	1e c0       	rjmp	.+60     	; 0x69da <No_limit_switch+0x13e>
			{
				if(Axis!=AxisRoll)
    699e:	04 30       	cpi	r16, 0x04	; 4
    69a0:	11 05       	cpc	r17, r1
    69a2:	b9 f0       	breq	.+46     	; 0x69d2 <No_limit_switch+0x136>
				{
					printf("No_limit_switch=> Limites Negativo activado por el  eje %s\n ",AxisName(Axis));
    69a4:	8d 2d       	mov	r24, r13
    69a6:	9c 2d       	mov	r25, r12
    69a8:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    69ac:	00 d0       	rcall	.+0      	; 0x69ae <No_limit_switch+0x112>
    69ae:	00 d0       	rcall	.+0      	; 0x69b0 <No_limit_switch+0x114>
    69b0:	ed b7       	in	r30, 0x3d	; 61
    69b2:	fe b7       	in	r31, 0x3e	; 62
    69b4:	b2 82       	std	Z+2, r11	; 0x02
    69b6:	a1 82       	std	Z+1, r10	; 0x01
    69b8:	94 83       	std	Z+4, r25	; 0x04
    69ba:	83 83       	std	Z+3, r24	; 0x03
    69bc:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
					Negativehandling(Axis);	
    69c0:	0f 90       	pop	r0
    69c2:	0f 90       	pop	r0
    69c4:	0f 90       	pop	r0
    69c6:	0f 90       	pop	r0
    69c8:	8d 2d       	mov	r24, r13
    69ca:	9c 2d       	mov	r25, r12
    69cc:	0e 94 d0 5b 	call	0xb7a0	; 0xb7a0 <Negativehandling>
    69d0:	04 c0       	rjmp	.+8      	; 0x69da <No_limit_switch+0x13e>
				}
				else
				{
					//Tiene que estar desconectado o hubo un error con el movimiento de pitch, pues pitch tiene los
					//mismo interuptores.
					printf("No_limit_switch=> Cable #2 de Sensores esta DESCONECTADO! limite negativo activado \n");
    69d2:	89 ea       	ldi	r24, 0xA9	; 169
    69d4:	9d e4       	ldi	r25, 0x4D	; 77
    69d6:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	PMDuint16 Axis,Limit_switch;
	
	//No se toma en cuenta roll ya que carese de sentido
	if(Ini_Axis!=AxisRoll)
	{
		for(Axis=(Ini_Axis);Axis<DOF;Axis++)
    69da:	0f 5f       	subi	r16, 0xFF	; 255
    69dc:	1f 4f       	sbci	r17, 0xFF	; 255
    69de:	20 e6       	ldi	r18, 0x60	; 96
    69e0:	30 e0       	ldi	r19, 0x00	; 0
    69e2:	e2 0e       	add	r14, r18
    69e4:	f3 1e       	adc	r15, r19
    69e6:	05 30       	cpi	r16, 0x05	; 5
    69e8:	11 05       	cpc	r17, r1
    69ea:	08 f4       	brcc	.+2      	; 0x69ee <No_limit_switch+0x152>
    69ec:	8d cf       	rjmp	.-230    	; 0x6908 <No_limit_switch+0x6c>
				
			}
		}
	}

} 
    69ee:	0f 90       	pop	r0
    69f0:	0f 90       	pop	r0
    69f2:	cf 91       	pop	r28
    69f4:	df 91       	pop	r29
    69f6:	1f 91       	pop	r17
    69f8:	0f 91       	pop	r16
    69fa:	ff 90       	pop	r15
    69fc:	ef 90       	pop	r14
    69fe:	df 90       	pop	r13
    6a00:	cf 90       	pop	r12
    6a02:	bf 90       	pop	r11
    6a04:	af 90       	pop	r10
    6a06:	9f 90       	pop	r9
    6a08:	8f 90       	pop	r8
    6a0a:	7f 90       	pop	r7
    6a0c:	6f 90       	pop	r6
    6a0e:	5f 90       	pop	r5
    6a10:	4f 90       	pop	r4
    6a12:	08 95       	ret

00006a14 <ObtenerPose>:



/**********************************************************************************************************************/
void ObtenerPose(PoseRobot *Pose)
{
    6a14:	cf 92       	push	r12
    6a16:	df 92       	push	r13
    6a18:	ef 92       	push	r14
    6a1a:	ff 92       	push	r15
    6a1c:	0f 93       	push	r16
    6a1e:	1f 93       	push	r17
    6a20:	df 93       	push	r29
    6a22:	cf 93       	push	r28
    6a24:	cd b7       	in	r28, 0x3d	; 61
    6a26:	de b7       	in	r29, 0x3e	; 62
    6a28:	2c 97       	sbiw	r28, 0x0c	; 12
    6a2a:	0f b6       	in	r0, 0x3f	; 63
    6a2c:	f8 94       	cli
    6a2e:	de bf       	out	0x3e, r29	; 62
    6a30:	0f be       	out	0x3f, r0	; 63
    6a32:	cd bf       	out	0x3d, r28	; 61
    6a34:	6c 01       	movw	r12, r24

	PMDint32 Mov_Pitch_Anterior_RAM,Mov_Roll_Anterior_RAM,Pos_Elbow_corelacionada;

	//Carga posicion de cintura
	PMDGetPosition(&hAxis[AxisWaist],&Pose->Pos_Waist);
    6a36:	bc 01       	movw	r22, r24
    6a38:	6e 5f       	subi	r22, 0xFE	; 254
    6a3a:	7f 4f       	sbci	r23, 0xFF	; 255
    6a3c:	84 e7       	ldi	r24, 0x74	; 116
    6a3e:	9d e7       	ldi	r25, 0x7D	; 125
    6a40:	0e 94 b6 64 	call	0xc96c	; 0xc96c <PMDGetPosition>
	
	//Carga poscion de hombro
	PMDGetPosition(&hAxis[AxisShoulder],&Pose->Pos_Shoulder);
    6a44:	b6 01       	movw	r22, r12
    6a46:	6a 5f       	subi	r22, 0xFA	; 250
    6a48:	7f 4f       	sbci	r23, 0xFF	; 255
    6a4a:	84 ed       	ldi	r24, 0xD4	; 212
    6a4c:	9d e7       	ldi	r25, 0x7D	; 125
    6a4e:	0e 94 b6 64 	call	0xc96c	; 0xc96c <PMDGetPosition>
	
	
	
	//Carga poscion de codo
	PMDGetPosition(&hAxis[AxisElbow],&Pos_Elbow_corelacionada);
    6a52:	84 e3       	ldi	r24, 0x34	; 52
    6a54:	9e e7       	ldi	r25, 0x7E	; 126
    6a56:	be 01       	movw	r22, r28
    6a58:	67 5f       	subi	r22, 0xF7	; 247
    6a5a:	7f 4f       	sbci	r23, 0xFF	; 255
    6a5c:	0e 94 b6 64 	call	0xc96c	; 0xc96c <PMDGetPosition>
	printf("ObtenerPose=> Pose->Pos_Elbow con correlacionado = %ld\n",Pos_Elbow_corelacionada);
    6a60:	00 d0       	rcall	.+0      	; 0x6a62 <ObtenerPose+0x4e>
    6a62:	00 d0       	rcall	.+0      	; 0x6a64 <ObtenerPose+0x50>
    6a64:	00 d0       	rcall	.+0      	; 0x6a66 <ObtenerPose+0x52>
    6a66:	8d ef       	ldi	r24, 0xFD	; 253
    6a68:	9d e4       	ldi	r25, 0x4D	; 77
    6a6a:	ed b7       	in	r30, 0x3d	; 61
    6a6c:	fe b7       	in	r31, 0x3e	; 62
    6a6e:	92 83       	std	Z+2, r25	; 0x02
    6a70:	81 83       	std	Z+1, r24	; 0x01
    6a72:	89 85       	ldd	r24, Y+9	; 0x09
    6a74:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a76:	ab 85       	ldd	r26, Y+11	; 0x0b
    6a78:	bc 85       	ldd	r27, Y+12	; 0x0c
    6a7a:	83 83       	std	Z+3, r24	; 0x03
    6a7c:	94 83       	std	Z+4, r25	; 0x04
    6a7e:	a5 83       	std	Z+5, r26	; 0x05
    6a80:	b6 83       	std	Z+6, r27	; 0x06
    6a82:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	Pose->Pos_Elbow = Pos_Elbow_corelacionada - (Pose->Pos_Shoulder*CORRELACION_HOMBRO_CODO);
    6a86:	69 85       	ldd	r22, Y+9	; 0x09
    6a88:	7a 85       	ldd	r23, Y+10	; 0x0a
    6a8a:	8b 85       	ldd	r24, Y+11	; 0x0b
    6a8c:	9c 85       	ldd	r25, Y+12	; 0x0c
    6a8e:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    6a92:	7b 01       	movw	r14, r22
    6a94:	8c 01       	movw	r16, r24
    6a96:	f6 01       	movw	r30, r12
    6a98:	66 81       	ldd	r22, Z+6	; 0x06
    6a9a:	77 81       	ldd	r23, Z+7	; 0x07
    6a9c:	80 85       	ldd	r24, Z+8	; 0x08
    6a9e:	91 85       	ldd	r25, Z+9	; 0x09
    6aa0:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    6aa4:	2d e1       	ldi	r18, 0x1D	; 29
    6aa6:	3a e5       	ldi	r19, 0x5A	; 90
    6aa8:	44 e5       	ldi	r20, 0x54	; 84
    6aaa:	5f eb       	ldi	r21, 0xBF	; 191
    6aac:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    6ab0:	9b 01       	movw	r18, r22
    6ab2:	ac 01       	movw	r20, r24
    6ab4:	c8 01       	movw	r24, r16
    6ab6:	b7 01       	movw	r22, r14
    6ab8:	0e 94 01 83 	call	0x10602	; 0x10602 <__addsf3>
    6abc:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    6ac0:	f6 01       	movw	r30, r12
    6ac2:	62 87       	std	Z+10, r22	; 0x0a
    6ac4:	73 87       	std	Z+11, r23	; 0x0b
    6ac6:	84 87       	std	Z+12, r24	; 0x0c
    6ac8:	95 87       	std	Z+13, r25	; 0x0d
	printf("ObtenerPose=> Pose->Pos_Elbow = %ld\n",Pose->Pos_Elbow);
    6aca:	25 e3       	ldi	r18, 0x35	; 53
    6acc:	3e e4       	ldi	r19, 0x4E	; 78
    6ace:	ed b7       	in	r30, 0x3d	; 61
    6ad0:	fe b7       	in	r31, 0x3e	; 62
    6ad2:	32 83       	std	Z+2, r19	; 0x02
    6ad4:	21 83       	std	Z+1, r18	; 0x01
    6ad6:	63 83       	std	Z+3, r22	; 0x03
    6ad8:	74 83       	std	Z+4, r23	; 0x04
    6ada:	85 83       	std	Z+5, r24	; 0x05
    6adc:	96 83       	std	Z+6, r25	; 0x06
    6ade:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	
	
	
	//Carga poscion de pitch
	eeprom_read_block((void*)&Mov_Pitch_Anterior_RAM,(const void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    6ae2:	8d b7       	in	r24, 0x3d	; 61
    6ae4:	9e b7       	in	r25, 0x3e	; 62
    6ae6:	06 96       	adiw	r24, 0x06	; 6
    6ae8:	0f b6       	in	r0, 0x3f	; 63
    6aea:	f8 94       	cli
    6aec:	9e bf       	out	0x3e, r25	; 62
    6aee:	0f be       	out	0x3f, r0	; 63
    6af0:	8d bf       	out	0x3d, r24	; 61
    6af2:	ce 01       	movw	r24, r28
    6af4:	01 96       	adiw	r24, 0x01	; 1
    6af6:	6a e5       	ldi	r22, 0x5A	; 90
    6af8:	71 e0       	ldi	r23, 0x01	; 1
    6afa:	44 e0       	ldi	r20, 0x04	; 4
    6afc:	50 e0       	ldi	r21, 0x00	; 0
    6afe:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
	//#ifdef DEBUGROBOTICS
	printf("ObtenerPose=> Mov_Pitch_Anterior_RAM = %ld\n",Mov_Pitch_Anterior_RAM);
    6b02:	00 d0       	rcall	.+0      	; 0x6b04 <ObtenerPose+0xf0>
    6b04:	00 d0       	rcall	.+0      	; 0x6b06 <ObtenerPose+0xf2>
    6b06:	00 d0       	rcall	.+0      	; 0x6b08 <ObtenerPose+0xf4>
    6b08:	8a e5       	ldi	r24, 0x5A	; 90
    6b0a:	9e e4       	ldi	r25, 0x4E	; 78
    6b0c:	ed b7       	in	r30, 0x3d	; 61
    6b0e:	fe b7       	in	r31, 0x3e	; 62
    6b10:	92 83       	std	Z+2, r25	; 0x02
    6b12:	81 83       	std	Z+1, r24	; 0x01
    6b14:	89 81       	ldd	r24, Y+1	; 0x01
    6b16:	9a 81       	ldd	r25, Y+2	; 0x02
    6b18:	ab 81       	ldd	r26, Y+3	; 0x03
    6b1a:	bc 81       	ldd	r27, Y+4	; 0x04
    6b1c:	83 83       	std	Z+3, r24	; 0x03
    6b1e:	94 83       	std	Z+4, r25	; 0x04
    6b20:	a5 83       	std	Z+5, r26	; 0x05
    6b22:	b6 83       	std	Z+6, r27	; 0x06
    6b24:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	//#endif
	Pose->Pos_Pitch=Mov_Pitch_Anterior_RAM - (Pos_Elbow_corelacionada *CORRELACION_CODO_PITCH) ;
    6b28:	69 81       	ldd	r22, Y+1	; 0x01
    6b2a:	7a 81       	ldd	r23, Y+2	; 0x02
    6b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    6b2e:	9c 81       	ldd	r25, Y+4	; 0x04
    6b30:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    6b34:	7b 01       	movw	r14, r22
    6b36:	8c 01       	movw	r16, r24
    6b38:	69 85       	ldd	r22, Y+9	; 0x09
    6b3a:	7a 85       	ldd	r23, Y+10	; 0x0a
    6b3c:	8b 85       	ldd	r24, Y+11	; 0x0b
    6b3e:	9c 85       	ldd	r25, Y+12	; 0x0c
    6b40:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    6b44:	29 ec       	ldi	r18, 0xC9	; 201
    6b46:	3e e8       	ldi	r19, 0x8E	; 142
    6b48:	4d e8       	ldi	r20, 0x8D	; 141
    6b4a:	5c eb       	ldi	r21, 0xBC	; 188
    6b4c:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    6b50:	9b 01       	movw	r18, r22
    6b52:	ac 01       	movw	r20, r24
    6b54:	c8 01       	movw	r24, r16
    6b56:	b7 01       	movw	r22, r14
    6b58:	0e 94 01 83 	call	0x10602	; 0x10602 <__addsf3>
    6b5c:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    6b60:	f6 01       	movw	r30, r12
    6b62:	66 87       	std	Z+14, r22	; 0x0e
    6b64:	77 87       	std	Z+15, r23	; 0x0f
    6b66:	80 8b       	std	Z+16, r24	; 0x10
    6b68:	91 8b       	std	Z+17, r25	; 0x11
	//#ifdef DEBUGROBOTICS
	printf("ObtenerPose=> Pose->Pos_Pitch = %ld\n",Pose->Pos_Pitch);
    6b6a:	26 e8       	ldi	r18, 0x86	; 134
    6b6c:	3e e4       	ldi	r19, 0x4E	; 78
    6b6e:	ed b7       	in	r30, 0x3d	; 61
    6b70:	fe b7       	in	r31, 0x3e	; 62
    6b72:	32 83       	std	Z+2, r19	; 0x02
    6b74:	21 83       	std	Z+1, r18	; 0x01
    6b76:	63 83       	std	Z+3, r22	; 0x03
    6b78:	74 83       	std	Z+4, r23	; 0x04
    6b7a:	85 83       	std	Z+5, r24	; 0x05
    6b7c:	96 83       	std	Z+6, r25	; 0x06
    6b7e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	//#endif
	
	
	
	//Carga poscion de roll
	eeprom_read_block((void*)&Mov_Roll_Anterior_RAM,(const void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    6b82:	8d b7       	in	r24, 0x3d	; 61
    6b84:	9e b7       	in	r25, 0x3e	; 62
    6b86:	06 96       	adiw	r24, 0x06	; 6
    6b88:	0f b6       	in	r0, 0x3f	; 63
    6b8a:	f8 94       	cli
    6b8c:	9e bf       	out	0x3e, r25	; 62
    6b8e:	0f be       	out	0x3f, r0	; 63
    6b90:	8d bf       	out	0x3d, r24	; 61
    6b92:	ce 01       	movw	r24, r28
    6b94:	05 96       	adiw	r24, 0x05	; 5
    6b96:	66 e5       	ldi	r22, 0x56	; 86
    6b98:	71 e0       	ldi	r23, 0x01	; 1
    6b9a:	44 e0       	ldi	r20, 0x04	; 4
    6b9c:	50 e0       	ldi	r21, 0x00	; 0
    6b9e:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
	//#ifdef DEBUGROBOTICS
	printf("ObtenerPose=> Mov_Roll_Anterior_RAM =  %ld\n",Mov_Roll_Anterior_RAM);
    6ba2:	00 d0       	rcall	.+0      	; 0x6ba4 <ObtenerPose+0x190>
    6ba4:	00 d0       	rcall	.+0      	; 0x6ba6 <ObtenerPose+0x192>
    6ba6:	00 d0       	rcall	.+0      	; 0x6ba8 <ObtenerPose+0x194>
    6ba8:	8b ea       	ldi	r24, 0xAB	; 171
    6baa:	9e e4       	ldi	r25, 0x4E	; 78
    6bac:	ed b7       	in	r30, 0x3d	; 61
    6bae:	fe b7       	in	r31, 0x3e	; 62
    6bb0:	92 83       	std	Z+2, r25	; 0x02
    6bb2:	81 83       	std	Z+1, r24	; 0x01
    6bb4:	8d 81       	ldd	r24, Y+5	; 0x05
    6bb6:	9e 81       	ldd	r25, Y+6	; 0x06
    6bb8:	af 81       	ldd	r26, Y+7	; 0x07
    6bba:	b8 85       	ldd	r27, Y+8	; 0x08
    6bbc:	83 83       	std	Z+3, r24	; 0x03
    6bbe:	94 83       	std	Z+4, r25	; 0x04
    6bc0:	a5 83       	std	Z+5, r26	; 0x05
    6bc2:	b6 83       	std	Z+6, r27	; 0x06
    6bc4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	//#endif
	Pose->Pos_Roll=Mov_Roll_Anterior_RAM;
    6bc8:	8d 81       	ldd	r24, Y+5	; 0x05
    6bca:	9e 81       	ldd	r25, Y+6	; 0x06
    6bcc:	af 81       	ldd	r26, Y+7	; 0x07
    6bce:	b8 85       	ldd	r27, Y+8	; 0x08
    6bd0:	f6 01       	movw	r30, r12
    6bd2:	82 8b       	std	Z+18, r24	; 0x12
    6bd4:	93 8b       	std	Z+19, r25	; 0x13
    6bd6:	a4 8b       	std	Z+20, r26	; 0x14
    6bd8:	b5 8b       	std	Z+21, r27	; 0x15
    6bda:	8d b7       	in	r24, 0x3d	; 61
    6bdc:	9e b7       	in	r25, 0x3e	; 62
    6bde:	06 96       	adiw	r24, 0x06	; 6
    6be0:	0f b6       	in	r0, 0x3f	; 63
    6be2:	f8 94       	cli
    6be4:	9e bf       	out	0x3e, r25	; 62
    6be6:	0f be       	out	0x3f, r0	; 63
    6be8:	8d bf       	out	0x3d, r24	; 61

}
    6bea:	2c 96       	adiw	r28, 0x0c	; 12
    6bec:	0f b6       	in	r0, 0x3f	; 63
    6bee:	f8 94       	cli
    6bf0:	de bf       	out	0x3e, r29	; 62
    6bf2:	0f be       	out	0x3f, r0	; 63
    6bf4:	cd bf       	out	0x3d, r28	; 61
    6bf6:	cf 91       	pop	r28
    6bf8:	df 91       	pop	r29
    6bfa:	1f 91       	pop	r17
    6bfc:	0f 91       	pop	r16
    6bfe:	ff 90       	pop	r15
    6c00:	ef 90       	pop	r14
    6c02:	df 90       	pop	r13
    6c04:	cf 90       	pop	r12
    6c06:	08 95       	ret

00006c08 <rangosrobot>:
/**********************************************************************************************************************/
void rangosrobot(tAxis Axis)
{
    6c08:	af 92       	push	r10
    6c0a:	bf 92       	push	r11
    6c0c:	cf 92       	push	r12
    6c0e:	df 92       	push	r13
    6c10:	ef 92       	push	r14
    6c12:	ff 92       	push	r15
    6c14:	0f 93       	push	r16
    6c16:	1f 93       	push	r17
    6c18:	df 93       	push	r29
    6c1a:	cf 93       	push	r28
    6c1c:	00 d0       	rcall	.+0      	; 0x6c1e <rangosrobot+0x16>
    6c1e:	00 d0       	rcall	.+0      	; 0x6c20 <rangosrobot+0x18>
    6c20:	cd b7       	in	r28, 0x3d	; 61
    6c22:	de b7       	in	r29, 0x3e	; 62
    6c24:	7c 01       	movw	r14, r24
	double grad;
	
	
	
	
	PMDGetActualPosition(&hAxis[Axis],&position);
    6c26:	80 e6       	ldi	r24, 0x60	; 96
    6c28:	90 e0       	ldi	r25, 0x00	; 0
    6c2a:	9c 01       	movw	r18, r24
    6c2c:	e2 9e       	mul	r14, r18
    6c2e:	c0 01       	movw	r24, r0
    6c30:	e3 9e       	mul	r14, r19
    6c32:	90 0d       	add	r25, r0
    6c34:	f2 9e       	mul	r15, r18
    6c36:	90 0d       	add	r25, r0
    6c38:	11 24       	eor	r1, r1
    6c3a:	04 e7       	ldi	r16, 0x74	; 116
    6c3c:	1d e7       	ldi	r17, 0x7D	; 125
    6c3e:	80 0f       	add	r24, r16
    6c40:	91 1f       	adc	r25, r17
    6c42:	be 01       	movw	r22, r28
    6c44:	6f 5f       	subi	r22, 0xFF	; 255
    6c46:	7f 4f       	sbci	r23, 0xFF	; 255
    6c48:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
	
	rad=ustep2rad(&hAxis[Axis].axisSettings, position);
    6c4c:	c7 01       	movw	r24, r14
    6c4e:	88 0f       	add	r24, r24
    6c50:	99 1f       	adc	r25, r25
    6c52:	8e 0d       	add	r24, r14
    6c54:	9f 1d       	adc	r25, r15
    6c56:	35 e0       	ldi	r19, 0x05	; 5
    6c58:	88 0f       	add	r24, r24
    6c5a:	99 1f       	adc	r25, r25
    6c5c:	3a 95       	dec	r19
    6c5e:	e1 f7       	brne	.-8      	; 0x6c58 <rangosrobot+0x50>
    6c60:	04 96       	adiw	r24, 0x04	; 4
    6c62:	08 0f       	add	r16, r24
    6c64:	19 1f       	adc	r17, r25
    6c66:	69 81       	ldd	r22, Y+1	; 0x01
    6c68:	7a 81       	ldd	r23, Y+2	; 0x02
    6c6a:	8b 81       	ldd	r24, Y+3	; 0x03
    6c6c:	9c 81       	ldd	r25, Y+4	; 0x04
    6c6e:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    6c72:	ab 01       	movw	r20, r22
    6c74:	bc 01       	movw	r22, r24
    6c76:	c8 01       	movw	r24, r16
    6c78:	0e 94 e7 12 	call	0x25ce	; 0x25ce <ustep2rad>
	grad=rad2grados(rad);
    6c7c:	0e 94 5c 13 	call	0x26b8	; 0x26b8 <rad2grados>
    6c80:	5b 01       	movw	r10, r22
    6c82:	6c 01       	movw	r12, r24
	
	printf("rangosrobot=> %s posicion = %ld \n",AxisName(Axis),position);	
    6c84:	c7 01       	movw	r24, r14
    6c86:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    6c8a:	ad b7       	in	r26, 0x3d	; 61
    6c8c:	be b7       	in	r27, 0x3e	; 62
    6c8e:	18 97       	sbiw	r26, 0x08	; 8
    6c90:	0f b6       	in	r0, 0x3f	; 63
    6c92:	f8 94       	cli
    6c94:	be bf       	out	0x3e, r27	; 62
    6c96:	0f be       	out	0x3f, r0	; 63
    6c98:	ad bf       	out	0x3d, r26	; 61
    6c9a:	ed b7       	in	r30, 0x3d	; 61
    6c9c:	fe b7       	in	r31, 0x3e	; 62
    6c9e:	31 96       	adiw	r30, 0x01	; 1
    6ca0:	27 ed       	ldi	r18, 0xD7	; 215
    6ca2:	3e e4       	ldi	r19, 0x4E	; 78
    6ca4:	12 96       	adiw	r26, 0x02	; 2
    6ca6:	3c 93       	st	X, r19
    6ca8:	2e 93       	st	-X, r18
    6caa:	11 97       	sbiw	r26, 0x01	; 1
    6cac:	93 83       	std	Z+3, r25	; 0x03
    6cae:	82 83       	std	Z+2, r24	; 0x02
    6cb0:	89 81       	ldd	r24, Y+1	; 0x01
    6cb2:	9a 81       	ldd	r25, Y+2	; 0x02
    6cb4:	ab 81       	ldd	r26, Y+3	; 0x03
    6cb6:	bc 81       	ldd	r27, Y+4	; 0x04
    6cb8:	84 83       	std	Z+4, r24	; 0x04
    6cba:	95 83       	std	Z+5, r25	; 0x05
    6cbc:	a6 83       	std	Z+6, r26	; 0x06
    6cbe:	b7 83       	std	Z+7, r27	; 0x07
    6cc0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("rangosrobot=> %s grados = %f \n \n",AxisName(Axis),grad);
    6cc4:	2d b7       	in	r18, 0x3d	; 61
    6cc6:	3e b7       	in	r19, 0x3e	; 62
    6cc8:	28 5f       	subi	r18, 0xF8	; 248
    6cca:	3f 4f       	sbci	r19, 0xFF	; 255
    6ccc:	0f b6       	in	r0, 0x3f	; 63
    6cce:	f8 94       	cli
    6cd0:	3e bf       	out	0x3e, r19	; 62
    6cd2:	0f be       	out	0x3f, r0	; 63
    6cd4:	2d bf       	out	0x3d, r18	; 61
    6cd6:	c7 01       	movw	r24, r14
    6cd8:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    6cdc:	ad b7       	in	r26, 0x3d	; 61
    6cde:	be b7       	in	r27, 0x3e	; 62
    6ce0:	18 97       	sbiw	r26, 0x08	; 8
    6ce2:	0f b6       	in	r0, 0x3f	; 63
    6ce4:	f8 94       	cli
    6ce6:	be bf       	out	0x3e, r27	; 62
    6ce8:	0f be       	out	0x3f, r0	; 63
    6cea:	ad bf       	out	0x3d, r26	; 61
    6cec:	ed b7       	in	r30, 0x3d	; 61
    6cee:	fe b7       	in	r31, 0x3e	; 62
    6cf0:	31 96       	adiw	r30, 0x01	; 1
    6cf2:	29 ef       	ldi	r18, 0xF9	; 249
    6cf4:	3e e4       	ldi	r19, 0x4E	; 78
    6cf6:	12 96       	adiw	r26, 0x02	; 2
    6cf8:	3c 93       	st	X, r19
    6cfa:	2e 93       	st	-X, r18
    6cfc:	11 97       	sbiw	r26, 0x01	; 1
    6cfe:	93 83       	std	Z+3, r25	; 0x03
    6d00:	82 83       	std	Z+2, r24	; 0x02
    6d02:	a4 82       	std	Z+4, r10	; 0x04
    6d04:	b5 82       	std	Z+5, r11	; 0x05
    6d06:	c6 82       	std	Z+6, r12	; 0x06
    6d08:	d7 82       	std	Z+7, r13	; 0x07
    6d0a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    6d0e:	2d b7       	in	r18, 0x3d	; 61
    6d10:	3e b7       	in	r19, 0x3e	; 62
    6d12:	28 5f       	subi	r18, 0xF8	; 248
    6d14:	3f 4f       	sbci	r19, 0xFF	; 255
    6d16:	0f b6       	in	r0, 0x3f	; 63
    6d18:	f8 94       	cli
    6d1a:	3e bf       	out	0x3e, r19	; 62
    6d1c:	0f be       	out	0x3f, r0	; 63
    6d1e:	2d bf       	out	0x3d, r18	; 61

	
}
    6d20:	0f 90       	pop	r0
    6d22:	0f 90       	pop	r0
    6d24:	0f 90       	pop	r0
    6d26:	0f 90       	pop	r0
    6d28:	cf 91       	pop	r28
    6d2a:	df 91       	pop	r29
    6d2c:	1f 91       	pop	r17
    6d2e:	0f 91       	pop	r16
    6d30:	ff 90       	pop	r15
    6d32:	ef 90       	pop	r14
    6d34:	df 90       	pop	r13
    6d36:	cf 90       	pop	r12
    6d38:	bf 90       	pop	r11
    6d3a:	af 90       	pop	r10
    6d3c:	08 95       	ret

00006d3e <motioncomplete>:
  return TRUE;
} // PMDcheckIdle

/**********************************************************************************************************************/
void motioncomplete(int16 axis)
{
    6d3e:	9c 01       	movw	r18, r24
	
	//Habilitar todos los ejes para el proximo movimiento limpiando  el bit
	//de Motion Complete ( Bit 0 del Event Status Register).
	
		if((hAxis[axis].axisSettings.axisEnabled == TRUE))
    6d40:	fc 01       	movw	r30, r24
    6d42:	ee 0f       	add	r30, r30
    6d44:	ff 1f       	adc	r31, r31
    6d46:	e8 0f       	add	r30, r24
    6d48:	f9 1f       	adc	r31, r25
    6d4a:	55 e0       	ldi	r21, 0x05	; 5
    6d4c:	ee 0f       	add	r30, r30
    6d4e:	ff 1f       	adc	r31, r31
    6d50:	5a 95       	dec	r21
    6d52:	e1 f7       	brne	.-8      	; 0x6d4c <motioncomplete+0xe>
    6d54:	e8 58       	subi	r30, 0x88	; 136
    6d56:	f2 48       	sbci	r31, 0x82	; 130
    6d58:	80 81       	ld	r24, Z
    6d5a:	81 30       	cpi	r24, 0x01	; 1
    6d5c:	81 f4       	brne	.+32     	; 0x6d7e <motioncomplete+0x40>
			PMDResetEventStatus(&hAxis[axis],~ PMDEventMotionCompleteMask);	
    6d5e:	80 e6       	ldi	r24, 0x60	; 96
    6d60:	90 e0       	ldi	r25, 0x00	; 0
    6d62:	ac 01       	movw	r20, r24
    6d64:	24 9f       	mul	r18, r20
    6d66:	c0 01       	movw	r24, r0
    6d68:	25 9f       	mul	r18, r21
    6d6a:	90 0d       	add	r25, r0
    6d6c:	34 9f       	mul	r19, r20
    6d6e:	90 0d       	add	r25, r0
    6d70:	11 24       	eor	r1, r1
    6d72:	8c 58       	subi	r24, 0x8C	; 140
    6d74:	92 48       	sbci	r25, 0x82	; 130
    6d76:	6e ef       	ldi	r22, 0xFE	; 254
    6d78:	7f ef       	ldi	r23, 0xFF	; 255
    6d7a:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
    6d7e:	08 95       	ret

00006d80 <abruptstop>:
		} 
	}
}
//*******************************************************************************************/
void abruptstop(void) 
{
    6d80:	0f 93       	push	r16
    6d82:	1f 93       	push	r17
    6d84:	cf 93       	push	r28
    6d86:	df 93       	push	r29
    6d88:	c4 e7       	ldi	r28, 0x74	; 116
    6d8a:	dd e7       	ldi	r29, 0x7D	; 125
    6d8c:	8e 01       	movw	r16, r28
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
	{
		PMDSetStopMode(&hAxis[axis],PMDAbruptStopMode);
    6d8e:	c8 01       	movw	r24, r16
    6d90:	61 e0       	ldi	r22, 0x01	; 1
    6d92:	70 e0       	ldi	r23, 0x00	; 0
    6d94:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
    6d98:	00 5a       	subi	r16, 0xA0	; 160
    6d9a:	1f 4f       	sbci	r17, 0xFF	; 255
//*******************************************************************************************/
void abruptstop(void) 
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
    6d9c:	8f e7       	ldi	r24, 0x7F	; 127
    6d9e:	04 35       	cpi	r16, 0x54	; 84
    6da0:	18 07       	cpc	r17, r24
    6da2:	a9 f7       	brne	.-22     	; 0x6d8e <abruptstop+0xe>
		PMDSetStopMode(&hAxis[axis],PMDAbruptStopMode);
	}
		
	for(axis=0; axis < DOF; axis++) 
	{ // for every chipset (all axis with axis number=1), call MultiUpdate once
		if(hAxis[axis].axis == 0) 
    6da4:	8a 81       	ldd	r24, Y+2	; 0x02
    6da6:	9b 81       	ldd	r25, Y+3	; 0x03
    6da8:	89 2b       	or	r24, r25
    6daa:	29 f4       	brne	.+10     	; 0x6db6 <abruptstop+0x36>
		{
			// Stop the robot (all axis in parallel)
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
    6dac:	ce 01       	movw	r24, r28
    6dae:	6f e0       	ldi	r22, 0x0F	; 15
    6db0:	70 e0       	ldi	r23, 0x00	; 0
    6db2:	0e 94 b3 63 	call	0xc766	; 0xc766 <PMDMultiUpdate>
    6db6:	c0 5a       	subi	r28, 0xA0	; 160
    6db8:	df 4f       	sbci	r29, 0xFF	; 255
	for(axis=0; axis < DOF; axis++)
	{
		PMDSetStopMode(&hAxis[axis],PMDAbruptStopMode);
	}
		
	for(axis=0; axis < DOF; axis++) 
    6dba:	c0 17       	cp	r28, r16
    6dbc:	d1 07       	cpc	r29, r17
    6dbe:	91 f7       	brne	.-28     	; 0x6da4 <abruptstop+0x24>
			// Stop the robot (all axis in parallel)
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
		} 
	}

}
    6dc0:	df 91       	pop	r29
    6dc2:	cf 91       	pop	r28
    6dc4:	1f 91       	pop	r17
    6dc6:	0f 91       	pop	r16
    6dc8:	08 95       	ret

00006dca <sofstop>:



//*******************************************************************************************/
void sofstop(void) 
{
    6dca:	0f 93       	push	r16
    6dcc:	1f 93       	push	r17
    6dce:	cf 93       	push	r28
    6dd0:	df 93       	push	r29
    6dd2:	c4 e7       	ldi	r28, 0x74	; 116
    6dd4:	dd e7       	ldi	r29, 0x7D	; 125
    6dd6:	8e 01       	movw	r16, r28
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
	{
		PMDSetStopMode(&hAxis[axis],PMDSmoothStopMode);
    6dd8:	c8 01       	movw	r24, r16
    6dda:	62 e0       	ldi	r22, 0x02	; 2
    6ddc:	70 e0       	ldi	r23, 0x00	; 0
    6dde:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
    6de2:	00 5a       	subi	r16, 0xA0	; 160
    6de4:	1f 4f       	sbci	r17, 0xFF	; 255
//*******************************************************************************************/
void sofstop(void) 
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
    6de6:	8f e7       	ldi	r24, 0x7F	; 127
    6de8:	04 35       	cpi	r16, 0x54	; 84
    6dea:	18 07       	cpc	r17, r24
    6dec:	a9 f7       	brne	.-22     	; 0x6dd8 <sofstop+0xe>
		PMDSetStopMode(&hAxis[axis],PMDSmoothStopMode);
	}
		
	for(axis=0; axis < DOF; axis++) 
	{ // for every chipset (all axis with axis number=1), call MultiUpdate once
		if(hAxis[axis].axis == 0) 
    6dee:	8a 81       	ldd	r24, Y+2	; 0x02
    6df0:	9b 81       	ldd	r25, Y+3	; 0x03
    6df2:	89 2b       	or	r24, r25
    6df4:	29 f4       	brne	.+10     	; 0x6e00 <sofstop+0x36>
		{
			// Stop the robot (all axis in parallel)
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
    6df6:	ce 01       	movw	r24, r28
    6df8:	6f e0       	ldi	r22, 0x0F	; 15
    6dfa:	70 e0       	ldi	r23, 0x00	; 0
    6dfc:	0e 94 b3 63 	call	0xc766	; 0xc766 <PMDMultiUpdate>
    6e00:	c0 5a       	subi	r28, 0xA0	; 160
    6e02:	df 4f       	sbci	r29, 0xFF	; 255
	for(axis=0; axis < DOF; axis++)
	{
		PMDSetStopMode(&hAxis[axis],PMDSmoothStopMode);
	}
		
	for(axis=0; axis < DOF; axis++) 
    6e04:	c0 17       	cp	r28, r16
    6e06:	d1 07       	cpc	r29, r17
    6e08:	91 f7       	brne	.-28     	; 0x6dee <sofstop+0x24>
		{
			// Stop the robot (all axis in parallel)
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
		} 
	}
}
    6e0a:	df 91       	pop	r29
    6e0c:	cf 91       	pop	r28
    6e0e:	1f 91       	pop	r17
    6e10:	0f 91       	pop	r16
    6e12:	08 95       	ret

00006e14 <Enable_Mov>:
		
}

/**********************************************************************************************************************/
void Enable_Mov(void)
{
    6e14:	cf 92       	push	r12
    6e16:	df 92       	push	r13
    6e18:	ef 92       	push	r14
    6e1a:	ff 92       	push	r15
    6e1c:	0f 93       	push	r16
    6e1e:	1f 93       	push	r17
    6e20:	df 93       	push	r29
    6e22:	cf 93       	push	r28
    6e24:	00 d0       	rcall	.+0      	; 0x6e26 <Enable_Mov+0x12>
    6e26:	cd b7       	in	r28, 0x3d	; 61
    6e28:	de b7       	in	r29, 0x3e	; 62
    6e2a:	74 e7       	ldi	r23, 0x74	; 116
    6e2c:	e7 2e       	mov	r14, r23
    6e2e:	7d e7       	ldi	r23, 0x7D	; 125
    6e30:	f7 2e       	mov	r15, r23
    6e32:	00 e0       	ldi	r16, 0x00	; 0
    6e34:	10 e0       	ldi	r17, 0x00	; 0

	for(axis=0; axis < DOF; axis++) 
	{
		if(hAxis[axis].axisSettings.axisEnabled == TRUE)
		{		
			PMDGetEventStatus(&hAxis[axis],&status);
    6e36:	6e 01       	movw	r12, r28
    6e38:	08 94       	sec
    6e3a:	c1 1c       	adc	r12, r1
    6e3c:	d1 1c       	adc	r13, r1
	int16 axis;
	PMDuint16 status;

	for(axis=0; axis < DOF; axis++) 
	{
		if(hAxis[axis].axisSettings.axisEnabled == TRUE)
    6e3e:	f7 01       	movw	r30, r14
    6e40:	84 81       	ldd	r24, Z+4	; 0x04
    6e42:	81 30       	cpi	r24, 0x01	; 1
    6e44:	51 f4       	brne	.+20     	; 0x6e5a <Enable_Mov+0x46>
		{		
			PMDGetEventStatus(&hAxis[axis],&status);
    6e46:	c7 01       	movw	r24, r14
    6e48:	b6 01       	movw	r22, r12
    6e4a:	0e 94 a7 61 	call	0xc34e	; 0xc34e <PMDGetEventStatus>
			if ((status & PMDEventMotionCompleteMask) > 0) //Eje detenido, movimiento completado 
    6e4e:	89 81       	ldd	r24, Y+1	; 0x01
    6e50:	80 ff       	sbrs	r24, 0
    6e52:	03 c0       	rjmp	.+6      	; 0x6e5a <Enable_Mov+0x46>
			{
				motioncomplete(axis);
    6e54:	c8 01       	movw	r24, r16
    6e56:	0e 94 9f 36 	call	0x6d3e	; 0x6d3e <motioncomplete>
void Enable_Mov(void)
{
	int16 axis;
	PMDuint16 status;

	for(axis=0; axis < DOF; axis++) 
    6e5a:	0f 5f       	subi	r16, 0xFF	; 255
    6e5c:	1f 4f       	sbci	r17, 0xFF	; 255
    6e5e:	80 e6       	ldi	r24, 0x60	; 96
    6e60:	90 e0       	ldi	r25, 0x00	; 0
    6e62:	e8 0e       	add	r14, r24
    6e64:	f9 1e       	adc	r15, r25
    6e66:	05 30       	cpi	r16, 0x05	; 5
    6e68:	11 05       	cpc	r17, r1
    6e6a:	49 f7       	brne	.-46     	; 0x6e3e <Enable_Mov+0x2a>
				
			}
		}
	}
	
}
    6e6c:	0f 90       	pop	r0
    6e6e:	0f 90       	pop	r0
    6e70:	cf 91       	pop	r28
    6e72:	df 91       	pop	r29
    6e74:	1f 91       	pop	r17
    6e76:	0f 91       	pop	r16
    6e78:	ff 90       	pop	r15
    6e7a:	ef 90       	pop	r14
    6e7c:	df 90       	pop	r13
    6e7e:	cf 90       	pop	r12
    6e80:	08 95       	ret

00006e82 <PMDcheckIdle>:
}

/*********************************************************************************************/

PMDresult PMDcheckIdle(int16 mask)
{
    6e82:	af 92       	push	r10
    6e84:	bf 92       	push	r11
    6e86:	cf 92       	push	r12
    6e88:	df 92       	push	r13
    6e8a:	ef 92       	push	r14
    6e8c:	ff 92       	push	r15
    6e8e:	0f 93       	push	r16
    6e90:	1f 93       	push	r17
    6e92:	df 93       	push	r29
    6e94:	cf 93       	push	r28
    6e96:	00 d0       	rcall	.+0      	; 0x6e98 <PMDcheckIdle+0x16>
    6e98:	cd b7       	in	r28, 0x3d	; 61
    6e9a:	de b7       	in	r29, 0x3e	; 62
    6e9c:	6c 01       	movw	r12, r24
    6e9e:	e4 e7       	ldi	r30, 0x74	; 116
    6ea0:	ee 2e       	mov	r14, r30
    6ea2:	ed e7       	ldi	r30, 0x7D	; 125
    6ea4:	fe 2e       	mov	r15, r30
    6ea6:	00 e0       	ldi	r16, 0x00	; 0
    6ea8:	10 e0       	ldi	r17, 0x00	; 0
	for(axis=0; axis < DOF; axis++) 
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE)&&
		  ((mask & (Axis2AxisMask(axis))) >0)) 
		{		
			PMDGetEventStatus(&hAxis[axis],&status);
    6eaa:	5e 01       	movw	r10, r28
    6eac:	08 94       	sec
    6eae:	a1 1c       	adc	r10, r1
    6eb0:	b1 1c       	adc	r11, r1
	int16 axis;
	
  
	for(axis=0; axis < DOF; axis++) 
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE)&&
    6eb2:	f7 01       	movw	r30, r14
    6eb4:	84 81       	ldd	r24, Z+4	; 0x04
    6eb6:	81 30       	cpi	r24, 0x01	; 1
    6eb8:	91 f4       	brne	.+36     	; 0x6ede <PMDcheckIdle+0x5c>
    6eba:	c8 01       	movw	r24, r16
    6ebc:	0e 94 60 18 	call	0x30c0	; 0x30c0 <Axis2AxisMask>
    6ec0:	8c 21       	and	r24, r12
    6ec2:	9d 21       	and	r25, r13
    6ec4:	18 16       	cp	r1, r24
    6ec6:	19 06       	cpc	r1, r25
    6ec8:	54 f4       	brge	.+20     	; 0x6ede <PMDcheckIdle+0x5c>
		  ((mask & (Axis2AxisMask(axis))) >0)) 
		{		
			PMDGetEventStatus(&hAxis[axis],&status);
    6eca:	c7 01       	movw	r24, r14
    6ecc:	b5 01       	movw	r22, r10
    6ece:	0e 94 a7 61 	call	0xc34e	; 0xc34e <PMDGetEventStatus>
			
			
			if ((status & PMDEventMotionCompleteMask) == 0)
    6ed2:	89 81       	ldd	r24, Y+1	; 0x01
    6ed4:	80 fd       	sbrc	r24, 0
    6ed6:	03 c0       	rjmp	.+6      	; 0x6ede <PMDcheckIdle+0x5c>
    6ed8:	20 e0       	ldi	r18, 0x00	; 0
    6eda:	30 e0       	ldi	r19, 0x00	; 0
    6edc:	0b c0       	rjmp	.+22     	; 0x6ef4 <PMDcheckIdle+0x72>
		
	PMDuint16 status;
	int16 axis;
	
  
	for(axis=0; axis < DOF; axis++) 
    6ede:	0f 5f       	subi	r16, 0xFF	; 255
    6ee0:	1f 4f       	sbci	r17, 0xFF	; 255
    6ee2:	80 e6       	ldi	r24, 0x60	; 96
    6ee4:	90 e0       	ldi	r25, 0x00	; 0
    6ee6:	e8 0e       	add	r14, r24
    6ee8:	f9 1e       	adc	r15, r25
    6eea:	05 30       	cpi	r16, 0x05	; 5
    6eec:	11 05       	cpc	r17, r1
    6eee:	09 f7       	brne	.-62     	; 0x6eb2 <PMDcheckIdle+0x30>
    6ef0:	21 e0       	ldi	r18, 0x01	; 1
    6ef2:	30 e0       	ldi	r19, 0x00	; 0
				return FALSE;			
			}
		}
	}
  return TRUE;
} // PMDcheckIdle
    6ef4:	c9 01       	movw	r24, r18
    6ef6:	0f 90       	pop	r0
    6ef8:	0f 90       	pop	r0
    6efa:	cf 91       	pop	r28
    6efc:	df 91       	pop	r29
    6efe:	1f 91       	pop	r17
    6f00:	0f 91       	pop	r16
    6f02:	ff 90       	pop	r15
    6f04:	ef 90       	pop	r14
    6f06:	df 90       	pop	r13
    6f08:	cf 90       	pop	r12
    6f0a:	bf 90       	pop	r11
    6f0c:	af 90       	pop	r10
    6f0e:	08 95       	ret

00006f10 <Status_Axis>:
	}

} 
/**********************************************************************************************************************/
PMDresult Status_Axis(tAxis Axis) 
{
    6f10:	0f 93       	push	r16
    6f12:	1f 93       	push	r17
    6f14:	df 93       	push	r29
    6f16:	cf 93       	push	r28
    6f18:	00 d0       	rcall	.+0      	; 0x6f1a <Status_Axis+0xa>
    6f1a:	cd b7       	in	r28, 0x3d	; 61
    6f1c:	de b7       	in	r29, 0x3e	; 62
    6f1e:	8c 01       	movw	r16, r24

	uint16 status;
	
	
	PMDGetActivityStatus(&hAxis[Axis],&status);
    6f20:	80 e6       	ldi	r24, 0x60	; 96
    6f22:	90 e0       	ldi	r25, 0x00	; 0
    6f24:	9c 01       	movw	r18, r24
    6f26:	02 9f       	mul	r16, r18
    6f28:	c0 01       	movw	r24, r0
    6f2a:	03 9f       	mul	r16, r19
    6f2c:	90 0d       	add	r25, r0
    6f2e:	12 9f       	mul	r17, r18
    6f30:	90 0d       	add	r25, r0
    6f32:	11 24       	eor	r1, r1
    6f34:	8c 58       	subi	r24, 0x8C	; 140
    6f36:	92 48       	sbci	r25, 0x82	; 130
    6f38:	be 01       	movw	r22, r28
    6f3a:	6f 5f       	subi	r22, 0xFF	; 255
    6f3c:	7f 4f       	sbci	r23, 0xFF	; 255
    6f3e:	0e 94 a1 61 	call	0xc342	; 0xc342 <PMDGetActivityStatus>
	
	if ((status & PMDActivityInMotionMask) !=0)  
    6f42:	89 81       	ldd	r24, Y+1	; 0x01
    6f44:	9a 81       	ldd	r25, Y+2	; 0x02
    6f46:	92 ff       	sbrs	r25, 2
    6f48:	03 c0       	rjmp	.+6      	; 0x6f50 <Status_Axis+0x40>
    6f4a:	22 e1       	ldi	r18, 0x12	; 18
    6f4c:	30 e0       	ldi	r19, 0x00	; 0
    6f4e:	0c c0       	rjmp	.+24     	; 0x6f68 <Status_Axis+0x58>
	{
		return rcPMDProfileactivo;
	}
	else
	{	
		if(!PMDcheckIdle(Axis2AxisMask(Axis)))
    6f50:	c8 01       	movw	r24, r16
    6f52:	0e 94 60 18 	call	0x30c0	; 0x30c0 <Axis2AxisMask>
    6f56:	0e 94 41 37 	call	0x6e82	; 0x6e82 <PMDcheckIdle>
    6f5a:	89 2b       	or	r24, r25
    6f5c:	19 f0       	breq	.+6      	; 0x6f64 <Status_Axis+0x54>
    6f5e:	20 e1       	ldi	r18, 0x10	; 16
    6f60:	30 e0       	ldi	r19, 0x00	; 0
    6f62:	02 c0       	rjmp	.+4      	; 0x6f68 <Status_Axis+0x58>
    6f64:	21 e1       	ldi	r18, 0x11	; 17
    6f66:	30 e0       	ldi	r19, 0x00	; 0
			return rcPMDAxisPresicionError;
		}
		/*Movimiento completado con presicion ya sea con o sin encoderes*/
		return rcPMDAxisPresicionMotionComplete;
	}
}
    6f68:	c9 01       	movw	r24, r18
    6f6a:	0f 90       	pop	r0
    6f6c:	0f 90       	pop	r0
    6f6e:	cf 91       	pop	r28
    6f70:	df 91       	pop	r29
    6f72:	1f 91       	pop	r17
    6f74:	0f 91       	pop	r16
    6f76:	08 95       	ret

00006f78 <inipitch_roll>:
		#endif
	}
}

void inipitch_roll(void)
{
    6f78:	0f 93       	push	r16
    6f7a:	1f 93       	push	r17
    6f7c:	df 93       	push	r29
    6f7e:	cf 93       	push	r28
    6f80:	00 d0       	rcall	.+0      	; 0x6f82 <inipitch_roll+0xa>
    6f82:	00 d0       	rcall	.+0      	; 0x6f84 <inipitch_roll+0xc>
    6f84:	cd b7       	in	r28, 0x3d	; 61
    6f86:	de b7       	in	r29, 0x3e	; 62
	PMDint32 position=0;
    6f88:	19 82       	std	Y+1, r1	; 0x01
    6f8a:	1a 82       	std	Y+2, r1	; 0x02
    6f8c:	1b 82       	std	Y+3, r1	; 0x03
    6f8e:	1c 82       	std	Y+4, r1	; 0x04
	
	eeprom_write_block((const void*)&position,(void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    6f90:	8e 01       	movw	r16, r28
    6f92:	0f 5f       	subi	r16, 0xFF	; 255
    6f94:	1f 4f       	sbci	r17, 0xFF	; 255
    6f96:	c8 01       	movw	r24, r16
    6f98:	6a e5       	ldi	r22, 0x5A	; 90
    6f9a:	71 e0       	ldi	r23, 0x01	; 1
    6f9c:	44 e0       	ldi	r20, 0x04	; 4
    6f9e:	50 e0       	ldi	r21, 0x00	; 0
    6fa0:	0e 94 e3 89 	call	0x113c6	; 0x113c6 <__eewr_block_m1280>
	eeprom_write_block((const void*)&position,(void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    6fa4:	c8 01       	movw	r24, r16
    6fa6:	66 e5       	ldi	r22, 0x56	; 86
    6fa8:	71 e0       	ldi	r23, 0x01	; 1
    6faa:	44 e0       	ldi	r20, 0x04	; 4
    6fac:	50 e0       	ldi	r21, 0x00	; 0
    6fae:	0e 94 e3 89 	call	0x113c6	; 0x113c6 <__eewr_block_m1280>
}
    6fb2:	0f 90       	pop	r0
    6fb4:	0f 90       	pop	r0
    6fb6:	0f 90       	pop	r0
    6fb8:	0f 90       	pop	r0
    6fba:	cf 91       	pop	r28
    6fbc:	df 91       	pop	r29
    6fbe:	1f 91       	pop	r17
    6fc0:	0f 91       	pop	r16
    6fc2:	08 95       	ret

00006fc4 <mov_axis>:
 

//*********************************************************************************************/
void mov_axis(tAxis Axis,PMDint32 position, PMDint32 velocity, 
					PMDuint32 acceleration, PMDint16 actualizar)
{ 
    6fc4:	6f 92       	push	r6
    6fc6:	7f 92       	push	r7
    6fc8:	8f 92       	push	r8
    6fca:	9f 92       	push	r9
    6fcc:	af 92       	push	r10
    6fce:	bf 92       	push	r11
    6fd0:	cf 92       	push	r12
    6fd2:	df 92       	push	r13
    6fd4:	ef 92       	push	r14
    6fd6:	ff 92       	push	r15
    6fd8:	0f 93       	push	r16
    6fda:	1f 93       	push	r17
    6fdc:	cf 93       	push	r28
    6fde:	df 93       	push	r29
    6fe0:	ec 01       	movw	r28, r24
    6fe2:	38 01       	movw	r6, r16
    6fe4:	49 01       	movw	r8, r18
	#ifdef DEBUGROBOTICS
	PMDint32 posicion_origen;
	#endif
	
	if(position!=none)
    6fe6:	41 3f       	cpi	r20, 0xF1	; 241
    6fe8:	2f ef       	ldi	r18, 0xFF	; 255
    6fea:	52 07       	cpc	r21, r18
    6fec:	2f ef       	ldi	r18, 0xFF	; 255
    6fee:	62 07       	cpc	r22, r18
    6ff0:	2f ef       	ldi	r18, 0xFF	; 255
    6ff2:	72 07       	cpc	r23, r18
    6ff4:	71 f0       	breq	.+28     	; 0x7012 <mov_axis+0x4e>
		#ifdef DEBUGROBOTICS
		PMDGetCommandedPosition(&hAxis[Axis],&posicion_origen);
		printf("mov_axis=> registro de posicion inicial en el motor %s =  %ld\n ",AxisName(Axis), posicion_origen);
		printf("mov_axis=> registro de posicion final en el motor %s =  %ld\n ",AxisName(Axis), position);
		#endif
		PMDSetPosition(&hAxis[Axis],position);
    6ff6:	80 e6       	ldi	r24, 0x60	; 96
    6ff8:	90 e0       	ldi	r25, 0x00	; 0
    6ffa:	9c 01       	movw	r18, r24
    6ffc:	c2 9f       	mul	r28, r18
    6ffe:	c0 01       	movw	r24, r0
    7000:	c3 9f       	mul	r28, r19
    7002:	90 0d       	add	r25, r0
    7004:	d2 9f       	mul	r29, r18
    7006:	90 0d       	add	r25, r0
    7008:	11 24       	eor	r1, r1
    700a:	8c 58       	subi	r24, 0x8C	; 140
    700c:	92 48       	sbci	r25, 0x82	; 130
    700e:	0e 94 f3 67 	call	0xcfe6	; 0xcfe6 <PMDSetPosition>
	}
	if(velocity!=none)
    7012:	31 ef       	ldi	r19, 0xF1	; 241
    7014:	63 16       	cp	r6, r19
    7016:	3f ef       	ldi	r19, 0xFF	; 255
    7018:	73 06       	cpc	r7, r19
    701a:	3f ef       	ldi	r19, 0xFF	; 255
    701c:	83 06       	cpc	r8, r19
    701e:	3f ef       	ldi	r19, 0xFF	; 255
    7020:	93 06       	cpc	r9, r19
    7022:	81 f0       	breq	.+32     	; 0x7044 <mov_axis+0x80>
	{
		#ifdef DEBUGROBOTICS
		printf("mov_axis=> registro de velocidad en el motor %s =  %ld\n ",AxisName(Axis), velocity);
		#endif
		PMDSetVelocity(&hAxis[Axis],velocity); //limite permitido 1310720 unidades en up/Sampletime	
    7024:	80 e6       	ldi	r24, 0x60	; 96
    7026:	90 e0       	ldi	r25, 0x00	; 0
    7028:	9c 01       	movw	r18, r24
    702a:	c2 9f       	mul	r28, r18
    702c:	c0 01       	movw	r24, r0
    702e:	c3 9f       	mul	r28, r19
    7030:	90 0d       	add	r25, r0
    7032:	d2 9f       	mul	r29, r18
    7034:	90 0d       	add	r25, r0
    7036:	11 24       	eor	r1, r1
    7038:	8c 58       	subi	r24, 0x8C	; 140
    703a:	92 48       	sbci	r25, 0x82	; 130
    703c:	b4 01       	movw	r22, r8
    703e:	a3 01       	movw	r20, r6
    7040:	0e 94 ec 67 	call	0xcfd8	; 0xcfd8 <PMDSetVelocity>
	}
	if(acceleration!=none)
    7044:	31 ef       	ldi	r19, 0xF1	; 241
    7046:	c3 16       	cp	r12, r19
    7048:	3f ef       	ldi	r19, 0xFF	; 255
    704a:	d3 06       	cpc	r13, r19
    704c:	3f ef       	ldi	r19, 0xFF	; 255
    704e:	e3 06       	cpc	r14, r19
    7050:	3f ef       	ldi	r19, 0xFF	; 255
    7052:	f3 06       	cpc	r15, r19
    7054:	81 f0       	breq	.+32     	; 0x7076 <mov_axis+0xb2>
	{
		#ifdef DEBUGROBOTICS
		printf("mov_axis=> registro de aceleracion en el motor %s =  %ld\n ",AxisName(Axis), acceleration);
		#endif
		PMDSetAcceleration(&hAxis[Axis],acceleration); //limite permitido 786 uP/Sample	
    7056:	80 e6       	ldi	r24, 0x60	; 96
    7058:	90 e0       	ldi	r25, 0x00	; 0
    705a:	9c 01       	movw	r18, r24
    705c:	c2 9f       	mul	r28, r18
    705e:	c0 01       	movw	r24, r0
    7060:	c3 9f       	mul	r28, r19
    7062:	90 0d       	add	r25, r0
    7064:	d2 9f       	mul	r29, r18
    7066:	90 0d       	add	r25, r0
    7068:	11 24       	eor	r1, r1
    706a:	8c 58       	subi	r24, 0x8C	; 140
    706c:	92 48       	sbci	r25, 0x82	; 130
    706e:	b7 01       	movw	r22, r14
    7070:	a6 01       	movw	r20, r12
    7072:	0e 94 de 67 	call	0xcfbc	; 0xcfbc <PMDSetAcceleration>
	}
	if(actualizar==update)
    7076:	30 ef       	ldi	r19, 0xF0	; 240
    7078:	a3 16       	cp	r10, r19
    707a:	3f ef       	ldi	r19, 0xFF	; 255
    707c:	b3 06       	cpc	r11, r19
    707e:	71 f4       	brne	.+28     	; 0x709c <mov_axis+0xd8>
	{
		PMDUpdate(&hAxis[Axis]);
    7080:	80 e6       	ldi	r24, 0x60	; 96
    7082:	90 e0       	ldi	r25, 0x00	; 0
    7084:	9c 01       	movw	r18, r24
    7086:	c2 9f       	mul	r28, r18
    7088:	c0 01       	movw	r24, r0
    708a:	c3 9f       	mul	r28, r19
    708c:	90 0d       	add	r25, r0
    708e:	d2 9f       	mul	r29, r18
    7090:	90 0d       	add	r25, r0
    7092:	11 24       	eor	r1, r1
    7094:	8c 58       	subi	r24, 0x8C	; 140
    7096:	92 48       	sbci	r25, 0x82	; 130
    7098:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
	{
		#ifdef DEBUGROBOTICS
		printf("mov_axis=> No Actualizando..\n ");
		#endif
	}
}
    709c:	df 91       	pop	r29
    709e:	cf 91       	pop	r28
    70a0:	1f 91       	pop	r17
    70a2:	0f 91       	pop	r16
    70a4:	ff 90       	pop	r15
    70a6:	ef 90       	pop	r14
    70a8:	df 90       	pop	r13
    70aa:	cf 90       	pop	r12
    70ac:	bf 90       	pop	r11
    70ae:	af 90       	pop	r10
    70b0:	9f 90       	pop	r9
    70b2:	8f 90       	pop	r8
    70b4:	7f 90       	pop	r7
    70b6:	6f 90       	pop	r6
    70b8:	08 95       	ret

000070ba <StepCalibration>:

	
}
/**********************************************************************************************************************/
void StepCalibration(tAxis Axis)
{
    70ba:	6f 92       	push	r6
    70bc:	7f 92       	push	r7
    70be:	8f 92       	push	r8
    70c0:	9f 92       	push	r9
    70c2:	af 92       	push	r10
    70c4:	bf 92       	push	r11
    70c6:	cf 92       	push	r12
    70c8:	df 92       	push	r13
    70ca:	ef 92       	push	r14
    70cc:	ff 92       	push	r15
    70ce:	0f 93       	push	r16
    70d0:	1f 93       	push	r17
    70d2:	df 93       	push	r29
    70d4:	cf 93       	push	r28
    70d6:	cd b7       	in	r28, 0x3d	; 61
    70d8:	de b7       	in	r29, 0x3e	; 62
    70da:	28 97       	sbiw	r28, 0x08	; 8
    70dc:	0f b6       	in	r0, 0x3f	; 63
    70de:	f8 94       	cli
    70e0:	de bf       	out	0x3e, r29	; 62
    70e2:	0f be       	out	0x3f, r0	; 63
    70e4:	cd bf       	out	0x3d, r28	; 61
    70e6:	7c 01       	movw	r14, r24


	PMDint32 position,encoder;
  
	PMDGetCommandedPosition(&hAxis[Axis],&position);
    70e8:	80 e6       	ldi	r24, 0x60	; 96
    70ea:	90 e0       	ldi	r25, 0x00	; 0
    70ec:	e8 9e       	mul	r14, r24
    70ee:	30 01       	movw	r6, r0
    70f0:	e9 9e       	mul	r14, r25
    70f2:	70 0c       	add	r7, r0
    70f4:	f8 9e       	mul	r15, r24
    70f6:	70 0c       	add	r7, r0
    70f8:	11 24       	eor	r1, r1
    70fa:	84 e7       	ldi	r24, 0x74	; 116
    70fc:	9d e7       	ldi	r25, 0x7D	; 125
    70fe:	68 0e       	add	r6, r24
    7100:	79 1e       	adc	r7, r25
    7102:	c3 01       	movw	r24, r6
    7104:	8e 01       	movw	r16, r28
    7106:	0f 5f       	subi	r16, 0xFF	; 255
    7108:	1f 4f       	sbci	r17, 0xFF	; 255
    710a:	b8 01       	movw	r22, r16
    710c:	0e 94 8c 64 	call	0xc918	; 0xc918 <PMDGetCommandedPosition>
	printf("StepCalibration=> Posicion Instantanea antes del ajuste %ld\n",position);
    7110:	00 d0       	rcall	.+0      	; 0x7112 <StepCalibration+0x58>
    7112:	00 d0       	rcall	.+0      	; 0x7114 <StepCalibration+0x5a>
    7114:	00 d0       	rcall	.+0      	; 0x7116 <StepCalibration+0x5c>
    7116:	8a e1       	ldi	r24, 0x1A	; 26
    7118:	9f e4       	ldi	r25, 0x4F	; 79
    711a:	ed b7       	in	r30, 0x3d	; 61
    711c:	fe b7       	in	r31, 0x3e	; 62
    711e:	92 83       	std	Z+2, r25	; 0x02
    7120:	81 83       	std	Z+1, r24	; 0x01
    7122:	89 81       	ldd	r24, Y+1	; 0x01
    7124:	9a 81       	ldd	r25, Y+2	; 0x02
    7126:	ab 81       	ldd	r26, Y+3	; 0x03
    7128:	bc 81       	ldd	r27, Y+4	; 0x04
    712a:	83 83       	std	Z+3, r24	; 0x03
    712c:	94 83       	std	Z+4, r25	; 0x04
    712e:	a5 83       	std	Z+5, r26	; 0x05
    7130:	b6 83       	std	Z+6, r27	; 0x06
    7132:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	PMDGetActualPosition(&hAxis[Axis],&encoder);
    7136:	8d b7       	in	r24, 0x3d	; 61
    7138:	9e b7       	in	r25, 0x3e	; 62
    713a:	06 96       	adiw	r24, 0x06	; 6
    713c:	0f b6       	in	r0, 0x3f	; 63
    713e:	f8 94       	cli
    7140:	9e bf       	out	0x3e, r25	; 62
    7142:	0f be       	out	0x3f, r0	; 63
    7144:	8d bf       	out	0x3d, r24	; 61
    7146:	b5 e0       	ldi	r27, 0x05	; 5
    7148:	8b 2e       	mov	r8, r27
    714a:	91 2c       	mov	r9, r1
    714c:	8c 0e       	add	r8, r28
    714e:	9d 1e       	adc	r9, r29
    7150:	c3 01       	movw	r24, r6
    7152:	b4 01       	movw	r22, r8
    7154:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
	printf("StepCalibration=> Lectura del encoder %ld\n",encoder);
    7158:	00 d0       	rcall	.+0      	; 0x715a <StepCalibration+0xa0>
    715a:	00 d0       	rcall	.+0      	; 0x715c <StepCalibration+0xa2>
    715c:	00 d0       	rcall	.+0      	; 0x715e <StepCalibration+0xa4>
    715e:	87 e5       	ldi	r24, 0x57	; 87
    7160:	9f e4       	ldi	r25, 0x4F	; 79
    7162:	ed b7       	in	r30, 0x3d	; 61
    7164:	fe b7       	in	r31, 0x3e	; 62
    7166:	92 83       	std	Z+2, r25	; 0x02
    7168:	81 83       	std	Z+1, r24	; 0x01
    716a:	8d 81       	ldd	r24, Y+5	; 0x05
    716c:	9e 81       	ldd	r25, Y+6	; 0x06
    716e:	af 81       	ldd	r26, Y+7	; 0x07
    7170:	b8 85       	ldd	r27, Y+8	; 0x08
    7172:	83 83       	std	Z+3, r24	; 0x03
    7174:	94 83       	std	Z+4, r25	; 0x04
    7176:	a5 83       	std	Z+5, r26	; 0x05
    7178:	b6 83       	std	Z+6, r27	; 0x06
    717a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	
	printf("StepCalibration=> Ajustando...\n");	
    717e:	8d b7       	in	r24, 0x3d	; 61
    7180:	9e b7       	in	r25, 0x3e	; 62
    7182:	06 96       	adiw	r24, 0x06	; 6
    7184:	0f b6       	in	r0, 0x3f	; 63
    7186:	f8 94       	cli
    7188:	9e bf       	out	0x3e, r25	; 62
    718a:	0f be       	out	0x3f, r0	; 63
    718c:	8d bf       	out	0x3d, r24	; 61
    718e:	82 e8       	ldi	r24, 0x82	; 130
    7190:	9f e4       	ldi	r25, 0x4F	; 79
    7192:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>

	PMDAdjustActualPosition(&hAxis[Axis],-encoder); 
    7196:	4d 81       	ldd	r20, Y+5	; 0x05
    7198:	5e 81       	ldd	r21, Y+6	; 0x06
    719a:	6f 81       	ldd	r22, Y+7	; 0x07
    719c:	78 85       	ldd	r23, Y+8	; 0x08
    719e:	70 95       	com	r23
    71a0:	60 95       	com	r22
    71a2:	50 95       	com	r21
    71a4:	41 95       	neg	r20
    71a6:	5f 4f       	sbci	r21, 0xFF	; 255
    71a8:	6f 4f       	sbci	r22, 0xFF	; 255
    71aa:	7f 4f       	sbci	r23, 0xFF	; 255
    71ac:	c3 01       	movw	r24, r6
    71ae:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>
	PMDGetCommandedPosition(&hAxis[Axis],&position);
    71b2:	c3 01       	movw	r24, r6
    71b4:	b8 01       	movw	r22, r16
    71b6:	0e 94 8c 64 	call	0xc918	; 0xc918 <PMDGetCommandedPosition>
	printf("StepCalibration=> Posicion Instantanea despues del ajuste %ld\n",position);
    71ba:	00 d0       	rcall	.+0      	; 0x71bc <StepCalibration+0x102>
    71bc:	00 d0       	rcall	.+0      	; 0x71be <StepCalibration+0x104>
    71be:	00 d0       	rcall	.+0      	; 0x71c0 <StepCalibration+0x106>
    71c0:	81 ea       	ldi	r24, 0xA1	; 161
    71c2:	9f e4       	ldi	r25, 0x4F	; 79
    71c4:	ed b7       	in	r30, 0x3d	; 61
    71c6:	fe b7       	in	r31, 0x3e	; 62
    71c8:	92 83       	std	Z+2, r25	; 0x02
    71ca:	81 83       	std	Z+1, r24	; 0x01
    71cc:	89 81       	ldd	r24, Y+1	; 0x01
    71ce:	9a 81       	ldd	r25, Y+2	; 0x02
    71d0:	ab 81       	ldd	r26, Y+3	; 0x03
    71d2:	bc 81       	ldd	r27, Y+4	; 0x04
    71d4:	83 83       	std	Z+3, r24	; 0x03
    71d6:	94 83       	std	Z+4, r25	; 0x04
    71d8:	a5 83       	std	Z+5, r26	; 0x05
    71da:	b6 83       	std	Z+6, r27	; 0x06
    71dc:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	PMDGetActualPosition(&hAxis[Axis],&encoder);
    71e0:	8d b7       	in	r24, 0x3d	; 61
    71e2:	9e b7       	in	r25, 0x3e	; 62
    71e4:	06 96       	adiw	r24, 0x06	; 6
    71e6:	0f b6       	in	r0, 0x3f	; 63
    71e8:	f8 94       	cli
    71ea:	9e bf       	out	0x3e, r25	; 62
    71ec:	0f be       	out	0x3f, r0	; 63
    71ee:	8d bf       	out	0x3d, r24	; 61
    71f0:	c3 01       	movw	r24, r6
    71f2:	b4 01       	movw	r22, r8
    71f4:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
	printf("StepCalibration=> Lectura encoder Despues de ajustar %ld\n",encoder);	
    71f8:	00 d0       	rcall	.+0      	; 0x71fa <StepCalibration+0x140>
    71fa:	00 d0       	rcall	.+0      	; 0x71fc <StepCalibration+0x142>
    71fc:	00 d0       	rcall	.+0      	; 0x71fe <StepCalibration+0x144>
    71fe:	80 ee       	ldi	r24, 0xE0	; 224
    7200:	9f e4       	ldi	r25, 0x4F	; 79
    7202:	ed b7       	in	r30, 0x3d	; 61
    7204:	fe b7       	in	r31, 0x3e	; 62
    7206:	92 83       	std	Z+2, r25	; 0x02
    7208:	81 83       	std	Z+1, r24	; 0x01
    720a:	8d 81       	ldd	r24, Y+5	; 0x05
    720c:	9e 81       	ldd	r25, Y+6	; 0x06
    720e:	af 81       	ldd	r26, Y+7	; 0x07
    7210:	b8 85       	ldd	r27, Y+8	; 0x08
    7212:	83 83       	std	Z+3, r24	; 0x03
    7214:	94 83       	std	Z+4, r25	; 0x04
    7216:	a5 83       	std	Z+5, r26	; 0x05
    7218:	b6 83       	std	Z+6, r27	; 0x06
    721a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	mov_axis(Axis,INF,300000,100,update);
    721e:	8d b7       	in	r24, 0x3d	; 61
    7220:	9e b7       	in	r25, 0x3e	; 62
    7222:	06 96       	adiw	r24, 0x06	; 6
    7224:	0f b6       	in	r0, 0x3f	; 63
    7226:	f8 94       	cli
    7228:	9e bf       	out	0x3e, r25	; 62
    722a:	0f be       	out	0x3f, r0	; 63
    722c:	8d bf       	out	0x3d, r24	; 61
    722e:	c7 01       	movw	r24, r14
    7230:	4f ef       	ldi	r20, 0xFF	; 255
    7232:	5f ef       	ldi	r21, 0xFF	; 255
    7234:	6f ef       	ldi	r22, 0xFF	; 255
    7236:	7f e7       	ldi	r23, 0x7F	; 127
    7238:	00 ee       	ldi	r16, 0xE0	; 224
    723a:	13 e9       	ldi	r17, 0x93	; 147
    723c:	24 e0       	ldi	r18, 0x04	; 4
    723e:	30 e0       	ldi	r19, 0x00	; 0
    7240:	a4 e6       	ldi	r26, 0x64	; 100
    7242:	ca 2e       	mov	r12, r26
    7244:	d1 2c       	mov	r13, r1
    7246:	e1 2c       	mov	r14, r1
    7248:	f1 2c       	mov	r15, r1
    724a:	f0 ef       	ldi	r31, 0xF0	; 240
    724c:	af 2e       	mov	r10, r31
    724e:	ff ef       	ldi	r31, 0xFF	; 255
    7250:	bf 2e       	mov	r11, r31
    7252:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
	
	while(encoder < 480)
	{
     
	PMDGetActualPosition(&hAxis[Axis],&encoder);
    7256:	18 2d       	mov	r17, r8
    7258:	89 2c       	mov	r8, r9
    725a:	05 c0       	rjmp	.+10     	; 0x7266 <StepCalibration+0x1ac>
    725c:	c3 01       	movw	r24, r6
    725e:	61 2f       	mov	r22, r17
    7260:	78 2d       	mov	r23, r8
    7262:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
	printf("StepCalibration=> Posicion Instantanea despues del ajuste %ld\n",position);
	PMDGetActualPosition(&hAxis[Axis],&encoder);
	printf("StepCalibration=> Lectura encoder Despues de ajustar %ld\n",encoder);	
	mov_axis(Axis,INF,300000,100,update);
	
	while(encoder < 480)
    7266:	8d 81       	ldd	r24, Y+5	; 0x05
    7268:	9e 81       	ldd	r25, Y+6	; 0x06
    726a:	af 81       	ldd	r26, Y+7	; 0x07
    726c:	b8 85       	ldd	r27, Y+8	; 0x08
    726e:	80 5e       	subi	r24, 0xE0	; 224
    7270:	91 40       	sbci	r25, 0x01	; 1
    7272:	a0 40       	sbci	r26, 0x00	; 0
    7274:	b0 40       	sbci	r27, 0x00	; 0
    7276:	94 f3       	brlt	.-28     	; 0x725c <StepCalibration+0x1a2>
     
	PMDGetActualPosition(&hAxis[Axis],&encoder);
	//printf("Encoder = %ld\n",encoder);	
	 
	}
	PMDSetStopMode(&hAxis[Axis],PMDAbruptStopMode);
    7278:	c3 01       	movw	r24, r6
    727a:	61 e0       	ldi	r22, 0x01	; 1
    727c:	70 e0       	ldi	r23, 0x00	; 0
    727e:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
	PMDUpdate(&hAxis[Axis]);
    7282:	c3 01       	movw	r24, r6
    7284:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
	PMDGetCommandedPosition(&hAxis[Axis],&position);
    7288:	c3 01       	movw	r24, r6
    728a:	be 01       	movw	r22, r28
    728c:	6f 5f       	subi	r22, 0xFF	; 255
    728e:	7f 4f       	sbci	r23, 0xFF	; 255
    7290:	0e 94 8c 64 	call	0xc918	; 0xc918 <PMDGetCommandedPosition>
	
	printf("StepCalibration=> Posicion Instantanea al completar 480 pulsos del encoder => %ld\n",position);  
    7294:	00 d0       	rcall	.+0      	; 0x7296 <StepCalibration+0x1dc>
    7296:	00 d0       	rcall	.+0      	; 0x7298 <StepCalibration+0x1de>
    7298:	00 d0       	rcall	.+0      	; 0x729a <StepCalibration+0x1e0>
    729a:	8a e1       	ldi	r24, 0x1A	; 26
    729c:	90 e5       	ldi	r25, 0x50	; 80
    729e:	ed b7       	in	r30, 0x3d	; 61
    72a0:	fe b7       	in	r31, 0x3e	; 62
    72a2:	92 83       	std	Z+2, r25	; 0x02
    72a4:	81 83       	std	Z+1, r24	; 0x01
    72a6:	89 81       	ldd	r24, Y+1	; 0x01
    72a8:	9a 81       	ldd	r25, Y+2	; 0x02
    72aa:	ab 81       	ldd	r26, Y+3	; 0x03
    72ac:	bc 81       	ldd	r27, Y+4	; 0x04
    72ae:	83 83       	std	Z+3, r24	; 0x03
    72b0:	94 83       	std	Z+4, r25	; 0x04
    72b2:	a5 83       	std	Z+5, r26	; 0x05
    72b4:	b6 83       	std	Z+6, r27	; 0x06
    72b6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Encoder = %ld\n",encoder);	
    72ba:	8d e6       	ldi	r24, 0x6D	; 109
    72bc:	90 e5       	ldi	r25, 0x50	; 80
    72be:	ed b7       	in	r30, 0x3d	; 61
    72c0:	fe b7       	in	r31, 0x3e	; 62
    72c2:	92 83       	std	Z+2, r25	; 0x02
    72c4:	81 83       	std	Z+1, r24	; 0x01
    72c6:	8d 81       	ldd	r24, Y+5	; 0x05
    72c8:	9e 81       	ldd	r25, Y+6	; 0x06
    72ca:	af 81       	ldd	r26, Y+7	; 0x07
    72cc:	b8 85       	ldd	r27, Y+8	; 0x08
    72ce:	83 83       	std	Z+3, r24	; 0x03
    72d0:	94 83       	std	Z+4, r25	; 0x04
    72d2:	a5 83       	std	Z+5, r26	; 0x05
    72d4:	b6 83       	std	Z+6, r27	; 0x06
    72d6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    72da:	8d b7       	in	r24, 0x3d	; 61
    72dc:	9e b7       	in	r25, 0x3e	; 62
    72de:	06 96       	adiw	r24, 0x06	; 6
    72e0:	0f b6       	in	r0, 0x3f	; 63
    72e2:	f8 94       	cli
    72e4:	9e bf       	out	0x3e, r25	; 62
    72e6:	0f be       	out	0x3f, r0	; 63
    72e8:	8d bf       	out	0x3d, r24	; 61

}
    72ea:	28 96       	adiw	r28, 0x08	; 8
    72ec:	0f b6       	in	r0, 0x3f	; 63
    72ee:	f8 94       	cli
    72f0:	de bf       	out	0x3e, r29	; 62
    72f2:	0f be       	out	0x3f, r0	; 63
    72f4:	cd bf       	out	0x3d, r28	; 61
    72f6:	cf 91       	pop	r28
    72f8:	df 91       	pop	r29
    72fa:	1f 91       	pop	r17
    72fc:	0f 91       	pop	r16
    72fe:	ff 90       	pop	r15
    7300:	ef 90       	pop	r14
    7302:	df 90       	pop	r13
    7304:	cf 90       	pop	r12
    7306:	bf 90       	pop	r11
    7308:	af 90       	pop	r10
    730a:	9f 90       	pop	r9
    730c:	8f 90       	pop	r8
    730e:	7f 90       	pop	r7
    7310:	6f 90       	pop	r6
    7312:	08 95       	ret

00007314 <roll>:


//**********************************************************************************************
void roll(PMDint32 position, PMDint32 velocity, PMDuint32 acceleration,
					PMDint16 actualizar,PMDint16 modo_movimiento)
{
    7314:	2f 92       	push	r2
    7316:	3f 92       	push	r3
    7318:	4f 92       	push	r4
    731a:	5f 92       	push	r5
    731c:	6f 92       	push	r6
    731e:	7f 92       	push	r7
    7320:	8f 92       	push	r8
    7322:	9f 92       	push	r9
    7324:	af 92       	push	r10
    7326:	bf 92       	push	r11
    7328:	cf 92       	push	r12
    732a:	df 92       	push	r13
    732c:	ef 92       	push	r14
    732e:	ff 92       	push	r15
    7330:	0f 93       	push	r16
    7332:	1f 93       	push	r17
    7334:	df 93       	push	r29
    7336:	cf 93       	push	r28
    7338:	cd b7       	in	r28, 0x3d	; 61
    733a:	de b7       	in	r29, 0x3e	; 62
    733c:	2e 97       	sbiw	r28, 0x0e	; 14
    733e:	0f b6       	in	r0, 0x3f	; 63
    7340:	f8 94       	cli
    7342:	de bf       	out	0x3e, r29	; 62
    7344:	0f be       	out	0x3f, r0	; 63
    7346:	cd bf       	out	0x3d, r28	; 61
    7348:	69 87       	std	Y+9, r22	; 0x09
    734a:	7a 87       	std	Y+10, r23	; 0x0a
    734c:	8b 87       	std	Y+11, r24	; 0x0b
    734e:	9c 87       	std	Y+12, r25	; 0x0c
    7350:	39 01       	movw	r6, r18
    7352:	4a 01       	movw	r8, r20
    7354:	17 01       	movw	r2, r14
    7356:	28 01       	movw	r4, r16
    7358:	de 86       	std	Y+14, r13	; 0x0e
    735a:	cd 86       	std	Y+13, r12	; 0x0d
	PMDint32  posicion_actual_motor_pitch,posicion_actual_motor_roll;
	#endif
	
	/*deshabilitando eventos de limite porque Roll no tiene interruptores 
	de fin de carrera*/
	PMDSetLimitSwitchMode(&hAxis[AxisRoll],PMDLimitDisabled);
    735c:	84 ef       	ldi	r24, 0xF4	; 244
    735e:	9e e7       	ldi	r25, 0x7E	; 126
    7360:	60 e0       	ldi	r22, 0x00	; 0
    7362:	70 e0       	ldi	r23, 0x00	; 0
    7364:	0e 94 ef 63 	call	0xc7de	; 0xc7de <PMDSetLimitSwitchMode>
	PMDSetLimitSwitchMode(&hAxis[AxisPitch],PMDLimitDisabled);
    7368:	84 e9       	ldi	r24, 0x94	; 148
    736a:	9e e7       	ldi	r25, 0x7E	; 126
    736c:	60 e0       	ldi	r22, 0x00	; 0
    736e:	70 e0       	ldi	r23, 0x00	; 0
    7370:	0e 94 ef 63 	call	0xc7de	; 0xc7de <PMDSetLimitSwitchMode>
	PMDGetActualPosition(&hAxis[AxisRoll],&posicion_actual_motor_roll);
	printf("roll=> Posicion encoder actual del motor de pitch %ld\n",posicion_actual_motor_pitch);
	printf("roll=> Posicion encoder actual del motor de roll %ld\n",posicion_actual_motor_roll);
	#endif
	
	switch (modo_movimiento)
    7374:	21 e0       	ldi	r18, 0x01	; 1
    7376:	a2 16       	cp	r10, r18
    7378:	b1 04       	cpc	r11, r1
    737a:	31 f0       	breq	.+12     	; 0x7388 <roll+0x74>
    737c:	34 e0       	ldi	r19, 0x04	; 4
    737e:	a3 16       	cp	r10, r19
    7380:	b1 04       	cpc	r11, r1
    7382:	09 f0       	breq	.+2      	; 0x7386 <roll+0x72>
    7384:	70 c0       	rjmp	.+224    	; 0x7466 <roll+0x152>
    7386:	4f c0       	rjmp	.+158    	; 0x7426 <roll+0x112>
	{ 
		case (MOVIMIENTO_NORMAL):
			/* Leer el movimiento anterior de Roll que esta almacenado en EEPROM*/
			eeprom_read_block((void*)&Mov_Roll_Anterior_RAM,(const void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    7388:	ce 01       	movw	r24, r28
    738a:	01 96       	adiw	r24, 0x01	; 1
    738c:	66 e5       	ldi	r22, 0x56	; 86
    738e:	71 e0       	ldi	r23, 0x01	; 1
    7390:	44 e0       	ldi	r20, 0x04	; 4
    7392:	50 e0       	ldi	r21, 0x00	; 0
    7394:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
			//#ifdef DEBUGROBOTICS
				printf("roll => Movimiento de roll Anterior EEPROM de %s = %ld\n",AxisName(AxisRoll),Mov_Roll_Anterior_RAM);
    7398:	84 e0       	ldi	r24, 0x04	; 4
    739a:	90 e0       	ldi	r25, 0x00	; 0
    739c:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    73a0:	ad b7       	in	r26, 0x3d	; 61
    73a2:	be b7       	in	r27, 0x3e	; 62
    73a4:	18 97       	sbiw	r26, 0x08	; 8
    73a6:	0f b6       	in	r0, 0x3f	; 63
    73a8:	f8 94       	cli
    73aa:	be bf       	out	0x3e, r27	; 62
    73ac:	0f be       	out	0x3f, r0	; 63
    73ae:	ad bf       	out	0x3d, r26	; 61
    73b0:	ed b7       	in	r30, 0x3d	; 61
    73b2:	fe b7       	in	r31, 0x3e	; 62
    73b4:	31 96       	adiw	r30, 0x01	; 1
    73b6:	2c e7       	ldi	r18, 0x7C	; 124
    73b8:	30 e5       	ldi	r19, 0x50	; 80
    73ba:	12 96       	adiw	r26, 0x02	; 2
    73bc:	3c 93       	st	X, r19
    73be:	2e 93       	st	-X, r18
    73c0:	11 97       	sbiw	r26, 0x01	; 1
    73c2:	93 83       	std	Z+3, r25	; 0x03
    73c4:	82 83       	std	Z+2, r24	; 0x02
    73c6:	89 81       	ldd	r24, Y+1	; 0x01
    73c8:	9a 81       	ldd	r25, Y+2	; 0x02
    73ca:	ab 81       	ldd	r26, Y+3	; 0x03
    73cc:	bc 81       	ldd	r27, Y+4	; 0x04
    73ce:	84 83       	std	Z+4, r24	; 0x04
    73d0:	95 83       	std	Z+5, r25	; 0x05
    73d2:	a6 83       	std	Z+6, r26	; 0x06
    73d4:	b7 83       	std	Z+7, r27	; 0x07
    73d6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				printf("roll => Actualizando ActualPosition motor de  PITCH y ROLL en roll();! \n");
    73da:	2d b7       	in	r18, 0x3d	; 61
    73dc:	3e b7       	in	r19, 0x3e	; 62
    73de:	28 5f       	subi	r18, 0xF8	; 248
    73e0:	3f 4f       	sbci	r19, 0xFF	; 255
    73e2:	0f b6       	in	r0, 0x3f	; 63
    73e4:	f8 94       	cli
    73e6:	3e bf       	out	0x3e, r19	; 62
    73e8:	0f be       	out	0x3f, r0	; 63
    73ea:	2d bf       	out	0x3d, r18	; 61
    73ec:	84 eb       	ldi	r24, 0xB4	; 180
    73ee:	90 e5       	ldi	r25, 0x50	; 80
    73f0:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
			//#endif	
			/* Carga el valor de movimiento anterior de Roll a los encoders de los motores de pitch y roll*/
			PMDSetActualPosition(&hAxis[AxisPitch],Mov_Roll_Anterior_RAM);
    73f4:	49 81       	ldd	r20, Y+1	; 0x01
    73f6:	5a 81       	ldd	r21, Y+2	; 0x02
    73f8:	6b 81       	ldd	r22, Y+3	; 0x03
    73fa:	7c 81       	ldd	r23, Y+4	; 0x04
    73fc:	84 e9       	ldi	r24, 0x94	; 148
    73fe:	9e e7       	ldi	r25, 0x7E	; 126
    7400:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>
			PMDSetActualPosition(&hAxis[AxisRoll],Mov_Roll_Anterior_RAM);
    7404:	49 81       	ldd	r20, Y+1	; 0x01
    7406:	5a 81       	ldd	r21, Y+2	; 0x02
    7408:	6b 81       	ldd	r22, Y+3	; 0x03
    740a:	7c 81       	ldd	r23, Y+4	; 0x04
    740c:	84 ef       	ldi	r24, 0xF4	; 244
    740e:	9e e7       	ldi	r25, 0x7E	; 126
    7410:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>
			//Es un movimiento normal se debe de actualizar la posicion eeprom.
			eeprom_write_block((const void*)&position,(void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    7414:	ce 01       	movw	r24, r28
    7416:	09 96       	adiw	r24, 0x09	; 9
    7418:	66 e5       	ldi	r22, 0x56	; 86
    741a:	71 e0       	ldi	r23, 0x01	; 1
    741c:	44 e0       	ldi	r20, 0x04	; 4
    741e:	50 e0       	ldi	r21, 0x00	; 0
    7420:	0e 94 e3 89 	call	0x113c6	; 0x113c6 <__eewr_block_m1280>
    7424:	20 c0       	rjmp	.+64     	; 0x7466 <roll+0x152>
	    break;
	    case (INICIANDO_HOME_PITCH_ROLL):
			//Debo reinicar el movimiento anterior a cero. Para evitar descuadre del encoder cuando: 
			//-Hago HOME luego me muevo hacia una posicion X y luego hago home.
			//-Apago el controlador y se mueve por error el los motores de pitch y roll.
			temp=0;
    7426:	1d 82       	std	Y+5, r1	; 0x05
    7428:	1e 82       	std	Y+6, r1	; 0x06
    742a:	1f 82       	std	Y+7, r1	; 0x07
    742c:	18 86       	std	Y+8, r1	; 0x08
			eeprom_write_block((const void*)&temp,(void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    742e:	ce 01       	movw	r24, r28
    7430:	05 96       	adiw	r24, 0x05	; 5
    7432:	66 e5       	ldi	r22, 0x56	; 86
    7434:	71 e0       	ldi	r23, 0x01	; 1
    7436:	44 e0       	ldi	r20, 0x04	; 4
    7438:	50 e0       	ldi	r21, 0x00	; 0
    743a:	0e 94 e3 89 	call	0x113c6	; 0x113c6 <__eewr_block_m1280>
			//reinicio encoders de pitch y roll en cero
			printf("roll => iniciando encodificadores a cero. \n");
    743e:	8c ef       	ldi	r24, 0xFC	; 252
    7440:	90 e5       	ldi	r25, 0x50	; 80
    7442:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
			PMDSetActualPosition(&hAxis[AxisPitch],0);
    7446:	84 e9       	ldi	r24, 0x94	; 148
    7448:	9e e7       	ldi	r25, 0x7E	; 126
    744a:	40 e0       	ldi	r20, 0x00	; 0
    744c:	50 e0       	ldi	r21, 0x00	; 0
    744e:	60 e0       	ldi	r22, 0x00	; 0
    7450:	70 e0       	ldi	r23, 0x00	; 0
    7452:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>
			PMDSetActualPosition(&hAxis[AxisRoll],0);
    7456:	84 ef       	ldi	r24, 0xF4	; 244
    7458:	9e e7       	ldi	r25, 0x7E	; 126
    745a:	40 e0       	ldi	r20, 0x00	; 0
    745c:	50 e0       	ldi	r21, 0x00	; 0
    745e:	60 e0       	ldi	r22, 0x00	; 0
    7460:	70 e0       	ldi	r23, 0x00	; 0
    7462:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>
	printf("roll => Posicion encoder actual del motor de roll %ld\n",posicion_actual_motor_roll);
	#endif
	
		
	/*Realizo el Movimiento de Roll */	
	mov_axis(AxisPitch, position, velocity, acceleration, actualizar);
    7466:	49 85       	ldd	r20, Y+9	; 0x09
    7468:	5a 85       	ldd	r21, Y+10	; 0x0a
    746a:	6b 85       	ldd	r22, Y+11	; 0x0b
    746c:	7c 85       	ldd	r23, Y+12	; 0x0c
    746e:	83 e0       	ldi	r24, 0x03	; 3
    7470:	90 e0       	ldi	r25, 0x00	; 0
    7472:	94 01       	movw	r18, r8
    7474:	83 01       	movw	r16, r6
    7476:	72 01       	movw	r14, r4
    7478:	61 01       	movw	r12, r2
    747a:	ad 84       	ldd	r10, Y+13	; 0x0d
    747c:	be 84       	ldd	r11, Y+14	; 0x0e
    747e:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
	mov_axis(AxisRoll, position, (velocity), acceleration, actualizar);
    7482:	49 85       	ldd	r20, Y+9	; 0x09
    7484:	5a 85       	ldd	r21, Y+10	; 0x0a
    7486:	6b 85       	ldd	r22, Y+11	; 0x0b
    7488:	7c 85       	ldd	r23, Y+12	; 0x0c
    748a:	84 e0       	ldi	r24, 0x04	; 4
    748c:	90 e0       	ldi	r25, 0x00	; 0
    748e:	94 01       	movw	r18, r8
    7490:	83 01       	movw	r16, r6
    7492:	ad 84       	ldd	r10, Y+13	; 0x0d
    7494:	be 84       	ldd	r11, Y+14	; 0x0e
    7496:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>


}
    749a:	2e 96       	adiw	r28, 0x0e	; 14
    749c:	0f b6       	in	r0, 0x3f	; 63
    749e:	f8 94       	cli
    74a0:	de bf       	out	0x3e, r29	; 62
    74a2:	0f be       	out	0x3f, r0	; 63
    74a4:	cd bf       	out	0x3d, r28	; 61
    74a6:	cf 91       	pop	r28
    74a8:	df 91       	pop	r29
    74aa:	1f 91       	pop	r17
    74ac:	0f 91       	pop	r16
    74ae:	ff 90       	pop	r15
    74b0:	ef 90       	pop	r14
    74b2:	df 90       	pop	r13
    74b4:	cf 90       	pop	r12
    74b6:	bf 90       	pop	r11
    74b8:	af 90       	pop	r10
    74ba:	9f 90       	pop	r9
    74bc:	8f 90       	pop	r8
    74be:	7f 90       	pop	r7
    74c0:	6f 90       	pop	r6
    74c2:	5f 90       	pop	r5
    74c4:	4f 90       	pop	r4
    74c6:	3f 90       	pop	r3
    74c8:	2f 90       	pop	r2
    74ca:	08 95       	ret

000074cc <search_home_roll_positive>:
	printf("search_home_positive=> El Event status register del eje %s despues de limpiar es %X \n ",AxisName(Axis),status);	
	#endif
}
/**********************************************************************************************************************/
void search_home_roll_positive(PMDint32 *home)
{
    74cc:	2f 92       	push	r2
    74ce:	3f 92       	push	r3
    74d0:	4f 92       	push	r4
    74d2:	5f 92       	push	r5
    74d4:	6f 92       	push	r6
    74d6:	7f 92       	push	r7
    74d8:	8f 92       	push	r8
    74da:	9f 92       	push	r9
    74dc:	af 92       	push	r10
    74de:	bf 92       	push	r11
    74e0:	cf 92       	push	r12
    74e2:	df 92       	push	r13
    74e4:	ef 92       	push	r14
    74e6:	ff 92       	push	r15
    74e8:	0f 93       	push	r16
    74ea:	1f 93       	push	r17
    74ec:	df 93       	push	r29
    74ee:	cf 93       	push	r28
    74f0:	00 d0       	rcall	.+0      	; 0x74f2 <search_home_roll_positive+0x26>
    74f2:	00 d0       	rcall	.+0      	; 0x74f4 <search_home_roll_positive+0x28>
    74f4:	00 d0       	rcall	.+0      	; 0x74f6 <search_home_roll_positive+0x2a>
    74f6:	cd b7       	in	r28, 0x3d	; 61
    74f8:	de b7       	in	r29, 0x3e	; 62
    74fa:	4c 01       	movw	r8, r24

  	

	find_home_out=1;
	
	No_limit_switch(AxisPitch);
    74fc:	83 e0       	ldi	r24, 0x03	; 3
    74fe:	90 e0       	ldi	r25, 0x00	; 0
    7500:	0e 94 4e 34 	call	0x689c	; 0x689c <No_limit_switch>
	//Se cambia el perfil movimiento a perfil de  Velocidad	
	PMDSetProfileMode(&hAxis[AxisRoll],  PMDVelocityContouringProfile );
    7504:	84 ef       	ldi	r24, 0xF4	; 244
    7506:	9e e7       	ldi	r25, 0x7E	; 126
    7508:	61 e0       	ldi	r22, 0x01	; 1
    750a:	70 e0       	ldi	r23, 0x00	; 0
    750c:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
	PMDSetProfileMode(&hAxis[AxisPitch],  PMDVelocityContouringProfile );
    7510:	84 e9       	ldi	r24, 0x94	; 148
    7512:	9e e7       	ldi	r25, 0x7E	; 126
    7514:	61 e0       	ldi	r22, 0x01	; 1
    7516:	70 e0       	ldi	r23, 0x00	; 0
    7518:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
	//Limpia el BiT de Position Capture Indicator en el Status Register
	PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventCaptureReceivedMask);	
    751c:	84 ef       	ldi	r24, 0xF4	; 244
    751e:	9e e7       	ldi	r25, 0x7E	; 126
    7520:	67 ef       	ldi	r22, 0xF7	; 247
    7522:	7f ef       	ldi	r23, 0xFF	; 255
    7524:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
	//La senal de HOME sera utilizada como Disparo para la Captura de la Posicion
	PMDSetCaptureSource(&hAxis[AxisRoll],PMDCaptureSourceHome);
    7528:	84 ef       	ldi	r24, 0xF4	; 244
    752a:	9e e7       	ldi	r25, 0x7E	; 126
    752c:	61 e0       	ldi	r22, 0x01	; 1
    752e:	70 e0       	ldi	r23, 0x00	; 0
    7530:	0e 94 95 63 	call	0xc72a	; 0xc72a <PMDSetCaptureSource>
	//Leyendo el registro de Captura de Posicion Causa "rearmar" 
	//el disparador con el fin de permitir mas capturas.
	PMDGetCaptureValue(&hAxis[AxisRoll],&temp); 
    7534:	84 ef       	ldi	r24, 0xF4	; 244
    7536:	9e e7       	ldi	r25, 0x7E	; 126
    7538:	be 01       	movw	r22, r28
    753a:	6d 5f       	subi	r22, 0xFD	; 253
    753c:	7f 4f       	sbci	r23, 0xFF	; 255
    753e:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <PMDGetCaptureValue>

	#ifdef DEBUGROBOTICS_HOME
	printf("search_home_roll_positive=> Ejecutado No_limit_switch\n");
    7542:	87 e2       	ldi	r24, 0x27	; 39
    7544:	91 e5       	ldi	r25, 0x51	; 81
    7546:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	printf("search_home_roll_positive=> Moviendo Roll en direccion Positiva para Hallar HOME \n ");
    754a:	00 d0       	rcall	.+0      	; 0x754c <search_home_roll_positive+0x80>
    754c:	8d e5       	ldi	r24, 0x5D	; 93
    754e:	91 e5       	ldi	r25, 0x51	; 81
    7550:	ed b7       	in	r30, 0x3d	; 61
    7552:	fe b7       	in	r31, 0x3e	; 62
    7554:	92 83       	std	Z+2, r25	; 0x02
    7556:	81 83       	std	Z+1, r24	; 0x01
    7558:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	#endif
	roll(none,0.7*(hAxis[AxisRoll].axisSettings.homeVelocity),
    755c:	0f 90       	pop	r0
    755e:	0f 90       	pop	r0
    7560:	60 91 34 7f 	lds	r22, 0x7F34
    7564:	70 91 35 7f 	lds	r23, 0x7F35
    7568:	80 91 36 7f 	lds	r24, 0x7F36
    756c:	90 91 37 7f 	lds	r25, 0x7F37
    7570:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    7574:	23 e3       	ldi	r18, 0x33	; 51
    7576:	33 e3       	ldi	r19, 0x33	; 51
    7578:	43 e3       	ldi	r20, 0x33	; 51
    757a:	5f e3       	ldi	r21, 0x3F	; 63
    757c:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    7580:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    7584:	9b 01       	movw	r18, r22
    7586:	ac 01       	movw	r20, r24
    7588:	e0 90 38 7f 	lds	r14, 0x7F38
    758c:	f0 90 39 7f 	lds	r15, 0x7F39
    7590:	00 91 3a 7f 	lds	r16, 0x7F3A
    7594:	10 91 3b 7f 	lds	r17, 0x7F3B
    7598:	61 ef       	ldi	r22, 0xF1	; 241
    759a:	7f ef       	ldi	r23, 0xFF	; 255
    759c:	8f ef       	ldi	r24, 0xFF	; 255
    759e:	9f ef       	ldi	r25, 0xFF	; 255
    75a0:	f0 ef       	ldi	r31, 0xF0	; 240
    75a2:	cf 2e       	mov	r12, r31
    75a4:	ff ef       	ldi	r31, 0xFF	; 255
    75a6:	df 2e       	mov	r13, r31
    75a8:	e4 e0       	ldi	r30, 0x04	; 4
    75aa:	ae 2e       	mov	r10, r30
    75ac:	b1 2c       	mov	r11, r1
    75ae:	0e 94 8a 39 	call	0x7314	; 0x7314 <roll>
    75b2:	22 e3       	ldi	r18, 0x32	; 50
    75b4:	c2 2e       	mov	r12, r18
    75b6:	d1 2c       	mov	r13, r1
			PMDUpdate(&hAxis[AxisPitch]);	
			//Adicionando correccion
			rad=grados2rad(AJUSTE_ROLL_HOME_POSI_TIME);
			Correcion=rad2usteps(&hAxis[AxisPitch].axisSettings,rad);
			printf("search_home_roll_positive=> Factor de correcion de roll (search_home_positive) en uPasos = %ld\n",Correcion);
			printf("search_home_roll_positive=> home = %ld\n",*home);
    75b8:	9b e7       	ldi	r25, 0x7B	; 123
    75ba:	29 2e       	mov	r2, r25
    75bc:	92 e5       	ldi	r25, 0x52	; 82
    75be:	39 2e       	mov	r3, r25
			*home = *home+Correcion;	
			printf("search_home_roll_positive=> home + Correcion = %ld\n",*home);	
    75c0:	83 ea       	ldi	r24, 0xA3	; 163
    75c2:	48 2e       	mov	r4, r24
    75c4:	82 e5       	ldi	r24, 0x52	; 82
    75c6:	58 2e       	mov	r5, r24
			
		timer --;
		
		#ifdef DEBUGROBOTICS_HOME		
		if(timer==0)
			printf("search_home_roll_positive=> Time OUT . \n ");				
    75c8:	07 ed       	ldi	r16, 0xD7	; 215
    75ca:	60 2e       	mov	r6, r16
    75cc:	02 e5       	ldi	r16, 0x52	; 82
    75ce:	70 2e       	mov	r7, r16
		printf("search_home_roll_positive=> Moviendo en direccion positiva. \n ");
    75d0:	11 e0       	ldi	r17, 0x01	; 1
    75d2:	a1 2e       	mov	r10, r17
    75d4:	13 e5       	ldi	r17, 0x53	; 83
    75d6:	b1 2e       	mov	r11, r17
	
	timer = 50;//50; 	//Este valor garantiza un movimiento de 45 grados en la direccion positiva
	
	do 
	{ 
		PMDGetEventStatus(&hAxis[AxisRoll],&status);
    75d8:	84 ef       	ldi	r24, 0xF4	; 244
    75da:	9e e7       	ldi	r25, 0x7E	; 126
    75dc:	be 01       	movw	r22, r28
    75de:	6f 5f       	subi	r22, 0xFF	; 255
    75e0:	7f 4f       	sbci	r23, 0xFF	; 255
    75e2:	0e 94 a7 61 	call	0xc34e	; 0xc34e <PMDGetEventStatus>
		
		if((status & PMDEventCaptureReceivedMask) != 0) // se ha capturado home
    75e6:	89 81       	ldd	r24, Y+1	; 0x01
    75e8:	83 fd       	sbrc	r24, 3
    75ea:	03 c0       	rjmp	.+6      	; 0x75f2 <search_home_roll_positive+0x126>
    75ec:	01 e0       	ldi	r16, 0x01	; 1
    75ee:	10 e0       	ldi	r17, 0x00	; 0
    75f0:	86 c0       	rjmp	.+268    	; 0x76fe <search_home_roll_positive+0x232>
		{   
			#ifdef DEBUGROBOTICS_HOME
				printf("search_home_roll_positive=> Captura de HOME realizada. \n ");			
    75f2:	00 d0       	rcall	.+0      	; 0x75f4 <search_home_roll_positive+0x128>
    75f4:	81 eb       	ldi	r24, 0xB1	; 177
    75f6:	91 e5       	ldi	r25, 0x51	; 81
    75f8:	ed b7       	in	r30, 0x3d	; 61
    75fa:	fe b7       	in	r31, 0x3e	; 62
    75fc:	92 83       	std	Z+2, r25	; 0x02
    75fe:	81 83       	std	Z+1, r24	; 0x01
    7600:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			#endif
			
			PMDGetCaptureValue(&hAxis[AxisRoll],home);
    7604:	0f 90       	pop	r0
    7606:	0f 90       	pop	r0
    7608:	84 ef       	ldi	r24, 0xF4	; 244
    760a:	9e e7       	ldi	r25, 0x7E	; 126
    760c:	b4 01       	movw	r22, r8
    760e:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <PMDGetCaptureValue>
			PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventCaptureReceivedMask);
    7612:	84 ef       	ldi	r24, 0xF4	; 244
    7614:	9e e7       	ldi	r25, 0x7E	; 126
    7616:	67 ef       	ldi	r22, 0xF7	; 247
    7618:	7f ef       	ldi	r23, 0xFF	; 255
    761a:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
			
			#ifdef DEBUGROBOTICS_HOME
				printf("search_home_roll_positive=> Parando Motor... \n ");
    761e:	00 d0       	rcall	.+0      	; 0x7620 <search_home_roll_positive+0x154>
    7620:	8b ee       	ldi	r24, 0xEB	; 235
    7622:	91 e5       	ldi	r25, 0x51	; 81
    7624:	ed b7       	in	r30, 0x3d	; 61
    7626:	fe b7       	in	r31, 0x3e	; 62
    7628:	92 83       	std	Z+2, r25	; 0x02
    762a:	81 83       	std	Z+1, r24	; 0x01
    762c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				
			//se Cambia la variable a 0 para salir del ciclo.
			find_home_out=0;
				
			//detener el movimiento
			PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
    7630:	0f 90       	pop	r0
    7632:	0f 90       	pop	r0
    7634:	84 ef       	ldi	r24, 0xF4	; 244
    7636:	9e e7       	ldi	r25, 0x7E	; 126
    7638:	61 e0       	ldi	r22, 0x01	; 1
    763a:	70 e0       	ldi	r23, 0x00	; 0
    763c:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
			PMDUpdate(&hAxis[AxisRoll]);
    7640:	84 ef       	ldi	r24, 0xF4	; 244
    7642:	9e e7       	ldi	r25, 0x7E	; 126
    7644:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode ); 
    7648:	84 e9       	ldi	r24, 0x94	; 148
    764a:	9e e7       	ldi	r25, 0x7E	; 126
    764c:	61 e0       	ldi	r22, 0x01	; 1
    764e:	70 e0       	ldi	r23, 0x00	; 0
    7650:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
			PMDUpdate(&hAxis[AxisPitch]);	
    7654:	84 e9       	ldi	r24, 0x94	; 148
    7656:	9e e7       	ldi	r25, 0x7E	; 126
    7658:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			//Adicionando correccion
			rad=grados2rad(AJUSTE_ROLL_HOME_POSI_TIME);
    765c:	60 e0       	ldi	r22, 0x00	; 0
    765e:	70 e0       	ldi	r23, 0x00	; 0
    7660:	80 ee       	ldi	r24, 0xE0	; 224
    7662:	90 ec       	ldi	r25, 0xC0	; 192
    7664:	0e 94 55 13 	call	0x26aa	; 0x26aa <grados2rad>
    7668:	ab 01       	movw	r20, r22
    766a:	bc 01       	movw	r22, r24
			Correcion=rad2usteps(&hAxis[AxisPitch].axisSettings,rad);
    766c:	88 e9       	ldi	r24, 0x98	; 152
    766e:	9e e7       	ldi	r25, 0x7E	; 126
    7670:	0e 94 83 12 	call	0x2506	; 0x2506 <rad2usteps>
    7674:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    7678:	7b 01       	movw	r14, r22
    767a:	8c 01       	movw	r16, r24
			printf("search_home_roll_positive=> Factor de correcion de roll (search_home_positive) en uPasos = %ld\n",Correcion);
    767c:	00 d0       	rcall	.+0      	; 0x767e <search_home_roll_positive+0x1b2>
    767e:	00 d0       	rcall	.+0      	; 0x7680 <search_home_roll_positive+0x1b4>
    7680:	00 d0       	rcall	.+0      	; 0x7682 <search_home_roll_positive+0x1b6>
    7682:	8b e1       	ldi	r24, 0x1B	; 27
    7684:	92 e5       	ldi	r25, 0x52	; 82
    7686:	ed b7       	in	r30, 0x3d	; 61
    7688:	fe b7       	in	r31, 0x3e	; 62
    768a:	92 83       	std	Z+2, r25	; 0x02
    768c:	81 83       	std	Z+1, r24	; 0x01
    768e:	e3 82       	std	Z+3, r14	; 0x03
    7690:	f4 82       	std	Z+4, r15	; 0x04
    7692:	05 83       	std	Z+5, r16	; 0x05
    7694:	16 83       	std	Z+6, r17	; 0x06
    7696:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			printf("search_home_roll_positive=> home = %ld\n",*home);
    769a:	ed b7       	in	r30, 0x3d	; 61
    769c:	fe b7       	in	r31, 0x3e	; 62
    769e:	32 82       	std	Z+2, r3	; 0x02
    76a0:	21 82       	std	Z+1, r2	; 0x01
    76a2:	f4 01       	movw	r30, r8
    76a4:	80 81       	ld	r24, Z
    76a6:	91 81       	ldd	r25, Z+1	; 0x01
    76a8:	a2 81       	ldd	r26, Z+2	; 0x02
    76aa:	b3 81       	ldd	r27, Z+3	; 0x03
    76ac:	ed b7       	in	r30, 0x3d	; 61
    76ae:	fe b7       	in	r31, 0x3e	; 62
    76b0:	83 83       	std	Z+3, r24	; 0x03
    76b2:	94 83       	std	Z+4, r25	; 0x04
    76b4:	a5 83       	std	Z+5, r26	; 0x05
    76b6:	b6 83       	std	Z+6, r27	; 0x06
    76b8:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			*home = *home+Correcion;	
    76bc:	f4 01       	movw	r30, r8
    76be:	80 81       	ld	r24, Z
    76c0:	91 81       	ldd	r25, Z+1	; 0x01
    76c2:	a2 81       	ldd	r26, Z+2	; 0x02
    76c4:	b3 81       	ldd	r27, Z+3	; 0x03
    76c6:	8e 0d       	add	r24, r14
    76c8:	9f 1d       	adc	r25, r15
    76ca:	a0 1f       	adc	r26, r16
    76cc:	b1 1f       	adc	r27, r17
    76ce:	80 83       	st	Z, r24
    76d0:	91 83       	std	Z+1, r25	; 0x01
    76d2:	a2 83       	std	Z+2, r26	; 0x02
    76d4:	b3 83       	std	Z+3, r27	; 0x03
			printf("search_home_roll_positive=> home + Correcion = %ld\n",*home);	
    76d6:	ed b7       	in	r30, 0x3d	; 61
    76d8:	fe b7       	in	r31, 0x3e	; 62
    76da:	52 82       	std	Z+2, r5	; 0x02
    76dc:	41 82       	std	Z+1, r4	; 0x01
    76de:	83 83       	std	Z+3, r24	; 0x03
    76e0:	94 83       	std	Z+4, r25	; 0x04
    76e2:	a5 83       	std	Z+5, r26	; 0x05
    76e4:	b6 83       	std	Z+6, r27	; 0x06
    76e6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    76ea:	00 e0       	ldi	r16, 0x00	; 0
    76ec:	10 e0       	ldi	r17, 0x00	; 0
    76ee:	8d b7       	in	r24, 0x3d	; 61
    76f0:	9e b7       	in	r25, 0x3e	; 62
    76f2:	06 96       	adiw	r24, 0x06	; 6
    76f4:	0f b6       	in	r0, 0x3f	; 63
    76f6:	f8 94       	cli
    76f8:	9e bf       	out	0x3e, r25	; 62
    76fa:	0f be       	out	0x3f, r0	; 63
    76fc:	8d bf       	out	0x3d, r24	; 61
			
		}
			
		timer --;
    76fe:	08 94       	sec
    7700:	c1 08       	sbc	r12, r1
    7702:	d1 08       	sbc	r13, r1
		
		#ifdef DEBUGROBOTICS_HOME		
		if(timer==0)
    7704:	c1 14       	cp	r12, r1
    7706:	d1 04       	cpc	r13, r1
    7708:	49 f4       	brne	.+18     	; 0x771c <search_home_roll_positive+0x250>
			printf("search_home_roll_positive=> Time OUT . \n ");				
    770a:	00 d0       	rcall	.+0      	; 0x770c <search_home_roll_positive+0x240>
    770c:	ed b7       	in	r30, 0x3d	; 61
    770e:	fe b7       	in	r31, 0x3e	; 62
    7710:	72 82       	std	Z+2, r7	; 0x02
    7712:	61 82       	std	Z+1, r6	; 0x01
    7714:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    7718:	0f 90       	pop	r0
    771a:	0f 90       	pop	r0
		printf("search_home_roll_positive=> Moviendo en direccion positiva. \n ");
    771c:	00 d0       	rcall	.+0      	; 0x771e <search_home_roll_positive+0x252>
    771e:	ed b7       	in	r30, 0x3d	; 61
    7720:	fe b7       	in	r31, 0x3e	; 62
    7722:	b2 82       	std	Z+2, r11	; 0x02
    7724:	a1 82       	std	Z+1, r10	; 0x01
    7726:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		#endif
	} 
	while  ((find_home_out==1) && (timer !=0));//Mientras encuentre HOME o no  se cumpla el timer
    772a:	0f 90       	pop	r0
    772c:	0f 90       	pop	r0
    772e:	01 30       	cpi	r16, 0x01	; 1
    7730:	11 05       	cpc	r17, r1
    7732:	21 f4       	brne	.+8      	; 0x773c <search_home_roll_positive+0x270>
    7734:	c1 14       	cp	r12, r1
    7736:	d1 04       	cpc	r13, r1
    7738:	09 f0       	breq	.+2      	; 0x773c <search_home_roll_positive+0x270>
    773a:	4e cf       	rjmp	.-356    	; 0x75d8 <search_home_roll_positive+0x10c>

	
	#ifdef DEBUGROBOTICS_HOME		
		printf("search_home_roll_positive=> El Valor del timer es  %d \n",timer);	
    773c:	00 d0       	rcall	.+0      	; 0x773e <search_home_roll_positive+0x272>
    773e:	00 d0       	rcall	.+0      	; 0x7740 <search_home_roll_positive+0x274>
    7740:	80 e4       	ldi	r24, 0x40	; 64
    7742:	93 e5       	ldi	r25, 0x53	; 83
    7744:	ed b7       	in	r30, 0x3d	; 61
    7746:	fe b7       	in	r31, 0x3e	; 62
    7748:	92 83       	std	Z+2, r25	; 0x02
    774a:	81 83       	std	Z+1, r24	; 0x01
    774c:	d4 82       	std	Z+4, r13	; 0x04
    774e:	c3 82       	std	Z+3, r12	; 0x03
    7750:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	#endif	
	
	//detener  el movimiento
	PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
    7754:	0f 90       	pop	r0
    7756:	0f 90       	pop	r0
    7758:	0f 90       	pop	r0
    775a:	0f 90       	pop	r0
    775c:	84 ef       	ldi	r24, 0xF4	; 244
    775e:	9e e7       	ldi	r25, 0x7E	; 126
    7760:	61 e0       	ldi	r22, 0x01	; 1
    7762:	70 e0       	ldi	r23, 0x00	; 0
    7764:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
	PMDUpdate(&hAxis[AxisRoll]);
    7768:	84 ef       	ldi	r24, 0xF4	; 244
    776a:	9e e7       	ldi	r25, 0x7E	; 126
    776c:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
	PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode ); 
    7770:	84 e9       	ldi	r24, 0x94	; 148
    7772:	9e e7       	ldi	r25, 0x7E	; 126
    7774:	61 e0       	ldi	r22, 0x01	; 1
    7776:	70 e0       	ldi	r23, 0x00	; 0
    7778:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
	PMDUpdate(&hAxis[AxisPitch]);
    777c:	84 e9       	ldi	r24, 0x94	; 148
    777e:	9e e7       	ldi	r25, 0x7E	; 126
    7780:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
	
	/*Se cambia el perfil movimiento a perfil trapezoidal*/ 
	PMDSetProfileMode(&hAxis[AxisRoll], PMDTrapezoidalProfile);
    7784:	84 ef       	ldi	r24, 0xF4	; 244
    7786:	9e e7       	ldi	r25, 0x7E	; 126
    7788:	60 e0       	ldi	r22, 0x00	; 0
    778a:	70 e0       	ldi	r23, 0x00	; 0
    778c:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
	PMDSetProfileMode(&hAxis[AxisPitch], PMDTrapezoidalProfile);	
    7790:	84 e9       	ldi	r24, 0x94	; 148
    7792:	9e e7       	ldi	r25, 0x7E	; 126
    7794:	60 e0       	ldi	r22, 0x00	; 0
    7796:	70 e0       	ldi	r23, 0x00	; 0
    7798:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
	
	

	
	
}
    779c:	26 96       	adiw	r28, 0x06	; 6
    779e:	0f b6       	in	r0, 0x3f	; 63
    77a0:	f8 94       	cli
    77a2:	de bf       	out	0x3e, r29	; 62
    77a4:	0f be       	out	0x3f, r0	; 63
    77a6:	cd bf       	out	0x3d, r28	; 61
    77a8:	cf 91       	pop	r28
    77aa:	df 91       	pop	r29
    77ac:	1f 91       	pop	r17
    77ae:	0f 91       	pop	r16
    77b0:	ff 90       	pop	r15
    77b2:	ef 90       	pop	r14
    77b4:	df 90       	pop	r13
    77b6:	cf 90       	pop	r12
    77b8:	bf 90       	pop	r11
    77ba:	af 90       	pop	r10
    77bc:	9f 90       	pop	r9
    77be:	8f 90       	pop	r8
    77c0:	7f 90       	pop	r7
    77c2:	6f 90       	pop	r6
    77c4:	5f 90       	pop	r5
    77c6:	4f 90       	pop	r4
    77c8:	3f 90       	pop	r3
    77ca:	2f 90       	pop	r2
    77cc:	08 95       	ret

000077ce <pitch>:


//**********************************************************************************************
void pitch(PMDint32 position, PMDint32 velocity, PMDuint32 acceleration,
					PMDint16 actualizar,PMDint16 modo_movimiento)
{
    77ce:	2f 92       	push	r2
    77d0:	3f 92       	push	r3
    77d2:	4f 92       	push	r4
    77d4:	5f 92       	push	r5
    77d6:	6f 92       	push	r6
    77d8:	7f 92       	push	r7
    77da:	8f 92       	push	r8
    77dc:	9f 92       	push	r9
    77de:	af 92       	push	r10
    77e0:	bf 92       	push	r11
    77e2:	cf 92       	push	r12
    77e4:	df 92       	push	r13
    77e6:	ef 92       	push	r14
    77e8:	ff 92       	push	r15
    77ea:	0f 93       	push	r16
    77ec:	1f 93       	push	r17
    77ee:	df 93       	push	r29
    77f0:	cf 93       	push	r28
    77f2:	cd b7       	in	r28, 0x3d	; 61
    77f4:	de b7       	in	r29, 0x3e	; 62
    77f6:	2e 97       	sbiw	r28, 0x0e	; 14
    77f8:	0f b6       	in	r0, 0x3f	; 63
    77fa:	f8 94       	cli
    77fc:	de bf       	out	0x3e, r29	; 62
    77fe:	0f be       	out	0x3f, r0	; 63
    7800:	cd bf       	out	0x3d, r28	; 61
    7802:	69 87       	std	Y+9, r22	; 0x09
    7804:	7a 87       	std	Y+10, r23	; 0x0a
    7806:	8b 87       	std	Y+11, r24	; 0x0b
    7808:	9c 87       	std	Y+12, r25	; 0x0c
    780a:	39 01       	movw	r6, r18
    780c:	4a 01       	movw	r8, r20
    780e:	17 01       	movw	r2, r14
    7810:	28 01       	movw	r4, r16
    7812:	de 86       	std	Y+14, r13	; 0x0e
    7814:	cd 86       	std	Y+13, r12	; 0x0d
	PMDint32 posicion_actual_motor_pitch, 
	posicion_actual_motor_roll;
	#endif
   
   /*habilitando eventos de limite para realizar movimientos de PiTch*/
	PMDSetLimitSwitchMode(&hAxis[AxisRoll],PMDLimitEnabled);
    7816:	84 ef       	ldi	r24, 0xF4	; 244
    7818:	9e e7       	ldi	r25, 0x7E	; 126
    781a:	61 e0       	ldi	r22, 0x01	; 1
    781c:	70 e0       	ldi	r23, 0x00	; 0
    781e:	0e 94 ef 63 	call	0xc7de	; 0xc7de <PMDSetLimitSwitchMode>
	PMDSetLimitSwitchMode(&hAxis[AxisPitch],PMDLimitEnabled);
    7822:	84 e9       	ldi	r24, 0x94	; 148
    7824:	9e e7       	ldi	r25, 0x7E	; 126
    7826:	61 e0       	ldi	r22, 0x01	; 1
    7828:	70 e0       	ldi	r23, 0x00	; 0
    782a:	0e 94 ef 63 	call	0xc7de	; 0xc7de <PMDSetLimitSwitchMode>
	PMDGetActualPosition(&hAxis[AxisRoll],&posicion_actual_motor_roll);
	printf("pitch=> Posicion encoder actual del motor de pitch %ld\n",posicion_actual_motor_pitch);
	printf("pitch=> Posicion encoder actual del motor de roll %ld\n",posicion_actual_motor_roll);
	#endif
	
	switch (modo_movimiento)
    782e:	21 e0       	ldi	r18, 0x01	; 1
    7830:	a2 16       	cp	r10, r18
    7832:	b1 04       	cpc	r11, r1
    7834:	31 f0       	breq	.+12     	; 0x7842 <pitch+0x74>
    7836:	34 e0       	ldi	r19, 0x04	; 4
    7838:	a3 16       	cp	r10, r19
    783a:	b1 04       	cpc	r11, r1
    783c:	09 f0       	breq	.+2      	; 0x7840 <pitch+0x72>
    783e:	7d c0       	rjmp	.+250    	; 0x793a <pitch+0x16c>
    7840:	60 c0       	rjmp	.+192    	; 0x7902 <pitch+0x134>
	{ 
		case (MOVIMIENTO_NORMAL):
			if(position!=none)
    7842:	89 85       	ldd	r24, Y+9	; 0x09
    7844:	9a 85       	ldd	r25, Y+10	; 0x0a
    7846:	ab 85       	ldd	r26, Y+11	; 0x0b
    7848:	bc 85       	ldd	r27, Y+12	; 0x0c
    784a:	81 5f       	subi	r24, 0xF1	; 241
    784c:	9f 4f       	sbci	r25, 0xFF	; 255
    784e:	af 4f       	sbci	r26, 0xFF	; 255
    7850:	bf 4f       	sbci	r27, 0xFF	; 255
    7852:	09 f4       	brne	.+2      	; 0x7856 <pitch+0x88>
    7854:	72 c0       	rjmp	.+228    	; 0x793a <pitch+0x16c>
			{
				//Leer el movimiento anterior de Pitch que esta almacenado en EEPROM
				eeprom_read_block((void*)&Mov_Pitch_Anterior_RAM,(const void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    7856:	ce 01       	movw	r24, r28
    7858:	01 96       	adiw	r24, 0x01	; 1
    785a:	6a e5       	ldi	r22, 0x5A	; 90
    785c:	71 e0       	ldi	r23, 0x01	; 1
    785e:	44 e0       	ldi	r20, 0x04	; 4
    7860:	50 e0       	ldi	r21, 0x00	; 0
    7862:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
			//	#ifdef DEBUGROBOTICS
				printf("pitch=> Movimiento Anterior de pitch EEPROM de %s = %ld\n",AxisName(AxisPitch),Mov_Pitch_Anterior_RAM);
    7866:	83 e0       	ldi	r24, 0x03	; 3
    7868:	90 e0       	ldi	r25, 0x00	; 0
    786a:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    786e:	ad b7       	in	r26, 0x3d	; 61
    7870:	be b7       	in	r27, 0x3e	; 62
    7872:	18 97       	sbiw	r26, 0x08	; 8
    7874:	0f b6       	in	r0, 0x3f	; 63
    7876:	f8 94       	cli
    7878:	be bf       	out	0x3e, r27	; 62
    787a:	0f be       	out	0x3f, r0	; 63
    787c:	ad bf       	out	0x3d, r26	; 61
    787e:	ed b7       	in	r30, 0x3d	; 61
    7880:	fe b7       	in	r31, 0x3e	; 62
    7882:	31 96       	adiw	r30, 0x01	; 1
    7884:	28 e7       	ldi	r18, 0x78	; 120
    7886:	33 e5       	ldi	r19, 0x53	; 83
    7888:	12 96       	adiw	r26, 0x02	; 2
    788a:	3c 93       	st	X, r19
    788c:	2e 93       	st	-X, r18
    788e:	11 97       	sbiw	r26, 0x01	; 1
    7890:	93 83       	std	Z+3, r25	; 0x03
    7892:	82 83       	std	Z+2, r24	; 0x02
    7894:	89 81       	ldd	r24, Y+1	; 0x01
    7896:	9a 81       	ldd	r25, Y+2	; 0x02
    7898:	ab 81       	ldd	r26, Y+3	; 0x03
    789a:	bc 81       	ldd	r27, Y+4	; 0x04
    789c:	84 83       	std	Z+4, r24	; 0x04
    789e:	95 83       	std	Z+5, r25	; 0x05
    78a0:	a6 83       	std	Z+6, r26	; 0x06
    78a2:	b7 83       	std	Z+7, r27	; 0x07
    78a4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			//	#endif
				//Es un movimiento normal se debe de actualizar la eeprom.
			//#ifdef DEBUGROBOTICS
				printf("pitch=> Actualizando ActualPosition motor de  PITCH y ROLL en pitch();! \n");
    78a8:	2d b7       	in	r18, 0x3d	; 61
    78aa:	3e b7       	in	r19, 0x3e	; 62
    78ac:	28 5f       	subi	r18, 0xF8	; 248
    78ae:	3f 4f       	sbci	r19, 0xFF	; 255
    78b0:	0f b6       	in	r0, 0x3f	; 63
    78b2:	f8 94       	cli
    78b4:	3e bf       	out	0x3e, r19	; 62
    78b6:	0f be       	out	0x3f, r0	; 63
    78b8:	2d bf       	out	0x3d, r18	; 61
    78ba:	81 eb       	ldi	r24, 0xB1	; 177
    78bc:	93 e5       	ldi	r25, 0x53	; 83
    78be:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
			//	#endif
				PMDSetActualPosition(&hAxis[AxisPitch],Mov_Pitch_Anterior_RAM);
    78c2:	49 81       	ldd	r20, Y+1	; 0x01
    78c4:	5a 81       	ldd	r21, Y+2	; 0x02
    78c6:	6b 81       	ldd	r22, Y+3	; 0x03
    78c8:	7c 81       	ldd	r23, Y+4	; 0x04
    78ca:	84 e9       	ldi	r24, 0x94	; 148
    78cc:	9e e7       	ldi	r25, 0x7E	; 126
    78ce:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>
				PMDSetActualPosition(&hAxis[AxisRoll],-(Mov_Pitch_Anterior_RAM));
    78d2:	49 81       	ldd	r20, Y+1	; 0x01
    78d4:	5a 81       	ldd	r21, Y+2	; 0x02
    78d6:	6b 81       	ldd	r22, Y+3	; 0x03
    78d8:	7c 81       	ldd	r23, Y+4	; 0x04
    78da:	70 95       	com	r23
    78dc:	60 95       	com	r22
    78de:	50 95       	com	r21
    78e0:	41 95       	neg	r20
    78e2:	5f 4f       	sbci	r21, 0xFF	; 255
    78e4:	6f 4f       	sbci	r22, 0xFF	; 255
    78e6:	7f 4f       	sbci	r23, 0xFF	; 255
    78e8:	84 ef       	ldi	r24, 0xF4	; 244
    78ea:	9e e7       	ldi	r25, 0x7E	; 126
    78ec:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>
				//Actualizo el movimiento anterior con el actual, para el proximo movimiento.
				eeprom_write_block((const void*)&position,(void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    78f0:	ce 01       	movw	r24, r28
    78f2:	09 96       	adiw	r24, 0x09	; 9
    78f4:	6a e5       	ldi	r22, 0x5A	; 90
    78f6:	71 e0       	ldi	r23, 0x01	; 1
    78f8:	44 e0       	ldi	r20, 0x04	; 4
    78fa:	50 e0       	ldi	r21, 0x00	; 0
    78fc:	0e 94 e3 89 	call	0x113c6	; 0x113c6 <__eewr_block_m1280>
    7900:	1c c0       	rjmp	.+56     	; 0x793a <pitch+0x16c>
			//-Hago HOME luego me muevo hacia una posicion X y luego hago home.
			//-Apago el controlador y se mueve por error los motores de pitch y roll.
			#ifdef DEBUGROBOTICS
				printf("pitch=> Iniciando variable Mov_Pitch_Anterior a Cero.! \n");
			#endif
			temp=0;
    7902:	1d 82       	std	Y+5, r1	; 0x05
    7904:	1e 82       	std	Y+6, r1	; 0x06
    7906:	1f 82       	std	Y+7, r1	; 0x07
    7908:	18 86       	std	Y+8, r1	; 0x08
			eeprom_write_block((const void*)&temp,(void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    790a:	ce 01       	movw	r24, r28
    790c:	05 96       	adiw	r24, 0x05	; 5
    790e:	6a e5       	ldi	r22, 0x5A	; 90
    7910:	71 e0       	ldi	r23, 0x01	; 1
    7912:	44 e0       	ldi	r20, 0x04	; 4
    7914:	50 e0       	ldi	r21, 0x00	; 0
    7916:	0e 94 e3 89 	call	0x113c6	; 0x113c6 <__eewr_block_m1280>
			PMDSetActualPosition(&hAxis[AxisPitch],0);
    791a:	84 e9       	ldi	r24, 0x94	; 148
    791c:	9e e7       	ldi	r25, 0x7E	; 126
    791e:	40 e0       	ldi	r20, 0x00	; 0
    7920:	50 e0       	ldi	r21, 0x00	; 0
    7922:	60 e0       	ldi	r22, 0x00	; 0
    7924:	70 e0       	ldi	r23, 0x00	; 0
    7926:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>
			PMDSetActualPosition(&hAxis[AxisRoll],0);
    792a:	84 ef       	ldi	r24, 0xF4	; 244
    792c:	9e e7       	ldi	r25, 0x7E	; 126
    792e:	40 e0       	ldi	r20, 0x00	; 0
    7930:	50 e0       	ldi	r21, 0x00	; 0
    7932:	60 e0       	ldi	r22, 0x00	; 0
    7934:	70 e0       	ldi	r23, 0x00	; 0
    7936:	0e 94 ad 67 	call	0xcf5a	; 0xcf5a <PMDSetActualPosition>
	
	/*Realizo el Movimiento en el motor de Pitch */	
	
	
	
	mov_axis(AxisPitch, position, velocity, acceleration, actualizar);
    793a:	49 85       	ldd	r20, Y+9	; 0x09
    793c:	5a 85       	ldd	r21, Y+10	; 0x0a
    793e:	6b 85       	ldd	r22, Y+11	; 0x0b
    7940:	7c 85       	ldd	r23, Y+12	; 0x0c
    7942:	83 e0       	ldi	r24, 0x03	; 3
    7944:	90 e0       	ldi	r25, 0x00	; 0
    7946:	94 01       	movw	r18, r8
    7948:	83 01       	movw	r16, r6
    794a:	72 01       	movw	r14, r4
    794c:	61 01       	movw	r12, r2
    794e:	ad 84       	ldd	r10, Y+13	; 0x0d
    7950:	be 84       	ldd	r11, Y+14	; 0x0e
    7952:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
	/*none es utilizado cuando se utiliza un perfil de velocidad constante.*/
	if (position == none)
    7956:	89 85       	ldd	r24, Y+9	; 0x09
    7958:	9a 85       	ldd	r25, Y+10	; 0x0a
    795a:	ab 85       	ldd	r26, Y+11	; 0x0b
    795c:	bc 85       	ldd	r27, Y+12	; 0x0c
    795e:	81 3f       	cpi	r24, 0xF1	; 241
    7960:	3f ef       	ldi	r19, 0xFF	; 255
    7962:	93 07       	cpc	r25, r19
    7964:	3f ef       	ldi	r19, 0xFF	; 255
    7966:	a3 07       	cpc	r26, r19
    7968:	3f ef       	ldi	r19, 0xFF	; 255
    796a:	b3 07       	cpc	r27, r19
    796c:	71 f4       	brne	.+28     	; 0x798a <pitch+0x1bc>
	{
		
		/*Realizo el Movimiento en el motor de roll */	
		mov_axis(AxisRoll, position, -(velocity), acceleration, actualizar);
    796e:	00 27       	eor	r16, r16
    7970:	11 27       	eor	r17, r17
    7972:	98 01       	movw	r18, r16
    7974:	06 19       	sub	r16, r6
    7976:	17 09       	sbc	r17, r7
    7978:	28 09       	sbc	r18, r8
    797a:	39 09       	sbc	r19, r9
    797c:	84 e0       	ldi	r24, 0x04	; 4
    797e:	90 e0       	ldi	r25, 0x00	; 0
    7980:	41 ef       	ldi	r20, 0xF1	; 241
    7982:	5f ef       	ldi	r21, 0xFF	; 255
    7984:	6f ef       	ldi	r22, 0xFF	; 255
    7986:	7f ef       	ldi	r23, 0xFF	; 255
    7988:	0d c0       	rjmp	.+26     	; 0x79a4 <pitch+0x1d6>
	}
	else
	{
		/*Realizo el Movimiento en el motor de roll */	
		mov_axis(AxisRoll, -position, (velocity), acceleration, actualizar);
    798a:	44 27       	eor	r20, r20
    798c:	55 27       	eor	r21, r21
    798e:	ba 01       	movw	r22, r20
    7990:	48 1b       	sub	r20, r24
    7992:	59 0b       	sbc	r21, r25
    7994:	6a 0b       	sbc	r22, r26
    7996:	7b 0b       	sbc	r23, r27
    7998:	84 e0       	ldi	r24, 0x04	; 4
    799a:	90 e0       	ldi	r25, 0x00	; 0
    799c:	94 01       	movw	r18, r8
    799e:	83 01       	movw	r16, r6
    79a0:	72 01       	movw	r14, r4
    79a2:	61 01       	movw	r12, r2
    79a4:	ad 84       	ldd	r10, Y+13	; 0x0d
    79a6:	be 84       	ldd	r11, Y+14	; 0x0e
    79a8:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
		
		
	}
	
	
}
    79ac:	2e 96       	adiw	r28, 0x0e	; 14
    79ae:	0f b6       	in	r0, 0x3f	; 63
    79b0:	f8 94       	cli
    79b2:	de bf       	out	0x3e, r29	; 62
    79b4:	0f be       	out	0x3f, r0	; 63
    79b6:	cd bf       	out	0x3d, r28	; 61
    79b8:	cf 91       	pop	r28
    79ba:	df 91       	pop	r29
    79bc:	1f 91       	pop	r17
    79be:	0f 91       	pop	r16
    79c0:	ff 90       	pop	r15
    79c2:	ef 90       	pop	r14
    79c4:	df 90       	pop	r13
    79c6:	cf 90       	pop	r12
    79c8:	bf 90       	pop	r11
    79ca:	af 90       	pop	r10
    79cc:	9f 90       	pop	r9
    79ce:	8f 90       	pop	r8
    79d0:	7f 90       	pop	r7
    79d2:	6f 90       	pop	r6
    79d4:	5f 90       	pop	r5
    79d6:	4f 90       	pop	r4
    79d8:	3f 90       	pop	r3
    79da:	2f 90       	pop	r2
    79dc:	08 95       	ret

000079de <calibration>:
		return b;
}

/**********************************************************************************************************************/
PMDint32 calibration(int16 Axis)
{
    79de:	2f 92       	push	r2
    79e0:	3f 92       	push	r3
    79e2:	4f 92       	push	r4
    79e4:	5f 92       	push	r5
    79e6:	6f 92       	push	r6
    79e8:	7f 92       	push	r7
    79ea:	8f 92       	push	r8
    79ec:	9f 92       	push	r9
    79ee:	af 92       	push	r10
    79f0:	bf 92       	push	r11
    79f2:	cf 92       	push	r12
    79f4:	df 92       	push	r13
    79f6:	ef 92       	push	r14
    79f8:	ff 92       	push	r15
    79fa:	0f 93       	push	r16
    79fc:	1f 93       	push	r17
    79fe:	df 93       	push	r29
    7a00:	cf 93       	push	r28
    7a02:	cd b7       	in	r28, 0x3d	; 61
    7a04:	de b7       	in	r29, 0x3e	; 62
    7a06:	64 97       	sbiw	r28, 0x14	; 20
    7a08:	0f b6       	in	r0, 0x3f	; 63
    7a0a:	f8 94       	cli
    7a0c:	de bf       	out	0x3e, r29	; 62
    7a0e:	0f be       	out	0x3f, r0	; 63
    7a10:	cd bf       	out	0x3d, r28	; 61
    7a12:	2c 01       	movw	r4, r24
	PMDuint16 signal_status;
	int16 i=0,Cont=0;
	

	//Elimina el Error.
	PMDClearPositionError(&hAxis[Axis]);
    7a14:	80 e6       	ldi	r24, 0x60	; 96
    7a16:	90 e0       	ldi	r25, 0x00	; 0
    7a18:	48 9e       	mul	r4, r24
    7a1a:	10 01       	movw	r2, r0
    7a1c:	49 9e       	mul	r4, r25
    7a1e:	30 0c       	add	r3, r0
    7a20:	58 9e       	mul	r5, r24
    7a22:	30 0c       	add	r3, r0
    7a24:	11 24       	eor	r1, r1
    7a26:	14 e7       	ldi	r17, 0x74	; 116
    7a28:	c1 2e       	mov	r12, r17
    7a2a:	1d e7       	ldi	r17, 0x7D	; 125
    7a2c:	d1 2e       	mov	r13, r17
    7a2e:	2c 0c       	add	r2, r12
    7a30:	3d 1c       	adc	r3, r13
    7a32:	c1 01       	movw	r24, r2
    7a34:	0e 94 74 65 	call	0xcae8	; 0xcae8 <PMDClearPositionError>
    7a38:	21 e0       	ldi	r18, 0x01	; 1
    7a3a:	30 e0       	ldi	r19, 0x00	; 0
    7a3c:	40 e0       	ldi	r20, 0x00	; 0
    7a3e:	50 e8       	ldi	r21, 0x80	; 128
    7a40:	2f 87       	std	Y+15, r18	; 0x0f
    7a42:	38 8b       	std	Y+16, r19	; 0x10
    7a44:	49 8b       	std	Y+17, r20	; 0x11
    7a46:	5a 8b       	std	Y+18, r21	; 0x12
    7a48:	8f ef       	ldi	r24, 0xFF	; 255
    7a4a:	9f ef       	ldi	r25, 0xFF	; 255
    7a4c:	af ef       	ldi	r26, 0xFF	; 255
    7a4e:	bf e7       	ldi	r27, 0x7F	; 127
    7a50:	8f 83       	std	Y+7, r24	; 0x07
    7a52:	98 87       	std	Y+8, r25	; 0x08
    7a54:	a9 87       	std	Y+9, r26	; 0x09
    7a56:	ba 87       	std	Y+10, r27	; 0x0a
    7a58:	1b 86       	std	Y+11, r1	; 0x0b
    7a5a:	1c 86       	std	Y+12, r1	; 0x0c
    7a5c:	1d 86       	std	Y+13, r1	; 0x0d
    7a5e:	1e 86       	std	Y+14, r1	; 0x0e
    7a60:	a2 e0       	ldi	r26, 0x02	; 2
    7a62:	b0 e0       	ldi	r27, 0x00	; 0
    7a64:	bc 8b       	std	Y+20, r27	; 0x14
    7a66:	ab 8b       	std	Y+19, r26	; 0x13
	for (i=0; i<5; i++)
	{
		//Mover el eje en la direccion positiva del movimiento. Hasta el que llegue al limite de
		//fin de carrera
		
		switch (Axis)
    7a68:	b2 e0       	ldi	r27, 0x02	; 2
    7a6a:	4b 16       	cp	r4, r27
    7a6c:	51 04       	cpc	r5, r1
    7a6e:	69 f1       	breq	.+90     	; 0x7aca <calibration+0xec>
    7a70:	e3 e0       	ldi	r30, 0x03	; 3
    7a72:	4e 16       	cp	r4, r30
    7a74:	51 04       	cpc	r5, r1
    7a76:	4c f4       	brge	.+18     	; 0x7a8a <calibration+0xac>
    7a78:	41 14       	cp	r4, r1
    7a7a:	51 04       	cpc	r5, r1
    7a7c:	81 f0       	breq	.+32     	; 0x7a9e <calibration+0xc0>
    7a7e:	f1 e0       	ldi	r31, 0x01	; 1
    7a80:	4f 16       	cp	r4, r31
    7a82:	51 04       	cpc	r5, r1
    7a84:	09 f0       	breq	.+2      	; 0x7a88 <calibration+0xaa>
    7a86:	65 c0       	rjmp	.+202    	; 0x7b52 <calibration+0x174>
    7a88:	15 c0       	rjmp	.+42     	; 0x7ab4 <calibration+0xd6>
    7a8a:	23 e0       	ldi	r18, 0x03	; 3
    7a8c:	42 16       	cp	r4, r18
    7a8e:	51 04       	cpc	r5, r1
    7a90:	91 f1       	breq	.+100    	; 0x7af6 <calibration+0x118>
    7a92:	34 e0       	ldi	r19, 0x04	; 4
    7a94:	43 16       	cp	r4, r19
    7a96:	51 04       	cpc	r5, r1
    7a98:	09 f0       	breq	.+2      	; 0x7a9c <calibration+0xbe>
    7a9a:	5b c0       	rjmp	.+182    	; 0x7b52 <calibration+0x174>
    7a9c:	43 c0       	rjmp	.+134    	; 0x7b24 <calibration+0x146>
		{
			
			case (AxisWaist):
		      mov_axis(AxisWaist,INF,60000,100,update);
    7a9e:	80 e0       	ldi	r24, 0x00	; 0
    7aa0:	90 e0       	ldi	r25, 0x00	; 0
    7aa2:	4f ef       	ldi	r20, 0xFF	; 255
    7aa4:	5f ef       	ldi	r21, 0xFF	; 255
    7aa6:	6f ef       	ldi	r22, 0xFF	; 255
    7aa8:	7f e7       	ldi	r23, 0x7F	; 127
    7aaa:	00 e6       	ldi	r16, 0x60	; 96
    7aac:	1a ee       	ldi	r17, 0xEA	; 234
    7aae:	20 e0       	ldi	r18, 0x00	; 0
    7ab0:	30 e0       	ldi	r19, 0x00	; 0
    7ab2:	15 c0       	rjmp	.+42     	; 0x7ade <calibration+0x100>
		   break;
			
		   case (AxisShoulder):
		      mov_axis(AxisShoulder,INF,30000,100,update);
    7ab4:	81 e0       	ldi	r24, 0x01	; 1
    7ab6:	90 e0       	ldi	r25, 0x00	; 0
    7ab8:	4f ef       	ldi	r20, 0xFF	; 255
    7aba:	5f ef       	ldi	r21, 0xFF	; 255
    7abc:	6f ef       	ldi	r22, 0xFF	; 255
    7abe:	7f e7       	ldi	r23, 0x7F	; 127
    7ac0:	00 e3       	ldi	r16, 0x30	; 48
    7ac2:	15 e7       	ldi	r17, 0x75	; 117
    7ac4:	20 e0       	ldi	r18, 0x00	; 0
    7ac6:	30 e0       	ldi	r19, 0x00	; 0
    7ac8:	0a c0       	rjmp	.+20     	; 0x7ade <calibration+0x100>
		   break;
			
			case (AxisElbow):
		      mov_axis(AxisElbow,INF,120000,100,update);
    7aca:	82 e0       	ldi	r24, 0x02	; 2
    7acc:	90 e0       	ldi	r25, 0x00	; 0
    7ace:	4f ef       	ldi	r20, 0xFF	; 255
    7ad0:	5f ef       	ldi	r21, 0xFF	; 255
    7ad2:	6f ef       	ldi	r22, 0xFF	; 255
    7ad4:	7f e7       	ldi	r23, 0x7F	; 127
    7ad6:	00 ec       	ldi	r16, 0xC0	; 192
    7ad8:	14 ed       	ldi	r17, 0xD4	; 212
    7ada:	21 e0       	ldi	r18, 0x01	; 1
    7adc:	30 e0       	ldi	r19, 0x00	; 0
    7ade:	b4 e6       	ldi	r27, 0x64	; 100
    7ae0:	cb 2e       	mov	r12, r27
    7ae2:	d1 2c       	mov	r13, r1
    7ae4:	e1 2c       	mov	r14, r1
    7ae6:	f1 2c       	mov	r15, r1
    7ae8:	a0 ef       	ldi	r26, 0xF0	; 240
    7aea:	aa 2e       	mov	r10, r26
    7aec:	af ef       	ldi	r26, 0xFF	; 255
    7aee:	ba 2e       	mov	r11, r26
    7af0:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
    7af4:	52 c0       	rjmp	.+164    	; 0x7b9a <calibration+0x1bc>
		   break;
			
			case (AxisPitch):
		      pitch(INF,35000,100,update,EN_CALIBRACION_PROCESOHOME);
    7af6:	6f ef       	ldi	r22, 0xFF	; 255
    7af8:	7f ef       	ldi	r23, 0xFF	; 255
    7afa:	8f ef       	ldi	r24, 0xFF	; 255
    7afc:	9f e7       	ldi	r25, 0x7F	; 127
    7afe:	28 eb       	ldi	r18, 0xB8	; 184
    7b00:	38 e8       	ldi	r19, 0x88	; 136
    7b02:	40 e0       	ldi	r20, 0x00	; 0
    7b04:	50 e0       	ldi	r21, 0x00	; 0
    7b06:	f4 e6       	ldi	r31, 0x64	; 100
    7b08:	ef 2e       	mov	r14, r31
    7b0a:	f1 2c       	mov	r15, r1
    7b0c:	01 2d       	mov	r16, r1
    7b0e:	11 2d       	mov	r17, r1
    7b10:	e0 ef       	ldi	r30, 0xF0	; 240
    7b12:	ce 2e       	mov	r12, r30
    7b14:	ef ef       	ldi	r30, 0xFF	; 255
    7b16:	de 2e       	mov	r13, r30
    7b18:	b3 e0       	ldi	r27, 0x03	; 3
    7b1a:	ab 2e       	mov	r10, r27
    7b1c:	b1 2c       	mov	r11, r1
    7b1e:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <pitch>
    7b22:	3b c0       	rjmp	.+118    	; 0x7b9a <calibration+0x1bc>
		   break;
			
		   case (AxisRoll):
		      roll(INF,35000,100,update,EN_CALIBRACION_PROCESOHOME );
    7b24:	6f ef       	ldi	r22, 0xFF	; 255
    7b26:	7f ef       	ldi	r23, 0xFF	; 255
    7b28:	8f ef       	ldi	r24, 0xFF	; 255
    7b2a:	9f e7       	ldi	r25, 0x7F	; 127
    7b2c:	28 eb       	ldi	r18, 0xB8	; 184
    7b2e:	38 e8       	ldi	r19, 0x88	; 136
    7b30:	40 e0       	ldi	r20, 0x00	; 0
    7b32:	50 e0       	ldi	r21, 0x00	; 0
    7b34:	a4 e6       	ldi	r26, 0x64	; 100
    7b36:	ea 2e       	mov	r14, r26
    7b38:	f1 2c       	mov	r15, r1
    7b3a:	01 2d       	mov	r16, r1
    7b3c:	11 2d       	mov	r17, r1
    7b3e:	f0 ef       	ldi	r31, 0xF0	; 240
    7b40:	cf 2e       	mov	r12, r31
    7b42:	ff ef       	ldi	r31, 0xFF	; 255
    7b44:	df 2e       	mov	r13, r31
    7b46:	e3 e0       	ldi	r30, 0x03	; 3
    7b48:	ae 2e       	mov	r10, r30
    7b4a:	b1 2c       	mov	r11, r1
    7b4c:	0e 94 8a 39 	call	0x7314	; 0x7314 <roll>
    7b50:	04 c0       	rjmp	.+8      	; 0x7b5a <calibration+0x17c>
		   break;
			
		}
		
		
		if(Axis==AxisRoll)
    7b52:	44 e0       	ldi	r20, 0x04	; 4
    7b54:	44 16       	cp	r4, r20
    7b56:	51 04       	cpc	r5, r1
    7b58:	01 f5       	brne	.+64     	; 0x7b9a <calibration+0x1bc>
		{
		    delay_1s();
    7b5a:	0e 94 e1 76 	call	0xedc2	; 0xedc2 <delay_1s>
			delay_1s();
    7b5e:	0e 94 e1 76 	call	0xedc2	; 0xedc2 <delay_1s>
			do 
			{
				PMDGetSignalStatus(&hAxis[Axis], &signal_status);				
    7b62:	c1 01       	movw	r24, r2
    7b64:	be 01       	movw	r22, r28
    7b66:	6f 5f       	subi	r22, 0xFF	; 255
    7b68:	7f 4f       	sbci	r23, 0xFF	; 255
    7b6a:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
			} 
			while ((signal_status & PMDSignalEncoderHomeMask)!=0);
    7b6e:	89 81       	ldd	r24, Y+1	; 0x01
    7b70:	83 fd       	sbrc	r24, 3
    7b72:	f7 cf       	rjmp	.-18     	; 0x7b62 <calibration+0x184>
			
			//Detener el Eje.(Ya que el Eje Roll no tiene Limites de fin de carrera.
			PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode); 
    7b74:	c1 01       	movw	r24, r2
    7b76:	61 e0       	ldi	r22, 0x01	; 1
    7b78:	70 e0       	ldi	r23, 0x00	; 0
    7b7a:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
			PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode); 
    7b7e:	84 e9       	ldi	r24, 0x94	; 148
    7b80:	9e e7       	ldi	r25, 0x7E	; 126
    7b82:	61 e0       	ldi	r22, 0x01	; 1
    7b84:	70 e0       	ldi	r23, 0x00	; 0
    7b86:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
			PMDUpdate(&hAxis[Axis]);	
    7b8a:	c1 01       	movw	r24, r2
    7b8c:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			PMDUpdate(&hAxis[AxisPitch]);	
    7b90:	84 e9       	ldi	r24, 0x94	; 148
    7b92:	9e e7       	ldi	r25, 0x7E	; 126
    7b94:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
    7b98:	2d c0       	rjmp	.+90     	; 0x7bf4 <calibration+0x216>
		}
		else
		{
			do 
			{			
				PMDGetSignalStatus(&hAxis[Axis], &signal_status);				
    7b9a:	c1 01       	movw	r24, r2
    7b9c:	be 01       	movw	r22, r28
    7b9e:	6f 5f       	subi	r22, 0xFF	; 255
    7ba0:	7f 4f       	sbci	r23, 0xFF	; 255
    7ba2:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
				printf("calibration=> El Signal status register al moverse en + del eje %s es %X \n",AxisName(Axis),signal_status);					
    7ba6:	c2 01       	movw	r24, r4
    7ba8:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    7bac:	00 d0       	rcall	.+0      	; 0x7bae <calibration+0x1d0>
    7bae:	00 d0       	rcall	.+0      	; 0x7bb0 <calibration+0x1d2>
    7bb0:	00 d0       	rcall	.+0      	; 0x7bb2 <calibration+0x1d4>
    7bb2:	ed b7       	in	r30, 0x3d	; 61
    7bb4:	fe b7       	in	r31, 0x3e	; 62
    7bb6:	31 96       	adiw	r30, 0x01	; 1
    7bb8:	0a ef       	ldi	r16, 0xFA	; 250
    7bba:	c0 2e       	mov	r12, r16
    7bbc:	03 e5       	ldi	r16, 0x53	; 83
    7bbe:	d0 2e       	mov	r13, r16
    7bc0:	ad b7       	in	r26, 0x3d	; 61
    7bc2:	be b7       	in	r27, 0x3e	; 62
    7bc4:	12 96       	adiw	r26, 0x02	; 2
    7bc6:	dc 92       	st	X, r13
    7bc8:	ce 92       	st	-X, r12
    7bca:	11 97       	sbiw	r26, 0x01	; 1
    7bcc:	93 83       	std	Z+3, r25	; 0x03
    7bce:	82 83       	std	Z+2, r24	; 0x02
    7bd0:	89 81       	ldd	r24, Y+1	; 0x01
    7bd2:	9a 81       	ldd	r25, Y+2	; 0x02
    7bd4:	95 83       	std	Z+5, r25	; 0x05
    7bd6:	84 83       	std	Z+4, r24	; 0x04
    7bd8:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			} 
			while ((signal_status & PMDSignalPositiveLimitMask)!=0);
    7bdc:	89 81       	ldd	r24, Y+1	; 0x01
    7bde:	2d b7       	in	r18, 0x3d	; 61
    7be0:	3e b7       	in	r19, 0x3e	; 62
    7be2:	2a 5f       	subi	r18, 0xFA	; 250
    7be4:	3f 4f       	sbci	r19, 0xFF	; 255
    7be6:	0f b6       	in	r0, 0x3f	; 63
    7be8:	f8 94       	cli
    7bea:	3e bf       	out	0x3e, r19	; 62
    7bec:	0f be       	out	0x3f, r0	; 63
    7bee:	2d bf       	out	0x3d, r18	; 61
    7bf0:	84 fd       	sbrc	r24, 4
    7bf2:	d3 cf       	rjmp	.-90     	; 0x7b9a <calibration+0x1bc>
		}
		
		// En este punto el Eje se Detiene automaticamente.
		
		//Leer Registro del Encoder
		PMDGetActualPosition(&hAxis[Axis],&read_encoder);
    7bf4:	c1 01       	movw	r24, r2
    7bf6:	be 01       	movw	r22, r28
    7bf8:	6d 5f       	subi	r22, 0xFD	; 253
    7bfa:	7f 4f       	sbci	r23, 0xFF	; 255
    7bfc:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
		
		
			printf("calibration=> La Lectura del valor No %d del encoder del eje %s es : %08ld \n ",(2*i+1),AxisName(Axis),read_encoder);
    7c00:	c2 01       	movw	r24, r4
    7c02:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    7c06:	4d b7       	in	r20, 0x3d	; 61
    7c08:	5e b7       	in	r21, 0x3e	; 62
    7c0a:	4a 50       	subi	r20, 0x0A	; 10
    7c0c:	50 40       	sbci	r21, 0x00	; 0
    7c0e:	0f b6       	in	r0, 0x3f	; 63
    7c10:	f8 94       	cli
    7c12:	5e bf       	out	0x3e, r21	; 62
    7c14:	0f be       	out	0x3f, r0	; 63
    7c16:	4d bf       	out	0x3d, r20	; 61
    7c18:	ed b7       	in	r30, 0x3d	; 61
    7c1a:	fe b7       	in	r31, 0x3e	; 62
    7c1c:	31 96       	adiw	r30, 0x01	; 1
    7c1e:	15 e4       	ldi	r17, 0x45	; 69
    7c20:	c1 2e       	mov	r12, r17
    7c22:	14 e5       	ldi	r17, 0x54	; 84
    7c24:	d1 2e       	mov	r13, r17
    7c26:	ad b7       	in	r26, 0x3d	; 61
    7c28:	be b7       	in	r27, 0x3e	; 62
    7c2a:	12 96       	adiw	r26, 0x02	; 2
    7c2c:	dc 92       	st	X, r13
    7c2e:	ce 92       	st	-X, r12
    7c30:	11 97       	sbiw	r26, 0x01	; 1
    7c32:	2b 89       	ldd	r18, Y+19	; 0x13
    7c34:	3c 89       	ldd	r19, Y+20	; 0x14
    7c36:	21 50       	subi	r18, 0x01	; 1
    7c38:	30 40       	sbci	r19, 0x00	; 0
    7c3a:	33 83       	std	Z+3, r19	; 0x03
    7c3c:	22 83       	std	Z+2, r18	; 0x02
    7c3e:	2f 5f       	subi	r18, 0xFF	; 255
    7c40:	3f 4f       	sbci	r19, 0xFF	; 255
    7c42:	3c 8b       	std	Y+20, r19	; 0x14
    7c44:	2b 8b       	std	Y+19, r18	; 0x13
    7c46:	95 83       	std	Z+5, r25	; 0x05
    7c48:	84 83       	std	Z+4, r24	; 0x04
    7c4a:	8b 81       	ldd	r24, Y+3	; 0x03
    7c4c:	9c 81       	ldd	r25, Y+4	; 0x04
    7c4e:	ad 81       	ldd	r26, Y+5	; 0x05
    7c50:	be 81       	ldd	r27, Y+6	; 0x06
    7c52:	86 83       	std	Z+6, r24	; 0x06
    7c54:	97 83       	std	Z+7, r25	; 0x07
    7c56:	a0 87       	std	Z+8, r26	; 0x08
    7c58:	b1 87       	std	Z+9, r27	; 0x09
    7c5a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		  //  scanf("%d",&Cont);


		
		//Sacar Maximos y Minimos
		max_read = max(max_read, read_encoder);
    7c5e:	6b 80       	ldd	r6, Y+3	; 0x03
    7c60:	7c 80       	ldd	r7, Y+4	; 0x04
    7c62:	8d 80       	ldd	r8, Y+5	; 0x05
    7c64:	9e 80       	ldd	r9, Y+6	; 0x06
		
		//sumar el valor leido
		sum=sum+read_encoder;
		
		//Borrar el registro del Encoder
		PMDAdjustActualPosition(&hAxis[Axis],-read_encoder);
    7c66:	4d b7       	in	r20, 0x3d	; 61
    7c68:	5e b7       	in	r21, 0x3e	; 62
    7c6a:	46 5f       	subi	r20, 0xF6	; 246
    7c6c:	5f 4f       	sbci	r21, 0xFF	; 255
    7c6e:	0f b6       	in	r0, 0x3f	; 63
    7c70:	f8 94       	cli
    7c72:	5e bf       	out	0x3e, r21	; 62
    7c74:	0f be       	out	0x3f, r0	; 63
    7c76:	4d bf       	out	0x3d, r20	; 61
    7c78:	44 27       	eor	r20, r20
    7c7a:	55 27       	eor	r21, r21
    7c7c:	ba 01       	movw	r22, r20
    7c7e:	46 19       	sub	r20, r6
    7c80:	57 09       	sbc	r21, r7
    7c82:	68 09       	sbc	r22, r8
    7c84:	79 09       	sbc	r23, r9
    7c86:	c1 01       	movw	r24, r2
    7c88:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>
		
		//Se limpia el Event Status Register, borrando la interrupcion 		
		PMDResetEventStatus(&hAxis[Axis],~PMDEventInPositiveLimitMask);
    7c8c:	c1 01       	movw	r24, r2
    7c8e:	6f ed       	ldi	r22, 0xDF	; 223
    7c90:	7f ef       	ldi	r23, 0xFF	; 255
    7c92:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
		
		//Se habilita el Generador de Trayectoria.
		PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  		
    7c96:	c1 01       	movw	r24, r2
    7c98:	61 e0       	ldi	r22, 0x01	; 1
    7c9a:	70 e0       	ldi	r23, 0x00	; 0
    7c9c:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
		
		if(Axis==AxisPitch)
    7ca0:	53 e0       	ldi	r21, 0x03	; 3
    7ca2:	45 16       	cp	r4, r21
    7ca4:	51 04       	cpc	r5, r1
    7ca6:	61 f4       	brne	.+24     	; 0x7cc0 <calibration+0x2e2>
		{
			PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventInNegativeLimitMask);	
    7ca8:	84 ef       	ldi	r24, 0xF4	; 244
    7caa:	9e e7       	ldi	r25, 0x7E	; 126
    7cac:	6f eb       	ldi	r22, 0xBF	; 191
    7cae:	7f ef       	ldi	r23, 0xFF	; 255
    7cb0:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 
    7cb4:	84 ef       	ldi	r24, 0xF4	; 244
    7cb6:	9e e7       	ldi	r25, 0x7E	; 126
    7cb8:	61 e0       	ldi	r22, 0x01	; 1
    7cba:	70 e0       	ldi	r23, 0x00	; 0
    7cbc:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
		}	
		
		read_encoder=0;
    7cc0:	1b 82       	std	Y+3, r1	; 0x03
    7cc2:	1c 82       	std	Y+4, r1	; 0x04
    7cc4:	1d 82       	std	Y+5, r1	; 0x05
    7cc6:	1e 82       	std	Y+6, r1	; 0x06
	//fin de carrera
		#ifdef DEBUGROBOTICS
		printf("calibration=> Empezar Movimiento en direccion  negativa \n ");			
		#endif
		
		switch (Axis)
    7cc8:	82 e0       	ldi	r24, 0x02	; 2
    7cca:	48 16       	cp	r4, r24
    7ccc:	51 04       	cpc	r5, r1
    7cce:	69 f1       	breq	.+90     	; 0x7d2a <calibration+0x34c>
    7cd0:	93 e0       	ldi	r25, 0x03	; 3
    7cd2:	49 16       	cp	r4, r25
    7cd4:	51 04       	cpc	r5, r1
    7cd6:	4c f4       	brge	.+18     	; 0x7cea <calibration+0x30c>
    7cd8:	41 14       	cp	r4, r1
    7cda:	51 04       	cpc	r5, r1
    7cdc:	81 f0       	breq	.+32     	; 0x7cfe <calibration+0x320>
    7cde:	a1 e0       	ldi	r26, 0x01	; 1
    7ce0:	4a 16       	cp	r4, r26
    7ce2:	51 04       	cpc	r5, r1
    7ce4:	09 f0       	breq	.+2      	; 0x7ce8 <calibration+0x30a>
    7ce6:	65 c0       	rjmp	.+202    	; 0x7db2 <calibration+0x3d4>
    7ce8:	15 c0       	rjmp	.+42     	; 0x7d14 <calibration+0x336>
    7cea:	b3 e0       	ldi	r27, 0x03	; 3
    7cec:	4b 16       	cp	r4, r27
    7cee:	51 04       	cpc	r5, r1
    7cf0:	91 f1       	breq	.+100    	; 0x7d56 <calibration+0x378>
    7cf2:	e4 e0       	ldi	r30, 0x04	; 4
    7cf4:	4e 16       	cp	r4, r30
    7cf6:	51 04       	cpc	r5, r1
    7cf8:	09 f0       	breq	.+2      	; 0x7cfc <calibration+0x31e>
    7cfa:	5b c0       	rjmp	.+182    	; 0x7db2 <calibration+0x3d4>
    7cfc:	43 c0       	rjmp	.+134    	; 0x7d84 <calibration+0x3a6>
		{
			
			case (AxisWaist):
		      mov_axis(AxisWaist,-INF,60000,100,update);
    7cfe:	80 e0       	ldi	r24, 0x00	; 0
    7d00:	90 e0       	ldi	r25, 0x00	; 0
    7d02:	41 e0       	ldi	r20, 0x01	; 1
    7d04:	50 e0       	ldi	r21, 0x00	; 0
    7d06:	60 e0       	ldi	r22, 0x00	; 0
    7d08:	70 e8       	ldi	r23, 0x80	; 128
    7d0a:	00 e6       	ldi	r16, 0x60	; 96
    7d0c:	1a ee       	ldi	r17, 0xEA	; 234
    7d0e:	20 e0       	ldi	r18, 0x00	; 0
    7d10:	30 e0       	ldi	r19, 0x00	; 0
    7d12:	15 c0       	rjmp	.+42     	; 0x7d3e <calibration+0x360>
		   break;
			
		   case (AxisShoulder):
		      mov_axis(AxisShoulder,-INF,30000,100,update);
    7d14:	81 e0       	ldi	r24, 0x01	; 1
    7d16:	90 e0       	ldi	r25, 0x00	; 0
    7d18:	41 e0       	ldi	r20, 0x01	; 1
    7d1a:	50 e0       	ldi	r21, 0x00	; 0
    7d1c:	60 e0       	ldi	r22, 0x00	; 0
    7d1e:	70 e8       	ldi	r23, 0x80	; 128
    7d20:	00 e3       	ldi	r16, 0x30	; 48
    7d22:	15 e7       	ldi	r17, 0x75	; 117
    7d24:	20 e0       	ldi	r18, 0x00	; 0
    7d26:	30 e0       	ldi	r19, 0x00	; 0
    7d28:	0a c0       	rjmp	.+20     	; 0x7d3e <calibration+0x360>
		   break;
			
			case (AxisElbow):
		      mov_axis(AxisElbow,-INF,120000,100,update);
    7d2a:	82 e0       	ldi	r24, 0x02	; 2
    7d2c:	90 e0       	ldi	r25, 0x00	; 0
    7d2e:	41 e0       	ldi	r20, 0x01	; 1
    7d30:	50 e0       	ldi	r21, 0x00	; 0
    7d32:	60 e0       	ldi	r22, 0x00	; 0
    7d34:	70 e8       	ldi	r23, 0x80	; 128
    7d36:	00 ec       	ldi	r16, 0xC0	; 192
    7d38:	14 ed       	ldi	r17, 0xD4	; 212
    7d3a:	21 e0       	ldi	r18, 0x01	; 1
    7d3c:	30 e0       	ldi	r19, 0x00	; 0
    7d3e:	b4 e6       	ldi	r27, 0x64	; 100
    7d40:	cb 2e       	mov	r12, r27
    7d42:	d1 2c       	mov	r13, r1
    7d44:	e1 2c       	mov	r14, r1
    7d46:	f1 2c       	mov	r15, r1
    7d48:	a0 ef       	ldi	r26, 0xF0	; 240
    7d4a:	aa 2e       	mov	r10, r26
    7d4c:	af ef       	ldi	r26, 0xFF	; 255
    7d4e:	ba 2e       	mov	r11, r26
    7d50:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
    7d54:	52 c0       	rjmp	.+164    	; 0x7dfa <calibration+0x41c>
		   break;
			
			case (AxisPitch):
		      pitch(-INF,35000,100,update,EN_CALIBRACION_PROCESOHOME);
    7d56:	61 e0       	ldi	r22, 0x01	; 1
    7d58:	70 e0       	ldi	r23, 0x00	; 0
    7d5a:	80 e0       	ldi	r24, 0x00	; 0
    7d5c:	90 e8       	ldi	r25, 0x80	; 128
    7d5e:	28 eb       	ldi	r18, 0xB8	; 184
    7d60:	38 e8       	ldi	r19, 0x88	; 136
    7d62:	40 e0       	ldi	r20, 0x00	; 0
    7d64:	50 e0       	ldi	r21, 0x00	; 0
    7d66:	f4 e6       	ldi	r31, 0x64	; 100
    7d68:	ef 2e       	mov	r14, r31
    7d6a:	f1 2c       	mov	r15, r1
    7d6c:	01 2d       	mov	r16, r1
    7d6e:	11 2d       	mov	r17, r1
    7d70:	e0 ef       	ldi	r30, 0xF0	; 240
    7d72:	ce 2e       	mov	r12, r30
    7d74:	ef ef       	ldi	r30, 0xFF	; 255
    7d76:	de 2e       	mov	r13, r30
    7d78:	b3 e0       	ldi	r27, 0x03	; 3
    7d7a:	ab 2e       	mov	r10, r27
    7d7c:	b1 2c       	mov	r11, r1
    7d7e:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <pitch>
    7d82:	3b c0       	rjmp	.+118    	; 0x7dfa <calibration+0x41c>
		   break;
			
		   case (AxisRoll):
		      roll(-INF,35000,100,update,EN_CALIBRACION_PROCESOHOME );
    7d84:	61 e0       	ldi	r22, 0x01	; 1
    7d86:	70 e0       	ldi	r23, 0x00	; 0
    7d88:	80 e0       	ldi	r24, 0x00	; 0
    7d8a:	90 e8       	ldi	r25, 0x80	; 128
    7d8c:	28 eb       	ldi	r18, 0xB8	; 184
    7d8e:	38 e8       	ldi	r19, 0x88	; 136
    7d90:	40 e0       	ldi	r20, 0x00	; 0
    7d92:	50 e0       	ldi	r21, 0x00	; 0
    7d94:	a4 e6       	ldi	r26, 0x64	; 100
    7d96:	ea 2e       	mov	r14, r26
    7d98:	f1 2c       	mov	r15, r1
    7d9a:	01 2d       	mov	r16, r1
    7d9c:	11 2d       	mov	r17, r1
    7d9e:	f0 ef       	ldi	r31, 0xF0	; 240
    7da0:	cf 2e       	mov	r12, r31
    7da2:	ff ef       	ldi	r31, 0xFF	; 255
    7da4:	df 2e       	mov	r13, r31
    7da6:	e3 e0       	ldi	r30, 0x03	; 3
    7da8:	ae 2e       	mov	r10, r30
    7daa:	b1 2c       	mov	r11, r1
    7dac:	0e 94 8a 39 	call	0x7314	; 0x7314 <roll>
    7db0:	04 c0       	rjmp	.+8      	; 0x7dba <calibration+0x3dc>
		   break;
		   
		}
		
		if(Axis==AxisRoll)
    7db2:	f4 e0       	ldi	r31, 0x04	; 4
    7db4:	4f 16       	cp	r4, r31
    7db6:	51 04       	cpc	r5, r1
    7db8:	01 f5       	brne	.+64     	; 0x7dfa <calibration+0x41c>
		{
		 //Modificado por david
		    delay_1s();
    7dba:	0e 94 e1 76 	call	0xedc2	; 0xedc2 <delay_1s>
			delay_1s();
    7dbe:	0e 94 e1 76 	call	0xedc2	; 0xedc2 <delay_1s>
			
		 	
			do 
			{
				PMDGetSignalStatus(&hAxis[Axis], &signal_status);				
    7dc2:	c1 01       	movw	r24, r2
    7dc4:	be 01       	movw	r22, r28
    7dc6:	6f 5f       	subi	r22, 0xFF	; 255
    7dc8:	7f 4f       	sbci	r23, 0xFF	; 255
    7dca:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
			} 
			while ((signal_status & PMDSignalEncoderHomeMask)!=0);
    7dce:	89 81       	ldd	r24, Y+1	; 0x01
    7dd0:	83 fd       	sbrc	r24, 3
    7dd2:	f7 cf       	rjmp	.-18     	; 0x7dc2 <calibration+0x3e4>
			
			//Detener el Eje.(Ya que el Eje Roll no tiene Limites de fin de carrera.
			PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode); 
    7dd4:	c1 01       	movw	r24, r2
    7dd6:	61 e0       	ldi	r22, 0x01	; 1
    7dd8:	70 e0       	ldi	r23, 0x00	; 0
    7dda:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
			PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode); 
    7dde:	84 e9       	ldi	r24, 0x94	; 148
    7de0:	9e e7       	ldi	r25, 0x7E	; 126
    7de2:	61 e0       	ldi	r22, 0x01	; 1
    7de4:	70 e0       	ldi	r23, 0x00	; 0
    7de6:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
			PMDUpdate(&hAxis[Axis]);	
    7dea:	c1 01       	movw	r24, r2
    7dec:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			PMDUpdate(&hAxis[AxisPitch]);			
    7df0:	84 e9       	ldi	r24, 0x94	; 148
    7df2:	9e e7       	ldi	r25, 0x7E	; 126
    7df4:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
    7df8:	2d c0       	rjmp	.+90     	; 0x7e54 <calibration+0x476>
		}
		else
		{
			do 
			{				
				PMDGetSignalStatus(&hAxis[Axis], &signal_status);					
    7dfa:	c1 01       	movw	r24, r2
    7dfc:	be 01       	movw	r22, r28
    7dfe:	6f 5f       	subi	r22, 0xFF	; 255
    7e00:	7f 4f       	sbci	r23, 0xFF	; 255
    7e02:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
				printf("calibration=> El Signal status register del eje %s al moverse en - es %X \n",AxisName(Axis),signal_status);					
    7e06:	c2 01       	movw	r24, r4
    7e08:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    7e0c:	00 d0       	rcall	.+0      	; 0x7e0e <calibration+0x430>
    7e0e:	00 d0       	rcall	.+0      	; 0x7e10 <calibration+0x432>
    7e10:	00 d0       	rcall	.+0      	; 0x7e12 <calibration+0x434>
    7e12:	ed b7       	in	r30, 0x3d	; 61
    7e14:	fe b7       	in	r31, 0x3e	; 62
    7e16:	31 96       	adiw	r30, 0x01	; 1
    7e18:	b3 e9       	ldi	r27, 0x93	; 147
    7e1a:	cb 2e       	mov	r12, r27
    7e1c:	b4 e5       	ldi	r27, 0x54	; 84
    7e1e:	db 2e       	mov	r13, r27
    7e20:	ad b7       	in	r26, 0x3d	; 61
    7e22:	be b7       	in	r27, 0x3e	; 62
    7e24:	12 96       	adiw	r26, 0x02	; 2
    7e26:	dc 92       	st	X, r13
    7e28:	ce 92       	st	-X, r12
    7e2a:	11 97       	sbiw	r26, 0x01	; 1
    7e2c:	93 83       	std	Z+3, r25	; 0x03
    7e2e:	82 83       	std	Z+2, r24	; 0x02
    7e30:	89 81       	ldd	r24, Y+1	; 0x01
    7e32:	9a 81       	ldd	r25, Y+2	; 0x02
    7e34:	95 83       	std	Z+5, r25	; 0x05
    7e36:	84 83       	std	Z+4, r24	; 0x04
    7e38:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			} 
			while ((signal_status & PMDSignalNegativeLimitMask)!=0);
    7e3c:	89 81       	ldd	r24, Y+1	; 0x01
    7e3e:	2d b7       	in	r18, 0x3d	; 61
    7e40:	3e b7       	in	r19, 0x3e	; 62
    7e42:	2a 5f       	subi	r18, 0xFA	; 250
    7e44:	3f 4f       	sbci	r19, 0xFF	; 255
    7e46:	0f b6       	in	r0, 0x3f	; 63
    7e48:	f8 94       	cli
    7e4a:	3e bf       	out	0x3e, r19	; 62
    7e4c:	0f be       	out	0x3f, r0	; 63
    7e4e:	2d bf       	out	0x3d, r18	; 61
    7e50:	85 fd       	sbrc	r24, 5
    7e52:	d3 cf       	rjmp	.-90     	; 0x7dfa <calibration+0x41c>
		}		
		
		// En este punto el Eje se Detiene automaticamente.
		
		//Leer Registro del Encoder
		PMDGetActualPosition(&hAxis[Axis],&read_encoder);
    7e54:	c1 01       	movw	r24, r2
    7e56:	be 01       	movw	r22, r28
    7e58:	6d 5f       	subi	r22, 0xFD	; 253
    7e5a:	7f 4f       	sbci	r23, 0xFF	; 255
    7e5c:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
		printf("calibration=> La Lectura del valor No %d del encoder del eje %s es : %08ld \n ",(2*i+2),AxisName(Axis),read_encoder);
    7e60:	c2 01       	movw	r24, r4
    7e62:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    7e66:	4d b7       	in	r20, 0x3d	; 61
    7e68:	5e b7       	in	r21, 0x3e	; 62
    7e6a:	4a 50       	subi	r20, 0x0A	; 10
    7e6c:	50 40       	sbci	r21, 0x00	; 0
    7e6e:	0f b6       	in	r0, 0x3f	; 63
    7e70:	f8 94       	cli
    7e72:	5e bf       	out	0x3e, r21	; 62
    7e74:	0f be       	out	0x3f, r0	; 63
    7e76:	4d bf       	out	0x3d, r20	; 61
    7e78:	ed b7       	in	r30, 0x3d	; 61
    7e7a:	fe b7       	in	r31, 0x3e	; 62
    7e7c:	31 96       	adiw	r30, 0x01	; 1
    7e7e:	a5 e4       	ldi	r26, 0x45	; 69
    7e80:	ca 2e       	mov	r12, r26
    7e82:	a4 e5       	ldi	r26, 0x54	; 84
    7e84:	da 2e       	mov	r13, r26
    7e86:	ad b7       	in	r26, 0x3d	; 61
    7e88:	be b7       	in	r27, 0x3e	; 62
    7e8a:	12 96       	adiw	r26, 0x02	; 2
    7e8c:	dc 92       	st	X, r13
    7e8e:	ce 92       	st	-X, r12
    7e90:	11 97       	sbiw	r26, 0x01	; 1
    7e92:	eb 88       	ldd	r14, Y+19	; 0x13
    7e94:	fc 88       	ldd	r15, Y+20	; 0x14
    7e96:	f3 82       	std	Z+3, r15	; 0x03
    7e98:	e2 82       	std	Z+2, r14	; 0x02
    7e9a:	95 83       	std	Z+5, r25	; 0x05
    7e9c:	84 83       	std	Z+4, r24	; 0x04
    7e9e:	8b 81       	ldd	r24, Y+3	; 0x03
    7ea0:	9c 81       	ldd	r25, Y+4	; 0x04
    7ea2:	ad 81       	ldd	r26, Y+5	; 0x05
    7ea4:	be 81       	ldd	r27, Y+6	; 0x06
    7ea6:	86 83       	std	Z+6, r24	; 0x06
    7ea8:	97 83       	std	Z+7, r25	; 0x07
    7eaa:	a0 87       	std	Z+8, r26	; 0x08
    7eac:	b1 87       	std	Z+9, r27	; 0x09
    7eae:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		//printf("La Lectura del valor del encoder del eje %s es : %08ld \n ",AxisName(Axis),read_encoder);
		//scanf("%d",&Cont);
		
		//Sacar Maximos y Minimos
		max_read = max(max_read, -read_encoder);
    7eb2:	0b 81       	ldd	r16, Y+3	; 0x03
    7eb4:	1c 81       	ldd	r17, Y+4	; 0x04
    7eb6:	2d 81       	ldd	r18, Y+5	; 0x05
    7eb8:	3e 81       	ldd	r19, Y+6	; 0x06
    7eba:	44 27       	eor	r20, r20
    7ebc:	55 27       	eor	r21, r21
    7ebe:	ba 01       	movw	r22, r20
    7ec0:	40 1b       	sub	r20, r16
    7ec2:	51 0b       	sbc	r21, r17
    7ec4:	62 0b       	sbc	r22, r18
    7ec6:	73 0b       	sbc	r23, r19
    7ec8:	db 01       	movw	r26, r22
    7eca:	ca 01       	movw	r24, r20
    7ecc:	ed b7       	in	r30, 0x3d	; 61
    7ece:	fe b7       	in	r31, 0x3e	; 62
    7ed0:	3a 96       	adiw	r30, 0x0a	; 10
    7ed2:	0f b6       	in	r0, 0x3f	; 63
    7ed4:	f8 94       	cli
    7ed6:	fe bf       	out	0x3e, r31	; 62
    7ed8:	0f be       	out	0x3f, r0	; 63
    7eda:	ed bf       	out	0x3d, r30	; 61
    7edc:	46 15       	cp	r20, r6
    7ede:	57 05       	cpc	r21, r7
    7ee0:	68 05       	cpc	r22, r8
    7ee2:	79 05       	cpc	r23, r9
    7ee4:	14 f4       	brge	.+4      	; 0x7eea <calibration+0x50c>
    7ee6:	d4 01       	movw	r26, r8
    7ee8:	c3 01       	movw	r24, r6
    7eea:	cf 84       	ldd	r12, Y+15	; 0x0f
    7eec:	d8 88       	ldd	r13, Y+16	; 0x10
    7eee:	e9 88       	ldd	r14, Y+17	; 0x11
    7ef0:	fa 88       	ldd	r15, Y+18	; 0x12
    7ef2:	c8 16       	cp	r12, r24
    7ef4:	d9 06       	cpc	r13, r25
    7ef6:	ea 06       	cpc	r14, r26
    7ef8:	fb 06       	cpc	r15, r27
    7efa:	24 f4       	brge	.+8      	; 0x7f04 <calibration+0x526>
    7efc:	8f 87       	std	Y+15, r24	; 0x0f
    7efe:	98 8b       	std	Y+16, r25	; 0x10
    7f00:	a9 8b       	std	Y+17, r26	; 0x11
    7f02:	ba 8b       	std	Y+18, r27	; 0x12
    7f04:	db 01       	movw	r26, r22
    7f06:	ca 01       	movw	r24, r20
    7f08:	64 16       	cp	r6, r20
    7f0a:	75 06       	cpc	r7, r21
    7f0c:	86 06       	cpc	r8, r22
    7f0e:	97 06       	cpc	r9, r23
    7f10:	14 f4       	brge	.+4      	; 0x7f16 <calibration+0x538>
    7f12:	d4 01       	movw	r26, r8
    7f14:	c3 01       	movw	r24, r6
    7f16:	cf 80       	ldd	r12, Y+7	; 0x07
    7f18:	d8 84       	ldd	r13, Y+8	; 0x08
    7f1a:	e9 84       	ldd	r14, Y+9	; 0x09
    7f1c:	fa 84       	ldd	r15, Y+10	; 0x0a
    7f1e:	8c 15       	cp	r24, r12
    7f20:	9d 05       	cpc	r25, r13
    7f22:	ae 05       	cpc	r26, r14
    7f24:	bf 05       	cpc	r27, r15
    7f26:	24 f4       	brge	.+8      	; 0x7f30 <calibration+0x552>
    7f28:	8f 83       	std	Y+7, r24	; 0x07
    7f2a:	98 87       	std	Y+8, r25	; 0x08
    7f2c:	a9 87       	std	Y+9, r26	; 0x09
    7f2e:	ba 87       	std	Y+10, r27	; 0x0a
		//Sacar Maximos y Minimos
		max_read = max(max_read, read_encoder);
		min_read = min(min_read, read_encoder);
		
		//sumar el valor leido
		sum=sum+read_encoder;
    7f30:	60 1a       	sub	r6, r16
    7f32:	71 0a       	sbc	r7, r17
    7f34:	82 0a       	sbc	r8, r18
    7f36:	93 0a       	sbc	r9, r19
		//Sacar Maximos y Minimos
		max_read = max(max_read, -read_encoder);
		min_read = min(min_read, -read_encoder);
		
		//sumar el valor leido
		sum=sum-read_encoder;
    7f38:	8b 85       	ldd	r24, Y+11	; 0x0b
    7f3a:	9c 85       	ldd	r25, Y+12	; 0x0c
    7f3c:	ad 85       	ldd	r26, Y+13	; 0x0d
    7f3e:	be 85       	ldd	r27, Y+14	; 0x0e
    7f40:	86 0d       	add	r24, r6
    7f42:	97 1d       	adc	r25, r7
    7f44:	a8 1d       	adc	r26, r8
    7f46:	b9 1d       	adc	r27, r9
    7f48:	8b 87       	std	Y+11, r24	; 0x0b
    7f4a:	9c 87       	std	Y+12, r25	; 0x0c
    7f4c:	ad 87       	std	Y+13, r26	; 0x0d
    7f4e:	be 87       	std	Y+14, r27	; 0x0e
		
		//Borrar el registro del Encoder
		PMDAdjustActualPosition(&hAxis[Axis],-read_encoder);
    7f50:	c1 01       	movw	r24, r2
    7f52:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>
		
		//Se limpia el Event Status Register, borrando la interrupcion 		
		PMDResetEventStatus(&hAxis[Axis],~PMDEventInNegativeLimitMask);
    7f56:	c1 01       	movw	r24, r2
    7f58:	6f eb       	ldi	r22, 0xBF	; 191
    7f5a:	7f ef       	ldi	r23, 0xFF	; 255
    7f5c:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
		
		//Se habilita el Generador de Trayectoria.
		PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  		
    7f60:	c1 01       	movw	r24, r2
    7f62:	61 e0       	ldi	r22, 0x01	; 1
    7f64:	70 e0       	ldi	r23, 0x00	; 0
    7f66:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
		
		if(Axis==AxisPitch)
    7f6a:	93 e0       	ldi	r25, 0x03	; 3
    7f6c:	49 16       	cp	r4, r25
    7f6e:	51 04       	cpc	r5, r1
    7f70:	61 f4       	brne	.+24     	; 0x7f8a <calibration+0x5ac>
		{
			PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventInPositiveLimitMask);	
    7f72:	84 ef       	ldi	r24, 0xF4	; 244
    7f74:	9e e7       	ldi	r25, 0x7E	; 126
    7f76:	6f ed       	ldi	r22, 0xDF	; 223
    7f78:	7f ef       	ldi	r23, 0xFF	; 255
    7f7a:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 
    7f7e:	84 ef       	ldi	r24, 0xF4	; 244
    7f80:	9e e7       	ldi	r25, 0x7E	; 126
    7f82:	61 e0       	ldi	r22, 0x01	; 1
    7f84:	70 e0       	ldi	r23, 0x00	; 0
    7f86:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
		}
		read_encoder=0;
    7f8a:	1b 82       	std	Y+3, r1	; 0x03
    7f8c:	1c 82       	std	Y+4, r1	; 0x04
    7f8e:	1d 82       	std	Y+5, r1	; 0x05
    7f90:	1e 82       	std	Y+6, r1	; 0x06
    7f92:	ab 89       	ldd	r26, Y+19	; 0x13
    7f94:	bc 89       	ldd	r27, Y+20	; 0x14
    7f96:	12 96       	adiw	r26, 0x02	; 2
    7f98:	bc 8b       	std	Y+20, r27	; 0x14
    7f9a:	ab 8b       	std	Y+19, r26	; 0x13
	sum=0;
	max_read= -INF;
	min_read=  INF;

	
	for (i=0; i<5; i++)
    7f9c:	1c 97       	sbiw	r26, 0x0c	; 12
    7f9e:	09 f0       	breq	.+2      	; 0x7fa2 <calibration+0x5c4>
    7fa0:	63 cd       	rjmp	.-1338   	; 0x7a68 <calibration+0x8a>
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 
		}
		read_encoder=0;
	}
	
	printf("calibration=> Los Valores maximo y minimo son= %08ld y %08ld  \n ",max_read,min_read);
    7fa2:	ed b7       	in	r30, 0x3d	; 61
    7fa4:	fe b7       	in	r31, 0x3e	; 62
    7fa6:	3a 97       	sbiw	r30, 0x0a	; 10
    7fa8:	0f b6       	in	r0, 0x3f	; 63
    7faa:	f8 94       	cli
    7fac:	fe bf       	out	0x3e, r31	; 62
    7fae:	0f be       	out	0x3f, r0	; 63
    7fb0:	ed bf       	out	0x3d, r30	; 61
    7fb2:	31 96       	adiw	r30, 0x01	; 1
    7fb4:	8e ed       	ldi	r24, 0xDE	; 222
    7fb6:	94 e5       	ldi	r25, 0x54	; 84
    7fb8:	ad b7       	in	r26, 0x3d	; 61
    7fba:	be b7       	in	r27, 0x3e	; 62
    7fbc:	12 96       	adiw	r26, 0x02	; 2
    7fbe:	9c 93       	st	X, r25
    7fc0:	8e 93       	st	-X, r24
    7fc2:	11 97       	sbiw	r26, 0x01	; 1
    7fc4:	cf 84       	ldd	r12, Y+15	; 0x0f
    7fc6:	d8 88       	ldd	r13, Y+16	; 0x10
    7fc8:	e9 88       	ldd	r14, Y+17	; 0x11
    7fca:	fa 88       	ldd	r15, Y+18	; 0x12
    7fcc:	c2 82       	std	Z+2, r12	; 0x02
    7fce:	d3 82       	std	Z+3, r13	; 0x03
    7fd0:	e4 82       	std	Z+4, r14	; 0x04
    7fd2:	f5 82       	std	Z+5, r15	; 0x05
    7fd4:	2f 81       	ldd	r18, Y+7	; 0x07
    7fd6:	38 85       	ldd	r19, Y+8	; 0x08
    7fd8:	49 85       	ldd	r20, Y+9	; 0x09
    7fda:	5a 85       	ldd	r21, Y+10	; 0x0a
    7fdc:	26 83       	std	Z+6, r18	; 0x06
    7fde:	37 83       	std	Z+7, r19	; 0x07
    7fe0:	40 87       	std	Z+8, r20	; 0x08
    7fe2:	51 87       	std	Z+9, r21	; 0x09
    7fe4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("calibration=> La sumatoria de los valores leidos es : %08ld \n",sum);
    7fe8:	0f 90       	pop	r0
    7fea:	0f 90       	pop	r0
    7fec:	0f 90       	pop	r0
    7fee:	0f 90       	pop	r0
    7ff0:	8f e1       	ldi	r24, 0x1F	; 31
    7ff2:	95 e5       	ldi	r25, 0x55	; 85
    7ff4:	ad b7       	in	r26, 0x3d	; 61
    7ff6:	be b7       	in	r27, 0x3e	; 62
    7ff8:	12 96       	adiw	r26, 0x02	; 2
    7ffa:	9c 93       	st	X, r25
    7ffc:	8e 93       	st	-X, r24
    7ffe:	11 97       	sbiw	r26, 0x01	; 1
    8000:	cb 84       	ldd	r12, Y+11	; 0x0b
    8002:	dc 84       	ldd	r13, Y+12	; 0x0c
    8004:	ed 84       	ldd	r14, Y+13	; 0x0d
    8006:	fe 84       	ldd	r15, Y+14	; 0x0e
    8008:	13 96       	adiw	r26, 0x03	; 3
    800a:	cd 92       	st	X+, r12
    800c:	dd 92       	st	X+, r13
    800e:	ed 92       	st	X+, r14
    8010:	fc 92       	st	X, r15
    8012:	16 97       	sbiw	r26, 0x06	; 6
    8014:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    8018:	2f 81       	ldd	r18, Y+7	; 0x07
    801a:	38 85       	ldd	r19, Y+8	; 0x08
    801c:	49 85       	ldd	r20, Y+9	; 0x09
    801e:	5a 85       	ldd	r21, Y+10	; 0x0a
    8020:	c2 1a       	sub	r12, r18
    8022:	d3 0a       	sbc	r13, r19
    8024:	e4 0a       	sbc	r14, r20
    8026:	f5 0a       	sbc	r15, r21
    8028:	8f 85       	ldd	r24, Y+15	; 0x0f
    802a:	98 89       	ldd	r25, Y+16	; 0x10
    802c:	a9 89       	ldd	r26, Y+17	; 0x11
    802e:	ba 89       	ldd	r27, Y+18	; 0x12
    8030:	c8 1a       	sub	r12, r24
    8032:	d9 0a       	sbc	r13, r25
    8034:	ea 0a       	sbc	r14, r26
    8036:	fb 0a       	sbc	r15, r27
    8038:	c7 01       	movw	r24, r14
    803a:	b6 01       	movw	r22, r12
    803c:	28 e0       	ldi	r18, 0x08	; 8
    803e:	30 e0       	ldi	r19, 0x00	; 0
    8040:	40 e0       	ldi	r20, 0x00	; 0
    8042:	50 e0       	ldi	r21, 0x00	; 0
    8044:	0e 94 ac 85 	call	0x10b58	; 0x10b58 <__divmodsi4>
    8048:	ca 01       	movw	r24, r20
    804a:	ad b7       	in	r26, 0x3d	; 61
    804c:	be b7       	in	r27, 0x3e	; 62
    804e:	16 96       	adiw	r26, 0x06	; 6
    8050:	0f b6       	in	r0, 0x3f	; 63
    8052:	f8 94       	cli
    8054:	be bf       	out	0x3e, r27	; 62
    8056:	0f be       	out	0x3f, r0	; 63
    8058:	ad bf       	out	0x3d, r26	; 61
	read = (sum-(max_read + min_read))/(2*(i-1));
	
	return read;
}
    805a:	b9 01       	movw	r22, r18
    805c:	64 96       	adiw	r28, 0x14	; 20
    805e:	0f b6       	in	r0, 0x3f	; 63
    8060:	f8 94       	cli
    8062:	de bf       	out	0x3e, r29	; 62
    8064:	0f be       	out	0x3f, r0	; 63
    8066:	cd bf       	out	0x3d, r28	; 61
    8068:	cf 91       	pop	r28
    806a:	df 91       	pop	r29
    806c:	1f 91       	pop	r17
    806e:	0f 91       	pop	r16
    8070:	ff 90       	pop	r15
    8072:	ef 90       	pop	r14
    8074:	df 90       	pop	r13
    8076:	cf 90       	pop	r12
    8078:	bf 90       	pop	r11
    807a:	af 90       	pop	r10
    807c:	9f 90       	pop	r9
    807e:	8f 90       	pop	r8
    8080:	7f 90       	pop	r7
    8082:	6f 90       	pop	r6
    8084:	5f 90       	pop	r5
    8086:	4f 90       	pop	r4
    8088:	3f 90       	pop	r3
    808a:	2f 90       	pop	r2
    808c:	08 95       	ret

0000808e <mov_correlacionado_HOME>:
//Al mover el EJe1 se tiene que mover proporcionalmente el Eje2
void mov_correlacionado_HOME(tAxis Eje2, PMDint32 Posicion,
										 PMDint32 Velocity_Eje1, PMDint32 *Velocity_Eje2,
						                 PMDuint32 Acceleration_Eje1, PMDuint32 *Acceleration_Eje2, 
										 double FACTOR_CORRELACION)
{
    808e:	4f 92       	push	r4
    8090:	5f 92       	push	r5
    8092:	6f 92       	push	r6
    8094:	7f 92       	push	r7
    8096:	8f 92       	push	r8
    8098:	9f 92       	push	r9
    809a:	af 92       	push	r10
    809c:	bf 92       	push	r11
    809e:	cf 92       	push	r12
    80a0:	df 92       	push	r13
    80a2:	ef 92       	push	r14
    80a4:	ff 92       	push	r15
    80a6:	0f 93       	push	r16
    80a8:	1f 93       	push	r17
    80aa:	df 93       	push	r29
    80ac:	cf 93       	push	r28
    80ae:	00 d0       	rcall	.+0      	; 0x80b0 <mov_correlacionado_HOME+0x22>
    80b0:	00 d0       	rcall	.+0      	; 0x80b2 <mov_correlacionado_HOME+0x24>
    80b2:	cd b7       	in	r28, 0x3d	; 61
    80b4:	de b7       	in	r29, 0x3e	; 62
    80b6:	2c 01       	movw	r4, r24
    80b8:	49 83       	std	Y+1, r20	; 0x01
    80ba:	5a 83       	std	Y+2, r21	; 0x02
    80bc:	6b 83       	std	Y+3, r22	; 0x03
    80be:	7c 83       	std	Y+4, r23	; 0x04
    80c0:	c9 01       	movw	r24, r18
    80c2:	b8 01       	movw	r22, r16
    80c4:	37 01       	movw	r6, r14
    80c6:	ef 88       	ldd	r14, Y+23	; 0x17
    80c8:	f8 8c       	ldd	r15, Y+24	; 0x18
    80ca:	09 8d       	ldd	r16, Y+25	; 0x19
    80cc:	1a 8d       	ldd	r17, Y+26	; 0x1a

	
	
	/*La Velocidad del Eje2 es igual a la del Registro del Eje2 + la velocidad del Eje1 X factor de correlacion*/
	*Velocity_Eje2 = (Velocity_Eje1*FACTOR_CORRELACION);
    80ce:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    80d2:	a8 01       	movw	r20, r16
    80d4:	97 01       	movw	r18, r14
    80d6:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    80da:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    80de:	d3 01       	movw	r26, r6
    80e0:	6d 93       	st	X+, r22
    80e2:	7d 93       	st	X+, r23
    80e4:	8d 93       	st	X+, r24
    80e6:	9c 93       	st	X, r25
    80e8:	13 97       	sbiw	r26, 0x03	; 3
	/*La Aceleracion del Eje2 es igual a la del Registro  del Eje 2 + la aceleracion del Eje1 X factor de correlacion*/
	*Acceleration_Eje2 =  (Acceleration_Eje1*FACTOR_CORRELACION);
    80ea:	c6 01       	movw	r24, r12
    80ec:	b5 01       	movw	r22, r10
    80ee:	0e 94 02 84 	call	0x10804	; 0x10804 <__floatunsisf>
    80f2:	a8 01       	movw	r20, r16
    80f4:	97 01       	movw	r18, r14
    80f6:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    80fa:	0e 94 d6 83 	call	0x107ac	; 0x107ac <__fixunssfsi>
    80fe:	f4 01       	movw	r30, r8
    8100:	60 83       	st	Z, r22
    8102:	71 83       	std	Z+1, r23	; 0x01
    8104:	82 83       	std	Z+2, r24	; 0x02
    8106:	93 83       	std	Z+3, r25	; 0x03
	
	/*Imprimo para debug*/ 	 
	printf("mov_correlacionado_HOME=> Velocidad Eje %s = %ld\n",AxisName(Eje2),*Velocity_Eje2);	
    8108:	c2 01       	movw	r24, r4
    810a:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    810e:	2d b7       	in	r18, 0x3d	; 61
    8110:	3e b7       	in	r19, 0x3e	; 62
    8112:	28 50       	subi	r18, 0x08	; 8
    8114:	30 40       	sbci	r19, 0x00	; 0
    8116:	0f b6       	in	r0, 0x3f	; 63
    8118:	f8 94       	cli
    811a:	3e bf       	out	0x3e, r19	; 62
    811c:	0f be       	out	0x3f, r0	; 63
    811e:	2d bf       	out	0x3d, r18	; 61
    8120:	ed b7       	in	r30, 0x3d	; 61
    8122:	fe b7       	in	r31, 0x3e	; 62
    8124:	31 96       	adiw	r30, 0x01	; 1
    8126:	2d e5       	ldi	r18, 0x5D	; 93
    8128:	35 e5       	ldi	r19, 0x55	; 85
    812a:	ad b7       	in	r26, 0x3d	; 61
    812c:	be b7       	in	r27, 0x3e	; 62
    812e:	12 96       	adiw	r26, 0x02	; 2
    8130:	3c 93       	st	X, r19
    8132:	2e 93       	st	-X, r18
    8134:	11 97       	sbiw	r26, 0x01	; 1
    8136:	93 83       	std	Z+3, r25	; 0x03
    8138:	82 83       	std	Z+2, r24	; 0x02
    813a:	d3 01       	movw	r26, r6
    813c:	2d 91       	ld	r18, X+
    813e:	3d 91       	ld	r19, X+
    8140:	4d 91       	ld	r20, X+
    8142:	5c 91       	ld	r21, X
    8144:	24 83       	std	Z+4, r18	; 0x04
    8146:	35 83       	std	Z+5, r19	; 0x05
    8148:	46 83       	std	Z+6, r20	; 0x06
    814a:	57 83       	std	Z+7, r21	; 0x07
    814c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("mov_correlacionado_HOME=> Aceleracion Eje %s = %ld\n",AxisName(Eje2),*Acceleration_Eje2);	
    8150:	ed b7       	in	r30, 0x3d	; 61
    8152:	fe b7       	in	r31, 0x3e	; 62
    8154:	38 96       	adiw	r30, 0x08	; 8
    8156:	0f b6       	in	r0, 0x3f	; 63
    8158:	f8 94       	cli
    815a:	fe bf       	out	0x3e, r31	; 62
    815c:	0f be       	out	0x3f, r0	; 63
    815e:	ed bf       	out	0x3d, r30	; 61
    8160:	c2 01       	movw	r24, r4
    8162:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    8166:	2d b7       	in	r18, 0x3d	; 61
    8168:	3e b7       	in	r19, 0x3e	; 62
    816a:	28 50       	subi	r18, 0x08	; 8
    816c:	30 40       	sbci	r19, 0x00	; 0
    816e:	0f b6       	in	r0, 0x3f	; 63
    8170:	f8 94       	cli
    8172:	3e bf       	out	0x3e, r19	; 62
    8174:	0f be       	out	0x3f, r0	; 63
    8176:	2d bf       	out	0x3d, r18	; 61
    8178:	ed b7       	in	r30, 0x3d	; 61
    817a:	fe b7       	in	r31, 0x3e	; 62
    817c:	31 96       	adiw	r30, 0x01	; 1
    817e:	2f e8       	ldi	r18, 0x8F	; 143
    8180:	35 e5       	ldi	r19, 0x55	; 85
    8182:	ad b7       	in	r26, 0x3d	; 61
    8184:	be b7       	in	r27, 0x3e	; 62
    8186:	12 96       	adiw	r26, 0x02	; 2
    8188:	3c 93       	st	X, r19
    818a:	2e 93       	st	-X, r18
    818c:	11 97       	sbiw	r26, 0x01	; 1
    818e:	93 83       	std	Z+3, r25	; 0x03
    8190:	82 83       	std	Z+2, r24	; 0x02
    8192:	d4 01       	movw	r26, r8
    8194:	2d 91       	ld	r18, X+
    8196:	3d 91       	ld	r19, X+
    8198:	4d 91       	ld	r20, X+
    819a:	5c 91       	ld	r21, X
    819c:	24 83       	std	Z+4, r18	; 0x04
    819e:	35 83       	std	Z+5, r19	; 0x05
    81a0:	46 83       	std	Z+6, r20	; 0x06
    81a2:	57 83       	std	Z+7, r21	; 0x07
    81a4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	
	
	/*Muevo el Eje2 con esos datos */
	if (Eje2==AxisPitch)
    81a8:	ed b7       	in	r30, 0x3d	; 61
    81aa:	fe b7       	in	r31, 0x3e	; 62
    81ac:	38 96       	adiw	r30, 0x08	; 8
    81ae:	0f b6       	in	r0, 0x3f	; 63
    81b0:	f8 94       	cli
    81b2:	fe bf       	out	0x3e, r31	; 62
    81b4:	0f be       	out	0x3f, r0	; 63
    81b6:	ed bf       	out	0x3d, r30	; 61
    81b8:	d3 01       	movw	r26, r6
    81ba:	0d 91       	ld	r16, X+
    81bc:	1d 91       	ld	r17, X+
    81be:	2d 91       	ld	r18, X+
    81c0:	3c 91       	ld	r19, X
    81c2:	f4 01       	movw	r30, r8
    81c4:	c0 80       	ld	r12, Z
    81c6:	d1 80       	ldd	r13, Z+1	; 0x01
    81c8:	e2 80       	ldd	r14, Z+2	; 0x02
    81ca:	f3 80       	ldd	r15, Z+3	; 0x03
    81cc:	f3 e0       	ldi	r31, 0x03	; 3
    81ce:	4f 16       	cp	r4, r31
    81d0:	51 04       	cpc	r5, r1
    81d2:	91 f4       	brne	.+36     	; 0x81f8 <mov_correlacionado_HOME+0x16a>
	{		
		pitch(Posicion,*Velocity_Eje2,*Acceleration_Eje2,no_update,EN_CALIBRACION_PROCESOHOME);
    81d4:	69 81       	ldd	r22, Y+1	; 0x01
    81d6:	7a 81       	ldd	r23, Y+2	; 0x02
    81d8:	8b 81       	ldd	r24, Y+3	; 0x03
    81da:	9c 81       	ldd	r25, Y+4	; 0x04
    81dc:	a9 01       	movw	r20, r18
    81de:	98 01       	movw	r18, r16
    81e0:	87 01       	movw	r16, r14
    81e2:	76 01       	movw	r14, r12
    81e4:	af ee       	ldi	r26, 0xEF	; 239
    81e6:	ca 2e       	mov	r12, r26
    81e8:	af ef       	ldi	r26, 0xFF	; 255
    81ea:	da 2e       	mov	r13, r26
    81ec:	f3 e0       	ldi	r31, 0x03	; 3
    81ee:	af 2e       	mov	r10, r31
    81f0:	b1 2c       	mov	r11, r1
    81f2:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <pitch>
    81f6:	0b c0       	rjmp	.+22     	; 0x820e <mov_correlacionado_HOME+0x180>
	}
	else
	{
		mov_axis(Eje2,Posicion,*Velocity_Eje2,*Acceleration_Eje2,no_update);	
    81f8:	c2 01       	movw	r24, r4
    81fa:	49 81       	ldd	r20, Y+1	; 0x01
    81fc:	5a 81       	ldd	r21, Y+2	; 0x02
    81fe:	6b 81       	ldd	r22, Y+3	; 0x03
    8200:	7c 81       	ldd	r23, Y+4	; 0x04
    8202:	ef ee       	ldi	r30, 0xEF	; 239
    8204:	ae 2e       	mov	r10, r30
    8206:	ef ef       	ldi	r30, 0xFF	; 255
    8208:	be 2e       	mov	r11, r30
    820a:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
	}			
		
}
    820e:	0f 90       	pop	r0
    8210:	0f 90       	pop	r0
    8212:	0f 90       	pop	r0
    8214:	0f 90       	pop	r0
    8216:	cf 91       	pop	r28
    8218:	df 91       	pop	r29
    821a:	1f 91       	pop	r17
    821c:	0f 91       	pop	r16
    821e:	ff 90       	pop	r15
    8220:	ef 90       	pop	r14
    8222:	df 90       	pop	r13
    8224:	cf 90       	pop	r12
    8226:	bf 90       	pop	r11
    8228:	af 90       	pop	r10
    822a:	9f 90       	pop	r9
    822c:	8f 90       	pop	r8
    822e:	7f 90       	pop	r7
    8230:	6f 90       	pop	r6
    8232:	5f 90       	pop	r5
    8234:	4f 90       	pop	r4
    8236:	08 95       	ret

00008238 <search_home_positive>:
	
	

}
void search_home_positive(int16 Axis,PMDint32 *home,PMDint32 *posicion,PMDint16 rangos)
{
    8238:	2f 92       	push	r2
    823a:	3f 92       	push	r3
    823c:	4f 92       	push	r4
    823e:	5f 92       	push	r5
    8240:	6f 92       	push	r6
    8242:	7f 92       	push	r7
    8244:	8f 92       	push	r8
    8246:	9f 92       	push	r9
    8248:	af 92       	push	r10
    824a:	bf 92       	push	r11
    824c:	cf 92       	push	r12
    824e:	df 92       	push	r13
    8250:	ef 92       	push	r14
    8252:	ff 92       	push	r15
    8254:	0f 93       	push	r16
    8256:	1f 93       	push	r17
    8258:	df 93       	push	r29
    825a:	cf 93       	push	r28
    825c:	cd b7       	in	r28, 0x3d	; 61
    825e:	de b7       	in	r29, 0x3e	; 62
    8260:	6c 97       	sbiw	r28, 0x1c	; 28
    8262:	0f b6       	in	r0, 0x3f	; 63
    8264:	f8 94       	cli
    8266:	de bf       	out	0x3e, r29	; 62
    8268:	0f be       	out	0x3f, r0	; 63
    826a:	cd bf       	out	0x3d, r28	; 61
    826c:	3c 01       	movw	r6, r24
    826e:	7a 8f       	std	Y+26, r23	; 0x1a
    8270:	69 8f       	std	Y+25, r22	; 0x19
    8272:	5c 8f       	std	Y+28, r21	; 0x1c
    8274:	4b 8f       	std	Y+27, r20	; 0x1b
    8276:	19 01       	movw	r2, r18
	find_home_out=1;
	
	

	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    8278:	80 e6       	ldi	r24, 0x60	; 96
    827a:	90 e0       	ldi	r25, 0x00	; 0
    827c:	68 9e       	mul	r6, r24
    827e:	20 01       	movw	r4, r0
    8280:	69 9e       	mul	r6, r25
    8282:	50 0c       	add	r5, r0
    8284:	78 9e       	mul	r7, r24
    8286:	50 0c       	add	r5, r0
    8288:	11 24       	eor	r1, r1
    828a:	84 e7       	ldi	r24, 0x74	; 116
    828c:	9d e7       	ldi	r25, 0x7D	; 125
    828e:	48 0e       	add	r4, r24
    8290:	59 1e       	adc	r5, r25
    8292:	f3 e0       	ldi	r31, 0x03	; 3
    8294:	8f 2e       	mov	r8, r31
    8296:	91 2c       	mov	r9, r1
    8298:	8c 0e       	add	r8, r28
    829a:	9d 1e       	adc	r9, r29
    829c:	c2 01       	movw	r24, r4
    829e:	b4 01       	movw	r22, r8
    82a0:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
	printf("search_home_positive=> HostIOError = %x para el eje %s\n ",test,AxisName(Axis));
    82a4:	0b 81       	ldd	r16, Y+3	; 0x03
    82a6:	1c 81       	ldd	r17, Y+4	; 0x04
    82a8:	c3 01       	movw	r24, r6
    82aa:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    82ae:	00 d0       	rcall	.+0      	; 0x82b0 <search_home_positive+0x78>
    82b0:	00 d0       	rcall	.+0      	; 0x82b2 <search_home_positive+0x7a>
    82b2:	00 d0       	rcall	.+0      	; 0x82b4 <search_home_positive+0x7c>
    82b4:	ed b7       	in	r30, 0x3d	; 61
    82b6:	fe b7       	in	r31, 0x3e	; 62
    82b8:	31 96       	adiw	r30, 0x01	; 1
    82ba:	23 ec       	ldi	r18, 0xC3	; 195
    82bc:	35 e5       	ldi	r19, 0x55	; 85
    82be:	ad b7       	in	r26, 0x3d	; 61
    82c0:	be b7       	in	r27, 0x3e	; 62
    82c2:	12 96       	adiw	r26, 0x02	; 2
    82c4:	3c 93       	st	X, r19
    82c6:	2e 93       	st	-X, r18
    82c8:	11 97       	sbiw	r26, 0x01	; 1
    82ca:	13 83       	std	Z+3, r17	; 0x03
    82cc:	02 83       	std	Z+2, r16	; 0x02
    82ce:	95 83       	std	Z+5, r25	; 0x05
    82d0:	84 83       	std	Z+4, r24	; 0x04
    82d2:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	// hay que mover el motor en la direccion contraria
	//Por ejemplo, situacion de error 
	//En search_home_positive estoy moviendo el hombro
	//Por casualidad el codo o pitch esta tocando el interuptor positivo
	//por lo tanto antes de mover nada hay que desactivarlos.
	No_limit_switch(Axis);
    82d6:	ed b7       	in	r30, 0x3d	; 61
    82d8:	fe b7       	in	r31, 0x3e	; 62
    82da:	36 96       	adiw	r30, 0x06	; 6
    82dc:	0f b6       	in	r0, 0x3f	; 63
    82de:	f8 94       	cli
    82e0:	fe bf       	out	0x3e, r31	; 62
    82e2:	0f be       	out	0x3f, r0	; 63
    82e4:	ed bf       	out	0x3d, r30	; 61
    82e6:	c3 01       	movw	r24, r6
    82e8:	0e 94 4e 34 	call	0x689c	; 0x689c <No_limit_switch>
	

	PMDGetHostIOError(&hAxis[Axis], &test);
    82ec:	c2 01       	movw	r24, r4
    82ee:	b4 01       	movw	r22, r8
    82f0:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
	//Limpia el BiT de Position Capture Indicator en el Status Register
	PMDResetEventStatus(&hAxis[Axis],~PMDEventCaptureReceivedMask);	
    82f4:	c2 01       	movw	r24, r4
    82f6:	67 ef       	ldi	r22, 0xF7	; 247
    82f8:	7f ef       	ldi	r23, 0xFF	; 255
    82fa:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
	//La senal de HOME sera utilizada como Disparo para la Captura de la Posicion
	PMDSetCaptureSource(&hAxis[Axis],PMDCaptureSourceHome);
    82fe:	c2 01       	movw	r24, r4
    8300:	61 e0       	ldi	r22, 0x01	; 1
    8302:	70 e0       	ldi	r23, 0x00	; 0
    8304:	0e 94 95 63 	call	0xc72a	; 0xc72a <PMDSetCaptureSource>
	//Leyendo el registro de Captura de Posicion Causa "rearmar" 
	//el disparador con el fin de permitir mas capturas.
	PMDGetCaptureValue(&hAxis[Axis],&temp); 
    8308:	c2 01       	movw	r24, r4
    830a:	be 01       	movw	r22, r28
    830c:	6b 5f       	subi	r22, 0xFB	; 251
    830e:	7f 4f       	sbci	r23, 0xFF	; 255
    8310:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <PMDGetCaptureValue>
	

	#ifdef DEBUGROBOTICS_HOME
	printf("search_home_positive=> Ejecutado No_limit_switch\n");
    8314:	8c ef       	ldi	r24, 0xFC	; 252
    8316:	95 e5       	ldi	r25, 0x55	; 85
    8318:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	printf("search_home_positive=> Busqueda home en dir Posi. del eje %s.\n ",AxisName(Axis));
    831c:	c3 01       	movw	r24, r6
    831e:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    8322:	00 d0       	rcall	.+0      	; 0x8324 <search_home_positive+0xec>
    8324:	00 d0       	rcall	.+0      	; 0x8326 <search_home_positive+0xee>
    8326:	2d e2       	ldi	r18, 0x2D	; 45
    8328:	36 e5       	ldi	r19, 0x56	; 86
    832a:	ad b7       	in	r26, 0x3d	; 61
    832c:	be b7       	in	r27, 0x3e	; 62
    832e:	12 96       	adiw	r26, 0x02	; 2
    8330:	3c 93       	st	X, r19
    8332:	2e 93       	st	-X, r18
    8334:	11 97       	sbiw	r26, 0x01	; 1
    8336:	14 96       	adiw	r26, 0x04	; 4
    8338:	9c 93       	st	X, r25
    833a:	8e 93       	st	-X, r24
    833c:	13 97       	sbiw	r26, 0x03	; 3
    833e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	#endif

	switch (Axis)
    8342:	0f 90       	pop	r0
    8344:	0f 90       	pop	r0
    8346:	0f 90       	pop	r0
    8348:	0f 90       	pop	r0
    834a:	b2 e0       	ldi	r27, 0x02	; 2
    834c:	6b 16       	cp	r6, r27
    834e:	71 04       	cpc	r7, r1
    8350:	09 f4       	brne	.+2      	; 0x8354 <search_home_positive+0x11c>
    8352:	bd c0       	rjmp	.+378    	; 0x84ce <search_home_positive+0x296>
    8354:	e3 e0       	ldi	r30, 0x03	; 3
    8356:	6e 16       	cp	r6, r30
    8358:	71 04       	cpc	r7, r1
    835a:	34 f4       	brge	.+12     	; 0x8368 <search_home_positive+0x130>
    835c:	f1 e0       	ldi	r31, 0x01	; 1
    835e:	6f 16       	cp	r6, r31
    8360:	71 04       	cpc	r7, r1
    8362:	09 f0       	breq	.+2      	; 0x8366 <search_home_positive+0x12e>
    8364:	9f c1       	rjmp	.+830    	; 0x86a4 <search_home_positive+0x46c>
    8366:	0b c0       	rjmp	.+22     	; 0x837e <search_home_positive+0x146>
    8368:	83 e0       	ldi	r24, 0x03	; 3
    836a:	68 16       	cp	r6, r24
    836c:	71 04       	cpc	r7, r1
    836e:	09 f4       	brne	.+2      	; 0x8372 <search_home_positive+0x13a>
    8370:	2b c1       	rjmp	.+598    	; 0x85c8 <search_home_positive+0x390>
    8372:	94 e0       	ldi	r25, 0x04	; 4
    8374:	69 16       	cp	r6, r25
    8376:	71 04       	cpc	r7, r1
    8378:	09 f0       	breq	.+2      	; 0x837c <search_home_positive+0x144>
    837a:	94 c1       	rjmp	.+808    	; 0x86a4 <search_home_positive+0x46c>
    837c:	5a c1       	rjmp	.+692    	; 0x8632 <search_home_positive+0x3fa>
	{
		case (AxisShoulder):
		{
			//No codo depende de nadie va directo...  
			//(Siempre entra aqui cuando se usa con una trayectoria )..
			mov_axis(Axis,INF, 
    837e:	00 91 14 7e 	lds	r16, 0x7E14
    8382:	10 91 15 7e 	lds	r17, 0x7E15
    8386:	20 91 16 7e 	lds	r18, 0x7E16
    838a:	30 91 17 7e 	lds	r19, 0x7E17
    838e:	c0 90 18 7e 	lds	r12, 0x7E18
    8392:	d0 90 19 7e 	lds	r13, 0x7E19
    8396:	e0 90 1a 7e 	lds	r14, 0x7E1A
    839a:	f0 90 1b 7e 	lds	r15, 0x7E1B
    839e:	81 e0       	ldi	r24, 0x01	; 1
    83a0:	90 e0       	ldi	r25, 0x00	; 0
    83a2:	4f ef       	ldi	r20, 0xFF	; 255
    83a4:	5f ef       	ldi	r21, 0xFF	; 255
    83a6:	6f ef       	ldi	r22, 0xFF	; 255
    83a8:	7f e7       	ldi	r23, 0x7F	; 127
    83aa:	ef ee       	ldi	r30, 0xEF	; 239
    83ac:	ae 2e       	mov	r10, r30
    83ae:	ef ef       	ldi	r30, 0xFF	; 255
    83b0:	be 2e       	mov	r11, r30
    83b2:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
			hAxis[Axis].axisSettings.homeVelocity*CORRELACION_HOMBRO_CODO*CORRELACION_CODO_PITCH,
			100,
			no_update,EN_CALIBRACION_PROCESOHOME );*/
			//Configurando los registros de codo, codo esta invertido invertido.
			
			mov_correlacionado_HOME(AxisElbow,INF,
    83b6:	00 d0       	rcall	.+0      	; 0x83b8 <search_home_positive+0x180>
    83b8:	00 d0       	rcall	.+0      	; 0x83ba <search_home_positive+0x182>
    83ba:	00 91 14 7e 	lds	r16, 0x7E14
    83be:	10 91 15 7e 	lds	r17, 0x7E15
    83c2:	20 91 16 7e 	lds	r18, 0x7E16
    83c6:	30 91 17 7e 	lds	r19, 0x7E17
    83ca:	a0 90 18 7e 	lds	r10, 0x7E18
    83ce:	b0 90 19 7e 	lds	r11, 0x7E19
    83d2:	c0 90 1a 7e 	lds	r12, 0x7E1A
    83d6:	d0 90 1b 7e 	lds	r13, 0x7E1B
    83da:	8d e1       	ldi	r24, 0x1D	; 29
    83dc:	9a e5       	ldi	r25, 0x5A	; 90
    83de:	a4 e5       	ldi	r26, 0x54	; 84
    83e0:	bf e3       	ldi	r27, 0x3F	; 63
    83e2:	ed b7       	in	r30, 0x3d	; 61
    83e4:	fe b7       	in	r31, 0x3e	; 62
    83e6:	81 83       	std	Z+1, r24	; 0x01
    83e8:	92 83       	std	Z+2, r25	; 0x02
    83ea:	a3 83       	std	Z+3, r26	; 0x03
    83ec:	b4 83       	std	Z+4, r27	; 0x04
    83ee:	82 e0       	ldi	r24, 0x02	; 2
    83f0:	90 e0       	ldi	r25, 0x00	; 0
    83f2:	4f ef       	ldi	r20, 0xFF	; 255
    83f4:	5f ef       	ldi	r21, 0xFF	; 255
    83f6:	6f ef       	ldi	r22, 0xFF	; 255
    83f8:	7f e7       	ldi	r23, 0x7F	; 127
    83fa:	b9 e0       	ldi	r27, 0x09	; 9
    83fc:	eb 2e       	mov	r14, r27
    83fe:	f1 2c       	mov	r15, r1
    8400:	ec 0e       	add	r14, r28
    8402:	fd 1e       	adc	r15, r29
    8404:	a1 e1       	ldi	r26, 0x11	; 17
    8406:	8a 2e       	mov	r8, r26
    8408:	91 2c       	mov	r9, r1
    840a:	8c 0e       	add	r8, r28
    840c:	9d 1e       	adc	r9, r29
    840e:	0e 94 47 40 	call	0x808e	; 0x808e <mov_correlacionado_HOME>
												hAxis[Axis].axisSettings.homeVelocity,
												&Velocidad_eje2_temp,hAxis[Axis].axisSettings.homeAcceleration,
												&Aceleracion_eje2_temp,CORRELACION_HOMBRO_CODO);		
			//Configurando los registros de pitch, el pitch esta en el mismo sentido que el codo.
			mov_correlacionado_HOME(AxisPitch,INF,
    8412:	09 85       	ldd	r16, Y+9	; 0x09
    8414:	1a 85       	ldd	r17, Y+10	; 0x0a
    8416:	2b 85       	ldd	r18, Y+11	; 0x0b
    8418:	3c 85       	ldd	r19, Y+12	; 0x0c
    841a:	a9 88       	ldd	r10, Y+17	; 0x11
    841c:	ba 88       	ldd	r11, Y+18	; 0x12
    841e:	cb 88       	ldd	r12, Y+19	; 0x13
    8420:	dc 88       	ldd	r13, Y+20	; 0x14
    8422:	89 ec       	ldi	r24, 0xC9	; 201
    8424:	9e e8       	ldi	r25, 0x8E	; 142
    8426:	ad e8       	ldi	r26, 0x8D	; 141
    8428:	bc e3       	ldi	r27, 0x3C	; 60
    842a:	ed b7       	in	r30, 0x3d	; 61
    842c:	fe b7       	in	r31, 0x3e	; 62
    842e:	81 83       	std	Z+1, r24	; 0x01
    8430:	92 83       	std	Z+2, r25	; 0x02
    8432:	a3 83       	std	Z+3, r26	; 0x03
    8434:	b4 83       	std	Z+4, r27	; 0x04
    8436:	83 e0       	ldi	r24, 0x03	; 3
    8438:	90 e0       	ldi	r25, 0x00	; 0
    843a:	4f ef       	ldi	r20, 0xFF	; 255
    843c:	5f ef       	ldi	r21, 0xFF	; 255
    843e:	6f ef       	ldi	r22, 0xFF	; 255
    8440:	7f e7       	ldi	r23, 0x7F	; 127
    8442:	fd e0       	ldi	r31, 0x0D	; 13
    8444:	ef 2e       	mov	r14, r31
    8446:	f1 2c       	mov	r15, r1
    8448:	ec 0e       	add	r14, r28
    844a:	fd 1e       	adc	r15, r29
    844c:	e5 e1       	ldi	r30, 0x15	; 21
    844e:	8e 2e       	mov	r8, r30
    8450:	91 2c       	mov	r9, r1
    8452:	8c 0e       	add	r8, r28
    8454:	9d 1e       	adc	r9, r29
    8456:	0e 94 47 40 	call	0x808e	; 0x808e <mov_correlacionado_HOME>
												&Velocidad_final_pitch,Aceleracion_eje2_temp,
												&Aceleracion_final_pitch,
												CORRELACION_CODO_PITCH);
			
	
			printf("search_home_positive=>  Update AxisShoulder \n ");
    845a:	0f 90       	pop	r0
    845c:	0f 90       	pop	r0
    845e:	8d e6       	ldi	r24, 0x6D	; 109
    8460:	96 e5       	ldi	r25, 0x56	; 86
    8462:	ad b7       	in	r26, 0x3d	; 61
    8464:	be b7       	in	r27, 0x3e	; 62
    8466:	12 96       	adiw	r26, 0x02	; 2
    8468:	9c 93       	st	X, r25
    846a:	8e 93       	st	-X, r24
    846c:	11 97       	sbiw	r26, 0x01	; 1
    846e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisShoulder]);
    8472:	0f 90       	pop	r0
    8474:	0f 90       	pop	r0
    8476:	84 ed       	ldi	r24, 0xD4	; 212
    8478:	9d e7       	ldi	r25, 0x7D	; 125
    847a:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			printf("search_home_positive=>  Update AxisElbow \n ");
    847e:	00 d0       	rcall	.+0      	; 0x8480 <search_home_positive+0x248>
    8480:	8c e9       	ldi	r24, 0x9C	; 156
    8482:	96 e5       	ldi	r25, 0x56	; 86
    8484:	ed b7       	in	r30, 0x3d	; 61
    8486:	fe b7       	in	r31, 0x3e	; 62
    8488:	92 83       	std	Z+2, r25	; 0x02
    848a:	81 83       	std	Z+1, r24	; 0x01
    848c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisElbow]);	
    8490:	0f 90       	pop	r0
    8492:	0f 90       	pop	r0
    8494:	84 e3       	ldi	r24, 0x34	; 52
    8496:	9e e7       	ldi	r25, 0x7E	; 126
    8498:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			printf("search_home_positive=>  Update AxisPitch \n ");
    849c:	00 d0       	rcall	.+0      	; 0x849e <search_home_positive+0x266>
    849e:	88 ec       	ldi	r24, 0xC8	; 200
    84a0:	96 e5       	ldi	r25, 0x56	; 86
    84a2:	ad b7       	in	r26, 0x3d	; 61
    84a4:	be b7       	in	r27, 0x3e	; 62
    84a6:	12 96       	adiw	r26, 0x02	; 2
    84a8:	9c 93       	st	X, r25
    84aa:	8e 93       	st	-X, r24
    84ac:	11 97       	sbiw	r26, 0x01	; 1
    84ae:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisPitch]);	
    84b2:	0f 90       	pop	r0
    84b4:	0f 90       	pop	r0
    84b6:	84 e9       	ldi	r24, 0x94	; 148
    84b8:	9e e7       	ldi	r25, 0x7E	; 126
    84ba:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			printf("search_home_positive=>  Update AxisRoll \n ");
    84be:	00 d0       	rcall	.+0      	; 0x84c0 <search_home_positive+0x288>
    84c0:	84 ef       	ldi	r24, 0xF4	; 244
    84c2:	96 e5       	ldi	r25, 0x56	; 86
    84c4:	ed b7       	in	r30, 0x3d	; 61
    84c6:	fe b7       	in	r31, 0x3e	; 62
    84c8:	92 83       	std	Z+2, r25	; 0x02
    84ca:	81 83       	std	Z+1, r24	; 0x01
    84cc:	74 c0       	rjmp	.+232    	; 0x85b6 <search_home_positive+0x37e>
			PMDUpdate(&hAxis[AxisRoll]);
		}	
		break;
		case (AxisElbow):
		{
			mov_axis(Axis,INF, 
    84ce:	00 91 74 7e 	lds	r16, 0x7E74
    84d2:	10 91 75 7e 	lds	r17, 0x7E75
    84d6:	20 91 76 7e 	lds	r18, 0x7E76
    84da:	30 91 77 7e 	lds	r19, 0x7E77
    84de:	c0 90 78 7e 	lds	r12, 0x7E78
    84e2:	d0 90 79 7e 	lds	r13, 0x7E79
    84e6:	e0 90 7a 7e 	lds	r14, 0x7E7A
    84ea:	f0 90 7b 7e 	lds	r15, 0x7E7B
    84ee:	82 e0       	ldi	r24, 0x02	; 2
    84f0:	90 e0       	ldi	r25, 0x00	; 0
    84f2:	4f ef       	ldi	r20, 0xFF	; 255
    84f4:	5f ef       	ldi	r21, 0xFF	; 255
    84f6:	6f ef       	ldi	r22, 0xFF	; 255
    84f8:	7f e7       	ldi	r23, 0x7F	; 127
    84fa:	bf ee       	ldi	r27, 0xEF	; 239
    84fc:	ab 2e       	mov	r10, r27
    84fe:	bf ef       	ldi	r27, 0xFF	; 255
    8500:	bb 2e       	mov	r11, r27
    8502:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
			hAxis[Axis].axisSettings.homeVelocity*0.0166,
			300,
			no_update,EN_CALIBRACION_PROCESOHOME );
			*/
			
			mov_correlacionado_HOME(AxisPitch,INF,
    8506:	00 d0       	rcall	.+0      	; 0x8508 <search_home_positive+0x2d0>
    8508:	00 d0       	rcall	.+0      	; 0x850a <search_home_positive+0x2d2>
    850a:	00 91 74 7e 	lds	r16, 0x7E74
    850e:	10 91 75 7e 	lds	r17, 0x7E75
    8512:	20 91 76 7e 	lds	r18, 0x7E76
    8516:	30 91 77 7e 	lds	r19, 0x7E77
    851a:	a0 90 78 7e 	lds	r10, 0x7E78
    851e:	b0 90 79 7e 	lds	r11, 0x7E79
    8522:	c0 90 7a 7e 	lds	r12, 0x7E7A
    8526:	d0 90 7b 7e 	lds	r13, 0x7E7B
    852a:	89 ec       	ldi	r24, 0xC9	; 201
    852c:	9e e8       	ldi	r25, 0x8E	; 142
    852e:	ad e8       	ldi	r26, 0x8D	; 141
    8530:	bc e3       	ldi	r27, 0x3C	; 60
    8532:	ed b7       	in	r30, 0x3d	; 61
    8534:	fe b7       	in	r31, 0x3e	; 62
    8536:	81 83       	std	Z+1, r24	; 0x01
    8538:	92 83       	std	Z+2, r25	; 0x02
    853a:	a3 83       	std	Z+3, r26	; 0x03
    853c:	b4 83       	std	Z+4, r27	; 0x04
    853e:	83 e0       	ldi	r24, 0x03	; 3
    8540:	90 e0       	ldi	r25, 0x00	; 0
    8542:	4f ef       	ldi	r20, 0xFF	; 255
    8544:	5f ef       	ldi	r21, 0xFF	; 255
    8546:	6f ef       	ldi	r22, 0xFF	; 255
    8548:	7f e7       	ldi	r23, 0x7F	; 127
    854a:	ad e0       	ldi	r26, 0x0D	; 13
    854c:	ea 2e       	mov	r14, r26
    854e:	f1 2c       	mov	r15, r1
    8550:	ec 0e       	add	r14, r28
    8552:	fd 1e       	adc	r15, r29
    8554:	f5 e1       	ldi	r31, 0x15	; 21
    8556:	8f 2e       	mov	r8, r31
    8558:	91 2c       	mov	r9, r1
    855a:	8c 0e       	add	r8, r28
    855c:	9d 1e       	adc	r9, r29
    855e:	0e 94 47 40 	call	0x808e	; 0x808e <mov_correlacionado_HOME>
												&Velocidad_final_pitch,hAxis[Axis].axisSettings.homeAcceleration,
												&Aceleracion_final_pitch,
												CORRELACION_CODO_PITCH);
			
	
			printf("search_home_positive=>  Update AxisElbow \n ");
    8562:	0f 90       	pop	r0
    8564:	0f 90       	pop	r0
    8566:	8c e9       	ldi	r24, 0x9C	; 156
    8568:	96 e5       	ldi	r25, 0x56	; 86
    856a:	ad b7       	in	r26, 0x3d	; 61
    856c:	be b7       	in	r27, 0x3e	; 62
    856e:	12 96       	adiw	r26, 0x02	; 2
    8570:	9c 93       	st	X, r25
    8572:	8e 93       	st	-X, r24
    8574:	11 97       	sbiw	r26, 0x01	; 1
    8576:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisElbow]);	
    857a:	0f 90       	pop	r0
    857c:	0f 90       	pop	r0
    857e:	84 e3       	ldi	r24, 0x34	; 52
    8580:	9e e7       	ldi	r25, 0x7E	; 126
    8582:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			printf("search_home_positive=>  Update AxisPitch \n ");
    8586:	00 d0       	rcall	.+0      	; 0x8588 <search_home_positive+0x350>
    8588:	88 ec       	ldi	r24, 0xC8	; 200
    858a:	96 e5       	ldi	r25, 0x56	; 86
    858c:	ed b7       	in	r30, 0x3d	; 61
    858e:	fe b7       	in	r31, 0x3e	; 62
    8590:	92 83       	std	Z+2, r25	; 0x02
    8592:	81 83       	std	Z+1, r24	; 0x01
    8594:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisPitch]);
    8598:	0f 90       	pop	r0
    859a:	0f 90       	pop	r0
    859c:	84 e9       	ldi	r24, 0x94	; 148
    859e:	9e e7       	ldi	r25, 0x7E	; 126
    85a0:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			printf("search_home_positive=>  Update AxisRoll \n ");
    85a4:	00 d0       	rcall	.+0      	; 0x85a6 <search_home_positive+0x36e>
    85a6:	84 ef       	ldi	r24, 0xF4	; 244
    85a8:	96 e5       	ldi	r25, 0x56	; 86
    85aa:	ad b7       	in	r26, 0x3d	; 61
    85ac:	be b7       	in	r27, 0x3e	; 62
    85ae:	12 96       	adiw	r26, 0x02	; 2
    85b0:	9c 93       	st	X, r25
    85b2:	8e 93       	st	-X, r24
    85b4:	11 97       	sbiw	r26, 0x01	; 1
    85b6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisRoll]);
    85ba:	0f 90       	pop	r0
    85bc:	0f 90       	pop	r0
    85be:	84 ef       	ldi	r24, 0xF4	; 244
    85c0:	9e e7       	ldi	r25, 0x7E	; 126
    85c2:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
    85c6:	8e c0       	rjmp	.+284    	; 0x86e4 <search_home_positive+0x4ac>
		}
		break;
		case (AxisPitch):
		{
			pitch(INF, (hAxis[Axis].axisSettings.homeVelocity)/2,
    85c8:	60 91 d4 7e 	lds	r22, 0x7ED4
    85cc:	70 91 d5 7e 	lds	r23, 0x7ED5
    85d0:	80 91 d6 7e 	lds	r24, 0x7ED6
    85d4:	90 91 d7 7e 	lds	r25, 0x7ED7
    85d8:	22 e0       	ldi	r18, 0x02	; 2
    85da:	30 e0       	ldi	r19, 0x00	; 0
    85dc:	40 e0       	ldi	r20, 0x00	; 0
    85de:	50 e0       	ldi	r21, 0x00	; 0
    85e0:	0e 94 ac 85 	call	0x10b58	; 0x10b58 <__divmodsi4>
    85e4:	e0 90 d8 7e 	lds	r14, 0x7ED8
    85e8:	f0 90 d9 7e 	lds	r15, 0x7ED9
    85ec:	00 91 da 7e 	lds	r16, 0x7EDA
    85f0:	10 91 db 7e 	lds	r17, 0x7EDB
    85f4:	6f ef       	ldi	r22, 0xFF	; 255
    85f6:	7f ef       	ldi	r23, 0xFF	; 255
    85f8:	8f ef       	ldi	r24, 0xFF	; 255
    85fa:	9f e7       	ldi	r25, 0x7F	; 127
    85fc:	e0 ef       	ldi	r30, 0xF0	; 240
    85fe:	ce 2e       	mov	r12, r30
    8600:	ef ef       	ldi	r30, 0xFF	; 255
    8602:	de 2e       	mov	r13, r30
    8604:	b4 e0       	ldi	r27, 0x04	; 4
    8606:	ab 2e       	mov	r10, r27
    8608:	b1 2c       	mov	r11, r1
    860a:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <pitch>
			hAxis[Axis].axisSettings.homeAcceleration, update,INICIANDO_HOME_PITCH_ROLL);
			#ifdef DEBUGROBOTICS_HOME
			PMDGetHostIOError(&hAxis[AxisRoll], &test);
    860e:	84 ef       	ldi	r24, 0xF4	; 244
    8610:	9e e7       	ldi	r25, 0x7E	; 126
    8612:	b4 01       	movw	r22, r8
    8614:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
			printf("search_home_positive=> HostIOError = %x del eje ROLL despues del update.\n ",test);
    8618:	00 d0       	rcall	.+0      	; 0x861a <search_home_positive+0x3e2>
    861a:	00 d0       	rcall	.+0      	; 0x861c <search_home_positive+0x3e4>
    861c:	8f e1       	ldi	r24, 0x1F	; 31
    861e:	97 e5       	ldi	r25, 0x57	; 87
    8620:	ed b7       	in	r30, 0x3d	; 61
    8622:	fe b7       	in	r31, 0x3e	; 62
    8624:	92 83       	std	Z+2, r25	; 0x02
    8626:	81 83       	std	Z+1, r24	; 0x01
    8628:	8b 81       	ldd	r24, Y+3	; 0x03
    862a:	9c 81       	ldd	r25, Y+4	; 0x04
    862c:	94 83       	std	Z+4, r25	; 0x04
    862e:	83 83       	std	Z+3, r24	; 0x03
    8630:	32 c0       	rjmp	.+100    	; 0x8696 <search_home_positive+0x45e>
			#endif
		}
	    break;
		
		case (AxisRoll):		
			roll(INF, hAxis[Axis].axisSettings.homeVelocity,
    8632:	20 91 34 7f 	lds	r18, 0x7F34
    8636:	30 91 35 7f 	lds	r19, 0x7F35
    863a:	40 91 36 7f 	lds	r20, 0x7F36
    863e:	50 91 37 7f 	lds	r21, 0x7F37
    8642:	e0 90 38 7f 	lds	r14, 0x7F38
    8646:	f0 90 39 7f 	lds	r15, 0x7F39
    864a:	00 91 3a 7f 	lds	r16, 0x7F3A
    864e:	10 91 3b 7f 	lds	r17, 0x7F3B
    8652:	6f ef       	ldi	r22, 0xFF	; 255
    8654:	7f ef       	ldi	r23, 0xFF	; 255
    8656:	8f ef       	ldi	r24, 0xFF	; 255
    8658:	9f e7       	ldi	r25, 0x7F	; 127
    865a:	a0 ef       	ldi	r26, 0xF0	; 240
    865c:	ca 2e       	mov	r12, r26
    865e:	af ef       	ldi	r26, 0xFF	; 255
    8660:	da 2e       	mov	r13, r26
    8662:	f4 e0       	ldi	r31, 0x04	; 4
    8664:	af 2e       	mov	r10, r31
    8666:	b1 2c       	mov	r11, r1
    8668:	0e 94 8a 39 	call	0x7314	; 0x7314 <roll>
			hAxis[Axis].axisSettings.homeAcceleration, update,INICIANDO_HOME_PITCH_ROLL );
			#ifdef DEBUGROBOTICS_HOME
			PMDGetHostIOError(&hAxis[AxisRoll], &test);
    866c:	84 ef       	ldi	r24, 0xF4	; 244
    866e:	9e e7       	ldi	r25, 0x7E	; 126
    8670:	b4 01       	movw	r22, r8
    8672:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
			printf("search_home_positive=> HostIOError = %x del eje pitch despues del update.\n ",test);
    8676:	00 d0       	rcall	.+0      	; 0x8678 <search_home_positive+0x440>
    8678:	00 d0       	rcall	.+0      	; 0x867a <search_home_positive+0x442>
    867a:	8a e6       	ldi	r24, 0x6A	; 106
    867c:	97 e5       	ldi	r25, 0x57	; 87
    867e:	ad b7       	in	r26, 0x3d	; 61
    8680:	be b7       	in	r27, 0x3e	; 62
    8682:	12 96       	adiw	r26, 0x02	; 2
    8684:	9c 93       	st	X, r25
    8686:	8e 93       	st	-X, r24
    8688:	11 97       	sbiw	r26, 0x01	; 1
    868a:	8b 81       	ldd	r24, Y+3	; 0x03
    868c:	9c 81       	ldd	r25, Y+4	; 0x04
    868e:	14 96       	adiw	r26, 0x04	; 4
    8690:	9c 93       	st	X, r25
    8692:	8e 93       	st	-X, r24
    8694:	13 97       	sbiw	r26, 0x03	; 3
    8696:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    869a:	0f 90       	pop	r0
    869c:	0f 90       	pop	r0
    869e:	0f 90       	pop	r0
    86a0:	0f 90       	pop	r0
    86a2:	20 c0       	rjmp	.+64     	; 0x86e4 <search_home_positive+0x4ac>
			#endif
	
	    break;
		
		default:
			mov_axis(Axis,INF, hAxis[Axis].axisSettings.homeVelocity,
    86a4:	80 e6       	ldi	r24, 0x60	; 96
    86a6:	90 e0       	ldi	r25, 0x00	; 0
    86a8:	68 9e       	mul	r6, r24
    86aa:	f0 01       	movw	r30, r0
    86ac:	69 9e       	mul	r6, r25
    86ae:	f0 0d       	add	r31, r0
    86b0:	78 9e       	mul	r7, r24
    86b2:	f0 0d       	add	r31, r0
    86b4:	11 24       	eor	r1, r1
    86b6:	ec 58       	subi	r30, 0x8C	; 140
    86b8:	f2 48       	sbci	r31, 0x82	; 130
    86ba:	e0 5c       	subi	r30, 0xC0	; 192
    86bc:	ff 4f       	sbci	r31, 0xFF	; 255
    86be:	01 91       	ld	r16, Z+
    86c0:	11 91       	ld	r17, Z+
    86c2:	21 91       	ld	r18, Z+
    86c4:	31 91       	ld	r19, Z+
    86c6:	c0 80       	ld	r12, Z
    86c8:	d1 80       	ldd	r13, Z+1	; 0x01
    86ca:	e2 80       	ldd	r14, Z+2	; 0x02
    86cc:	f3 80       	ldd	r15, Z+3	; 0x03
    86ce:	c3 01       	movw	r24, r6
    86d0:	4f ef       	ldi	r20, 0xFF	; 255
    86d2:	5f ef       	ldi	r21, 0xFF	; 255
    86d4:	6f ef       	ldi	r22, 0xFF	; 255
    86d6:	7f e7       	ldi	r23, 0x7F	; 127
    86d8:	e0 ef       	ldi	r30, 0xF0	; 240
    86da:	ae 2e       	mov	r10, r30
    86dc:	ef ef       	ldi	r30, 0xFF	; 255
    86de:	be 2e       	mov	r11, r30
    86e0:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
	}
		
	

	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    86e4:	c2 01       	movw	r24, r4
    86e6:	be 01       	movw	r22, r28
    86e8:	6d 5f       	subi	r22, 0xFD	; 253
    86ea:	7f 4f       	sbci	r23, 0xFF	; 255
    86ec:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
	printf("search_home_positive=> HostIOError = %x del eje %s despues del Update.\n ",test,AxisName(Axis));
    86f0:	0b 81       	ldd	r16, Y+3	; 0x03
    86f2:	1c 81       	ldd	r17, Y+4	; 0x04
    86f4:	c3 01       	movw	r24, r6
    86f6:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    86fa:	00 d0       	rcall	.+0      	; 0x86fc <search_home_positive+0x4c4>
    86fc:	00 d0       	rcall	.+0      	; 0x86fe <search_home_positive+0x4c6>
    86fe:	00 d0       	rcall	.+0      	; 0x8700 <search_home_positive+0x4c8>
    8700:	ed b7       	in	r30, 0x3d	; 61
    8702:	fe b7       	in	r31, 0x3e	; 62
    8704:	31 96       	adiw	r30, 0x01	; 1
    8706:	26 eb       	ldi	r18, 0xB6	; 182
    8708:	37 e5       	ldi	r19, 0x57	; 87
    870a:	ad b7       	in	r26, 0x3d	; 61
    870c:	be b7       	in	r27, 0x3e	; 62
    870e:	12 96       	adiw	r26, 0x02	; 2
    8710:	3c 93       	st	X, r19
    8712:	2e 93       	st	-X, r18
    8714:	11 97       	sbiw	r26, 0x01	; 1
    8716:	13 83       	std	Z+3, r17	; 0x03
    8718:	02 83       	std	Z+2, r16	; 0x02
    871a:	95 83       	std	Z+5, r25	; 0x05
    871c:	84 83       	std	Z+4, r24	; 0x04
    871e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("search_home_positive=> Iniciando busqueda de home en el sentido positivo.\n");	
    8722:	ed b7       	in	r30, 0x3d	; 61
    8724:	fe b7       	in	r31, 0x3e	; 62
    8726:	36 96       	adiw	r30, 0x06	; 6
    8728:	0f b6       	in	r0, 0x3f	; 63
    872a:	f8 94       	cli
    872c:	fe bf       	out	0x3e, r31	; 62
    872e:	0f be       	out	0x3f, r0	; 63
    8730:	ed bf       	out	0x3d, r30	; 61
    8732:	8f ef       	ldi	r24, 0xFF	; 255
    8734:	97 e5       	ldi	r25, 0x57	; 87
    8736:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	#endif	
	
	
	do 
	{ 
		PMDGetEventStatus(&hAxis[Axis],&status);
    873a:	4e 01       	movw	r8, r28
    873c:	08 94       	sec
    873e:	81 1c       	adc	r8, r1
    8740:	91 1c       	adc	r9, r1
		
		if((status & PMDEventCaptureReceivedMask) != 0) 
		{   
			#ifdef DEBUGROBOTICS_HOME
			printf("search_home_positive=>  Captura de HOME realizada. \n ");			
    8742:	b9 e4       	ldi	r27, 0x49	; 73
    8744:	ab 2e       	mov	r10, r27
    8746:	b8 e5       	ldi	r27, 0x58	; 88
    8748:	bb 2e       	mov	r11, r27
						PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode ); 
						PMDUpdate(&hAxis[AxisPitch]);
					case (AxisPitch):
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
						PMDUpdate(&hAxis[AxisRoll]);
				    break;
    874a:	08 94       	sec
    874c:	61 1c       	adc	r6, r1
    874e:	71 1c       	adc	r7, r1
    8750:	80 e6       	ldi	r24, 0x60	; 96
    8752:	90 e0       	ldi	r25, 0x00	; 0
    8754:	68 9e       	mul	r6, r24
    8756:	60 01       	movw	r12, r0
    8758:	69 9e       	mul	r6, r25
    875a:	d0 0c       	add	r13, r0
    875c:	78 9e       	mul	r7, r24
    875e:	d0 0c       	add	r13, r0
    8760:	11 24       	eor	r1, r1
    8762:	08 94       	sec
    8764:	61 08       	sbc	r6, r1
    8766:	71 08       	sbc	r7, r1
    8768:	84 e7       	ldi	r24, 0x74	; 116
    876a:	9d e7       	ldi	r25, 0x7D	; 125
    876c:	c8 0e       	add	r12, r24
    876e:	d9 1e       	adc	r13, r25
	#endif	
	
	
	do 
	{ 
		PMDGetEventStatus(&hAxis[Axis],&status);
    8770:	c2 01       	movw	r24, r4
    8772:	b4 01       	movw	r22, r8
    8774:	0e 94 a7 61 	call	0xc34e	; 0xc34e <PMDGetEventStatus>
		
		if((status & PMDEventCaptureReceivedMask) != 0) 
    8778:	89 81       	ldd	r24, Y+1	; 0x01
    877a:	83 ff       	sbrs	r24, 3
    877c:	5f c0       	rjmp	.+190    	; 0x883c <search_home_positive+0x604>
		{   
			#ifdef DEBUGROBOTICS_HOME
			printf("search_home_positive=>  Captura de HOME realizada. \n ");			
    877e:	00 d0       	rcall	.+0      	; 0x8780 <search_home_positive+0x548>
    8780:	ad b7       	in	r26, 0x3d	; 61
    8782:	be b7       	in	r27, 0x3e	; 62
    8784:	12 96       	adiw	r26, 0x02	; 2
    8786:	bc 92       	st	X, r11
    8788:	ae 92       	st	-X, r10
    878a:	11 97       	sbiw	r26, 0x01	; 1
    878c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			#endif
			PMDGetCaptureValue(&hAxis[Axis],home);
    8790:	0f 90       	pop	r0
    8792:	0f 90       	pop	r0
    8794:	c2 01       	movw	r24, r4
    8796:	69 8d       	ldd	r22, Y+25	; 0x19
    8798:	7a 8d       	ldd	r23, Y+26	; 0x1a
    879a:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <PMDGetCaptureValue>
			PMDResetEventStatus(&hAxis[Axis],~PMDEventCaptureReceivedMask);
    879e:	c2 01       	movw	r24, r4
    87a0:	67 ef       	ldi	r22, 0xF7	; 247
    87a2:	7f ef       	ldi	r23, 0xFF	; 255
    87a4:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
			
			if(rangos==FALSE) //se Hace Caputura de HOME y se quiere detener el motor
    87a8:	21 14       	cp	r2, r1
    87aa:	31 04       	cpc	r3, r1
    87ac:	09 f0       	breq	.+2      	; 0x87b0 <search_home_positive+0x578>
    87ae:	46 c0       	rjmp	.+140    	; 0x883c <search_home_positive+0x604>
				//del eje donde se esta buscando HOME.
				//Ejempo si estoy buscando el home de hombro hay que detener codo y pitch
				//Ya que Home se detiene automaticamente. 
				//Tambien hay que tomar en cuenta los casos especiales de Cintura y roll 
				//Que no se detiene al llegar el home.
				switch (Axis)
    87b0:	b3 e0       	ldi	r27, 0x03	; 3
    87b2:	6b 16       	cp	r6, r27
    87b4:	71 04       	cpc	r7, r1
    87b6:	01 f1       	breq	.+64     	; 0x87f8 <search_home_positive+0x5c0>
    87b8:	e4 e0       	ldi	r30, 0x04	; 4
    87ba:	6e 16       	cp	r6, r30
    87bc:	71 04       	cpc	r7, r1
    87be:	51 f0       	breq	.+20     	; 0x87d4 <search_home_positive+0x59c>
    87c0:	61 14       	cp	r6, r1
    87c2:	71 04       	cpc	r7, r1
    87c4:	31 f5       	brne	.+76     	; 0x8812 <search_home_positive+0x5da>
				{
				    case (AxisWaist):
						PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode ); 
    87c6:	c2 01       	movw	r24, r4
    87c8:	61 e0       	ldi	r22, 0x01	; 1
    87ca:	70 e0       	ldi	r23, 0x00	; 0
    87cc:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
						PMDUpdate(&hAxis[Axis]);
    87d0:	c2 01       	movw	r24, r4
    87d2:	1a c0       	rjmp	.+52     	; 0x8808 <search_home_positive+0x5d0>
				    break;
					case (AxisRoll):
						PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode ); 
    87d4:	c2 01       	movw	r24, r4
    87d6:	61 e0       	ldi	r22, 0x01	; 1
    87d8:	70 e0       	ldi	r23, 0x00	; 0
    87da:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
						PMDUpdate(&hAxis[Axis]);
    87de:	c2 01       	movw	r24, r4
    87e0:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
						PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode ); 
    87e4:	84 e9       	ldi	r24, 0x94	; 148
    87e6:	9e e7       	ldi	r25, 0x7E	; 126
    87e8:	61 e0       	ldi	r22, 0x01	; 1
    87ea:	70 e0       	ldi	r23, 0x00	; 0
    87ec:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
						PMDUpdate(&hAxis[AxisPitch]);
    87f0:	84 e9       	ldi	r24, 0x94	; 148
    87f2:	9e e7       	ldi	r25, 0x7E	; 126
    87f4:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
					case (AxisPitch):
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
    87f8:	84 ef       	ldi	r24, 0xF4	; 244
    87fa:	9e e7       	ldi	r25, 0x7E	; 126
    87fc:	61 e0       	ldi	r22, 0x01	; 1
    87fe:	70 e0       	ldi	r23, 0x00	; 0
    8800:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
						PMDUpdate(&hAxis[AxisRoll]);
    8804:	84 ef       	ldi	r24, 0xF4	; 244
    8806:	9e e7       	ldi	r25, 0x7E	; 126
    8808:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
    880c:	20 e0       	ldi	r18, 0x00	; 0
    880e:	30 e0       	ldi	r19, 0x00	; 0
    8810:	17 c0       	rjmp	.+46     	; 0x8840 <search_home_positive+0x608>
				    break;
    8812:	86 01       	movw	r16, r12
    8814:	73 01       	movw	r14, r6
    8816:	0a c0       	rjmp	.+20     	; 0x882c <search_home_positive+0x5f4>
				    default:
						
				    	for(Axis_Update=Axis+1; Axis_Update < DOF; Axis_Update++) 
						{ 
							PMDSetStopMode(&hAxis[Axis_Update], PMDAbruptStopMode ); 
    8818:	c8 01       	movw	r24, r16
    881a:	61 e0       	ldi	r22, 0x01	; 1
    881c:	70 e0       	ldi	r23, 0x00	; 0
    881e:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
							PMDUpdate(&hAxis[Axis_Update]);
    8822:	c8 01       	movw	r24, r16
    8824:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
    8828:	00 5a       	subi	r16, 0xA0	; 160
    882a:	1f 4f       	sbci	r17, 0xFF	; 255
    882c:	08 94       	sec
    882e:	e1 1c       	adc	r14, r1
    8830:	f1 1c       	adc	r15, r1
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
						PMDUpdate(&hAxis[AxisRoll]);
				    break;
				    default:
						
				    	for(Axis_Update=Axis+1; Axis_Update < DOF; Axis_Update++) 
    8832:	f5 e0       	ldi	r31, 0x05	; 5
    8834:	ef 16       	cp	r14, r31
    8836:	f1 04       	cpc	r15, r1
    8838:	7c f3       	brlt	.-34     	; 0x8818 <search_home_positive+0x5e0>
    883a:	e8 cf       	rjmp	.-48     	; 0x880c <search_home_positive+0x5d4>
    883c:	21 e0       	ldi	r18, 0x01	; 1
    883e:	30 e0       	ldi	r19, 0x00	; 0
		#ifdef DEBUGROBOTICS_HOME
		//	printf("Moviendo en direccion positiva. \n ");
		//	printf("El Event status register del eje %s es %X \n",AxisName(Axis),status);	
		#endif
	} 
	while (((status & PMDEventInPositiveLimitMask) ==0) && (find_home_out==1));
    8840:	89 81       	ldd	r24, Y+1	; 0x01
    8842:	85 fd       	sbrc	r24, 5
    8844:	04 c0       	rjmp	.+8      	; 0x884e <search_home_positive+0x616>
    8846:	21 30       	cpi	r18, 0x01	; 1
    8848:	31 05       	cpc	r19, r1
    884a:	09 f4       	brne	.+2      	; 0x884e <search_home_positive+0x616>
    884c:	91 cf       	rjmp	.-222    	; 0x8770 <search_home_positive+0x538>

	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    884e:	c2 01       	movw	r24, r4
    8850:	be 01       	movw	r22, r28
    8852:	6d 5f       	subi	r22, 0xFD	; 253
    8854:	7f 4f       	sbci	r23, 0xFF	; 255
    8856:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
	printf("search_home_positive=> Error en el eje %s despues del movimiento %x\n ",AxisName(Axis),test);
    885a:	c3 01       	movw	r24, r6
    885c:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    8860:	00 d0       	rcall	.+0      	; 0x8862 <search_home_positive+0x62a>
    8862:	00 d0       	rcall	.+0      	; 0x8864 <search_home_positive+0x62c>
    8864:	00 d0       	rcall	.+0      	; 0x8866 <search_home_positive+0x62e>
    8866:	ed b7       	in	r30, 0x3d	; 61
    8868:	fe b7       	in	r31, 0x3e	; 62
    886a:	31 96       	adiw	r30, 0x01	; 1
    886c:	2f e7       	ldi	r18, 0x7F	; 127
    886e:	38 e5       	ldi	r19, 0x58	; 88
    8870:	ad b7       	in	r26, 0x3d	; 61
    8872:	be b7       	in	r27, 0x3e	; 62
    8874:	12 96       	adiw	r26, 0x02	; 2
    8876:	3c 93       	st	X, r19
    8878:	2e 93       	st	-X, r18
    887a:	11 97       	sbiw	r26, 0x01	; 1
    887c:	93 83       	std	Z+3, r25	; 0x03
    887e:	82 83       	std	Z+2, r24	; 0x02
    8880:	8b 81       	ldd	r24, Y+3	; 0x03
    8882:	9c 81       	ldd	r25, Y+4	; 0x04
    8884:	95 83       	std	Z+5, r25	; 0x05
    8886:	84 83       	std	Z+4, r24	; 0x04
    8888:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	PMDGetEventStatus(&hAxis[Axis],&status);  
    888c:	ed b7       	in	r30, 0x3d	; 61
    888e:	fe b7       	in	r31, 0x3e	; 62
    8890:	36 96       	adiw	r30, 0x06	; 6
    8892:	0f b6       	in	r0, 0x3f	; 63
    8894:	f8 94       	cli
    8896:	fe bf       	out	0x3e, r31	; 62
    8898:	0f be       	out	0x3f, r0	; 63
    889a:	ed bf       	out	0x3d, r30	; 61
    889c:	c2 01       	movw	r24, r4
    889e:	8e 01       	movw	r16, r28
    88a0:	0f 5f       	subi	r16, 0xFF	; 255
    88a2:	1f 4f       	sbci	r17, 0xFF	; 255
    88a4:	b8 01       	movw	r22, r16
    88a6:	0e 94 a7 61 	call	0xc34e	; 0xc34e <PMDGetEventStatus>
	printf("search_home_positive=> El Event status register antes de limpiar del eje %s es %X \n",AxisName(Axis),status);	
    88aa:	c3 01       	movw	r24, r6
    88ac:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    88b0:	00 d0       	rcall	.+0      	; 0x88b2 <search_home_positive+0x67a>
    88b2:	00 d0       	rcall	.+0      	; 0x88b4 <search_home_positive+0x67c>
    88b4:	00 d0       	rcall	.+0      	; 0x88b6 <search_home_positive+0x67e>
    88b6:	ed b7       	in	r30, 0x3d	; 61
    88b8:	fe b7       	in	r31, 0x3e	; 62
    88ba:	31 96       	adiw	r30, 0x01	; 1
    88bc:	25 ec       	ldi	r18, 0xC5	; 197
    88be:	38 e5       	ldi	r19, 0x58	; 88
    88c0:	ad b7       	in	r26, 0x3d	; 61
    88c2:	be b7       	in	r27, 0x3e	; 62
    88c4:	12 96       	adiw	r26, 0x02	; 2
    88c6:	3c 93       	st	X, r19
    88c8:	2e 93       	st	-X, r18
    88ca:	11 97       	sbiw	r26, 0x01	; 1
    88cc:	93 83       	std	Z+3, r25	; 0x03
    88ce:	82 83       	std	Z+2, r24	; 0x02
    88d0:	89 81       	ldd	r24, Y+1	; 0x01
    88d2:	9a 81       	ldd	r25, Y+2	; 0x02
    88d4:	95 83       	std	Z+5, r25	; 0x05
    88d6:	84 83       	std	Z+4, r24	; 0x04
    88d8:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	#endif	

	
	/*Se limpia el Event Status Register, borrando las interrupciones generadas: Evento de Limite
	Positivo y Fin de movimiento*/	
	Reset_Even_Status_Register();
    88dc:	ed b7       	in	r30, 0x3d	; 61
    88de:	fe b7       	in	r31, 0x3e	; 62
    88e0:	36 96       	adiw	r30, 0x06	; 6
    88e2:	0f b6       	in	r0, 0x3f	; 63
    88e4:	f8 94       	cli
    88e6:	fe bf       	out	0x3e, r31	; 62
    88e8:	0f be       	out	0x3f, r0	; 63
    88ea:	ed bf       	out	0x3d, r30	; 61
    88ec:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <Reset_Even_Status_Register>
	
	
	/* Se obtiene la posicion Actual del encoder*/
	PMDGetActualPosition(&hAxis[Axis],posicion);
    88f0:	c2 01       	movw	r24, r4
    88f2:	6b 8d       	ldd	r22, Y+27	; 0x1b
    88f4:	7c 8d       	ldd	r23, Y+28	; 0x1c
    88f6:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetEventStatus(&hAxis[Axis],&status);  
    88fa:	c2 01       	movw	r24, r4
    88fc:	b8 01       	movw	r22, r16
    88fe:	0e 94 a7 61 	call	0xc34e	; 0xc34e <PMDGetEventStatus>
	printf("search_home_positive=> El Event status register del eje %s despues de limpiar es %X \n ",AxisName(Axis),status);	
    8902:	c3 01       	movw	r24, r6
    8904:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    8908:	00 d0       	rcall	.+0      	; 0x890a <search_home_positive+0x6d2>
    890a:	00 d0       	rcall	.+0      	; 0x890c <search_home_positive+0x6d4>
    890c:	00 d0       	rcall	.+0      	; 0x890e <search_home_positive+0x6d6>
    890e:	ed b7       	in	r30, 0x3d	; 61
    8910:	fe b7       	in	r31, 0x3e	; 62
    8912:	31 96       	adiw	r30, 0x01	; 1
    8914:	29 e1       	ldi	r18, 0x19	; 25
    8916:	39 e5       	ldi	r19, 0x59	; 89
    8918:	ad b7       	in	r26, 0x3d	; 61
    891a:	be b7       	in	r27, 0x3e	; 62
    891c:	12 96       	adiw	r26, 0x02	; 2
    891e:	3c 93       	st	X, r19
    8920:	2e 93       	st	-X, r18
    8922:	11 97       	sbiw	r26, 0x01	; 1
    8924:	93 83       	std	Z+3, r25	; 0x03
    8926:	82 83       	std	Z+2, r24	; 0x02
    8928:	89 81       	ldd	r24, Y+1	; 0x01
    892a:	9a 81       	ldd	r25, Y+2	; 0x02
    892c:	95 83       	std	Z+5, r25	; 0x05
    892e:	84 83       	std	Z+4, r24	; 0x04
    8930:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    8934:	ed b7       	in	r30, 0x3d	; 61
    8936:	fe b7       	in	r31, 0x3e	; 62
    8938:	36 96       	adiw	r30, 0x06	; 6
    893a:	0f b6       	in	r0, 0x3f	; 63
    893c:	f8 94       	cli
    893e:	fe bf       	out	0x3e, r31	; 62
    8940:	0f be       	out	0x3f, r0	; 63
    8942:	ed bf       	out	0x3d, r30	; 61
	#endif
}
    8944:	6c 96       	adiw	r28, 0x1c	; 28
    8946:	0f b6       	in	r0, 0x3f	; 63
    8948:	f8 94       	cli
    894a:	de bf       	out	0x3e, r29	; 62
    894c:	0f be       	out	0x3f, r0	; 63
    894e:	cd bf       	out	0x3d, r28	; 61
    8950:	cf 91       	pop	r28
    8952:	df 91       	pop	r29
    8954:	1f 91       	pop	r17
    8956:	0f 91       	pop	r16
    8958:	ff 90       	pop	r15
    895a:	ef 90       	pop	r14
    895c:	df 90       	pop	r13
    895e:	cf 90       	pop	r12
    8960:	bf 90       	pop	r11
    8962:	af 90       	pop	r10
    8964:	9f 90       	pop	r9
    8966:	8f 90       	pop	r8
    8968:	7f 90       	pop	r7
    896a:	6f 90       	pop	r6
    896c:	5f 90       	pop	r5
    896e:	4f 90       	pop	r4
    8970:	3f 90       	pop	r3
    8972:	2f 90       	pop	r2
    8974:	08 95       	ret

00008976 <search_home_negative>:



/**********************************************************************************************************************/
void search_home_negative(int16 Axis,PMDint32 *home,PMDint32 *posicion,PMDint16 rangos)
{
    8976:	2f 92       	push	r2
    8978:	3f 92       	push	r3
    897a:	4f 92       	push	r4
    897c:	5f 92       	push	r5
    897e:	6f 92       	push	r6
    8980:	7f 92       	push	r7
    8982:	8f 92       	push	r8
    8984:	9f 92       	push	r9
    8986:	af 92       	push	r10
    8988:	bf 92       	push	r11
    898a:	cf 92       	push	r12
    898c:	df 92       	push	r13
    898e:	ef 92       	push	r14
    8990:	ff 92       	push	r15
    8992:	0f 93       	push	r16
    8994:	1f 93       	push	r17
    8996:	df 93       	push	r29
    8998:	cf 93       	push	r28
    899a:	cd b7       	in	r28, 0x3d	; 61
    899c:	de b7       	in	r29, 0x3e	; 62
    899e:	6c 97       	sbiw	r28, 0x1c	; 28
    89a0:	0f b6       	in	r0, 0x3f	; 63
    89a2:	f8 94       	cli
    89a4:	de bf       	out	0x3e, r29	; 62
    89a6:	0f be       	out	0x3f, r0	; 63
    89a8:	cd bf       	out	0x3d, r28	; 61
    89aa:	3c 01       	movw	r6, r24
    89ac:	7a 8f       	std	Y+26, r23	; 0x1a
    89ae:	69 8f       	std	Y+25, r22	; 0x19
    89b0:	5c 8f       	std	Y+28, r21	; 0x1c
    89b2:	4b 8f       	std	Y+27, r20	; 0x1b
    89b4:	19 01       	movw	r2, r18
	find_home_out=1;
	

	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    89b6:	80 e6       	ldi	r24, 0x60	; 96
    89b8:	90 e0       	ldi	r25, 0x00	; 0
    89ba:	68 9e       	mul	r6, r24
    89bc:	20 01       	movw	r4, r0
    89be:	69 9e       	mul	r6, r25
    89c0:	50 0c       	add	r5, r0
    89c2:	78 9e       	mul	r7, r24
    89c4:	50 0c       	add	r5, r0
    89c6:	11 24       	eor	r1, r1
    89c8:	84 e7       	ldi	r24, 0x74	; 116
    89ca:	9d e7       	ldi	r25, 0x7D	; 125
    89cc:	48 0e       	add	r4, r24
    89ce:	59 1e       	adc	r5, r25
    89d0:	13 e0       	ldi	r17, 0x03	; 3
    89d2:	81 2e       	mov	r8, r17
    89d4:	91 2c       	mov	r9, r1
    89d6:	8c 0e       	add	r8, r28
    89d8:	9d 1e       	adc	r9, r29
    89da:	c2 01       	movw	r24, r4
    89dc:	b4 01       	movw	r22, r8
    89de:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
	printf("search_home_negative=> HostIOError = %x para el eje %s\n ",test,AxisName(Axis));
    89e2:	0b 81       	ldd	r16, Y+3	; 0x03
    89e4:	1c 81       	ldd	r17, Y+4	; 0x04
    89e6:	c3 01       	movw	r24, r6
    89e8:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    89ec:	00 d0       	rcall	.+0      	; 0x89ee <search_home_negative+0x78>
    89ee:	00 d0       	rcall	.+0      	; 0x89f0 <search_home_negative+0x7a>
    89f0:	00 d0       	rcall	.+0      	; 0x89f2 <search_home_negative+0x7c>
    89f2:	ed b7       	in	r30, 0x3d	; 61
    89f4:	fe b7       	in	r31, 0x3e	; 62
    89f6:	31 96       	adiw	r30, 0x01	; 1
    89f8:	20 e7       	ldi	r18, 0x70	; 112
    89fa:	39 e5       	ldi	r19, 0x59	; 89
    89fc:	ad b7       	in	r26, 0x3d	; 61
    89fe:	be b7       	in	r27, 0x3e	; 62
    8a00:	12 96       	adiw	r26, 0x02	; 2
    8a02:	3c 93       	st	X, r19
    8a04:	2e 93       	st	-X, r18
    8a06:	11 97       	sbiw	r26, 0x01	; 1
    8a08:	13 83       	std	Z+3, r17	; 0x03
    8a0a:	02 83       	std	Z+2, r16	; 0x02
    8a0c:	95 83       	std	Z+5, r25	; 0x05
    8a0e:	84 83       	std	Z+4, r24	; 0x04
    8a10:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	#endif
	
	No_limit_switch(Axis);
    8a14:	ed b7       	in	r30, 0x3d	; 61
    8a16:	fe b7       	in	r31, 0x3e	; 62
    8a18:	36 96       	adiw	r30, 0x06	; 6
    8a1a:	0f b6       	in	r0, 0x3f	; 63
    8a1c:	f8 94       	cli
    8a1e:	fe bf       	out	0x3e, r31	; 62
    8a20:	0f be       	out	0x3f, r0	; 63
    8a22:	ed bf       	out	0x3d, r30	; 61
    8a24:	c3 01       	movw	r24, r6
    8a26:	0e 94 4e 34 	call	0x689c	; 0x689c <No_limit_switch>
	//Limpia el BiT de Position Capture Indicator en el Status Register
	PMDResetEventStatus(&hAxis[Axis],~PMDEventCaptureReceivedMask);	
    8a2a:	c2 01       	movw	r24, r4
    8a2c:	67 ef       	ldi	r22, 0xF7	; 247
    8a2e:	7f ef       	ldi	r23, 0xFF	; 255
    8a30:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
	//La senal de HOME sera utilizada como Disparo para la Captura de la Posicion
	PMDSetCaptureSource(&hAxis[Axis],PMDCaptureSourceHome);
    8a34:	c2 01       	movw	r24, r4
    8a36:	61 e0       	ldi	r22, 0x01	; 1
    8a38:	70 e0       	ldi	r23, 0x00	; 0
    8a3a:	0e 94 95 63 	call	0xc72a	; 0xc72a <PMDSetCaptureSource>
	//Leyendo el registro de Captura de Posicion Causa "rearmar" 
	//el disparador con el fin de permitir mas capturas.
	PMDGetCaptureValue(&hAxis[Axis],&temp); 
    8a3e:	c2 01       	movw	r24, r4
    8a40:	be 01       	movw	r22, r28
    8a42:	6b 5f       	subi	r22, 0xFB	; 251
    8a44:	7f 4f       	sbci	r23, 0xFF	; 255
    8a46:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <PMDGetCaptureValue>
	
	#ifdef DEBUGROBOTICS_HOME
	printf("search_home_negative=> Ejecutado No_limit_switch\n");
    8a4a:	89 ea       	ldi	r24, 0xA9	; 169
    8a4c:	99 e5       	ldi	r25, 0x59	; 89
    8a4e:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	printf("search_home_negative=> Busqueda home en dir neg. del eje %s.\n ",AxisName(Axis));
    8a52:	c3 01       	movw	r24, r6
    8a54:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    8a58:	00 d0       	rcall	.+0      	; 0x8a5a <search_home_negative+0xe4>
    8a5a:	00 d0       	rcall	.+0      	; 0x8a5c <search_home_negative+0xe6>
    8a5c:	2a ed       	ldi	r18, 0xDA	; 218
    8a5e:	39 e5       	ldi	r19, 0x59	; 89
    8a60:	ad b7       	in	r26, 0x3d	; 61
    8a62:	be b7       	in	r27, 0x3e	; 62
    8a64:	12 96       	adiw	r26, 0x02	; 2
    8a66:	3c 93       	st	X, r19
    8a68:	2e 93       	st	-X, r18
    8a6a:	11 97       	sbiw	r26, 0x01	; 1
    8a6c:	14 96       	adiw	r26, 0x04	; 4
    8a6e:	9c 93       	st	X, r25
    8a70:	8e 93       	st	-X, r24
    8a72:	13 97       	sbiw	r26, 0x03	; 3
    8a74:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	#endif

	
	switch (Axis)
    8a78:	0f 90       	pop	r0
    8a7a:	0f 90       	pop	r0
    8a7c:	0f 90       	pop	r0
    8a7e:	0f 90       	pop	r0
    8a80:	b2 e0       	ldi	r27, 0x02	; 2
    8a82:	6b 16       	cp	r6, r27
    8a84:	71 04       	cpc	r7, r1
    8a86:	09 f4       	brne	.+2      	; 0x8a8a <search_home_negative+0x114>
    8a88:	bd c0       	rjmp	.+378    	; 0x8c04 <search_home_negative+0x28e>
    8a8a:	e3 e0       	ldi	r30, 0x03	; 3
    8a8c:	6e 16       	cp	r6, r30
    8a8e:	71 04       	cpc	r7, r1
    8a90:	34 f4       	brge	.+12     	; 0x8a9e <search_home_negative+0x128>
    8a92:	f1 e0       	ldi	r31, 0x01	; 1
    8a94:	6f 16       	cp	r6, r31
    8a96:	71 04       	cpc	r7, r1
    8a98:	09 f0       	breq	.+2      	; 0x8a9c <search_home_negative+0x126>
    8a9a:	99 c1       	rjmp	.+818    	; 0x8dce <search_home_negative+0x458>
    8a9c:	0b c0       	rjmp	.+22     	; 0x8ab4 <search_home_negative+0x13e>
    8a9e:	83 e0       	ldi	r24, 0x03	; 3
    8aa0:	68 16       	cp	r6, r24
    8aa2:	71 04       	cpc	r7, r1
    8aa4:	09 f4       	brne	.+2      	; 0x8aa8 <search_home_negative+0x132>
    8aa6:	2b c1       	rjmp	.+598    	; 0x8cfe <search_home_negative+0x388>
    8aa8:	94 e0       	ldi	r25, 0x04	; 4
    8aaa:	69 16       	cp	r6, r25
    8aac:	71 04       	cpc	r7, r1
    8aae:	09 f0       	breq	.+2      	; 0x8ab2 <search_home_negative+0x13c>
    8ab0:	8e c1       	rjmp	.+796    	; 0x8dce <search_home_negative+0x458>
    8ab2:	54 c1       	rjmp	.+680    	; 0x8d5c <search_home_negative+0x3e6>
		case (AxisShoulder):
		{
			//No codo depende de nadie va directo...  
			//(Siempre entra aqui cuando se usa con una trayectoria )..
			//NO OLVIDAR CONFIGURAR LOS DEMAS COMO VELOCIDAD CONTINUA 
			mov_axis(Axis,-INF, 
    8ab4:	00 91 14 7e 	lds	r16, 0x7E14
    8ab8:	10 91 15 7e 	lds	r17, 0x7E15
    8abc:	20 91 16 7e 	lds	r18, 0x7E16
    8ac0:	30 91 17 7e 	lds	r19, 0x7E17
    8ac4:	c0 90 18 7e 	lds	r12, 0x7E18
    8ac8:	d0 90 19 7e 	lds	r13, 0x7E19
    8acc:	e0 90 1a 7e 	lds	r14, 0x7E1A
    8ad0:	f0 90 1b 7e 	lds	r15, 0x7E1B
    8ad4:	81 e0       	ldi	r24, 0x01	; 1
    8ad6:	90 e0       	ldi	r25, 0x00	; 0
    8ad8:	41 e0       	ldi	r20, 0x01	; 1
    8ada:	50 e0       	ldi	r21, 0x00	; 0
    8adc:	60 e0       	ldi	r22, 0x00	; 0
    8ade:	70 e8       	ldi	r23, 0x80	; 128
    8ae0:	bf ee       	ldi	r27, 0xEF	; 239
    8ae2:	ab 2e       	mov	r10, r27
    8ae4:	bf ef       	ldi	r27, 0xFF	; 255
    8ae6:	bb 2e       	mov	r11, r27
    8ae8:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
			100,
			no_update,EN_CALIBRACION_PROCESOHOME );
			*/
			
			//Configurando los registros de codo, codo esta invertido invertido.
			mov_correlacionado_HOME(AxisElbow,-INF,
    8aec:	00 d0       	rcall	.+0      	; 0x8aee <search_home_negative+0x178>
    8aee:	00 d0       	rcall	.+0      	; 0x8af0 <search_home_negative+0x17a>
    8af0:	00 91 14 7e 	lds	r16, 0x7E14
    8af4:	10 91 15 7e 	lds	r17, 0x7E15
    8af8:	20 91 16 7e 	lds	r18, 0x7E16
    8afc:	30 91 17 7e 	lds	r19, 0x7E17
    8b00:	a0 90 18 7e 	lds	r10, 0x7E18
    8b04:	b0 90 19 7e 	lds	r11, 0x7E19
    8b08:	c0 90 1a 7e 	lds	r12, 0x7E1A
    8b0c:	d0 90 1b 7e 	lds	r13, 0x7E1B
    8b10:	8d e1       	ldi	r24, 0x1D	; 29
    8b12:	9a e5       	ldi	r25, 0x5A	; 90
    8b14:	a4 e5       	ldi	r26, 0x54	; 84
    8b16:	bf e3       	ldi	r27, 0x3F	; 63
    8b18:	ed b7       	in	r30, 0x3d	; 61
    8b1a:	fe b7       	in	r31, 0x3e	; 62
    8b1c:	81 83       	std	Z+1, r24	; 0x01
    8b1e:	92 83       	std	Z+2, r25	; 0x02
    8b20:	a3 83       	std	Z+3, r26	; 0x03
    8b22:	b4 83       	std	Z+4, r27	; 0x04
    8b24:	82 e0       	ldi	r24, 0x02	; 2
    8b26:	90 e0       	ldi	r25, 0x00	; 0
    8b28:	41 e0       	ldi	r20, 0x01	; 1
    8b2a:	50 e0       	ldi	r21, 0x00	; 0
    8b2c:	60 e0       	ldi	r22, 0x00	; 0
    8b2e:	70 e8       	ldi	r23, 0x80	; 128
    8b30:	a9 e0       	ldi	r26, 0x09	; 9
    8b32:	ea 2e       	mov	r14, r26
    8b34:	f1 2c       	mov	r15, r1
    8b36:	ec 0e       	add	r14, r28
    8b38:	fd 1e       	adc	r15, r29
    8b3a:	f1 e1       	ldi	r31, 0x11	; 17
    8b3c:	8f 2e       	mov	r8, r31
    8b3e:	91 2c       	mov	r9, r1
    8b40:	8c 0e       	add	r8, r28
    8b42:	9d 1e       	adc	r9, r29
    8b44:	0e 94 47 40 	call	0x808e	; 0x808e <mov_correlacionado_HOME>
												hAxis[Axis].axisSettings.homeVelocity,
												&Velocidad_eje2_temp,hAxis[Axis].axisSettings.homeAcceleration,
												&Aceleracion_eje2_temp,CORRELACION_HOMBRO_CODO);		
			//Configurando los registros de pitch, el pitch esta en el mismo sentido que el codo.
			mov_correlacionado_HOME(AxisPitch,-INF,
    8b48:	09 85       	ldd	r16, Y+9	; 0x09
    8b4a:	1a 85       	ldd	r17, Y+10	; 0x0a
    8b4c:	2b 85       	ldd	r18, Y+11	; 0x0b
    8b4e:	3c 85       	ldd	r19, Y+12	; 0x0c
    8b50:	a9 88       	ldd	r10, Y+17	; 0x11
    8b52:	ba 88       	ldd	r11, Y+18	; 0x12
    8b54:	cb 88       	ldd	r12, Y+19	; 0x13
    8b56:	dc 88       	ldd	r13, Y+20	; 0x14
    8b58:	89 ec       	ldi	r24, 0xC9	; 201
    8b5a:	9e e8       	ldi	r25, 0x8E	; 142
    8b5c:	ad e8       	ldi	r26, 0x8D	; 141
    8b5e:	bc e3       	ldi	r27, 0x3C	; 60
    8b60:	ed b7       	in	r30, 0x3d	; 61
    8b62:	fe b7       	in	r31, 0x3e	; 62
    8b64:	81 83       	std	Z+1, r24	; 0x01
    8b66:	92 83       	std	Z+2, r25	; 0x02
    8b68:	a3 83       	std	Z+3, r26	; 0x03
    8b6a:	b4 83       	std	Z+4, r27	; 0x04
    8b6c:	83 e0       	ldi	r24, 0x03	; 3
    8b6e:	90 e0       	ldi	r25, 0x00	; 0
    8b70:	41 e0       	ldi	r20, 0x01	; 1
    8b72:	50 e0       	ldi	r21, 0x00	; 0
    8b74:	60 e0       	ldi	r22, 0x00	; 0
    8b76:	70 e8       	ldi	r23, 0x80	; 128
    8b78:	ed e0       	ldi	r30, 0x0D	; 13
    8b7a:	ee 2e       	mov	r14, r30
    8b7c:	f1 2c       	mov	r15, r1
    8b7e:	ec 0e       	add	r14, r28
    8b80:	fd 1e       	adc	r15, r29
    8b82:	b5 e1       	ldi	r27, 0x15	; 21
    8b84:	8b 2e       	mov	r8, r27
    8b86:	91 2c       	mov	r9, r1
    8b88:	8c 0e       	add	r8, r28
    8b8a:	9d 1e       	adc	r9, r29
    8b8c:	0e 94 47 40 	call	0x808e	; 0x808e <mov_correlacionado_HOME>
												Velocidad_eje2_temp,
												&Velocidad_final_pitch,Aceleracion_eje2_temp,
												&Aceleracion_final_pitch,
												CORRELACION_CODO_PITCH);
			
			printf("search_home_negative=> Update AxisShoulder \n ");
    8b90:	0f 90       	pop	r0
    8b92:	0f 90       	pop	r0
    8b94:	89 e1       	ldi	r24, 0x19	; 25
    8b96:	9a e5       	ldi	r25, 0x5A	; 90
    8b98:	ad b7       	in	r26, 0x3d	; 61
    8b9a:	be b7       	in	r27, 0x3e	; 62
    8b9c:	12 96       	adiw	r26, 0x02	; 2
    8b9e:	9c 93       	st	X, r25
    8ba0:	8e 93       	st	-X, r24
    8ba2:	11 97       	sbiw	r26, 0x01	; 1
    8ba4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisShoulder]);
    8ba8:	0f 90       	pop	r0
    8baa:	0f 90       	pop	r0
    8bac:	84 ed       	ldi	r24, 0xD4	; 212
    8bae:	9d e7       	ldi	r25, 0x7D	; 125
    8bb0:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			printf("search_home_negative=> Update AxisElbow \n ");
    8bb4:	00 d0       	rcall	.+0      	; 0x8bb6 <search_home_negative+0x240>
    8bb6:	87 e4       	ldi	r24, 0x47	; 71
    8bb8:	9a e5       	ldi	r25, 0x5A	; 90
    8bba:	ed b7       	in	r30, 0x3d	; 61
    8bbc:	fe b7       	in	r31, 0x3e	; 62
    8bbe:	92 83       	std	Z+2, r25	; 0x02
    8bc0:	81 83       	std	Z+1, r24	; 0x01
    8bc2:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisElbow]);	
    8bc6:	0f 90       	pop	r0
    8bc8:	0f 90       	pop	r0
    8bca:	84 e3       	ldi	r24, 0x34	; 52
    8bcc:	9e e7       	ldi	r25, 0x7E	; 126
    8bce:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			printf("search_home_negative=> Update AxisPitch \n ");
    8bd2:	00 d0       	rcall	.+0      	; 0x8bd4 <search_home_negative+0x25e>
    8bd4:	82 e7       	ldi	r24, 0x72	; 114
    8bd6:	9a e5       	ldi	r25, 0x5A	; 90
    8bd8:	ad b7       	in	r26, 0x3d	; 61
    8bda:	be b7       	in	r27, 0x3e	; 62
    8bdc:	12 96       	adiw	r26, 0x02	; 2
    8bde:	9c 93       	st	X, r25
    8be0:	8e 93       	st	-X, r24
    8be2:	11 97       	sbiw	r26, 0x01	; 1
    8be4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisPitch]);	
    8be8:	0f 90       	pop	r0
    8bea:	0f 90       	pop	r0
    8bec:	84 e9       	ldi	r24, 0x94	; 148
    8bee:	9e e7       	ldi	r25, 0x7E	; 126
    8bf0:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			printf("search_home_negative=> Update AxisRoll \n ");
    8bf4:	00 d0       	rcall	.+0      	; 0x8bf6 <search_home_negative+0x280>
    8bf6:	8d e9       	ldi	r24, 0x9D	; 157
    8bf8:	9a e5       	ldi	r25, 0x5A	; 90
    8bfa:	ed b7       	in	r30, 0x3d	; 61
    8bfc:	fe b7       	in	r31, 0x3e	; 62
    8bfe:	92 83       	std	Z+2, r25	; 0x02
    8c00:	81 83       	std	Z+1, r24	; 0x01
    8c02:	74 c0       	rjmp	.+232    	; 0x8cec <search_home_negative+0x376>
			PMDUpdate(&hAxis[AxisRoll]);
		}
		break;
		case (AxisElbow):
		{
			mov_axis(Axis,-INF, 
    8c04:	00 91 74 7e 	lds	r16, 0x7E74
    8c08:	10 91 75 7e 	lds	r17, 0x7E75
    8c0c:	20 91 76 7e 	lds	r18, 0x7E76
    8c10:	30 91 77 7e 	lds	r19, 0x7E77
    8c14:	c0 90 78 7e 	lds	r12, 0x7E78
    8c18:	d0 90 79 7e 	lds	r13, 0x7E79
    8c1c:	e0 90 7a 7e 	lds	r14, 0x7E7A
    8c20:	f0 90 7b 7e 	lds	r15, 0x7E7B
    8c24:	82 e0       	ldi	r24, 0x02	; 2
    8c26:	90 e0       	ldi	r25, 0x00	; 0
    8c28:	41 e0       	ldi	r20, 0x01	; 1
    8c2a:	50 e0       	ldi	r21, 0x00	; 0
    8c2c:	60 e0       	ldi	r22, 0x00	; 0
    8c2e:	70 e8       	ldi	r23, 0x80	; 128
    8c30:	af ee       	ldi	r26, 0xEF	; 239
    8c32:	aa 2e       	mov	r10, r26
    8c34:	af ef       	ldi	r26, 0xFF	; 255
    8c36:	ba 2e       	mov	r11, r26
    8c38:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
			300,
			no_update,EN_CALIBRACION_PROCESOHOME );
			
			*/
			
			mov_correlacionado_HOME(AxisPitch,-INF,
    8c3c:	00 d0       	rcall	.+0      	; 0x8c3e <search_home_negative+0x2c8>
    8c3e:	00 d0       	rcall	.+0      	; 0x8c40 <search_home_negative+0x2ca>
    8c40:	00 91 74 7e 	lds	r16, 0x7E74
    8c44:	10 91 75 7e 	lds	r17, 0x7E75
    8c48:	20 91 76 7e 	lds	r18, 0x7E76
    8c4c:	30 91 77 7e 	lds	r19, 0x7E77
    8c50:	a0 90 78 7e 	lds	r10, 0x7E78
    8c54:	b0 90 79 7e 	lds	r11, 0x7E79
    8c58:	c0 90 7a 7e 	lds	r12, 0x7E7A
    8c5c:	d0 90 7b 7e 	lds	r13, 0x7E7B
    8c60:	89 ec       	ldi	r24, 0xC9	; 201
    8c62:	9e e8       	ldi	r25, 0x8E	; 142
    8c64:	ad e8       	ldi	r26, 0x8D	; 141
    8c66:	bc e3       	ldi	r27, 0x3C	; 60
    8c68:	ed b7       	in	r30, 0x3d	; 61
    8c6a:	fe b7       	in	r31, 0x3e	; 62
    8c6c:	81 83       	std	Z+1, r24	; 0x01
    8c6e:	92 83       	std	Z+2, r25	; 0x02
    8c70:	a3 83       	std	Z+3, r26	; 0x03
    8c72:	b4 83       	std	Z+4, r27	; 0x04
    8c74:	83 e0       	ldi	r24, 0x03	; 3
    8c76:	90 e0       	ldi	r25, 0x00	; 0
    8c78:	41 e0       	ldi	r20, 0x01	; 1
    8c7a:	50 e0       	ldi	r21, 0x00	; 0
    8c7c:	60 e0       	ldi	r22, 0x00	; 0
    8c7e:	70 e8       	ldi	r23, 0x80	; 128
    8c80:	fd e0       	ldi	r31, 0x0D	; 13
    8c82:	ef 2e       	mov	r14, r31
    8c84:	f1 2c       	mov	r15, r1
    8c86:	ec 0e       	add	r14, r28
    8c88:	fd 1e       	adc	r15, r29
    8c8a:	e5 e1       	ldi	r30, 0x15	; 21
    8c8c:	8e 2e       	mov	r8, r30
    8c8e:	91 2c       	mov	r9, r1
    8c90:	8c 0e       	add	r8, r28
    8c92:	9d 1e       	adc	r9, r29
    8c94:	0e 94 47 40 	call	0x808e	; 0x808e <mov_correlacionado_HOME>
												hAxis[Axis].axisSettings.homeVelocity ,
												&Velocidad_final_pitch,hAxis[Axis].axisSettings.homeAcceleration,
												&Aceleracion_final_pitch,
												CORRELACION_CODO_PITCH);	
			printf("search_home_negative=> Update AxisElbow \n ");
    8c98:	0f 90       	pop	r0
    8c9a:	0f 90       	pop	r0
    8c9c:	87 e4       	ldi	r24, 0x47	; 71
    8c9e:	9a e5       	ldi	r25, 0x5A	; 90
    8ca0:	ad b7       	in	r26, 0x3d	; 61
    8ca2:	be b7       	in	r27, 0x3e	; 62
    8ca4:	12 96       	adiw	r26, 0x02	; 2
    8ca6:	9c 93       	st	X, r25
    8ca8:	8e 93       	st	-X, r24
    8caa:	11 97       	sbiw	r26, 0x01	; 1
    8cac:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisElbow]);
    8cb0:	0f 90       	pop	r0
    8cb2:	0f 90       	pop	r0
    8cb4:	84 e3       	ldi	r24, 0x34	; 52
    8cb6:	9e e7       	ldi	r25, 0x7E	; 126
    8cb8:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			printf("search_home_negative=> Update AxisPitch \n ");
    8cbc:	00 d0       	rcall	.+0      	; 0x8cbe <search_home_negative+0x348>
    8cbe:	82 e7       	ldi	r24, 0x72	; 114
    8cc0:	9a e5       	ldi	r25, 0x5A	; 90
    8cc2:	ed b7       	in	r30, 0x3d	; 61
    8cc4:	fe b7       	in	r31, 0x3e	; 62
    8cc6:	92 83       	std	Z+2, r25	; 0x02
    8cc8:	81 83       	std	Z+1, r24	; 0x01
    8cca:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisPitch]);	
    8cce:	0f 90       	pop	r0
    8cd0:	0f 90       	pop	r0
    8cd2:	84 e9       	ldi	r24, 0x94	; 148
    8cd4:	9e e7       	ldi	r25, 0x7E	; 126
    8cd6:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			printf("search_home_negative=> Update AxisRoll \n ");
    8cda:	00 d0       	rcall	.+0      	; 0x8cdc <search_home_negative+0x366>
    8cdc:	8d e9       	ldi	r24, 0x9D	; 157
    8cde:	9a e5       	ldi	r25, 0x5A	; 90
    8ce0:	ad b7       	in	r26, 0x3d	; 61
    8ce2:	be b7       	in	r27, 0x3e	; 62
    8ce4:	12 96       	adiw	r26, 0x02	; 2
    8ce6:	9c 93       	st	X, r25
    8ce8:	8e 93       	st	-X, r24
    8cea:	11 97       	sbiw	r26, 0x01	; 1
    8cec:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			PMDUpdate(&hAxis[AxisRoll]);
    8cf0:	0f 90       	pop	r0
    8cf2:	0f 90       	pop	r0
    8cf4:	84 ef       	ldi	r24, 0xF4	; 244
    8cf6:	9e e7       	ldi	r25, 0x7E	; 126
    8cf8:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
    8cfc:	88 c0       	rjmp	.+272    	; 0x8e0e <search_home_negative+0x498>
		}
		break;					
		case (AxisPitch):
		{
			pitch(-INF, hAxis[Axis].axisSettings.homeVelocity,
    8cfe:	20 91 d4 7e 	lds	r18, 0x7ED4
    8d02:	30 91 d5 7e 	lds	r19, 0x7ED5
    8d06:	40 91 d6 7e 	lds	r20, 0x7ED6
    8d0a:	50 91 d7 7e 	lds	r21, 0x7ED7
    8d0e:	e0 90 d8 7e 	lds	r14, 0x7ED8
    8d12:	f0 90 d9 7e 	lds	r15, 0x7ED9
    8d16:	00 91 da 7e 	lds	r16, 0x7EDA
    8d1a:	10 91 db 7e 	lds	r17, 0x7EDB
    8d1e:	61 e0       	ldi	r22, 0x01	; 1
    8d20:	70 e0       	ldi	r23, 0x00	; 0
    8d22:	80 e0       	ldi	r24, 0x00	; 0
    8d24:	90 e8       	ldi	r25, 0x80	; 128
    8d26:	b0 ef       	ldi	r27, 0xF0	; 240
    8d28:	cb 2e       	mov	r12, r27
    8d2a:	bf ef       	ldi	r27, 0xFF	; 255
    8d2c:	db 2e       	mov	r13, r27
    8d2e:	a4 e0       	ldi	r26, 0x04	; 4
    8d30:	aa 2e       	mov	r10, r26
    8d32:	b1 2c       	mov	r11, r1
    8d34:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <pitch>
			hAxis[Axis].axisSettings.homeAcceleration,update,INICIANDO_HOME_PITCH_ROLL );
			
			
			#ifdef DEBUGROBOTICS_HOME
			PMDGetHostIOError(&hAxis[AxisRoll], &test);
    8d38:	84 ef       	ldi	r24, 0xF4	; 244
    8d3a:	9e e7       	ldi	r25, 0x7E	; 126
    8d3c:	b4 01       	movw	r22, r8
    8d3e:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
			printf("search_home_negative=> HostIOError = %x del eje ROLL despues del update.\n ",test);
    8d42:	00 d0       	rcall	.+0      	; 0x8d44 <search_home_negative+0x3ce>
    8d44:	00 d0       	rcall	.+0      	; 0x8d46 <search_home_negative+0x3d0>
    8d46:	87 ec       	ldi	r24, 0xC7	; 199
    8d48:	9a e5       	ldi	r25, 0x5A	; 90
    8d4a:	ed b7       	in	r30, 0x3d	; 61
    8d4c:	fe b7       	in	r31, 0x3e	; 62
    8d4e:	92 83       	std	Z+2, r25	; 0x02
    8d50:	81 83       	std	Z+1, r24	; 0x01
    8d52:	8b 81       	ldd	r24, Y+3	; 0x03
    8d54:	9c 81       	ldd	r25, Y+4	; 0x04
    8d56:	94 83       	std	Z+4, r25	; 0x04
    8d58:	83 83       	std	Z+3, r24	; 0x03
    8d5a:	32 c0       	rjmp	.+100    	; 0x8dc0 <search_home_negative+0x44a>
			#endif
		}
	    break;	
		case (AxisRoll):		
		{
			roll(-INF, hAxis[Axis].axisSettings.homeVelocity,
    8d5c:	20 91 34 7f 	lds	r18, 0x7F34
    8d60:	30 91 35 7f 	lds	r19, 0x7F35
    8d64:	40 91 36 7f 	lds	r20, 0x7F36
    8d68:	50 91 37 7f 	lds	r21, 0x7F37
    8d6c:	e0 90 38 7f 	lds	r14, 0x7F38
    8d70:	f0 90 39 7f 	lds	r15, 0x7F39
    8d74:	00 91 3a 7f 	lds	r16, 0x7F3A
    8d78:	10 91 3b 7f 	lds	r17, 0x7F3B
    8d7c:	61 e0       	ldi	r22, 0x01	; 1
    8d7e:	70 e0       	ldi	r23, 0x00	; 0
    8d80:	80 e0       	ldi	r24, 0x00	; 0
    8d82:	90 e8       	ldi	r25, 0x80	; 128
    8d84:	f0 ef       	ldi	r31, 0xF0	; 240
    8d86:	cf 2e       	mov	r12, r31
    8d88:	ff ef       	ldi	r31, 0xFF	; 255
    8d8a:	df 2e       	mov	r13, r31
    8d8c:	e4 e0       	ldi	r30, 0x04	; 4
    8d8e:	ae 2e       	mov	r10, r30
    8d90:	b1 2c       	mov	r11, r1
    8d92:	0e 94 8a 39 	call	0x7314	; 0x7314 <roll>
			hAxis[Axis].axisSettings.homeAcceleration,update,INICIANDO_HOME_PITCH_ROLL );
			
			
			#ifdef DEBUGROBOTICS_HOME
			PMDGetHostIOError(&hAxis[AxisPitch], &test);
    8d96:	84 e9       	ldi	r24, 0x94	; 148
    8d98:	9e e7       	ldi	r25, 0x7E	; 126
    8d9a:	b4 01       	movw	r22, r8
    8d9c:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
			printf("search_home_negative=> HostIOError = %x del eje PITCH despues del update.\n ",test);
    8da0:	00 d0       	rcall	.+0      	; 0x8da2 <search_home_negative+0x42c>
    8da2:	00 d0       	rcall	.+0      	; 0x8da4 <search_home_negative+0x42e>
    8da4:	82 e1       	ldi	r24, 0x12	; 18
    8da6:	9b e5       	ldi	r25, 0x5B	; 91
    8da8:	ad b7       	in	r26, 0x3d	; 61
    8daa:	be b7       	in	r27, 0x3e	; 62
    8dac:	12 96       	adiw	r26, 0x02	; 2
    8dae:	9c 93       	st	X, r25
    8db0:	8e 93       	st	-X, r24
    8db2:	11 97       	sbiw	r26, 0x01	; 1
    8db4:	8b 81       	ldd	r24, Y+3	; 0x03
    8db6:	9c 81       	ldd	r25, Y+4	; 0x04
    8db8:	14 96       	adiw	r26, 0x04	; 4
    8dba:	9c 93       	st	X, r25
    8dbc:	8e 93       	st	-X, r24
    8dbe:	13 97       	sbiw	r26, 0x03	; 3
    8dc0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    8dc4:	0f 90       	pop	r0
    8dc6:	0f 90       	pop	r0
    8dc8:	0f 90       	pop	r0
    8dca:	0f 90       	pop	r0
    8dcc:	20 c0       	rjmp	.+64     	; 0x8e0e <search_home_negative+0x498>
			#endif
		}
	    break;
		//Solo cintura
		default:
			mov_axis(Axis,-INF,hAxis[Axis].axisSettings.homeVelocity,
    8dce:	80 e6       	ldi	r24, 0x60	; 96
    8dd0:	90 e0       	ldi	r25, 0x00	; 0
    8dd2:	68 9e       	mul	r6, r24
    8dd4:	f0 01       	movw	r30, r0
    8dd6:	69 9e       	mul	r6, r25
    8dd8:	f0 0d       	add	r31, r0
    8dda:	78 9e       	mul	r7, r24
    8ddc:	f0 0d       	add	r31, r0
    8dde:	11 24       	eor	r1, r1
    8de0:	ec 58       	subi	r30, 0x8C	; 140
    8de2:	f2 48       	sbci	r31, 0x82	; 130
    8de4:	e0 5c       	subi	r30, 0xC0	; 192
    8de6:	ff 4f       	sbci	r31, 0xFF	; 255
    8de8:	01 91       	ld	r16, Z+
    8dea:	11 91       	ld	r17, Z+
    8dec:	21 91       	ld	r18, Z+
    8dee:	31 91       	ld	r19, Z+
    8df0:	c0 80       	ld	r12, Z
    8df2:	d1 80       	ldd	r13, Z+1	; 0x01
    8df4:	e2 80       	ldd	r14, Z+2	; 0x02
    8df6:	f3 80       	ldd	r15, Z+3	; 0x03
    8df8:	c3 01       	movw	r24, r6
    8dfa:	41 e0       	ldi	r20, 0x01	; 1
    8dfc:	50 e0       	ldi	r21, 0x00	; 0
    8dfe:	60 e0       	ldi	r22, 0x00	; 0
    8e00:	70 e8       	ldi	r23, 0x80	; 128
    8e02:	b0 ef       	ldi	r27, 0xF0	; 240
    8e04:	ab 2e       	mov	r10, r27
    8e06:	bf ef       	ldi	r27, 0xFF	; 255
    8e08:	bb 2e       	mov	r11, r27
    8e0a:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
	    break;
	}
	
	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    8e0e:	c2 01       	movw	r24, r4
    8e10:	be 01       	movw	r22, r28
    8e12:	6d 5f       	subi	r22, 0xFD	; 253
    8e14:	7f 4f       	sbci	r23, 0xFF	; 255
    8e16:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
	printf("search_home_negative=> HostIOError = %x del eje %s despues del Update.\n ",test,AxisName(Axis));
    8e1a:	0b 81       	ldd	r16, Y+3	; 0x03
    8e1c:	1c 81       	ldd	r17, Y+4	; 0x04
    8e1e:	c3 01       	movw	r24, r6
    8e20:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    8e24:	00 d0       	rcall	.+0      	; 0x8e26 <search_home_negative+0x4b0>
    8e26:	00 d0       	rcall	.+0      	; 0x8e28 <search_home_negative+0x4b2>
    8e28:	00 d0       	rcall	.+0      	; 0x8e2a <search_home_negative+0x4b4>
    8e2a:	ed b7       	in	r30, 0x3d	; 61
    8e2c:	fe b7       	in	r31, 0x3e	; 62
    8e2e:	31 96       	adiw	r30, 0x01	; 1
    8e30:	2e e5       	ldi	r18, 0x5E	; 94
    8e32:	3b e5       	ldi	r19, 0x5B	; 91
    8e34:	ad b7       	in	r26, 0x3d	; 61
    8e36:	be b7       	in	r27, 0x3e	; 62
    8e38:	12 96       	adiw	r26, 0x02	; 2
    8e3a:	3c 93       	st	X, r19
    8e3c:	2e 93       	st	-X, r18
    8e3e:	11 97       	sbiw	r26, 0x01	; 1
    8e40:	13 83       	std	Z+3, r17	; 0x03
    8e42:	02 83       	std	Z+2, r16	; 0x02
    8e44:	95 83       	std	Z+5, r25	; 0x05
    8e46:	84 83       	std	Z+4, r24	; 0x04
    8e48:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("search_home_negative=> Iniciando busqueda de home en el sentido negativo.\n");	
    8e4c:	ed b7       	in	r30, 0x3d	; 61
    8e4e:	fe b7       	in	r31, 0x3e	; 62
    8e50:	36 96       	adiw	r30, 0x06	; 6
    8e52:	0f b6       	in	r0, 0x3f	; 63
    8e54:	f8 94       	cli
    8e56:	fe bf       	out	0x3e, r31	; 62
    8e58:	0f be       	out	0x3f, r0	; 63
    8e5a:	ed bf       	out	0x3d, r30	; 61
    8e5c:	87 ea       	ldi	r24, 0xA7	; 167
    8e5e:	9b e5       	ldi	r25, 0x5B	; 91
    8e60:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	#endif

	do 
	{ 
		PMDGetEventStatus(&hAxis[Axis],&status);            
    8e64:	4e 01       	movw	r8, r28
    8e66:	08 94       	sec
    8e68:	81 1c       	adc	r8, r1
    8e6a:	91 1c       	adc	r9, r1
		
		if((status & PMDEventCaptureReceivedMask) != 0) 
		{   
			#ifdef DEBUGROBOTICS_HOME
			printf("search_home_negative=>  Captura de HOME realizada. \n ");			
    8e6c:	a1 ef       	ldi	r26, 0xF1	; 241
    8e6e:	aa 2e       	mov	r10, r26
    8e70:	ab e5       	ldi	r26, 0x5B	; 91
    8e72:	ba 2e       	mov	r11, r26
						PMDUpdate(&hAxis[AxisPitch]);
						
					case (AxisPitch):
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
						PMDUpdate(&hAxis[AxisRoll]);
				    break;
    8e74:	08 94       	sec
    8e76:	61 1c       	adc	r6, r1
    8e78:	71 1c       	adc	r7, r1
    8e7a:	80 e6       	ldi	r24, 0x60	; 96
    8e7c:	90 e0       	ldi	r25, 0x00	; 0
    8e7e:	68 9e       	mul	r6, r24
    8e80:	60 01       	movw	r12, r0
    8e82:	69 9e       	mul	r6, r25
    8e84:	d0 0c       	add	r13, r0
    8e86:	78 9e       	mul	r7, r24
    8e88:	d0 0c       	add	r13, r0
    8e8a:	11 24       	eor	r1, r1
    8e8c:	08 94       	sec
    8e8e:	61 08       	sbc	r6, r1
    8e90:	71 08       	sbc	r7, r1
    8e92:	84 e7       	ldi	r24, 0x74	; 116
    8e94:	9d e7       	ldi	r25, 0x7D	; 125
    8e96:	c8 0e       	add	r12, r24
    8e98:	d9 1e       	adc	r13, r25
	printf("search_home_negative=> Iniciando busqueda de home en el sentido negativo.\n");	
	#endif

	do 
	{ 
		PMDGetEventStatus(&hAxis[Axis],&status);            
    8e9a:	c2 01       	movw	r24, r4
    8e9c:	b4 01       	movw	r22, r8
    8e9e:	0e 94 a7 61 	call	0xc34e	; 0xc34e <PMDGetEventStatus>
		
		if((status & PMDEventCaptureReceivedMask) != 0) 
    8ea2:	89 81       	ldd	r24, Y+1	; 0x01
    8ea4:	83 ff       	sbrs	r24, 3
    8ea6:	5f c0       	rjmp	.+190    	; 0x8f66 <search_home_negative+0x5f0>
		{   
			#ifdef DEBUGROBOTICS_HOME
			printf("search_home_negative=>  Captura de HOME realizada. \n ");			
    8ea8:	00 d0       	rcall	.+0      	; 0x8eaa <search_home_negative+0x534>
    8eaa:	ad b7       	in	r26, 0x3d	; 61
    8eac:	be b7       	in	r27, 0x3e	; 62
    8eae:	12 96       	adiw	r26, 0x02	; 2
    8eb0:	bc 92       	st	X, r11
    8eb2:	ae 92       	st	-X, r10
    8eb4:	11 97       	sbiw	r26, 0x01	; 1
    8eb6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			#endif
			PMDGetCaptureValue(&hAxis[Axis],home);
    8eba:	0f 90       	pop	r0
    8ebc:	0f 90       	pop	r0
    8ebe:	c2 01       	movw	r24, r4
    8ec0:	69 8d       	ldd	r22, Y+25	; 0x19
    8ec2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    8ec4:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <PMDGetCaptureValue>
			PMDResetEventStatus(&hAxis[Axis],~PMDEventCaptureReceivedMask);
    8ec8:	c2 01       	movw	r24, r4
    8eca:	67 ef       	ldi	r22, 0xF7	; 247
    8ecc:	7f ef       	ldi	r23, 0xFF	; 255
    8ece:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
			
			if(rangos==FALSE) //se Hace Caputura de HOME y se quiere detener el motor
    8ed2:	21 14       	cp	r2, r1
    8ed4:	31 04       	cpc	r3, r1
    8ed6:	09 f0       	breq	.+2      	; 0x8eda <search_home_negative+0x564>
    8ed8:	46 c0       	rjmp	.+140    	; 0x8f66 <search_home_negative+0x5f0>
			{	
				
				//se Cambia la variable a 0 para salir del ciclo.
				find_home_out=0;
				//detener suavemente el movimiento	
				switch (Axis)
    8eda:	b3 e0       	ldi	r27, 0x03	; 3
    8edc:	6b 16       	cp	r6, r27
    8ede:	71 04       	cpc	r7, r1
    8ee0:	01 f1       	breq	.+64     	; 0x8f22 <search_home_negative+0x5ac>
    8ee2:	e4 e0       	ldi	r30, 0x04	; 4
    8ee4:	6e 16       	cp	r6, r30
    8ee6:	71 04       	cpc	r7, r1
    8ee8:	51 f0       	breq	.+20     	; 0x8efe <search_home_negative+0x588>
    8eea:	61 14       	cp	r6, r1
    8eec:	71 04       	cpc	r7, r1
    8eee:	31 f5       	brne	.+76     	; 0x8f3c <search_home_negative+0x5c6>
				{
				    case (AxisWaist):
						PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode ); 
    8ef0:	c2 01       	movw	r24, r4
    8ef2:	61 e0       	ldi	r22, 0x01	; 1
    8ef4:	70 e0       	ldi	r23, 0x00	; 0
    8ef6:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
						PMDUpdate(&hAxis[Axis]);
    8efa:	c2 01       	movw	r24, r4
    8efc:	1a c0       	rjmp	.+52     	; 0x8f32 <search_home_negative+0x5bc>
				    break;
					case (AxisRoll):
						PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode ); 
    8efe:	c2 01       	movw	r24, r4
    8f00:	61 e0       	ldi	r22, 0x01	; 1
    8f02:	70 e0       	ldi	r23, 0x00	; 0
    8f04:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
						PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode ); 
    8f08:	84 e9       	ldi	r24, 0x94	; 148
    8f0a:	9e e7       	ldi	r25, 0x7E	; 126
    8f0c:	61 e0       	ldi	r22, 0x01	; 1
    8f0e:	70 e0       	ldi	r23, 0x00	; 0
    8f10:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
						PMDUpdate(&hAxis[Axis]);
    8f14:	c2 01       	movw	r24, r4
    8f16:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
						PMDUpdate(&hAxis[AxisPitch]);
    8f1a:	84 e9       	ldi	r24, 0x94	; 148
    8f1c:	9e e7       	ldi	r25, 0x7E	; 126
    8f1e:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
						
					case (AxisPitch):
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
    8f22:	84 ef       	ldi	r24, 0xF4	; 244
    8f24:	9e e7       	ldi	r25, 0x7E	; 126
    8f26:	61 e0       	ldi	r22, 0x01	; 1
    8f28:	70 e0       	ldi	r23, 0x00	; 0
    8f2a:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
						PMDUpdate(&hAxis[AxisRoll]);
    8f2e:	84 ef       	ldi	r24, 0xF4	; 244
    8f30:	9e e7       	ldi	r25, 0x7E	; 126
    8f32:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
    8f36:	20 e0       	ldi	r18, 0x00	; 0
    8f38:	30 e0       	ldi	r19, 0x00	; 0
    8f3a:	17 c0       	rjmp	.+46     	; 0x8f6a <search_home_negative+0x5f4>
				    break;
    8f3c:	86 01       	movw	r16, r12
    8f3e:	73 01       	movw	r14, r6
    8f40:	0a c0       	rjmp	.+20     	; 0x8f56 <search_home_negative+0x5e0>
				    default:
				    	for(Axis_Update=Axis+1; Axis_Update < DOF; Axis_Update++) 
						{ 
							PMDSetStopMode(&hAxis[Axis_Update], PMDAbruptStopMode ); 
    8f42:	c8 01       	movw	r24, r16
    8f44:	61 e0       	ldi	r22, 0x01	; 1
    8f46:	70 e0       	ldi	r23, 0x00	; 0
    8f48:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
							PMDUpdate(&hAxis[Axis_Update]);
    8f4c:	c8 01       	movw	r24, r16
    8f4e:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
    8f52:	00 5a       	subi	r16, 0xA0	; 160
    8f54:	1f 4f       	sbci	r17, 0xFF	; 255
    8f56:	08 94       	sec
    8f58:	e1 1c       	adc	r14, r1
    8f5a:	f1 1c       	adc	r15, r1
					case (AxisPitch):
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
						PMDUpdate(&hAxis[AxisRoll]);
				    break;
				    default:
				    	for(Axis_Update=Axis+1; Axis_Update < DOF; Axis_Update++) 
    8f5c:	f5 e0       	ldi	r31, 0x05	; 5
    8f5e:	ef 16       	cp	r14, r31
    8f60:	f1 04       	cpc	r15, r1
    8f62:	7c f3       	brlt	.-34     	; 0x8f42 <search_home_negative+0x5cc>
    8f64:	e8 cf       	rjmp	.-48     	; 0x8f36 <search_home_negative+0x5c0>
    8f66:	21 e0       	ldi	r18, 0x01	; 1
    8f68:	30 e0       	ldi	r19, 0x00	; 0
		//printf(" Moviendo en direccion negativa. \n ");
			//printf("El Event status register del eje %s es %X \n",AxisName(Axis),status);			
		#endif
		
	}		
	while (((status & PMDEventInNegativeLimitMask) == 0) && (find_home_out==1));	
    8f6a:	89 81       	ldd	r24, Y+1	; 0x01
    8f6c:	86 fd       	sbrc	r24, 6
    8f6e:	04 c0       	rjmp	.+8      	; 0x8f78 <search_home_negative+0x602>
    8f70:	21 30       	cpi	r18, 0x01	; 1
    8f72:	31 05       	cpc	r19, r1
    8f74:	09 f4       	brne	.+2      	; 0x8f78 <search_home_negative+0x602>
    8f76:	91 cf       	rjmp	.-222    	; 0x8e9a <search_home_negative+0x524>
	
	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    8f78:	c2 01       	movw	r24, r4
    8f7a:	be 01       	movw	r22, r28
    8f7c:	6d 5f       	subi	r22, 0xFD	; 253
    8f7e:	7f 4f       	sbci	r23, 0xFF	; 255
    8f80:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
	printf("search_home_negative=> Error en el eje %s despues del movimiento %x\n ",AxisName(Axis),test);
    8f84:	c3 01       	movw	r24, r6
    8f86:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    8f8a:	00 d0       	rcall	.+0      	; 0x8f8c <search_home_negative+0x616>
    8f8c:	00 d0       	rcall	.+0      	; 0x8f8e <search_home_negative+0x618>
    8f8e:	00 d0       	rcall	.+0      	; 0x8f90 <search_home_negative+0x61a>
    8f90:	ed b7       	in	r30, 0x3d	; 61
    8f92:	fe b7       	in	r31, 0x3e	; 62
    8f94:	31 96       	adiw	r30, 0x01	; 1
    8f96:	27 e2       	ldi	r18, 0x27	; 39
    8f98:	3c e5       	ldi	r19, 0x5C	; 92
    8f9a:	ad b7       	in	r26, 0x3d	; 61
    8f9c:	be b7       	in	r27, 0x3e	; 62
    8f9e:	12 96       	adiw	r26, 0x02	; 2
    8fa0:	3c 93       	st	X, r19
    8fa2:	2e 93       	st	-X, r18
    8fa4:	11 97       	sbiw	r26, 0x01	; 1
    8fa6:	93 83       	std	Z+3, r25	; 0x03
    8fa8:	82 83       	std	Z+2, r24	; 0x02
    8faa:	8b 81       	ldd	r24, Y+3	; 0x03
    8fac:	9c 81       	ldd	r25, Y+4	; 0x04
    8fae:	95 83       	std	Z+5, r25	; 0x05
    8fb0:	84 83       	std	Z+4, r24	; 0x04
    8fb2:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	PMDGetEventStatus(&hAxis[Axis],&status);  
    8fb6:	ed b7       	in	r30, 0x3d	; 61
    8fb8:	fe b7       	in	r31, 0x3e	; 62
    8fba:	36 96       	adiw	r30, 0x06	; 6
    8fbc:	0f b6       	in	r0, 0x3f	; 63
    8fbe:	f8 94       	cli
    8fc0:	fe bf       	out	0x3e, r31	; 62
    8fc2:	0f be       	out	0x3f, r0	; 63
    8fc4:	ed bf       	out	0x3d, r30	; 61
    8fc6:	c2 01       	movw	r24, r4
    8fc8:	8e 01       	movw	r16, r28
    8fca:	0f 5f       	subi	r16, 0xFF	; 255
    8fcc:	1f 4f       	sbci	r17, 0xFF	; 255
    8fce:	b8 01       	movw	r22, r16
    8fd0:	0e 94 a7 61 	call	0xc34e	; 0xc34e <PMDGetEventStatus>
	printf("search_home_negative=> El Event status register antes de limpiar del eje %s es %X \n",AxisName(Axis),status);	
    8fd4:	c3 01       	movw	r24, r6
    8fd6:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    8fda:	00 d0       	rcall	.+0      	; 0x8fdc <search_home_negative+0x666>
    8fdc:	00 d0       	rcall	.+0      	; 0x8fde <search_home_negative+0x668>
    8fde:	00 d0       	rcall	.+0      	; 0x8fe0 <search_home_negative+0x66a>
    8fe0:	ed b7       	in	r30, 0x3d	; 61
    8fe2:	fe b7       	in	r31, 0x3e	; 62
    8fe4:	31 96       	adiw	r30, 0x01	; 1
    8fe6:	2d e6       	ldi	r18, 0x6D	; 109
    8fe8:	3c e5       	ldi	r19, 0x5C	; 92
    8fea:	ad b7       	in	r26, 0x3d	; 61
    8fec:	be b7       	in	r27, 0x3e	; 62
    8fee:	12 96       	adiw	r26, 0x02	; 2
    8ff0:	3c 93       	st	X, r19
    8ff2:	2e 93       	st	-X, r18
    8ff4:	11 97       	sbiw	r26, 0x01	; 1
    8ff6:	93 83       	std	Z+3, r25	; 0x03
    8ff8:	82 83       	std	Z+2, r24	; 0x02
    8ffa:	89 81       	ldd	r24, Y+1	; 0x01
    8ffc:	9a 81       	ldd	r25, Y+2	; 0x02
    8ffe:	95 83       	std	Z+5, r25	; 0x05
    9000:	84 83       	std	Z+4, r24	; 0x04
    9002:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	

	
	/*Se limpia el Event Status Register, borrando las interrupciones generadas: Evento de Limite
	Negativo y Fin de movimiento*/	
	Reset_Even_Status_Register();
    9006:	ed b7       	in	r30, 0x3d	; 61
    9008:	fe b7       	in	r31, 0x3e	; 62
    900a:	36 96       	adiw	r30, 0x06	; 6
    900c:	0f b6       	in	r0, 0x3f	; 63
    900e:	f8 94       	cli
    9010:	fe bf       	out	0x3e, r31	; 62
    9012:	0f be       	out	0x3f, r0	; 63
    9014:	ed bf       	out	0x3d, r30	; 61
    9016:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <Reset_Even_Status_Register>
	
	
	/* Se obtiene la posicion Actual del encoder*/
	PMDGetActualPosition(&hAxis[Axis],posicion);
    901a:	c2 01       	movw	r24, r4
    901c:	6b 8d       	ldd	r22, Y+27	; 0x1b
    901e:	7c 8d       	ldd	r23, Y+28	; 0x1c
    9020:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
	
	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetEventStatus(&hAxis[Axis],&status);  
    9024:	c2 01       	movw	r24, r4
    9026:	b8 01       	movw	r22, r16
    9028:	0e 94 a7 61 	call	0xc34e	; 0xc34e <PMDGetEventStatus>
	printf("search_home_negative=> El Event status register del eje %s despues de limpiar es %X \n ",AxisName(Axis),status);	
    902c:	c3 01       	movw	r24, r6
    902e:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    9032:	00 d0       	rcall	.+0      	; 0x9034 <search_home_negative+0x6be>
    9034:	00 d0       	rcall	.+0      	; 0x9036 <search_home_negative+0x6c0>
    9036:	00 d0       	rcall	.+0      	; 0x9038 <search_home_negative+0x6c2>
    9038:	ed b7       	in	r30, 0x3d	; 61
    903a:	fe b7       	in	r31, 0x3e	; 62
    903c:	31 96       	adiw	r30, 0x01	; 1
    903e:	21 ec       	ldi	r18, 0xC1	; 193
    9040:	3c e5       	ldi	r19, 0x5C	; 92
    9042:	ad b7       	in	r26, 0x3d	; 61
    9044:	be b7       	in	r27, 0x3e	; 62
    9046:	12 96       	adiw	r26, 0x02	; 2
    9048:	3c 93       	st	X, r19
    904a:	2e 93       	st	-X, r18
    904c:	11 97       	sbiw	r26, 0x01	; 1
    904e:	93 83       	std	Z+3, r25	; 0x03
    9050:	82 83       	std	Z+2, r24	; 0x02
    9052:	89 81       	ldd	r24, Y+1	; 0x01
    9054:	9a 81       	ldd	r25, Y+2	; 0x02
    9056:	95 83       	std	Z+5, r25	; 0x05
    9058:	84 83       	std	Z+4, r24	; 0x04
    905a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    905e:	ed b7       	in	r30, 0x3d	; 61
    9060:	fe b7       	in	r31, 0x3e	; 62
    9062:	36 96       	adiw	r30, 0x06	; 6
    9064:	0f b6       	in	r0, 0x3f	; 63
    9066:	f8 94       	cli
    9068:	fe bf       	out	0x3e, r31	; 62
    906a:	0f be       	out	0x3f, r0	; 63
    906c:	ed bf       	out	0x3d, r30	; 61
	#endif	
	
	

}
    906e:	6c 96       	adiw	r28, 0x1c	; 28
    9070:	0f b6       	in	r0, 0x3f	; 63
    9072:	f8 94       	cli
    9074:	de bf       	out	0x3e, r29	; 62
    9076:	0f be       	out	0x3f, r0	; 63
    9078:	cd bf       	out	0x3d, r28	; 61
    907a:	cf 91       	pop	r28
    907c:	df 91       	pop	r29
    907e:	1f 91       	pop	r17
    9080:	0f 91       	pop	r16
    9082:	ff 90       	pop	r15
    9084:	ef 90       	pop	r14
    9086:	df 90       	pop	r13
    9088:	cf 90       	pop	r12
    908a:	bf 90       	pop	r11
    908c:	af 90       	pop	r10
    908e:	9f 90       	pop	r9
    9090:	8f 90       	pop	r8
    9092:	7f 90       	pop	r7
    9094:	6f 90       	pop	r6
    9096:	5f 90       	pop	r5
    9098:	4f 90       	pop	r4
    909a:	3f 90       	pop	r3
    909c:	2f 90       	pop	r2
    909e:	08 95       	ret

000090a0 <go_home>:
	printf("Encoder = %ld\n",encoder);	

}
/**********************************************************************************************************************/
void go_home(void)
{
    90a0:	2f 92       	push	r2
    90a2:	3f 92       	push	r3
    90a4:	4f 92       	push	r4
    90a6:	5f 92       	push	r5
    90a8:	6f 92       	push	r6
    90aa:	7f 92       	push	r7
    90ac:	8f 92       	push	r8
    90ae:	9f 92       	push	r9
    90b0:	af 92       	push	r10
    90b2:	bf 92       	push	r11
    90b4:	cf 92       	push	r12
    90b6:	df 92       	push	r13
    90b8:	ef 92       	push	r14
    90ba:	ff 92       	push	r15
    90bc:	0f 93       	push	r16
    90be:	1f 93       	push	r17
    90c0:	df 93       	push	r29
    90c2:	cf 93       	push	r28
    90c4:	cd b7       	in	r28, 0x3d	; 61
    90c6:	de b7       	in	r29, 0x3e	; 62
    90c8:	ca 54       	subi	r28, 0x4A	; 74
    90ca:	d0 40       	sbci	r29, 0x00	; 0
    90cc:	0f b6       	in	r0, 0x3f	; 63
    90ce:	f8 94       	cli
    90d0:	de bf       	out	0x3e, r29	; 62
    90d2:	0f be       	out	0x3f, r0	; 63
    90d4:	cd bf       	out	0x3d, r28	; 61
	PMDint32 home=0,home1=INF,home2=INF,minPos,maxPos;
    90d6:	1b 86       	std	Y+11, r1	; 0x0b
    90d8:	1c 86       	std	Y+12, r1	; 0x0c
    90da:	1d 86       	std	Y+13, r1	; 0x0d
    90dc:	1e 86       	std	Y+14, r1	; 0x0e
    90de:	8f ef       	ldi	r24, 0xFF	; 255
    90e0:	9f ef       	ldi	r25, 0xFF	; 255
    90e2:	af ef       	ldi	r26, 0xFF	; 255
    90e4:	bf e7       	ldi	r27, 0x7F	; 127
    90e6:	8f 87       	std	Y+15, r24	; 0x0f
    90e8:	98 8b       	std	Y+16, r25	; 0x10
    90ea:	a9 8b       	std	Y+17, r26	; 0x11
    90ec:	ba 8b       	std	Y+18, r27	; 0x12
    90ee:	8b 8b       	std	Y+19, r24	; 0x13
    90f0:	9c 8b       	std	Y+20, r25	; 0x14
    90f2:	ad 8b       	std	Y+21, r26	; 0x15
    90f4:	be 8b       	std	Y+22, r27	; 0x16
	PMDuint32 acceleration1, deceleration;
	PMDuint16 cuentas_encoder, micropasos,test;
	#endif
		
	/* Desactivar las interrupciones generadas por los PMDs*/
	HostInterruptDisable();	
    90f6:	0e 94 39 5f 	call	0xbe72	; 0xbe72 <HostInterruptDisable>
    90fa:	0f 2e       	mov	r0, r31
    90fc:	f0 e0       	ldi	r31, 0x00	; 0
    90fe:	2f 2e       	mov	r2, r31
    9100:	f0 e0       	ldi	r31, 0x00	; 0
    9102:	3f 2e       	mov	r3, r31
    9104:	f0 e0       	ldi	r31, 0x00	; 0
    9106:	4f 2e       	mov	r4, r31
    9108:	f0 e0       	ldi	r31, 0x00	; 0
    910a:	5f 2e       	mov	r5, r31
    910c:	f0 2d       	mov	r31, r0
    910e:	31 e0       	ldi	r19, 0x01	; 1
    9110:	63 2e       	mov	r6, r19
    9112:	71 2c       	mov	r7, r1
	
	
	
	for(Axis=AxisShoulder; Axis <= DOF; Axis++) 
	{	
		if(Axis==DOF)
    9114:	25 e0       	ldi	r18, 0x05	; 5
    9116:	62 16       	cp	r6, r18
    9118:	71 04       	cpc	r7, r1
    911a:	11 f4       	brne	.+4      	; 0x9120 <go_home+0x80>
    911c:	66 24       	eor	r6, r6
    911e:	77 24       	eor	r7, r7
			case (AxisRoll):
		    //fprintf_P(stderr,PSTR("Secuencia de HOME Roll \n"));  ;
		    break;	
		  
		}		
		printf("go_home=> --INICIO DE SECUENCIA DE HOME EJE %s--- \n ",AxisName(Axis));
    9120:	c3 01       	movw	r24, r6
    9122:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    9126:	00 d0       	rcall	.+0      	; 0x9128 <go_home+0x88>
    9128:	00 d0       	rcall	.+0      	; 0x912a <go_home+0x8a>
    912a:	e8 e1       	ldi	r30, 0x18	; 24
    912c:	fd e5       	ldi	r31, 0x5D	; 93
    912e:	ad b7       	in	r26, 0x3d	; 61
    9130:	be b7       	in	r27, 0x3e	; 62
    9132:	12 96       	adiw	r26, 0x02	; 2
    9134:	fc 93       	st	X, r31
    9136:	ee 93       	st	-X, r30
    9138:	11 97       	sbiw	r26, 0x01	; 1
    913a:	14 96       	adiw	r26, 0x04	; 4
    913c:	9c 93       	st	X, r25
    913e:	8e 93       	st	-X, r24
    9140:	13 97       	sbiw	r26, 0x03	; 3
    9142:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("Saltar eje, teclee 1\n ");
    9146:	0f 90       	pop	r0
    9148:	0f 90       	pop	r0
    914a:	ed e4       	ldi	r30, 0x4D	; 77
    914c:	fd e5       	ldi	r31, 0x5D	; 93
    914e:	ad b7       	in	r26, 0x3d	; 61
    9150:	be b7       	in	r27, 0x3e	; 62
    9152:	12 96       	adiw	r26, 0x02	; 2
    9154:	fc 93       	st	X, r31
    9156:	ee 93       	st	-X, r30
    9158:	11 97       	sbiw	r26, 0x01	; 1
    915a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		
		#ifdef DEBUGROBOTICS_HOME
		scanf("%d",&test);
    915e:	00 d0       	rcall	.+0      	; 0x9160 <go_home+0xc0>
    9160:	e4 e6       	ldi	r30, 0x64	; 100
    9162:	fd e5       	ldi	r31, 0x5D	; 93
    9164:	ad b7       	in	r26, 0x3d	; 61
    9166:	be b7       	in	r27, 0x3e	; 62
    9168:	12 96       	adiw	r26, 0x02	; 2
    916a:	fc 93       	st	X, r31
    916c:	ee 93       	st	-X, r30
    916e:	11 97       	sbiw	r26, 0x01	; 1
    9170:	29 e0       	ldi	r18, 0x09	; 9
    9172:	30 e0       	ldi	r19, 0x00	; 0
    9174:	2c 0f       	add	r18, r28
    9176:	3d 1f       	adc	r19, r29
    9178:	14 96       	adiw	r26, 0x04	; 4
    917a:	3c 93       	st	X, r19
    917c:	2e 93       	st	-X, r18
    917e:	13 97       	sbiw	r26, 0x03	; 3
    9180:	0e 94 49 89 	call	0x11292	; 0x11292 <scanf>
		#endif
		
		if(test!=1)
    9184:	0f 90       	pop	r0
    9186:	0f 90       	pop	r0
    9188:	0f 90       	pop	r0
    918a:	0f 90       	pop	r0
    918c:	89 85       	ldd	r24, Y+9	; 0x09
    918e:	9a 85       	ldd	r25, Y+10	; 0x0a
    9190:	01 97       	sbiw	r24, 0x01	; 1
    9192:	09 f4       	brne	.+2      	; 0x9196 <go_home+0xf6>
    9194:	2a c3       	rjmp	.+1620   	; 0x97ea <go_home+0x74a>
		{
			//-----------------------------------------------------------------------------------------------------
			// Busqueda el home.
			//-----------------------------------------------------------------------------------------------------
			switch(hAxis[Axis].axisSettings.homeSwitchHandling) 
    9196:	80 e6       	ldi	r24, 0x60	; 96
    9198:	90 e0       	ldi	r25, 0x00	; 0
    919a:	68 9e       	mul	r6, r24
    919c:	f0 01       	movw	r30, r0
    919e:	69 9e       	mul	r6, r25
    91a0:	f0 0d       	add	r31, r0
    91a2:	78 9e       	mul	r7, r24
    91a4:	f0 0d       	add	r31, r0
    91a6:	11 24       	eor	r1, r1
    91a8:	ec 58       	subi	r30, 0x8C	; 140
    91aa:	f2 48       	sbci	r31, 0x82	; 130
    91ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    91ae:	97 8d       	ldd	r25, Z+31	; 0x1f
    91b0:	00 97       	sbiw	r24, 0x00	; 0
    91b2:	09 f4       	brne	.+2      	; 0x91b6 <go_home+0x116>
    91b4:	75 c0       	rjmp	.+234    	; 0x92a0 <go_home+0x200>
    91b6:	81 30       	cpi	r24, 0x01	; 1
    91b8:	91 05       	cpc	r25, r1
    91ba:	e1 f1       	breq	.+120    	; 0x9234 <go_home+0x194>
    91bc:	8f 5f       	subi	r24, 0xFF	; 255
    91be:	9f 4f       	sbci	r25, 0xFF	; 255
    91c0:	09 f0       	breq	.+2      	; 0x91c4 <go_home+0x124>
    91c2:	13 c3       	rjmp	.+1574   	; 0x97ea <go_home+0x74a>
				case -1 : //Hombro
				{
					//Como el interuptor es desactivo por No_limit_switch(), 
					//ya no hay necesidad de entrar a el limite para volver a salir.
					//Mover el Eje en Direccion Negativa llegando al Limite Negativo
					search_home_negative(Axis,&home1,&minPos,FALSE);
    91c4:	c3 01       	movw	r24, r6
    91c6:	be 01       	movw	r22, r28
    91c8:	61 5f       	subi	r22, 0xF1	; 241
    91ca:	7f 4f       	sbci	r23, 0xFF	; 255
    91cc:	ae 01       	movw	r20, r28
    91ce:	49 5e       	subi	r20, 0xE9	; 233
    91d0:	5f 4f       	sbci	r21, 0xFF	; 255
    91d2:	20 e0       	ldi	r18, 0x00	; 0
    91d4:	30 e0       	ldi	r19, 0x00	; 0
    91d6:	0e 94 bb 44 	call	0x8976	; 0x8976 <search_home_negative>
					//Mover el Eje en Direccion Positiva parando cuando encuentre el HOME
					//Nunca lo va a encontrar porque al ejecutar No_limit_switch() no esta oprimido el interuptor.
					//search_home_positive(Axis,&home2,&maxPos,FALSE);	
					rad=grados2rad(AJUSTE_HOMBRO_HOME_NEGA);
    91da:	66 e6       	ldi	r22, 0x66	; 102
    91dc:	76 e6       	ldi	r23, 0x66	; 102
    91de:	86 ee       	ldi	r24, 0xE6	; 230
    91e0:	9f e3       	ldi	r25, 0x3F	; 63
    91e2:	0e 94 55 13 	call	0x26aa	; 0x26aa <grados2rad>
    91e6:	1b 01       	movw	r2, r22
    91e8:	2c 01       	movw	r4, r24
					Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    91ea:	c3 01       	movw	r24, r6
    91ec:	88 0f       	add	r24, r24
    91ee:	99 1f       	adc	r25, r25
    91f0:	86 0d       	add	r24, r6
    91f2:	97 1d       	adc	r25, r7
    91f4:	05 e0       	ldi	r16, 0x05	; 5
    91f6:	88 0f       	add	r24, r24
    91f8:	99 1f       	adc	r25, r25
    91fa:	0a 95       	dec	r16
    91fc:	e1 f7       	brne	.-8      	; 0x91f6 <go_home+0x156>
    91fe:	88 58       	subi	r24, 0x88	; 136
    9200:	92 48       	sbci	r25, 0x82	; 130
    9202:	b2 01       	movw	r22, r4
    9204:	a1 01       	movw	r20, r2
    9206:	0e 94 83 12 	call	0x2506	; 0x2506 <rad2usteps>
    920a:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    920e:	7b 01       	movw	r14, r22
    9210:	8c 01       	movw	r16, r24
					printf("go_home=> Factor de correcion %s (search_home_negative) en uPasos = %ld\n",AxisName(Axis),Correcion);
    9212:	c3 01       	movw	r24, r6
    9214:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    9218:	ad b7       	in	r26, 0x3d	; 61
    921a:	be b7       	in	r27, 0x3e	; 62
    921c:	18 97       	sbiw	r26, 0x08	; 8
    921e:	0f b6       	in	r0, 0x3f	; 63
    9220:	f8 94       	cli
    9222:	be bf       	out	0x3e, r27	; 62
    9224:	0f be       	out	0x3f, r0	; 63
    9226:	ad bf       	out	0x3d, r26	; 61
    9228:	ed b7       	in	r30, 0x3d	; 61
    922a:	fe b7       	in	r31, 0x3e	; 62
    922c:	31 96       	adiw	r30, 0x01	; 1
    922e:	27 e6       	ldi	r18, 0x67	; 103
    9230:	3d e5       	ldi	r19, 0x5D	; 93
    9232:	a4 c2       	rjmp	.+1352   	; 0x977c <go_home+0x6dc>
				}
				break;
				case  1 : //Codo y Pitch
				{
					//Mover el Eje en Direccion Positiva hasta llegar al Limite Positivo.
					search_home_positive(Axis,&home1,&maxPos,FALSE);
    9234:	c3 01       	movw	r24, r6
    9236:	be 01       	movw	r22, r28
    9238:	61 5f       	subi	r22, 0xF1	; 241
    923a:	7f 4f       	sbci	r23, 0xFF	; 255
    923c:	ae 01       	movw	r20, r28
    923e:	45 5e       	subi	r20, 0xE5	; 229
    9240:	5f 4f       	sbci	r21, 0xFF	; 255
    9242:	20 e0       	ldi	r18, 0x00	; 0
    9244:	30 e0       	ldi	r19, 0x00	; 0
    9246:	0e 94 1c 41 	call	0x8238	; 0x8238 <search_home_positive>
					//Mover el Eje en Direccion Negativa parando cuando encuentre el HOME
					//Nunca lo va a encontrar porque al ejecutar No_limit_switch() no esta oprimido el interuptor.
					//search_home_negative(Axis,&home2,&minPos,FALSE);				
					//home = home1;            // just use right limit
					if(Axis==AxisElbow)
    924a:	32 e0       	ldi	r19, 0x02	; 2
    924c:	63 16       	cp	r6, r19
    924e:	71 04       	cpc	r7, r1
    9250:	29 f4       	brne	.+10     	; 0x925c <go_home+0x1bc>
					{
						//-9700
						//home=home-9700;
						rad=grados2rad(AJUSTE_CODO_HOME_POSI);
    9252:	60 e0       	ldi	r22, 0x00	; 0
    9254:	70 e0       	ldi	r23, 0x00	; 0
    9256:	80 e2       	ldi	r24, 0x20	; 32
    9258:	90 ec       	ldi	r25, 0xC0	; 192
    925a:	08 c0       	rjmp	.+16     	; 0x926c <go_home+0x1cc>
						
					}	
					if(Axis==AxisPitch)
    925c:	83 e0       	ldi	r24, 0x03	; 3
    925e:	68 16       	cp	r6, r24
    9260:	71 04       	cpc	r7, r1
    9262:	41 f4       	brne	.+16     	; 0x9274 <go_home+0x1d4>
					{
						//-1100
						//home=home-1100;
						rad=grados2rad(AJUSTE_PITCH_HOME_POSI);
    9264:	60 e0       	ldi	r22, 0x00	; 0
    9266:	70 e0       	ldi	r23, 0x00	; 0
    9268:	88 e7       	ldi	r24, 0x78	; 120
    926a:	91 ec       	ldi	r25, 0xC1	; 193
    926c:	0e 94 55 13 	call	0x26aa	; 0x26aa <grados2rad>
    9270:	1b 01       	movw	r2, r22
    9272:	2c 01       	movw	r4, r24
					}
					
					Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    9274:	c3 01       	movw	r24, r6
    9276:	88 0f       	add	r24, r24
    9278:	99 1f       	adc	r25, r25
    927a:	86 0d       	add	r24, r6
    927c:	97 1d       	adc	r25, r7
    927e:	b5 e0       	ldi	r27, 0x05	; 5
    9280:	88 0f       	add	r24, r24
    9282:	99 1f       	adc	r25, r25
    9284:	ba 95       	dec	r27
    9286:	e1 f7       	brne	.-8      	; 0x9280 <go_home+0x1e0>
    9288:	88 58       	subi	r24, 0x88	; 136
    928a:	92 48       	sbci	r25, 0x82	; 130
    928c:	b2 01       	movw	r22, r4
    928e:	a1 01       	movw	r20, r2
    9290:	0e 94 83 12 	call	0x2506	; 0x2506 <rad2usteps>
    9294:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    9298:	7b 01       	movw	r14, r22
    929a:	8c 01       	movw	r16, r24
					printf("go_home=> Factor de correcion %s (search_home_positive) en uPasos = %ld\n",AxisName(Axis),Correcion);
    929c:	c3 01       	movw	r24, r6
    929e:	5f c2       	rjmp	.+1214   	; 0x975e <go_home+0x6be>
				{
					/*si las articulaciones (cintura) esta en home entonces no se realiza
					ningun procedimiento de busqueda de home y se asigna como home
					su posicion actual.*/
					
					if (Axis==AxisWaist)
    92a0:	61 14       	cp	r6, r1
    92a2:	71 04       	cpc	r7, r1
    92a4:	09 f0       	breq	.+2      	; 0x92a8 <go_home+0x208>
    92a6:	d8 c0       	rjmp	.+432    	; 0x9458 <go_home+0x3b8>
					{
						
						PMDGetSignalStatus(&hAxis[Axis], &signal_status);				
    92a8:	84 e7       	ldi	r24, 0x74	; 116
    92aa:	9d e7       	ldi	r25, 0x7D	; 125
    92ac:	be 01       	movw	r22, r28
    92ae:	6f 5f       	subi	r22, 0xFF	; 255
    92b0:	7f 4f       	sbci	r23, 0xFF	; 255
    92b2:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
						if((signal_status & PMDSignalEncoderHomeMask)==0) //si la articulacion esta en HOME
    92b6:	89 81       	ldd	r24, Y+1	; 0x01
    92b8:	83 fd       	sbrc	r24, 3
    92ba:	08 c0       	rjmp	.+16     	; 0x92cc <go_home+0x22c>
						{
							PMDGetActualPosition(&hAxis[Axis],&home);
    92bc:	84 e7       	ldi	r24, 0x74	; 116
    92be:	9d e7       	ldi	r25, 0x7D	; 125
    92c0:	be 01       	movw	r22, r28
    92c2:	65 5f       	subi	r22, 0xF5	; 245
    92c4:	7f 4f       	sbci	r23, 0xFF	; 255
    92c6:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
    92ca:	8f c2       	rjmp	.+1310   	; 0x97ea <go_home+0x74a>
						}
						else//si la articulacion no esta en HOME
						{
							//Mover el Eje en Direccion Negativa llegando al Limite Negativo
							search_home_negative(Axis,&home1,&minPos,FALSE);
    92cc:	80 e0       	ldi	r24, 0x00	; 0
    92ce:	90 e0       	ldi	r25, 0x00	; 0
    92d0:	be 01       	movw	r22, r28
    92d2:	61 5f       	subi	r22, 0xF1	; 241
    92d4:	7f 4f       	sbci	r23, 0xFF	; 255
    92d6:	ae 01       	movw	r20, r28
    92d8:	49 5e       	subi	r20, 0xE9	; 233
    92da:	5f 4f       	sbci	r21, 0xFF	; 255
    92dc:	20 e0       	ldi	r18, 0x00	; 0
    92de:	30 e0       	ldi	r19, 0x00	; 0
    92e0:	0e 94 bb 44 	call	0x8976	; 0x8976 <search_home_negative>
							//Si no se encuentra home
							if(home1==INF)
    92e4:	8f 85       	ldd	r24, Y+15	; 0x0f
    92e6:	98 89       	ldd	r25, Y+16	; 0x10
    92e8:	a9 89       	ldd	r26, Y+17	; 0x11
    92ea:	ba 89       	ldd	r27, Y+18	; 0x12
    92ec:	8f 5f       	subi	r24, 0xFF	; 255
    92ee:	9f 4f       	sbci	r25, 0xFF	; 255
    92f0:	af 4f       	sbci	r26, 0xFF	; 255
    92f2:	bf 47       	sbci	r27, 0x7F	; 127
    92f4:	09 f0       	breq	.+2      	; 0x92f8 <go_home+0x258>
    92f6:	56 c0       	rjmp	.+172    	; 0x93a4 <go_home+0x304>
							{	
								//Mover el Eje en Direccion Positiva hasta llegar al Limite Positivo
								search_home_positive(Axis,&home2,&maxPos,FALSE);
    92f8:	80 e0       	ldi	r24, 0x00	; 0
    92fa:	90 e0       	ldi	r25, 0x00	; 0
    92fc:	be 01       	movw	r22, r28
    92fe:	6d 5e       	subi	r22, 0xED	; 237
    9300:	7f 4f       	sbci	r23, 0xFF	; 255
    9302:	ae 01       	movw	r20, r28
    9304:	45 5e       	subi	r20, 0xE5	; 229
    9306:	5f 4f       	sbci	r21, 0xFF	; 255
    9308:	20 e0       	ldi	r18, 0x00	; 0
    930a:	30 e0       	ldi	r19, 0x00	; 0
    930c:	0e 94 1c 41 	call	0x8238	; 0x8238 <search_home_positive>
								rad=grados2rad(AJUSTE_CINTURA_HOME_POSI); //ok
    9310:	60 e0       	ldi	r22, 0x00	; 0
    9312:	70 e0       	ldi	r23, 0x00	; 0
    9314:	80 e0       	ldi	r24, 0x00	; 0
    9316:	9f e3       	ldi	r25, 0x3F	; 63
    9318:	0e 94 55 13 	call	0x26aa	; 0x26aa <grados2rad>
    931c:	1b 01       	movw	r2, r22
    931e:	2c 01       	movw	r4, r24
								Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    9320:	88 e7       	ldi	r24, 0x78	; 120
    9322:	9d e7       	ldi	r25, 0x7D	; 125
    9324:	b2 01       	movw	r22, r4
    9326:	a1 01       	movw	r20, r2
    9328:	0e 94 83 12 	call	0x2506	; 0x2506 <rad2usteps>
    932c:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    9330:	7b 01       	movw	r14, r22
    9332:	8c 01       	movw	r16, r24
								printf("go_home=> Factor de correcion %s (search_home_positive) en uPasos = %ld\n",AxisName(Axis),Correcion);
    9334:	80 e0       	ldi	r24, 0x00	; 0
    9336:	90 e0       	ldi	r25, 0x00	; 0
    9338:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    933c:	ad b7       	in	r26, 0x3d	; 61
    933e:	be b7       	in	r27, 0x3e	; 62
    9340:	18 97       	sbiw	r26, 0x08	; 8
    9342:	0f b6       	in	r0, 0x3f	; 63
    9344:	f8 94       	cli
    9346:	be bf       	out	0x3e, r27	; 62
    9348:	0f be       	out	0x3f, r0	; 63
    934a:	ad bf       	out	0x3d, r26	; 61
    934c:	ed b7       	in	r30, 0x3d	; 61
    934e:	fe b7       	in	r31, 0x3e	; 62
    9350:	31 96       	adiw	r30, 0x01	; 1
    9352:	27 ec       	ldi	r18, 0xC7	; 199
    9354:	3d e5       	ldi	r19, 0x5D	; 93
    9356:	12 96       	adiw	r26, 0x02	; 2
    9358:	3c 93       	st	X, r19
    935a:	2e 93       	st	-X, r18
    935c:	11 97       	sbiw	r26, 0x01	; 1
    935e:	93 83       	std	Z+3, r25	; 0x03
    9360:	82 83       	std	Z+2, r24	; 0x02
    9362:	e4 82       	std	Z+4, r14	; 0x04
    9364:	f5 82       	std	Z+5, r15	; 0x05
    9366:	06 83       	std	Z+6, r16	; 0x06
    9368:	17 83       	std	Z+7, r17	; 0x07
    936a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
								printf("go_home=> home2  = %ld\n",home2);
    936e:	0f 90       	pop	r0
    9370:	0f 90       	pop	r0
    9372:	e0 e1       	ldi	r30, 0x10	; 16
    9374:	fe e5       	ldi	r31, 0x5E	; 94
    9376:	ad b7       	in	r26, 0x3d	; 61
    9378:	be b7       	in	r27, 0x3e	; 62
    937a:	12 96       	adiw	r26, 0x02	; 2
    937c:	fc 93       	st	X, r31
    937e:	ee 93       	st	-X, r30
    9380:	11 97       	sbiw	r26, 0x01	; 1
    9382:	8b 89       	ldd	r24, Y+19	; 0x13
    9384:	9c 89       	ldd	r25, Y+20	; 0x14
    9386:	ad 89       	ldd	r26, Y+21	; 0x15
    9388:	be 89       	ldd	r27, Y+22	; 0x16
    938a:	ed b7       	in	r30, 0x3d	; 61
    938c:	fe b7       	in	r31, 0x3e	; 62
    938e:	83 83       	std	Z+3, r24	; 0x03
    9390:	94 83       	std	Z+4, r25	; 0x04
    9392:	a5 83       	std	Z+5, r26	; 0x05
    9394:	b6 83       	std	Z+6, r27	; 0x06
    9396:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
								home = home2+Correcion;
    939a:	8b 89       	ldd	r24, Y+19	; 0x13
    939c:	9c 89       	ldd	r25, Y+20	; 0x14
    939e:	ad 89       	ldd	r26, Y+21	; 0x15
    93a0:	be 89       	ldd	r27, Y+22	; 0x16
    93a2:	49 c0       	rjmp	.+146    	; 0x9436 <go_home+0x396>
							}
							else	
							{		
								rad=grados2rad(AJUSTE_CINTURA_HOME_NEGA);
    93a4:	6a e9       	ldi	r22, 0x9A	; 154
    93a6:	79 e9       	ldi	r23, 0x99	; 153
    93a8:	89 e1       	ldi	r24, 0x19	; 25
    93aa:	9f eb       	ldi	r25, 0xBF	; 191
    93ac:	0e 94 55 13 	call	0x26aa	; 0x26aa <grados2rad>
    93b0:	1b 01       	movw	r2, r22
    93b2:	2c 01       	movw	r4, r24
								Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    93b4:	88 e7       	ldi	r24, 0x78	; 120
    93b6:	9d e7       	ldi	r25, 0x7D	; 125
    93b8:	b2 01       	movw	r22, r4
    93ba:	a1 01       	movw	r20, r2
    93bc:	0e 94 83 12 	call	0x2506	; 0x2506 <rad2usteps>
    93c0:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    93c4:	7b 01       	movw	r14, r22
    93c6:	8c 01       	movw	r16, r24
								printf("go_home=> Factor de correcion %s (search_home_negative) en uPasos = %ld\n",AxisName(Axis),Correcion);
    93c8:	80 e0       	ldi	r24, 0x00	; 0
    93ca:	90 e0       	ldi	r25, 0x00	; 0
    93cc:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    93d0:	ad b7       	in	r26, 0x3d	; 61
    93d2:	be b7       	in	r27, 0x3e	; 62
    93d4:	18 97       	sbiw	r26, 0x08	; 8
    93d6:	0f b6       	in	r0, 0x3f	; 63
    93d8:	f8 94       	cli
    93da:	be bf       	out	0x3e, r27	; 62
    93dc:	0f be       	out	0x3f, r0	; 63
    93de:	ad bf       	out	0x3d, r26	; 61
    93e0:	ed b7       	in	r30, 0x3d	; 61
    93e2:	fe b7       	in	r31, 0x3e	; 62
    93e4:	31 96       	adiw	r30, 0x01	; 1
    93e6:	27 e6       	ldi	r18, 0x67	; 103
    93e8:	3d e5       	ldi	r19, 0x5D	; 93
    93ea:	12 96       	adiw	r26, 0x02	; 2
    93ec:	3c 93       	st	X, r19
    93ee:	2e 93       	st	-X, r18
    93f0:	11 97       	sbiw	r26, 0x01	; 1
    93f2:	93 83       	std	Z+3, r25	; 0x03
    93f4:	82 83       	std	Z+2, r24	; 0x02
    93f6:	e4 82       	std	Z+4, r14	; 0x04
    93f8:	f5 82       	std	Z+5, r15	; 0x05
    93fa:	06 83       	std	Z+6, r16	; 0x06
    93fc:	17 83       	std	Z+7, r17	; 0x07
    93fe:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
								printf("go_home=> home1 = %ld\n",home1);
    9402:	0f 90       	pop	r0
    9404:	0f 90       	pop	r0
    9406:	e0 eb       	ldi	r30, 0xB0	; 176
    9408:	fd e5       	ldi	r31, 0x5D	; 93
    940a:	ad b7       	in	r26, 0x3d	; 61
    940c:	be b7       	in	r27, 0x3e	; 62
    940e:	12 96       	adiw	r26, 0x02	; 2
    9410:	fc 93       	st	X, r31
    9412:	ee 93       	st	-X, r30
    9414:	11 97       	sbiw	r26, 0x01	; 1
    9416:	8f 85       	ldd	r24, Y+15	; 0x0f
    9418:	98 89       	ldd	r25, Y+16	; 0x10
    941a:	a9 89       	ldd	r26, Y+17	; 0x11
    941c:	ba 89       	ldd	r27, Y+18	; 0x12
    941e:	ed b7       	in	r30, 0x3d	; 61
    9420:	fe b7       	in	r31, 0x3e	; 62
    9422:	83 83       	std	Z+3, r24	; 0x03
    9424:	94 83       	std	Z+4, r25	; 0x04
    9426:	a5 83       	std	Z+5, r26	; 0x05
    9428:	b6 83       	std	Z+6, r27	; 0x06
    942a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
								home = home1+Correcion;		
    942e:	8f 85       	ldd	r24, Y+15	; 0x0f
    9430:	98 89       	ldd	r25, Y+16	; 0x10
    9432:	a9 89       	ldd	r26, Y+17	; 0x11
    9434:	ba 89       	ldd	r27, Y+18	; 0x12
    9436:	8e 0d       	add	r24, r14
    9438:	9f 1d       	adc	r25, r15
    943a:	a0 1f       	adc	r26, r16
    943c:	b1 1f       	adc	r27, r17
    943e:	8b 87       	std	Y+11, r24	; 0x0b
    9440:	9c 87       	std	Y+12, r25	; 0x0c
    9442:	ad 87       	std	Y+13, r26	; 0x0d
    9444:	be 87       	std	Y+14, r27	; 0x0e
    9446:	2d b7       	in	r18, 0x3d	; 61
    9448:	3e b7       	in	r19, 0x3e	; 62
    944a:	2a 5f       	subi	r18, 0xFA	; 250
    944c:	3f 4f       	sbci	r19, 0xFF	; 255
    944e:	0f b6       	in	r0, 0x3f	; 63
    9450:	f8 94       	cli
    9452:	3e bf       	out	0x3e, r19	; 62
    9454:	0f be       	out	0x3f, r0	; 63
    9456:	2d bf       	out	0x3d, r18	; 61
							}
							
						}
					}		
					if(Axis==AxisRoll)
    9458:	34 e0       	ldi	r19, 0x04	; 4
    945a:	63 16       	cp	r6, r19
    945c:	71 04       	cpc	r7, r1
    945e:	09 f0       	breq	.+2      	; 0x9462 <go_home+0x3c2>
    9460:	c4 c1       	rjmp	.+904    	; 0x97ea <go_home+0x74a>
					{
						
						// Leer el movimiento anterior de Roll que esta almacenado en EEPROM
						eeprom_read_block((void*)&Mov_Roll_Anterior_RAM,(const void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    9462:	ce 01       	movw	r24, r28
    9464:	87 96       	adiw	r24, 0x27	; 39
    9466:	66 e5       	ldi	r22, 0x56	; 86
    9468:	71 e0       	ldi	r23, 0x01	; 1
    946a:	44 e0       	ldi	r20, 0x04	; 4
    946c:	50 e0       	ldi	r21, 0x00	; 0
    946e:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
						#ifdef DEBUGROBOTICS_HOME
							printf("go_home=> El valor anterior de Roll = %ld\n",Mov_Roll_Anterior_RAM);		
    9472:	00 d0       	rcall	.+0      	; 0x9474 <go_home+0x3d4>
    9474:	00 d0       	rcall	.+0      	; 0x9476 <go_home+0x3d6>
    9476:	00 d0       	rcall	.+0      	; 0x9478 <go_home+0x3d8>
    9478:	e8 e2       	ldi	r30, 0x28	; 40
    947a:	fe e5       	ldi	r31, 0x5E	; 94
    947c:	ad b7       	in	r26, 0x3d	; 61
    947e:	be b7       	in	r27, 0x3e	; 62
    9480:	12 96       	adiw	r26, 0x02	; 2
    9482:	fc 93       	st	X, r31
    9484:	ee 93       	st	-X, r30
    9486:	11 97       	sbiw	r26, 0x01	; 1
    9488:	8f a1       	ldd	r24, Y+39	; 0x27
    948a:	98 a5       	ldd	r25, Y+40	; 0x28
    948c:	a9 a5       	ldd	r26, Y+41	; 0x29
    948e:	ba a5       	ldd	r27, Y+42	; 0x2a
    9490:	ed b7       	in	r30, 0x3d	; 61
    9492:	fe b7       	in	r31, 0x3e	; 62
    9494:	83 83       	std	Z+3, r24	; 0x03
    9496:	94 83       	std	Z+4, r25	; 0x04
    9498:	a5 83       	std	Z+5, r26	; 0x05
    949a:	b6 83       	std	Z+6, r27	; 0x06
    949c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
						#endif
						
						PMDGetSignalStatus(&hAxis[Axis], &signal_status);				
    94a0:	2d b7       	in	r18, 0x3d	; 61
    94a2:	3e b7       	in	r19, 0x3e	; 62
    94a4:	2a 5f       	subi	r18, 0xFA	; 250
    94a6:	3f 4f       	sbci	r19, 0xFF	; 255
    94a8:	0f b6       	in	r0, 0x3f	; 63
    94aa:	f8 94       	cli
    94ac:	3e bf       	out	0x3e, r19	; 62
    94ae:	0f be       	out	0x3f, r0	; 63
    94b0:	2d bf       	out	0x3d, r18	; 61
    94b2:	84 ef       	ldi	r24, 0xF4	; 244
    94b4:	9e e7       	ldi	r25, 0x7E	; 126
    94b6:	be 01       	movw	r22, r28
    94b8:	6f 5f       	subi	r22, 0xFF	; 255
    94ba:	7f 4f       	sbci	r23, 0xFF	; 255
    94bc:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
						//si la articulacion esta en HOME 
						if((signal_status & PMDSignalEncoderHomeMask)!=0)	 
    94c0:	89 81       	ldd	r24, Y+1	; 0x01
    94c2:	83 ff       	sbrs	r24, 3
    94c4:	21 c0       	rjmp	.+66     	; 0x9508 <go_home+0x468>
						{
							//Debo mover el roll para ajustar home con search_home_positive.
							roll(-15, hAxis[AxisRoll].axisSettings.homeVelocity,
    94c6:	20 91 34 7f 	lds	r18, 0x7F34
    94ca:	30 91 35 7f 	lds	r19, 0x7F35
    94ce:	40 91 36 7f 	lds	r20, 0x7F36
    94d2:	50 91 37 7f 	lds	r21, 0x7F37
    94d6:	e0 90 38 7f 	lds	r14, 0x7F38
    94da:	f0 90 39 7f 	lds	r15, 0x7F39
    94de:	00 91 3a 7f 	lds	r16, 0x7F3A
    94e2:	10 91 3b 7f 	lds	r17, 0x7F3B
    94e6:	61 ef       	ldi	r22, 0xF1	; 241
    94e8:	7f ef       	ldi	r23, 0xFF	; 255
    94ea:	8f ef       	ldi	r24, 0xFF	; 255
    94ec:	9f ef       	ldi	r25, 0xFF	; 255
    94ee:	a0 ef       	ldi	r26, 0xF0	; 240
    94f0:	ca 2e       	mov	r12, r26
    94f2:	af ef       	ldi	r26, 0xFF	; 255
    94f4:	da 2e       	mov	r13, r26
    94f6:	f3 e0       	ldi	r31, 0x03	; 3
    94f8:	af 2e       	mov	r10, r31
    94fa:	b1 2c       	mov	r11, r1
    94fc:	0e 94 8a 39 	call	0x7314	; 0x7314 <roll>
							hAxis[AxisRoll].axisSettings.homeAcceleration, update,EN_CALIBRACION_PROCESOHOME);
							Mov_Roll_Anterior_RAM=0;
    9500:	1f a2       	std	Y+39, r1	; 0x27
    9502:	18 a6       	std	Y+40, r1	; 0x28
    9504:	19 a6       	std	Y+41, r1	; 0x29
    9506:	1a a6       	std	Y+42, r1	; 0x2a
						}
						#ifdef DEBUGROBOTICS_HOME
							printf("go_home=>  El eje de Roll No esta en HOME\n");		
    9508:	83 e5       	ldi	r24, 0x53	; 83
    950a:	9e e5       	ldi	r25, 0x5E	; 94
    950c:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
						#endif
						//Caso Inicializacion (HOME ejecutado o reprogramacion)
						if(Mov_Roll_Anterior_RAM==0)
    9510:	8f a1       	ldd	r24, Y+39	; 0x27
    9512:	98 a5       	ldd	r25, Y+40	; 0x28
    9514:	a9 a5       	ldd	r26, Y+41	; 0x29
    9516:	ba a5       	ldd	r27, Y+42	; 0x2a
    9518:	00 97       	sbiw	r24, 0x00	; 0
    951a:	a1 05       	cpc	r26, r1
    951c:	b1 05       	cpc	r27, r1
    951e:	09 f0       	breq	.+2      	; 0x9522 <go_home+0x482>
    9520:	80 c0       	rjmp	.+256    	; 0x9622 <go_home+0x582>
						{
							search_home_roll_positive(&home1);
    9522:	ce 01       	movw	r24, r28
    9524:	0f 96       	adiw	r24, 0x0f	; 15
    9526:	0e 94 66 3a 	call	0x74cc	; 0x74cc <search_home_roll_positive>
							if(home1==INF) //que se cumplio el timer y no encontro home
    952a:	8f 85       	ldd	r24, Y+15	; 0x0f
    952c:	98 89       	ldd	r25, Y+16	; 0x10
    952e:	a9 89       	ldd	r26, Y+17	; 0x11
    9530:	ba 89       	ldd	r27, Y+18	; 0x12
    9532:	8f 3f       	cpi	r24, 0xFF	; 255
    9534:	3f ef       	ldi	r19, 0xFF	; 255
    9536:	93 07       	cpc	r25, r19
    9538:	3f ef       	ldi	r19, 0xFF	; 255
    953a:	a3 07       	cpc	r26, r19
    953c:	3f e7       	ldi	r19, 0x7F	; 127
    953e:	b3 07       	cpc	r27, r19
    9540:	09 f0       	breq	.+2      	; 0x9544 <go_home+0x4a4>
    9542:	6b c0       	rjmp	.+214    	; 0x961a <go_home+0x57a>
							{
								printf("go_home=> caso home1==INF\n");
    9544:	8d e7       	ldi	r24, 0x7D	; 125
    9546:	9e e5       	ldi	r25, 0x5E	; 94
    9548:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
								search_home_negative(Axis,&home1,&minPos,FALSE);//mover en direcion negativa y hallar Home
    954c:	84 e0       	ldi	r24, 0x04	; 4
    954e:	90 e0       	ldi	r25, 0x00	; 0
    9550:	be 01       	movw	r22, r28
    9552:	61 5f       	subi	r22, 0xF1	; 241
    9554:	7f 4f       	sbci	r23, 0xFF	; 255
    9556:	ae 01       	movw	r20, r28
    9558:	49 5e       	subi	r20, 0xE9	; 233
    955a:	5f 4f       	sbci	r21, 0xFF	; 255
    955c:	20 e0       	ldi	r18, 0x00	; 0
    955e:	30 e0       	ldi	r19, 0x00	; 0
    9560:	0e 94 bb 44 	call	0x8976	; 0x8976 <search_home_negative>
								rad=grados2rad(AJUSTE_ROLL_HOME_NEGA);
    9564:	60 e0       	ldi	r22, 0x00	; 0
    9566:	70 e0       	ldi	r23, 0x00	; 0
    9568:	80 ea       	ldi	r24, 0xA0	; 160
    956a:	91 e4       	ldi	r25, 0x41	; 65
    956c:	0e 94 55 13 	call	0x26aa	; 0x26aa <grados2rad>
    9570:	1b 01       	movw	r2, r22
    9572:	2c 01       	movw	r4, r24
								Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    9574:	88 ef       	ldi	r24, 0xF8	; 248
    9576:	9e e7       	ldi	r25, 0x7E	; 126
    9578:	b2 01       	movw	r22, r4
    957a:	a1 01       	movw	r20, r2
    957c:	0e 94 83 12 	call	0x2506	; 0x2506 <rad2usteps>
    9580:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    9584:	7b 01       	movw	r14, r22
    9586:	8c 01       	movw	r16, r24
								printf("go_home=> Factor de correcion %s (search_home_negative) en uPasos = %ld\n",AxisName(Axis),Correcion);
    9588:	84 e0       	ldi	r24, 0x04	; 4
    958a:	90 e0       	ldi	r25, 0x00	; 0
    958c:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    9590:	ad b7       	in	r26, 0x3d	; 61
    9592:	be b7       	in	r27, 0x3e	; 62
    9594:	18 97       	sbiw	r26, 0x08	; 8
    9596:	0f b6       	in	r0, 0x3f	; 63
    9598:	f8 94       	cli
    959a:	be bf       	out	0x3e, r27	; 62
    959c:	0f be       	out	0x3f, r0	; 63
    959e:	ad bf       	out	0x3d, r26	; 61
    95a0:	ed b7       	in	r30, 0x3d	; 61
    95a2:	fe b7       	in	r31, 0x3e	; 62
    95a4:	31 96       	adiw	r30, 0x01	; 1
    95a6:	27 e6       	ldi	r18, 0x67	; 103
    95a8:	3d e5       	ldi	r19, 0x5D	; 93
    95aa:	12 96       	adiw	r26, 0x02	; 2
    95ac:	3c 93       	st	X, r19
    95ae:	2e 93       	st	-X, r18
    95b0:	11 97       	sbiw	r26, 0x01	; 1
    95b2:	93 83       	std	Z+3, r25	; 0x03
    95b4:	82 83       	std	Z+2, r24	; 0x02
    95b6:	e4 82       	std	Z+4, r14	; 0x04
    95b8:	f5 82       	std	Z+5, r15	; 0x05
    95ba:	06 83       	std	Z+6, r16	; 0x06
    95bc:	17 83       	std	Z+7, r17	; 0x07
    95be:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
								printf("go_home=> home1 = %ld\n",home1);
    95c2:	0f 90       	pop	r0
    95c4:	0f 90       	pop	r0
    95c6:	e0 eb       	ldi	r30, 0xB0	; 176
    95c8:	fd e5       	ldi	r31, 0x5D	; 93
    95ca:	ad b7       	in	r26, 0x3d	; 61
    95cc:	be b7       	in	r27, 0x3e	; 62
    95ce:	12 96       	adiw	r26, 0x02	; 2
    95d0:	fc 93       	st	X, r31
    95d2:	ee 93       	st	-X, r30
    95d4:	11 97       	sbiw	r26, 0x01	; 1
    95d6:	8f 85       	ldd	r24, Y+15	; 0x0f
    95d8:	98 89       	ldd	r25, Y+16	; 0x10
    95da:	a9 89       	ldd	r26, Y+17	; 0x11
    95dc:	ba 89       	ldd	r27, Y+18	; 0x12
    95de:	ed b7       	in	r30, 0x3d	; 61
    95e0:	fe b7       	in	r31, 0x3e	; 62
    95e2:	83 83       	std	Z+3, r24	; 0x03
    95e4:	94 83       	std	Z+4, r25	; 0x04
    95e6:	a5 83       	std	Z+5, r26	; 0x05
    95e8:	b6 83       	std	Z+6, r27	; 0x06
    95ea:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
								home = home1+Correcion;		
    95ee:	8f 85       	ldd	r24, Y+15	; 0x0f
    95f0:	98 89       	ldd	r25, Y+16	; 0x10
    95f2:	a9 89       	ldd	r26, Y+17	; 0x11
    95f4:	ba 89       	ldd	r27, Y+18	; 0x12
    95f6:	8e 0d       	add	r24, r14
    95f8:	9f 1d       	adc	r25, r15
    95fa:	a0 1f       	adc	r26, r16
    95fc:	b1 1f       	adc	r27, r17
    95fe:	8b 87       	std	Y+11, r24	; 0x0b
    9600:	9c 87       	std	Y+12, r25	; 0x0c
    9602:	ad 87       	std	Y+13, r26	; 0x0d
    9604:	be 87       	std	Y+14, r27	; 0x0e
    9606:	2d b7       	in	r18, 0x3d	; 61
    9608:	3e b7       	in	r19, 0x3e	; 62
    960a:	2a 5f       	subi	r18, 0xFA	; 250
    960c:	3f 4f       	sbci	r19, 0xFF	; 255
    960e:	0f b6       	in	r0, 0x3f	; 63
    9610:	f8 94       	cli
    9612:	3e bf       	out	0x3e, r19	; 62
    9614:	0f be       	out	0x3f, r0	; 63
    9616:	2d bf       	out	0x3d, r18	; 61
    9618:	04 c0       	rjmp	.+8      	; 0x9622 <go_home+0x582>
							}
							else
							{
								home = home1;
    961a:	8b 87       	std	Y+11, r24	; 0x0b
    961c:	9c 87       	std	Y+12, r25	; 0x0c
    961e:	ad 87       	std	Y+13, r26	; 0x0d
    9620:	be 87       	std	Y+14, r27	; 0x0e
							}
						}
						
						//Verifico el signo del movimiento anterior
						if (Mov_Roll_Anterior_RAM > 0)// Positivo
    9622:	8f a1       	ldd	r24, Y+39	; 0x27
    9624:	98 a5       	ldd	r25, Y+40	; 0x28
    9626:	a9 a5       	ldd	r26, Y+41	; 0x29
    9628:	ba a5       	ldd	r27, Y+42	; 0x2a
    962a:	18 16       	cp	r1, r24
    962c:	19 06       	cpc	r1, r25
    962e:	1a 06       	cpc	r1, r26
    9630:	1b 06       	cpc	r1, r27
    9632:	0c f0       	brlt	.+2      	; 0x9636 <go_home+0x596>
    9634:	6a c0       	rjmp	.+212    	; 0x970a <go_home+0x66a>
						{
							printf("go_home=> caso Mov_Roll_Anterior_RAM > 0\n");
    9636:	87 e9       	ldi	r24, 0x97	; 151
    9638:	9e e5       	ldi	r25, 0x5E	; 94
    963a:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
							search_home_negative(Axis,&home1,&minPos,FALSE);
    963e:	84 e0       	ldi	r24, 0x04	; 4
    9640:	90 e0       	ldi	r25, 0x00	; 0
    9642:	be 01       	movw	r22, r28
    9644:	61 5f       	subi	r22, 0xF1	; 241
    9646:	7f 4f       	sbci	r23, 0xFF	; 255
    9648:	ae 01       	movw	r20, r28
    964a:	49 5e       	subi	r20, 0xE9	; 233
    964c:	5f 4f       	sbci	r21, 0xFF	; 255
    964e:	20 e0       	ldi	r18, 0x00	; 0
    9650:	30 e0       	ldi	r19, 0x00	; 0
    9652:	0e 94 bb 44 	call	0x8976	; 0x8976 <search_home_negative>
							rad=grados2rad(AJUSTE_ROLL_HOME_NEGA);
    9656:	60 e0       	ldi	r22, 0x00	; 0
    9658:	70 e0       	ldi	r23, 0x00	; 0
    965a:	80 ea       	ldi	r24, 0xA0	; 160
    965c:	91 e4       	ldi	r25, 0x41	; 65
    965e:	0e 94 55 13 	call	0x26aa	; 0x26aa <grados2rad>
    9662:	1b 01       	movw	r2, r22
    9664:	2c 01       	movw	r4, r24
							Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    9666:	88 ef       	ldi	r24, 0xF8	; 248
    9668:	9e e7       	ldi	r25, 0x7E	; 126
    966a:	b2 01       	movw	r22, r4
    966c:	a1 01       	movw	r20, r2
    966e:	0e 94 83 12 	call	0x2506	; 0x2506 <rad2usteps>
    9672:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    9676:	7b 01       	movw	r14, r22
    9678:	8c 01       	movw	r16, r24
							printf("go_home=> Factor de correcion %s (search_home_negative) en uPasos = %ld\n",AxisName(Axis),Correcion);
    967a:	84 e0       	ldi	r24, 0x04	; 4
    967c:	90 e0       	ldi	r25, 0x00	; 0
    967e:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    9682:	ad b7       	in	r26, 0x3d	; 61
    9684:	be b7       	in	r27, 0x3e	; 62
    9686:	18 97       	sbiw	r26, 0x08	; 8
    9688:	0f b6       	in	r0, 0x3f	; 63
    968a:	f8 94       	cli
    968c:	be bf       	out	0x3e, r27	; 62
    968e:	0f be       	out	0x3f, r0	; 63
    9690:	ad bf       	out	0x3d, r26	; 61
    9692:	ed b7       	in	r30, 0x3d	; 61
    9694:	fe b7       	in	r31, 0x3e	; 62
    9696:	31 96       	adiw	r30, 0x01	; 1
    9698:	27 e6       	ldi	r18, 0x67	; 103
    969a:	3d e5       	ldi	r19, 0x5D	; 93
    969c:	12 96       	adiw	r26, 0x02	; 2
    969e:	3c 93       	st	X, r19
    96a0:	2e 93       	st	-X, r18
    96a2:	11 97       	sbiw	r26, 0x01	; 1
    96a4:	93 83       	std	Z+3, r25	; 0x03
    96a6:	82 83       	std	Z+2, r24	; 0x02
    96a8:	e4 82       	std	Z+4, r14	; 0x04
    96aa:	f5 82       	std	Z+5, r15	; 0x05
    96ac:	06 83       	std	Z+6, r16	; 0x06
    96ae:	17 83       	std	Z+7, r17	; 0x07
    96b0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
							printf("go_home=> home1 = %ld\n",home1);
    96b4:	0f 90       	pop	r0
    96b6:	0f 90       	pop	r0
    96b8:	e0 eb       	ldi	r30, 0xB0	; 176
    96ba:	fd e5       	ldi	r31, 0x5D	; 93
    96bc:	ad b7       	in	r26, 0x3d	; 61
    96be:	be b7       	in	r27, 0x3e	; 62
    96c0:	12 96       	adiw	r26, 0x02	; 2
    96c2:	fc 93       	st	X, r31
    96c4:	ee 93       	st	-X, r30
    96c6:	11 97       	sbiw	r26, 0x01	; 1
    96c8:	8f 85       	ldd	r24, Y+15	; 0x0f
    96ca:	98 89       	ldd	r25, Y+16	; 0x10
    96cc:	a9 89       	ldd	r26, Y+17	; 0x11
    96ce:	ba 89       	ldd	r27, Y+18	; 0x12
    96d0:	ed b7       	in	r30, 0x3d	; 61
    96d2:	fe b7       	in	r31, 0x3e	; 62
    96d4:	83 83       	std	Z+3, r24	; 0x03
    96d6:	94 83       	std	Z+4, r25	; 0x04
    96d8:	a5 83       	std	Z+5, r26	; 0x05
    96da:	b6 83       	std	Z+6, r27	; 0x06
    96dc:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
							home = home1-Correcion;		
    96e0:	8f 85       	ldd	r24, Y+15	; 0x0f
    96e2:	98 89       	ldd	r25, Y+16	; 0x10
    96e4:	a9 89       	ldd	r26, Y+17	; 0x11
    96e6:	ba 89       	ldd	r27, Y+18	; 0x12
    96e8:	8e 19       	sub	r24, r14
    96ea:	9f 09       	sbc	r25, r15
    96ec:	a0 0b       	sbc	r26, r16
    96ee:	b1 0b       	sbc	r27, r17
    96f0:	8b 87       	std	Y+11, r24	; 0x0b
    96f2:	9c 87       	std	Y+12, r25	; 0x0c
    96f4:	ad 87       	std	Y+13, r26	; 0x0d
    96f6:	be 87       	std	Y+14, r27	; 0x0e
    96f8:	2d b7       	in	r18, 0x3d	; 61
    96fa:	3e b7       	in	r19, 0x3e	; 62
    96fc:	2a 5f       	subi	r18, 0xFA	; 250
    96fe:	3f 4f       	sbci	r19, 0xFF	; 255
    9700:	0f b6       	in	r0, 0x3f	; 63
    9702:	f8 94       	cli
    9704:	3e bf       	out	0x3e, r19	; 62
    9706:	0f be       	out	0x3f, r0	; 63
    9708:	2d bf       	out	0x3d, r18	; 61
							
						}
						
						if (Mov_Roll_Anterior_RAM < 0) // Negativo
    970a:	8f a1       	ldd	r24, Y+39	; 0x27
    970c:	98 a5       	ldd	r25, Y+40	; 0x28
    970e:	a9 a5       	ldd	r26, Y+41	; 0x29
    9710:	ba a5       	ldd	r27, Y+42	; 0x2a
    9712:	b7 ff       	sbrs	r27, 7
    9714:	6a c0       	rjmp	.+212    	; 0x97ea <go_home+0x74a>
						{
							printf("go_home=> caso Mov_Roll_Anterior_RAM < 0\n");
    9716:	80 ec       	ldi	r24, 0xC0	; 192
    9718:	9e e5       	ldi	r25, 0x5E	; 94
    971a:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
							search_home_positive(Axis,&home1,&maxPos,FALSE);
    971e:	84 e0       	ldi	r24, 0x04	; 4
    9720:	90 e0       	ldi	r25, 0x00	; 0
    9722:	be 01       	movw	r22, r28
    9724:	61 5f       	subi	r22, 0xF1	; 241
    9726:	7f 4f       	sbci	r23, 0xFF	; 255
    9728:	ae 01       	movw	r20, r28
    972a:	45 5e       	subi	r20, 0xE5	; 229
    972c:	5f 4f       	sbci	r21, 0xFF	; 255
    972e:	20 e0       	ldi	r18, 0x00	; 0
    9730:	30 e0       	ldi	r19, 0x00	; 0
    9732:	0e 94 1c 41 	call	0x8238	; 0x8238 <search_home_positive>
							rad=grados2rad(AJUSTE_ROLL_HOME_POSI);
    9736:	60 e0       	ldi	r22, 0x00	; 0
    9738:	70 e0       	ldi	r23, 0x00	; 0
    973a:	80 e0       	ldi	r24, 0x00	; 0
    973c:	91 ec       	ldi	r25, 0xC1	; 193
    973e:	0e 94 55 13 	call	0x26aa	; 0x26aa <grados2rad>
    9742:	1b 01       	movw	r2, r22
    9744:	2c 01       	movw	r4, r24
							Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    9746:	88 ef       	ldi	r24, 0xF8	; 248
    9748:	9e e7       	ldi	r25, 0x7E	; 126
    974a:	b2 01       	movw	r22, r4
    974c:	a1 01       	movw	r20, r2
    974e:	0e 94 83 12 	call	0x2506	; 0x2506 <rad2usteps>
    9752:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    9756:	7b 01       	movw	r14, r22
    9758:	8c 01       	movw	r16, r24
							printf("go_home=> Factor de correcion %s (search_home_positive) en uPasos = %ld\n",AxisName(Axis),Correcion);
    975a:	84 e0       	ldi	r24, 0x04	; 4
    975c:	90 e0       	ldi	r25, 0x00	; 0
    975e:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    9762:	ad b7       	in	r26, 0x3d	; 61
    9764:	be b7       	in	r27, 0x3e	; 62
    9766:	18 97       	sbiw	r26, 0x08	; 8
    9768:	0f b6       	in	r0, 0x3f	; 63
    976a:	f8 94       	cli
    976c:	be bf       	out	0x3e, r27	; 62
    976e:	0f be       	out	0x3f, r0	; 63
    9770:	ad bf       	out	0x3d, r26	; 61
    9772:	ed b7       	in	r30, 0x3d	; 61
    9774:	fe b7       	in	r31, 0x3e	; 62
    9776:	31 96       	adiw	r30, 0x01	; 1
    9778:	27 ec       	ldi	r18, 0xC7	; 199
    977a:	3d e5       	ldi	r19, 0x5D	; 93
    977c:	12 96       	adiw	r26, 0x02	; 2
    977e:	3c 93       	st	X, r19
    9780:	2e 93       	st	-X, r18
    9782:	11 97       	sbiw	r26, 0x01	; 1
    9784:	93 83       	std	Z+3, r25	; 0x03
    9786:	82 83       	std	Z+2, r24	; 0x02
    9788:	e4 82       	std	Z+4, r14	; 0x04
    978a:	f5 82       	std	Z+5, r15	; 0x05
    978c:	06 83       	std	Z+6, r16	; 0x06
    978e:	17 83       	std	Z+7, r17	; 0x07
    9790:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
							printf("go_home=> home1 = %ld\n",home1);
    9794:	0f 90       	pop	r0
    9796:	0f 90       	pop	r0
    9798:	e0 eb       	ldi	r30, 0xB0	; 176
    979a:	fd e5       	ldi	r31, 0x5D	; 93
    979c:	ad b7       	in	r26, 0x3d	; 61
    979e:	be b7       	in	r27, 0x3e	; 62
    97a0:	12 96       	adiw	r26, 0x02	; 2
    97a2:	fc 93       	st	X, r31
    97a4:	ee 93       	st	-X, r30
    97a6:	11 97       	sbiw	r26, 0x01	; 1
    97a8:	8f 85       	ldd	r24, Y+15	; 0x0f
    97aa:	98 89       	ldd	r25, Y+16	; 0x10
    97ac:	a9 89       	ldd	r26, Y+17	; 0x11
    97ae:	ba 89       	ldd	r27, Y+18	; 0x12
    97b0:	ed b7       	in	r30, 0x3d	; 61
    97b2:	fe b7       	in	r31, 0x3e	; 62
    97b4:	83 83       	std	Z+3, r24	; 0x03
    97b6:	94 83       	std	Z+4, r25	; 0x04
    97b8:	a5 83       	std	Z+5, r26	; 0x05
    97ba:	b6 83       	std	Z+6, r27	; 0x06
    97bc:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
							home = home1+Correcion;		
    97c0:	8f 85       	ldd	r24, Y+15	; 0x0f
    97c2:	98 89       	ldd	r25, Y+16	; 0x10
    97c4:	a9 89       	ldd	r26, Y+17	; 0x11
    97c6:	ba 89       	ldd	r27, Y+18	; 0x12
    97c8:	8e 0d       	add	r24, r14
    97ca:	9f 1d       	adc	r25, r15
    97cc:	a0 1f       	adc	r26, r16
    97ce:	b1 1f       	adc	r27, r17
    97d0:	8b 87       	std	Y+11, r24	; 0x0b
    97d2:	9c 87       	std	Y+12, r25	; 0x0c
    97d4:	ad 87       	std	Y+13, r26	; 0x0d
    97d6:	be 87       	std	Y+14, r27	; 0x0e
    97d8:	2d b7       	in	r18, 0x3d	; 61
    97da:	3e b7       	in	r19, 0x3e	; 62
    97dc:	2a 5f       	subi	r18, 0xFA	; 250
    97de:	3f 4f       	sbci	r19, 0xFF	; 255
    97e0:	0f b6       	in	r0, 0x3f	; 63
    97e2:	f8 94       	cli
    97e4:	3e bf       	out	0x3e, r19	; 62
    97e6:	0f be       	out	0x3f, r0	; 63
    97e8:	2d bf       	out	0x3d, r18	; 61
		//-----------------------------------------------------------------------------------------------------
		//Mover el eje al home encontrado + la correcion.
		//Necesitamos que el concodificador tenga el valor de home para los calculos de PMDAdjustActualPosition.
		//-----------------------------------------------------------------------------------------------------
		#ifdef DEBUGROBOTICS_HOME
		printf("go_home=> El valor de home encontrado! del eje %s = %ld. \n ",AxisName(Axis),home);
    97ea:	c3 01       	movw	r24, r6
    97ec:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    97f0:	ad b7       	in	r26, 0x3d	; 61
    97f2:	be b7       	in	r27, 0x3e	; 62
    97f4:	18 97       	sbiw	r26, 0x08	; 8
    97f6:	0f b6       	in	r0, 0x3f	; 63
    97f8:	f8 94       	cli
    97fa:	be bf       	out	0x3e, r27	; 62
    97fc:	0f be       	out	0x3f, r0	; 63
    97fe:	ad bf       	out	0x3d, r26	; 61
    9800:	ed b7       	in	r30, 0x3d	; 61
    9802:	fe b7       	in	r31, 0x3e	; 62
    9804:	31 96       	adiw	r30, 0x01	; 1
    9806:	29 ee       	ldi	r18, 0xE9	; 233
    9808:	3e e5       	ldi	r19, 0x5E	; 94
    980a:	12 96       	adiw	r26, 0x02	; 2
    980c:	3c 93       	st	X, r19
    980e:	2e 93       	st	-X, r18
    9810:	11 97       	sbiw	r26, 0x01	; 1
    9812:	93 83       	std	Z+3, r25	; 0x03
    9814:	82 83       	std	Z+2, r24	; 0x02
    9816:	8b 85       	ldd	r24, Y+11	; 0x0b
    9818:	9c 85       	ldd	r25, Y+12	; 0x0c
    981a:	ad 85       	ldd	r26, Y+13	; 0x0d
    981c:	be 85       	ldd	r27, Y+14	; 0x0e
    981e:	84 83       	std	Z+4, r24	; 0x04
    9820:	95 83       	std	Z+5, r25	; 0x05
    9822:	a6 83       	std	Z+6, r26	; 0x06
    9824:	b7 83       	std	Z+7, r27	; 0x07
    9826:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("go_home=> Moviendo el Eje %s hacia home \n ",AxisName(Axis));
    982a:	8d b7       	in	r24, 0x3d	; 61
    982c:	9e b7       	in	r25, 0x3e	; 62
    982e:	08 96       	adiw	r24, 0x08	; 8
    9830:	0f b6       	in	r0, 0x3f	; 63
    9832:	f8 94       	cli
    9834:	9e bf       	out	0x3e, r25	; 62
    9836:	0f be       	out	0x3f, r0	; 63
    9838:	8d bf       	out	0x3d, r24	; 61
    983a:	c3 01       	movw	r24, r6
    983c:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    9840:	00 d0       	rcall	.+0      	; 0x9842 <go_home+0x7a2>
    9842:	00 d0       	rcall	.+0      	; 0x9844 <go_home+0x7a4>
    9844:	e5 e2       	ldi	r30, 0x25	; 37
    9846:	ff e5       	ldi	r31, 0x5F	; 95
    9848:	ad b7       	in	r26, 0x3d	; 61
    984a:	be b7       	in	r27, 0x3e	; 62
    984c:	12 96       	adiw	r26, 0x02	; 2
    984e:	fc 93       	st	X, r31
    9850:	ee 93       	st	-X, r30
    9852:	11 97       	sbiw	r26, 0x01	; 1
    9854:	14 96       	adiw	r26, 0x04	; 4
    9856:	9c 93       	st	X, r25
    9858:	8e 93       	st	-X, r24
    985a:	13 97       	sbiw	r26, 0x03	; 3
    985c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		//scanf("%d",&test);
		#endif
		if(home!=INF)
    9860:	8b 84       	ldd	r8, Y+11	; 0x0b
    9862:	9c 84       	ldd	r9, Y+12	; 0x0c
    9864:	ad 84       	ldd	r10, Y+13	; 0x0d
    9866:	be 84       	ldd	r11, Y+14	; 0x0e
    9868:	0f 90       	pop	r0
    986a:	0f 90       	pop	r0
    986c:	0f 90       	pop	r0
    986e:	0f 90       	pop	r0
    9870:	ff ef       	ldi	r31, 0xFF	; 255
    9872:	8f 16       	cp	r8, r31
    9874:	ff ef       	ldi	r31, 0xFF	; 255
    9876:	9f 06       	cpc	r9, r31
    9878:	ff ef       	ldi	r31, 0xFF	; 255
    987a:	af 06       	cpc	r10, r31
    987c:	ff e7       	ldi	r31, 0x7F	; 127
    987e:	bf 06       	cpc	r11, r31
    9880:	09 f4       	brne	.+2      	; 0x9884 <go_home+0x7e4>
    9882:	5f c0       	rjmp	.+190    	; 0x9942 <go_home+0x8a2>
		{
			switch (Axis)
    9884:	23 e0       	ldi	r18, 0x03	; 3
    9886:	62 16       	cp	r6, r18
    9888:	71 04       	cpc	r7, r1
    988a:	29 f0       	breq	.+10     	; 0x9896 <go_home+0x7f6>
    988c:	34 e0       	ldi	r19, 0x04	; 4
    988e:	63 16       	cp	r6, r19
    9890:	71 04       	cpc	r7, r1
    9892:	c9 f5       	brne	.+114    	; 0x9906 <go_home+0x866>
    9894:	1c c0       	rjmp	.+56     	; 0x98ce <go_home+0x82e>
			{
				case (AxisPitch):	
					pitch(home,hAxis[Axis].axisSettings.homeVelocity,
    9896:	20 91 d4 7e 	lds	r18, 0x7ED4
    989a:	30 91 d5 7e 	lds	r19, 0x7ED5
    989e:	40 91 d6 7e 	lds	r20, 0x7ED6
    98a2:	50 91 d7 7e 	lds	r21, 0x7ED7
    98a6:	e0 90 d8 7e 	lds	r14, 0x7ED8
    98aa:	f0 90 d9 7e 	lds	r15, 0x7ED9
    98ae:	00 91 da 7e 	lds	r16, 0x7EDA
    98b2:	10 91 db 7e 	lds	r17, 0x7EDB
    98b6:	c5 01       	movw	r24, r10
    98b8:	b4 01       	movw	r22, r8
    98ba:	e0 ef       	ldi	r30, 0xF0	; 240
    98bc:	ce 2e       	mov	r12, r30
    98be:	ef ef       	ldi	r30, 0xFF	; 255
    98c0:	de 2e       	mov	r13, r30
    98c2:	b2 e0       	ldi	r27, 0x02	; 2
    98c4:	ab 2e       	mov	r10, r27
    98c6:	b1 2c       	mov	r11, r1
    98c8:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <pitch>
    98cc:	3a c0       	rjmp	.+116    	; 0x9942 <go_home+0x8a2>
						hAxis[Axis].axisSettings.homeAcceleration,update,MOVIMIENTO_HACIA_HOME ); 
				break;
				case (AxisRoll):
					roll(home,hAxis[Axis].axisSettings.homeVelocity,
    98ce:	20 91 34 7f 	lds	r18, 0x7F34
    98d2:	30 91 35 7f 	lds	r19, 0x7F35
    98d6:	40 91 36 7f 	lds	r20, 0x7F36
    98da:	50 91 37 7f 	lds	r21, 0x7F37
    98de:	e0 90 38 7f 	lds	r14, 0x7F38
    98e2:	f0 90 39 7f 	lds	r15, 0x7F39
    98e6:	00 91 3a 7f 	lds	r16, 0x7F3A
    98ea:	10 91 3b 7f 	lds	r17, 0x7F3B
    98ee:	c5 01       	movw	r24, r10
    98f0:	b4 01       	movw	r22, r8
    98f2:	a0 ef       	ldi	r26, 0xF0	; 240
    98f4:	ca 2e       	mov	r12, r26
    98f6:	af ef       	ldi	r26, 0xFF	; 255
    98f8:	da 2e       	mov	r13, r26
    98fa:	f2 e0       	ldi	r31, 0x02	; 2
    98fc:	af 2e       	mov	r10, r31
    98fe:	b1 2c       	mov	r11, r1
    9900:	0e 94 8a 39 	call	0x7314	; 0x7314 <roll>
    9904:	1e c0       	rjmp	.+60     	; 0x9942 <go_home+0x8a2>
						hAxis[Axis].axisSettings.homeAcceleration,update,MOVIMIENTO_HACIA_HOME );	
				break;
				default:
					mov_axis(Axis,home,hAxis[Axis].axisSettings.homeVelocity,
    9906:	80 e6       	ldi	r24, 0x60	; 96
    9908:	90 e0       	ldi	r25, 0x00	; 0
    990a:	68 9e       	mul	r6, r24
    990c:	f0 01       	movw	r30, r0
    990e:	69 9e       	mul	r6, r25
    9910:	f0 0d       	add	r31, r0
    9912:	78 9e       	mul	r7, r24
    9914:	f0 0d       	add	r31, r0
    9916:	11 24       	eor	r1, r1
    9918:	ec 58       	subi	r30, 0x8C	; 140
    991a:	f2 48       	sbci	r31, 0x82	; 130
    991c:	e0 5c       	subi	r30, 0xC0	; 192
    991e:	ff 4f       	sbci	r31, 0xFF	; 255
    9920:	01 91       	ld	r16, Z+
    9922:	11 91       	ld	r17, Z+
    9924:	21 91       	ld	r18, Z+
    9926:	31 91       	ld	r19, Z+
    9928:	c0 80       	ld	r12, Z
    992a:	d1 80       	ldd	r13, Z+1	; 0x01
    992c:	e2 80       	ldd	r14, Z+2	; 0x02
    992e:	f3 80       	ldd	r15, Z+3	; 0x03
    9930:	c3 01       	movw	r24, r6
    9932:	b5 01       	movw	r22, r10
    9934:	a4 01       	movw	r20, r8
    9936:	e0 ef       	ldi	r30, 0xF0	; 240
    9938:	ae 2e       	mov	r10, r30
    993a:	ef ef       	ldi	r30, 0xFF	; 255
    993c:	be 2e       	mov	r11, r30
    993e:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
							hAxis[Axis].axisSettings.homeAcceleration,update); 
				break;
			}
		}	
		// se reinician las variables de Busqueda home1 y home2
		home1=INF;
    9942:	8f ef       	ldi	r24, 0xFF	; 255
    9944:	9f ef       	ldi	r25, 0xFF	; 255
    9946:	af ef       	ldi	r26, 0xFF	; 255
    9948:	bf e7       	ldi	r27, 0x7F	; 127
    994a:	8f 87       	std	Y+15, r24	; 0x0f
    994c:	98 8b       	std	Y+16, r25	; 0x10
    994e:	a9 8b       	std	Y+17, r26	; 0x11
    9950:	ba 8b       	std	Y+18, r27	; 0x12
		home2=INF;
    9952:	8b 8b       	std	Y+19, r24	; 0x13
    9954:	9c 8b       	std	Y+20, r25	; 0x14
    9956:	ad 8b       	std	Y+21, r26	; 0x15
    9958:	be 8b       	std	Y+22, r27	; 0x16
		
		//-----------------------------------------------------------------------------------------------------
		//Informacion del movimiento al llegar home + correccion.
		//-----------------------------------------------------------------------------------------------------
		#ifdef DEBUGROBOTICS_HOME
		printf("go_home=> Informacion del movimiento antes de AJUSTAR! \n ");
    995a:	00 d0       	rcall	.+0      	; 0x995c <go_home+0x8bc>
    995c:	e0 e5       	ldi	r30, 0x50	; 80
    995e:	ff e5       	ldi	r31, 0x5F	; 95
    9960:	ad b7       	in	r26, 0x3d	; 61
    9962:	be b7       	in	r27, 0x3e	; 62
    9964:	12 96       	adiw	r26, 0x02	; 2
    9966:	fc 93       	st	X, r31
    9968:	ee 93       	st	-X, r30
    996a:	11 97       	sbiw	r26, 0x01	; 1
    996c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		infomov(Axis,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    9970:	00 d0       	rcall	.+0      	; 0x9972 <go_home+0x8d2>
    9972:	00 d0       	rcall	.+0      	; 0x9974 <go_home+0x8d4>
    9974:	ed b7       	in	r30, 0x3d	; 61
    9976:	fe b7       	in	r31, 0x3e	; 62
    9978:	31 96       	adiw	r30, 0x01	; 1
    997a:	2f e1       	ldi	r18, 0x1F	; 31
    997c:	30 e0       	ldi	r19, 0x00	; 0
    997e:	2c 0f       	add	r18, r28
    9980:	3d 1f       	adc	r19, r29
    9982:	ad b7       	in	r26, 0x3d	; 61
    9984:	be b7       	in	r27, 0x3e	; 62
    9986:	12 96       	adiw	r26, 0x02	; 2
    9988:	3c 93       	st	X, r19
    998a:	2e 93       	st	-X, r18
    998c:	11 97       	sbiw	r26, 0x01	; 1
    998e:	85 e0       	ldi	r24, 0x05	; 5
    9990:	90 e0       	ldi	r25, 0x00	; 0
    9992:	8c 0f       	add	r24, r28
    9994:	9d 1f       	adc	r25, r29
    9996:	93 83       	std	Z+3, r25	; 0x03
    9998:	82 83       	std	Z+2, r24	; 0x02
    999a:	a7 e0       	ldi	r26, 0x07	; 7
    999c:	b0 e0       	ldi	r27, 0x00	; 0
    999e:	ac 0f       	add	r26, r28
    99a0:	bd 1f       	adc	r27, r29
    99a2:	b5 83       	std	Z+5, r27	; 0x05
    99a4:	a4 83       	std	Z+4, r26	; 0x04
    99a6:	c3 01       	movw	r24, r6
    99a8:	be 01       	movw	r22, r28
    99aa:	65 5d       	subi	r22, 0xD5	; 213
    99ac:	7f 4f       	sbci	r23, 0xFF	; 255
    99ae:	ae 01       	movw	r20, r28
    99b0:	41 5d       	subi	r20, 0xD1	; 209
    99b2:	5f 4f       	sbci	r21, 0xFF	; 255
    99b4:	9e 01       	movw	r18, r28
    99b6:	2d 5b       	subi	r18, 0xBD	; 189
    99b8:	3f 4f       	sbci	r19, 0xFF	; 255
    99ba:	8e 01       	movw	r16, r28
    99bc:	09 5b       	subi	r16, 0xB9	; 185
    99be:	1f 4f       	sbci	r17, 0xFF	; 255
    99c0:	b3 e3       	ldi	r27, 0x33	; 51
    99c2:	eb 2e       	mov	r14, r27
    99c4:	f1 2c       	mov	r15, r1
    99c6:	ec 0e       	add	r14, r28
    99c8:	fd 1e       	adc	r15, r29
    99ca:	a7 e3       	ldi	r26, 0x37	; 55
    99cc:	ca 2e       	mov	r12, r26
    99ce:	d1 2c       	mov	r13, r1
    99d0:	cc 0e       	add	r12, r28
    99d2:	dd 1e       	adc	r13, r29
    99d4:	fb e3       	ldi	r31, 0x3B	; 59
    99d6:	af 2e       	mov	r10, r31
    99d8:	b1 2c       	mov	r11, r1
    99da:	ac 0e       	add	r10, r28
    99dc:	bd 1e       	adc	r11, r29
    99de:	ef e3       	ldi	r30, 0x3F	; 63
    99e0:	8e 2e       	mov	r8, r30
    99e2:	91 2c       	mov	r9, r1
    99e4:	8c 0e       	add	r8, r28
    99e6:	9d 1e       	adc	r9, r29
    99e8:	0e 94 70 56 	call	0xace0	; 0xace0 <infomov>
				&commandedvelocity, &commandedacceleration, &readencoder1, &readerror,&cuentas_encoder,
				&micropasos);
		if(Axis==AxisRoll)
    99ec:	ed b7       	in	r30, 0x3d	; 61
    99ee:	fe b7       	in	r31, 0x3e	; 62
    99f0:	36 96       	adiw	r30, 0x06	; 6
    99f2:	0f b6       	in	r0, 0x3f	; 63
    99f4:	f8 94       	cli
    99f6:	fe bf       	out	0x3e, r31	; 62
    99f8:	0f be       	out	0x3f, r0	; 63
    99fa:	ed bf       	out	0x3d, r30	; 61
    99fc:	f4 e0       	ldi	r31, 0x04	; 4
    99fe:	6f 16       	cp	r6, r31
    9a00:	71 04       	cpc	r7, r1
    9a02:	f9 f4       	brne	.+62     	; 0x9a42 <go_home+0x9a2>
		{
			infomov(AxisPitch,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    9a04:	00 d0       	rcall	.+0      	; 0x9a06 <go_home+0x966>
    9a06:	00 d0       	rcall	.+0      	; 0x9a08 <go_home+0x968>
    9a08:	00 d0       	rcall	.+0      	; 0x9a0a <go_home+0x96a>
    9a0a:	ed b7       	in	r30, 0x3d	; 61
    9a0c:	fe b7       	in	r31, 0x3e	; 62
    9a0e:	31 96       	adiw	r30, 0x01	; 1
    9a10:	2f e1       	ldi	r18, 0x1F	; 31
    9a12:	30 e0       	ldi	r19, 0x00	; 0
    9a14:	2c 0f       	add	r18, r28
    9a16:	3d 1f       	adc	r19, r29
    9a18:	ad b7       	in	r26, 0x3d	; 61
    9a1a:	be b7       	in	r27, 0x3e	; 62
    9a1c:	12 96       	adiw	r26, 0x02	; 2
    9a1e:	3c 93       	st	X, r19
    9a20:	2e 93       	st	-X, r18
    9a22:	11 97       	sbiw	r26, 0x01	; 1
    9a24:	85 e0       	ldi	r24, 0x05	; 5
    9a26:	90 e0       	ldi	r25, 0x00	; 0
    9a28:	8c 0f       	add	r24, r28
    9a2a:	9d 1f       	adc	r25, r29
    9a2c:	93 83       	std	Z+3, r25	; 0x03
    9a2e:	82 83       	std	Z+2, r24	; 0x02
    9a30:	a7 e0       	ldi	r26, 0x07	; 7
    9a32:	b0 e0       	ldi	r27, 0x00	; 0
    9a34:	ac 0f       	add	r26, r28
    9a36:	bd 1f       	adc	r27, r29
    9a38:	b5 83       	std	Z+5, r27	; 0x05
    9a3a:	a4 83       	std	Z+4, r26	; 0x04
    9a3c:	83 e0       	ldi	r24, 0x03	; 3
    9a3e:	90 e0       	ldi	r25, 0x00	; 0
    9a40:	23 c0       	rjmp	.+70     	; 0x9a88 <go_home+0x9e8>
			&commandedvelocity, &commandedacceleration, &readencoder1, &readerror,&cuentas_encoder,
			&micropasos);PMDGetPositionError(&hAxis[AxisPitch], &readerror);
		}
		if(Axis==AxisPitch)
    9a42:	f3 e0       	ldi	r31, 0x03	; 3
    9a44:	6f 16       	cp	r6, r31
    9a46:	71 04       	cpc	r7, r1
    9a48:	09 f0       	breq	.+2      	; 0x9a4c <go_home+0x9ac>
    9a4a:	4f c0       	rjmp	.+158    	; 0x9aea <go_home+0xa4a>
		{
			infomov(AxisRoll,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    9a4c:	00 d0       	rcall	.+0      	; 0x9a4e <go_home+0x9ae>
    9a4e:	00 d0       	rcall	.+0      	; 0x9a50 <go_home+0x9b0>
    9a50:	00 d0       	rcall	.+0      	; 0x9a52 <go_home+0x9b2>
    9a52:	ed b7       	in	r30, 0x3d	; 61
    9a54:	fe b7       	in	r31, 0x3e	; 62
    9a56:	31 96       	adiw	r30, 0x01	; 1
    9a58:	2f e1       	ldi	r18, 0x1F	; 31
    9a5a:	30 e0       	ldi	r19, 0x00	; 0
    9a5c:	2c 0f       	add	r18, r28
    9a5e:	3d 1f       	adc	r19, r29
    9a60:	ad b7       	in	r26, 0x3d	; 61
    9a62:	be b7       	in	r27, 0x3e	; 62
    9a64:	12 96       	adiw	r26, 0x02	; 2
    9a66:	3c 93       	st	X, r19
    9a68:	2e 93       	st	-X, r18
    9a6a:	11 97       	sbiw	r26, 0x01	; 1
    9a6c:	85 e0       	ldi	r24, 0x05	; 5
    9a6e:	90 e0       	ldi	r25, 0x00	; 0
    9a70:	8c 0f       	add	r24, r28
    9a72:	9d 1f       	adc	r25, r29
    9a74:	93 83       	std	Z+3, r25	; 0x03
    9a76:	82 83       	std	Z+2, r24	; 0x02
    9a78:	a7 e0       	ldi	r26, 0x07	; 7
    9a7a:	b0 e0       	ldi	r27, 0x00	; 0
    9a7c:	ac 0f       	add	r26, r28
    9a7e:	bd 1f       	adc	r27, r29
    9a80:	b5 83       	std	Z+5, r27	; 0x05
    9a82:	a4 83       	std	Z+4, r26	; 0x04
    9a84:	84 e0       	ldi	r24, 0x04	; 4
    9a86:	90 e0       	ldi	r25, 0x00	; 0
    9a88:	be 01       	movw	r22, r28
    9a8a:	65 5d       	subi	r22, 0xD5	; 213
    9a8c:	7f 4f       	sbci	r23, 0xFF	; 255
    9a8e:	ae 01       	movw	r20, r28
    9a90:	41 5d       	subi	r20, 0xD1	; 209
    9a92:	5f 4f       	sbci	r21, 0xFF	; 255
    9a94:	9e 01       	movw	r18, r28
    9a96:	2d 5b       	subi	r18, 0xBD	; 189
    9a98:	3f 4f       	sbci	r19, 0xFF	; 255
    9a9a:	8e 01       	movw	r16, r28
    9a9c:	09 5b       	subi	r16, 0xB9	; 185
    9a9e:	1f 4f       	sbci	r17, 0xFF	; 255
    9aa0:	b3 e3       	ldi	r27, 0x33	; 51
    9aa2:	eb 2e       	mov	r14, r27
    9aa4:	f1 2c       	mov	r15, r1
    9aa6:	ec 0e       	add	r14, r28
    9aa8:	fd 1e       	adc	r15, r29
    9aaa:	a7 e3       	ldi	r26, 0x37	; 55
    9aac:	ca 2e       	mov	r12, r26
    9aae:	d1 2c       	mov	r13, r1
    9ab0:	cc 0e       	add	r12, r28
    9ab2:	dd 1e       	adc	r13, r29
    9ab4:	fb e3       	ldi	r31, 0x3B	; 59
    9ab6:	af 2e       	mov	r10, r31
    9ab8:	b1 2c       	mov	r11, r1
    9aba:	ac 0e       	add	r10, r28
    9abc:	bd 1e       	adc	r11, r29
    9abe:	ef e3       	ldi	r30, 0x3F	; 63
    9ac0:	8e 2e       	mov	r8, r30
    9ac2:	91 2c       	mov	r9, r1
    9ac4:	8c 0e       	add	r8, r28
    9ac6:	9d 1e       	adc	r9, r29
    9ac8:	0e 94 70 56 	call	0xace0	; 0xace0 <infomov>
			&commandedvelocity, &commandedacceleration, &readencoder1, &readerror,&cuentas_encoder,
			&micropasos);PMDGetPositionError(&hAxis[AxisPitch], &readerror);
    9acc:	ed b7       	in	r30, 0x3d	; 61
    9ace:	fe b7       	in	r31, 0x3e	; 62
    9ad0:	36 96       	adiw	r30, 0x06	; 6
    9ad2:	0f b6       	in	r0, 0x3f	; 63
    9ad4:	f8 94       	cli
    9ad6:	fe bf       	out	0x3e, r31	; 62
    9ad8:	0f be       	out	0x3f, r0	; 63
    9ada:	ed bf       	out	0x3d, r30	; 61
    9adc:	84 e9       	ldi	r24, 0x94	; 148
    9ade:	9e e7       	ldi	r25, 0x7E	; 126
    9ae0:	be 01       	movw	r22, r28
    9ae2:	61 5e       	subi	r22, 0xE1	; 225
    9ae4:	7f 4f       	sbci	r23, 0xFF	; 255
    9ae6:	0e 94 68 64 	call	0xc8d0	; 0xc8d0 <PMDGetPositionError>
		//Espero a que los motores de detengan
		//-----------------------------------------------------------------------------------------------------
		do
		{
			//Hallo el El registro de actividad del eje
			PMDGetActivityStatus(&hAxis[Axis],&activity_status);
    9aea:	80 e6       	ldi	r24, 0x60	; 96
    9aec:	90 e0       	ldi	r25, 0x00	; 0
    9aee:	68 9e       	mul	r6, r24
    9af0:	80 01       	movw	r16, r0
    9af2:	69 9e       	mul	r6, r25
    9af4:	10 0d       	add	r17, r0
    9af6:	78 9e       	mul	r7, r24
    9af8:	10 0d       	add	r17, r0
    9afa:	11 24       	eor	r1, r1
    9afc:	0c 58       	subi	r16, 0x8C	; 140
    9afe:	12 48       	sbci	r17, 0x82	; 130
    9b00:	c8 01       	movw	r24, r16
    9b02:	be 01       	movw	r22, r28
    9b04:	6d 5f       	subi	r22, 0xFD	; 253
    9b06:	7f 4f       	sbci	r23, 0xFF	; 255
    9b08:	0e 94 a1 61 	call	0xc342	; 0xc342 <PMDGetActivityStatus>
		}
		while ((activity_status & PMDActivityInMotionMask) !=0);
    9b0c:	8b 81       	ldd	r24, Y+3	; 0x03
    9b0e:	9c 81       	ldd	r25, Y+4	; 0x04
    9b10:	92 fd       	sbrc	r25, 2
    9b12:	f6 cf       	rjmp	.-20     	; 0x9b00 <go_home+0xa60>
		
		
		//-----------------------------------------------------------------------------------------------------
		//Adjustando el Valor home encontrado a Cero
		//-----------------------------------------------------------------------------------------------------
		switch (Axis)
    9b14:	f3 e0       	ldi	r31, 0x03	; 3
    9b16:	6f 16       	cp	r6, r31
    9b18:	71 04       	cpc	r7, r1
    9b1a:	51 f0       	breq	.+20     	; 0x9b30 <go_home+0xa90>
    9b1c:	8b 85       	ldd	r24, Y+11	; 0x0b
    9b1e:	9c 85       	ldd	r25, Y+12	; 0x0c
    9b20:	ad 85       	ldd	r26, Y+13	; 0x0d
    9b22:	be 85       	ldd	r27, Y+14	; 0x0e
    9b24:	24 e0       	ldi	r18, 0x04	; 4
    9b26:	62 16       	cp	r6, r18
    9b28:	71 04       	cpc	r7, r1
    9b2a:	09 f0       	breq	.+2      	; 0x9b2e <go_home+0xa8e>
    9b2c:	78 c0       	rjmp	.+240    	; 0x9c1e <go_home+0xb7e>
    9b2e:	25 c0       	rjmp	.+74     	; 0x9b7a <go_home+0xada>
		{
			case (AxisPitch):	
				//Se coloca home positivo ya que el motor de roll esta invertido con respecto al motor de pitch
				PMDAdjustActualPosition(&hAxis[AxisRoll],home);	
    9b30:	4b 85       	ldd	r20, Y+11	; 0x0b
    9b32:	5c 85       	ldd	r21, Y+12	; 0x0c
    9b34:	6d 85       	ldd	r22, Y+13	; 0x0d
    9b36:	7e 85       	ldd	r23, Y+14	; 0x0e
    9b38:	84 ef       	ldi	r24, 0xF4	; 244
    9b3a:	9e e7       	ldi	r25, 0x7E	; 126
    9b3c:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>
				#ifdef DEBUGROBOTICS_HOME
				printf("Informacion del movimiento despues de AJUSTAR AxisRoll! \n");
    9b40:	8a e8       	ldi	r24, 0x8A	; 138
    9b42:	9f e5       	ldi	r25, 0x5F	; 95
    9b44:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				infomov(AxisRoll,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    9b48:	00 d0       	rcall	.+0      	; 0x9b4a <go_home+0xaaa>
    9b4a:	00 d0       	rcall	.+0      	; 0x9b4c <go_home+0xaac>
    9b4c:	00 d0       	rcall	.+0      	; 0x9b4e <go_home+0xaae>
    9b4e:	ed b7       	in	r30, 0x3d	; 61
    9b50:	fe b7       	in	r31, 0x3e	; 62
    9b52:	31 96       	adiw	r30, 0x01	; 1
    9b54:	ce 01       	movw	r24, r28
    9b56:	4f 96       	adiw	r24, 0x1f	; 31
    9b58:	ad b7       	in	r26, 0x3d	; 61
    9b5a:	be b7       	in	r27, 0x3e	; 62
    9b5c:	12 96       	adiw	r26, 0x02	; 2
    9b5e:	9c 93       	st	X, r25
    9b60:	8e 93       	st	-X, r24
    9b62:	11 97       	sbiw	r26, 0x01	; 1
    9b64:	ce 01       	movw	r24, r28
    9b66:	05 96       	adiw	r24, 0x05	; 5
    9b68:	93 83       	std	Z+3, r25	; 0x03
    9b6a:	82 83       	std	Z+2, r24	; 0x02
    9b6c:	ce 01       	movw	r24, r28
    9b6e:	07 96       	adiw	r24, 0x07	; 7
    9b70:	95 83       	std	Z+5, r25	; 0x05
    9b72:	84 83       	std	Z+4, r24	; 0x04
    9b74:	84 e0       	ldi	r24, 0x04	; 4
    9b76:	90 e0       	ldi	r25, 0x00	; 0
    9b78:	27 c0       	rjmp	.+78     	; 0x9bc8 <go_home+0xb28>
				&micropasos);
			//	scanf("%d",&test);
				#endif
			break;
			case (AxisRoll):
				PMDAdjustActualPosition(&hAxis[AxisPitch],-home);
    9b7a:	44 27       	eor	r20, r20
    9b7c:	55 27       	eor	r21, r21
    9b7e:	ba 01       	movw	r22, r20
    9b80:	48 1b       	sub	r20, r24
    9b82:	59 0b       	sbc	r21, r25
    9b84:	6a 0b       	sbc	r22, r26
    9b86:	7b 0b       	sbc	r23, r27
    9b88:	84 e9       	ldi	r24, 0x94	; 148
    9b8a:	9e e7       	ldi	r25, 0x7E	; 126
    9b8c:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>
				#ifdef DEBUGROBOTICS_HOME
				printf("Informacion del movimiento despues de AJUSTAR AxisPitch! \n");
    9b90:	83 ec       	ldi	r24, 0xC3	; 195
    9b92:	9f e5       	ldi	r25, 0x5F	; 95
    9b94:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				infomov(AxisPitch,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    9b98:	00 d0       	rcall	.+0      	; 0x9b9a <go_home+0xafa>
    9b9a:	00 d0       	rcall	.+0      	; 0x9b9c <go_home+0xafc>
    9b9c:	00 d0       	rcall	.+0      	; 0x9b9e <go_home+0xafe>
    9b9e:	ed b7       	in	r30, 0x3d	; 61
    9ba0:	fe b7       	in	r31, 0x3e	; 62
    9ba2:	31 96       	adiw	r30, 0x01	; 1
    9ba4:	ce 01       	movw	r24, r28
    9ba6:	4f 96       	adiw	r24, 0x1f	; 31
    9ba8:	ad b7       	in	r26, 0x3d	; 61
    9baa:	be b7       	in	r27, 0x3e	; 62
    9bac:	12 96       	adiw	r26, 0x02	; 2
    9bae:	9c 93       	st	X, r25
    9bb0:	8e 93       	st	-X, r24
    9bb2:	11 97       	sbiw	r26, 0x01	; 1
    9bb4:	ce 01       	movw	r24, r28
    9bb6:	05 96       	adiw	r24, 0x05	; 5
    9bb8:	93 83       	std	Z+3, r25	; 0x03
    9bba:	82 83       	std	Z+2, r24	; 0x02
    9bbc:	ce 01       	movw	r24, r28
    9bbe:	07 96       	adiw	r24, 0x07	; 7
    9bc0:	95 83       	std	Z+5, r25	; 0x05
    9bc2:	84 83       	std	Z+4, r24	; 0x04
    9bc4:	83 e0       	ldi	r24, 0x03	; 3
    9bc6:	90 e0       	ldi	r25, 0x00	; 0
    9bc8:	be 01       	movw	r22, r28
    9bca:	65 5d       	subi	r22, 0xD5	; 213
    9bcc:	7f 4f       	sbci	r23, 0xFF	; 255
    9bce:	ae 01       	movw	r20, r28
    9bd0:	41 5d       	subi	r20, 0xD1	; 209
    9bd2:	5f 4f       	sbci	r21, 0xFF	; 255
    9bd4:	9e 01       	movw	r18, r28
    9bd6:	2d 5b       	subi	r18, 0xBD	; 189
    9bd8:	3f 4f       	sbci	r19, 0xFF	; 255
    9bda:	8e 01       	movw	r16, r28
    9bdc:	09 5b       	subi	r16, 0xB9	; 185
    9bde:	1f 4f       	sbci	r17, 0xFF	; 255
    9be0:	b3 e3       	ldi	r27, 0x33	; 51
    9be2:	eb 2e       	mov	r14, r27
    9be4:	f1 2c       	mov	r15, r1
    9be6:	ec 0e       	add	r14, r28
    9be8:	fd 1e       	adc	r15, r29
    9bea:	a7 e3       	ldi	r26, 0x37	; 55
    9bec:	ca 2e       	mov	r12, r26
    9bee:	d1 2c       	mov	r13, r1
    9bf0:	cc 0e       	add	r12, r28
    9bf2:	dd 1e       	adc	r13, r29
    9bf4:	fb e3       	ldi	r31, 0x3B	; 59
    9bf6:	af 2e       	mov	r10, r31
    9bf8:	b1 2c       	mov	r11, r1
    9bfa:	ac 0e       	add	r10, r28
    9bfc:	bd 1e       	adc	r11, r29
    9bfe:	ef e3       	ldi	r30, 0x3F	; 63
    9c00:	8e 2e       	mov	r8, r30
    9c02:	91 2c       	mov	r9, r1
    9c04:	8c 0e       	add	r8, r28
    9c06:	9d 1e       	adc	r9, r29
    9c08:	0e 94 70 56 	call	0xace0	; 0xace0 <infomov>
    9c0c:	ed b7       	in	r30, 0x3d	; 61
    9c0e:	fe b7       	in	r31, 0x3e	; 62
    9c10:	36 96       	adiw	r30, 0x06	; 6
    9c12:	0f b6       	in	r0, 0x3f	; 63
    9c14:	f8 94       	cli
    9c16:	fe bf       	out	0x3e, r31	; 62
    9c18:	0f be       	out	0x3f, r0	; 63
    9c1a:	ed bf       	out	0x3d, r30	; 61
    9c1c:	0a c0       	rjmp	.+20     	; 0x9c32 <go_home+0xb92>
				&micropasos);
				//scanf("%d",&test);
				#endif
			break;
			default:
				PMDAdjustActualPosition(&hAxis[Axis],-home); 		
    9c1e:	44 27       	eor	r20, r20
    9c20:	55 27       	eor	r21, r21
    9c22:	ba 01       	movw	r22, r20
    9c24:	48 1b       	sub	r20, r24
    9c26:	59 0b       	sbc	r21, r25
    9c28:	6a 0b       	sbc	r22, r26
    9c2a:	7b 0b       	sbc	r23, r27
    9c2c:	c8 01       	movw	r24, r16
    9c2e:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>
		
		//-----------------------------------------------------------------------------------------------------
		//Imprimiendo estado del eje despues del ajuste
		//-----------------------------------------------------------------------------------------------------
		#ifdef DEBUGROBOTICS_HOME
		printf("go_home=> Informacion del movimiento despues de AJUSTAR! \n ");
    9c32:	00 d0       	rcall	.+0      	; 0x9c34 <go_home+0xb94>
    9c34:	ed ef       	ldi	r30, 0xFD	; 253
    9c36:	ff e5       	ldi	r31, 0x5F	; 95
    9c38:	ad b7       	in	r26, 0x3d	; 61
    9c3a:	be b7       	in	r27, 0x3e	; 62
    9c3c:	12 96       	adiw	r26, 0x02	; 2
    9c3e:	fc 93       	st	X, r31
    9c40:	ee 93       	st	-X, r30
    9c42:	11 97       	sbiw	r26, 0x01	; 1
    9c44:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		infomov(Axis,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    9c48:	00 d0       	rcall	.+0      	; 0x9c4a <go_home+0xbaa>
    9c4a:	00 d0       	rcall	.+0      	; 0x9c4c <go_home+0xbac>
    9c4c:	ed b7       	in	r30, 0x3d	; 61
    9c4e:	fe b7       	in	r31, 0x3e	; 62
    9c50:	31 96       	adiw	r30, 0x01	; 1
    9c52:	ce 01       	movw	r24, r28
    9c54:	4f 96       	adiw	r24, 0x1f	; 31
    9c56:	ad b7       	in	r26, 0x3d	; 61
    9c58:	be b7       	in	r27, 0x3e	; 62
    9c5a:	12 96       	adiw	r26, 0x02	; 2
    9c5c:	9c 93       	st	X, r25
    9c5e:	8e 93       	st	-X, r24
    9c60:	11 97       	sbiw	r26, 0x01	; 1
    9c62:	ce 01       	movw	r24, r28
    9c64:	05 96       	adiw	r24, 0x05	; 5
    9c66:	93 83       	std	Z+3, r25	; 0x03
    9c68:	82 83       	std	Z+2, r24	; 0x02
    9c6a:	ce 01       	movw	r24, r28
    9c6c:	07 96       	adiw	r24, 0x07	; 7
    9c6e:	95 83       	std	Z+5, r25	; 0x05
    9c70:	84 83       	std	Z+4, r24	; 0x04
    9c72:	c3 01       	movw	r24, r6
    9c74:	be 01       	movw	r22, r28
    9c76:	65 5d       	subi	r22, 0xD5	; 213
    9c78:	7f 4f       	sbci	r23, 0xFF	; 255
    9c7a:	ae 01       	movw	r20, r28
    9c7c:	41 5d       	subi	r20, 0xD1	; 209
    9c7e:	5f 4f       	sbci	r21, 0xFF	; 255
    9c80:	9e 01       	movw	r18, r28
    9c82:	2d 5b       	subi	r18, 0xBD	; 189
    9c84:	3f 4f       	sbci	r19, 0xFF	; 255
    9c86:	8e 01       	movw	r16, r28
    9c88:	09 5b       	subi	r16, 0xB9	; 185
    9c8a:	1f 4f       	sbci	r17, 0xFF	; 255
    9c8c:	b3 e3       	ldi	r27, 0x33	; 51
    9c8e:	eb 2e       	mov	r14, r27
    9c90:	f1 2c       	mov	r15, r1
    9c92:	ec 0e       	add	r14, r28
    9c94:	fd 1e       	adc	r15, r29
    9c96:	a7 e3       	ldi	r26, 0x37	; 55
    9c98:	ca 2e       	mov	r12, r26
    9c9a:	d1 2c       	mov	r13, r1
    9c9c:	cc 0e       	add	r12, r28
    9c9e:	dd 1e       	adc	r13, r29
    9ca0:	fb e3       	ldi	r31, 0x3B	; 59
    9ca2:	af 2e       	mov	r10, r31
    9ca4:	b1 2c       	mov	r11, r1
    9ca6:	ac 0e       	add	r10, r28
    9ca8:	bd 1e       	adc	r11, r29
    9caa:	ef e3       	ldi	r30, 0x3F	; 63
    9cac:	8e 2e       	mov	r8, r30
    9cae:	91 2c       	mov	r9, r1
    9cb0:	8c 0e       	add	r8, r28
    9cb2:	9d 1e       	adc	r9, r29
    9cb4:	0e 94 70 56 	call	0xace0	; 0xace0 <infomov>
				&micropasos);
		#endif
		//-----------------------------------------------------------------------------------------------------
		//Caso especial de Axis == Cintura indica que se acabo el proceso.
		//-----------------------------------------------------------------------------------------------------
		if(Axis==AxisWaist)
    9cb8:	ed b7       	in	r30, 0x3d	; 61
    9cba:	fe b7       	in	r31, 0x3e	; 62
    9cbc:	36 96       	adiw	r30, 0x06	; 6
    9cbe:	0f b6       	in	r0, 0x3f	; 63
    9cc0:	f8 94       	cli
    9cc2:	fe bf       	out	0x3e, r31	; 62
    9cc4:	0f be       	out	0x3f, r0	; 63
    9cc6:	ed bf       	out	0x3d, r30	; 61
    9cc8:	61 14       	cp	r6, r1
    9cca:	71 04       	cpc	r7, r1
    9ccc:	99 f4       	brne	.+38     	; 0x9cf4 <go_home+0xc54>
    9cce:	04 e7       	ldi	r16, 0x74	; 116
    9cd0:	1d e7       	ldi	r17, 0x7D	; 125
    9cd2:	ee 24       	eor	r14, r14
    9cd4:	ff 24       	eor	r15, r15
	

	
	for(Axis=0; Axis < DOF; Axis++) 
	{	
		PMDGetActualPosition(&hAxis[Axis],&encoder);
    9cd6:	23 e2       	ldi	r18, 0x23	; 35
    9cd8:	82 2e       	mov	r8, r18
    9cda:	91 2c       	mov	r9, r1
    9cdc:	8c 0e       	add	r8, r28
    9cde:	9d 1e       	adc	r9, r29
			PMDGetPositionError(&hAxis[Axis], &readerror);
			printf("go_home=> Error de posicion del Eje %s despues del proceso de home = %ld\n",AxisName(Axis),readerror);		
		#endif
		
		PMDAdjustActualPosition(&hAxis[Axis],-encoder); 		
		PMDGetPositionError(&hAxis[Axis], &readerror);
    9ce0:	9f e1       	ldi	r25, 0x1F	; 31
    9ce2:	a9 2e       	mov	r10, r25
    9ce4:	b1 2c       	mov	r11, r1
    9ce6:	ac 0e       	add	r10, r28
    9ce8:	bd 1e       	adc	r11, r29
		printf("go_home=> Error de posicion del Eje %s al finalizar el proceso de HOME = %ld\n",AxisName(Axis),readerror);		
    9cea:	89 e3       	ldi	r24, 0x39	; 57
    9cec:	c8 2e       	mov	r12, r24
    9cee:	80 e6       	ldi	r24, 0x60	; 96
    9cf0:	d8 2e       	mov	r13, r24
    9cf2:	09 c0       	rjmp	.+18     	; 0x9d06 <go_home+0xc66>
	/* Desactivar las interrupciones generadas por los PMDs*/
	HostInterruptDisable();	
	
	
	
	for(Axis=AxisShoulder; Axis <= DOF; Axis++) 
    9cf4:	08 94       	sec
    9cf6:	61 1c       	adc	r6, r1
    9cf8:	71 1c       	adc	r7, r1
    9cfa:	f6 e0       	ldi	r31, 0x06	; 6
    9cfc:	6f 16       	cp	r6, r31
    9cfe:	71 04       	cpc	r7, r1
    9d00:	0c f4       	brge	.+2      	; 0x9d04 <go_home+0xc64>
    9d02:	08 ca       	rjmp	.-3056   	; 0x9114 <go_home+0x74>
    9d04:	e4 cf       	rjmp	.-56     	; 0x9cce <go_home+0xc2e>
	

	
	for(Axis=0; Axis < DOF; Axis++) 
	{	
		PMDGetActualPosition(&hAxis[Axis],&encoder);
    9d06:	c8 01       	movw	r24, r16
    9d08:	b4 01       	movw	r22, r8
    9d0a:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
			printf("go_home=> Posicion Encoder despues del proceso de home del Eje %s es= %ld\n",AxisName(Axis),encoder);		
			PMDGetPositionError(&hAxis[Axis], &readerror);
			printf("go_home=> Error de posicion del Eje %s despues del proceso de home = %ld\n",AxisName(Axis),readerror);		
		#endif
		
		PMDAdjustActualPosition(&hAxis[Axis],-encoder); 		
    9d0e:	4b a1       	ldd	r20, Y+35	; 0x23
    9d10:	5c a1       	ldd	r21, Y+36	; 0x24
    9d12:	6d a1       	ldd	r22, Y+37	; 0x25
    9d14:	7e a1       	ldd	r23, Y+38	; 0x26
    9d16:	70 95       	com	r23
    9d18:	60 95       	com	r22
    9d1a:	50 95       	com	r21
    9d1c:	41 95       	neg	r20
    9d1e:	5f 4f       	sbci	r21, 0xFF	; 255
    9d20:	6f 4f       	sbci	r22, 0xFF	; 255
    9d22:	7f 4f       	sbci	r23, 0xFF	; 255
    9d24:	c8 01       	movw	r24, r16
    9d26:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>
		PMDGetPositionError(&hAxis[Axis], &readerror);
    9d2a:	c8 01       	movw	r24, r16
    9d2c:	b5 01       	movw	r22, r10
    9d2e:	0e 94 68 64 	call	0xc8d0	; 0xc8d0 <PMDGetPositionError>
		printf("go_home=> Error de posicion del Eje %s al finalizar el proceso de HOME = %ld\n",AxisName(Axis),readerror);		
    9d32:	c7 01       	movw	r24, r14
    9d34:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    9d38:	2d b7       	in	r18, 0x3d	; 61
    9d3a:	3e b7       	in	r19, 0x3e	; 62
    9d3c:	28 50       	subi	r18, 0x08	; 8
    9d3e:	30 40       	sbci	r19, 0x00	; 0
    9d40:	0f b6       	in	r0, 0x3f	; 63
    9d42:	f8 94       	cli
    9d44:	3e bf       	out	0x3e, r19	; 62
    9d46:	0f be       	out	0x3f, r0	; 63
    9d48:	2d bf       	out	0x3d, r18	; 61
    9d4a:	ed b7       	in	r30, 0x3d	; 61
    9d4c:	fe b7       	in	r31, 0x3e	; 62
    9d4e:	31 96       	adiw	r30, 0x01	; 1
    9d50:	ad b7       	in	r26, 0x3d	; 61
    9d52:	be b7       	in	r27, 0x3e	; 62
    9d54:	12 96       	adiw	r26, 0x02	; 2
    9d56:	dc 92       	st	X, r13
    9d58:	ce 92       	st	-X, r12
    9d5a:	11 97       	sbiw	r26, 0x01	; 1
    9d5c:	93 83       	std	Z+3, r25	; 0x03
    9d5e:	82 83       	std	Z+2, r24	; 0x02
    9d60:	8f 8d       	ldd	r24, Y+31	; 0x1f
    9d62:	98 a1       	ldd	r25, Y+32	; 0x20
    9d64:	a9 a1       	ldd	r26, Y+33	; 0x21
    9d66:	ba a1       	ldd	r27, Y+34	; 0x22
    9d68:	84 83       	std	Z+4, r24	; 0x04
    9d6a:	95 83       	std	Z+5, r25	; 0x05
    9d6c:	a6 83       	std	Z+6, r26	; 0x06
    9d6e:	b7 83       	std	Z+7, r27	; 0x07
    9d70:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>


	

	
	for(Axis=0; Axis < DOF; Axis++) 
    9d74:	08 94       	sec
    9d76:	e1 1c       	adc	r14, r1
    9d78:	f1 1c       	adc	r15, r1
    9d7a:	00 5a       	subi	r16, 0xA0	; 160
    9d7c:	1f 4f       	sbci	r17, 0xFF	; 255
    9d7e:	ed b7       	in	r30, 0x3d	; 61
    9d80:	fe b7       	in	r31, 0x3e	; 62
    9d82:	38 96       	adiw	r30, 0x08	; 8
    9d84:	0f b6       	in	r0, 0x3f	; 63
    9d86:	f8 94       	cli
    9d88:	fe bf       	out	0x3e, r31	; 62
    9d8a:	0f be       	out	0x3f, r0	; 63
    9d8c:	ed bf       	out	0x3d, r30	; 61
    9d8e:	f5 e0       	ldi	r31, 0x05	; 5
    9d90:	ef 16       	cp	r14, r31
    9d92:	f1 04       	cpc	r15, r1
    9d94:	09 f0       	breq	.+2      	; 0x9d98 <go_home+0xcf8>
    9d96:	b7 cf       	rjmp	.-146    	; 0x9d06 <go_home+0xc66>
		PMDGetPositionError(&hAxis[Axis], &readerror);
		printf("go_home=> Error de posicion del Eje %s al finalizar el proceso de HOME = %ld\n",AxisName(Axis),readerror);		
	}
	//habilitada las interrupciones hacia el uControlador
	
	HostInterruptEnable();
    9d98:	0e 94 21 5f 	call	0xbe42	; 0xbe42 <HostInterruptEnable>
	
}
    9d9c:	c6 5b       	subi	r28, 0xB6	; 182
    9d9e:	df 4f       	sbci	r29, 0xFF	; 255
    9da0:	0f b6       	in	r0, 0x3f	; 63
    9da2:	f8 94       	cli
    9da4:	de bf       	out	0x3e, r29	; 62
    9da6:	0f be       	out	0x3f, r0	; 63
    9da8:	cd bf       	out	0x3d, r28	; 61
    9daa:	cf 91       	pop	r28
    9dac:	df 91       	pop	r29
    9dae:	1f 91       	pop	r17
    9db0:	0f 91       	pop	r16
    9db2:	ff 90       	pop	r15
    9db4:	ef 90       	pop	r14
    9db6:	df 90       	pop	r13
    9db8:	cf 90       	pop	r12
    9dba:	bf 90       	pop	r11
    9dbc:	af 90       	pop	r10
    9dbe:	9f 90       	pop	r9
    9dc0:	8f 90       	pop	r8
    9dc2:	7f 90       	pop	r7
    9dc4:	6f 90       	pop	r6
    9dc6:	5f 90       	pop	r5
    9dc8:	4f 90       	pop	r4
    9dca:	3f 90       	pop	r3
    9dcc:	2f 90       	pop	r2
    9dce:	08 95       	ret

00009dd0 <initializeAxis>:
	
}

/*****************************************************************************************/ 
PMDresult initializeAxis(int16 Axis) //falta realizar para Pitch & Roll y enviar o guardar los Datos encontrados!!
{
    9dd0:	8f 92       	push	r8
    9dd2:	9f 92       	push	r9
    9dd4:	af 92       	push	r10
    9dd6:	bf 92       	push	r11
    9dd8:	cf 92       	push	r12
    9dda:	df 92       	push	r13
    9ddc:	ef 92       	push	r14
    9dde:	ff 92       	push	r15
    9de0:	0f 93       	push	r16
    9de2:	1f 93       	push	r17
    9de4:	df 93       	push	r29
    9de6:	cf 93       	push	r28
    9de8:	cd b7       	in	r28, 0x3d	; 61
    9dea:	de b7       	in	r29, 0x3e	; 62
    9dec:	60 97       	sbiw	r28, 0x10	; 16
    9dee:	0f b6       	in	r0, 0x3f	; 63
    9df0:	f8 94       	cli
    9df2:	de bf       	out	0x3e, r29	; 62
    9df4:	0f be       	out	0x3f, r0	; 63
    9df6:	cd bf       	out	0x3d, r28	; 61
    9df8:	4c 01       	movw	r8, r24
	PMDuint16 rc = rcOK;
	
	PMDint32 home=0,home1=INF,home2=INF,minPos,maxPos;
    9dfa:	8f ef       	ldi	r24, 0xFF	; 255
    9dfc:	9f ef       	ldi	r25, 0xFF	; 255
    9dfe:	af ef       	ldi	r26, 0xFF	; 255
    9e00:	bf e7       	ldi	r27, 0x7F	; 127
    9e02:	89 83       	std	Y+1, r24	; 0x01
    9e04:	9a 83       	std	Y+2, r25	; 0x02
    9e06:	ab 83       	std	Y+3, r26	; 0x03
    9e08:	bc 83       	std	Y+4, r27	; 0x04
    9e0a:	8d 83       	std	Y+5, r24	; 0x05
    9e0c:	9e 83       	std	Y+6, r25	; 0x06
    9e0e:	af 83       	std	Y+7, r26	; 0x07
    9e10:	b8 87       	std	Y+8, r27	; 0x08
		int16 temp1;
	#endif		


    // Deshabilitada las interrupciones hacia el uControlador
	HostInterruptDisable();							
    9e12:	0e 94 39 5f 	call	0xbe72	; 0xbe72 <HostInterruptDisable>
	//Limpia la Posicion de Error. Posicion_Comandada=Posicion_Acutal
	PMDClearPositionError(&hAxis[Axis]); 			
    9e16:	80 e6       	ldi	r24, 0x60	; 96
    9e18:	90 e0       	ldi	r25, 0x00	; 0
    9e1a:	88 9e       	mul	r8, r24
    9e1c:	80 01       	movw	r16, r0
    9e1e:	89 9e       	mul	r8, r25
    9e20:	10 0d       	add	r17, r0
    9e22:	98 9e       	mul	r9, r24
    9e24:	10 0d       	add	r17, r0
    9e26:	11 24       	eor	r1, r1
    9e28:	0c 58       	subi	r16, 0x8C	; 140
    9e2a:	12 48       	sbci	r17, 0x82	; 130
    9e2c:	c8 01       	movw	r24, r16
    9e2e:	0e 94 74 65 	call	0xcae8	; 0xcae8 <PMDClearPositionError>
	PMDUpdate(&hAxis[Axis]);
    9e32:	c8 01       	movw	r24, r16
    9e34:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>

	printf("initializeAxis=> Inicializado eje %s\n  ",AxisName(Axis));
    9e38:	c4 01       	movw	r24, r8
    9e3a:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    9e3e:	00 d0       	rcall	.+0      	; 0x9e40 <initializeAxis+0x70>
    9e40:	00 d0       	rcall	.+0      	; 0x9e42 <initializeAxis+0x72>
    9e42:	27 e8       	ldi	r18, 0x87	; 135
    9e44:	30 e6       	ldi	r19, 0x60	; 96
    9e46:	ed b7       	in	r30, 0x3d	; 61
    9e48:	fe b7       	in	r31, 0x3e	; 62
    9e4a:	32 83       	std	Z+2, r19	; 0x02
    9e4c:	21 83       	std	Z+1, r18	; 0x01
    9e4e:	94 83       	std	Z+4, r25	; 0x04
    9e50:	83 83       	std	Z+3, r24	; 0x03
    9e52:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	#ifdef DEBUGROBOTICS
	//	scanf("%d",&temp1);
	#endif

	switch(Axis) 
    9e56:	0f 90       	pop	r0
    9e58:	0f 90       	pop	r0
    9e5a:	0f 90       	pop	r0
    9e5c:	0f 90       	pop	r0
    9e5e:	c4 01       	movw	r24, r8
    9e60:	02 97       	sbiw	r24, 0x02	; 2
    9e62:	02 97       	sbiw	r24, 0x02	; 2
    9e64:	18 f5       	brcc	.+70     	; 0x9eac <initializeAxis+0xdc>
	{
		case  (AxisPitch) :
		case  (AxisElbow) : 					
			
			//Si el eje es Pitch se debe limpiar la posicion de error para el motor Roll.
			if(Axis==AxisPitch)
    9e66:	f3 e0       	ldi	r31, 0x03	; 3
    9e68:	8f 16       	cp	r8, r31
    9e6a:	91 04       	cpc	r9, r1
    9e6c:	41 f4       	brne	.+16     	; 0x9e7e <initializeAxis+0xae>
			{
				PMDClearPositionError(&hAxis[AxisRoll]); 			
    9e6e:	84 ef       	ldi	r24, 0xF4	; 244
    9e70:	9e e7       	ldi	r25, 0x7E	; 126
    9e72:	0e 94 74 65 	call	0xcae8	; 0xcae8 <PMDClearPositionError>
				PMDUpdate(&hAxis[AxisRoll]);
    9e76:	84 ef       	ldi	r24, 0xF4	; 244
    9e78:	9e e7       	ldi	r25, 0x7E	; 126
    9e7a:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			}
			
		    //Mover el Eje en Direccion Positiva
			search_home_positive(Axis,&home1,&maxPos,TRUE);
    9e7e:	c4 01       	movw	r24, r8
    9e80:	be 01       	movw	r22, r28
    9e82:	6f 5f       	subi	r22, 0xFF	; 255
    9e84:	7f 4f       	sbci	r23, 0xFF	; 255
    9e86:	ae 01       	movw	r20, r28
    9e88:	43 5f       	subi	r20, 0xF3	; 243
    9e8a:	5f 4f       	sbci	r21, 0xFF	; 255
    9e8c:	21 e0       	ldi	r18, 0x01	; 1
    9e8e:	30 e0       	ldi	r19, 0x00	; 0
    9e90:	0e 94 1c 41 	call	0x8238	; 0x8238 <search_home_positive>
				printf("initializeAxis=> El valor maxPos del eje %s = %ld. \n ",AxisName(Axis),maxPos);
			//	scanf("%d",&temp1);
			#endif			
			
			//Mover el Eje en Direccion Negativa
			search_home_negative(Axis,&home2,&minPos,TRUE);
    9e94:	c4 01       	movw	r24, r8
    9e96:	be 01       	movw	r22, r28
    9e98:	6b 5f       	subi	r22, 0xFB	; 251
    9e9a:	7f 4f       	sbci	r23, 0xFF	; 255
    9e9c:	ae 01       	movw	r20, r28
    9e9e:	47 5f       	subi	r20, 0xF7	; 247
    9ea0:	5f 4f       	sbci	r21, 0xFF	; 255
    9ea2:	21 e0       	ldi	r18, 0x01	; 1
    9ea4:	30 e0       	ldi	r19, 0x00	; 0
    9ea6:	0e 94 bb 44 	call	0x8976	; 0x8976 <search_home_negative>
    9eaa:	16 c0       	rjmp	.+44     	; 0x9ed8 <initializeAxis+0x108>
			//	scanf("%d",&temp1);
			#endif			
        break;
		default : 					 // just use neg. limit
			//Mover el Eje en Direccion Negativa
			search_home_negative(Axis,&home1,&minPos,TRUE);
    9eac:	c4 01       	movw	r24, r8
    9eae:	be 01       	movw	r22, r28
    9eb0:	6f 5f       	subi	r22, 0xFF	; 255
    9eb2:	7f 4f       	sbci	r23, 0xFF	; 255
    9eb4:	ae 01       	movw	r20, r28
    9eb6:	47 5f       	subi	r20, 0xF7	; 247
    9eb8:	5f 4f       	sbci	r21, 0xFF	; 255
    9eba:	21 e0       	ldi	r18, 0x01	; 1
    9ebc:	30 e0       	ldi	r19, 0x00	; 0
    9ebe:	0e 94 bb 44 	call	0x8976	; 0x8976 <search_home_negative>
			#endif
			//PMDResetEventStatus(&hAxis[Axis],~(PMDEventMotionCompleteMask | PMDEventInNegativeLimitMask));	
			//PMDSetMotorMode(&hAxis[Axis],PMDMotorOn); 
					 
			//Mover el Eje en Direccion Positiva
			search_home_positive(Axis,&home2,&maxPos,TRUE);
    9ec2:	c4 01       	movw	r24, r8
    9ec4:	be 01       	movw	r22, r28
    9ec6:	6b 5f       	subi	r22, 0xFB	; 251
    9ec8:	7f 4f       	sbci	r23, 0xFF	; 255
    9eca:	ae 01       	movw	r20, r28
    9ecc:	43 5f       	subi	r20, 0xF3	; 243
    9ece:	5f 4f       	sbci	r21, 0xFF	; 255
    9ed0:	21 e0       	ldi	r18, 0x01	; 1
    9ed2:	30 e0       	ldi	r19, 0x00	; 0
    9ed4:	0e 94 1c 41 	call	0x8238	; 0x8238 <search_home_positive>
		break;
	}
	
	
	//------------- depending on the axis configuration, calibrate the HOME value.-----------------
	switch(hAxis[Axis].axisSettings.homeSwitchHandling) 
    9ed8:	80 e6       	ldi	r24, 0x60	; 96
    9eda:	90 e0       	ldi	r25, 0x00	; 0
    9edc:	88 9e       	mul	r8, r24
    9ede:	f0 01       	movw	r30, r0
    9ee0:	89 9e       	mul	r8, r25
    9ee2:	f0 0d       	add	r31, r0
    9ee4:	98 9e       	mul	r9, r24
    9ee6:	f0 0d       	add	r31, r0
    9ee8:	11 24       	eor	r1, r1
    9eea:	ec 58       	subi	r30, 0x8C	; 140
    9eec:	f2 48       	sbci	r31, 0x82	; 130
    9eee:	86 8d       	ldd	r24, Z+30	; 0x1e
    9ef0:	97 8d       	ldd	r25, Z+31	; 0x1f
    9ef2:	2f ef       	ldi	r18, 0xFF	; 255
    9ef4:	8f 3f       	cpi	r24, 0xFF	; 255
    9ef6:	92 07       	cpc	r25, r18
    9ef8:	31 f0       	breq	.+12     	; 0x9f06 <initializeAxis+0x136>
    9efa:	01 97       	sbiw	r24, 0x01	; 1
    9efc:	21 f0       	breq	.+8      	; 0x9f06 <initializeAxis+0x136>
    9efe:	aa 24       	eor	r10, r10
    9f00:	bb 24       	eor	r11, r11
    9f02:	65 01       	movw	r12, r10
    9f04:	04 c0       	rjmp	.+8      	; 0x9f0e <initializeAxis+0x13e>
	{
		case -1 : 
		case  1 : 
			home = home2;            // just use right limit
    9f06:	ad 80       	ldd	r10, Y+5	; 0x05
    9f08:	be 80       	ldd	r11, Y+6	; 0x06
    9f0a:	cf 80       	ldd	r12, Y+7	; 0x07
    9f0c:	d8 84       	ldd	r13, Y+8	; 0x08
				else					
			//		home = ((home1+home2)/2)-(AJUSTE_HOME2*(hAxis[Axis].axisSettings.ustepsPerStep)); // use medium position
        break;
	}	
	
	hAxis[Axis].axisLimits.minPosition = minPos-home;
    9f0e:	80 e6       	ldi	r24, 0x60	; 96
    9f10:	90 e0       	ldi	r25, 0x00	; 0
    9f12:	88 9e       	mul	r8, r24
    9f14:	70 01       	movw	r14, r0
    9f16:	89 9e       	mul	r8, r25
    9f18:	f0 0c       	add	r15, r0
    9f1a:	98 9e       	mul	r9, r24
    9f1c:	f0 0c       	add	r15, r0
    9f1e:	11 24       	eor	r1, r1
    9f20:	84 e7       	ldi	r24, 0x74	; 116
    9f22:	9d e7       	ldi	r25, 0x7D	; 125
    9f24:	e8 0e       	add	r14, r24
    9f26:	f9 1e       	adc	r15, r25
    9f28:	e8 e4       	ldi	r30, 0x48	; 72
    9f2a:	f0 e0       	ldi	r31, 0x00	; 0
    9f2c:	ee 0e       	add	r14, r30
    9f2e:	ff 1e       	adc	r15, r31
    9f30:	89 85       	ldd	r24, Y+9	; 0x09
    9f32:	9a 85       	ldd	r25, Y+10	; 0x0a
    9f34:	ab 85       	ldd	r26, Y+11	; 0x0b
    9f36:	bc 85       	ldd	r27, Y+12	; 0x0c
    9f38:	8a 19       	sub	r24, r10
    9f3a:	9b 09       	sbc	r25, r11
    9f3c:	ac 09       	sbc	r26, r12
    9f3e:	bd 09       	sbc	r27, r13
    9f40:	f7 01       	movw	r30, r14
    9f42:	81 93       	st	Z+, r24
    9f44:	91 93       	st	Z+, r25
    9f46:	a1 93       	st	Z+, r26
    9f48:	b1 93       	st	Z+, r27
    9f4a:	7f 01       	movw	r14, r30
	hAxis[Axis].axisLimits.maxPosition = maxPos-home;
    9f4c:	8d 85       	ldd	r24, Y+13	; 0x0d
    9f4e:	9e 85       	ldd	r25, Y+14	; 0x0e
    9f50:	af 85       	ldd	r26, Y+15	; 0x0f
    9f52:	b8 89       	ldd	r27, Y+16	; 0x10
    9f54:	8a 19       	sub	r24, r10
    9f56:	9b 09       	sbc	r25, r11
    9f58:	ac 09       	sbc	r26, r12
    9f5a:	bd 09       	sbc	r27, r13
    9f5c:	80 83       	st	Z, r24
    9f5e:	91 83       	std	Z+1, r25	; 0x01
    9f60:	a2 83       	std	Z+2, r26	; 0x02
    9f62:	b3 83       	std	Z+3, r27	; 0x03
    9f64:	84 eb       	ldi	r24, 0xB4	; 180
    9f66:	9f ef       	ldi	r25, 0xFF	; 255
    9f68:	e8 0e       	add	r14, r24
    9f6a:	f9 1e       	adc	r15, r25
	PMDAdjustActualPosition(&hAxis[Axis],-home); 
    9f6c:	44 27       	eor	r20, r20
    9f6e:	55 27       	eor	r21, r21
    9f70:	ba 01       	movw	r22, r20
    9f72:	4a 19       	sub	r20, r10
    9f74:	5b 09       	sbc	r21, r11
    9f76:	6c 09       	sbc	r22, r12
    9f78:	7d 09       	sbc	r23, r13
    9f7a:	c8 01       	movw	r24, r16
    9f7c:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>
		printf("initializeAxis=> Valor final para maxPos del eje %s = %ld. \n ",AxisName(Axis),hAxis[Axis].axisLimits.maxPosition);
		printf("initializeAxis=> Valor final para minPos del eje %s = %ld. \n ",AxisName(Axis),hAxis[Axis].axisLimits.minPosition);
		printf("initializeAxis=> Moviendo hacia Home \n ");
	#endif
	
	switch (Axis)
    9f80:	93 e0       	ldi	r25, 0x03	; 3
    9f82:	89 16       	cp	r8, r25
    9f84:	91 04       	cpc	r9, r1
    9f86:	21 f5       	brne	.+72     	; 0x9fd0 <initializeAxis+0x200>
	{
		case (AxisPitch):
			//Se coloca home positivo ya que el motor de roll esta invertido con respecto al motor de pitch
			PMDAdjustActualPosition(&hAxis[AxisRoll],home);
    9f88:	84 ef       	ldi	r24, 0xF4	; 244
    9f8a:	9e e7       	ldi	r25, 0x7E	; 126
    9f8c:	b6 01       	movw	r22, r12
    9f8e:	a5 01       	movw	r20, r10
    9f90:	0e 94 b4 67 	call	0xcf68	; 0xcf68 <PMDAdjustActualPosition>
			
			
			pitch(HOME,hAxis[Axis].axisSettings.homeVelocity,
    9f94:	20 91 d4 7e 	lds	r18, 0x7ED4
    9f98:	30 91 d5 7e 	lds	r19, 0x7ED5
    9f9c:	40 91 d6 7e 	lds	r20, 0x7ED6
    9fa0:	50 91 d7 7e 	lds	r21, 0x7ED7
    9fa4:	e0 90 d8 7e 	lds	r14, 0x7ED8
    9fa8:	f0 90 d9 7e 	lds	r15, 0x7ED9
    9fac:	00 91 da 7e 	lds	r16, 0x7EDA
    9fb0:	10 91 db 7e 	lds	r17, 0x7EDB
    9fb4:	60 e0       	ldi	r22, 0x00	; 0
    9fb6:	70 e0       	ldi	r23, 0x00	; 0
    9fb8:	80 e0       	ldi	r24, 0x00	; 0
    9fba:	90 e0       	ldi	r25, 0x00	; 0
    9fbc:	a0 ef       	ldi	r26, 0xF0	; 240
    9fbe:	ca 2e       	mov	r12, r26
    9fc0:	af ef       	ldi	r26, 0xFF	; 255
    9fc2:	da 2e       	mov	r13, r26
    9fc4:	f3 e0       	ldi	r31, 0x03	; 3
    9fc6:	af 2e       	mov	r10, r31
    9fc8:	b1 2c       	mov	r11, r1
    9fca:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <pitch>
    9fce:	19 c0       	rjmp	.+50     	; 0xa002 <initializeAxis+0x232>
						hAxis[Axis].axisSettings.homeAcceleration,update,EN_CALIBRACION_PROCESOHOME ); 
		break;
		
		default:
			mov_axis(Axis,HOME,hAxis[Axis].axisSettings.homeVelocity,
    9fd0:	f7 01       	movw	r30, r14
    9fd2:	e0 5c       	subi	r30, 0xC0	; 192
    9fd4:	ff 4f       	sbci	r31, 0xFF	; 255
    9fd6:	00 81       	ld	r16, Z
    9fd8:	11 81       	ldd	r17, Z+1	; 0x01
    9fda:	22 81       	ldd	r18, Z+2	; 0x02
    9fdc:	33 81       	ldd	r19, Z+3	; 0x03
    9fde:	f7 01       	movw	r30, r14
    9fe0:	ec 5b       	subi	r30, 0xBC	; 188
    9fe2:	ff 4f       	sbci	r31, 0xFF	; 255
    9fe4:	c0 80       	ld	r12, Z
    9fe6:	d1 80       	ldd	r13, Z+1	; 0x01
    9fe8:	e2 80       	ldd	r14, Z+2	; 0x02
    9fea:	f3 80       	ldd	r15, Z+3	; 0x03
    9fec:	c4 01       	movw	r24, r8
    9fee:	40 e0       	ldi	r20, 0x00	; 0
    9ff0:	50 e0       	ldi	r21, 0x00	; 0
    9ff2:	60 e0       	ldi	r22, 0x00	; 0
    9ff4:	70 e0       	ldi	r23, 0x00	; 0
    9ff6:	e0 ef       	ldi	r30, 0xF0	; 240
    9ff8:	ae 2e       	mov	r10, r30
    9ffa:	ef ef       	ldi	r30, 0xFF	; 255
    9ffc:	be 2e       	mov	r11, r30
    9ffe:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
						hAxis[Axis].axisSettings.homeAcceleration,update); 
	    break;
	}

	//habilitada las interrupciones hacia el uControlador
	HostInterruptEnable();
    a002:	0e 94 21 5f 	call	0xbe42	; 0xbe42 <HostInterruptEnable>
	return rc;
	
}
    a006:	80 e0       	ldi	r24, 0x00	; 0
    a008:	90 e0       	ldi	r25, 0x00	; 0
    a00a:	60 96       	adiw	r28, 0x10	; 16
    a00c:	0f b6       	in	r0, 0x3f	; 63
    a00e:	f8 94       	cli
    a010:	de bf       	out	0x3e, r29	; 62
    a012:	0f be       	out	0x3f, r0	; 63
    a014:	cd bf       	out	0x3d, r28	; 61
    a016:	cf 91       	pop	r28
    a018:	df 91       	pop	r29
    a01a:	1f 91       	pop	r17
    a01c:	0f 91       	pop	r16
    a01e:	ff 90       	pop	r15
    a020:	ef 90       	pop	r14
    a022:	df 90       	pop	r13
    a024:	cf 90       	pop	r12
    a026:	bf 90       	pop	r11
    a028:	af 90       	pop	r10
    a02a:	9f 90       	pop	r9
    a02c:	8f 90       	pop	r8
    a02e:	08 95       	ret

0000a030 <mov_correlacionado>:
//**********************************************************************************************
//Solo carga los registros no efectua movimiento.
//Al mover el EJe1 se tiene que mover proporcionalmente el Eje2
void mov_correlacionado( tTrajectory   *TrajectoryPOINT, int16 pointIndex,
						tAxis Eje1, tAxis Eje2, double FACTOR_CORRELACION)
{
    a030:	2f 92       	push	r2
    a032:	3f 92       	push	r3
    a034:	4f 92       	push	r4
    a036:	5f 92       	push	r5
    a038:	6f 92       	push	r6
    a03a:	7f 92       	push	r7
    a03c:	8f 92       	push	r8
    a03e:	9f 92       	push	r9
    a040:	af 92       	push	r10
    a042:	bf 92       	push	r11
    a044:	cf 92       	push	r12
    a046:	df 92       	push	r13
    a048:	ef 92       	push	r14
    a04a:	ff 92       	push	r15
    a04c:	0f 93       	push	r16
    a04e:	1f 93       	push	r17
    a050:	df 93       	push	r29
    a052:	cf 93       	push	r28
    a054:	cd b7       	in	r28, 0x3d	; 61
    a056:	de b7       	in	r29, 0x3e	; 62
    a058:	69 97       	sbiw	r28, 0x19	; 25
    a05a:	0f b6       	in	r0, 0x3f	; 63
    a05c:	f8 94       	cli
    a05e:	de bf       	out	0x3e, r29	; 62
    a060:	0f be       	out	0x3f, r0	; 63
    a062:	cd bf       	out	0x3d, r28	; 61
    a064:	98 87       	std	Y+8, r25	; 0x08
    a066:	8f 83       	std	Y+7, r24	; 0x07
    a068:	1a 01       	movw	r2, r20
    a06a:	49 01       	movw	r8, r18
    a06c:	57 01       	movw	r10, r14
    a06e:	68 01       	movw	r12, r16
	#endif
	
	
	
	//Leyendo datos de la posicion final para el eje 1
	Velocity_Eje1=TrajectoryPOINT->point[pointIndex].axis[Eje1].velocity;
    a070:	8d e3       	ldi	r24, 0x3D	; 61
    a072:	90 e0       	ldi	r25, 0x00	; 0
    a074:	68 9f       	mul	r22, r24
    a076:	90 01       	movw	r18, r0
    a078:	69 9f       	mul	r22, r25
    a07a:	30 0d       	add	r19, r0
    a07c:	78 9f       	mul	r23, r24
    a07e:	30 0d       	add	r19, r0
    a080:	11 24       	eor	r1, r1
    a082:	3e 83       	std	Y+6, r19	; 0x06
    a084:	2d 83       	std	Y+5, r18	; 0x05
    a086:	ef 81       	ldd	r30, Y+7	; 0x07
    a088:	f8 85       	ldd	r31, Y+8	; 0x08
    a08a:	04 80       	ldd	r0, Z+4	; 0x04
    a08c:	f5 81       	ldd	r31, Z+5	; 0x05
    a08e:	e0 2d       	mov	r30, r0
    a090:	e2 0f       	add	r30, r18
    a092:	f3 1f       	adc	r31, r19
    a094:	fe 8b       	std	Y+22, r31	; 0x16
    a096:	ed 8b       	std	Y+21, r30	; 0x15
    a098:	da 01       	movw	r26, r20
    a09a:	aa 0f       	add	r26, r26
    a09c:	bb 1f       	adc	r27, r27
    a09e:	a4 0f       	add	r26, r20
    a0a0:	b5 1f       	adc	r27, r21
    a0a2:	fd 01       	movw	r30, r26
    a0a4:	31 96       	adiw	r30, 0x01	; 1
    a0a6:	ee 0f       	add	r30, r30
    a0a8:	ff 1f       	adc	r31, r31
    a0aa:	ee 0f       	add	r30, r30
    a0ac:	ff 1f       	adc	r31, r31
    a0ae:	2d 89       	ldd	r18, Y+21	; 0x15
    a0b0:	3e 89       	ldd	r19, Y+22	; 0x16
    a0b2:	e2 0f       	add	r30, r18
    a0b4:	f3 1f       	adc	r31, r19
    a0b6:	60 81       	ld	r22, Z
    a0b8:	71 81       	ldd	r23, Z+1	; 0x01
    a0ba:	82 81       	ldd	r24, Z+2	; 0x02
    a0bc:	93 81       	ldd	r25, Z+3	; 0x03
	Acceleration_Eje1=TrajectoryPOINT->point[pointIndex].axis[Eje1].acceleration;
    a0be:	aa 0f       	add	r26, r26
    a0c0:	bb 1f       	adc	r27, r27
    a0c2:	aa 0f       	add	r26, r26
    a0c4:	bb 1f       	adc	r27, r27
    a0c6:	a2 0f       	add	r26, r18
    a0c8:	b3 1f       	adc	r27, r19
    a0ca:	18 96       	adiw	r26, 0x08	; 8
    a0cc:	ed 90       	ld	r14, X+
    a0ce:	fd 90       	ld	r15, X+
    a0d0:	0d 91       	ld	r16, X+
    a0d2:	1c 91       	ld	r17, X
    a0d4:	1b 97       	sbiw	r26, 0x0b	; 11
	position_Eje1 = TrajectoryPOINT->point[pointIndex].axis[Eje1].position;
    a0d6:	2d 91       	ld	r18, X+
    a0d8:	3d 91       	ld	r19, X+
    a0da:	4d 91       	ld	r20, X+
    a0dc:	5c 91       	ld	r21, X
    a0de:	29 83       	std	Y+1, r18	; 0x01
    a0e0:	3a 83       	std	Y+2, r19	; 0x02
    a0e2:	4b 83       	std	Y+3, r20	; 0x03
    a0e4:	5c 83       	std	Y+4, r21	; 0x04
	
	//Leyendo datos de la posicion final para el eje 2
	position_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].position;
    a0e6:	f4 01       	movw	r30, r8
    a0e8:	ee 0f       	add	r30, r30
    a0ea:	ff 1f       	adc	r31, r31
    a0ec:	e8 0d       	add	r30, r8
    a0ee:	f9 1d       	adc	r31, r9
    a0f0:	df 01       	movw	r26, r30
    a0f2:	aa 0f       	add	r26, r26
    a0f4:	bb 1f       	adc	r27, r27
    a0f6:	aa 0f       	add	r26, r26
    a0f8:	bb 1f       	adc	r27, r27
    a0fa:	4d 89       	ldd	r20, Y+21	; 0x15
    a0fc:	5e 89       	ldd	r21, Y+22	; 0x16
    a0fe:	a4 0f       	add	r26, r20
    a100:	b5 1f       	adc	r27, r21
    a102:	4d 90       	ld	r4, X+
    a104:	5d 90       	ld	r5, X+
    a106:	6d 90       	ld	r6, X+
    a108:	7c 90       	ld	r7, X
    a10a:	13 97       	sbiw	r26, 0x03	; 3
	Velocity_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].velocity;
    a10c:	31 96       	adiw	r30, 0x01	; 1
    a10e:	ee 0f       	add	r30, r30
    a110:	ff 1f       	adc	r31, r31
    a112:	ee 0f       	add	r30, r30
    a114:	ff 1f       	adc	r31, r31
    a116:	e4 0f       	add	r30, r20
    a118:	f5 1f       	adc	r31, r21
    a11a:	50 81       	ld	r21, Z
    a11c:	59 8f       	std	Y+25, r21	; 0x19
    a11e:	31 81       	ldd	r19, Z+1	; 0x01
    a120:	42 81       	ldd	r20, Z+2	; 0x02
    a122:	53 81       	ldd	r21, Z+3	; 0x03
	Acceleration_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].acceleration;
    a124:	fd 01       	movw	r30, r26
    a126:	38 96       	adiw	r30, 0x08	; 8
    a128:	f8 8f       	std	Y+24, r31	; 0x18
    a12a:	ef 8b       	std	Y+23, r30	; 0x17
    a12c:	18 96       	adiw	r26, 0x08	; 8
    a12e:	fc 91       	ld	r31, X
    a130:	f9 8b       	std	Y+17, r31	; 0x11
    a132:	ef 89       	ldd	r30, Y+23	; 0x17
    a134:	f8 8d       	ldd	r31, Y+24	; 0x18
    a136:	f1 81       	ldd	r31, Z+1	; 0x01
    a138:	fa 8b       	std	Y+18, r31	; 0x12
    a13a:	ef 89       	ldd	r30, Y+23	; 0x17
    a13c:	f8 8d       	ldd	r31, Y+24	; 0x18
    a13e:	f2 81       	ldd	r31, Z+2	; 0x02
    a140:	fb 8b       	std	Y+19, r31	; 0x13
    a142:	ef 89       	ldd	r30, Y+23	; 0x17
    a144:	f8 8d       	ldd	r31, Y+24	; 0x18
    a146:	f3 81       	ldd	r31, Z+3	; 0x03
    a148:	fc 8b       	std	Y+20, r31	; 0x14
	
	/*La Velocidad del Eje2 es igual a la del Registro del Eje2 + la velocidad del Eje1 X factor de correlacion*/
	if(Velocity_Eje1 != 0)
    a14a:	61 15       	cp	r22, r1
    a14c:	71 05       	cpc	r23, r1
    a14e:	81 05       	cpc	r24, r1
    a150:	91 05       	cpc	r25, r1
    a152:	31 f4       	brne	.+12     	; 0xa160 <mov_correlacionado+0x130>
	Acceleration_Eje1=TrajectoryPOINT->point[pointIndex].axis[Eje1].acceleration;
	position_Eje1 = TrajectoryPOINT->point[pointIndex].axis[Eje1].position;
	
	//Leyendo datos de la posicion final para el eje 2
	position_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].position;
	Velocity_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].velocity;
    a154:	29 8d       	ldd	r18, Y+25	; 0x19
    a156:	29 87       	std	Y+9, r18	; 0x09
    a158:	3a 87       	std	Y+10, r19	; 0x0a
    a15a:	4b 87       	std	Y+11, r20	; 0x0b
    a15c:	5c 87       	std	Y+12, r21	; 0x0c
    a15e:	0c c0       	rjmp	.+24     	; 0xa178 <mov_correlacionado+0x148>
	Acceleration_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].acceleration;
	
	/*La Velocidad del Eje2 es igual a la del Registro del Eje2 + la velocidad del Eje1 X factor de correlacion*/
	if(Velocity_Eje1 != 0)
	{
		Velocity_Eje2 = (Velocity_Eje1*FACTOR_CORRELACION);
    a160:	0e 94 02 84 	call	0x10804	; 0x10804 <__floatunsisf>
    a164:	a6 01       	movw	r20, r12
    a166:	95 01       	movw	r18, r10
    a168:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    a16c:	0e 94 d6 83 	call	0x107ac	; 0x107ac <__fixunssfsi>
    a170:	69 87       	std	Y+9, r22	; 0x09
    a172:	7a 87       	std	Y+10, r23	; 0x0a
    a174:	8b 87       	std	Y+11, r24	; 0x0b
    a176:	9c 87       	std	Y+12, r25	; 0x0c
		
	}
	
	if(Acceleration_Eje1 != 0)
    a178:	e1 14       	cp	r14, r1
    a17a:	f1 04       	cpc	r15, r1
    a17c:	01 05       	cpc	r16, r1
    a17e:	11 05       	cpc	r17, r1
    a180:	49 f4       	brne	.+18     	; 0xa194 <mov_correlacionado+0x164>
	position_Eje1 = TrajectoryPOINT->point[pointIndex].axis[Eje1].position;
	
	//Leyendo datos de la posicion final para el eje 2
	position_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].position;
	Velocity_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].velocity;
	Acceleration_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].acceleration;
    a182:	39 89       	ldd	r19, Y+17	; 0x11
    a184:	3d 87       	std	Y+13, r19	; 0x0d
    a186:	4a 89       	ldd	r20, Y+18	; 0x12
    a188:	4e 87       	std	Y+14, r20	; 0x0e
    a18a:	5b 89       	ldd	r21, Y+19	; 0x13
    a18c:	5f 87       	std	Y+15, r21	; 0x0f
    a18e:	8c 89       	ldd	r24, Y+20	; 0x14
    a190:	88 8b       	std	Y+16, r24	; 0x10
    a192:	0e c0       	rjmp	.+28     	; 0xa1b0 <mov_correlacionado+0x180>
		
	}
	
	if(Acceleration_Eje1 != 0)
	{
		Acceleration_Eje2 =  (Acceleration_Eje1*FACTOR_CORRELACION);
    a194:	c8 01       	movw	r24, r16
    a196:	b7 01       	movw	r22, r14
    a198:	0e 94 02 84 	call	0x10804	; 0x10804 <__floatunsisf>
    a19c:	a6 01       	movw	r20, r12
    a19e:	95 01       	movw	r18, r10
    a1a0:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    a1a4:	0e 94 d6 83 	call	0x107ac	; 0x107ac <__fixunssfsi>
    a1a8:	6d 87       	std	Y+13, r22	; 0x0d
    a1aa:	7e 87       	std	Y+14, r23	; 0x0e
    a1ac:	8f 87       	std	Y+15, r24	; 0x0f
    a1ae:	98 8b       	std	Y+16, r25	; 0x10
	
	//INTERACCION Eje1-Eje2
	
	/*La Posicion del Eje2 es igual al valor almacenado en el registro del Eje2 + la poscion
	del Eje1*FaCTOR DE CORRELACION*/
	position_Eje2_de_Correlacion = position_Eje2+(position_Eje1 * FACTOR_CORRELACION);	
    a1b0:	c3 01       	movw	r24, r6
    a1b2:	b2 01       	movw	r22, r4
    a1b4:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    a1b8:	7b 01       	movw	r14, r22
    a1ba:	8c 01       	movw	r16, r24
    a1bc:	69 81       	ldd	r22, Y+1	; 0x01
    a1be:	7a 81       	ldd	r23, Y+2	; 0x02
    a1c0:	8b 81       	ldd	r24, Y+3	; 0x03
    a1c2:	9c 81       	ldd	r25, Y+4	; 0x04
    a1c4:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    a1c8:	a6 01       	movw	r20, r12
    a1ca:	95 01       	movw	r18, r10
    a1cc:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    a1d0:	9b 01       	movw	r18, r22
    a1d2:	ac 01       	movw	r20, r24
    a1d4:	c8 01       	movw	r24, r16
    a1d6:	b7 01       	movw	r22, r14
    a1d8:	0e 94 01 83 	call	0x10602	; 0x10602 <__addsf3>
    a1dc:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    a1e0:	8b 01       	movw	r16, r22
    a1e2:	9c 01       	movw	r18, r24
    a1e4:	76 2e       	mov	r7, r22
    a1e6:	61 2e       	mov	r6, r17
    a1e8:	52 2e       	mov	r5, r18
    a1ea:	43 2e       	mov	r4, r19
		printf("mov_correlacionado => position Eje %s deseada(Formula)= %ld\n",AxisName(Eje2),position_Eje2_de_Correlacion);
	
	 #endif
	
	/*Muevo el Eje2 con esos datos */
	if (Eje2==AxisPitch)
    a1ec:	93 e0       	ldi	r25, 0x03	; 3
    a1ee:	89 16       	cp	r8, r25
    a1f0:	91 04       	cpc	r9, r1
    a1f2:	d1 f4       	brne	.+52     	; 0xa228 <mov_correlacionado+0x1f8>
	{	
		/*Almaceno la posicion final del pitch, es necesaria para 
                reconfiguracion del movimiento*/
                TrajectoryPOINT->point[pointIndex].axis[Eje2].position=position_Eje2_de_Correlacion;
    a1f4:	ed 89       	ldd	r30, Y+21	; 0x15
    a1f6:	fe 89       	ldd	r31, Y+22	; 0x16
    a1f8:	04 a3       	std	Z+36, r16	; 0x24
    a1fa:	15 a3       	std	Z+37, r17	; 0x25
    a1fc:	26 a3       	std	Z+38, r18	; 0x26
    a1fe:	37 a3       	std	Z+39, r19	; 0x27
		pitch(position_Eje2_de_Correlacion,Velocity_Eje2,Acceleration_Eje2,no_update,MOVIMIENTO_NORMAL );
    a200:	b8 01       	movw	r22, r16
    a202:	c9 01       	movw	r24, r18
    a204:	29 85       	ldd	r18, Y+9	; 0x09
    a206:	3a 85       	ldd	r19, Y+10	; 0x0a
    a208:	4b 85       	ldd	r20, Y+11	; 0x0b
    a20a:	5c 85       	ldd	r21, Y+12	; 0x0c
    a20c:	ed 84       	ldd	r14, Y+13	; 0x0d
    a20e:	fe 84       	ldd	r15, Y+14	; 0x0e
    a210:	0f 85       	ldd	r16, Y+15	; 0x0f
    a212:	18 89       	ldd	r17, Y+16	; 0x10
    a214:	af ee       	ldi	r26, 0xEF	; 239
    a216:	ca 2e       	mov	r12, r26
    a218:	af ef       	ldi	r26, 0xFF	; 255
    a21a:	da 2e       	mov	r13, r26
    a21c:	f1 e0       	ldi	r31, 0x01	; 1
    a21e:	af 2e       	mov	r10, r31
    a220:	b1 2c       	mov	r11, r1
    a222:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <pitch>
    a226:	11 c0       	rjmp	.+34     	; 0xa24a <mov_correlacionado+0x21a>
	}
	else
	{
		mov_axis(Eje2,position_Eje2_de_Correlacion,Velocity_Eje2,Acceleration_Eje2,no_update);	
    a228:	c4 01       	movw	r24, r8
    a22a:	a8 01       	movw	r20, r16
    a22c:	b9 01       	movw	r22, r18
    a22e:	09 85       	ldd	r16, Y+9	; 0x09
    a230:	1a 85       	ldd	r17, Y+10	; 0x0a
    a232:	2b 85       	ldd	r18, Y+11	; 0x0b
    a234:	3c 85       	ldd	r19, Y+12	; 0x0c
    a236:	cd 84       	ldd	r12, Y+13	; 0x0d
    a238:	de 84       	ldd	r13, Y+14	; 0x0e
    a23a:	ef 84       	ldd	r14, Y+15	; 0x0f
    a23c:	f8 88       	ldd	r15, Y+16	; 0x10
    a23e:	ef ee       	ldi	r30, 0xEF	; 239
    a240:	ae 2e       	mov	r10, r30
    a242:	ef ef       	ldi	r30, 0xFF	; 255
    a244:	be 2e       	mov	r11, r30
    a246:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
	}			
	
	
	
	
	if(Eje1==AxisShoulder)
    a24a:	f1 e0       	ldi	r31, 0x01	; 1
    a24c:	2f 16       	cp	r2, r31
    a24e:	31 04       	cpc	r3, r1
    a250:	e9 f5       	brne	.+122    	; 0xa2cc <mov_correlacionado+0x29c>
	{
		#ifdef DEBUGROBOTICS				
		printf("mov_correlacionado =>  Actualizando valores de codo \n");
		#endif
		TrajectoryPOINT->point[pointIndex].axis[Eje2].position=position_Eje2_de_Correlacion;
    a252:	ef 81       	ldd	r30, Y+7	; 0x07
    a254:	f8 85       	ldd	r31, Y+8	; 0x08
    a256:	84 81       	ldd	r24, Z+4	; 0x04
    a258:	95 81       	ldd	r25, Z+5	; 0x05
    a25a:	2d 81       	ldd	r18, Y+5	; 0x05
    a25c:	3e 81       	ldd	r19, Y+6	; 0x06
    a25e:	82 0f       	add	r24, r18
    a260:	93 1f       	adc	r25, r19
    a262:	f4 01       	movw	r30, r8
    a264:	ee 0f       	add	r30, r30
    a266:	ff 1f       	adc	r31, r31
    a268:	e8 0d       	add	r30, r8
    a26a:	f9 1d       	adc	r31, r9
    a26c:	df 01       	movw	r26, r30
    a26e:	aa 0f       	add	r26, r26
    a270:	bb 1f       	adc	r27, r27
    a272:	aa 0f       	add	r26, r26
    a274:	bb 1f       	adc	r27, r27
    a276:	a8 0f       	add	r26, r24
    a278:	b9 1f       	adc	r27, r25
    a27a:	7c 92       	st	X, r7
    a27c:	11 96       	adiw	r26, 0x01	; 1
    a27e:	6c 92       	st	X, r6
    a280:	11 97       	sbiw	r26, 0x01	; 1
    a282:	12 96       	adiw	r26, 0x02	; 2
    a284:	5c 92       	st	X, r5
    a286:	12 97       	sbiw	r26, 0x02	; 2
    a288:	13 96       	adiw	r26, 0x03	; 3
    a28a:	4c 92       	st	X, r4
    a28c:	13 97       	sbiw	r26, 0x03	; 3
		TrajectoryPOINT->point[pointIndex].axis[Eje2].velocity=Velocity_Eje2;
    a28e:	9f 01       	movw	r18, r30
    a290:	2f 5f       	subi	r18, 0xFF	; 255
    a292:	3f 4f       	sbci	r19, 0xFF	; 255
    a294:	22 0f       	add	r18, r18
    a296:	33 1f       	adc	r19, r19
    a298:	22 0f       	add	r18, r18
    a29a:	33 1f       	adc	r19, r19
    a29c:	28 0f       	add	r18, r24
    a29e:	39 1f       	adc	r19, r25
    a2a0:	49 85       	ldd	r20, Y+9	; 0x09
    a2a2:	f9 01       	movw	r30, r18
    a2a4:	40 83       	st	Z, r20
    a2a6:	5a 85       	ldd	r21, Y+10	; 0x0a
    a2a8:	51 83       	std	Z+1, r21	; 0x01
    a2aa:	8b 85       	ldd	r24, Y+11	; 0x0b
    a2ac:	82 83       	std	Z+2, r24	; 0x02
    a2ae:	9c 85       	ldd	r25, Y+12	; 0x0c
    a2b0:	93 83       	std	Z+3, r25	; 0x03
		TrajectoryPOINT->point[pointIndex].axis[Eje2].acceleration=Acceleration_Eje2;
    a2b2:	9d 01       	movw	r18, r26
    a2b4:	28 5f       	subi	r18, 0xF8	; 248
    a2b6:	3f 4f       	sbci	r19, 0xFF	; 255
    a2b8:	ed 85       	ldd	r30, Y+13	; 0x0d
    a2ba:	18 96       	adiw	r26, 0x08	; 8
    a2bc:	ec 93       	st	X, r30
    a2be:	4e 85       	ldd	r20, Y+14	; 0x0e
    a2c0:	f9 01       	movw	r30, r18
    a2c2:	41 83       	std	Z+1, r20	; 0x01
    a2c4:	5f 85       	ldd	r21, Y+15	; 0x0f
    a2c6:	52 83       	std	Z+2, r21	; 0x02
    a2c8:	88 89       	ldd	r24, Y+16	; 0x10
    a2ca:	83 83       	std	Z+3, r24	; 0x03
	#ifdef DEBUGROBOTICS				
	//scanf("%d",&temp);
	#endif
		
	
}
    a2cc:	69 96       	adiw	r28, 0x19	; 25
    a2ce:	0f b6       	in	r0, 0x3f	; 63
    a2d0:	f8 94       	cli
    a2d2:	de bf       	out	0x3e, r29	; 62
    a2d4:	0f be       	out	0x3f, r0	; 63
    a2d6:	cd bf       	out	0x3d, r28	; 61
    a2d8:	cf 91       	pop	r28
    a2da:	df 91       	pop	r29
    a2dc:	1f 91       	pop	r17
    a2de:	0f 91       	pop	r16
    a2e0:	ff 90       	pop	r15
    a2e2:	ef 90       	pop	r14
    a2e4:	df 90       	pop	r13
    a2e6:	cf 90       	pop	r12
    a2e8:	bf 90       	pop	r11
    a2ea:	af 90       	pop	r10
    a2ec:	9f 90       	pop	r9
    a2ee:	8f 90       	pop	r8
    a2f0:	7f 90       	pop	r7
    a2f2:	6f 90       	pop	r6
    a2f4:	5f 90       	pop	r5
    a2f6:	4f 90       	pop	r4
    a2f8:	3f 90       	pop	r3
    a2fa:	2f 90       	pop	r2
    a2fc:	08 95       	ret

0000a2fe <teach_pendant_point>:
	return rc;
	
}
/*****************************************************************************************/
void teach_pendant_point(tTrajectory   *TrajectoryPOINT,int16 pointIndex )
{
    a2fe:	2f 92       	push	r2
    a300:	3f 92       	push	r3
    a302:	4f 92       	push	r4
    a304:	5f 92       	push	r5
    a306:	6f 92       	push	r6
    a308:	7f 92       	push	r7
    a30a:	8f 92       	push	r8
    a30c:	9f 92       	push	r9
    a30e:	af 92       	push	r10
    a310:	bf 92       	push	r11
    a312:	cf 92       	push	r12
    a314:	df 92       	push	r13
    a316:	ef 92       	push	r14
    a318:	ff 92       	push	r15
    a31a:	0f 93       	push	r16
    a31c:	1f 93       	push	r17
    a31e:	df 93       	push	r29
    a320:	cf 93       	push	r28
    a322:	cd b7       	in	r28, 0x3d	; 61
    a324:	de b7       	in	r29, 0x3e	; 62
    a326:	ae 97       	sbiw	r28, 0x2e	; 46
    a328:	0f b6       	in	r0, 0x3f	; 63
    a32a:	f8 94       	cli
    a32c:	de bf       	out	0x3e, r29	; 62
    a32e:	0f be       	out	0x3f, r0	; 63
    a330:	cd bf       	out	0x3d, r28	; 61
    a332:	3c 01       	movw	r6, r24
    a334:	2b 01       	movw	r4, r22
	position=0;
	velocity=0;
	acceleration=0;
	reconf_Elbow=0;
	reconf_Pitch=0;
	Enable_Mov();		
    a336:	0e 94 0a 37 	call	0x6e14	; 0x6e14 <Enable_Mov>
	mask= TrajectoryPOINT->invalidmask;
    a33a:	d3 01       	movw	r26, r6
    a33c:	12 96       	adiw	r26, 0x02	; 2
    a33e:	0d 90       	ld	r0, X+
    a340:	bc 91       	ld	r27, X
    a342:	a0 2d       	mov	r26, r0
    a344:	ba 8b       	std	Y+18, r27	; 0x12
    a346:	a9 8b       	std	Y+17, r26	; 0x11
	
	
	/*Posicion Actual de Hombro y codo y Pitch*/
	PMDGetPosition(&hAxis[AxisShoulder],&actual_shoulder_position);
    a348:	84 ed       	ldi	r24, 0xD4	; 212
    a34a:	9d e7       	ldi	r25, 0x7D	; 125
    a34c:	be 01       	movw	r22, r28
    a34e:	6d 5f       	subi	r22, 0xFD	; 253
    a350:	7f 4f       	sbci	r23, 0xFF	; 255
    a352:	0e 94 b6 64 	call	0xc96c	; 0xc96c <PMDGetPosition>
	PMDGetPosition(&hAxis[AxisElbow],&actual_elbow_position);
    a356:	84 e3       	ldi	r24, 0x34	; 52
    a358:	9e e7       	ldi	r25, 0x7E	; 126
    a35a:	be 01       	movw	r22, r28
    a35c:	69 5f       	subi	r22, 0xF9	; 249
    a35e:	7f 4f       	sbci	r23, 0xFF	; 255
    a360:	0e 94 b6 64 	call	0xc96c	; 0xc96c <PMDGetPosition>
	
	
	printf("teach_pendant_point=> Ejecutando movimiento o pose asignada\n");
    a364:	8f ea       	ldi	r24, 0xAF	; 175
    a366:	90 e6       	ldi	r25, 0x60	; 96
    a368:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
					default:
						//Aplica solo  para cintura.
						
					break;
				}				
				TrajectoryPOINT->point[pointIndex].axis[axis].position= actual_position;
    a36c:	8d e3       	ldi	r24, 0x3D	; 61
    a36e:	90 e0       	ldi	r25, 0x00	; 0
    a370:	48 9e       	mul	r4, r24
    a372:	10 01       	movw	r2, r0
    a374:	49 9e       	mul	r4, r25
    a376:	30 0c       	add	r3, r0
    a378:	58 9e       	mul	r5, r24
    a37a:	30 0c       	add	r3, r0
    a37c:	11 24       	eor	r1, r1
    a37e:	e4 e7       	ldi	r30, 0x74	; 116
    a380:	fd e7       	ldi	r31, 0x7D	; 125
    a382:	f8 8b       	std	Y+16, r31	; 0x10
    a384:	ef 87       	std	Y+15, r30	; 0x0f
    a386:	5f 01       	movw	r10, r30
    a388:	cc 24       	eor	r12, r12
    a38a:	dd 24       	eor	r13, r13
		{	
			 // El eje no esta habilitado para el movimiento, igual tengo que mantener la posicion actual
			if( ( mask & Axis2AxisMask(axis) )== 0 )     
			{
				//Obtengo la posicion ANTES de actualizar!
				PMDGetPosition(&hAxis[axis],&actual_position);	
    a38c:	8b e0       	ldi	r24, 0x0B	; 11
    a38e:	88 2e       	mov	r8, r24
    a390:	91 2c       	mov	r9, r1
    a392:	8c 0e       	add	r8, r28
    a394:	9d 1e       	adc	r9, r29
	//Configuro condiciones iniciales (Caso en el eje no se selecciona para el movimiento, 
	//por tal motivo debe mantener el valor en donde se encuentra)
	for(axis=0; axis < DOF; axis++) 
	{  
		
		if ( hAxis[axis].axisSettings.axisEnabled == TRUE) 		
    a396:	d5 01       	movw	r26, r10
    a398:	14 96       	adiw	r26, 0x04	; 4
    a39a:	8c 91       	ld	r24, X
    a39c:	81 30       	cpi	r24, 0x01	; 1
    a39e:	09 f0       	breq	.+2      	; 0xa3a2 <teach_pendant_point+0xa4>
    a3a0:	8b c0       	rjmp	.+278    	; 0xa4b8 <teach_pendant_point+0x1ba>
		{	
			 // El eje no esta habilitado para el movimiento, igual tengo que mantener la posicion actual
			if( ( mask & Axis2AxisMask(axis) )== 0 )     
    a3a2:	c6 01       	movw	r24, r12
    a3a4:	0e 94 60 18 	call	0x30c0	; 0x30c0 <Axis2AxisMask>
    a3a8:	e9 89       	ldd	r30, Y+17	; 0x11
    a3aa:	fa 89       	ldd	r31, Y+18	; 0x12
    a3ac:	8e 23       	and	r24, r30
    a3ae:	9f 23       	and	r25, r31
    a3b0:	89 2b       	or	r24, r25
    a3b2:	09 f0       	breq	.+2      	; 0xa3b6 <teach_pendant_point+0xb8>
    a3b4:	81 c0       	rjmp	.+258    	; 0xa4b8 <teach_pendant_point+0x1ba>
			{
				//Obtengo la posicion ANTES de actualizar!
				PMDGetPosition(&hAxis[axis],&actual_position);	
    a3b6:	c5 01       	movw	r24, r10
    a3b8:	b4 01       	movw	r22, r8
    a3ba:	0e 94 b6 64 	call	0xc96c	; 0xc96c <PMDGetPosition>
				
				switch (axis)
    a3be:	f2 e0       	ldi	r31, 0x02	; 2
    a3c0:	cf 16       	cp	r12, r31
    a3c2:	d1 04       	cpc	r13, r1
    a3c4:	e9 f0       	breq	.+58     	; 0xa400 <teach_pendant_point+0x102>
    a3c6:	23 e0       	ldi	r18, 0x03	; 3
    a3c8:	c2 16       	cp	r12, r18
    a3ca:	d1 04       	cpc	r13, r1
    a3cc:	34 f4       	brge	.+12     	; 0xa3da <teach_pendant_point+0xdc>
    a3ce:	31 e0       	ldi	r19, 0x01	; 1
    a3d0:	c3 16       	cp	r12, r19
    a3d2:	d1 04       	cpc	r13, r1
    a3d4:	09 f0       	breq	.+2      	; 0xa3d8 <teach_pendant_point+0xda>
    a3d6:	56 c0       	rjmp	.+172    	; 0xa484 <teach_pendant_point+0x186>
    a3d8:	0a c0       	rjmp	.+20     	; 0xa3ee <teach_pendant_point+0xf0>
    a3da:	83 e0       	ldi	r24, 0x03	; 3
    a3dc:	c8 16       	cp	r12, r24
    a3de:	d1 04       	cpc	r13, r1
    a3e0:	11 f1       	breq	.+68     	; 0xa426 <teach_pendant_point+0x128>
    a3e2:	94 e0       	ldi	r25, 0x04	; 4
    a3e4:	c9 16       	cp	r12, r25
    a3e6:	d1 04       	cpc	r13, r1
    a3e8:	09 f0       	breq	.+2      	; 0xa3ec <teach_pendant_point+0xee>
    a3ea:	4c c0       	rjmp	.+152    	; 0xa484 <teach_pendant_point+0x186>
    a3ec:	44 c0       	rjmp	.+136    	; 0xa476 <teach_pendant_point+0x178>
				{
					
					case (AxisShoulder):
						actual_position=actual_shoulder_position;
    a3ee:	8b 81       	ldd	r24, Y+3	; 0x03
    a3f0:	9c 81       	ldd	r25, Y+4	; 0x04
    a3f2:	ad 81       	ldd	r26, Y+5	; 0x05
    a3f4:	be 81       	ldd	r27, Y+6	; 0x06
    a3f6:	8b 87       	std	Y+11, r24	; 0x0b
    a3f8:	9c 87       	std	Y+12, r25	; 0x0c
    a3fa:	ad 87       	std	Y+13, r26	; 0x0d
    a3fc:	be 87       	std	Y+14, r27	; 0x0e
    a3fe:	42 c0       	rjmp	.+132    	; 0xa484 <teach_pendant_point+0x186>
					break;
					case (AxisElbow):
						/*Se tiene la siguiente formula:
						Pos_Codo= Pos_Codo_inicial + PosHombro*(R_Codo/R_Hombro)
						Como es necesario la posicion inicial del codo se despeja, Pos_Codo_inicial.*/
						actual_position=(actual_position)-(actual_shoulder_position*CORRELACION_HOMBRO_CODO);					
    a400:	6b 85       	ldd	r22, Y+11	; 0x0b
    a402:	7c 85       	ldd	r23, Y+12	; 0x0c
    a404:	8d 85       	ldd	r24, Y+13	; 0x0d
    a406:	9e 85       	ldd	r25, Y+14	; 0x0e
    a408:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    a40c:	7b 01       	movw	r14, r22
    a40e:	8c 01       	movw	r16, r24
    a410:	6b 81       	ldd	r22, Y+3	; 0x03
    a412:	7c 81       	ldd	r23, Y+4	; 0x04
    a414:	8d 81       	ldd	r24, Y+5	; 0x05
    a416:	9e 81       	ldd	r25, Y+6	; 0x06
    a418:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    a41c:	2d e1       	ldi	r18, 0x1D	; 29
    a41e:	3a e5       	ldi	r19, 0x5A	; 90
    a420:	44 e5       	ldi	r20, 0x54	; 84
    a422:	5f eb       	ldi	r21, 0xBF	; 191
    a424:	19 c0       	rjmp	.+50     	; 0xa458 <teach_pendant_point+0x15a>
					break;
					case (AxisPitch):
						/* Leer el movimiento anterior de Pitch que esta almacenado en EEPROM*/
						eeprom_read_block((void*)&actual_position,(const void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    a426:	c4 01       	movw	r24, r8
    a428:	6a e5       	ldi	r22, 0x5A	; 90
    a42a:	71 e0       	ldi	r23, 0x01	; 1
    a42c:	44 e0       	ldi	r20, 0x04	; 4
    a42e:	50 e0       	ldi	r21, 0x00	; 0
    a430:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
						actual_position = (actual_position)-(actual_elbow_position*CORRELACION_CODO_PITCH);
    a434:	6b 85       	ldd	r22, Y+11	; 0x0b
    a436:	7c 85       	ldd	r23, Y+12	; 0x0c
    a438:	8d 85       	ldd	r24, Y+13	; 0x0d
    a43a:	9e 85       	ldd	r25, Y+14	; 0x0e
    a43c:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    a440:	7b 01       	movw	r14, r22
    a442:	8c 01       	movw	r16, r24
    a444:	6f 81       	ldd	r22, Y+7	; 0x07
    a446:	78 85       	ldd	r23, Y+8	; 0x08
    a448:	89 85       	ldd	r24, Y+9	; 0x09
    a44a:	9a 85       	ldd	r25, Y+10	; 0x0a
    a44c:	0e 94 04 84 	call	0x10808	; 0x10808 <__floatsisf>
    a450:	29 ec       	ldi	r18, 0xC9	; 201
    a452:	3e e8       	ldi	r19, 0x8E	; 142
    a454:	4d e8       	ldi	r20, 0x8D	; 141
    a456:	5c eb       	ldi	r21, 0xBC	; 188
    a458:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    a45c:	9b 01       	movw	r18, r22
    a45e:	ac 01       	movw	r20, r24
    a460:	c8 01       	movw	r24, r16
    a462:	b7 01       	movw	r22, r14
    a464:	0e 94 01 83 	call	0x10602	; 0x10602 <__addsf3>
    a468:	0e 94 d1 83 	call	0x107a2	; 0x107a2 <__fixsfsi>
    a46c:	6b 87       	std	Y+11, r22	; 0x0b
    a46e:	7c 87       	std	Y+12, r23	; 0x0c
    a470:	8d 87       	std	Y+13, r24	; 0x0d
    a472:	9e 87       	std	Y+14, r25	; 0x0e
    a474:	07 c0       	rjmp	.+14     	; 0xa484 <teach_pendant_point+0x186>
					break;
					case (AxisRoll):
						/* Leer el movimiento anterior de Roll que esta almacenado en EEPROM*/
						eeprom_read_block((void*)&actual_position,(const void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    a476:	c4 01       	movw	r24, r8
    a478:	66 e5       	ldi	r22, 0x56	; 86
    a47a:	71 e0       	ldi	r23, 0x01	; 1
    a47c:	44 e0       	ldi	r20, 0x04	; 4
    a47e:	50 e0       	ldi	r21, 0x00	; 0
    a480:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
					default:
						//Aplica solo  para cintura.
						
					break;
				}				
				TrajectoryPOINT->point[pointIndex].axis[axis].position= actual_position;
    a484:	d3 01       	movw	r26, r6
    a486:	14 96       	adiw	r26, 0x04	; 4
    a488:	ed 91       	ld	r30, X+
    a48a:	fc 91       	ld	r31, X
    a48c:	15 97       	sbiw	r26, 0x05	; 5
    a48e:	e2 0d       	add	r30, r2
    a490:	f3 1d       	adc	r31, r3
    a492:	c6 01       	movw	r24, r12
    a494:	88 0f       	add	r24, r24
    a496:	99 1f       	adc	r25, r25
    a498:	8c 0d       	add	r24, r12
    a49a:	9d 1d       	adc	r25, r13
    a49c:	88 0f       	add	r24, r24
    a49e:	99 1f       	adc	r25, r25
    a4a0:	88 0f       	add	r24, r24
    a4a2:	99 1f       	adc	r25, r25
    a4a4:	e8 0f       	add	r30, r24
    a4a6:	f9 1f       	adc	r31, r25
    a4a8:	8b 85       	ldd	r24, Y+11	; 0x0b
    a4aa:	9c 85       	ldd	r25, Y+12	; 0x0c
    a4ac:	ad 85       	ldd	r26, Y+13	; 0x0d
    a4ae:	be 85       	ldd	r27, Y+14	; 0x0e
    a4b0:	80 83       	st	Z, r24
    a4b2:	91 83       	std	Z+1, r25	; 0x01
    a4b4:	a2 83       	std	Z+2, r26	; 0x02
    a4b6:	b3 83       	std	Z+3, r27	; 0x03
		printf("teach_pendant_point=> actual_Elbow_position = %ld\n",actual_elbow_position);	
		printf("teach_pendant_point=> actual_pitch_position = %ld\n",actual_pitch_position);	
	#endif
	//Configuro condiciones iniciales (Caso en el eje no se selecciona para el movimiento, 
	//por tal motivo debe mantener el valor en donde se encuentra)
	for(axis=0; axis < DOF; axis++) 
    a4b8:	08 94       	sec
    a4ba:	c1 1c       	adc	r12, r1
    a4bc:	d1 1c       	adc	r13, r1
    a4be:	e0 e6       	ldi	r30, 0x60	; 96
    a4c0:	f0 e0       	ldi	r31, 0x00	; 0
    a4c2:	ae 0e       	add	r10, r30
    a4c4:	bf 1e       	adc	r11, r31
    a4c6:	f5 e0       	ldi	r31, 0x05	; 5
    a4c8:	cf 16       	cp	r12, r31
    a4ca:	d1 04       	cpc	r13, r1
    a4cc:	09 f0       	breq	.+2      	; 0xa4d0 <teach_pendant_point+0x1d2>
    a4ce:	63 cf       	rjmp	.-314    	; 0xa396 <teach_pendant_point+0x98>
				#endif
			}
		}
	}
	/*Salvo la velocidad y aceleracion de usuario de pitch y codo */
	velocity_elbow_usr=TrajectoryPOINT->point[pointIndex].axis[AxisElbow].velocity;
    a4d0:	d3 01       	movw	r26, r6
    a4d2:	14 96       	adiw	r26, 0x04	; 4
    a4d4:	ed 91       	ld	r30, X+
    a4d6:	fc 91       	ld	r31, X
    a4d8:	15 97       	sbiw	r26, 0x05	; 5
    a4da:	e2 0d       	add	r30, r2
    a4dc:	f3 1d       	adc	r31, r3
    a4de:	84 8d       	ldd	r24, Z+28	; 0x1c
    a4e0:	95 8d       	ldd	r25, Z+29	; 0x1d
    a4e2:	a6 8d       	ldd	r26, Z+30	; 0x1e
    a4e4:	b7 8d       	ldd	r27, Z+31	; 0x1f
    a4e6:	8b 8f       	std	Y+27, r24	; 0x1b
    a4e8:	9c 8f       	std	Y+28, r25	; 0x1c
    a4ea:	ad 8f       	std	Y+29, r26	; 0x1d
    a4ec:	be 8f       	std	Y+30, r27	; 0x1e
	acceleration_elbow_usr=TrajectoryPOINT->point[pointIndex].axis[AxisElbow].acceleration;
    a4ee:	80 a1       	ldd	r24, Z+32	; 0x20
    a4f0:	91 a1       	ldd	r25, Z+33	; 0x21
    a4f2:	a2 a1       	ldd	r26, Z+34	; 0x22
    a4f4:	b3 a1       	ldd	r27, Z+35	; 0x23
    a4f6:	8b 8b       	std	Y+19, r24	; 0x13
    a4f8:	9c 8b       	std	Y+20, r25	; 0x14
    a4fa:	ad 8b       	std	Y+21, r26	; 0x15
    a4fc:	be 8b       	std	Y+22, r27	; 0x16
	velocity_pich_usr=TrajectoryPOINT->point[pointIndex].axis[AxisPitch].velocity;
    a4fe:	80 a5       	ldd	r24, Z+40	; 0x28
    a500:	91 a5       	ldd	r25, Z+41	; 0x29
    a502:	a2 a5       	ldd	r26, Z+42	; 0x2a
    a504:	b3 a5       	ldd	r27, Z+43	; 0x2b
    a506:	8f 8b       	std	Y+23, r24	; 0x17
    a508:	98 8f       	std	Y+24, r25	; 0x18
    a50a:	a9 8f       	std	Y+25, r26	; 0x19
    a50c:	ba 8f       	std	Y+26, r27	; 0x1a
	acceleration_pich_usr=TrajectoryPOINT->point[pointIndex].axis[AxisPitch].acceleration;
    a50e:	94 a5       	ldd	r25, Z+44	; 0x2c
    a510:	9b a7       	std	Y+43, r25	; 0x2b
    a512:	a5 a5       	ldd	r26, Z+45	; 0x2d
    a514:	ac a7       	std	Y+44, r26	; 0x2c
    a516:	b6 a5       	ldd	r27, Z+46	; 0x2e
    a518:	bd a7       	std	Y+45, r27	; 0x2d
    a51a:	27 a5       	ldd	r18, Z+47	; 0x2f
    a51c:	2e a7       	std	Y+46, r18	; 0x2e
    a51e:	1f a2       	std	Y+39, r1	; 0x27
    a520:	18 a6       	std	Y+40, r1	; 0x28
    a522:	19 a6       	std	Y+41, r1	; 0x29
    a524:	1a a6       	std	Y+42, r1	; 0x2a
    a526:	1b a2       	std	Y+35, r1	; 0x23
    a528:	1c a2       	std	Y+36, r1	; 0x24
    a52a:	1d a2       	std	Y+37, r1	; 0x25
    a52c:	1e a2       	std	Y+38, r1	; 0x26
    a52e:	1f 8e       	std	Y+31, r1	; 0x1f
    a530:	18 a2       	std	Y+32, r1	; 0x20
    a532:	19 a2       	std	Y+33, r1	; 0x21
    a534:	1a a2       	std	Y+34, r1	; 0x22
    a536:	88 24       	eor	r8, r8
    a538:	99 24       	eor	r9, r9
	//Busco el primer eje seleccionado y configuro el resto, es decir que si encuentro que hombro es el primero, 
	//configuro hombro, codo, pitch y salgo imediatamente del for para no reconfigurar con datos erroneos los demas ejes
	for(axis=0; axis < DOF; axis++) 
	{  
		
		if ( hAxis[axis].axisSettings.axisEnabled == TRUE) 		
    a53a:	f4 01       	movw	r30, r8
    a53c:	ee 0f       	add	r30, r30
    a53e:	ff 1f       	adc	r31, r31
    a540:	e8 0d       	add	r30, r8
    a542:	f9 1d       	adc	r31, r9
    a544:	a5 e0       	ldi	r26, 0x05	; 5
    a546:	ee 0f       	add	r30, r30
    a548:	ff 1f       	adc	r31, r31
    a54a:	aa 95       	dec	r26
    a54c:	e1 f7       	brne	.-8      	; 0xa546 <teach_pendant_point+0x248>
    a54e:	e8 58       	subi	r30, 0x88	; 136
    a550:	f2 48       	sbci	r31, 0x82	; 130
    a552:	80 81       	ld	r24, Z
    a554:	81 30       	cpi	r24, 0x01	; 1
    a556:	09 f0       	breq	.+2      	; 0xa55a <teach_pendant_point+0x25c>
    a558:	d6 c0       	rjmp	.+428    	; 0xa706 <teach_pendant_point+0x408>
		{	
			 // El eje esta habilitado para el movimiento,
			if( ( mask & Axis2AxisMask(axis) )!= 0 )     
    a55a:	c4 01       	movw	r24, r8
    a55c:	0e 94 60 18 	call	0x30c0	; 0x30c0 <Axis2AxisMask>
    a560:	a9 89       	ldd	r26, Y+17	; 0x11
    a562:	ba 89       	ldd	r27, Y+18	; 0x12
    a564:	8a 23       	and	r24, r26
    a566:	9b 23       	and	r25, r27
    a568:	89 2b       	or	r24, r25
    a56a:	09 f4       	brne	.+2      	; 0xa56e <teach_pendant_point+0x270>
    a56c:	cc c0       	rjmp	.+408    	; 0xa706 <teach_pendant_point+0x408>
			{	
				switch (axis)
    a56e:	b2 e0       	ldi	r27, 0x02	; 2
    a570:	8b 16       	cp	r8, r27
    a572:	91 04       	cpc	r9, r1
    a574:	81 f1       	breq	.+96     	; 0xa5d6 <teach_pendant_point+0x2d8>
    a576:	e3 e0       	ldi	r30, 0x03	; 3
    a578:	8e 16       	cp	r8, r30
    a57a:	91 04       	cpc	r9, r1
    a57c:	34 f4       	brge	.+12     	; 0xa58a <teach_pendant_point+0x28c>
    a57e:	f1 e0       	ldi	r31, 0x01	; 1
    a580:	8f 16       	cp	r8, r31
    a582:	91 04       	cpc	r9, r1
    a584:	09 f0       	breq	.+2      	; 0xa588 <teach_pendant_point+0x28a>
    a586:	94 c0       	rjmp	.+296    	; 0xa6b0 <teach_pendant_point+0x3b2>
    a588:	0b c0       	rjmp	.+22     	; 0xa5a0 <teach_pendant_point+0x2a2>
    a58a:	23 e0       	ldi	r18, 0x03	; 3
    a58c:	82 16       	cp	r8, r18
    a58e:	91 04       	cpc	r9, r1
    a590:	09 f4       	brne	.+2      	; 0xa594 <teach_pendant_point+0x296>
    a592:	49 c0       	rjmp	.+146    	; 0xa626 <teach_pendant_point+0x328>
    a594:	34 e0       	ldi	r19, 0x04	; 4
    a596:	83 16       	cp	r8, r19
    a598:	91 04       	cpc	r9, r1
    a59a:	09 f0       	breq	.+2      	; 0xa59e <teach_pendant_point+0x2a0>
    a59c:	89 c0       	rjmp	.+274    	; 0xa6b0 <teach_pendant_point+0x3b2>
    a59e:	68 c0       	rjmp	.+208    	; 0xa670 <teach_pendant_point+0x372>
				{
					case (AxisShoulder):
						//No depende de nadie va directo...  
						//(Siempre entra aqui cuando se usa con una trayectoria )..
						mov_axis(AxisShoulder,TrajectoryPOINT->point[pointIndex].axis[axis].position, 
    a5a0:	d3 01       	movw	r26, r6
    a5a2:	14 96       	adiw	r26, 0x04	; 4
    a5a4:	ed 91       	ld	r30, X+
    a5a6:	fc 91       	ld	r31, X
    a5a8:	15 97       	sbiw	r26, 0x05	; 5
    a5aa:	e2 0d       	add	r30, r2
    a5ac:	f3 1d       	adc	r31, r3
    a5ae:	44 85       	ldd	r20, Z+12	; 0x0c
    a5b0:	55 85       	ldd	r21, Z+13	; 0x0d
    a5b2:	66 85       	ldd	r22, Z+14	; 0x0e
    a5b4:	77 85       	ldd	r23, Z+15	; 0x0f
    a5b6:	00 89       	ldd	r16, Z+16	; 0x10
    a5b8:	11 89       	ldd	r17, Z+17	; 0x11
    a5ba:	22 89       	ldd	r18, Z+18	; 0x12
    a5bc:	33 89       	ldd	r19, Z+19	; 0x13
    a5be:	c4 88       	ldd	r12, Z+20	; 0x14
    a5c0:	d5 88       	ldd	r13, Z+21	; 0x15
    a5c2:	e6 88       	ldd	r14, Z+22	; 0x16
    a5c4:	f7 88       	ldd	r15, Z+23	; 0x17
    a5c6:	81 e0       	ldi	r24, 0x01	; 1
    a5c8:	90 e0       	ldi	r25, 0x00	; 0
    a5ca:	ef ee       	ldi	r30, 0xEF	; 239
    a5cc:	ae 2e       	mov	r10, r30
    a5ce:	ef ef       	ldi	r30, 0xFF	; 255
    a5d0:	be 2e       	mov	r11, r30
    a5d2:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
						axis=AxisPitch;
					break;
					case (AxisElbow):
							//Si el hombro se ha movido tengo que tomarlo en cuenta para calcular la 
							//posicion del codo
							mov_correlacionado(TrajectoryPOINT,pointIndex,AxisShoulder,AxisElbow,CORRELACION_HOMBRO_CODO);				
    a5d6:	c3 01       	movw	r24, r6
    a5d8:	b2 01       	movw	r22, r4
    a5da:	41 e0       	ldi	r20, 0x01	; 1
    a5dc:	50 e0       	ldi	r21, 0x00	; 0
    a5de:	22 e0       	ldi	r18, 0x02	; 2
    a5e0:	30 e0       	ldi	r19, 0x00	; 0
    a5e2:	0f 2e       	mov	r0, r31
    a5e4:	fd e1       	ldi	r31, 0x1D	; 29
    a5e6:	ef 2e       	mov	r14, r31
    a5e8:	fa e5       	ldi	r31, 0x5A	; 90
    a5ea:	ff 2e       	mov	r15, r31
    a5ec:	f4 e5       	ldi	r31, 0x54	; 84
    a5ee:	0f 2f       	mov	r16, r31
    a5f0:	ff e3       	ldi	r31, 0x3F	; 63
    a5f2:	1f 2f       	mov	r17, r31
    a5f4:	f0 2d       	mov	r31, r0
    a5f6:	0e 94 18 50 	call	0xa030	; 0xa030 <mov_correlacionado>
							mov_correlacionado(TrajectoryPOINT,pointIndex,AxisElbow,AxisPitch,CORRELACION_CODO_PITCH);
    a5fa:	c3 01       	movw	r24, r6
    a5fc:	b2 01       	movw	r22, r4
    a5fe:	42 e0       	ldi	r20, 0x02	; 2
    a600:	50 e0       	ldi	r21, 0x00	; 0
    a602:	23 e0       	ldi	r18, 0x03	; 3
    a604:	30 e0       	ldi	r19, 0x00	; 0
    a606:	0f 2e       	mov	r0, r31
    a608:	f9 ec       	ldi	r31, 0xC9	; 201
    a60a:	ef 2e       	mov	r14, r31
    a60c:	fe e8       	ldi	r31, 0x8E	; 142
    a60e:	ff 2e       	mov	r15, r31
    a610:	fd e8       	ldi	r31, 0x8D	; 141
    a612:	0f 2f       	mov	r16, r31
    a614:	fc e3       	ldi	r31, 0x3C	; 60
    a616:	1f 2f       	mov	r17, r31
    a618:	f0 2d       	mov	r31, r0
    a61a:	0e 94 18 50 	call	0xa030	; 0xa030 <mov_correlacionado>
    a61e:	33 e0       	ldi	r19, 0x03	; 3
    a620:	83 2e       	mov	r8, r19
    a622:	91 2c       	mov	r9, r1
    a624:	70 c0       	rjmp	.+224    	; 0xa706 <teach_pendant_point+0x408>
					case (AxisPitch):
						#ifdef DEBUGROBOTICS				
							printf("teach_pendant_point=> cargando valores de Pitch\n");
							//scanf("%d",&temp);
						#endif
						mov_correlacionado(TrajectoryPOINT,pointIndex,AxisShoulder,AxisElbow,CORRELACION_HOMBRO_CODO);
    a626:	c3 01       	movw	r24, r6
    a628:	b2 01       	movw	r22, r4
    a62a:	41 e0       	ldi	r20, 0x01	; 1
    a62c:	50 e0       	ldi	r21, 0x00	; 0
    a62e:	22 e0       	ldi	r18, 0x02	; 2
    a630:	30 e0       	ldi	r19, 0x00	; 0
    a632:	0f 2e       	mov	r0, r31
    a634:	fd e1       	ldi	r31, 0x1D	; 29
    a636:	ef 2e       	mov	r14, r31
    a638:	fa e5       	ldi	r31, 0x5A	; 90
    a63a:	ff 2e       	mov	r15, r31
    a63c:	f4 e5       	ldi	r31, 0x54	; 84
    a63e:	0f 2f       	mov	r16, r31
    a640:	ff e3       	ldi	r31, 0x3F	; 63
    a642:	1f 2f       	mov	r17, r31
    a644:	f0 2d       	mov	r31, r0
    a646:	0e 94 18 50 	call	0xa030	; 0xa030 <mov_correlacionado>
						mov_correlacionado(TrajectoryPOINT,pointIndex,AxisElbow,AxisPitch,CORRELACION_CODO_PITCH);					
    a64a:	c3 01       	movw	r24, r6
    a64c:	b2 01       	movw	r22, r4
    a64e:	42 e0       	ldi	r20, 0x02	; 2
    a650:	50 e0       	ldi	r21, 0x00	; 0
    a652:	23 e0       	ldi	r18, 0x03	; 3
    a654:	30 e0       	ldi	r19, 0x00	; 0
    a656:	0f 2e       	mov	r0, r31
    a658:	f9 ec       	ldi	r31, 0xC9	; 201
    a65a:	ef 2e       	mov	r14, r31
    a65c:	fe e8       	ldi	r31, 0x8E	; 142
    a65e:	ff 2e       	mov	r15, r31
    a660:	fd e8       	ldi	r31, 0x8D	; 141
    a662:	0f 2f       	mov	r16, r31
    a664:	fc e3       	ldi	r31, 0x3C	; 60
    a666:	1f 2f       	mov	r17, r31
    a668:	f0 2d       	mov	r31, r0
    a66a:	0e 94 18 50 	call	0xa030	; 0xa030 <mov_correlacionado>
    a66e:	4b c0       	rjmp	.+150    	; 0xa706 <teach_pendant_point+0x408>
					case (AxisRoll):
						#ifdef DEBUGROBOTICS				
							printf("teach_pendant_point=> cargando valores de Roll\n");
						//	scanf("%d",&temp);
						#endif
						position     = TrajectoryPOINT->point[pointIndex].axis[axis].position;
    a670:	d3 01       	movw	r26, r6
    a672:	14 96       	adiw	r26, 0x04	; 4
    a674:	ed 91       	ld	r30, X+
    a676:	fc 91       	ld	r31, X
    a678:	15 97       	sbiw	r26, 0x05	; 5
    a67a:	e2 0d       	add	r30, r2
    a67c:	f3 1d       	adc	r31, r3
    a67e:	80 a9       	ldd	r24, Z+48	; 0x30
    a680:	91 a9       	ldd	r25, Z+49	; 0x31
    a682:	a2 a9       	ldd	r26, Z+50	; 0x32
    a684:	b3 a9       	ldd	r27, Z+51	; 0x33
    a686:	8f a3       	std	Y+39, r24	; 0x27
    a688:	98 a7       	std	Y+40, r25	; 0x28
    a68a:	a9 a7       	std	Y+41, r26	; 0x29
    a68c:	ba a7       	std	Y+42, r27	; 0x2a
						velocity     = TrajectoryPOINT->point[pointIndex].axis[axis].velocity;
    a68e:	84 a9       	ldd	r24, Z+52	; 0x34
    a690:	95 a9       	ldd	r25, Z+53	; 0x35
    a692:	a6 a9       	ldd	r26, Z+54	; 0x36
    a694:	b7 a9       	ldd	r27, Z+55	; 0x37
    a696:	8b a3       	std	Y+35, r24	; 0x23
    a698:	9c a3       	std	Y+36, r25	; 0x24
    a69a:	ad a3       	std	Y+37, r26	; 0x25
    a69c:	be a3       	std	Y+38, r27	; 0x26
						acceleration = TrajectoryPOINT->point[pointIndex].axis[axis].acceleration;
    a69e:	80 ad       	ldd	r24, Z+56	; 0x38
    a6a0:	91 ad       	ldd	r25, Z+57	; 0x39
    a6a2:	a2 ad       	ldd	r26, Z+58	; 0x3a
    a6a4:	b3 ad       	ldd	r27, Z+59	; 0x3b
    a6a6:	8f 8f       	std	Y+31, r24	; 0x1f
    a6a8:	98 a3       	std	Y+32, r25	; 0x20
    a6aa:	a9 a3       	std	Y+33, r26	; 0x21
    a6ac:	ba a3       	std	Y+34, r27	; 0x22
    a6ae:	2b c0       	rjmp	.+86     	; 0xa706 <teach_pendant_point+0x408>
						
					break;								
					default:
						//Aplican para cintura
						mov_axis(axis,TrajectoryPOINT->point[pointIndex].axis[axis].position, 
    a6b0:	f3 01       	movw	r30, r6
    a6b2:	a4 81       	ldd	r26, Z+4	; 0x04
    a6b4:	b5 81       	ldd	r27, Z+5	; 0x05
    a6b6:	a2 0d       	add	r26, r2
    a6b8:	b3 1d       	adc	r27, r3
    a6ba:	c4 01       	movw	r24, r8
    a6bc:	88 0f       	add	r24, r24
    a6be:	99 1f       	adc	r25, r25
    a6c0:	88 0d       	add	r24, r8
    a6c2:	99 1d       	adc	r25, r9
    a6c4:	fc 01       	movw	r30, r24
    a6c6:	ee 0f       	add	r30, r30
    a6c8:	ff 1f       	adc	r31, r31
    a6ca:	ee 0f       	add	r30, r30
    a6cc:	ff 1f       	adc	r31, r31
    a6ce:	ea 0f       	add	r30, r26
    a6d0:	fb 1f       	adc	r31, r27
    a6d2:	40 81       	ld	r20, Z
    a6d4:	51 81       	ldd	r21, Z+1	; 0x01
    a6d6:	62 81       	ldd	r22, Z+2	; 0x02
    a6d8:	73 81       	ldd	r23, Z+3	; 0x03
    a6da:	01 96       	adiw	r24, 0x01	; 1
    a6dc:	88 0f       	add	r24, r24
    a6de:	99 1f       	adc	r25, r25
    a6e0:	88 0f       	add	r24, r24
    a6e2:	99 1f       	adc	r25, r25
    a6e4:	a8 0f       	add	r26, r24
    a6e6:	b9 1f       	adc	r27, r25
    a6e8:	0d 91       	ld	r16, X+
    a6ea:	1d 91       	ld	r17, X+
    a6ec:	2d 91       	ld	r18, X+
    a6ee:	3c 91       	ld	r19, X
    a6f0:	c0 84       	ldd	r12, Z+8	; 0x08
    a6f2:	d1 84       	ldd	r13, Z+9	; 0x09
    a6f4:	e2 84       	ldd	r14, Z+10	; 0x0a
    a6f6:	f3 84       	ldd	r15, Z+11	; 0x0b
    a6f8:	c4 01       	movw	r24, r8
    a6fa:	ef ee       	ldi	r30, 0xEF	; 239
    a6fc:	ae 2e       	mov	r10, r30
    a6fe:	ef ef       	ldi	r30, 0xFF	; 255
    a700:	be 2e       	mov	r11, r30
    a702:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
	acceleration_elbow_usr=TrajectoryPOINT->point[pointIndex].axis[AxisElbow].acceleration;
	velocity_pich_usr=TrajectoryPOINT->point[pointIndex].axis[AxisPitch].velocity;
	acceleration_pich_usr=TrajectoryPOINT->point[pointIndex].axis[AxisPitch].acceleration;
	//Busco el primer eje seleccionado y configuro el resto, es decir que si encuentro que hombro es el primero, 
	//configuro hombro, codo, pitch y salgo imediatamente del for para no reconfigurar con datos erroneos los demas ejes
	for(axis=0; axis < DOF; axis++) 
    a706:	08 94       	sec
    a708:	81 1c       	adc	r8, r1
    a70a:	91 1c       	adc	r9, r1
    a70c:	f5 e0       	ldi	r31, 0x05	; 5
    a70e:	8f 16       	cp	r8, r31
    a710:	91 04       	cpc	r9, r1
    a712:	0c f4       	brge	.+2      	; 0xa716 <teach_pendant_point+0x418>
    a714:	12 cf       	rjmp	.-476    	; 0xa53a <teach_pendant_point+0x23c>
	
	
	/*Se realiza el movimiento simultaneo de las articulaciones*/
	for(axis=0; axis < DOF; axis++) 
	{ 
		if(hAxis[axis].axis == 0) 
    a716:	af 85       	ldd	r26, Y+15	; 0x0f
    a718:	b8 89       	ldd	r27, Y+16	; 0x10
    a71a:	12 96       	adiw	r26, 0x02	; 2
    a71c:	8d 91       	ld	r24, X+
    a71e:	9c 91       	ld	r25, X
    a720:	13 97       	sbiw	r26, 0x03	; 3
    a722:	89 2b       	or	r24, r25
    a724:	29 f4       	brne	.+10     	; 0xa730 <teach_pendant_point+0x432>
		{
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    // move the robot (all axis in parallel)
    a726:	cd 01       	movw	r24, r26
    a728:	6f e0       	ldi	r22, 0x0F	; 15
    a72a:	70 e0       	ldi	r23, 0x00	; 0
    a72c:	0e 94 b3 63 	call	0xc766	; 0xc766 <PMDMultiUpdate>
    a730:	ef 85       	ldd	r30, Y+15	; 0x0f
    a732:	f8 89       	ldd	r31, Y+16	; 0x10
    a734:	e0 5a       	subi	r30, 0xA0	; 160
    a736:	ff 4f       	sbci	r31, 0xFF	; 255
    a738:	f8 8b       	std	Y+16, r31	; 0x10
    a73a:	ef 87       	std	Y+15, r30	; 0x0f
		}
	}
	
	
	/*Se realiza el movimiento simultaneo de las articulaciones*/
	for(axis=0; axis < DOF; axis++) 
    a73c:	e4 55       	subi	r30, 0x54	; 84
    a73e:	ff 47       	sbci	r31, 0x7F	; 127
    a740:	51 f7       	brne	.-44     	; 0xa716 <teach_pendant_point+0x418>
    a742:	20 e0       	ldi	r18, 0x00	; 0
    a744:	30 e0       	ldi	r19, 0x00	; 0
    a746:	48 ec       	ldi	r20, 0xC8	; 200
    a748:	50 e0       	ldi	r21, 0x00	; 0
    a74a:	0a c0       	rjmp	.+20     	; 0xa760 <teach_pendant_point+0x462>
    a74c:	fa 01       	movw	r30, r20
    a74e:	31 97       	sbiw	r30, 0x01	; 1
    a750:	f1 f7       	brne	.-4      	; 0xa74e <teach_pendant_point+0x450>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    a752:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    a754:	d9 f7       	brne	.-10     	; 0xa74c <teach_pendant_point+0x44e>
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    // move the robot (all axis in parallel)
		} 
	}
	
	/*Espero un segundo a que los ejes comiencen a moverse*/
	for(test8=0; test8 < 10; test8++) 
    a756:	2f 5f       	subi	r18, 0xFF	; 255
    a758:	3f 4f       	sbci	r19, 0xFF	; 255
    a75a:	2a 30       	cpi	r18, 0x0A	; 10
    a75c:	31 05       	cpc	r19, r1
    a75e:	19 f0       	breq	.+6      	; 0xa766 <teach_pendant_point+0x468>
    a760:	88 ee       	ldi	r24, 0xE8	; 232
    a762:	93 e0       	ldi	r25, 0x03	; 3
    a764:	f3 cf       	rjmp	.-26     	; 0xa74c <teach_pendant_point+0x44e>
    a766:	00 e0       	ldi	r16, 0x00	; 0
    a768:	10 e0       	ldi	r17, 0x00	; 0
    a76a:	ee 24       	eor	r14, r14
    a76c:	ff 24       	eor	r15, r15
	}
	
	do
	{
		//Hallo el El registro de actividad en el hombro
		PMDGetActivityStatus(&hAxis[AxisShoulder],&status);
    a76e:	4e 01       	movw	r8, r28
    a770:	08 94       	sec
    a772:	81 1c       	adc	r8, r1
    a774:	91 1c       	adc	r9, r1
    a776:	84 ed       	ldi	r24, 0xD4	; 212
    a778:	9d e7       	ldi	r25, 0x7D	; 125
    a77a:	b4 01       	movw	r22, r8
    a77c:	0e 94 a1 61 	call	0xc342	; 0xc342 <PMDGetActivityStatus>
		//Si hombro se mueve
		if ((status & PMDActivityInMotionMask) !=0)  
    a780:	89 81       	ldd	r24, Y+1	; 0x01
    a782:	9a 81       	ldd	r25, Y+2	; 0x02
    a784:	92 fd       	sbrc	r25, 2
    a786:	6d c0       	rjmp	.+218    	; 0xa862 <teach_pendant_point+0x564>
		{
			//tengo que mover el codo con la misma velocidad para no chocar	
		}
		else
		{	//Ya me puedo mover a la velocidad escogida por el usuario.
			if(reconf_Elbow==0)
    a788:	01 2b       	or	r16, r17
    a78a:	a1 f4       	brne	.+40     	; 0xa7b4 <teach_pendant_point+0x4b6>
				printf("teach_pendant_point=> Reconfigurando Codo\n");
				printf("teach_pendant_point=> Velocidad codo usuario = %ld\n",velocity_elbow_usr);	
				printf("teach_pendant_point=> Aceleracion codo usuario = %ld\n",acceleration_elbow_usr);	
				#endif
				reconf_Elbow=1;
				PMDSetVelocity(&hAxis[AxisElbow],velocity_elbow_usr); 
    a78c:	84 e3       	ldi	r24, 0x34	; 52
    a78e:	9e e7       	ldi	r25, 0x7E	; 126
    a790:	4b 8d       	ldd	r20, Y+27	; 0x1b
    a792:	5c 8d       	ldd	r21, Y+28	; 0x1c
    a794:	6d 8d       	ldd	r22, Y+29	; 0x1d
    a796:	7e 8d       	ldd	r23, Y+30	; 0x1e
    a798:	0e 94 ec 67 	call	0xcfd8	; 0xcfd8 <PMDSetVelocity>
				PMDSetAcceleration(&hAxis[AxisElbow],acceleration_elbow_usr); 
    a79c:	84 e3       	ldi	r24, 0x34	; 52
    a79e:	9e e7       	ldi	r25, 0x7E	; 126
    a7a0:	4b 89       	ldd	r20, Y+19	; 0x13
    a7a2:	5c 89       	ldd	r21, Y+20	; 0x14
    a7a4:	6d 89       	ldd	r22, Y+21	; 0x15
    a7a6:	7e 89       	ldd	r23, Y+22	; 0x16
    a7a8:	0e 94 de 67 	call	0xcfbc	; 0xcfbc <PMDSetAcceleration>
				PMDUpdate(&hAxis[AxisElbow]);
    a7ac:	84 e3       	ldi	r24, 0x34	; 52
    a7ae:	9e e7       	ldi	r25, 0x7E	; 126
    a7b0:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
			}
			//Hallo el El registro de actividad en el codo
			PMDGetActivityStatus(&hAxis[AxisElbow],&status);
    a7b4:	84 e3       	ldi	r24, 0x34	; 52
    a7b6:	9e e7       	ldi	r25, 0x7E	; 126
    a7b8:	b4 01       	movw	r22, r8
    a7ba:	0e 94 a1 61 	call	0xc342	; 0xc342 <PMDGetActivityStatus>
			//Si codo se mueve
			if ((status & PMDActivityInMotionMask) !=0)
    a7be:	89 81       	ldd	r24, Y+1	; 0x01
    a7c0:	9a 81       	ldd	r25, Y+2	; 0x02
    a7c2:	92 fd       	sbrc	r25, 2
    a7c4:	4c c0       	rjmp	.+152    	; 0xa85e <teach_pendant_point+0x560>
				//tengo que mover el pitch con la misma velocidad para no chocar	
			}
			else
			{
				//Ya me puedo mover a la velocidad escogida por el usuario.
				if(reconf_Pitch==0)
    a7c6:	e1 14       	cp	r14, r1
    a7c8:	f1 04       	cpc	r15, r1
    a7ca:	09 f0       	breq	.+2      	; 0xa7ce <teach_pendant_point+0x4d0>
    a7cc:	48 c0       	rjmp	.+144    	; 0xa85e <teach_pendant_point+0x560>
				{
					reconf_Pitch=1;
					if(velocity_pich_usr>0)
    a7ce:	8f 89       	ldd	r24, Y+23	; 0x17
    a7d0:	98 8d       	ldd	r25, Y+24	; 0x18
    a7d2:	a9 8d       	ldd	r26, Y+25	; 0x19
    a7d4:	ba 8d       	ldd	r27, Y+26	; 0x1a
    a7d6:	18 16       	cp	r1, r24
    a7d8:	19 06       	cpc	r1, r25
    a7da:	1a 06       	cpc	r1, r26
    a7dc:	1b 06       	cpc	r1, r27
    a7de:	cc f5       	brge	.+114    	; 0xa852 <teach_pendant_point+0x554>
						printf("teach_pendant_point=> Velocidad Pitch usuario = %ld\n",velocity_pich_usr);	
						printf("teach_pendant_point=> Aceleracion Pitch usuario = %ld\n",acceleration_pich_usr);	
						printf("teach_pendant_point=> Posicion final de  Pitch= %ld\n",TrajectoryPOINT->point[pointIndex].axis[AxisPitch].position);	
						#endif
						//No puede usar la funcion pitch porque se reinicia los encoderes..
						mov_axis(AxisPitch, TrajectoryPOINT->point[pointIndex].axis[AxisPitch].position, 
    a7e0:	d3 01       	movw	r26, r6
    a7e2:	14 96       	adiw	r26, 0x04	; 4
    a7e4:	ed 91       	ld	r30, X+
    a7e6:	fc 91       	ld	r31, X
    a7e8:	15 97       	sbiw	r26, 0x05	; 5
    a7ea:	e2 0d       	add	r30, r2
    a7ec:	f3 1d       	adc	r31, r3
    a7ee:	44 a1       	ldd	r20, Z+36	; 0x24
    a7f0:	55 a1       	ldd	r21, Z+37	; 0x25
    a7f2:	66 a1       	ldd	r22, Z+38	; 0x26
    a7f4:	77 a1       	ldd	r23, Z+39	; 0x27
    a7f6:	83 e0       	ldi	r24, 0x03	; 3
    a7f8:	90 e0       	ldi	r25, 0x00	; 0
    a7fa:	0f 89       	ldd	r16, Y+23	; 0x17
    a7fc:	18 8d       	ldd	r17, Y+24	; 0x18
    a7fe:	29 8d       	ldd	r18, Y+25	; 0x19
    a800:	3a 8d       	ldd	r19, Y+26	; 0x1a
    a802:	cb a4       	ldd	r12, Y+43	; 0x2b
    a804:	dc a4       	ldd	r13, Y+44	; 0x2c
    a806:	ed a4       	ldd	r14, Y+45	; 0x2d
    a808:	fe a4       	ldd	r15, Y+46	; 0x2e
    a80a:	b0 ef       	ldi	r27, 0xF0	; 240
    a80c:	ab 2e       	mov	r10, r27
    a80e:	bf ef       	ldi	r27, 0xFF	; 255
    a810:	bb 2e       	mov	r11, r27
    a812:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
						velocity_pich_usr, acceleration_pich_usr, update);
						mov_axis(AxisRoll, -TrajectoryPOINT->point[pointIndex].axis[AxisPitch].position,
    a816:	d3 01       	movw	r26, r6
    a818:	14 96       	adiw	r26, 0x04	; 4
    a81a:	ed 91       	ld	r30, X+
    a81c:	fc 91       	ld	r31, X
    a81e:	15 97       	sbiw	r26, 0x05	; 5
    a820:	e2 0d       	add	r30, r2
    a822:	f3 1d       	adc	r31, r3
    a824:	44 a1       	ldd	r20, Z+36	; 0x24
    a826:	55 a1       	ldd	r21, Z+37	; 0x25
    a828:	66 a1       	ldd	r22, Z+38	; 0x26
    a82a:	77 a1       	ldd	r23, Z+39	; 0x27
    a82c:	70 95       	com	r23
    a82e:	60 95       	com	r22
    a830:	50 95       	com	r21
    a832:	41 95       	neg	r20
    a834:	5f 4f       	sbci	r21, 0xFF	; 255
    a836:	6f 4f       	sbci	r22, 0xFF	; 255
    a838:	7f 4f       	sbci	r23, 0xFF	; 255
    a83a:	84 e0       	ldi	r24, 0x04	; 4
    a83c:	90 e0       	ldi	r25, 0x00	; 0
    a83e:	0f 89       	ldd	r16, Y+23	; 0x17
    a840:	18 8d       	ldd	r17, Y+24	; 0x18
    a842:	29 8d       	ldd	r18, Y+25	; 0x19
    a844:	3a 8d       	ldd	r19, Y+26	; 0x1a
    a846:	cb a4       	ldd	r12, Y+43	; 0x2b
    a848:	dc a4       	ldd	r13, Y+44	; 0x2c
    a84a:	ed a4       	ldd	r14, Y+45	; 0x2d
    a84c:	fe a4       	ldd	r15, Y+46	; 0x2e
    a84e:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
    a852:	01 e0       	ldi	r16, 0x01	; 1
    a854:	10 e0       	ldi	r17, 0x00	; 0
    a856:	a1 e0       	ldi	r26, 0x01	; 1
    a858:	ea 2e       	mov	r14, r26
    a85a:	f1 2c       	mov	r15, r1
    a85c:	02 c0       	rjmp	.+4      	; 0xa862 <teach_pendant_point+0x564>
    a85e:	01 e0       	ldi	r16, 0x01	; 1
    a860:	10 e0       	ldi	r17, 0x00	; 0
				}
			}
		}
		
	}	
	while( PMDcheckIdle(mask & ~Axis2AxisMask(AxisRoll))==FALSE);
    a862:	84 e0       	ldi	r24, 0x04	; 4
    a864:	90 e0       	ldi	r25, 0x00	; 0
    a866:	0e 94 60 18 	call	0x30c0	; 0x30c0 <Axis2AxisMask>
    a86a:	80 95       	com	r24
    a86c:	90 95       	com	r25
    a86e:	e9 89       	ldd	r30, Y+17	; 0x11
    a870:	fa 89       	ldd	r31, Y+18	; 0x12
    a872:	8e 23       	and	r24, r30
    a874:	9f 23       	and	r25, r31
    a876:	0e 94 41 37 	call	0x6e82	; 0x6e82 <PMDcheckIdle>
    a87a:	89 2b       	or	r24, r25
    a87c:	09 f4       	brne	.+2      	; 0xa880 <teach_pendant_point+0x582>
    a87e:	7b cf       	rjmp	.-266    	; 0xa776 <teach_pendant_point+0x478>

	
	//Una vez el robot este totalmente detenido se empieza a efectur el movimiento de Roll 
	//(si existe) para eso se debe habiliar los ejes de pitch and Roll limpiando  el bit
	//de Motion Complete ( Bit 0 del Event Status Register).	
	if((hAxis[AxisRoll].axisSettings.axisEnabled == TRUE) && 
    a880:	80 91 f8 7e 	lds	r24, 0x7EF8
    a884:	81 30       	cpi	r24, 0x01	; 1
    a886:	39 f5       	brne	.+78     	; 0xa8d6 <teach_pendant_point+0x5d8>
    a888:	84 e0       	ldi	r24, 0x04	; 4
    a88a:	90 e0       	ldi	r25, 0x00	; 0
    a88c:	0e 94 60 18 	call	0x30c0	; 0x30c0 <Axis2AxisMask>
    a890:	29 89       	ldd	r18, Y+17	; 0x11
    a892:	3a 89       	ldd	r19, Y+18	; 0x12
    a894:	82 23       	and	r24, r18
    a896:	93 23       	and	r25, r19
    a898:	18 16       	cp	r1, r24
    a89a:	19 06       	cpc	r1, r25
    a89c:	e4 f4       	brge	.+56     	; 0xa8d6 <teach_pendant_point+0x5d8>
		((mask & (Axis2AxisMask(AxisRoll))) >0  )) 
	{ 
		Enable_Mov();
    a89e:	0e 94 0a 37 	call	0x6e14	; 0x6e14 <Enable_Mov>
		roll(position,velocity,acceleration,update,MOVIMIENTO_NORMAL );			//Efectuo movimiento de Roll.
    a8a2:	6f a1       	ldd	r22, Y+39	; 0x27
    a8a4:	78 a5       	ldd	r23, Y+40	; 0x28
    a8a6:	89 a5       	ldd	r24, Y+41	; 0x29
    a8a8:	9a a5       	ldd	r25, Y+42	; 0x2a
    a8aa:	2b a1       	ldd	r18, Y+35	; 0x23
    a8ac:	3c a1       	ldd	r19, Y+36	; 0x24
    a8ae:	4d a1       	ldd	r20, Y+37	; 0x25
    a8b0:	5e a1       	ldd	r21, Y+38	; 0x26
    a8b2:	ef 8c       	ldd	r14, Y+31	; 0x1f
    a8b4:	f8 a0       	ldd	r15, Y+32	; 0x20
    a8b6:	09 a1       	ldd	r16, Y+33	; 0x21
    a8b8:	1a a1       	ldd	r17, Y+34	; 0x22
    a8ba:	f0 ef       	ldi	r31, 0xF0	; 240
    a8bc:	cf 2e       	mov	r12, r31
    a8be:	ff ef       	ldi	r31, 0xFF	; 255
    a8c0:	df 2e       	mov	r13, r31
    a8c2:	e1 e0       	ldi	r30, 0x01	; 1
    a8c4:	ae 2e       	mov	r10, r30
    a8c6:	b1 2c       	mov	r11, r1
    a8c8:	0e 94 8a 39 	call	0x7314	; 0x7314 <roll>
    a8cc:	04 c0       	rjmp	.+8      	; 0xa8d6 <teach_pendant_point+0x5d8>
	}

	while( PMDcheckIdle(mask & Axis2AxisMask(AxisRoll))==FALSE)	
	{	

		printf("teach_pendant_point=> Efectuando Movimiento de Roll.\n");
    a8ce:	8b ee       	ldi	r24, 0xEB	; 235
    a8d0:	90 e6       	ldi	r25, 0x60	; 96
    a8d2:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	{ 
		Enable_Mov();
		roll(position,velocity,acceleration,update,MOVIMIENTO_NORMAL );			//Efectuo movimiento de Roll.
	}

	while( PMDcheckIdle(mask & Axis2AxisMask(AxisRoll))==FALSE)	
    a8d6:	84 e0       	ldi	r24, 0x04	; 4
    a8d8:	90 e0       	ldi	r25, 0x00	; 0
    a8da:	0e 94 60 18 	call	0x30c0	; 0x30c0 <Axis2AxisMask>
    a8de:	a9 89       	ldd	r26, Y+17	; 0x11
    a8e0:	ba 89       	ldd	r27, Y+18	; 0x12
    a8e2:	8a 23       	and	r24, r26
    a8e4:	9b 23       	and	r25, r27
    a8e6:	0e 94 41 37 	call	0x6e82	; 0x6e82 <PMDcheckIdle>
    a8ea:	89 2b       	or	r24, r25
    a8ec:	81 f3       	breq	.-32     	; 0xa8ce <teach_pendant_point+0x5d0>
	}

	//Habilitar todos los ejes para el proximo movimiento limpiando la el bit
	//de Motion Complete ( Bit 0 del Event Status Register).*/

	Enable_Mov();
    a8ee:	0e 94 0a 37 	call	0x6e14	; 0x6e14 <Enable_Mov>
	
	printf("teach_pendant_point=> Fin del Movimiento \n");
    a8f2:	80 e2       	ldi	r24, 0x20	; 32
    a8f4:	91 e6       	ldi	r25, 0x61	; 97
    a8f6:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	
	
}
    a8fa:	ae 96       	adiw	r28, 0x2e	; 46
    a8fc:	0f b6       	in	r0, 0x3f	; 63
    a8fe:	f8 94       	cli
    a900:	de bf       	out	0x3e, r29	; 62
    a902:	0f be       	out	0x3f, r0	; 63
    a904:	cd bf       	out	0x3d, r28	; 61
    a906:	cf 91       	pop	r28
    a908:	df 91       	pop	r29
    a90a:	1f 91       	pop	r17
    a90c:	0f 91       	pop	r16
    a90e:	ff 90       	pop	r15
    a910:	ef 90       	pop	r14
    a912:	df 90       	pop	r13
    a914:	cf 90       	pop	r12
    a916:	bf 90       	pop	r11
    a918:	af 90       	pop	r10
    a91a:	9f 90       	pop	r9
    a91c:	8f 90       	pop	r8
    a91e:	7f 90       	pop	r7
    a920:	6f 90       	pop	r6
    a922:	5f 90       	pop	r5
    a924:	4f 90       	pop	r4
    a926:	3f 90       	pop	r3
    a928:	2f 90       	pop	r2
    a92a:	08 95       	ret

0000a92c <PMDprocessTrajectory>:
	
}

//**********************************************************************************************
void PMDprocessTrajectory(tTrajectory* Trajectory, int16 TraceOP)
{
    a92c:	af 92       	push	r10
    a92e:	bf 92       	push	r11
    a930:	cf 92       	push	r12
    a932:	df 92       	push	r13
    a934:	ef 92       	push	r14
    a936:	ff 92       	push	r15
    a938:	0f 93       	push	r16
    a93a:	1f 93       	push	r17
    a93c:	cf 93       	push	r28
    a93e:	df 93       	push	r29
    a940:	7c 01       	movw	r14, r24
    a942:	6b 01       	movw	r12, r22
    a944:	c0 e0       	ldi	r28, 0x00	; 0
    a946:	d0 e0       	ldi	r29, 0x00	; 0
    a948:	00 e0       	ldi	r16, 0x00	; 0
    a94a:	10 e0       	ldi	r17, 0x00	; 0
	printf("PMDprocessTrajectory=> El Numero de puntos de la trayectoria es en PMDfunctions.c => %d\n",Trajectory->size);
	printf("PMDprocessTrajectory=> invalid mask en PMDfunctions.c => %X\n",Trajectory->invalidmask);
	#endif
	do
	{  
		printf("PMDprocessTrajectory=> Procesado el  punto %d \n",pointIndex);
    a94c:	9a e4       	ldi	r25, 0x4A	; 74
    a94e:	a9 2e       	mov	r10, r25
    a950:	91 e6       	ldi	r25, 0x61	; 97
    a952:	b9 2e       	mov	r11, r25
    a954:	00 d0       	rcall	.+0      	; 0xa956 <PMDprocessTrajectory+0x2a>
    a956:	00 d0       	rcall	.+0      	; 0xa958 <PMDprocessTrajectory+0x2c>
    a958:	ad b7       	in	r26, 0x3d	; 61
    a95a:	be b7       	in	r27, 0x3e	; 62
    a95c:	12 96       	adiw	r26, 0x02	; 2
    a95e:	bc 92       	st	X, r11
    a960:	ae 92       	st	-X, r10
    a962:	11 97       	sbiw	r26, 0x01	; 1
    a964:	14 96       	adiw	r26, 0x04	; 4
    a966:	dc 93       	st	X, r29
    a968:	ce 93       	st	-X, r28
    a96a:	13 97       	sbiw	r26, 0x03	; 3
    a96c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				Trajectory->point[pointIndex].axis[AxisRoll].position);
		#endif
		//Cargo la posicion, velocidad, aceleracion con pointIndex tomando encuenta 
		//La interaccion de los ejes, espera a que termine el movimiento de cintura, 
		//hombro, codo y pich para finalmente  ejecutar roll
		teach_pendant_point(Trajectory,pointIndex);
    a970:	0f 90       	pop	r0
    a972:	0f 90       	pop	r0
    a974:	0f 90       	pop	r0
    a976:	0f 90       	pop	r0
    a978:	c7 01       	movw	r24, r14
    a97a:	be 01       	movw	r22, r28
    a97c:	0e 94 7f 51 	call	0xa2fe	; 0xa2fe <teach_pendant_point>
		/*Ejecuto movimiento del gripper*/
		if(Trajectory->point[pointIndex].Gripper_Status==1)
    a980:	d7 01       	movw	r26, r14
    a982:	14 96       	adiw	r26, 0x04	; 4
    a984:	ed 91       	ld	r30, X+
    a986:	fc 91       	ld	r31, X
    a988:	15 97       	sbiw	r26, 0x05	; 5
    a98a:	e0 0f       	add	r30, r16
    a98c:	f1 1f       	adc	r31, r17
    a98e:	84 ad       	ldd	r24, Z+60	; 0x3c
    a990:	81 30       	cpi	r24, 0x01	; 1
    a992:	11 f4       	brne	.+4      	; 0xa998 <PMDprocessTrajectory+0x6c>
		{
			closeGripper();
    a994:	0e 94 9a 76 	call	0xed34	; 0xed34 <closeGripper>
			#ifdef DEBUGROBOTICS
			printf("PMDprocessTrajectory=> Pose con gripper cerrado\n");	
			#endif
		}
		if(Trajectory->point[pointIndex].Gripper_Status==0)
    a998:	d7 01       	movw	r26, r14
    a99a:	14 96       	adiw	r26, 0x04	; 4
    a99c:	ed 91       	ld	r30, X+
    a99e:	fc 91       	ld	r31, X
    a9a0:	15 97       	sbiw	r26, 0x05	; 5
    a9a2:	e0 0f       	add	r30, r16
    a9a4:	f1 1f       	adc	r31, r17
    a9a6:	84 ad       	ldd	r24, Z+60	; 0x3c
    a9a8:	88 23       	and	r24, r24
    a9aa:	11 f4       	brne	.+4      	; 0xa9b0 <PMDprocessTrajectory+0x84>
		{
			openGripper();
    a9ac:	0e 94 69 76 	call	0xecd2	; 0xecd2 <openGripper>
			#ifdef DEBUGROBOTICS
			printf("PMDprocessTrajectory=> Pose con gripper abierto\n");	
			#endif
		}
		pointIndex++;				
    a9b0:	21 96       	adiw	r28, 0x01	; 1
    a9b2:	03 5c       	subi	r16, 0xC3	; 195
    a9b4:	1f 4f       	sbci	r17, 0xFF	; 255
	}
	while (pointIndex <  (Trajectory->size)); //pointIndex es la variable que marca el punto en ejecucion 
    a9b6:	f7 01       	movw	r30, r14
    a9b8:	80 81       	ld	r24, Z
    a9ba:	91 81       	ldd	r25, Z+1	; 0x01
    a9bc:	c8 17       	cp	r28, r24
    a9be:	d9 07       	cpc	r29, r25
    a9c0:	4c f2       	brlt	.-110    	; 0xa954 <PMDprocessTrajectory+0x28>
    printf("PMDprocessTrajectory=>  Saliendo de PMDprocessTrajectory\n");
    a9c2:	8a e7       	ldi	r24, 0x7A	; 122
    a9c4:	91 e6       	ldi	r25, 0x61	; 97
    a9c6:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	//He configurado trazar una trajectoria
	if(TraceOP==1)
    a9ca:	f1 e0       	ldi	r31, 0x01	; 1
    a9cc:	cf 16       	cp	r12, r31
    a9ce:	d1 04       	cpc	r13, r1
    a9d0:	49 f4       	brne	.+18     	; 0xa9e4 <PMDprocessTrajectory+0xb8>
	{
		//Parao el trazado para PMD1
		PMDSetTraceStop(&hAxis[AxisWaist],AxisWaist,PMDTraceConditionImmediate,0,0);
    a9d2:	84 e7       	ldi	r24, 0x74	; 116
    a9d4:	9d e7       	ldi	r25, 0x7D	; 125
    a9d6:	60 e0       	ldi	r22, 0x00	; 0
    a9d8:	70 e0       	ldi	r23, 0x00	; 0
    a9da:	40 e0       	ldi	r20, 0x00	; 0
    a9dc:	20 e0       	ldi	r18, 0x00	; 0
    a9de:	00 e0       	ldi	r16, 0x00	; 0
    a9e0:	0e 94 ab 62 	call	0xc556	; 0xc556 <PMDSetTraceStop>
		//PMDSetTraceStop(&hAxis[axis], axis,PMDTraceConditionImmediate,0,0);
	}

	
} 
    a9e4:	df 91       	pop	r29
    a9e6:	cf 91       	pop	r28
    a9e8:	1f 91       	pop	r17
    a9ea:	0f 91       	pop	r16
    a9ec:	ff 90       	pop	r15
    a9ee:	ef 90       	pop	r14
    a9f0:	df 90       	pop	r13
    a9f2:	cf 90       	pop	r12
    a9f4:	bf 90       	pop	r11
    a9f6:	af 90       	pop	r10
    a9f8:	08 95       	ret

0000a9fa <checkconnect>:
	
	return ErrorPMD;
}
/**********************************************************************************************************************/
int16 checkconnect(void)
{
    a9fa:	2f 92       	push	r2
    a9fc:	3f 92       	push	r3
    a9fe:	4f 92       	push	r4
    aa00:	5f 92       	push	r5
    aa02:	6f 92       	push	r6
    aa04:	7f 92       	push	r7
    aa06:	8f 92       	push	r8
    aa08:	9f 92       	push	r9
    aa0a:	af 92       	push	r10
    aa0c:	bf 92       	push	r11
    aa0e:	cf 92       	push	r12
    aa10:	df 92       	push	r13
    aa12:	ef 92       	push	r14
    aa14:	ff 92       	push	r15
    aa16:	0f 93       	push	r16
    aa18:	1f 93       	push	r17
    aa1a:	df 93       	push	r29
    aa1c:	cf 93       	push	r28
    aa1e:	00 d0       	rcall	.+0      	; 0xaa20 <checkconnect+0x26>
    aa20:	cd b7       	in	r28, 0x3d	; 61
    aa22:	de b7       	in	r29, 0x3e	; 62
	
	rc=rcOK;
	
	/** SE observa el Estado del Boton de Parada de Emergecia **/
	
	if(bit_is_set(PIND, Estado_Boton_Emergencia))
    aa24:	4a 9b       	sbis	0x09, 2	; 9
    aa26:	1c c0       	rjmp	.+56     	; 0xaa60 <checkconnect+0x66>
	{
		buzzer(1);
    aa28:	81 e0       	ldi	r24, 0x01	; 1
    aa2a:	90 e0       	ldi	r25, 0x00	; 0
    aa2c:	0e 94 eb 76 	call	0xedd6	; 0xedd6 <buzzer>
		
		printf("checkconnect=> Boton de Parada de Emergencia Activo \n");
    aa30:	83 eb       	ldi	r24, 0xB3	; 179
    aa32:	91 e6       	ldi	r25, 0x61	; 97
    aa34:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		fprintf_P(stderr,PSTR("Boton de Parada de Emergencia Activo \n"));
    aa38:	00 d0       	rcall	.+0      	; 0xaa3a <checkconnect+0x40>
    aa3a:	00 d0       	rcall	.+0      	; 0xaa3c <checkconnect+0x42>
    aa3c:	80 91 33 82 	lds	r24, 0x8233
    aa40:	90 91 34 82 	lds	r25, 0x8234
    aa44:	ed b7       	in	r30, 0x3d	; 61
    aa46:	fe b7       	in	r31, 0x3e	; 62
    aa48:	92 83       	std	Z+2, r25	; 0x02
    aa4a:	81 83       	std	Z+1, r24	; 0x01
    aa4c:	84 ea       	ldi	r24, 0xA4	; 164
    aa4e:	94 e0       	ldi	r25, 0x04	; 4
    aa50:	94 83       	std	Z+4, r25	; 0x04
    aa52:	83 83       	std	Z+3, r24	; 0x03
    aa54:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
    aa58:	0f 90       	pop	r0
    aa5a:	0f 90       	pop	r0
    aa5c:	0f 90       	pop	r0
    aa5e:	0f 90       	pop	r0
    aa60:	44 e7       	ldi	r20, 0x74	; 116
    aa62:	c4 2e       	mov	r12, r20
    aa64:	4d e7       	ldi	r20, 0x7D	; 125
    aa66:	d4 2e       	mov	r13, r20
    aa68:	ee 24       	eor	r14, r14
    aa6a:	ff 24       	eor	r15, r15
    aa6c:	00 e0       	ldi	r16, 0x00	; 0
    aa6e:	10 e0       	ldi	r17, 0x00	; 0
		
	}
	for(Axis=0; Axis < DOF; Axis++) 
	{
		
		PMDGetSignalStatus(&hAxis[Axis],&signal_status);	
    aa70:	1e 01       	movw	r2, r28
    aa72:	08 94       	sec
    aa74:	21 1c       	adc	r2, r1
    aa76:	31 1c       	adc	r3, r1
			{
				
				buzzer_ms(50);
				buzzer_ms(50);
				Chipset=Axis2PMDChipset(Axis)+1;
				printf("checkconnect=> Cable #%d de Sensores esta desconectado \n",Chipset);
    aa78:	38 ee       	ldi	r19, 0xE8	; 232
    aa7a:	43 2e       	mov	r4, r19
    aa7c:	31 e6       	ldi	r19, 0x61	; 97
    aa7e:	53 2e       	mov	r5, r19
				printf("checkconnect=> Los switch del eje de %s estan desconectados \n",AxisName(Axis));
    aa80:	21 e2       	ldi	r18, 0x21	; 33
    aa82:	62 2e       	mov	r6, r18
    aa84:	22 e6       	ldi	r18, 0x62	; 98
    aa86:	72 2e       	mov	r7, r18
				//impresion de caracteres Display
				if (Chipset==1)
					fprintf_P(stderr,PSTR("Cable #1 de sensores desconectado \n"));
				
				if (Chipset==2)
					fprintf_P(stderr,PSTR("Cable #2 de sensores desconectado \n"));
    aa88:	9c e5       	ldi	r25, 0x5C	; 92
    aa8a:	89 2e       	mov	r8, r25
    aa8c:	94 e0       	ldi	r25, 0x04	; 4
    aa8e:	99 2e       	mov	r9, r25
				printf("checkconnect=> Cable #%d de Sensores esta desconectado \n",Chipset);
				printf("checkconnect=> Los switch del eje de %s estan desconectados \n",AxisName(Axis));
				
				//impresion de caracteres Display
				if (Chipset==1)
					fprintf_P(stderr,PSTR("Cable #1 de sensores desconectado \n"));
    aa90:	80 e8       	ldi	r24, 0x80	; 128
    aa92:	a8 2e       	mov	r10, r24
    aa94:	84 e0       	ldi	r24, 0x04	; 4
    aa96:	b8 2e       	mov	r11, r24
		
	}
	for(Axis=0; Axis < DOF; Axis++) 
	{
		
		PMDGetSignalStatus(&hAxis[Axis],&signal_status);	
    aa98:	c6 01       	movw	r24, r12
    aa9a:	b1 01       	movw	r22, r2
    aa9c:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
		
		if ((signal_status & PMDSignalPositiveLimitMask) ==0) //Significa que esta activado el Limite Positivo
    aaa0:	89 81       	ldd	r24, Y+1	; 0x01
    aaa2:	84 fd       	sbrc	r24, 4
    aaa4:	5d c0       	rjmp	.+186    	; 0xab60 <checkconnect+0x166>
		{
			
			/*Verificar si los cables de Sensores estan conectados*/
			if((signal_status & PMDSignalNegativeLimitMask) ==0)
    aaa6:	85 fd       	sbrc	r24, 5
    aaa8:	5b c0       	rjmp	.+182    	; 0xab60 <checkconnect+0x166>
			{
				
				buzzer_ms(50);
    aaaa:	62 e3       	ldi	r22, 0x32	; 50
    aaac:	70 e0       	ldi	r23, 0x00	; 0
    aaae:	80 e0       	ldi	r24, 0x00	; 0
    aab0:	90 e0       	ldi	r25, 0x00	; 0
    aab2:	0e 94 00 77 	call	0xee00	; 0xee00 <buzzer_ms>
				buzzer_ms(50);
    aab6:	62 e3       	ldi	r22, 0x32	; 50
    aab8:	70 e0       	ldi	r23, 0x00	; 0
    aaba:	80 e0       	ldi	r24, 0x00	; 0
    aabc:	90 e0       	ldi	r25, 0x00	; 0
    aabe:	0e 94 00 77 	call	0xee00	; 0xee00 <buzzer_ms>
				Chipset=Axis2PMDChipset(Axis)+1;
    aac2:	c7 01       	movw	r24, r14
    aac4:	0e 94 fa 67 	call	0xcff4	; 0xcff4 <Axis2PMDChipset>
    aac8:	8c 01       	movw	r16, r24
    aaca:	0f 5f       	subi	r16, 0xFF	; 255
    aacc:	1f 4f       	sbci	r17, 0xFF	; 255
				printf("checkconnect=> Cable #%d de Sensores esta desconectado \n",Chipset);
    aace:	00 d0       	rcall	.+0      	; 0xaad0 <checkconnect+0xd6>
    aad0:	00 d0       	rcall	.+0      	; 0xaad2 <checkconnect+0xd8>
    aad2:	ed b7       	in	r30, 0x3d	; 61
    aad4:	fe b7       	in	r31, 0x3e	; 62
    aad6:	52 82       	std	Z+2, r5	; 0x02
    aad8:	41 82       	std	Z+1, r4	; 0x01
    aada:	14 83       	std	Z+4, r17	; 0x04
    aadc:	03 83       	std	Z+3, r16	; 0x03
    aade:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				printf("checkconnect=> Los switch del eje de %s estan desconectados \n",AxisName(Axis));
    aae2:	0f 90       	pop	r0
    aae4:	0f 90       	pop	r0
    aae6:	0f 90       	pop	r0
    aae8:	0f 90       	pop	r0
    aaea:	c7 01       	movw	r24, r14
    aaec:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    aaf0:	00 d0       	rcall	.+0      	; 0xaaf2 <checkconnect+0xf8>
    aaf2:	00 d0       	rcall	.+0      	; 0xaaf4 <checkconnect+0xfa>
    aaf4:	ed b7       	in	r30, 0x3d	; 61
    aaf6:	fe b7       	in	r31, 0x3e	; 62
    aaf8:	72 82       	std	Z+2, r7	; 0x02
    aafa:	61 82       	std	Z+1, r6	; 0x01
    aafc:	94 83       	std	Z+4, r25	; 0x04
    aafe:	83 83       	std	Z+3, r24	; 0x03
    ab00:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				
				//impresion de caracteres Display
				if (Chipset==1)
    ab04:	0f 90       	pop	r0
    ab06:	0f 90       	pop	r0
    ab08:	0f 90       	pop	r0
    ab0a:	0f 90       	pop	r0
    ab0c:	01 30       	cpi	r16, 0x01	; 1
    ab0e:	11 05       	cpc	r17, r1
    ab10:	69 f4       	brne	.+26     	; 0xab2c <checkconnect+0x132>
					fprintf_P(stderr,PSTR("Cable #1 de sensores desconectado \n"));
    ab12:	00 d0       	rcall	.+0      	; 0xab14 <checkconnect+0x11a>
    ab14:	00 d0       	rcall	.+0      	; 0xab16 <checkconnect+0x11c>
    ab16:	80 91 33 82 	lds	r24, 0x8233
    ab1a:	90 91 34 82 	lds	r25, 0x8234
    ab1e:	ed b7       	in	r30, 0x3d	; 61
    ab20:	fe b7       	in	r31, 0x3e	; 62
    ab22:	92 83       	std	Z+2, r25	; 0x02
    ab24:	81 83       	std	Z+1, r24	; 0x01
    ab26:	b4 82       	std	Z+4, r11	; 0x04
    ab28:	a3 82       	std	Z+3, r10	; 0x03
    ab2a:	12 c0       	rjmp	.+36     	; 0xab50 <checkconnect+0x156>
				
				if (Chipset==2)
    ab2c:	02 30       	cpi	r16, 0x02	; 2
    ab2e:	11 05       	cpc	r17, r1
    ab30:	19 f0       	breq	.+6      	; 0xab38 <checkconnect+0x13e>
    ab32:	0f ef       	ldi	r16, 0xFF	; 255
    ab34:	1f ef       	ldi	r17, 0xFF	; 255
    ab36:	14 c0       	rjmp	.+40     	; 0xab60 <checkconnect+0x166>
					fprintf_P(stderr,PSTR("Cable #2 de sensores desconectado \n"));
    ab38:	00 d0       	rcall	.+0      	; 0xab3a <checkconnect+0x140>
    ab3a:	00 d0       	rcall	.+0      	; 0xab3c <checkconnect+0x142>
    ab3c:	80 91 33 82 	lds	r24, 0x8233
    ab40:	90 91 34 82 	lds	r25, 0x8234
    ab44:	ed b7       	in	r30, 0x3d	; 61
    ab46:	fe b7       	in	r31, 0x3e	; 62
    ab48:	92 83       	std	Z+2, r25	; 0x02
    ab4a:	81 83       	std	Z+1, r24	; 0x01
    ab4c:	94 82       	std	Z+4, r9	; 0x04
    ab4e:	83 82       	std	Z+3, r8	; 0x03
    ab50:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
    ab54:	0f ef       	ldi	r16, 0xFF	; 255
    ab56:	1f ef       	ldi	r17, 0xFF	; 255
    ab58:	0f 90       	pop	r0
    ab5a:	0f 90       	pop	r0
    ab5c:	0f 90       	pop	r0
    ab5e:	0f 90       	pop	r0
		
		printf("checkconnect=> Boton de Parada de Emergencia Activo \n");
		fprintf_P(stderr,PSTR("Boton de Parada de Emergencia Activo \n"));
		
	}
	for(Axis=0; Axis < DOF; Axis++) 
    ab60:	08 94       	sec
    ab62:	e1 1c       	adc	r14, r1
    ab64:	f1 1c       	adc	r15, r1
    ab66:	80 e6       	ldi	r24, 0x60	; 96
    ab68:	90 e0       	ldi	r25, 0x00	; 0
    ab6a:	c8 0e       	add	r12, r24
    ab6c:	d9 1e       	adc	r13, r25
    ab6e:	95 e0       	ldi	r25, 0x05	; 5
    ab70:	e9 16       	cp	r14, r25
    ab72:	f1 04       	cpc	r15, r1
    ab74:	09 f0       	breq	.+2      	; 0xab78 <checkconnect+0x17e>
    ab76:	90 cf       	rjmp	.-224    	; 0xaa98 <checkconnect+0x9e>
		}
		
	}
	
	return rc;
}
    ab78:	c8 01       	movw	r24, r16
    ab7a:	0f 90       	pop	r0
    ab7c:	0f 90       	pop	r0
    ab7e:	cf 91       	pop	r28
    ab80:	df 91       	pop	r29
    ab82:	1f 91       	pop	r17
    ab84:	0f 91       	pop	r16
    ab86:	ff 90       	pop	r15
    ab88:	ef 90       	pop	r14
    ab8a:	df 90       	pop	r13
    ab8c:	cf 90       	pop	r12
    ab8e:	bf 90       	pop	r11
    ab90:	af 90       	pop	r10
    ab92:	9f 90       	pop	r9
    ab94:	8f 90       	pop	r8
    ab96:	7f 90       	pop	r7
    ab98:	6f 90       	pop	r6
    ab9a:	5f 90       	pop	r5
    ab9c:	4f 90       	pop	r4
    ab9e:	3f 90       	pop	r3
    aba0:	2f 90       	pop	r2
    aba2:	08 95       	ret

0000aba4 <Print_Handlesinfo>:
}

/**********************************************************************************************************************/

void Print_Handlesinfo(void)
{
    aba4:	8f 92       	push	r8
    aba6:	9f 92       	push	r9
    aba8:	af 92       	push	r10
    abaa:	bf 92       	push	r11
    abac:	cf 92       	push	r12
    abae:	df 92       	push	r13
    abb0:	ef 92       	push	r14
    abb2:	ff 92       	push	r15
    abb4:	0f 93       	push	r16
    abb6:	1f 93       	push	r17
    abb8:	cf 93       	push	r28
    abba:	df 93       	push	r29
    abbc:	04 e7       	ldi	r16, 0x74	; 116
    abbe:	1d e7       	ldi	r17, 0x7D	; 125
    abc0:	c0 e0       	ldi	r28, 0x00	; 0
    abc2:	d0 e0       	ldi	r29, 0x00	; 0
  int16 axis;
  
	for(axis=0; axis < DOF; axis++) 
	{  
		printf("Print_Handlesinfo=> El Index del vector es %d \n",axis );
    abc4:	ef e5       	ldi	r30, 0x5F	; 95
    abc6:	8e 2e       	mov	r8, r30
    abc8:	e2 e6       	ldi	r30, 0x62	; 98
    abca:	9e 2e       	mov	r9, r30
		printf("Print_Handlesinfo=> hAxis[%d].axis es igual a  %d  \n",axis,hAxis[axis].axis);
    abcc:	7f e8       	ldi	r23, 0x8F	; 143
    abce:	a7 2e       	mov	r10, r23
    abd0:	72 e6       	ldi	r23, 0x62	; 98
    abd2:	b7 2e       	mov	r11, r23
		printf("Print_Handlesinfo=> Corresponde a %s \n",AxisName(axis));
    abd4:	64 ec       	ldi	r22, 0xC4	; 196
    abd6:	c6 2e       	mov	r12, r22
    abd8:	62 e6       	ldi	r22, 0x62	; 98
    abda:	d6 2e       	mov	r13, r22
		printf("Print_Handlesinfo=> Es manejado por el chipset %d  \n",hAxis[axis].chipset);
    abdc:	5b ee       	ldi	r21, 0xEB	; 235
    abde:	e5 2e       	mov	r14, r21
    abe0:	52 e6       	ldi	r21, 0x62	; 98
    abe2:	f5 2e       	mov	r15, r21
{
  int16 axis;
  
	for(axis=0; axis < DOF; axis++) 
	{  
		printf("Print_Handlesinfo=> El Index del vector es %d \n",axis );
    abe4:	00 d0       	rcall	.+0      	; 0xabe6 <Print_Handlesinfo+0x42>
    abe6:	00 d0       	rcall	.+0      	; 0xabe8 <Print_Handlesinfo+0x44>
    abe8:	ad b7       	in	r26, 0x3d	; 61
    abea:	be b7       	in	r27, 0x3e	; 62
    abec:	12 96       	adiw	r26, 0x02	; 2
    abee:	9c 92       	st	X, r9
    abf0:	8e 92       	st	-X, r8
    abf2:	11 97       	sbiw	r26, 0x01	; 1
    abf4:	14 96       	adiw	r26, 0x04	; 4
    abf6:	dc 93       	st	X, r29
    abf8:	ce 93       	st	-X, r28
    abfa:	13 97       	sbiw	r26, 0x03	; 3
    abfc:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("Print_Handlesinfo=> hAxis[%d].axis es igual a  %d  \n",axis,hAxis[axis].axis);
    ac00:	00 d0       	rcall	.+0      	; 0xac02 <Print_Handlesinfo+0x5e>
    ac02:	ed b7       	in	r30, 0x3d	; 61
    ac04:	fe b7       	in	r31, 0x3e	; 62
    ac06:	31 96       	adiw	r30, 0x01	; 1
    ac08:	ad b7       	in	r26, 0x3d	; 61
    ac0a:	be b7       	in	r27, 0x3e	; 62
    ac0c:	12 96       	adiw	r26, 0x02	; 2
    ac0e:	bc 92       	st	X, r11
    ac10:	ae 92       	st	-X, r10
    ac12:	11 97       	sbiw	r26, 0x01	; 1
    ac14:	d3 83       	std	Z+3, r29	; 0x03
    ac16:	c2 83       	std	Z+2, r28	; 0x02
    ac18:	d8 01       	movw	r26, r16
    ac1a:	12 96       	adiw	r26, 0x02	; 2
    ac1c:	8d 91       	ld	r24, X+
    ac1e:	9c 91       	ld	r25, X
    ac20:	13 97       	sbiw	r26, 0x03	; 3
    ac22:	95 83       	std	Z+5, r25	; 0x05
    ac24:	84 83       	std	Z+4, r24	; 0x04
    ac26:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("Print_Handlesinfo=> Corresponde a %s \n",AxisName(axis));
    ac2a:	ed b7       	in	r30, 0x3d	; 61
    ac2c:	fe b7       	in	r31, 0x3e	; 62
    ac2e:	36 96       	adiw	r30, 0x06	; 6
    ac30:	0f b6       	in	r0, 0x3f	; 63
    ac32:	f8 94       	cli
    ac34:	fe bf       	out	0x3e, r31	; 62
    ac36:	0f be       	out	0x3f, r0	; 63
    ac38:	ed bf       	out	0x3d, r30	; 61
    ac3a:	ce 01       	movw	r24, r28
    ac3c:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    ac40:	00 d0       	rcall	.+0      	; 0xac42 <Print_Handlesinfo+0x9e>
    ac42:	00 d0       	rcall	.+0      	; 0xac44 <Print_Handlesinfo+0xa0>
    ac44:	ad b7       	in	r26, 0x3d	; 61
    ac46:	be b7       	in	r27, 0x3e	; 62
    ac48:	12 96       	adiw	r26, 0x02	; 2
    ac4a:	dc 92       	st	X, r13
    ac4c:	ce 92       	st	-X, r12
    ac4e:	11 97       	sbiw	r26, 0x01	; 1
    ac50:	14 96       	adiw	r26, 0x04	; 4
    ac52:	9c 93       	st	X, r25
    ac54:	8e 93       	st	-X, r24
    ac56:	13 97       	sbiw	r26, 0x03	; 3
    ac58:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		printf("Print_Handlesinfo=> Es manejado por el chipset %d  \n",hAxis[axis].chipset);
    ac5c:	ed b7       	in	r30, 0x3d	; 61
    ac5e:	fe b7       	in	r31, 0x3e	; 62
    ac60:	f2 82       	std	Z+2, r15	; 0x02
    ac62:	e1 82       	std	Z+1, r14	; 0x01
    ac64:	d8 01       	movw	r26, r16
    ac66:	8d 91       	ld	r24, X+
    ac68:	9c 91       	ld	r25, X
    ac6a:	94 83       	std	Z+4, r25	; 0x04
    ac6c:	83 83       	std	Z+3, r24	; 0x03
    ac6e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>

void Print_Handlesinfo(void)
{
  int16 axis;
  
	for(axis=0; axis < DOF; axis++) 
    ac72:	21 96       	adiw	r28, 0x01	; 1
    ac74:	00 5a       	subi	r16, 0xA0	; 160
    ac76:	1f 4f       	sbci	r17, 0xFF	; 255
    ac78:	0f 90       	pop	r0
    ac7a:	0f 90       	pop	r0
    ac7c:	0f 90       	pop	r0
    ac7e:	0f 90       	pop	r0
    ac80:	c5 30       	cpi	r28, 0x05	; 5
    ac82:	d1 05       	cpc	r29, r1
    ac84:	09 f0       	breq	.+2      	; 0xac88 <Print_Handlesinfo+0xe4>
    ac86:	ae cf       	rjmp	.-164    	; 0xabe4 <Print_Handlesinfo+0x40>
		printf("Print_Handlesinfo=> hAxis[%d].axis es igual a  %d  \n",axis,hAxis[axis].axis);
		printf("Print_Handlesinfo=> Corresponde a %s \n",AxisName(axis));
		printf("Print_Handlesinfo=> Es manejado por el chipset %d  \n",hAxis[axis].chipset);
	}
	
}
    ac88:	df 91       	pop	r29
    ac8a:	cf 91       	pop	r28
    ac8c:	1f 91       	pop	r17
    ac8e:	0f 91       	pop	r16
    ac90:	ff 90       	pop	r15
    ac92:	ef 90       	pop	r14
    ac94:	df 90       	pop	r13
    ac96:	cf 90       	pop	r12
    ac98:	bf 90       	pop	r11
    ac9a:	af 90       	pop	r10
    ac9c:	9f 90       	pop	r9
    ac9e:	8f 90       	pop	r8
    aca0:	08 95       	ret

0000aca2 <getErrorHost>:
/**********************************************************************************************************************/
PMDuint16 getErrorHost(int16 axis)
{
    aca2:	df 93       	push	r29
    aca4:	cf 93       	push	r28
    aca6:	00 d0       	rcall	.+0      	; 0xaca8 <getErrorHost+0x6>
    aca8:	cd b7       	in	r28, 0x3d	; 61
    acaa:	de b7       	in	r29, 0x3e	; 62
    PMDuint16 ErrorPMD=0;
    acac:	1a 82       	std	Y+2, r1	; 0x02
    acae:	19 82       	std	Y+1, r1	; 0x01
	 
	PMDGetHostIOError(&hAxis[axis],&ErrorPMD);
    acb0:	20 e6       	ldi	r18, 0x60	; 96
    acb2:	30 e0       	ldi	r19, 0x00	; 0
    acb4:	ac 01       	movw	r20, r24
    acb6:	42 9f       	mul	r20, r18
    acb8:	c0 01       	movw	r24, r0
    acba:	43 9f       	mul	r20, r19
    acbc:	90 0d       	add	r25, r0
    acbe:	52 9f       	mul	r21, r18
    acc0:	90 0d       	add	r25, r0
    acc2:	11 24       	eor	r1, r1
    acc4:	8c 58       	subi	r24, 0x8C	; 140
    acc6:	92 48       	sbci	r25, 0x82	; 130
    acc8:	be 01       	movw	r22, r28
    acca:	6f 5f       	subi	r22, 0xFF	; 255
    accc:	7f 4f       	sbci	r23, 0xFF	; 255
    acce:	0e 94 09 60 	call	0xc012	; 0xc012 <PMDGetHostIOError>
	
	return ErrorPMD;
}
    acd2:	89 81       	ldd	r24, Y+1	; 0x01
    acd4:	9a 81       	ldd	r25, Y+2	; 0x02
    acd6:	0f 90       	pop	r0
    acd8:	0f 90       	pop	r0
    acda:	cf 91       	pop	r28
    acdc:	df 91       	pop	r29
    acde:	08 95       	ret

0000ace0 <infomov>:
}
/**********************************************************************************************************************/
void infomov(int16 Axis, PMDint32* position, PMDint32* velocity, PMDuint32* acceleration, PMDuint32* deceleration,
			PMDint32* commandedposition,PMDint32* commandedvelocity, PMDint32* commandedacceleration,
			PMDint32* readencoder1, PMDint32* readerror,PMDuint16* encoderCounts, PMDuint16* steps)
{
    ace0:	2f 92       	push	r2
    ace2:	3f 92       	push	r3
    ace4:	4f 92       	push	r4
    ace6:	5f 92       	push	r5
    ace8:	6f 92       	push	r6
    acea:	7f 92       	push	r7
    acec:	8f 92       	push	r8
    acee:	9f 92       	push	r9
    acf0:	af 92       	push	r10
    acf2:	bf 92       	push	r11
    acf4:	cf 92       	push	r12
    acf6:	df 92       	push	r13
    acf8:	ef 92       	push	r14
    acfa:	ff 92       	push	r15
    acfc:	0f 93       	push	r16
    acfe:	1f 93       	push	r17
    ad00:	df 93       	push	r29
    ad02:	cf 93       	push	r28
    ad04:	00 d0       	rcall	.+0      	; 0xad06 <infomov+0x26>
    ad06:	00 d0       	rcall	.+0      	; 0xad08 <infomov+0x28>
    ad08:	cd b7       	in	r28, 0x3d	; 61
    ad0a:	de b7       	in	r29, 0x3e	; 62
    ad0c:	3c 01       	movw	r6, r24
    ad0e:	2b 01       	movw	r4, r22
    ad10:	1a 01       	movw	r2, r20
    ad12:	3a 83       	std	Y+2, r19	; 0x02
    ad14:	29 83       	std	Y+1, r18	; 0x01
    ad16:	1c 83       	std	Y+4, r17	; 0x04
    ad18:	0b 83       	std	Y+3, r16	; 0x03
	
	PMDGetPosition(&hAxis[Axis],position);
    ad1a:	80 e6       	ldi	r24, 0x60	; 96
    ad1c:	90 e0       	ldi	r25, 0x00	; 0
    ad1e:	68 9e       	mul	r6, r24
    ad20:	80 01       	movw	r16, r0
    ad22:	69 9e       	mul	r6, r25
    ad24:	10 0d       	add	r17, r0
    ad26:	78 9e       	mul	r7, r24
    ad28:	10 0d       	add	r17, r0
    ad2a:	11 24       	eor	r1, r1
    ad2c:	0c 58       	subi	r16, 0x8C	; 140
    ad2e:	12 48       	sbci	r17, 0x82	; 130
    ad30:	c8 01       	movw	r24, r16
    ad32:	0e 94 b6 64 	call	0xc96c	; 0xc96c <PMDGetPosition>
	PMDGetVelocity(&hAxis[Axis],velocity);
    ad36:	c8 01       	movw	r24, r16
    ad38:	b1 01       	movw	r22, r2
    ad3a:	0e 94 b0 64 	call	0xc960	; 0xc960 <PMDGetVelocity>
	PMDGetAcceleration(&hAxis[Axis],acceleration);
    ad3e:	c8 01       	movw	r24, r16
    ad40:	69 81       	ldd	r22, Y+1	; 0x01
    ad42:	7a 81       	ldd	r23, Y+2	; 0x02
    ad44:	0e 94 a4 64 	call	0xc948	; 0xc948 <PMDGetAcceleration>
	PMDGetDeceleration(&hAxis[Axis],deceleration);
    ad48:	c8 01       	movw	r24, r16
    ad4a:	6b 81       	ldd	r22, Y+3	; 0x03
    ad4c:	7c 81       	ldd	r23, Y+4	; 0x04
    ad4e:	0e 94 9e 64 	call	0xc93c	; 0xc93c <PMDGetDeceleration>
	
	PMDGetCommandedPosition(&hAxis[Axis],commandedposition);
    ad52:	c8 01       	movw	r24, r16
    ad54:	b7 01       	movw	r22, r14
    ad56:	0e 94 8c 64 	call	0xc918	; 0xc918 <PMDGetCommandedPosition>
	PMDGetCommandedVelocity(&hAxis[Axis],commandedvelocity);
    ad5a:	c8 01       	movw	r24, r16
    ad5c:	b6 01       	movw	r22, r12
    ad5e:	0e 94 86 64 	call	0xc90c	; 0xc90c <PMDGetCommandedVelocity>
	PMDGetCommandedAcceleration(&hAxis[Axis],commandedacceleration);
    ad62:	c8 01       	movw	r24, r16
    ad64:	b5 01       	movw	r22, r10
    ad66:	0e 94 80 64 	call	0xc900	; 0xc900 <PMDGetCommandedAcceleration>
	
	
	//Funciones que hacen uso del Encoder
	PMDGetActualPosition(&hAxis[Axis],readencoder1);
    ad6a:	c8 01       	movw	r24, r16
    ad6c:	b4 01       	movw	r22, r8
    ad6e:	0e 94 62 64 	call	0xc8c4	; 0xc8c4 <PMDGetActualPosition>
	PMDGetPositionError(&hAxis[Axis], readerror);	
    ad72:	c8 01       	movw	r24, r16
    ad74:	69 8d       	ldd	r22, Y+25	; 0x19
    ad76:	7a 8d       	ldd	r23, Y+26	; 0x1a
    ad78:	0e 94 68 64 	call	0xc8d0	; 0xc8d0 <PMDGetPositionError>
	PMDGetEncoderToStepRatio(&hAxis[Axis], encoderCounts,steps);
    ad7c:	c8 01       	movw	r24, r16
    ad7e:	6b 8d       	ldd	r22, Y+27	; 0x1b
    ad80:	7c 8d       	ldd	r23, Y+28	; 0x1c
    ad82:	4d 8d       	ldd	r20, Y+29	; 0x1d
    ad84:	5e 8d       	ldd	r21, Y+30	; 0x1e
    ad86:	0e 94 31 65 	call	0xca62	; 0xca62 <PMDGetEncoderToStepRatio>
	
	printf("infomov=> La informacion correspondiente del movimiento del eje %s es :\n",AxisName(Axis));
    ad8a:	c3 01       	movw	r24, r6
    ad8c:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    ad90:	00 d0       	rcall	.+0      	; 0xad92 <infomov+0xb2>
    ad92:	00 d0       	rcall	.+0      	; 0xad94 <infomov+0xb4>
    ad94:	20 e2       	ldi	r18, 0x20	; 32
    ad96:	33 e6       	ldi	r19, 0x63	; 99
    ad98:	ed b7       	in	r30, 0x3d	; 61
    ad9a:	fe b7       	in	r31, 0x3e	; 62
    ad9c:	32 83       	std	Z+2, r19	; 0x02
    ad9e:	21 83       	std	Z+1, r18	; 0x01
    ada0:	94 83       	std	Z+4, r25	; 0x04
    ada2:	83 83       	std	Z+3, r24	; 0x03
    ada4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("infomov=> posicion=	%08ld\n",*position);
    ada8:	00 d0       	rcall	.+0      	; 0xadaa <infomov+0xca>
    adaa:	89 e6       	ldi	r24, 0x69	; 105
    adac:	93 e6       	ldi	r25, 0x63	; 99
    adae:	ed b7       	in	r30, 0x3d	; 61
    adb0:	fe b7       	in	r31, 0x3e	; 62
    adb2:	92 83       	std	Z+2, r25	; 0x02
    adb4:	81 83       	std	Z+1, r24	; 0x01
    adb6:	f2 01       	movw	r30, r4
    adb8:	80 81       	ld	r24, Z
    adba:	91 81       	ldd	r25, Z+1	; 0x01
    adbc:	a2 81       	ldd	r26, Z+2	; 0x02
    adbe:	b3 81       	ldd	r27, Z+3	; 0x03
    adc0:	ed b7       	in	r30, 0x3d	; 61
    adc2:	fe b7       	in	r31, 0x3e	; 62
    adc4:	83 83       	std	Z+3, r24	; 0x03
    adc6:	94 83       	std	Z+4, r25	; 0x04
    adc8:	a5 83       	std	Z+5, r26	; 0x05
    adca:	b6 83       	std	Z+6, r27	; 0x06
    adcc:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("infomov=> velodidad	= 	%08ld\n",*velocity);
    add0:	84 e8       	ldi	r24, 0x84	; 132
    add2:	93 e6       	ldi	r25, 0x63	; 99
    add4:	ed b7       	in	r30, 0x3d	; 61
    add6:	fe b7       	in	r31, 0x3e	; 62
    add8:	92 83       	std	Z+2, r25	; 0x02
    adda:	81 83       	std	Z+1, r24	; 0x01
    addc:	f1 01       	movw	r30, r2
    adde:	80 81       	ld	r24, Z
    ade0:	91 81       	ldd	r25, Z+1	; 0x01
    ade2:	a2 81       	ldd	r26, Z+2	; 0x02
    ade4:	b3 81       	ldd	r27, Z+3	; 0x03
    ade6:	ed b7       	in	r30, 0x3d	; 61
    ade8:	fe b7       	in	r31, 0x3e	; 62
    adea:	83 83       	std	Z+3, r24	; 0x03
    adec:	94 83       	std	Z+4, r25	; 0x04
    adee:	a5 83       	std	Z+5, r26	; 0x05
    adf0:	b6 83       	std	Z+6, r27	; 0x06
    adf2:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("infomov=> aceleracion=	%08ld\n",*acceleration);
    adf6:	82 ea       	ldi	r24, 0xA2	; 162
    adf8:	93 e6       	ldi	r25, 0x63	; 99
    adfa:	ed b7       	in	r30, 0x3d	; 61
    adfc:	fe b7       	in	r31, 0x3e	; 62
    adfe:	92 83       	std	Z+2, r25	; 0x02
    ae00:	81 83       	std	Z+1, r24	; 0x01
    ae02:	e9 81       	ldd	r30, Y+1	; 0x01
    ae04:	fa 81       	ldd	r31, Y+2	; 0x02
    ae06:	80 81       	ld	r24, Z
    ae08:	91 81       	ldd	r25, Z+1	; 0x01
    ae0a:	a2 81       	ldd	r26, Z+2	; 0x02
    ae0c:	b3 81       	ldd	r27, Z+3	; 0x03
    ae0e:	ed b7       	in	r30, 0x3d	; 61
    ae10:	fe b7       	in	r31, 0x3e	; 62
    ae12:	83 83       	std	Z+3, r24	; 0x03
    ae14:	94 83       	std	Z+4, r25	; 0x04
    ae16:	a5 83       	std	Z+5, r26	; 0x05
    ae18:	b6 83       	std	Z+6, r27	; 0x06
    ae1a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("infomov=> desaceleracion=	%08ld\n",*deceleration);
    ae1e:	80 ec       	ldi	r24, 0xC0	; 192
    ae20:	93 e6       	ldi	r25, 0x63	; 99
    ae22:	ed b7       	in	r30, 0x3d	; 61
    ae24:	fe b7       	in	r31, 0x3e	; 62
    ae26:	92 83       	std	Z+2, r25	; 0x02
    ae28:	81 83       	std	Z+1, r24	; 0x01
    ae2a:	eb 81       	ldd	r30, Y+3	; 0x03
    ae2c:	fc 81       	ldd	r31, Y+4	; 0x04
    ae2e:	80 81       	ld	r24, Z
    ae30:	91 81       	ldd	r25, Z+1	; 0x01
    ae32:	a2 81       	ldd	r26, Z+2	; 0x02
    ae34:	b3 81       	ldd	r27, Z+3	; 0x03
    ae36:	ed b7       	in	r30, 0x3d	; 61
    ae38:	fe b7       	in	r31, 0x3e	; 62
    ae3a:	83 83       	std	Z+3, r24	; 0x03
    ae3c:	94 83       	std	Z+4, r25	; 0x04
    ae3e:	a5 83       	std	Z+5, r26	; 0x05
    ae40:	b6 83       	std	Z+6, r27	; 0x06
    ae42:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("infomov=> posicion instantanea=	%08ld\n",*commandedposition);
    ae46:	81 ee       	ldi	r24, 0xE1	; 225
    ae48:	93 e6       	ldi	r25, 0x63	; 99
    ae4a:	ed b7       	in	r30, 0x3d	; 61
    ae4c:	fe b7       	in	r31, 0x3e	; 62
    ae4e:	92 83       	std	Z+2, r25	; 0x02
    ae50:	81 83       	std	Z+1, r24	; 0x01
    ae52:	f7 01       	movw	r30, r14
    ae54:	80 81       	ld	r24, Z
    ae56:	91 81       	ldd	r25, Z+1	; 0x01
    ae58:	a2 81       	ldd	r26, Z+2	; 0x02
    ae5a:	b3 81       	ldd	r27, Z+3	; 0x03
    ae5c:	ed b7       	in	r30, 0x3d	; 61
    ae5e:	fe b7       	in	r31, 0x3e	; 62
    ae60:	83 83       	std	Z+3, r24	; 0x03
    ae62:	94 83       	std	Z+4, r25	; 0x04
    ae64:	a5 83       	std	Z+5, r26	; 0x05
    ae66:	b6 83       	std	Z+6, r27	; 0x06
    ae68:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("infomov=> velocidad instantanea=	%08ld\n",*commandedvelocity);
    ae6c:	88 e0       	ldi	r24, 0x08	; 8
    ae6e:	94 e6       	ldi	r25, 0x64	; 100
    ae70:	ed b7       	in	r30, 0x3d	; 61
    ae72:	fe b7       	in	r31, 0x3e	; 62
    ae74:	92 83       	std	Z+2, r25	; 0x02
    ae76:	81 83       	std	Z+1, r24	; 0x01
    ae78:	f6 01       	movw	r30, r12
    ae7a:	80 81       	ld	r24, Z
    ae7c:	91 81       	ldd	r25, Z+1	; 0x01
    ae7e:	a2 81       	ldd	r26, Z+2	; 0x02
    ae80:	b3 81       	ldd	r27, Z+3	; 0x03
    ae82:	ed b7       	in	r30, 0x3d	; 61
    ae84:	fe b7       	in	r31, 0x3e	; 62
    ae86:	83 83       	std	Z+3, r24	; 0x03
    ae88:	94 83       	std	Z+4, r25	; 0x04
    ae8a:	a5 83       	std	Z+5, r26	; 0x05
    ae8c:	b6 83       	std	Z+6, r27	; 0x06
    ae8e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("infomov=> aceleracion instantanea=	%08ld\n",*commandedacceleration);
    ae92:	80 e3       	ldi	r24, 0x30	; 48
    ae94:	94 e6       	ldi	r25, 0x64	; 100
    ae96:	ed b7       	in	r30, 0x3d	; 61
    ae98:	fe b7       	in	r31, 0x3e	; 62
    ae9a:	92 83       	std	Z+2, r25	; 0x02
    ae9c:	81 83       	std	Z+1, r24	; 0x01
    ae9e:	f5 01       	movw	r30, r10
    aea0:	80 81       	ld	r24, Z
    aea2:	91 81       	ldd	r25, Z+1	; 0x01
    aea4:	a2 81       	ldd	r26, Z+2	; 0x02
    aea6:	b3 81       	ldd	r27, Z+3	; 0x03
    aea8:	ed b7       	in	r30, 0x3d	; 61
    aeaa:	fe b7       	in	r31, 0x3e	; 62
    aeac:	83 83       	std	Z+3, r24	; 0x03
    aeae:	94 83       	std	Z+4, r25	; 0x04
    aeb0:	a5 83       	std	Z+5, r26	; 0x05
    aeb2:	b6 83       	std	Z+6, r27	; 0x06
    aeb4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("infomov=> Lectura Encoder=	%08ld\n",*readencoder1);
    aeb8:	8a e5       	ldi	r24, 0x5A	; 90
    aeba:	94 e6       	ldi	r25, 0x64	; 100
    aebc:	ed b7       	in	r30, 0x3d	; 61
    aebe:	fe b7       	in	r31, 0x3e	; 62
    aec0:	92 83       	std	Z+2, r25	; 0x02
    aec2:	81 83       	std	Z+1, r24	; 0x01
    aec4:	f4 01       	movw	r30, r8
    aec6:	80 81       	ld	r24, Z
    aec8:	91 81       	ldd	r25, Z+1	; 0x01
    aeca:	a2 81       	ldd	r26, Z+2	; 0x02
    aecc:	b3 81       	ldd	r27, Z+3	; 0x03
    aece:	ed b7       	in	r30, 0x3d	; 61
    aed0:	fe b7       	in	r31, 0x3e	; 62
    aed2:	83 83       	std	Z+3, r24	; 0x03
    aed4:	94 83       	std	Z+4, r25	; 0x04
    aed6:	a5 83       	std	Z+5, r26	; 0x05
    aed8:	b6 83       	std	Z+6, r27	; 0x06
    aeda:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("infomov=> Error Posicion=	%08ld\n",*readerror);	
    aede:	8c e7       	ldi	r24, 0x7C	; 124
    aee0:	94 e6       	ldi	r25, 0x64	; 100
    aee2:	ed b7       	in	r30, 0x3d	; 61
    aee4:	fe b7       	in	r31, 0x3e	; 62
    aee6:	92 83       	std	Z+2, r25	; 0x02
    aee8:	81 83       	std	Z+1, r24	; 0x01
    aeea:	e9 8d       	ldd	r30, Y+25	; 0x19
    aeec:	fa 8d       	ldd	r31, Y+26	; 0x1a
    aeee:	80 81       	ld	r24, Z
    aef0:	91 81       	ldd	r25, Z+1	; 0x01
    aef2:	a2 81       	ldd	r26, Z+2	; 0x02
    aef4:	b3 81       	ldd	r27, Z+3	; 0x03
    aef6:	ed b7       	in	r30, 0x3d	; 61
    aef8:	fe b7       	in	r31, 0x3e	; 62
    aefa:	83 83       	std	Z+3, r24	; 0x03
    aefc:	94 83       	std	Z+4, r25	; 0x04
    aefe:	a5 83       	std	Z+5, r26	; 0x05
    af00:	b6 83       	std	Z+6, r27	; 0x06
    af02:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    af06:	8d b7       	in	r24, 0x3d	; 61
    af08:	9e b7       	in	r25, 0x3e	; 62
    af0a:	06 96       	adiw	r24, 0x06	; 6
    af0c:	0f b6       	in	r0, 0x3f	; 63
    af0e:	f8 94       	cli
    af10:	9e bf       	out	0x3e, r25	; 62
    af12:	0f be       	out	0x3f, r0	; 63
    af14:	8d bf       	out	0x3d, r24	; 61
	//printf("infomov=> Cuentas de Encoder= %08d \n",*cuentas_encoder);
	//printf("infomov=> No. uPasos por vuelta= %08d \n",*steps);		

	
}
    af16:	0f 90       	pop	r0
    af18:	0f 90       	pop	r0
    af1a:	0f 90       	pop	r0
    af1c:	0f 90       	pop	r0
    af1e:	cf 91       	pop	r28
    af20:	df 91       	pop	r29
    af22:	1f 91       	pop	r17
    af24:	0f 91       	pop	r16
    af26:	ff 90       	pop	r15
    af28:	ef 90       	pop	r14
    af2a:	df 90       	pop	r13
    af2c:	cf 90       	pop	r12
    af2e:	bf 90       	pop	r11
    af30:	af 90       	pop	r10
    af32:	9f 90       	pop	r9
    af34:	8f 90       	pop	r8
    af36:	7f 90       	pop	r7
    af38:	6f 90       	pop	r6
    af3a:	5f 90       	pop	r5
    af3c:	4f 90       	pop	r4
    af3e:	3f 90       	pop	r3
    af40:	2f 90       	pop	r2
    af42:	08 95       	ret

0000af44 <PMDCheckSignalStatus>:
//Si hay un 1 en la maskara SetSignalSense devuelve el invertido del valor electrico
//Si hay un 1 en la maskara el PMD interpreta que (0V SW oprimido) significa limite
//Si hay un 0 en la maskara SetSignalSense devuelve el el valor electrico
//Si hay un 0 en la maskara el PMD interpreta que (5V SW sin oprimir) significa limite
PMDresult PMDCheckSignalStatus(int16 Axis, PMDint16 print)
{
    af44:	af 92       	push	r10
    af46:	bf 92       	push	r11
    af48:	cf 92       	push	r12
    af4a:	df 92       	push	r13
    af4c:	ef 92       	push	r14
    af4e:	ff 92       	push	r15
    af50:	0f 93       	push	r16
    af52:	1f 93       	push	r17
    af54:	df 93       	push	r29
    af56:	cf 93       	push	r28
    af58:	cd b7       	in	r28, 0x3d	; 61
    af5a:	de b7       	in	r29, 0x3e	; 62
    af5c:	68 97       	sbiw	r28, 0x18	; 24
    af5e:	0f b6       	in	r0, 0x3f	; 63
    af60:	f8 94       	cli
    af62:	de bf       	out	0x3e, r29	; 62
    af64:	0f be       	out	0x3f, r0	; 63
    af66:	cd bf       	out	0x3d, r28	; 61
    af68:	5c 01       	movw	r10, r24
    af6a:	7b 01       	movw	r14, r22

	PMDuint16 status,mask,status_char;
	char binario[20]="0";
    af6c:	80 e3       	ldi	r24, 0x30	; 48
    af6e:	90 e0       	ldi	r25, 0x00	; 0
    af70:	a0 e0       	ldi	r26, 0x00	; 0
    af72:	b0 e0       	ldi	r27, 0x00	; 0
    af74:	8d 83       	std	Y+5, r24	; 0x05
    af76:	9e 83       	std	Y+6, r25	; 0x06
    af78:	af 83       	std	Y+7, r26	; 0x07
    af7a:	b8 87       	std	Y+8, r27	; 0x08
    af7c:	fe 01       	movw	r30, r28
    af7e:	39 96       	adiw	r30, 0x09	; 9
    af80:	80 e1       	ldi	r24, 0x10	; 16
    af82:	df 01       	movw	r26, r30
    af84:	1d 92       	st	X+, r1
    af86:	8a 95       	dec	r24
    af88:	e9 f7       	brne	.-6      	; 0xaf84 <PMDCheckSignalStatus+0x40>
	
	
	PMDGetSignalStatus(&hAxis[Axis],&status);
    af8a:	80 e6       	ldi	r24, 0x60	; 96
    af8c:	90 e0       	ldi	r25, 0x00	; 0
    af8e:	a8 9e       	mul	r10, r24
    af90:	60 01       	movw	r12, r0
    af92:	a9 9e       	mul	r10, r25
    af94:	d0 0c       	add	r13, r0
    af96:	b8 9e       	mul	r11, r24
    af98:	d0 0c       	add	r13, r0
    af9a:	11 24       	eor	r1, r1
    af9c:	e4 e7       	ldi	r30, 0x74	; 116
    af9e:	fd e7       	ldi	r31, 0x7D	; 125
    afa0:	ce 0e       	add	r12, r30
    afa2:	df 1e       	adc	r13, r31
    afa4:	c6 01       	movw	r24, r12
    afa6:	be 01       	movw	r22, r28
    afa8:	6f 5f       	subi	r22, 0xFF	; 255
    afaa:	7f 4f       	sbci	r23, 0xFF	; 255
    afac:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
	//printf("El Signal status register del eje %s es %X \n",AxisName(Axis),status);
	
	status_char=status;
    afb0:	89 81       	ldd	r24, Y+1	; 0x01
    afb2:	9a 81       	ldd	r25, Y+2	; 0x02
	status_char= status_char >> 3;
	
	itoa(status_char,binario,2);	
    afb4:	8e 01       	movw	r16, r28
    afb6:	0b 5f       	subi	r16, 0xFB	; 251
    afb8:	1f 4f       	sbci	r17, 0xFF	; 255
    afba:	f3 e0       	ldi	r31, 0x03	; 3
    afbc:	96 95       	lsr	r25
    afbe:	87 95       	ror	r24
    afc0:	fa 95       	dec	r31
    afc2:	e1 f7       	brne	.-8      	; 0xafbc <PMDCheckSignalStatus+0x78>
    afc4:	b8 01       	movw	r22, r16
    afc6:	42 e0       	ldi	r20, 0x02	; 2
    afc8:	50 e0       	ldi	r21, 0x00	; 0
    afca:	0e 94 12 88 	call	0x11024	; 0x11024 <itoa>
	
	printf("PMDCheckSignalStatus=> signal status = %s  \n",binario);
    afce:	00 d0       	rcall	.+0      	; 0xafd0 <PMDCheckSignalStatus+0x8c>
    afd0:	00 d0       	rcall	.+0      	; 0xafd2 <PMDCheckSignalStatus+0x8e>
    afd2:	8d e9       	ldi	r24, 0x9D	; 157
    afd4:	94 e6       	ldi	r25, 0x64	; 100
    afd6:	ad b7       	in	r26, 0x3d	; 61
    afd8:	be b7       	in	r27, 0x3e	; 62
    afda:	12 96       	adiw	r26, 0x02	; 2
    afdc:	9c 93       	st	X, r25
    afde:	8e 93       	st	-X, r24
    afe0:	11 97       	sbiw	r26, 0x01	; 1
    afe2:	14 96       	adiw	r26, 0x04	; 4
    afe4:	1c 93       	st	X, r17
    afe6:	0e 93       	st	-X, r16
    afe8:	13 97       	sbiw	r26, 0x03	; 3
    afea:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	
	
	if(print==imprimir)
    afee:	0f 90       	pop	r0
    aff0:	0f 90       	pop	r0
    aff2:	0f 90       	pop	r0
    aff4:	0f 90       	pop	r0
    aff6:	be ee       	ldi	r27, 0xEE	; 238
    aff8:	eb 16       	cp	r14, r27
    affa:	bf ef       	ldi	r27, 0xFF	; 255
    affc:	fb 06       	cpc	r15, r27
    affe:	09 f0       	breq	.+2      	; 0xb002 <PMDCheckSignalStatus+0xbe>
    b000:	bb c0       	rjmp	.+374    	; 0xb178 <PMDCheckSignalStatus+0x234>
	{
		PMDGetSignalSense(&hAxis[Axis],& mask);
    b002:	c6 01       	movw	r24, r12
    b004:	be 01       	movw	r22, r28
    b006:	6d 5f       	subi	r22, 0xFD	; 253
    b008:	7f 4f       	sbci	r23, 0xFF	; 255
    b00a:	0e 94 9b 61 	call	0xc336	; 0xc336 <PMDGetSignalSense>
		printf("PMDCheckSignalStatus=> La mascara de Signal sense del eje %s es %X \n",AxisName(Axis),mask);
    b00e:	c5 01       	movw	r24, r10
    b010:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b014:	00 d0       	rcall	.+0      	; 0xb016 <PMDCheckSignalStatus+0xd2>
    b016:	00 d0       	rcall	.+0      	; 0xb018 <PMDCheckSignalStatus+0xd4>
    b018:	00 d0       	rcall	.+0      	; 0xb01a <PMDCheckSignalStatus+0xd6>
    b01a:	ed b7       	in	r30, 0x3d	; 61
    b01c:	fe b7       	in	r31, 0x3e	; 62
    b01e:	31 96       	adiw	r30, 0x01	; 1
    b020:	2a ec       	ldi	r18, 0xCA	; 202
    b022:	34 e6       	ldi	r19, 0x64	; 100
    b024:	ad b7       	in	r26, 0x3d	; 61
    b026:	be b7       	in	r27, 0x3e	; 62
    b028:	12 96       	adiw	r26, 0x02	; 2
    b02a:	3c 93       	st	X, r19
    b02c:	2e 93       	st	-X, r18
    b02e:	11 97       	sbiw	r26, 0x01	; 1
    b030:	93 83       	std	Z+3, r25	; 0x03
    b032:	82 83       	std	Z+2, r24	; 0x02
    b034:	8b 81       	ldd	r24, Y+3	; 0x03
    b036:	9c 81       	ldd	r25, Y+4	; 0x04
    b038:	95 83       	std	Z+5, r25	; 0x05
    b03a:	84 83       	std	Z+4, r24	; 0x04
    b03c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	
		if ((status & PMDSignalEncoderAMask) !=0)
    b040:	89 81       	ldd	r24, Y+1	; 0x01
    b042:	ed b7       	in	r30, 0x3d	; 61
    b044:	fe b7       	in	r31, 0x3e	; 62
    b046:	36 96       	adiw	r30, 0x06	; 6
    b048:	0f b6       	in	r0, 0x3f	; 63
    b04a:	f8 94       	cli
    b04c:	fe bf       	out	0x3e, r31	; 62
    b04e:	0f be       	out	0x3f, r0	; 63
    b050:	ed bf       	out	0x3d, r30	; 61
    b052:	9b 81       	ldd	r25, Y+3	; 0x03
    b054:	80 ff       	sbrs	r24, 0
    b056:	08 c0       	rjmp	.+16     	; 0xb068 <PMDCheckSignalStatus+0x124>
		{
			if((mask & PMDSignalEncoderAMask)!=0)  //el bit vale 1 en el signal sense
    b058:	90 ff       	sbrs	r25, 0
    b05a:	03 c0       	rjmp	.+6      	; 0xb062 <PMDCheckSignalStatus+0x11e>
			
			printf("PMDCheckSignalStatus=> El canal A = Real (0V) Valor  registro (5V) \n");		
    b05c:	8f e0       	ldi	r24, 0x0F	; 15
    b05e:	95 e6       	ldi	r25, 0x65	; 101
    b060:	0a c0       	rjmp	.+20     	; 0xb076 <PMDCheckSignalStatus+0x132>
		    else
			printf("PMDCheckSignalStatus=> El canal A = (5V) Valor Electrico Real =registro \n");
    b062:	83 e5       	ldi	r24, 0x53	; 83
    b064:	95 e6       	ldi	r25, 0x65	; 101
    b066:	07 c0       	rjmp	.+14     	; 0xb076 <PMDCheckSignalStatus+0x132>
		}
		else
		{
			if((mask & PMDSignalEncoderAMask)!=0)  //el bit vale 1 en el signal sense
    b068:	90 ff       	sbrs	r25, 0
    b06a:	03 c0       	rjmp	.+6      	; 0xb072 <PMDCheckSignalStatus+0x12e>
			printf("PMDCheckSignalStatus=> El canal A = Real (5V) Valor  Registro (0V) \n");
    b06c:	8c e9       	ldi	r24, 0x9C	; 156
    b06e:	95 e6       	ldi	r25, 0x65	; 101
    b070:	02 c0       	rjmp	.+4      	; 0xb076 <PMDCheckSignalStatus+0x132>
				
		    else
			printf("PMDCheckSignalStatus=> El canal A = (0V) Valor Electrico Real = Registro \n");	
    b072:	80 ee       	ldi	r24, 0xE0	; 224
    b074:	95 e6       	ldi	r25, 0x65	; 101
    b076:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		}
		
		//--------------------------------------------------------------------------------//
		if ((status & PMDSignalEncoderBMask) !=0)
    b07a:	89 81       	ldd	r24, Y+1	; 0x01
    b07c:	9b 81       	ldd	r25, Y+3	; 0x03
    b07e:	81 ff       	sbrs	r24, 1
    b080:	08 c0       	rjmp	.+16     	; 0xb092 <PMDCheckSignalStatus+0x14e>
		{
			if((mask & PMDSignalEncoderBMask)!=0)  //el bit vale 1 en el signal sense
    b082:	91 ff       	sbrs	r25, 1
    b084:	03 c0       	rjmp	.+6      	; 0xb08c <PMDCheckSignalStatus+0x148>
			
			printf("PMDCheckSignalStatus=> El canal B = Real (0V) Valor registro (5V) \n");		
    b086:	8a e2       	ldi	r24, 0x2A	; 42
    b088:	96 e6       	ldi	r25, 0x66	; 102
    b08a:	0a c0       	rjmp	.+20     	; 0xb0a0 <PMDCheckSignalStatus+0x15c>
		    else
			printf("PMDCheckSignalStatus=> El canal B = (5V) Valor Electrico Real =registro \n");
    b08c:	8d e6       	ldi	r24, 0x6D	; 109
    b08e:	96 e6       	ldi	r25, 0x66	; 102
    b090:	07 c0       	rjmp	.+14     	; 0xb0a0 <PMDCheckSignalStatus+0x15c>
		}
		else
		{
			if((mask & PMDSignalEncoderBMask)!=0)  //el bit vale 1 en el signal sense
    b092:	91 ff       	sbrs	r25, 1
    b094:	03 c0       	rjmp	.+6      	; 0xb09c <PMDCheckSignalStatus+0x158>
			printf("PMDCheckSignalStatus=> El canal B = Real (5V) Valor Registro (0V) \n");
    b096:	86 eb       	ldi	r24, 0xB6	; 182
    b098:	96 e6       	ldi	r25, 0x66	; 102
    b09a:	02 c0       	rjmp	.+4      	; 0xb0a0 <PMDCheckSignalStatus+0x15c>
				
		    else
			printf("PMDCheckSignalStatus=> El canal B = (0V) Valor Electrico Real= Registro \n");	
    b09c:	89 ef       	ldi	r24, 0xF9	; 249
    b09e:	96 e6       	ldi	r25, 0x66	; 102
    b0a0:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		}
		//--------------------------------------------------------------------------------//
		
		if ((status & PMDSignalEncoderIndexMask) !=0)
    b0a4:	89 81       	ldd	r24, Y+1	; 0x01
    b0a6:	9b 81       	ldd	r25, Y+3	; 0x03
    b0a8:	82 ff       	sbrs	r24, 2
    b0aa:	08 c0       	rjmp	.+16     	; 0xb0bc <PMDCheckSignalStatus+0x178>
		{
			if((mask & PMDSignalEncoderIndexMask)!=0)  //el bit vale 1 en el signal sense
    b0ac:	92 ff       	sbrs	r25, 2
    b0ae:	03 c0       	rjmp	.+6      	; 0xb0b6 <PMDCheckSignalStatus+0x172>
			
			printf("PMDCheckSignalStatus=> Index = Real (0V) Valor registro (5V) \n");		
    b0b0:	82 e4       	ldi	r24, 0x42	; 66
    b0b2:	97 e6       	ldi	r25, 0x67	; 103
    b0b4:	0a c0       	rjmp	.+20     	; 0xb0ca <PMDCheckSignalStatus+0x186>
		    else
			printf("PMDCheckSignalStatus=> Index = (5V) Valor Electrico Real = registro \n");
    b0b6:	80 e8       	ldi	r24, 0x80	; 128
    b0b8:	97 e6       	ldi	r25, 0x67	; 103
    b0ba:	07 c0       	rjmp	.+14     	; 0xb0ca <PMDCheckSignalStatus+0x186>
		}
		else
		{
			if((mask & PMDSignalEncoderIndexMask)!=0)  //el bit vale 1 en el signal sense
    b0bc:	92 ff       	sbrs	r25, 2
    b0be:	03 c0       	rjmp	.+6      	; 0xb0c6 <PMDCheckSignalStatus+0x182>
			printf("PMDCheckSignalStatus=> Index = Real (5V) Valor Registro (0V) \n");
    b0c0:	85 ec       	ldi	r24, 0xC5	; 197
    b0c2:	97 e6       	ldi	r25, 0x67	; 103
    b0c4:	02 c0       	rjmp	.+4      	; 0xb0ca <PMDCheckSignalStatus+0x186>
				
		    else
			printf("PMDCheckSignalStatus=> Index = (0V) Valor Electrico Real= Registro \n");	
    b0c6:	83 e0       	ldi	r24, 0x03	; 3
    b0c8:	98 e6       	ldi	r25, 0x68	; 104
    b0ca:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		}
		
		
		//--------------------------------------------------------------------------------//
		
		if ((status & PMDSignalEncoderHomeMask) !=0)
    b0ce:	89 81       	ldd	r24, Y+1	; 0x01
    b0d0:	9b 81       	ldd	r25, Y+3	; 0x03
    b0d2:	83 ff       	sbrs	r24, 3
    b0d4:	08 c0       	rjmp	.+16     	; 0xb0e6 <PMDCheckSignalStatus+0x1a2>
		{
			if((mask & PMDSignalEncoderHomeMask)!=0)  //el bit vale 1 en el signal sense
    b0d6:	93 ff       	sbrs	r25, 3
    b0d8:	03 c0       	rjmp	.+6      	; 0xb0e0 <PMDCheckSignalStatus+0x19c>
			
			printf("PMDCheckSignalStatus=> Home = Real (0V) Valor registro (5V) Captura Low to High \n");		
    b0da:	87 e4       	ldi	r24, 0x47	; 71
    b0dc:	98 e6       	ldi	r25, 0x68	; 104
    b0de:	0a c0       	rjmp	.+20     	; 0xb0f4 <PMDCheckSignalStatus+0x1b0>
		    else
			printf("PMDCheckSignalStatus=> Home = (5V) Valor Electrico Real = registro Captura de High To Low \n");
    b0e0:	88 e9       	ldi	r24, 0x98	; 152
    b0e2:	98 e6       	ldi	r25, 0x68	; 104
    b0e4:	07 c0       	rjmp	.+14     	; 0xb0f4 <PMDCheckSignalStatus+0x1b0>
		}
		else
		{
			if((mask & PMDSignalEncoderHomeMask)!=0)  //el bit vale 1 en el signal sense
    b0e6:	93 ff       	sbrs	r25, 3
    b0e8:	03 c0       	rjmp	.+6      	; 0xb0f0 <PMDCheckSignalStatus+0x1ac>
			printf("PMDCheckSignalStatus=> Home = Real (5V) Valor Registro (0V) Captura Low to High \n");
    b0ea:	83 ef       	ldi	r24, 0xF3	; 243
    b0ec:	98 e6       	ldi	r25, 0x68	; 104
    b0ee:	02 c0       	rjmp	.+4      	; 0xb0f4 <PMDCheckSignalStatus+0x1b0>
				
		    else
			printf("PMDCheckSignalStatus=> Home = (0V) Valor Electrico Real = Registro  Captura de High To Low \n");	
    b0f0:	84 e4       	ldi	r24, 0x44	; 68
    b0f2:	99 e6       	ldi	r25, 0x69	; 105
    b0f4:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		}
		
		//--------------------------------------------------------------------------------//
		if ((status & PMDSignalPositiveLimitMask) !=0)
    b0f8:	89 81       	ldd	r24, Y+1	; 0x01
    b0fa:	9b 81       	ldd	r25, Y+3	; 0x03
    b0fc:	84 ff       	sbrs	r24, 4
    b0fe:	08 c0       	rjmp	.+16     	; 0xb110 <PMDCheckSignalStatus+0x1cc>
		{
			if((mask & PMDSignalPositiveLimitMask)!=0)  //el bit vale 1 en el signal sense
    b100:	94 ff       	sbrs	r25, 4
    b102:	03 c0       	rjmp	.+6      	; 0xb10a <PMDCheckSignalStatus+0x1c6>
			
			printf("PMDCheckSignalStatus=> Limite Positivo = Real (0V) Valor registro (5V)  No hay Evento de Limite \n");		
    b104:	80 ea       	ldi	r24, 0xA0	; 160
    b106:	99 e6       	ldi	r25, 0x69	; 105
    b108:	0a c0       	rjmp	.+20     	; 0xb11e <PMDCheckSignalStatus+0x1da>
		    else
			printf("PMDCheckSignalStatus=> Limite Positivo = (5V) Valor Electrico Real = registro No hay Evento de Limite \n");
    b10a:	81 e0       	ldi	r24, 0x01	; 1
    b10c:	9a e6       	ldi	r25, 0x6A	; 106
    b10e:	07 c0       	rjmp	.+14     	; 0xb11e <PMDCheckSignalStatus+0x1da>
		}
		else
		{
			if((mask & PMDSignalPositiveLimitMask)!=0)  //el bit vale 1 en el signal sense
    b110:	94 ff       	sbrs	r25, 4
    b112:	03 c0       	rjmp	.+6      	; 0xb11a <PMDCheckSignalStatus+0x1d6>
			
			printf("PMDCheckSignalStatus=> Limite Positivo = Real (5V) Valor Registro (0V) Hay Evento de Limite\n");
    b114:	88 e6       	ldi	r24, 0x68	; 104
    b116:	9a e6       	ldi	r25, 0x6A	; 106
    b118:	02 c0       	rjmp	.+4      	; 0xb11e <PMDCheckSignalStatus+0x1da>
			else
			printf("PMDCheckSignalStatus=> Limite Positivo = (0V) Valor Electrico Real = Registro hay Evento de Limite \n");	
    b11a:	84 ec       	ldi	r24, 0xC4	; 196
    b11c:	9a e6       	ldi	r25, 0x6A	; 106
    b11e:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		}
		//--------------------------------------------------------------------------------//
		if ((status & PMDSignalNegativeLimitMask) !=0)
    b122:	89 81       	ldd	r24, Y+1	; 0x01
    b124:	9b 81       	ldd	r25, Y+3	; 0x03
    b126:	85 ff       	sbrs	r24, 5
    b128:	08 c0       	rjmp	.+16     	; 0xb13a <PMDCheckSignalStatus+0x1f6>
		{
			if((mask & PMDSignalNegativeLimitMask)!=0)  //el bit vale 1 en el signal sense
    b12a:	95 ff       	sbrs	r25, 5
    b12c:	03 c0       	rjmp	.+6      	; 0xb134 <PMDCheckSignalStatus+0x1f0>
			
			printf("PMDCheckSignalStatus=> Limite Negativo = Real (0V) Valor registro (5V) No hay Evento de Limite \n");		
    b12e:	88 e2       	ldi	r24, 0x28	; 40
    b130:	9b e6       	ldi	r25, 0x6B	; 107
    b132:	0a c0       	rjmp	.+20     	; 0xb148 <PMDCheckSignalStatus+0x204>
		    else
			printf("PMDCheckSignalStatus=> Limite Negativo = (5V) Valor Electrico Real= registro No hay Evento de Limite \n");
    b134:	88 e8       	ldi	r24, 0x88	; 136
    b136:	9b e6       	ldi	r25, 0x6B	; 107
    b138:	07 c0       	rjmp	.+14     	; 0xb148 <PMDCheckSignalStatus+0x204>
		}
		else
		{
			if((mask & PMDSignalNegativeLimitMask)!=0)  //el bit vale 1 en el signal sense
    b13a:	95 ff       	sbrs	r25, 5
    b13c:	03 c0       	rjmp	.+6      	; 0xb144 <PMDCheckSignalStatus+0x200>
			printf("PMDCheckSignalStatus=> Limite Negativo = Real (5V) Valor Registro (0V) Hay Evento de Limite\n");
    b13e:	8e ee       	ldi	r24, 0xEE	; 238
    b140:	9b e6       	ldi	r25, 0x6B	; 107
    b142:	02 c0       	rjmp	.+4      	; 0xb148 <PMDCheckSignalStatus+0x204>
			else
			printf("PMDCheckSignalStatus=> Limite Negativo = (0V) Valor Electrico Real = Registro hay Evento de Limite \n");	
    b144:	8a e4       	ldi	r24, 0x4A	; 74
    b146:	9c e6       	ldi	r25, 0x6C	; 108
    b148:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		}
		
		//--------------------------------------------------------------------------------//
		
		if ((status & PMDSignalStepOutputInvertMask) !=0) 
    b14c:	89 81       	ldd	r24, Y+1	; 0x01
    b14e:	9a 81       	ldd	r25, Y+2	; 0x02
    b150:	93 ff       	sbrs	r25, 3
    b152:	03 c0       	rjmp	.+6      	; 0xb15a <PMDCheckSignalStatus+0x216>
			printf("PMDCheckSignalStatus=> Step Output invert = + positivo\n");
    b154:	8e ea       	ldi	r24, 0xAE	; 174
    b156:	9c e6       	ldi	r25, 0x6C	; 108
    b158:	02 c0       	rjmp	.+4      	; 0xb15e <PMDCheckSignalStatus+0x21a>
		else
			printf("PMDCheckSignalStatus=> Step Output invert = - negativo\n");
    b15a:	85 ee       	ldi	r24, 0xE5	; 229
    b15c:	9c e6       	ldi	r25, 0x6C	; 108
    b15e:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		//--------------------------------------------------------------------------------//
		
		if ((status & PMDSignalMotorOutputInvertMask) !=0) 
    b162:	89 81       	ldd	r24, Y+1	; 0x01
    b164:	9a 81       	ldd	r25, Y+2	; 0x02
    b166:	94 ff       	sbrs	r25, 4
    b168:	03 c0       	rjmp	.+6      	; 0xb170 <PMDCheckSignalStatus+0x22c>
			printf("PMDCheckSignalStatus=> Motor Output invert = + positivo\n");
    b16a:	8c e1       	ldi	r24, 0x1C	; 28
    b16c:	9d e6       	ldi	r25, 0x6D	; 109
    b16e:	02 c0       	rjmp	.+4      	; 0xb174 <PMDCheckSignalStatus+0x230>
		else
			printf("PMDCheckSignalStatus=> Motor Output invert = - negativo\n");
    b170:	84 e5       	ldi	r24, 0x54	; 84
    b172:	9d e6       	ldi	r25, 0x6D	; 109
    b174:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
		//--------------------------------------------------------------------------------//
	}
	
	return status;

}
    b178:	89 81       	ldd	r24, Y+1	; 0x01
    b17a:	9a 81       	ldd	r25, Y+2	; 0x02
    b17c:	68 96       	adiw	r28, 0x18	; 24
    b17e:	0f b6       	in	r0, 0x3f	; 63
    b180:	f8 94       	cli
    b182:	de bf       	out	0x3e, r29	; 62
    b184:	0f be       	out	0x3f, r0	; 63
    b186:	cd bf       	out	0x3d, r28	; 61
    b188:	cf 91       	pop	r28
    b18a:	df 91       	pop	r29
    b18c:	1f 91       	pop	r17
    b18e:	0f 91       	pop	r16
    b190:	ff 90       	pop	r15
    b192:	ef 90       	pop	r14
    b194:	df 90       	pop	r13
    b196:	cf 90       	pop	r12
    b198:	bf 90       	pop	r11
    b19a:	af 90       	pop	r10
    b19c:	08 95       	ret

0000b19e <PMDCheckActivityStatus>:
}


/*****************************************************************************************/
PMDresult PMDCheckActivityStatus(int16 Axis, PMDint16 print)
{ 
    b19e:	ef 92       	push	r14
    b1a0:	ff 92       	push	r15
    b1a2:	0f 93       	push	r16
    b1a4:	1f 93       	push	r17
    b1a6:	df 93       	push	r29
    b1a8:	cf 93       	push	r28
    b1aa:	00 d0       	rcall	.+0      	; 0xb1ac <PMDCheckActivityStatus+0xe>
    b1ac:	cd b7       	in	r28, 0x3d	; 61
    b1ae:	de b7       	in	r29, 0x3e	; 62
    b1b0:	7c 01       	movw	r14, r24
    b1b2:	8b 01       	movw	r16, r22
	PMDuint16 status,profile;	
	
	PMDGetActivityStatus(&hAxis[Axis],&status);
    b1b4:	80 e6       	ldi	r24, 0x60	; 96
    b1b6:	90 e0       	ldi	r25, 0x00	; 0
    b1b8:	9c 01       	movw	r18, r24
    b1ba:	e2 9e       	mul	r14, r18
    b1bc:	c0 01       	movw	r24, r0
    b1be:	e3 9e       	mul	r14, r19
    b1c0:	90 0d       	add	r25, r0
    b1c2:	f2 9e       	mul	r15, r18
    b1c4:	90 0d       	add	r25, r0
    b1c6:	11 24       	eor	r1, r1
    b1c8:	8c 58       	subi	r24, 0x8C	; 140
    b1ca:	92 48       	sbci	r25, 0x82	; 130
    b1cc:	be 01       	movw	r22, r28
    b1ce:	6f 5f       	subi	r22, 0xFF	; 255
    b1d0:	7f 4f       	sbci	r23, 0xFF	; 255
    b1d2:	0e 94 a1 61 	call	0xc342	; 0xc342 <PMDGetActivityStatus>
	printf("PMDCheckActivityStatus=> El Activity status del eje %s es %X \n",AxisName(Axis),status);
    b1d6:	c7 01       	movw	r24, r14
    b1d8:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b1dc:	00 d0       	rcall	.+0      	; 0xb1de <PMDCheckActivityStatus+0x40>
    b1de:	00 d0       	rcall	.+0      	; 0xb1e0 <PMDCheckActivityStatus+0x42>
    b1e0:	00 d0       	rcall	.+0      	; 0xb1e2 <PMDCheckActivityStatus+0x44>
    b1e2:	ed b7       	in	r30, 0x3d	; 61
    b1e4:	fe b7       	in	r31, 0x3e	; 62
    b1e6:	31 96       	adiw	r30, 0x01	; 1
    b1e8:	2c e8       	ldi	r18, 0x8C	; 140
    b1ea:	3d e6       	ldi	r19, 0x6D	; 109
    b1ec:	ad b7       	in	r26, 0x3d	; 61
    b1ee:	be b7       	in	r27, 0x3e	; 62
    b1f0:	12 96       	adiw	r26, 0x02	; 2
    b1f2:	3c 93       	st	X, r19
    b1f4:	2e 93       	st	-X, r18
    b1f6:	11 97       	sbiw	r26, 0x01	; 1
    b1f8:	93 83       	std	Z+3, r25	; 0x03
    b1fa:	82 83       	std	Z+2, r24	; 0x02
    b1fc:	89 81       	ldd	r24, Y+1	; 0x01
    b1fe:	9a 81       	ldd	r25, Y+2	; 0x02
    b200:	95 83       	std	Z+5, r25	; 0x05
    b202:	84 83       	std	Z+4, r24	; 0x04
    b204:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	
	if(print==imprimir)
    b208:	ed b7       	in	r30, 0x3d	; 61
    b20a:	fe b7       	in	r31, 0x3e	; 62
    b20c:	36 96       	adiw	r30, 0x06	; 6
    b20e:	0f b6       	in	r0, 0x3f	; 63
    b210:	f8 94       	cli
    b212:	fe bf       	out	0x3e, r31	; 62
    b214:	0f be       	out	0x3f, r0	; 63
    b216:	ed bf       	out	0x3d, r30	; 61
    b218:	0e 5e       	subi	r16, 0xEE	; 238
    b21a:	1f 4f       	sbci	r17, 0xFF	; 255
    b21c:	09 f0       	breq	.+2      	; 0xb220 <PMDCheckActivityStatus+0x82>
    b21e:	0f c1       	rjmp	.+542    	; 0xb43e <PMDCheckActivityStatus+0x2a0>
	{
		if ((status & PMDActivityAtMaximumVelocityMask) !=0 ) 
    b220:	89 81       	ldd	r24, Y+1	; 0x01
    b222:	81 ff       	sbrs	r24, 1
    b224:	17 c0       	rjmp	.+46     	; 0xb254 <PMDCheckActivityStatus+0xb6>
			printf("PMDCheckActivityStatus=> El eje %s esta A la maxima Velocidad  \n",AxisName(Axis));
    b226:	c7 01       	movw	r24, r14
    b228:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b22c:	00 d0       	rcall	.+0      	; 0xb22e <PMDCheckActivityStatus+0x90>
    b22e:	00 d0       	rcall	.+0      	; 0xb230 <PMDCheckActivityStatus+0x92>
    b230:	2b ec       	ldi	r18, 0xCB	; 203
    b232:	3d e6       	ldi	r19, 0x6D	; 109
    b234:	ad b7       	in	r26, 0x3d	; 61
    b236:	be b7       	in	r27, 0x3e	; 62
    b238:	12 96       	adiw	r26, 0x02	; 2
    b23a:	3c 93       	st	X, r19
    b23c:	2e 93       	st	-X, r18
    b23e:	11 97       	sbiw	r26, 0x01	; 1
    b240:	14 96       	adiw	r26, 0x04	; 4
    b242:	9c 93       	st	X, r25
    b244:	8e 93       	st	-X, r24
    b246:	13 97       	sbiw	r26, 0x03	; 3
    b248:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b24c:	0f 90       	pop	r0
    b24e:	0f 90       	pop	r0
    b250:	0f 90       	pop	r0
    b252:	0f 90       	pop	r0
		
		if ((status & PMDActivityTrackingMask) !=0) 
    b254:	89 81       	ldd	r24, Y+1	; 0x01
    b256:	82 ff       	sbrs	r24, 2
    b258:	13 c0       	rjmp	.+38     	; 0xb280 <PMDCheckActivityStatus+0xe2>
			printf("PMDCheckActivityStatus=> El eje %s esta dentro del tracking window  \n",AxisName(Axis));
    b25a:	c7 01       	movw	r24, r14
    b25c:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b260:	00 d0       	rcall	.+0      	; 0xb262 <PMDCheckActivityStatus+0xc4>
    b262:	00 d0       	rcall	.+0      	; 0xb264 <PMDCheckActivityStatus+0xc6>
    b264:	2c e0       	ldi	r18, 0x0C	; 12
    b266:	3e e6       	ldi	r19, 0x6E	; 110
    b268:	ed b7       	in	r30, 0x3d	; 61
    b26a:	fe b7       	in	r31, 0x3e	; 62
    b26c:	32 83       	std	Z+2, r19	; 0x02
    b26e:	21 83       	std	Z+1, r18	; 0x01
    b270:	94 83       	std	Z+4, r25	; 0x04
    b272:	83 83       	std	Z+3, r24	; 0x03
    b274:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b278:	0f 90       	pop	r0
    b27a:	0f 90       	pop	r0
    b27c:	0f 90       	pop	r0
    b27e:	0f 90       	pop	r0
		
		profile=(status & PMDActivityProfileModeMask) >> 3;
		switch (profile)
    b280:	89 81       	ldd	r24, Y+1	; 0x01
    b282:	9a 81       	ldd	r25, Y+2	; 0x02
    b284:	88 73       	andi	r24, 0x38	; 56
    b286:	90 70       	andi	r25, 0x00	; 0
    b288:	a3 e0       	ldi	r26, 0x03	; 3
    b28a:	96 95       	lsr	r25
    b28c:	87 95       	ror	r24
    b28e:	aa 95       	dec	r26
    b290:	e1 f7       	brne	.-8      	; 0xb28a <PMDCheckActivityStatus+0xec>
    b292:	81 30       	cpi	r24, 0x01	; 1
    b294:	91 05       	cpc	r25, r1
    b296:	89 f0       	breq	.+34     	; 0xb2ba <PMDCheckActivityStatus+0x11c>
    b298:	81 30       	cpi	r24, 0x01	; 1
    b29a:	91 05       	cpc	r25, r1
    b29c:	30 f0       	brcs	.+12     	; 0xb2aa <PMDCheckActivityStatus+0x10c>
    b29e:	82 30       	cpi	r24, 0x02	; 2
    b2a0:	91 05       	cpc	r25, r1
    b2a2:	99 f0       	breq	.+38     	; 0xb2ca <PMDCheckActivityStatus+0x12c>
    b2a4:	03 97       	sbiw	r24, 0x03	; 3
    b2a6:	b1 f5       	brne	.+108    	; 0xb314 <PMDCheckActivityStatus+0x176>
    b2a8:	22 c0       	rjmp	.+68     	; 0xb2ee <PMDCheckActivityStatus+0x150>
		{
			case (0):
			printf("PMDCheckActivityStatus=> El eje  %s tiene perfil TRAPEZOIDAL \n",AxisName(Axis));
    b2aa:	c7 01       	movw	r24, r14
    b2ac:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b2b0:	00 d0       	rcall	.+0      	; 0xb2b2 <PMDCheckActivityStatus+0x114>
    b2b2:	00 d0       	rcall	.+0      	; 0xb2b4 <PMDCheckActivityStatus+0x116>
    b2b4:	22 e5       	ldi	r18, 0x52	; 82
    b2b6:	3e e6       	ldi	r19, 0x6E	; 110
    b2b8:	0f c0       	rjmp	.+30     	; 0xb2d8 <PMDCheckActivityStatus+0x13a>
			break;
			
			case (1):
			printf("PMDCheckActivityStatus=> El eje  %s tiene perfil de VELOCIDAD \n",AxisName(Axis));
    b2ba:	c7 01       	movw	r24, r14
    b2bc:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b2c0:	00 d0       	rcall	.+0      	; 0xb2c2 <PMDCheckActivityStatus+0x124>
    b2c2:	00 d0       	rcall	.+0      	; 0xb2c4 <PMDCheckActivityStatus+0x126>
    b2c4:	21 e9       	ldi	r18, 0x91	; 145
    b2c6:	3e e6       	ldi	r19, 0x6E	; 110
    b2c8:	19 c0       	rjmp	.+50     	; 0xb2fc <PMDCheckActivityStatus+0x15e>
			break;
			
			case (2):
			printf("PMDCheckActivityStatus=> El eje  %s tiene perfil CURVA-S \n",AxisName(Axis));
    b2ca:	c7 01       	movw	r24, r14
    b2cc:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b2d0:	00 d0       	rcall	.+0      	; 0xb2d2 <PMDCheckActivityStatus+0x134>
    b2d2:	00 d0       	rcall	.+0      	; 0xb2d4 <PMDCheckActivityStatus+0x136>
    b2d4:	21 ed       	ldi	r18, 0xD1	; 209
    b2d6:	3e e6       	ldi	r19, 0x6E	; 110
    b2d8:	ad b7       	in	r26, 0x3d	; 61
    b2da:	be b7       	in	r27, 0x3e	; 62
    b2dc:	12 96       	adiw	r26, 0x02	; 2
    b2de:	3c 93       	st	X, r19
    b2e0:	2e 93       	st	-X, r18
    b2e2:	11 97       	sbiw	r26, 0x01	; 1
    b2e4:	14 96       	adiw	r26, 0x04	; 4
    b2e6:	9c 93       	st	X, r25
    b2e8:	8e 93       	st	-X, r24
    b2ea:	13 97       	sbiw	r26, 0x03	; 3
    b2ec:	0d c0       	rjmp	.+26     	; 0xb308 <PMDCheckActivityStatus+0x16a>
			break;
			
			case (3):
			printf("PMDCheckActivityStatus=> El eje  %s tiene perfil ELECTRONIC GEAR \n",AxisName(Axis));
    b2ee:	c7 01       	movw	r24, r14
    b2f0:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b2f4:	00 d0       	rcall	.+0      	; 0xb2f6 <PMDCheckActivityStatus+0x158>
    b2f6:	00 d0       	rcall	.+0      	; 0xb2f8 <PMDCheckActivityStatus+0x15a>
    b2f8:	2c e0       	ldi	r18, 0x0C	; 12
    b2fa:	3f e6       	ldi	r19, 0x6F	; 111
    b2fc:	ed b7       	in	r30, 0x3d	; 61
    b2fe:	fe b7       	in	r31, 0x3e	; 62
    b300:	32 83       	std	Z+2, r19	; 0x02
    b302:	21 83       	std	Z+1, r18	; 0x01
    b304:	94 83       	std	Z+4, r25	; 0x04
    b306:	83 83       	std	Z+3, r24	; 0x03
    b308:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b30c:	0f 90       	pop	r0
    b30e:	0f 90       	pop	r0
    b310:	0f 90       	pop	r0
    b312:	0f 90       	pop	r0
			break;
		}
		
		if ((status & PMDActivityAxisSettledMask)!=0) 
    b314:	89 81       	ldd	r24, Y+1	; 0x01
    b316:	87 ff       	sbrs	r24, 7
    b318:	17 c0       	rjmp	.+46     	; 0xb348 <PMDCheckActivityStatus+0x1aa>
			printf("PMDCheckActivityStatus=> El eje %s ha permanecido en el Settle Window por un periodo de tiempo N \n",AxisName(Axis));
    b31a:	c7 01       	movw	r24, r14
    b31c:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b320:	00 d0       	rcall	.+0      	; 0xb322 <PMDCheckActivityStatus+0x184>
    b322:	00 d0       	rcall	.+0      	; 0xb324 <PMDCheckActivityStatus+0x186>
    b324:	2f e4       	ldi	r18, 0x4F	; 79
    b326:	3f e6       	ldi	r19, 0x6F	; 111
    b328:	ad b7       	in	r26, 0x3d	; 61
    b32a:	be b7       	in	r27, 0x3e	; 62
    b32c:	12 96       	adiw	r26, 0x02	; 2
    b32e:	3c 93       	st	X, r19
    b330:	2e 93       	st	-X, r18
    b332:	11 97       	sbiw	r26, 0x01	; 1
    b334:	14 96       	adiw	r26, 0x04	; 4
    b336:	9c 93       	st	X, r25
    b338:	8e 93       	st	-X, r24
    b33a:	13 97       	sbiw	r26, 0x03	; 3
    b33c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b340:	0f 90       	pop	r0
    b342:	0f 90       	pop	r0
    b344:	0f 90       	pop	r0
    b346:	0f 90       	pop	r0
		if ((status &  PMDActivityMotorOnMask) !=0) 
    b348:	89 81       	ldd	r24, Y+1	; 0x01
    b34a:	9a 81       	ldd	r25, Y+2	; 0x02
    b34c:	90 ff       	sbrs	r25, 0
    b34e:	13 c0       	rjmp	.+38     	; 0xb376 <PMDCheckActivityStatus+0x1d8>
			printf("PMDCheckActivityStatus=> El eje %s esta en MOTOR MODE ON \n",AxisName(Axis));		
    b350:	c7 01       	movw	r24, r14
    b352:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b356:	00 d0       	rcall	.+0      	; 0xb358 <PMDCheckActivityStatus+0x1ba>
    b358:	00 d0       	rcall	.+0      	; 0xb35a <PMDCheckActivityStatus+0x1bc>
    b35a:	22 eb       	ldi	r18, 0xB2	; 178
    b35c:	3f e6       	ldi	r19, 0x6F	; 111
    b35e:	ed b7       	in	r30, 0x3d	; 61
    b360:	fe b7       	in	r31, 0x3e	; 62
    b362:	32 83       	std	Z+2, r19	; 0x02
    b364:	21 83       	std	Z+1, r18	; 0x01
    b366:	94 83       	std	Z+4, r25	; 0x04
    b368:	83 83       	std	Z+3, r24	; 0x03
    b36a:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b36e:	0f 90       	pop	r0
    b370:	0f 90       	pop	r0
    b372:	0f 90       	pop	r0
    b374:	0f 90       	pop	r0
		if ((status & PMDActivityPositionCaptureMask) !=0 ) 
    b376:	89 81       	ldd	r24, Y+1	; 0x01
    b378:	9a 81       	ldd	r25, Y+2	; 0x02
    b37a:	91 ff       	sbrs	r25, 1
    b37c:	17 c0       	rjmp	.+46     	; 0xb3ac <PMDCheckActivityStatus+0x20e>
			printf("PMDCheckActivityStatus=> El eje %s tiene un nuevo valor de posicion disponible para leer \n",AxisName(Axis));		
    b37e:	c7 01       	movw	r24, r14
    b380:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b384:	00 d0       	rcall	.+0      	; 0xb386 <PMDCheckActivityStatus+0x1e8>
    b386:	00 d0       	rcall	.+0      	; 0xb388 <PMDCheckActivityStatus+0x1ea>
    b388:	2d ee       	ldi	r18, 0xED	; 237
    b38a:	3f e6       	ldi	r19, 0x6F	; 111
    b38c:	ad b7       	in	r26, 0x3d	; 61
    b38e:	be b7       	in	r27, 0x3e	; 62
    b390:	12 96       	adiw	r26, 0x02	; 2
    b392:	3c 93       	st	X, r19
    b394:	2e 93       	st	-X, r18
    b396:	11 97       	sbiw	r26, 0x01	; 1
    b398:	14 96       	adiw	r26, 0x04	; 4
    b39a:	9c 93       	st	X, r25
    b39c:	8e 93       	st	-X, r24
    b39e:	13 97       	sbiw	r26, 0x03	; 3
    b3a0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b3a4:	0f 90       	pop	r0
    b3a6:	0f 90       	pop	r0
    b3a8:	0f 90       	pop	r0
    b3aa:	0f 90       	pop	r0
		if ((status & PMDActivityInMotionMask) !=0) 
    b3ac:	89 81       	ldd	r24, Y+1	; 0x01
    b3ae:	9a 81       	ldd	r25, Y+2	; 0x02
    b3b0:	92 ff       	sbrs	r25, 2
    b3b2:	13 c0       	rjmp	.+38     	; 0xb3da <PMDCheckActivityStatus+0x23c>
			printf("PMDCheckActivityStatus=> La posicion comandada esta cambiando en el eje %s\n",AxisName(Axis));		
    b3b4:	c7 01       	movw	r24, r14
    b3b6:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b3ba:	00 d0       	rcall	.+0      	; 0xb3bc <PMDCheckActivityStatus+0x21e>
    b3bc:	00 d0       	rcall	.+0      	; 0xb3be <PMDCheckActivityStatus+0x220>
    b3be:	28 e4       	ldi	r18, 0x48	; 72
    b3c0:	30 e7       	ldi	r19, 0x70	; 112
    b3c2:	ed b7       	in	r30, 0x3d	; 61
    b3c4:	fe b7       	in	r31, 0x3e	; 62
    b3c6:	32 83       	std	Z+2, r19	; 0x02
    b3c8:	21 83       	std	Z+1, r18	; 0x01
    b3ca:	94 83       	std	Z+4, r25	; 0x04
    b3cc:	83 83       	std	Z+3, r24	; 0x03
    b3ce:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b3d2:	0f 90       	pop	r0
    b3d4:	0f 90       	pop	r0
    b3d6:	0f 90       	pop	r0
    b3d8:	0f 90       	pop	r0
		if ((status & PMDActivityInPositiveLimitMask) !=0) 
    b3da:	89 81       	ldd	r24, Y+1	; 0x01
    b3dc:	9a 81       	ldd	r25, Y+2	; 0x02
    b3de:	93 ff       	sbrs	r25, 3
    b3e0:	17 c0       	rjmp	.+46     	; 0xb410 <PMDCheckActivityStatus+0x272>
			printf("PMDCheckActivityStatus=> El eje %s  esta en el Limite Positivo \n",AxisName(Axis));		
    b3e2:	c7 01       	movw	r24, r14
    b3e4:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b3e8:	00 d0       	rcall	.+0      	; 0xb3ea <PMDCheckActivityStatus+0x24c>
    b3ea:	00 d0       	rcall	.+0      	; 0xb3ec <PMDCheckActivityStatus+0x24e>
    b3ec:	24 e9       	ldi	r18, 0x94	; 148
    b3ee:	30 e7       	ldi	r19, 0x70	; 112
    b3f0:	ad b7       	in	r26, 0x3d	; 61
    b3f2:	be b7       	in	r27, 0x3e	; 62
    b3f4:	12 96       	adiw	r26, 0x02	; 2
    b3f6:	3c 93       	st	X, r19
    b3f8:	2e 93       	st	-X, r18
    b3fa:	11 97       	sbiw	r26, 0x01	; 1
    b3fc:	14 96       	adiw	r26, 0x04	; 4
    b3fe:	9c 93       	st	X, r25
    b400:	8e 93       	st	-X, r24
    b402:	13 97       	sbiw	r26, 0x03	; 3
    b404:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b408:	0f 90       	pop	r0
    b40a:	0f 90       	pop	r0
    b40c:	0f 90       	pop	r0
    b40e:	0f 90       	pop	r0
		if ((status &  PMDActivityInNegativeLimitMask) !=0) 
    b410:	89 81       	ldd	r24, Y+1	; 0x01
    b412:	9a 81       	ldd	r25, Y+2	; 0x02
    b414:	94 ff       	sbrs	r25, 4
    b416:	13 c0       	rjmp	.+38     	; 0xb43e <PMDCheckActivityStatus+0x2a0>
			printf("PMDCheckActivityStatus=> El eje %s  esta en el Limite Negativo \n",AxisName(Axis));
    b418:	c7 01       	movw	r24, r14
    b41a:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b41e:	00 d0       	rcall	.+0      	; 0xb420 <PMDCheckActivityStatus+0x282>
    b420:	00 d0       	rcall	.+0      	; 0xb422 <PMDCheckActivityStatus+0x284>
    b422:	25 ed       	ldi	r18, 0xD5	; 213
    b424:	30 e7       	ldi	r19, 0x70	; 112
    b426:	ed b7       	in	r30, 0x3d	; 61
    b428:	fe b7       	in	r31, 0x3e	; 62
    b42a:	32 83       	std	Z+2, r19	; 0x02
    b42c:	21 83       	std	Z+1, r18	; 0x01
    b42e:	94 83       	std	Z+4, r25	; 0x04
    b430:	83 83       	std	Z+3, r24	; 0x03
    b432:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b436:	0f 90       	pop	r0
    b438:	0f 90       	pop	r0
    b43a:	0f 90       	pop	r0
    b43c:	0f 90       	pop	r0
	}

	return status;
}
    b43e:	89 81       	ldd	r24, Y+1	; 0x01
    b440:	9a 81       	ldd	r25, Y+2	; 0x02
    b442:	0f 90       	pop	r0
    b444:	0f 90       	pop	r0
    b446:	cf 91       	pop	r28
    b448:	df 91       	pop	r29
    b44a:	1f 91       	pop	r17
    b44c:	0f 91       	pop	r16
    b44e:	ff 90       	pop	r15
    b450:	ef 90       	pop	r14
    b452:	08 95       	ret

0000b454 <PMDCheckEventStatus>:
extern PMDAxisHandle hAxis[DOF]; 

//**********************************************************************************************

PMDresult PMDCheckEventStatus(int16 Axis, PMDint16 print)  
{
    b454:	cf 92       	push	r12
    b456:	df 92       	push	r13
    b458:	ef 92       	push	r14
    b45a:	ff 92       	push	r15
    b45c:	0f 93       	push	r16
    b45e:	1f 93       	push	r17
    b460:	df 93       	push	r29
    b462:	cf 93       	push	r28
    b464:	00 d0       	rcall	.+0      	; 0xb466 <PMDCheckEventStatus+0x12>
    b466:	cd b7       	in	r28, 0x3d	; 61
    b468:	de b7       	in	r29, 0x3e	; 62
    b46a:	6c 01       	movw	r12, r24
    b46c:	7b 01       	movw	r14, r22
	PMDuint16 status;	
	
	PMDGetEventStatus(&hAxis[Axis],&status);
    b46e:	80 e6       	ldi	r24, 0x60	; 96
    b470:	90 e0       	ldi	r25, 0x00	; 0
    b472:	c8 9e       	mul	r12, r24
    b474:	80 01       	movw	r16, r0
    b476:	c9 9e       	mul	r12, r25
    b478:	10 0d       	add	r17, r0
    b47a:	d8 9e       	mul	r13, r24
    b47c:	10 0d       	add	r17, r0
    b47e:	11 24       	eor	r1, r1
    b480:	0c 58       	subi	r16, 0x8C	; 140
    b482:	12 48       	sbci	r17, 0x82	; 130
    b484:	c8 01       	movw	r24, r16
    b486:	be 01       	movw	r22, r28
    b488:	6f 5f       	subi	r22, 0xFF	; 255
    b48a:	7f 4f       	sbci	r23, 0xFF	; 255
    b48c:	0e 94 a7 61 	call	0xc34e	; 0xc34e <PMDGetEventStatus>
	//Se limpia el Event Status Register
	PMDResetEventStatus(&hAxis[Axis],~PMDEventStatusMask);
    b490:	c8 01       	movw	r24, r16
    b492:	60 e0       	ldi	r22, 0x00	; 0
    b494:	77 eb       	ldi	r23, 0xB7	; 183
    b496:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
		
	printf("PMDCheckEventStatus=> El Event Status del eje %s es %X \n",AxisName(Axis),status);
    b49a:	c6 01       	movw	r24, r12
    b49c:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b4a0:	00 d0       	rcall	.+0      	; 0xb4a2 <PMDCheckEventStatus+0x4e>
    b4a2:	00 d0       	rcall	.+0      	; 0xb4a4 <PMDCheckEventStatus+0x50>
    b4a4:	00 d0       	rcall	.+0      	; 0xb4a6 <PMDCheckEventStatus+0x52>
    b4a6:	ed b7       	in	r30, 0x3d	; 61
    b4a8:	fe b7       	in	r31, 0x3e	; 62
    b4aa:	31 96       	adiw	r30, 0x01	; 1
    b4ac:	26 e1       	ldi	r18, 0x16	; 22
    b4ae:	31 e7       	ldi	r19, 0x71	; 113
    b4b0:	ad b7       	in	r26, 0x3d	; 61
    b4b2:	be b7       	in	r27, 0x3e	; 62
    b4b4:	12 96       	adiw	r26, 0x02	; 2
    b4b6:	3c 93       	st	X, r19
    b4b8:	2e 93       	st	-X, r18
    b4ba:	11 97       	sbiw	r26, 0x01	; 1
    b4bc:	93 83       	std	Z+3, r25	; 0x03
    b4be:	82 83       	std	Z+2, r24	; 0x02
    b4c0:	89 81       	ldd	r24, Y+1	; 0x01
    b4c2:	9a 81       	ldd	r25, Y+2	; 0x02
    b4c4:	95 83       	std	Z+5, r25	; 0x05
    b4c6:	84 83       	std	Z+4, r24	; 0x04
    b4c8:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	
	if(print==imprimir)
    b4cc:	ed b7       	in	r30, 0x3d	; 61
    b4ce:	fe b7       	in	r31, 0x3e	; 62
    b4d0:	36 96       	adiw	r30, 0x06	; 6
    b4d2:	0f b6       	in	r0, 0x3f	; 63
    b4d4:	f8 94       	cli
    b4d6:	fe bf       	out	0x3e, r31	; 62
    b4d8:	0f be       	out	0x3f, r0	; 63
    b4da:	ed bf       	out	0x3d, r30	; 61
    b4dc:	fe ee       	ldi	r31, 0xEE	; 238
    b4de:	ef 16       	cp	r14, r31
    b4e0:	ff ef       	ldi	r31, 0xFF	; 255
    b4e2:	ff 06       	cpc	r15, r31
    b4e4:	09 f0       	breq	.+2      	; 0xb4e8 <PMDCheckEventStatus+0x94>
    b4e6:	f2 c0       	rjmp	.+484    	; 0xb6cc <PMDCheckEventStatus+0x278>
	{
    
		
		if ((status & PMDEventMotionCompleteMask) !=0) //Este eje est en movimiento		
    b4e8:	89 81       	ldd	r24, Y+1	; 0x01
    b4ea:	80 ff       	sbrs	r24, 0
    b4ec:	17 c0       	rjmp	.+46     	; 0xb51c <PMDCheckEventStatus+0xc8>
			printf("PMDCheckEventStatus=> El movimiento  en el eje %s ha sido completado\n",AxisName(Axis));
    b4ee:	c6 01       	movw	r24, r12
    b4f0:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b4f4:	00 d0       	rcall	.+0      	; 0xb4f6 <PMDCheckEventStatus+0xa2>
    b4f6:	00 d0       	rcall	.+0      	; 0xb4f8 <PMDCheckEventStatus+0xa4>
    b4f8:	2f e4       	ldi	r18, 0x4F	; 79
    b4fa:	31 e7       	ldi	r19, 0x71	; 113
    b4fc:	ad b7       	in	r26, 0x3d	; 61
    b4fe:	be b7       	in	r27, 0x3e	; 62
    b500:	12 96       	adiw	r26, 0x02	; 2
    b502:	3c 93       	st	X, r19
    b504:	2e 93       	st	-X, r18
    b506:	11 97       	sbiw	r26, 0x01	; 1
    b508:	14 96       	adiw	r26, 0x04	; 4
    b50a:	9c 93       	st	X, r25
    b50c:	8e 93       	st	-X, r24
    b50e:	13 97       	sbiw	r26, 0x03	; 3
    b510:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b514:	0f 90       	pop	r0
    b516:	0f 90       	pop	r0
    b518:	0f 90       	pop	r0
    b51a:	0f 90       	pop	r0
		
		
		if ((status & PMDEventWrapAroundMask) !=0 ) 
    b51c:	89 81       	ldd	r24, Y+1	; 0x01
    b51e:	81 ff       	sbrs	r24, 1
    b520:	13 c0       	rjmp	.+38     	; 0xb548 <PMDCheckEventStatus+0xf4>
			printf("PMDCheckEventStatus=> Desborde en la posicion actual del motor 7FFFFFFF O 80000000 eje %s \n",AxisName(Axis));
    b522:	c6 01       	movw	r24, r12
    b524:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b528:	00 d0       	rcall	.+0      	; 0xb52a <PMDCheckEventStatus+0xd6>
    b52a:	00 d0       	rcall	.+0      	; 0xb52c <PMDCheckEventStatus+0xd8>
    b52c:	25 e9       	ldi	r18, 0x95	; 149
    b52e:	31 e7       	ldi	r19, 0x71	; 113
    b530:	ed b7       	in	r30, 0x3d	; 61
    b532:	fe b7       	in	r31, 0x3e	; 62
    b534:	32 83       	std	Z+2, r19	; 0x02
    b536:	21 83       	std	Z+1, r18	; 0x01
    b538:	94 83       	std	Z+4, r25	; 0x04
    b53a:	83 83       	std	Z+3, r24	; 0x03
    b53c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b540:	0f 90       	pop	r0
    b542:	0f 90       	pop	r0
    b544:	0f 90       	pop	r0
    b546:	0f 90       	pop	r0
	 
		//Se ha activado el Breakpoint 1
		if ((status & PMDEventBreakpoint1Mask) !=0) 
    b548:	89 81       	ldd	r24, Y+1	; 0x01
    b54a:	82 ff       	sbrs	r24, 2
    b54c:	17 c0       	rjmp	.+46     	; 0xb57c <PMDCheckEventStatus+0x128>
			printf("PMDCheckEventStatus=> Se ha activado el Breakpoint 1 en el eje %s \n",AxisName(Axis));
    b54e:	c6 01       	movw	r24, r12
    b550:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b554:	00 d0       	rcall	.+0      	; 0xb556 <PMDCheckEventStatus+0x102>
    b556:	00 d0       	rcall	.+0      	; 0xb558 <PMDCheckEventStatus+0x104>
    b558:	21 ef       	ldi	r18, 0xF1	; 241
    b55a:	31 e7       	ldi	r19, 0x71	; 113
    b55c:	ad b7       	in	r26, 0x3d	; 61
    b55e:	be b7       	in	r27, 0x3e	; 62
    b560:	12 96       	adiw	r26, 0x02	; 2
    b562:	3c 93       	st	X, r19
    b564:	2e 93       	st	-X, r18
    b566:	11 97       	sbiw	r26, 0x01	; 1
    b568:	14 96       	adiw	r26, 0x04	; 4
    b56a:	9c 93       	st	X, r25
    b56c:	8e 93       	st	-X, r24
    b56e:	13 97       	sbiw	r26, 0x03	; 3
    b570:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b574:	0f 90       	pop	r0
    b576:	0f 90       	pop	r0
    b578:	0f 90       	pop	r0
    b57a:	0f 90       	pop	r0
		
		//Se activa cuando el hardware de alta velocidad actura un nuevo dato de posicion
		if ((status & PMDEventCaptureReceivedMask) !=0) 
    b57c:	89 81       	ldd	r24, Y+1	; 0x01
    b57e:	83 ff       	sbrs	r24, 3
    b580:	13 c0       	rjmp	.+38     	; 0xb5a8 <PMDCheckEventStatus+0x154>
			printf("PMDCheckEventStatus=> El Hardware de alta velocidad ha capturado una nueva posicion del eje %s \n",AxisName(Axis));
    b582:	c6 01       	movw	r24, r12
    b584:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b588:	00 d0       	rcall	.+0      	; 0xb58a <PMDCheckEventStatus+0x136>
    b58a:	00 d0       	rcall	.+0      	; 0xb58c <PMDCheckEventStatus+0x138>
    b58c:	25 e3       	ldi	r18, 0x35	; 53
    b58e:	32 e7       	ldi	r19, 0x72	; 114
    b590:	ed b7       	in	r30, 0x3d	; 61
    b592:	fe b7       	in	r31, 0x3e	; 62
    b594:	32 83       	std	Z+2, r19	; 0x02
    b596:	21 83       	std	Z+1, r18	; 0x01
    b598:	94 83       	std	Z+4, r25	; 0x04
    b59a:	83 83       	std	Z+3, r24	; 0x03
    b59c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b5a0:	0f 90       	pop	r0
    b5a2:	0f 90       	pop	r0
    b5a4:	0f 90       	pop	r0
    b5a6:	0f 90       	pop	r0
			
		//Cuando la posicion Actual difiere de la posicion commandada por una cantidad mayor 
		//que la expecificada por el maximo error de posicion
		if ((status & PMDEventMotionErrorMask)!=0) 
    b5a8:	89 81       	ldd	r24, Y+1	; 0x01
    b5aa:	84 ff       	sbrs	r24, 4
    b5ac:	17 c0       	rjmp	.+46     	; 0xb5dc <PMDCheckEventStatus+0x188>
			printf("PMDCheckEventStatus=> El error del movimiento excede el limite maximo de error para el eje %s \n",AxisName(Axis));
    b5ae:	c6 01       	movw	r24, r12
    b5b0:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b5b4:	00 d0       	rcall	.+0      	; 0xb5b6 <PMDCheckEventStatus+0x162>
    b5b6:	00 d0       	rcall	.+0      	; 0xb5b8 <PMDCheckEventStatus+0x164>
    b5b8:	26 e9       	ldi	r18, 0x96	; 150
    b5ba:	32 e7       	ldi	r19, 0x72	; 114
    b5bc:	ad b7       	in	r26, 0x3d	; 61
    b5be:	be b7       	in	r27, 0x3e	; 62
    b5c0:	12 96       	adiw	r26, 0x02	; 2
    b5c2:	3c 93       	st	X, r19
    b5c4:	2e 93       	st	-X, r18
    b5c6:	11 97       	sbiw	r26, 0x01	; 1
    b5c8:	14 96       	adiw	r26, 0x04	; 4
    b5ca:	9c 93       	st	X, r25
    b5cc:	8e 93       	st	-X, r24
    b5ce:	13 97       	sbiw	r26, 0x03	; 3
    b5d0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b5d4:	0f 90       	pop	r0
    b5d6:	0f 90       	pop	r0
    b5d8:	0f 90       	pop	r0
    b5da:	0f 90       	pop	r0
		
		//Se llego al limite positivo
		if ((status & PMDEventInPositiveLimitMask) !=0) 
    b5dc:	89 81       	ldd	r24, Y+1	; 0x01
    b5de:	85 ff       	sbrs	r24, 5
    b5e0:	13 c0       	rjmp	.+38     	; 0xb608 <PMDCheckEventStatus+0x1b4>
			printf("PMDCheckEventStatus=> Se ha llegado al limite Positivo en el eje %s\n",AxisName(Axis));
    b5e2:	c6 01       	movw	r24, r12
    b5e4:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b5e8:	00 d0       	rcall	.+0      	; 0xb5ea <PMDCheckEventStatus+0x196>
    b5ea:	00 d0       	rcall	.+0      	; 0xb5ec <PMDCheckEventStatus+0x198>
    b5ec:	26 ef       	ldi	r18, 0xF6	; 246
    b5ee:	32 e7       	ldi	r19, 0x72	; 114
    b5f0:	ed b7       	in	r30, 0x3d	; 61
    b5f2:	fe b7       	in	r31, 0x3e	; 62
    b5f4:	32 83       	std	Z+2, r19	; 0x02
    b5f6:	21 83       	std	Z+1, r18	; 0x01
    b5f8:	94 83       	std	Z+4, r25	; 0x04
    b5fa:	83 83       	std	Z+3, r24	; 0x03
    b5fc:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b600:	0f 90       	pop	r0
    b602:	0f 90       	pop	r0
    b604:	0f 90       	pop	r0
    b606:	0f 90       	pop	r0
		
		//Se llego al limite negativo
		if ((status & PMDEventInNegativeLimitMask) !=0 ) 
    b608:	89 81       	ldd	r24, Y+1	; 0x01
    b60a:	86 ff       	sbrs	r24, 6
    b60c:	17 c0       	rjmp	.+46     	; 0xb63c <PMDCheckEventStatus+0x1e8>
			printf("PMDCheckEventStatus=> Se ha llegado al limite negativo en el eje %s\n",AxisName(Axis));
    b60e:	c6 01       	movw	r24, r12
    b610:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b614:	00 d0       	rcall	.+0      	; 0xb616 <PMDCheckEventStatus+0x1c2>
    b616:	00 d0       	rcall	.+0      	; 0xb618 <PMDCheckEventStatus+0x1c4>
    b618:	2b e3       	ldi	r18, 0x3B	; 59
    b61a:	33 e7       	ldi	r19, 0x73	; 115
    b61c:	ad b7       	in	r26, 0x3d	; 61
    b61e:	be b7       	in	r27, 0x3e	; 62
    b620:	12 96       	adiw	r26, 0x02	; 2
    b622:	3c 93       	st	X, r19
    b624:	2e 93       	st	-X, r18
    b626:	11 97       	sbiw	r26, 0x01	; 1
    b628:	14 96       	adiw	r26, 0x04	; 4
    b62a:	9c 93       	st	X, r25
    b62c:	8e 93       	st	-X, r24
    b62e:	13 97       	sbiw	r26, 0x03	; 3
    b630:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b634:	0f 90       	pop	r0
    b636:	0f 90       	pop	r0
    b638:	0f 90       	pop	r0
    b63a:	0f 90       	pop	r0
			
		//Error de instruccion
		if ((status & PMDEventInstructionErrorMask) !=0) 
    b63c:	89 81       	ldd	r24, Y+1	; 0x01
    b63e:	87 ff       	sbrs	r24, 7
    b640:	13 c0       	rjmp	.+38     	; 0xb668 <PMDCheckEventStatus+0x214>
			printf("PMDCheckEventStatus=> Ha ocurrido un error de Instruccion en el eje %s \n",AxisName(Axis));
    b642:	c6 01       	movw	r24, r12
    b644:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b648:	00 d0       	rcall	.+0      	; 0xb64a <PMDCheckEventStatus+0x1f6>
    b64a:	00 d0       	rcall	.+0      	; 0xb64c <PMDCheckEventStatus+0x1f8>
    b64c:	20 e8       	ldi	r18, 0x80	; 128
    b64e:	33 e7       	ldi	r19, 0x73	; 115
    b650:	ed b7       	in	r30, 0x3d	; 61
    b652:	fe b7       	in	r31, 0x3e	; 62
    b654:	32 83       	std	Z+2, r19	; 0x02
    b656:	21 83       	std	Z+1, r18	; 0x01
    b658:	94 83       	std	Z+4, r25	; 0x04
    b65a:	83 83       	std	Z+3, r24	; 0x03
    b65c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b660:	0f 90       	pop	r0
    b662:	0f 90       	pop	r0
    b664:	0f 90       	pop	r0
    b666:	0f 90       	pop	r0
		
		//Error de la comunicacion solo para (MC2300)
		if ((status & PMDEventCommutationErrorMask) !=0) 
    b668:	89 81       	ldd	r24, Y+1	; 0x01
    b66a:	9a 81       	ldd	r25, Y+2	; 0x02
    b66c:	93 ff       	sbrs	r25, 3
    b66e:	17 c0       	rjmp	.+46     	; 0xb69e <PMDCheckEventStatus+0x24a>
			printf("PMDCheckEventStatus=> Error de comunicacion solo para MC2300 en el eje %s \n",AxisName(Axis));
    b670:	c6 01       	movw	r24, r12
    b672:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b676:	00 d0       	rcall	.+0      	; 0xb678 <PMDCheckEventStatus+0x224>
    b678:	00 d0       	rcall	.+0      	; 0xb67a <PMDCheckEventStatus+0x226>
    b67a:	29 ec       	ldi	r18, 0xC9	; 201
    b67c:	33 e7       	ldi	r19, 0x73	; 115
    b67e:	ad b7       	in	r26, 0x3d	; 61
    b680:	be b7       	in	r27, 0x3e	; 62
    b682:	12 96       	adiw	r26, 0x02	; 2
    b684:	3c 93       	st	X, r19
    b686:	2e 93       	st	-X, r18
    b688:	11 97       	sbiw	r26, 0x01	; 1
    b68a:	14 96       	adiw	r26, 0x04	; 4
    b68c:	9c 93       	st	X, r25
    b68e:	8e 93       	st	-X, r24
    b690:	13 97       	sbiw	r26, 0x03	; 3
    b692:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b696:	0f 90       	pop	r0
    b698:	0f 90       	pop	r0
    b69a:	0f 90       	pop	r0
    b69c:	0f 90       	pop	r0
		
		//Se ha activado el Breakpoint 2
		if ((status & PMDEventBreakpoint2Mask) !=0) 
    b69e:	89 81       	ldd	r24, Y+1	; 0x01
    b6a0:	9a 81       	ldd	r25, Y+2	; 0x02
    b6a2:	96 ff       	sbrs	r25, 6
    b6a4:	13 c0       	rjmp	.+38     	; 0xb6cc <PMDCheckEventStatus+0x278>
			printf("PMDCheckEventStatus=> Se ha activado del Breakpoint2 en el eje %s \n",AxisName(Axis));
    b6a6:	c6 01       	movw	r24, r12
    b6a8:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b6ac:	00 d0       	rcall	.+0      	; 0xb6ae <PMDCheckEventStatus+0x25a>
    b6ae:	00 d0       	rcall	.+0      	; 0xb6b0 <PMDCheckEventStatus+0x25c>
    b6b0:	25 e1       	ldi	r18, 0x15	; 21
    b6b2:	34 e7       	ldi	r19, 0x74	; 116
    b6b4:	ed b7       	in	r30, 0x3d	; 61
    b6b6:	fe b7       	in	r31, 0x3e	; 62
    b6b8:	32 83       	std	Z+2, r19	; 0x02
    b6ba:	21 83       	std	Z+1, r18	; 0x01
    b6bc:	94 83       	std	Z+4, r25	; 0x04
    b6be:	83 83       	std	Z+3, r24	; 0x03
    b6c0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    b6c4:	0f 90       	pop	r0
    b6c6:	0f 90       	pop	r0
    b6c8:	0f 90       	pop	r0
    b6ca:	0f 90       	pop	r0
	}	
	
	return status;
  
}
    b6cc:	89 81       	ldd	r24, Y+1	; 0x01
    b6ce:	9a 81       	ldd	r25, Y+2	; 0x02
    b6d0:	0f 90       	pop	r0
    b6d2:	0f 90       	pop	r0
    b6d4:	cf 91       	pop	r28
    b6d6:	df 91       	pop	r29
    b6d8:	1f 91       	pop	r17
    b6da:	0f 91       	pop	r16
    b6dc:	ff 90       	pop	r15
    b6de:	ef 90       	pop	r14
    b6e0:	df 90       	pop	r13
    b6e2:	cf 90       	pop	r12
    b6e4:	08 95       	ret

0000b6e6 <InstructionErrorhandling>:
	
}

/*****************************************************************************************/
void InstructionErrorhandling(tAxis Axis)
{
    b6e6:	0f 93       	push	r16
    b6e8:	1f 93       	push	r17
    b6ea:	8c 01       	movw	r16, r24
	
	
	/* Imprimir mensajes de Error*/	
	printf("Negativehandling=> El eje de %s Produjo un Error de Instruccion \n", AxisName(Axis));
    b6ec:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    b6f0:	00 d0       	rcall	.+0      	; 0xb6f2 <InstructionErrorhandling+0xc>
    b6f2:	00 d0       	rcall	.+0      	; 0xb6f4 <InstructionErrorhandling+0xe>
    b6f4:	29 e5       	ldi	r18, 0x59	; 89
    b6f6:	34 e7       	ldi	r19, 0x74	; 116
    b6f8:	ed b7       	in	r30, 0x3d	; 61
    b6fa:	fe b7       	in	r31, 0x3e	; 62
    b6fc:	32 83       	std	Z+2, r19	; 0x02
    b6fe:	21 83       	std	Z+1, r18	; 0x01
    b700:	94 83       	std	Z+4, r25	; 0x04
    b702:	83 83       	std	Z+3, r24	; 0x03
    b704:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	fprintf_P(stderr,PSTR("Error de Instruccion \n"));
    b708:	80 91 33 82 	lds	r24, 0x8233
    b70c:	90 91 34 82 	lds	r25, 0x8234
    b710:	ed b7       	in	r30, 0x3d	; 61
    b712:	fe b7       	in	r31, 0x3e	; 62
    b714:	92 83       	std	Z+2, r25	; 0x02
    b716:	81 83       	std	Z+1, r24	; 0x01
    b718:	8b ec       	ldi	r24, 0xCB	; 203
    b71a:	94 e0       	ldi	r25, 0x04	; 4
    b71c:	94 83       	std	Z+4, r25	; 0x04
    b71e:	83 83       	std	Z+3, r24	; 0x03
    b720:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
	/* se enciende el LED Rojo*/
	Led_on(Rojo);
    b724:	0f 90       	pop	r0
    b726:	0f 90       	pop	r0
    b728:	0f 90       	pop	r0
    b72a:	0f 90       	pop	r0
    b72c:	81 e0       	ldi	r24, 0x01	; 1
    b72e:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
	
	
	
	/*Se limpia el Event Status Register, borrando la interrupcion 	*/	
	PMDResetEventStatus(&hAxis[Axis],~PMDEventInstructionErrorMask);
    b732:	80 e6       	ldi	r24, 0x60	; 96
    b734:	90 e0       	ldi	r25, 0x00	; 0
    b736:	9c 01       	movw	r18, r24
    b738:	02 9f       	mul	r16, r18
    b73a:	c0 01       	movw	r24, r0
    b73c:	03 9f       	mul	r16, r19
    b73e:	90 0d       	add	r25, r0
    b740:	12 9f       	mul	r17, r18
    b742:	90 0d       	add	r25, r0
    b744:	11 24       	eor	r1, r1
    b746:	8c 58       	subi	r24, 0x8C	; 140
    b748:	92 48       	sbci	r25, 0x82	; 130
    b74a:	6f e7       	ldi	r22, 0x7F	; 127
    b74c:	7f ef       	ldi	r23, 0xFF	; 255
    b74e:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
	
	
	
}
    b752:	1f 91       	pop	r17
    b754:	0f 91       	pop	r16
    b756:	08 95       	ret

0000b758 <MotionCompletehandling>:
}

/*****************************************************************************************/
//Funcion NO UTILIZADA
void MotionCompletehandling(tAxis Axis)
{
    b758:	cf 93       	push	r28
    b75a:	df 93       	push	r29
    b75c:	ec 01       	movw	r28, r24
	printf("MotionCompletehandling=> El eje de %s ha completado el Movimiento \n", AxisName(Axis));
	#endif
	/*Se limpia el Event Status Register, borrando la interrupcion
	should clear the motion complete bit, enabling the bit to indicate 
	the end of motion for the next move*/	
	PMDResetEventStatus(&hAxis[Axis],~PMDEventMotionCompleteMask);
    b75e:	80 e6       	ldi	r24, 0x60	; 96
    b760:	90 e0       	ldi	r25, 0x00	; 0
    b762:	9c 01       	movw	r18, r24
    b764:	c2 9f       	mul	r28, r18
    b766:	c0 01       	movw	r24, r0
    b768:	c3 9f       	mul	r28, r19
    b76a:	90 0d       	add	r25, r0
    b76c:	d2 9f       	mul	r29, r18
    b76e:	90 0d       	add	r25, r0
    b770:	11 24       	eor	r1, r1
    b772:	8c 58       	subi	r24, 0x8C	; 140
    b774:	92 48       	sbci	r25, 0x82	; 130
    b776:	6e ef       	ldi	r22, 0xFE	; 254
    b778:	7f ef       	ldi	r23, 0xFF	; 255
    b77a:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
	
	if(Axis==AxisPitch)
    b77e:	c3 30       	cpi	r28, 0x03	; 3
    b780:	d1 05       	cpc	r29, r1
    b782:	19 f4       	brne	.+6      	; 0xb78a <MotionCompletehandling+0x32>
	{	
		PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventMotionCompleteMask);		
    b784:	84 ef       	ldi	r24, 0xF4	; 244
    b786:	9e e7       	ldi	r25, 0x7E	; 126
    b788:	04 c0       	rjmp	.+8      	; 0xb792 <MotionCompletehandling+0x3a>
	}
	
	if(Axis==AxisRoll)
    b78a:	24 97       	sbiw	r28, 0x04	; 4
    b78c:	31 f4       	brne	.+12     	; 0xb79a <MotionCompletehandling+0x42>
	{	
		PMDResetEventStatus(&hAxis[AxisPitch],~PMDEventMotionCompleteMask);		
    b78e:	84 e9       	ldi	r24, 0x94	; 148
    b790:	9e e7       	ldi	r25, 0x7E	; 126
    b792:	6e ef       	ldi	r22, 0xFE	; 254
    b794:	7f ef       	ldi	r23, 0xFF	; 255
    b796:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
	}
	
}
    b79a:	df 91       	pop	r29
    b79c:	cf 91       	pop	r28
    b79e:	08 95       	ret

0000b7a0 <Negativehandling>:
	
}

/*****************************************************************************************/
void Negativehandling(tAxis Axis)
{
    b7a0:	6f 92       	push	r6
    b7a2:	7f 92       	push	r7
    b7a4:	8f 92       	push	r8
    b7a6:	9f 92       	push	r9
    b7a8:	af 92       	push	r10
    b7aa:	bf 92       	push	r11
    b7ac:	cf 92       	push	r12
    b7ae:	df 92       	push	r13
    b7b0:	ef 92       	push	r14
    b7b2:	ff 92       	push	r15
    b7b4:	0f 93       	push	r16
    b7b6:	1f 93       	push	r17
    b7b8:	df 93       	push	r29
    b7ba:	cf 93       	push	r28
    b7bc:	00 d0       	rcall	.+0      	; 0xb7be <Negativehandling+0x1e>
    b7be:	00 d0       	rcall	.+0      	; 0xb7c0 <Negativehandling+0x20>
    b7c0:	00 d0       	rcall	.+0      	; 0xb7c2 <Negativehandling+0x22>
    b7c2:	cd b7       	in	r28, 0x3d	; 61
    b7c4:	de b7       	in	r29, 0x3e	; 62
    b7c6:	3c 01       	movw	r6, r24
	#endif
	//fprintf_P(stderr,PSTR("Se produjo un Evento de Limite Negativo \n"));


	/*Salvar el Perfil de Velocidad para no alterarlo.*/
	PMDGetProfileMode(&hAxis[Axis],&Profile);
    b7c8:	80 e6       	ldi	r24, 0x60	; 96
    b7ca:	90 e0       	ldi	r25, 0x00	; 0
    b7cc:	68 9e       	mul	r6, r24
    b7ce:	40 01       	movw	r8, r0
    b7d0:	69 9e       	mul	r6, r25
    b7d2:	90 0c       	add	r9, r0
    b7d4:	78 9e       	mul	r7, r24
    b7d6:	90 0c       	add	r9, r0
    b7d8:	11 24       	eor	r1, r1
    b7da:	84 e7       	ldi	r24, 0x74	; 116
    b7dc:	9d e7       	ldi	r25, 0x7D	; 125
    b7de:	88 0e       	add	r8, r24
    b7e0:	99 1e       	adc	r9, r25
    b7e2:	c4 01       	movw	r24, r8
    b7e4:	be 01       	movw	r22, r28
    b7e6:	6d 5f       	subi	r22, 0xFD	; 253
    b7e8:	7f 4f       	sbci	r23, 0xFF	; 255
    b7ea:	0e 94 4b 62 	call	0xc496	; 0xc496 <PMDGetProfileMode>
	The limit switch bit(s) in the event status register should be cleared
	by issuing the ResetEventStatus command. No motion is possible in any 
	direction while either of the limit switch bits in the event status register
	is set.*/
	
	PMDResetEventStatus(&hAxis[Axis],~PMDEventInNegativeLimitMask);		
    b7ee:	c4 01       	movw	r24, r8
    b7f0:	6f eb       	ldi	r22, 0xBF	; 191
    b7f2:	7f ef       	ldi	r23, 0xFF	; 255
    b7f4:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
		
	//-----Mover el eje en la direccion opuesta del Lmite Negativo.
		
	switch (Axis)
    b7f8:	93 e0       	ldi	r25, 0x03	; 3
    b7fa:	69 16       	cp	r6, r25
    b7fc:	71 04       	cpc	r7, r1
    b7fe:	31 f0       	breq	.+12     	; 0xb80c <Negativehandling+0x6c>
    b800:	84 e0       	ldi	r24, 0x04	; 4
    b802:	68 16       	cp	r6, r24
    b804:	71 04       	cpc	r7, r1
    b806:	09 f0       	breq	.+2      	; 0xb80a <Negativehandling+0x6a>
    b808:	42 c0       	rjmp	.+132    	; 0xb88e <Negativehandling+0xee>
    b80a:	64 c0       	rjmp	.+200    	; 0xb8d4 <Negativehandling+0x134>
	{
		case (AxisPitch):
				
			/*Si se produce un evento de limite negativo en el eje de pitch
			entonces el eje roll producira un evento de Limite Positivo.*/				
			PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventInPositiveLimitMask);	
    b80c:	84 ef       	ldi	r24, 0xF4	; 244
    b80e:	9e e7       	ldi	r25, 0x7E	; 126
    b810:	6f ed       	ldi	r22, 0xDF	; 223
    b812:	7f ef       	ldi	r23, 0xFF	; 255
    b814:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
				
			/*Se realiza un movimiento de pitch en la direccion positiva*/			
			PMDGetProfileMode(&hAxis[AxisRoll],&Profile_roll);
    b818:	84 ef       	ldi	r24, 0xF4	; 244
    b81a:	9e e7       	ldi	r25, 0x7E	; 126
    b81c:	be 01       	movw	r22, r28
    b81e:	6b 5f       	subi	r22, 0xFB	; 251
    b820:	7f 4f       	sbci	r23, 0xFF	; 255
    b822:	0e 94 4b 62 	call	0xc496	; 0xc496 <PMDGetProfileMode>
			PMDSetProfileMode(&hAxis[Axis],  PMDVelocityContouringProfile ); 
    b826:	c4 01       	movw	r24, r8
    b828:	61 e0       	ldi	r22, 0x01	; 1
    b82a:	70 e0       	ldi	r23, 0x00	; 0
    b82c:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
			PMDSetProfileMode(&hAxis[AxisRoll],  PMDVelocityContouringProfile ); 
    b830:	84 ef       	ldi	r24, 0xF4	; 244
    b832:	9e e7       	ldi	r25, 0x7E	; 126
    b834:	61 e0       	ldi	r22, 0x01	; 1
    b836:	70 e0       	ldi	r23, 0x00	; 0
    b838:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
			PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  	
    b83c:	c4 01       	movw	r24, r8
    b83e:	61 e0       	ldi	r22, 0x01	; 1
    b840:	70 e0       	ldi	r23, 0x00	; 0
    b842:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 
    b846:	84 ef       	ldi	r24, 0xF4	; 244
    b848:	9e e7       	ldi	r25, 0x7E	; 126
    b84a:	61 e0       	ldi	r22, 0x01	; 1
    b84c:	70 e0       	ldi	r23, 0x00	; 0
    b84e:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
			pitch(none,hAxis[Axis].axisSettings.homeVelocity,
    b852:	20 91 d4 7e 	lds	r18, 0x7ED4
    b856:	30 91 d5 7e 	lds	r19, 0x7ED5
    b85a:	40 91 d6 7e 	lds	r20, 0x7ED6
    b85e:	50 91 d7 7e 	lds	r21, 0x7ED7
    b862:	e0 90 d8 7e 	lds	r14, 0x7ED8
    b866:	f0 90 d9 7e 	lds	r15, 0x7ED9
    b86a:	00 91 da 7e 	lds	r16, 0x7EDA
    b86e:	10 91 db 7e 	lds	r17, 0x7EDB
    b872:	61 ef       	ldi	r22, 0xF1	; 241
    b874:	7f ef       	ldi	r23, 0xFF	; 255
    b876:	8f ef       	ldi	r24, 0xFF	; 255
    b878:	9f ef       	ldi	r25, 0xFF	; 255
    b87a:	a0 ef       	ldi	r26, 0xF0	; 240
    b87c:	ca 2e       	mov	r12, r26
    b87e:	af ef       	ldi	r26, 0xFF	; 255
    b880:	da 2e       	mov	r13, r26
    b882:	f1 e0       	ldi	r31, 0x01	; 1
    b884:	af 2e       	mov	r10, r31
    b886:	b1 2c       	mov	r11, r1
    b888:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <pitch>
    b88c:	23 c0       	rjmp	.+70     	; 0xb8d4 <Negativehandling+0x134>
		break;
		case (AxisRoll):		
		break;
			
		default:
			PMDSetProfileMode(&hAxis[Axis],  PMDVelocityContouringProfile ); 
    b88e:	c4 01       	movw	r24, r8
    b890:	61 e0       	ldi	r22, 0x01	; 1
    b892:	70 e0       	ldi	r23, 0x00	; 0
    b894:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
			PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  				
    b898:	c4 01       	movw	r24, r8
    b89a:	61 e0       	ldi	r22, 0x01	; 1
    b89c:	70 e0       	ldi	r23, 0x00	; 0
    b89e:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
			mov_axis(Axis,none,hAxis[Axis].axisSettings.homeVelocity,
    b8a2:	f4 01       	movw	r30, r8
    b8a4:	e0 5c       	subi	r30, 0xC0	; 192
    b8a6:	ff 4f       	sbci	r31, 0xFF	; 255
    b8a8:	00 81       	ld	r16, Z
    b8aa:	11 81       	ldd	r17, Z+1	; 0x01
    b8ac:	22 81       	ldd	r18, Z+2	; 0x02
    b8ae:	33 81       	ldd	r19, Z+3	; 0x03
    b8b0:	f4 01       	movw	r30, r8
    b8b2:	ec 5b       	subi	r30, 0xBC	; 188
    b8b4:	ff 4f       	sbci	r31, 0xFF	; 255
    b8b6:	c0 80       	ld	r12, Z
    b8b8:	d1 80       	ldd	r13, Z+1	; 0x01
    b8ba:	e2 80       	ldd	r14, Z+2	; 0x02
    b8bc:	f3 80       	ldd	r15, Z+3	; 0x03
    b8be:	c3 01       	movw	r24, r6
    b8c0:	41 ef       	ldi	r20, 0xF1	; 241
    b8c2:	5f ef       	ldi	r21, 0xFF	; 255
    b8c4:	6f ef       	ldi	r22, 0xFF	; 255
    b8c6:	7f ef       	ldi	r23, 0xFF	; 255
    b8c8:	e0 ef       	ldi	r30, 0xF0	; 240
    b8ca:	ae 2e       	mov	r10, r30
    b8cc:	ef ef       	ldi	r30, 0xFF	; 255
    b8ce:	be 2e       	mov	r11, r30
    b8d0:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
				hAxis[Axis].axisSettings.homeAcceleration, update);	
		break;
	}		

	
	PMDGetSignalStatus(&hAxis[Axis], &signal_status);
    b8d4:	c4 01       	movw	r24, r8
    b8d6:	8e 01       	movw	r16, r28
    b8d8:	0f 5f       	subi	r16, 0xFF	; 255
    b8da:	1f 4f       	sbci	r17, 0xFF	; 255
    b8dc:	b8 01       	movw	r22, r16
    b8de:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
	
	do 
	{
		PMDGetSignalStatus(&hAxis[Axis], &signal_status);
    b8e2:	f0 2e       	mov	r15, r16
    b8e4:	01 2f       	mov	r16, r17
    b8e6:	c4 01       	movw	r24, r8
    b8e8:	6f 2d       	mov	r22, r15
    b8ea:	70 2f       	mov	r23, r16
    b8ec:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
		#ifdef DEBUGINTERRUPT
			printf("Negativehandling=> El Estado de la senal del Switch Negativo del eje %s es : %#X \n ",
					AxisName(Axis),mask);
		#endif
	} 
	while ((signal_status & PMDSignalNegativeLimitMask)==0);
    b8f0:	89 81       	ldd	r24, Y+1	; 0x01
    b8f2:	85 ff       	sbrs	r24, 5
    b8f4:	f8 cf       	rjmp	.-16     	; 0xb8e6 <Negativehandling+0x146>



	//---------------- Detener suavemente el movimiento.------------------------------	
	
	PMDSetStopMode(&hAxis[Axis], PMDSmoothStopMode ); 
    b8f6:	c4 01       	movw	r24, r8
    b8f8:	62 e0       	ldi	r22, 0x02	; 2
    b8fa:	70 e0       	ldi	r23, 0x00	; 0
    b8fc:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
	PMDUpdate(&hAxis[Axis]);
    b900:	c4 01       	movw	r24, r8
    b902:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
	
	if(Axis==AxisPitch)
    b906:	93 e0       	ldi	r25, 0x03	; 3
    b908:	69 16       	cp	r6, r25
    b90a:	71 04       	cpc	r7, r1
    b90c:	a1 f4       	brne	.+40     	; 0xb936 <Negativehandling+0x196>
	{
		PMDSetStopMode(&hAxis[AxisRoll], PMDSmoothStopMode ); 	//detiene el Motor de Roll
    b90e:	84 ef       	ldi	r24, 0xF4	; 244
    b910:	9e e7       	ldi	r25, 0x7E	; 126
    b912:	62 e0       	ldi	r22, 0x02	; 2
    b914:	70 e0       	ldi	r23, 0x00	; 0
    b916:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
		PMDUpdate(&hAxis[AxisRoll]);
    b91a:	84 ef       	ldi	r24, 0xF4	; 244
    b91c:	9e e7       	ldi	r25, 0x7E	; 126
    b91e:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
		PMDSetProfileMode(&hAxis[AxisRoll],Profile_roll);			//restaura el perfil de moviemiento de Roll
    b922:	6d 81       	ldd	r22, Y+5	; 0x05
    b924:	7e 81       	ldd	r23, Y+6	; 0x06
    b926:	84 ef       	ldi	r24, 0xF4	; 244
    b928:	9e e7       	ldi	r25, 0x7E	; 126
    b92a:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
		PMDUpdate(&hAxis[AxisRoll]);
    b92e:	84 ef       	ldi	r24, 0xF4	; 244
    b930:	9e e7       	ldi	r25, 0x7E	; 126
    b932:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
		
	}

	//Se restaura el Valor inicial del Perfil de la trayectoria.
	PMDSetProfileMode(&hAxis[Axis],Profile);
    b936:	6b 81       	ldd	r22, Y+3	; 0x03
    b938:	7c 81       	ldd	r23, Y+4	; 0x04
    b93a:	c4 01       	movw	r24, r8
    b93c:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
	PMDUpdate(&hAxis[Axis]);	
    b940:	c4 01       	movw	r24, r8
    b942:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
	
}
    b946:	26 96       	adiw	r28, 0x06	; 6
    b948:	0f b6       	in	r0, 0x3f	; 63
    b94a:	f8 94       	cli
    b94c:	de bf       	out	0x3e, r29	; 62
    b94e:	0f be       	out	0x3f, r0	; 63
    b950:	cd bf       	out	0x3d, r28	; 61
    b952:	cf 91       	pop	r28
    b954:	df 91       	pop	r29
    b956:	1f 91       	pop	r17
    b958:	0f 91       	pop	r16
    b95a:	ff 90       	pop	r15
    b95c:	ef 90       	pop	r14
    b95e:	df 90       	pop	r13
    b960:	cf 90       	pop	r12
    b962:	bf 90       	pop	r11
    b964:	af 90       	pop	r10
    b966:	9f 90       	pop	r9
    b968:	8f 90       	pop	r8
    b96a:	7f 90       	pop	r7
    b96c:	6f 90       	pop	r6
    b96e:	08 95       	ret

0000b970 <Positivehandling>:
	
}

/*****************************************************************************************/
void Positivehandling(tAxis Axis)
{
    b970:	6f 92       	push	r6
    b972:	7f 92       	push	r7
    b974:	8f 92       	push	r8
    b976:	9f 92       	push	r9
    b978:	af 92       	push	r10
    b97a:	bf 92       	push	r11
    b97c:	cf 92       	push	r12
    b97e:	df 92       	push	r13
    b980:	ef 92       	push	r14
    b982:	ff 92       	push	r15
    b984:	0f 93       	push	r16
    b986:	1f 93       	push	r17
    b988:	df 93       	push	r29
    b98a:	cf 93       	push	r28
    b98c:	00 d0       	rcall	.+0      	; 0xb98e <Positivehandling+0x1e>
    b98e:	00 d0       	rcall	.+0      	; 0xb990 <Positivehandling+0x20>
    b990:	00 d0       	rcall	.+0      	; 0xb992 <Positivehandling+0x22>
    b992:	cd b7       	in	r28, 0x3d	; 61
    b994:	de b7       	in	r29, 0x3e	; 62
    b996:	3c 01       	movw	r6, r24
	#endif
	
	//fprintf_P(stderr,PSTR("Se produjo un Evento de Limite Positivo \n"));
	
	/*Salvar el Perfil de Velocidad para no alterarlo.*/
	PMDGetProfileMode(&hAxis[Axis],&Profile);	
    b998:	80 e6       	ldi	r24, 0x60	; 96
    b99a:	90 e0       	ldi	r25, 0x00	; 0
    b99c:	68 9e       	mul	r6, r24
    b99e:	40 01       	movw	r8, r0
    b9a0:	69 9e       	mul	r6, r25
    b9a2:	90 0c       	add	r9, r0
    b9a4:	78 9e       	mul	r7, r24
    b9a6:	90 0c       	add	r9, r0
    b9a8:	11 24       	eor	r1, r1
    b9aa:	84 e7       	ldi	r24, 0x74	; 116
    b9ac:	9d e7       	ldi	r25, 0x7D	; 125
    b9ae:	88 0e       	add	r8, r24
    b9b0:	99 1e       	adc	r9, r25
    b9b2:	c4 01       	movw	r24, r8
    b9b4:	be 01       	movw	r22, r28
    b9b6:	6d 5f       	subi	r22, 0xFD	; 253
    b9b8:	7f 4f       	sbci	r23, 0xFF	; 255
    b9ba:	0e 94 4b 62 	call	0xc496	; 0xc496 <PMDGetProfileMode>
	The limit switch bit(s) in the event status register should be cleared
	by issuing the ResetEventStatus command. No motion is possible in any 
	direction while either of the limit switch bits in the event status register
	is set.*/
	
	PMDResetEventStatus(&hAxis[Axis],~PMDEventInPositiveLimitMask);		
    b9be:	c4 01       	movw	r24, r8
    b9c0:	6f ed       	ldi	r22, 0xDF	; 223
    b9c2:	7f ef       	ldi	r23, 0xFF	; 255
    b9c4:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
		
	// Mover el eje en la direccion opuesta del Lmite Positivo.
		
	switch (Axis)
    b9c8:	93 e0       	ldi	r25, 0x03	; 3
    b9ca:	69 16       	cp	r6, r25
    b9cc:	71 04       	cpc	r7, r1
    b9ce:	31 f0       	breq	.+12     	; 0xb9dc <Positivehandling+0x6c>
    b9d0:	84 e0       	ldi	r24, 0x04	; 4
    b9d2:	68 16       	cp	r6, r24
    b9d4:	71 04       	cpc	r7, r1
    b9d6:	09 f0       	breq	.+2      	; 0xb9da <Positivehandling+0x6a>
    b9d8:	49 c0       	rjmp	.+146    	; 0xba6c <Positivehandling+0xfc>
    b9da:	72 c0       	rjmp	.+228    	; 0xbac0 <Positivehandling+0x150>
	{
		case (AxisPitch):
		
			/*Si se produce un evento de limite positivo en el eje de pitch
			entonces el eje roll producira un evento de Limite Negativo.*/
			PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventInNegativeLimitMask);	
    b9dc:	84 ef       	ldi	r24, 0xF4	; 244
    b9de:	9e e7       	ldi	r25, 0x7E	; 126
    b9e0:	6f eb       	ldi	r22, 0xBF	; 191
    b9e2:	7f ef       	ldi	r23, 0xFF	; 255
    b9e4:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
				
			/*Se realiza un movimiento de pitch en la direccion negativa*/
			PMDGetProfileMode(&hAxis[AxisRoll],&Profile_roll);
    b9e8:	84 ef       	ldi	r24, 0xF4	; 244
    b9ea:	9e e7       	ldi	r25, 0x7E	; 126
    b9ec:	be 01       	movw	r22, r28
    b9ee:	6b 5f       	subi	r22, 0xFB	; 251
    b9f0:	7f 4f       	sbci	r23, 0xFF	; 255
    b9f2:	0e 94 4b 62 	call	0xc496	; 0xc496 <PMDGetProfileMode>
			PMDSetProfileMode(&hAxis[Axis],  PMDVelocityContouringProfile ); 
    b9f6:	c4 01       	movw	r24, r8
    b9f8:	61 e0       	ldi	r22, 0x01	; 1
    b9fa:	70 e0       	ldi	r23, 0x00	; 0
    b9fc:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
			PMDSetProfileMode(&hAxis[AxisRoll],  PMDVelocityContouringProfile ); 
    ba00:	84 ef       	ldi	r24, 0xF4	; 244
    ba02:	9e e7       	ldi	r25, 0x7E	; 126
    ba04:	61 e0       	ldi	r22, 0x01	; 1
    ba06:	70 e0       	ldi	r23, 0x00	; 0
    ba08:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
			PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  	
    ba0c:	c4 01       	movw	r24, r8
    ba0e:	61 e0       	ldi	r22, 0x01	; 1
    ba10:	70 e0       	ldi	r23, 0x00	; 0
    ba12:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 
    ba16:	84 ef       	ldi	r24, 0xF4	; 244
    ba18:	9e e7       	ldi	r25, 0x7E	; 126
    ba1a:	61 e0       	ldi	r22, 0x01	; 1
    ba1c:	70 e0       	ldi	r23, 0x00	; 0
    ba1e:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
			pitch(none,-hAxis[Axis].axisSettings.homeVelocity,
    ba22:	20 91 d4 7e 	lds	r18, 0x7ED4
    ba26:	30 91 d5 7e 	lds	r19, 0x7ED5
    ba2a:	40 91 d6 7e 	lds	r20, 0x7ED6
    ba2e:	50 91 d7 7e 	lds	r21, 0x7ED7
    ba32:	50 95       	com	r21
    ba34:	40 95       	com	r20
    ba36:	30 95       	com	r19
    ba38:	21 95       	neg	r18
    ba3a:	3f 4f       	sbci	r19, 0xFF	; 255
    ba3c:	4f 4f       	sbci	r20, 0xFF	; 255
    ba3e:	5f 4f       	sbci	r21, 0xFF	; 255
    ba40:	e0 90 d8 7e 	lds	r14, 0x7ED8
    ba44:	f0 90 d9 7e 	lds	r15, 0x7ED9
    ba48:	00 91 da 7e 	lds	r16, 0x7EDA
    ba4c:	10 91 db 7e 	lds	r17, 0x7EDB
    ba50:	61 ef       	ldi	r22, 0xF1	; 241
    ba52:	7f ef       	ldi	r23, 0xFF	; 255
    ba54:	8f ef       	ldi	r24, 0xFF	; 255
    ba56:	9f ef       	ldi	r25, 0xFF	; 255
    ba58:	f0 ef       	ldi	r31, 0xF0	; 240
    ba5a:	cf 2e       	mov	r12, r31
    ba5c:	ff ef       	ldi	r31, 0xFF	; 255
    ba5e:	df 2e       	mov	r13, r31
    ba60:	e1 e0       	ldi	r30, 0x01	; 1
    ba62:	ae 2e       	mov	r10, r30
    ba64:	b1 2c       	mov	r11, r1
    ba66:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <pitch>
    ba6a:	2a c0       	rjmp	.+84     	; 0xbac0 <Positivehandling+0x150>
		
		case (AxisRoll):
		break;
			
		default:				
			PMDSetProfileMode(&hAxis[Axis],  PMDVelocityContouringProfile ); 
    ba6c:	c4 01       	movw	r24, r8
    ba6e:	61 e0       	ldi	r22, 0x01	; 1
    ba70:	70 e0       	ldi	r23, 0x00	; 0
    ba72:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
			PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  				
    ba76:	c4 01       	movw	r24, r8
    ba78:	61 e0       	ldi	r22, 0x01	; 1
    ba7a:	70 e0       	ldi	r23, 0x00	; 0
    ba7c:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
			mov_axis(Axis,none, -hAxis[Axis].axisSettings.homeVelocity,
    ba80:	f4 01       	movw	r30, r8
    ba82:	e0 5c       	subi	r30, 0xC0	; 192
    ba84:	ff 4f       	sbci	r31, 0xFF	; 255
    ba86:	00 81       	ld	r16, Z
    ba88:	11 81       	ldd	r17, Z+1	; 0x01
    ba8a:	22 81       	ldd	r18, Z+2	; 0x02
    ba8c:	33 81       	ldd	r19, Z+3	; 0x03
    ba8e:	30 95       	com	r19
    ba90:	20 95       	com	r18
    ba92:	10 95       	com	r17
    ba94:	01 95       	neg	r16
    ba96:	1f 4f       	sbci	r17, 0xFF	; 255
    ba98:	2f 4f       	sbci	r18, 0xFF	; 255
    ba9a:	3f 4f       	sbci	r19, 0xFF	; 255
    ba9c:	f4 01       	movw	r30, r8
    ba9e:	ec 5b       	subi	r30, 0xBC	; 188
    baa0:	ff 4f       	sbci	r31, 0xFF	; 255
    baa2:	c0 80       	ld	r12, Z
    baa4:	d1 80       	ldd	r13, Z+1	; 0x01
    baa6:	e2 80       	ldd	r14, Z+2	; 0x02
    baa8:	f3 80       	ldd	r15, Z+3	; 0x03
    baaa:	c3 01       	movw	r24, r6
    baac:	41 ef       	ldi	r20, 0xF1	; 241
    baae:	5f ef       	ldi	r21, 0xFF	; 255
    bab0:	6f ef       	ldi	r22, 0xFF	; 255
    bab2:	7f ef       	ldi	r23, 0xFF	; 255
    bab4:	b0 ef       	ldi	r27, 0xF0	; 240
    bab6:	ab 2e       	mov	r10, r27
    bab8:	bf ef       	ldi	r27, 0xFF	; 255
    baba:	bb 2e       	mov	r11, r27
    babc:	0e 94 e2 37 	call	0x6fc4	; 0x6fc4 <mov_axis>
				hAxis[Axis].axisSettings.homeAcceleration, update);		
		break;
	}		
		
	PMDGetSignalStatus(&hAxis[Axis], &signal_status);
    bac0:	c4 01       	movw	r24, r8
    bac2:	8e 01       	movw	r16, r28
    bac4:	0f 5f       	subi	r16, 0xFF	; 255
    bac6:	1f 4f       	sbci	r17, 0xFF	; 255
    bac8:	b8 01       	movw	r22, r16
    baca:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
		
	do 
	{
		PMDGetSignalStatus(&hAxis[Axis], &signal_status);
    bace:	f0 2e       	mov	r15, r16
    bad0:	01 2f       	mov	r16, r17
    bad2:	c4 01       	movw	r24, r8
    bad4:	6f 2d       	mov	r22, r15
    bad6:	70 2f       	mov	r23, r16
    bad8:	0e 94 95 61 	call	0xc32a	; 0xc32a <PMDGetSignalStatus>
			printf("Positivehandling=> El Estado de la senal del Switch Positivo del eje %s es : %#X \n ",
					AxisName(Axis),mask);
		#endif
			
	} 
	while ((signal_status & PMDSignalPositiveLimitMask)==0);
    badc:	89 81       	ldd	r24, Y+1	; 0x01
    bade:	84 ff       	sbrs	r24, 4
    bae0:	f8 cf       	rjmp	.-16     	; 0xbad2 <Positivehandling+0x162>
	

	//---------------- Detener suavemente el movimiento.	
	
	PMDSetStopMode(&hAxis[Axis], PMDSmoothStopMode ); 
    bae2:	c4 01       	movw	r24, r8
    bae4:	62 e0       	ldi	r22, 0x02	; 2
    bae6:	70 e0       	ldi	r23, 0x00	; 0
    bae8:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
	PMDUpdate(&hAxis[Axis]);
    baec:	c4 01       	movw	r24, r8
    baee:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
	
	if(Axis==AxisPitch)
    baf2:	93 e0       	ldi	r25, 0x03	; 3
    baf4:	69 16       	cp	r6, r25
    baf6:	71 04       	cpc	r7, r1
    baf8:	a1 f4       	brne	.+40     	; 0xbb22 <Positivehandling+0x1b2>
	{
		PMDSetStopMode(&hAxis[AxisRoll], PMDSmoothStopMode ); 
    bafa:	84 ef       	ldi	r24, 0xF4	; 244
    bafc:	9e e7       	ldi	r25, 0x7E	; 126
    bafe:	62 e0       	ldi	r22, 0x02	; 2
    bb00:	70 e0       	ldi	r23, 0x00	; 0
    bb02:	0e 94 19 64 	call	0xc832	; 0xc832 <PMDSetStopMode>
		PMDUpdate(&hAxis[AxisRoll]);
    bb06:	84 ef       	ldi	r24, 0xF4	; 244
    bb08:	9e e7       	ldi	r25, 0x7E	; 126
    bb0a:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
		PMDSetProfileMode(&hAxis[AxisRoll],Profile_roll);
    bb0e:	6d 81       	ldd	r22, Y+5	; 0x05
    bb10:	7e 81       	ldd	r23, Y+6	; 0x06
    bb12:	84 ef       	ldi	r24, 0xF4	; 244
    bb14:	9e e7       	ldi	r25, 0x7E	; 126
    bb16:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
		PMDUpdate(&hAxis[AxisRoll]);
    bb1a:	84 ef       	ldi	r24, 0xF4	; 244
    bb1c:	9e e7       	ldi	r25, 0x7E	; 126
    bb1e:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
		
	}	
	
	//Se restaura el Valor inicial del Perfil de la trayectoria.
	PMDSetProfileMode(&hAxis[Axis],Profile);
    bb22:	6b 81       	ldd	r22, Y+3	; 0x03
    bb24:	7c 81       	ldd	r23, Y+4	; 0x04
    bb26:	c4 01       	movw	r24, r8
    bb28:	0e 94 2d 64 	call	0xc85a	; 0xc85a <PMDSetProfileMode>
	PMDUpdate(&hAxis[Axis]);	
    bb2c:	c4 01       	movw	r24, r8
    bb2e:	0e 94 6f 65 	call	0xcade	; 0xcade <PMDUpdate>
	
}
    bb32:	26 96       	adiw	r28, 0x06	; 6
    bb34:	0f b6       	in	r0, 0x3f	; 63
    bb36:	f8 94       	cli
    bb38:	de bf       	out	0x3e, r29	; 62
    bb3a:	0f be       	out	0x3f, r0	; 63
    bb3c:	cd bf       	out	0x3d, r28	; 61
    bb3e:	cf 91       	pop	r28
    bb40:	df 91       	pop	r29
    bb42:	1f 91       	pop	r17
    bb44:	0f 91       	pop	r16
    bb46:	ff 90       	pop	r15
    bb48:	ef 90       	pop	r14
    bb4a:	df 90       	pop	r13
    bb4c:	cf 90       	pop	r12
    bb4e:	bf 90       	pop	r11
    bb50:	af 90       	pop	r10
    bb52:	9f 90       	pop	r9
    bb54:	8f 90       	pop	r8
    bb56:	7f 90       	pop	r7
    bb58:	6f 90       	pop	r6
    bb5a:	08 95       	ret

0000bb5c <MotionErrorhandling>:
	
}

/*****************************************************************************************/
void MotionErrorhandling(tAxis Axis)
{
    bb5c:	ef 92       	push	r14
    bb5e:	ff 92       	push	r15
    bb60:	0f 93       	push	r16
    bb62:	1f 93       	push	r17
    bb64:	df 93       	push	r29
    bb66:	cf 93       	push	r28
    bb68:	00 d0       	rcall	.+0      	; 0xbb6a <MotionErrorhandling+0xe>
    bb6a:	cd b7       	in	r28, 0x3d	; 61
    bb6c:	de b7       	in	r29, 0x3e	; 62
    bb6e:	7c 01       	movw	r14, r24
	PMDuint16 mode;
	
	/* Imprimir mensajes de Error*/	
	printf("MotionErrorhandling=> El eje de %s Produjo un Error de Movimiento \n", AxisName(Axis));
    bb70:	0e 94 10 20 	call	0x4020	; 0x4020 <AxisName>
    bb74:	00 d0       	rcall	.+0      	; 0xbb76 <MotionErrorhandling+0x1a>
    bb76:	00 d0       	rcall	.+0      	; 0xbb78 <MotionErrorhandling+0x1c>
    bb78:	2b e9       	ldi	r18, 0x9B	; 155
    bb7a:	34 e7       	ldi	r19, 0x74	; 116
    bb7c:	ed b7       	in	r30, 0x3d	; 61
    bb7e:	fe b7       	in	r31, 0x3e	; 62
    bb80:	32 83       	std	Z+2, r19	; 0x02
    bb82:	21 83       	std	Z+1, r18	; 0x01
    bb84:	94 83       	std	Z+4, r25	; 0x04
    bb86:	83 83       	std	Z+3, r24	; 0x03
    bb88:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	fprintf_P(stderr,PSTR(" Error de Movimiento \n"));
    bb8c:	80 91 33 82 	lds	r24, 0x8233
    bb90:	90 91 34 82 	lds	r25, 0x8234
    bb94:	ed b7       	in	r30, 0x3d	; 61
    bb96:	fe b7       	in	r31, 0x3e	; 62
    bb98:	92 83       	std	Z+2, r25	; 0x02
    bb9a:	81 83       	std	Z+1, r24	; 0x01
    bb9c:	82 ee       	ldi	r24, 0xE2	; 226
    bb9e:	94 e0       	ldi	r25, 0x04	; 4
    bba0:	94 83       	std	Z+4, r25	; 0x04
    bba2:	83 83       	std	Z+3, r24	; 0x03
    bba4:	0e 94 86 88 	call	0x1110c	; 0x1110c <fprintf_P>
	/* se enciende el LED Rojo*/
	Led_on(Rojo);
    bba8:	0f 90       	pop	r0
    bbaa:	0f 90       	pop	r0
    bbac:	0f 90       	pop	r0
    bbae:	0f 90       	pop	r0
    bbb0:	81 e0       	ldi	r24, 0x01	; 1
    bbb2:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
	
	
	/*Se limpia el Event Status Register, borrando la interrupcion 	*/	
	PMDResetEventStatus(&hAxis[Axis],~PMDEventMotionErrorMask);
    bbb6:	80 e6       	ldi	r24, 0x60	; 96
    bbb8:	90 e0       	ldi	r25, 0x00	; 0
    bbba:	e8 9e       	mul	r14, r24
    bbbc:	80 01       	movw	r16, r0
    bbbe:	e9 9e       	mul	r14, r25
    bbc0:	10 0d       	add	r17, r0
    bbc2:	f8 9e       	mul	r15, r24
    bbc4:	10 0d       	add	r17, r0
    bbc6:	11 24       	eor	r1, r1
    bbc8:	0c 58       	subi	r16, 0x8C	; 140
    bbca:	12 48       	sbci	r17, 0x82	; 130
    bbcc:	c8 01       	movw	r24, r16
    bbce:	6f ee       	ldi	r22, 0xEF	; 239
    bbd0:	7f ef       	ldi	r23, 0xFF	; 255
    bbd2:	0e 94 a7 63 	call	0xc74e	; 0xc74e <PMDResetEventStatus>
	
	// reactivar el movimiento dependiendo de si existe parada automatica
	PMDGetAutoStopMode(&hAxis[Axis], &mode);
    bbd6:	c8 01       	movw	r24, r16
    bbd8:	be 01       	movw	r22, r28
    bbda:	6f 5f       	subi	r22, 0xFF	; 255
    bbdc:	7f 4f       	sbci	r23, 0xFF	; 255
    bbde:	0e 94 e3 61 	call	0xc3c6	; 0xc3c6 <PMDGetAutoStopMode>
			
	if (mode==PMDEnable)
    bbe2:	89 81       	ldd	r24, Y+1	; 0x01
    bbe4:	9a 81       	ldd	r25, Y+2	; 0x02
    bbe6:	01 97       	sbiw	r24, 0x01	; 1
    bbe8:	79 f4       	brne	.+30     	; 0xbc08 <MotionErrorhandling+0xac>
	{
		PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);
    bbea:	c8 01       	movw	r24, r16
    bbec:	61 e0       	ldi	r22, 0x01	; 1
    bbee:	70 e0       	ldi	r23, 0x00	; 0
    bbf0:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
		if(Axis==AxisPitch)
    bbf4:	f3 e0       	ldi	r31, 0x03	; 3
    bbf6:	ef 16       	cp	r14, r31
    bbf8:	f1 04       	cpc	r15, r1
    bbfa:	31 f4       	brne	.+12     	; 0xbc08 <MotionErrorhandling+0xac>
		{				
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 		
    bbfc:	84 ef       	ldi	r24, 0xF4	; 244
    bbfe:	9e e7       	ldi	r25, 0x7E	; 126
    bc00:	61 e0       	ldi	r22, 0x01	; 1
    bc02:	70 e0       	ldi	r23, 0x00	; 0
    bc04:	0e 94 7d 63 	call	0xc6fa	; 0xc6fa <PMDSetMotorMode>
		}		
	}
	
}
    bc08:	0f 90       	pop	r0
    bc0a:	0f 90       	pop	r0
    bc0c:	cf 91       	pop	r28
    bc0e:	df 91       	pop	r29
    bc10:	1f 91       	pop	r17
    bc12:	0f 91       	pop	r16
    bc14:	ff 90       	pop	r15
    bc16:	ef 90       	pop	r14
    bc18:	08 95       	ret

0000bc1a <interruptAxisHandling>:
	
}

/*****************************************************************************************/
void interruptAxisHandling(tAxis Axis)
{
    bc1a:	0f 93       	push	r16
    bc1c:	1f 93       	push	r17
    bc1e:	df 93       	push	r29
    bc20:	cf 93       	push	r28
    bc22:	00 d0       	rcall	.+0      	; 0xbc24 <interruptAxisHandling+0xa>
    bc24:	cd b7       	in	r28, 0x3d	; 61
    bc26:	de b7       	in	r29, 0x3e	; 62
    bc28:	8c 01       	movw	r16, r24
	PMDuint16 status;
	
	
	/* ----Verificar La causa de la Interrupcion a traves de Event Status REgister*/
	
	PMDGetEventStatus(&hAxis[Axis],&status);
    bc2a:	80 e6       	ldi	r24, 0x60	; 96
    bc2c:	90 e0       	ldi	r25, 0x00	; 0
    bc2e:	9c 01       	movw	r18, r24
    bc30:	02 9f       	mul	r16, r18
    bc32:	c0 01       	movw	r24, r0
    bc34:	03 9f       	mul	r16, r19
    bc36:	90 0d       	add	r25, r0
    bc38:	12 9f       	mul	r17, r18
    bc3a:	90 0d       	add	r25, r0
    bc3c:	11 24       	eor	r1, r1
    bc3e:	8c 58       	subi	r24, 0x8C	; 140
    bc40:	92 48       	sbci	r25, 0x82	; 130
    bc42:	be 01       	movw	r22, r28
    bc44:	6f 5f       	subi	r22, 0xFF	; 255
    bc46:	7f 4f       	sbci	r23, 0xFF	; 255
    bc48:	0e 94 a7 61 	call	0xc34e	; 0xc34e <PMDGetEventStatus>
	#endif	
	
	
	/*--------La causa de la Interrupcion es un Error de Movimiento */
	
	if((status & PMDEventMotionErrorMask)!=0)
    bc4c:	89 81       	ldd	r24, Y+1	; 0x01
    bc4e:	84 ff       	sbrs	r24, 4
    bc50:	09 c0       	rjmp	.+18     	; 0xbc64 <interruptAxisHandling+0x4a>
	{
		buzzer_ms(500);
    bc52:	64 ef       	ldi	r22, 0xF4	; 244
    bc54:	71 e0       	ldi	r23, 0x01	; 1
    bc56:	80 e0       	ldi	r24, 0x00	; 0
    bc58:	90 e0       	ldi	r25, 0x00	; 0
    bc5a:	0e 94 00 77 	call	0xee00	; 0xee00 <buzzer_ms>
		MotionErrorhandling(Axis);		
    bc5e:	c8 01       	movw	r24, r16
    bc60:	0e 94 ae 5d 	call	0xbb5c	; 0xbb5c <MotionErrorhandling>
	}	
	
	/*--------La causa de la Interrupcion es el Evento de Limite Positivo */
	
	if((status & PMDEventInPositiveLimitMask)!=0)
    bc64:	89 81       	ldd	r24, Y+1	; 0x01
    bc66:	85 ff       	sbrs	r24, 5
    bc68:	09 c0       	rjmp	.+18     	; 0xbc7c <interruptAxisHandling+0x62>
	{
		buzzer_ms(100);
    bc6a:	64 e6       	ldi	r22, 0x64	; 100
    bc6c:	70 e0       	ldi	r23, 0x00	; 0
    bc6e:	80 e0       	ldi	r24, 0x00	; 0
    bc70:	90 e0       	ldi	r25, 0x00	; 0
    bc72:	0e 94 00 77 	call	0xee00	; 0xee00 <buzzer_ms>
		Positivehandling(Axis);		
    bc76:	c8 01       	movw	r24, r16
    bc78:	0e 94 b8 5c 	call	0xb970	; 0xb970 <Positivehandling>
	}		
	
	/*--------La causa de la Interrupcion es el Evento de Limite Negativo */
	
	if((status & PMDEventInNegativeLimitMask)!=0)
    bc7c:	89 81       	ldd	r24, Y+1	; 0x01
    bc7e:	86 ff       	sbrs	r24, 6
    bc80:	09 c0       	rjmp	.+18     	; 0xbc94 <interruptAxisHandling+0x7a>
	{
		buzzer_ms(100);
    bc82:	64 e6       	ldi	r22, 0x64	; 100
    bc84:	70 e0       	ldi	r23, 0x00	; 0
    bc86:	80 e0       	ldi	r24, 0x00	; 0
    bc88:	90 e0       	ldi	r25, 0x00	; 0
    bc8a:	0e 94 00 77 	call	0xee00	; 0xee00 <buzzer_ms>
		Negativehandling(Axis);		
    bc8e:	c8 01       	movw	r24, r16
    bc90:	0e 94 d0 5b 	call	0xb7a0	; 0xb7a0 <Negativehandling>
	
	
	
	/*--------La causa de la Interrupcion es un Error de Instruccion */
	
	if((status & PMDEventInstructionErrorMask)!=0)
    bc94:	89 81       	ldd	r24, Y+1	; 0x01
    bc96:	87 ff       	sbrs	r24, 7
    bc98:	09 c0       	rjmp	.+18     	; 0xbcac <interruptAxisHandling+0x92>
	{
		buzzer_ms(500);
    bc9a:	64 ef       	ldi	r22, 0xF4	; 244
    bc9c:	71 e0       	ldi	r23, 0x01	; 1
    bc9e:	80 e0       	ldi	r24, 0x00	; 0
    bca0:	90 e0       	ldi	r25, 0x00	; 0
    bca2:	0e 94 00 77 	call	0xee00	; 0xee00 <buzzer_ms>
		InstructionErrorhandling(Axis);		
    bca6:	c8 01       	movw	r24, r16
    bca8:	0e 94 73 5b 	call	0xb6e6	; 0xb6e6 <InstructionErrorhandling>
	}	


	
}
    bcac:	0f 90       	pop	r0
    bcae:	0f 90       	pop	r0
    bcb0:	cf 91       	pop	r28
    bcb2:	df 91       	pop	r29
    bcb4:	1f 91       	pop	r17
    bcb6:	0f 91       	pop	r16
    bcb8:	08 95       	ret

0000bcba <InterruptHandling_chipset2>:
}
	

/*****************************************************************************************/
void InterruptHandling_chipset2(void)
{
    bcba:	0f 93       	push	r16
    bcbc:	1f 93       	push	r17
    bcbe:	df 93       	push	r29
    bcc0:	cf 93       	push	r28
    bcc2:	00 d0       	rcall	.+0      	; 0xbcc4 <InterruptHandling_chipset2+0xa>
    bcc4:	cd b7       	in	r28, 0x3d	; 61
    bcc6:	de b7       	in	r29, 0x3e	; 62
	PMDuint16 interruptingAxisMask2;
	PMDresult rc;
	
	interruptingAxisMask2=0;
    bcc8:	1a 82       	std	Y+2, r1	; 0x02
    bcca:	19 82       	std	Y+1, r1	; 0x01
	
	//Verificar que eje produjo la Interrupcion	
	do
	{
		rc=PMDGetInterruptAxis(&hAxis[AxisRoll],  &interruptingAxisMask2);
    bccc:	8e 01       	movw	r16, r28
    bcce:	0f 5f       	subi	r16, 0xFF	; 255
    bcd0:	1f 4f       	sbci	r17, 0xFF	; 255
    bcd2:	84 ef       	ldi	r24, 0xF4	; 244
    bcd4:	9e e7       	ldi	r25, 0x7E	; 126
    bcd6:	b8 01       	movw	r22, r16
    bcd8:	0e 94 ad 61 	call	0xc35a	; 0xc35a <PMDGetInterruptAxis>
	}
	while (rc!=PMD_ERR_OK);			
    bcdc:	89 2b       	or	r24, r25
    bcde:	c9 f7       	brne	.-14     	; 0xbcd2 <InterruptHandling_chipset2+0x18>
	#ifdef DEBUGINTERRUPT
		printf("InterruptHandling_chipset2=> La mascara 2 de interrupcion es %X \n",interruptingAxisMask2 );
	#endif
	
	
	if ((interruptingAxisMask2 & PMDAxis1Mask)!=0)					//Eje de Roll Causo la Interrupcion?
    bce0:	89 81       	ldd	r24, Y+1	; 0x01
    bce2:	80 ff       	sbrs	r24, 0
    bce4:	10 c0       	rjmp	.+32     	; 0xbd06 <InterruptHandling_chipset2+0x4c>
	{
		interruptAxisHandling(AxisRoll);
    bce6:	84 e0       	ldi	r24, 0x04	; 4
    bce8:	90 e0       	ldi	r25, 0x00	; 0
    bcea:	0e 94 0d 5e 	call	0xbc1a	; 0xbc1a <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask2 = interruptingAxisMask2 & ~(PMDAxis1Mask);
    bcee:	89 81       	ldd	r24, Y+1	; 0x01
    bcf0:	9a 81       	ldd	r25, Y+2	; 0x02
    bcf2:	8e 7f       	andi	r24, 0xFE	; 254
    bcf4:	9a 83       	std	Y+2, r25	; 0x02
    bcf6:	89 83       	std	Y+1, r24	; 0x01
		#endif	
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisRoll]);	
    bcf8:	84 ef       	ldi	r24, 0xF4	; 244
    bcfa:	9e e7       	ldi	r25, 0x7E	; 126
    bcfc:	0e 94 59 65 	call	0xcab2	; 0xcab2 <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    bd00:	89 2b       	or	r24, r25
    bd02:	d1 f7       	brne	.-12     	; 0xbcf8 <InterruptHandling_chipset2+0x3e>
    bd04:	35 c0       	rjmp	.+106    	; 0xbd70 <InterruptHandling_chipset2+0xb6>
		
		return;
	}
		
	if ((interruptingAxisMask2 & PMDAxis2Mask)!=0)					//Eje Aux1 Causo la Interrupcion?
    bd06:	81 ff       	sbrs	r24, 1
    bd08:	10 c0       	rjmp	.+32     	; 0xbd2a <InterruptHandling_chipset2+0x70>
	{
		interruptAxisHandling(AxisAux1);
    bd0a:	85 e0       	ldi	r24, 0x05	; 5
    bd0c:	90 e0       	ldi	r25, 0x00	; 0
    bd0e:	0e 94 0d 5e 	call	0xbc1a	; 0xbc1a <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask2 = interruptingAxisMask2 & ~(PMDAxis2Mask);
    bd12:	89 81       	ldd	r24, Y+1	; 0x01
    bd14:	9a 81       	ldd	r25, Y+2	; 0x02
    bd16:	8d 7f       	andi	r24, 0xFD	; 253
    bd18:	9a 83       	std	Y+2, r25	; 0x02
    bd1a:	89 83       	std	Y+1, r24	; 0x01
		#endif	
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisAux1]);	
    bd1c:	84 e5       	ldi	r24, 0x54	; 84
    bd1e:	9f e7       	ldi	r25, 0x7F	; 127
    bd20:	0e 94 59 65 	call	0xcab2	; 0xcab2 <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);		
    bd24:	89 2b       	or	r24, r25
    bd26:	d1 f7       	brne	.-12     	; 0xbd1c <InterruptHandling_chipset2+0x62>
    bd28:	23 c0       	rjmp	.+70     	; 0xbd70 <InterruptHandling_chipset2+0xb6>
		
		return;
	}
		
	if ((interruptingAxisMask2 & PMDAxis3Mask)!=0)					//Eje Aux2 Causo la Interrupcion?
    bd2a:	82 ff       	sbrs	r24, 2
    bd2c:	10 c0       	rjmp	.+32     	; 0xbd4e <InterruptHandling_chipset2+0x94>
	{
		interruptAxisHandling(AxisAux2);
    bd2e:	86 e0       	ldi	r24, 0x06	; 6
    bd30:	90 e0       	ldi	r25, 0x00	; 0
    bd32:	0e 94 0d 5e 	call	0xbc1a	; 0xbc1a <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask2 = interruptingAxisMask2 & ~(PMDAxis3Mask);
    bd36:	89 81       	ldd	r24, Y+1	; 0x01
    bd38:	9a 81       	ldd	r25, Y+2	; 0x02
    bd3a:	8b 7f       	andi	r24, 0xFB	; 251
    bd3c:	9a 83       	std	Y+2, r25	; 0x02
    bd3e:	89 83       	std	Y+1, r24	; 0x01
		#endif	
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisAux2]);	
    bd40:	84 eb       	ldi	r24, 0xB4	; 180
    bd42:	9f e7       	ldi	r25, 0x7F	; 127
    bd44:	0e 94 59 65 	call	0xcab2	; 0xcab2 <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    bd48:	89 2b       	or	r24, r25
    bd4a:	d1 f7       	brne	.-12     	; 0xbd40 <InterruptHandling_chipset2+0x86>
    bd4c:	11 c0       	rjmp	.+34     	; 0xbd70 <InterruptHandling_chipset2+0xb6>
		
		return;
	}
		
	if ((interruptingAxisMask2 & PMDAxis4Mask)!=0)					//Eje Aux3 Causo la Interrupcion?
    bd4e:	83 ff       	sbrs	r24, 3
    bd50:	0f c0       	rjmp	.+30     	; 0xbd70 <InterruptHandling_chipset2+0xb6>
	{
		interruptAxisHandling(AxisAux3);
    bd52:	87 e0       	ldi	r24, 0x07	; 7
    bd54:	90 e0       	ldi	r25, 0x00	; 0
    bd56:	0e 94 0d 5e 	call	0xbc1a	; 0xbc1a <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask2 = interruptingAxisMask2 & ~(PMDAxis4Mask);
    bd5a:	89 81       	ldd	r24, Y+1	; 0x01
    bd5c:	9a 81       	ldd	r25, Y+2	; 0x02
    bd5e:	87 7f       	andi	r24, 0xF7	; 247
    bd60:	9a 83       	std	Y+2, r25	; 0x02
    bd62:	89 83       	std	Y+1, r24	; 0x01
		#endif	
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisAux3]);	
    bd64:	84 e1       	ldi	r24, 0x14	; 20
    bd66:	90 e8       	ldi	r25, 0x80	; 128
    bd68:	0e 94 59 65 	call	0xcab2	; 0xcab2 <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    bd6c:	89 2b       	or	r24, r25
    bd6e:	d1 f7       	brne	.-12     	; 0xbd64 <InterruptHandling_chipset2+0xaa>
		
		return;
	}
	
	
    bd70:	0f 90       	pop	r0
    bd72:	0f 90       	pop	r0
    bd74:	cf 91       	pop	r28
    bd76:	df 91       	pop	r29
    bd78:	1f 91       	pop	r17
    bd7a:	0f 91       	pop	r16
    bd7c:	08 95       	ret

0000bd7e <InterruptHandling_chipset1>:
	
}

/*****************************************************************************************/
void InterruptHandling_chipset1(void)
{
    bd7e:	0f 93       	push	r16
    bd80:	1f 93       	push	r17
    bd82:	df 93       	push	r29
    bd84:	cf 93       	push	r28
    bd86:	00 d0       	rcall	.+0      	; 0xbd88 <InterruptHandling_chipset1+0xa>
    bd88:	cd b7       	in	r28, 0x3d	; 61
    bd8a:	de b7       	in	r29, 0x3e	; 62
	PMDuint16 interruptingAxisMask1;
	PMDresult rc;	
	interruptingAxisMask1=0;
    bd8c:	1a 82       	std	Y+2, r1	; 0x02
    bd8e:	19 82       	std	Y+1, r1	; 0x01
	
	//Verificar que eje produjo la Interrupcion

	do
	{
		rc=PMDGetInterruptAxis(&hAxis[AxisWaist],  &interruptingAxisMask1);
    bd90:	8e 01       	movw	r16, r28
    bd92:	0f 5f       	subi	r16, 0xFF	; 255
    bd94:	1f 4f       	sbci	r17, 0xFF	; 255
    bd96:	84 e7       	ldi	r24, 0x74	; 116
    bd98:	9d e7       	ldi	r25, 0x7D	; 125
    bd9a:	b8 01       	movw	r22, r16
    bd9c:	0e 94 ad 61 	call	0xc35a	; 0xc35a <PMDGetInterruptAxis>
	}
	while (rc!=PMD_ERR_OK);		
    bda0:	89 2b       	or	r24, r25
    bda2:	c9 f7       	brne	.-14     	; 0xbd96 <InterruptHandling_chipset1+0x18>
		printf("InterruptHandling_chipset1=> La mascara 1 de interrupcion es %X \n",interruptingAxisMask1 );
	#endif
	
	
	
	if ((interruptingAxisMask1 & PMDAxis1Mask)!=0)					//Eje de cintura Causo la Interrupcion?
    bda4:	89 81       	ldd	r24, Y+1	; 0x01
    bda6:	80 ff       	sbrs	r24, 0
    bda8:	10 c0       	rjmp	.+32     	; 0xbdca <InterruptHandling_chipset1+0x4c>
	{
		interruptAxisHandling(AxisWaist);
    bdaa:	80 e0       	ldi	r24, 0x00	; 0
    bdac:	90 e0       	ldi	r25, 0x00	; 0
    bdae:	0e 94 0d 5e 	call	0xbc1a	; 0xbc1a <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask1 = interruptingAxisMask1 & ~(PMDAxis1Mask);
    bdb2:	89 81       	ldd	r24, Y+1	; 0x01
    bdb4:	9a 81       	ldd	r25, Y+2	; 0x02
    bdb6:	8e 7f       	andi	r24, 0xFE	; 254
    bdb8:	9a 83       	std	Y+2, r25	; 0x02
    bdba:	89 83       	std	Y+1, r24	; 0x01
		#endif
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisWaist]);	
    bdbc:	84 e7       	ldi	r24, 0x74	; 116
    bdbe:	9d e7       	ldi	r25, 0x7D	; 125
    bdc0:	0e 94 59 65 	call	0xcab2	; 0xcab2 <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);			
    bdc4:	89 2b       	or	r24, r25
    bdc6:	d1 f7       	brne	.-12     	; 0xbdbc <InterruptHandling_chipset1+0x3e>
    bdc8:	35 c0       	rjmp	.+106    	; 0xbe34 <InterruptHandling_chipset1+0xb6>
		
		return;
	}
	
	
	if ((interruptingAxisMask1 & PMDAxis2Mask)!=0)					//Eje de HOmbro Causo la Interrupcion?
    bdca:	81 ff       	sbrs	r24, 1
    bdcc:	10 c0       	rjmp	.+32     	; 0xbdee <InterruptHandling_chipset1+0x70>
	{
		interruptAxisHandling(AxisShoulder);
    bdce:	81 e0       	ldi	r24, 0x01	; 1
    bdd0:	90 e0       	ldi	r25, 0x00	; 0
    bdd2:	0e 94 0d 5e 	call	0xbc1a	; 0xbc1a <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask1 = interruptingAxisMask1 & ~(PMDAxis2Mask);
    bdd6:	89 81       	ldd	r24, Y+1	; 0x01
    bdd8:	9a 81       	ldd	r25, Y+2	; 0x02
    bdda:	8d 7f       	andi	r24, 0xFD	; 253
    bddc:	9a 83       	std	Y+2, r25	; 0x02
    bdde:	89 83       	std	Y+1, r24	; 0x01
		#endif
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisShoulder]);	
    bde0:	84 ed       	ldi	r24, 0xD4	; 212
    bde2:	9d e7       	ldi	r25, 0x7D	; 125
    bde4:	0e 94 59 65 	call	0xcab2	; 0xcab2 <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    bde8:	89 2b       	or	r24, r25
    bdea:	d1 f7       	brne	.-12     	; 0xbde0 <InterruptHandling_chipset1+0x62>
    bdec:	23 c0       	rjmp	.+70     	; 0xbe34 <InterruptHandling_chipset1+0xb6>
		
		return;
	}

	if ((interruptingAxisMask1 & PMDAxis3Mask)!=0)					//Eje de Codo Causo la Interrupcion?
    bdee:	82 ff       	sbrs	r24, 2
    bdf0:	10 c0       	rjmp	.+32     	; 0xbe12 <InterruptHandling_chipset1+0x94>
	{
		interruptAxisHandling(AxisElbow);
    bdf2:	82 e0       	ldi	r24, 0x02	; 2
    bdf4:	90 e0       	ldi	r25, 0x00	; 0
    bdf6:	0e 94 0d 5e 	call	0xbc1a	; 0xbc1a <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask1 = interruptingAxisMask1 & ~(PMDAxis3Mask);
    bdfa:	89 81       	ldd	r24, Y+1	; 0x01
    bdfc:	9a 81       	ldd	r25, Y+2	; 0x02
    bdfe:	8b 7f       	andi	r24, 0xFB	; 251
    be00:	9a 83       	std	Y+2, r25	; 0x02
    be02:	89 83       	std	Y+1, r24	; 0x01
		#endif
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisElbow]);	
    be04:	84 e3       	ldi	r24, 0x34	; 52
    be06:	9e e7       	ldi	r25, 0x7E	; 126
    be08:	0e 94 59 65 	call	0xcab2	; 0xcab2 <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    be0c:	89 2b       	or	r24, r25
    be0e:	d1 f7       	brne	.-12     	; 0xbe04 <InterruptHandling_chipset1+0x86>
    be10:	11 c0       	rjmp	.+34     	; 0xbe34 <InterruptHandling_chipset1+0xb6>
		
		return;
	}

	if ((interruptingAxisMask1 & PMDAxis4Mask)!=0)					//Eje de Pitch Causo la Interrupcion?
    be12:	83 ff       	sbrs	r24, 3
    be14:	0f c0       	rjmp	.+30     	; 0xbe34 <InterruptHandling_chipset1+0xb6>
	{
		interruptAxisHandling(AxisPitch);
    be16:	83 e0       	ldi	r24, 0x03	; 3
    be18:	90 e0       	ldi	r25, 0x00	; 0
    be1a:	0e 94 0d 5e 	call	0xbc1a	; 0xbc1a <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask1 = interruptingAxisMask1 & ~(PMDAxis4Mask);
    be1e:	89 81       	ldd	r24, Y+1	; 0x01
    be20:	9a 81       	ldd	r25, Y+2	; 0x02
    be22:	87 7f       	andi	r24, 0xF7	; 247
    be24:	9a 83       	std	Y+2, r25	; 0x02
    be26:	89 83       	std	Y+1, r24	; 0x01
		#endif
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisPitch]);	
    be28:	84 e9       	ldi	r24, 0x94	; 148
    be2a:	9e e7       	ldi	r25, 0x7E	; 126
    be2c:	0e 94 59 65 	call	0xcab2	; 0xcab2 <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    be30:	89 2b       	or	r24, r25
    be32:	d1 f7       	brne	.-12     	; 0xbe28 <InterruptHandling_chipset1+0xaa>
		
		return;
	}
	
}
    be34:	0f 90       	pop	r0
    be36:	0f 90       	pop	r0
    be38:	cf 91       	pop	r28
    be3a:	df 91       	pop	r29
    be3c:	1f 91       	pop	r17
    be3e:	0f 91       	pop	r16
    be40:	08 95       	ret

0000be42 <HostInterruptEnable>:
		}
	}
} 
/*****************************************************************************************/
void HostInterruptEnable(void)
{
    be42:	cf 93       	push	r28
    be44:	df 93       	push	r29
    be46:	c4 e7       	ldi	r28, 0x74	; 116
    be48:	dd e7       	ldi	r29, 0x7D	; 125
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE) &&
    be4a:	8c 81       	ldd	r24, Y+4	; 0x04
    be4c:	81 30       	cpi	r24, 0x01	; 1
    be4e:	41 f4       	brne	.+16     	; 0xbe60 <HostInterruptEnable+0x1e>
    be50:	8d 81       	ldd	r24, Y+5	; 0x05
    be52:	81 30       	cpi	r24, 0x01	; 1
    be54:	29 f4       	brne	.+10     	; 0xbe60 <HostInterruptEnable+0x1e>
			(hAxis[axis].axisSettings.interruptEnable==TRUE))
		{
			PMDSetInterruptMask(&hAxis[axis],	PMDEventMotionErrorMask		|
    be56:	ce 01       	movw	r24, r28
    be58:	60 ef       	ldi	r22, 0xF0	; 240
    be5a:	70 e0       	ldi	r23, 0x00	; 0
    be5c:	0e 94 ad 63 	call	0xc75a	; 0xc75a <PMDSetInterruptMask>
    be60:	c0 5a       	subi	r28, 0xA0	; 160
    be62:	df 4f       	sbci	r29, 0xFF	; 255
/*****************************************************************************************/
void HostInterruptEnable(void)
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
    be64:	8f e7       	ldi	r24, 0x7F	; 127
    be66:	c4 35       	cpi	r28, 0x54	; 84
    be68:	d8 07       	cpc	r29, r24
    be6a:	79 f7       	brne	.-34     	; 0xbe4a <HostInterruptEnable+0x8>
												PMDEventInPositiveLimitMask | 
												PMDEventInNegativeLimitMask	|
												PMDEventInstructionErrorMask);
		}
	}
}
    be6c:	df 91       	pop	r29
    be6e:	cf 91       	pop	r28
    be70:	08 95       	ret

0000be72 <HostInterruptDisable>:



/*******************************************************************************************/
void HostInterruptDisable(void)
{
    be72:	cf 93       	push	r28
    be74:	df 93       	push	r29
    be76:	c4 e7       	ldi	r28, 0x74	; 116
    be78:	dd e7       	ldi	r29, 0x7D	; 125
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE) &&
    be7a:	8c 81       	ldd	r24, Y+4	; 0x04
    be7c:	81 30       	cpi	r24, 0x01	; 1
    be7e:	41 f4       	brne	.+16     	; 0xbe90 <HostInterruptDisable+0x1e>
    be80:	8d 81       	ldd	r24, Y+5	; 0x05
    be82:	81 30       	cpi	r24, 0x01	; 1
    be84:	29 f4       	brne	.+10     	; 0xbe90 <HostInterruptDisable+0x1e>
			(hAxis[axis].axisSettings.interruptEnable==TRUE))
		{
			PMDSetInterruptMask(&hAxis[axis],0);
    be86:	ce 01       	movw	r24, r28
    be88:	60 e0       	ldi	r22, 0x00	; 0
    be8a:	70 e0       	ldi	r23, 0x00	; 0
    be8c:	0e 94 ad 63 	call	0xc75a	; 0xc75a <PMDSetInterruptMask>
    be90:	c0 5a       	subi	r28, 0xA0	; 160
    be92:	df 4f       	sbci	r29, 0xFF	; 255
/*******************************************************************************************/
void HostInterruptDisable(void)
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
    be94:	8f e7       	ldi	r24, 0x7F	; 127
    be96:	c4 35       	cpi	r28, 0x54	; 84
    be98:	d8 07       	cpc	r29, r24
    be9a:	79 f7       	brne	.-34     	; 0xbe7a <HostInterruptDisable+0x8>
			(hAxis[axis].axisSettings.interruptEnable==TRUE))
		{
			PMDSetInterruptMask(&hAxis[axis],0);
		}
	}
} 
    be9c:	df 91       	pop	r29
    be9e:	cf 91       	pop	r28
    bea0:	08 95       	ret

0000bea2 <PMDGetStatus>:


// C-Motion provided functions

PMDresult PMDGetStatus(PMDAxisHandle* axis_handle)
{
    bea2:	fc 01       	movw	r30, r24
	return axis_handle->transport.GetStatus(axis_handle->transport_data);
    bea4:	dc 01       	movw	r26, r24
    bea6:	a2 5a       	subi	r26, 0xA2	; 162
    bea8:	bf 4f       	sbci	r27, 0xFF	; 255
    beaa:	ec 5a       	subi	r30, 0xAC	; 172
    beac:	ff 4f       	sbci	r31, 0xFF	; 255
    beae:	01 90       	ld	r0, Z+
    beb0:	f0 81       	ld	r31, Z
    beb2:	e0 2d       	mov	r30, r0
    beb4:	8d 91       	ld	r24, X+
    beb6:	9c 91       	ld	r25, X
    beb8:	09 95       	icall
}
    beba:	08 95       	ret

0000bebc <PMDHasError>:

PMDresult PMDHasError(PMDAxisHandle* axis_handle)
{
    bebc:	fc 01       	movw	r30, r24
	return axis_handle->transport.HasError(axis_handle->transport_data);
    bebe:	dc 01       	movw	r26, r24
    bec0:	a2 5a       	subi	r26, 0xA2	; 162
    bec2:	bf 4f       	sbci	r27, 0xFF	; 255
    bec4:	e6 5a       	subi	r30, 0xA6	; 166
    bec6:	ff 4f       	sbci	r31, 0xFF	; 255
    bec8:	01 90       	ld	r0, Z+
    beca:	f0 81       	ld	r31, Z
    becc:	e0 2d       	mov	r30, r0
    bece:	8d 91       	ld	r24, X+
    bed0:	9c 91       	ld	r25, X
    bed2:	09 95       	icall
}
    bed4:	08 95       	ret

0000bed6 <PMDIsReady>:

PMDresult PMDIsReady(PMDAxisHandle* axis_handle)
{
    bed6:	fc 01       	movw	r30, r24
	return axis_handle->transport.IsReady(axis_handle->transport_data);
    bed8:	dc 01       	movw	r26, r24
    beda:	a2 5a       	subi	r26, 0xA2	; 162
    bedc:	bf 4f       	sbci	r27, 0xFF	; 255
    bede:	ea 5a       	subi	r30, 0xAA	; 170
    bee0:	ff 4f       	sbci	r31, 0xFF	; 255
    bee2:	01 90       	ld	r0, Z+
    bee4:	f0 81       	ld	r31, Z
    bee6:	e0 2d       	mov	r30, r0
    bee8:	8d 91       	ld	r24, X+
    beea:	9c 91       	ld	r25, X
    beec:	09 95       	icall
}
    beee:	08 95       	ret

0000bef0 <PMDHasInterrupt>:

PMDresult PMDHasInterrupt(PMDAxisHandle* axis_handle)
{
    bef0:	fc 01       	movw	r30, r24
	return axis_handle->transport.HasInterrupt(axis_handle->transport_data);
    bef2:	dc 01       	movw	r26, r24
    bef4:	a2 5a       	subi	r26, 0xA2	; 162
    bef6:	bf 4f       	sbci	r27, 0xFF	; 255
    bef8:	e8 5a       	subi	r30, 0xA8	; 168
    befa:	ff 4f       	sbci	r31, 0xFF	; 255
    befc:	01 90       	ld	r0, Z+
    befe:	f0 81       	ld	r31, Z
    bf00:	e0 2d       	mov	r30, r0
    bf02:	8d 91       	ld	r24, X+
    bf04:	9c 91       	ld	r25, X
    bf06:	09 95       	icall
}
    bf08:	08 95       	ret

0000bf0a <PMDHardReset>:

PMDresult PMDHardReset(PMDAxisHandle* axis_handle)
{  //Se invoca la funcion asociada a axis_handle->transport.HardReset
    bf0a:	fc 01       	movw	r30, r24
   //luego esta funcion toma transport_data y ejecuta una de las funciones asocioadas
   //mediante PIOtransport_data->Hard();
   //que si se ha sido corretamente inicializada sera OutP8BitHard(void)
   //esta llama writePMDreset() en basicio.c
   //la cual finalmente hace el reset por hardaware y mana comandos de reset sin esperar PMDready.
	return axis_handle->transport.HardReset(axis_handle->transport_data);
    bf0c:	dc 01       	movw	r26, r24
    bf0e:	a2 5a       	subi	r26, 0xA2	; 162
    bf10:	bf 4f       	sbci	r27, 0xFF	; 255
    bf12:	e4 5a       	subi	r30, 0xA4	; 164
    bf14:	ff 4f       	sbci	r31, 0xFF	; 255
    bf16:	01 90       	ld	r0, Z+
    bf18:	f0 81       	ld	r31, Z
    bf1a:	e0 2d       	mov	r30, r0
    bf1c:	8d 91       	ld	r24, X+
    bf1e:	9c 91       	ld	r25, X
    bf20:	09 95       	icall
}
    bf22:	08 95       	ret

0000bf24 <PMDCloseAxisInterface>:

void PMDCloseAxisInterface(PMDAxisHandle* axis_handle)
{
    bf24:	fc 01       	movw	r30, r24
	axis_handle->transport.Close(axis_handle->transport_data);
    bf26:	dc 01       	movw	r26, r24
    bf28:	a2 5a       	subi	r26, 0xA2	; 162
    bf2a:	bf 4f       	sbci	r27, 0xFF	; 255
    bf2c:	ee 5a       	subi	r30, 0xAE	; 174
    bf2e:	ff 4f       	sbci	r31, 0xFF	; 255
    bf30:	01 90       	ld	r0, Z+
    bf32:	f0 81       	ld	r31, Z
    bf34:	e0 2d       	mov	r30, r0
    bf36:	8d 91       	ld	r24, X+
    bf38:	9c 91       	ld	r25, X
    bf3a:	09 95       	icall
}
    bf3c:	08 95       	ret

0000bf3e <PMDGetCMotionVersion>:

void PMDGetCMotionVersion(PMDuint8* MajorVersion, PMDuint8* MinorVersion)
{
    bf3e:	fc 01       	movw	r30, r24
    bf40:	db 01       	movw	r26, r22
	*MajorVersion = CMOTION_MAJOR_VERSION;
    bf42:	81 e0       	ldi	r24, 0x01	; 1
    bf44:	80 83       	st	Z, r24
	*MinorVersion = CMOTION_MINOR_VERSION;
    bf46:	85 e0       	ldi	r24, 0x05	; 5
    bf48:	8c 93       	st	X, r24
}
    bf4a:	08 95       	ret

0000bf4c <PMDGetSynchronizationMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetSynchronizationMode, mode);
}

PMDresult PMDGetSynchronizationMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    bf4c:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSynchronizationMode, mode);
    bf4e:	63 ef       	ldi	r22, 0xF3	; 243
    bf50:	70 e0       	ldi	r23, 0x00	; 0
    bf52:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    bf56:	08 95       	ret

0000bf58 <PMDGetStepRange>:
{
	return SendCommandWord(axis_handle, PMDOPSetStepRange, range);
}

PMDresult PMDGetStepRange(PMDAxisHandle* axis_handle, PMDuint16* range)
{
    bf58:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetStepRange, range);
    bf5a:	6e ec       	ldi	r22, 0xCE	; 206
    bf5c:	70 e0       	ldi	r23, 0x00	; 0
    bf5e:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    bf62:	08 95       	ret

0000bf64 <PMDGetDiagnosticPortMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetDiagnosticPortMode, mode);
}

PMDresult PMDGetDiagnosticPortMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    bf64:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetDiagnosticPortMode, mode);
    bf66:	6a e8       	ldi	r22, 0x8A	; 138
    bf68:	70 e0       	ldi	r23, 0x00	; 0
    bf6a:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    bf6e:	08 95       	ret

0000bf70 <PMDGetSerialPortMode>:
	return SendCommandWord(axis_handle, PMDOPSetSerialPortMode, serialData);
}

PMDresult PMDGetSerialPortMode(PMDAxisHandle* axis_handle, PMDuint8* baud, PMDuint8* parity, 
					PMDuint8* stopBits, PMDuint8* protocol, PMDuint8* multiDropID)
{
    bf70:	8f 92       	push	r8
    bf72:	9f 92       	push	r9
    bf74:	af 92       	push	r10
    bf76:	bf 92       	push	r11
    bf78:	cf 92       	push	r12
    bf7a:	df 92       	push	r13
    bf7c:	ef 92       	push	r14
    bf7e:	ff 92       	push	r15
    bf80:	0f 93       	push	r16
    bf82:	1f 93       	push	r17
    bf84:	df 93       	push	r29
    bf86:	cf 93       	push	r28
    bf88:	00 d0       	rcall	.+0      	; 0xbf8a <PMDGetSerialPortMode+0x1a>
    bf8a:	cd b7       	in	r28, 0x3d	; 61
    bf8c:	de b7       	in	r29, 0x3e	; 62
    bf8e:	6b 01       	movw	r12, r22
    bf90:	5a 01       	movw	r10, r20
    bf92:	49 01       	movw	r8, r18
	PMDuint16 serialData;
	PMDuint16 result;

	result = SendCommandGetWord(axis_handle, PMDOPGetSerialPortMode, &serialData);
    bf94:	6c e8       	ldi	r22, 0x8C	; 140
    bf96:	70 e0       	ldi	r23, 0x00	; 0
    bf98:	ae 01       	movw	r20, r28
    bf9a:	4f 5f       	subi	r20, 0xFF	; 255
    bf9c:	5f 4f       	sbci	r21, 0xFF	; 255
    bf9e:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>

	*baud = (PMDuint8)(serialData & 0x000F);
    bfa2:	29 81       	ldd	r18, Y+1	; 0x01
    bfa4:	2f 70       	andi	r18, 0x0F	; 15
    bfa6:	f6 01       	movw	r30, r12
    bfa8:	20 83       	st	Z, r18
	*parity = (PMDuint8)((serialData & 0x0030) >> 4);
    bfaa:	49 81       	ldd	r20, Y+1	; 0x01
    bfac:	5a 81       	ldd	r21, Y+2	; 0x02
    bfae:	9a 01       	movw	r18, r20
    bfb0:	20 73       	andi	r18, 0x30	; 48
    bfb2:	30 70       	andi	r19, 0x00	; 0
    bfb4:	74 e0       	ldi	r23, 0x04	; 4
    bfb6:	36 95       	lsr	r19
    bfb8:	27 95       	ror	r18
    bfba:	7a 95       	dec	r23
    bfbc:	e1 f7       	brne	.-8      	; 0xbfb6 <PMDGetSerialPortMode+0x46>
    bfbe:	f5 01       	movw	r30, r10
    bfc0:	20 83       	st	Z, r18
	*stopBits = (PMDuint8)((serialData & 0x0040) >> 6);
    bfc2:	9a 01       	movw	r18, r20
    bfc4:	20 74       	andi	r18, 0x40	; 64
    bfc6:	30 70       	andi	r19, 0x00	; 0
    bfc8:	66 e0       	ldi	r22, 0x06	; 6
    bfca:	36 95       	lsr	r19
    bfcc:	27 95       	ror	r18
    bfce:	6a 95       	dec	r22
    bfd0:	e1 f7       	brne	.-8      	; 0xbfca <PMDGetSerialPortMode+0x5a>
    bfd2:	f4 01       	movw	r30, r8
    bfd4:	20 83       	st	Z, r18
	*protocol = (PMDuint8)((serialData & 0x0180) >> 7);
    bfd6:	40 78       	andi	r20, 0x80	; 128
    bfd8:	51 70       	andi	r21, 0x01	; 1
    bfda:	44 0f       	add	r20, r20
    bfdc:	45 2f       	mov	r20, r21
    bfde:	44 1f       	adc	r20, r20
    bfe0:	55 0b       	sbc	r21, r21
    bfe2:	51 95       	neg	r21
    bfe4:	f8 01       	movw	r30, r16
    bfe6:	40 83       	st	Z, r20
	*multiDropID = (PMDuint8)((serialData & 0xF800) >> 11);
    bfe8:	2a 81       	ldd	r18, Y+2	; 0x02
    bfea:	26 95       	lsr	r18
    bfec:	26 95       	lsr	r18
    bfee:	26 95       	lsr	r18
    bff0:	f7 01       	movw	r30, r14
    bff2:	20 83       	st	Z, r18

	return result;
}
    bff4:	0f 90       	pop	r0
    bff6:	0f 90       	pop	r0
    bff8:	cf 91       	pop	r28
    bffa:	df 91       	pop	r29
    bffc:	1f 91       	pop	r17
    bffe:	0f 91       	pop	r16
    c000:	ff 90       	pop	r15
    c002:	ef 90       	pop	r14
    c004:	df 90       	pop	r13
    c006:	cf 90       	pop	r12
    c008:	bf 90       	pop	r11
    c00a:	af 90       	pop	r10
    c00c:	9f 90       	pop	r9
    c00e:	8f 90       	pop	r8
    c010:	08 95       	ret

0000c012 <PMDGetHostIOError>:

	return result;
}

PMDresult PMDGetHostIOError(PMDAxisHandle* axis_handle, PMDuint16 *hostIOError)
{
    c012:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetHostIOError, hostIOError);
    c014:	65 ea       	ldi	r22, 0xA5	; 165
    c016:	70 e0       	ldi	r23, 0x00	; 0
    c018:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c01c:	08 95       	ret

0000c01e <PMDGetAxisOutSource>:
		
	return SendCommandWord(axis_handle, PMDOPSetAxisOutSource, value);
}

PMDresult PMDGetAxisOutSource(PMDAxisHandle* axis_handle, PMDAxis* sourceAxis, PMDuint8* bit, PMDuint8* sourceRegister)
{
    c01e:	cf 92       	push	r12
    c020:	df 92       	push	r13
    c022:	ef 92       	push	r14
    c024:	ff 92       	push	r15
    c026:	0f 93       	push	r16
    c028:	1f 93       	push	r17
    c02a:	df 93       	push	r29
    c02c:	cf 93       	push	r28
    c02e:	00 d0       	rcall	.+0      	; 0xc030 <PMDGetAxisOutSource+0x12>
    c030:	cd b7       	in	r28, 0x3d	; 61
    c032:	de b7       	in	r29, 0x3e	; 62
    c034:	8b 01       	movw	r16, r22
    c036:	7a 01       	movw	r14, r20
    c038:	69 01       	movw	r12, r18
	PMDuint16 result;
	PMDuint16 value;

	result = SendCommandGetWord(axis_handle, PMDOPGetAxisOutSource, &value);
    c03a:	6e ee       	ldi	r22, 0xEE	; 238
    c03c:	70 e0       	ldi	r23, 0x00	; 0
    c03e:	ae 01       	movw	r20, r28
    c040:	4f 5f       	subi	r20, 0xFF	; 255
    c042:	5f 4f       	sbci	r21, 0xFF	; 255
    c044:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>

	*sourceAxis = (PMDAxis)(value & nibbleMask);
    c048:	29 81       	ldd	r18, Y+1	; 0x01
    c04a:	3a 81       	ldd	r19, Y+2	; 0x02
    c04c:	a9 01       	movw	r20, r18
    c04e:	4f 70       	andi	r20, 0x0F	; 15
    c050:	50 70       	andi	r21, 0x00	; 0
    c052:	f8 01       	movw	r30, r16
    c054:	51 83       	std	Z+1, r21	; 0x01
    c056:	40 83       	st	Z, r20

	value = (PMDuint16)(value >> 4);
    c058:	f4 e0       	ldi	r31, 0x04	; 4
    c05a:	36 95       	lsr	r19
    c05c:	27 95       	ror	r18
    c05e:	fa 95       	dec	r31
    c060:	e1 f7       	brne	.-8      	; 0xc05a <PMDGetAxisOutSource+0x3c>
	*bit = (PMDuint8)(value & nibbleMask);
    c062:	42 2f       	mov	r20, r18
    c064:	4f 70       	andi	r20, 0x0F	; 15
    c066:	f7 01       	movw	r30, r14
    c068:	40 83       	st	Z, r20

	value = (PMDuint16)(value >> 4);
    c06a:	e4 e0       	ldi	r30, 0x04	; 4
    c06c:	36 95       	lsr	r19
    c06e:	27 95       	ror	r18
    c070:	ea 95       	dec	r30
    c072:	e1 f7       	brne	.-8      	; 0xc06c <PMDGetAxisOutSource+0x4e>
	*sourceRegister = (PMDuint8)(value & nibbleMask);
    c074:	2f 70       	andi	r18, 0x0F	; 15
    c076:	f6 01       	movw	r30, r12
    c078:	20 83       	st	Z, r18

	return result;
}
    c07a:	0f 90       	pop	r0
    c07c:	0f 90       	pop	r0
    c07e:	cf 91       	pop	r28
    c080:	df 91       	pop	r29
    c082:	1f 91       	pop	r17
    c084:	0f 91       	pop	r16
    c086:	ff 90       	pop	r15
    c088:	ef 90       	pop	r14
    c08a:	df 90       	pop	r13
    c08c:	cf 90       	pop	r12
    c08e:	08 95       	ret

0000c090 <PMDGetAxisMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetAxisMode, mode);
}

PMDresult PMDGetAxisMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c090:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetAxisMode, mode);
    c092:	68 e8       	ldi	r22, 0x88	; 136
    c094:	70 e0       	ldi	r23, 0x00	; 0
    c096:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c09a:	08 95       	ret

0000c09c <PMDGetTraceStatus>:
	return result;
}


PMDresult PMDGetTraceStatus(PMDAxisHandle* axis_handle, PMDuint16* status)
{
    c09c:	ef 92       	push	r14
    c09e:	ff 92       	push	r15
    c0a0:	0f 93       	push	r16
    c0a2:	1f 93       	push	r17
    c0a4:	8c 01       	movw	r16, r24
    c0a6:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    c0a8:	fc 01       	movw	r30, r24
    c0aa:	e2 80       	ldd	r14, Z+2	; 0x02
    c0ac:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    c0ae:	13 82       	std	Z+3, r1	; 0x03
    c0b0:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetWord(axis_handle, PMDOPGetTraceStatus, status);
    c0b2:	6a eb       	ldi	r22, 0xBA	; 186
    c0b4:	70 e0       	ldi	r23, 0x00	; 0
    c0b6:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>

	axis_handle->axis = axis;
    c0ba:	f8 01       	movw	r30, r16
    c0bc:	f3 82       	std	Z+3, r15	; 0x03
    c0be:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    c0c0:	1f 91       	pop	r17
    c0c2:	0f 91       	pop	r16
    c0c4:	ff 90       	pop	r15
    c0c6:	ef 90       	pop	r14
    c0c8:	08 95       	ret

0000c0ca <PMDGetTraceStop>:

	return result;
}

PMDresult PMDGetTraceStop(PMDAxisHandle* axis_handle, PMDAxis *traceAxis, PMDuint8* condition, PMDuint8* bit, PMDuint8* state)
{
    c0ca:	6f 92       	push	r6
    c0cc:	7f 92       	push	r7
    c0ce:	8f 92       	push	r8
    c0d0:	9f 92       	push	r9
    c0d2:	af 92       	push	r10
    c0d4:	bf 92       	push	r11
    c0d6:	cf 92       	push	r12
    c0d8:	df 92       	push	r13
    c0da:	ef 92       	push	r14
    c0dc:	ff 92       	push	r15
    c0de:	0f 93       	push	r16
    c0e0:	1f 93       	push	r17
    c0e2:	df 93       	push	r29
    c0e4:	cf 93       	push	r28
    c0e6:	00 d0       	rcall	.+0      	; 0xc0e8 <PMDGetTraceStop+0x1e>
    c0e8:	cd b7       	in	r28, 0x3d	; 61
    c0ea:	de b7       	in	r29, 0x3e	; 62
    c0ec:	7c 01       	movw	r14, r24
    c0ee:	6b 01       	movw	r12, r22
    c0f0:	5a 01       	movw	r10, r20
    c0f2:	49 01       	movw	r8, r18
	PMDuint16 result;
	PMDuint16 value;
	PMDAxis axis = axis_handle->axis;
    c0f4:	fc 01       	movw	r30, r24
    c0f6:	62 80       	ldd	r6, Z+2	; 0x02
    c0f8:	73 80       	ldd	r7, Z+3	; 0x03

	// set the axis number to zero
	axis_handle->axis = 0;
    c0fa:	13 82       	std	Z+3, r1	; 0x03
    c0fc:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetWord(axis_handle, PMDOPGetTraceStop, &value);
    c0fe:	65 eb       	ldi	r22, 0xB5	; 181
    c100:	70 e0       	ldi	r23, 0x00	; 0
    c102:	ae 01       	movw	r20, r28
    c104:	4f 5f       	subi	r20, 0xFF	; 255
    c106:	5f 4f       	sbci	r21, 0xFF	; 255
    c108:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
	*traceAxis = (PMDAxis)((value & nibbleMask));
    c10c:	29 81       	ldd	r18, Y+1	; 0x01
    c10e:	3a 81       	ldd	r19, Y+2	; 0x02
    c110:	a9 01       	movw	r20, r18
    c112:	4f 70       	andi	r20, 0x0F	; 15
    c114:	50 70       	andi	r21, 0x00	; 0
    c116:	f6 01       	movw	r30, r12
    c118:	51 83       	std	Z+1, r21	; 0x01
    c11a:	40 83       	st	Z, r20
	*condition = (PMDuint8)((value >> 4) & nibbleMask);
    c11c:	a4 e0       	ldi	r26, 0x04	; 4
    c11e:	36 95       	lsr	r19
    c120:	27 95       	ror	r18
    c122:	aa 95       	dec	r26
    c124:	e1 f7       	brne	.-8      	; 0xc11e <PMDGetTraceStop+0x54>
    c126:	2f 70       	andi	r18, 0x0F	; 15
    c128:	f5 01       	movw	r30, r10
    c12a:	20 83       	st	Z, r18
	*bit = (PMDuint8)((value >> 8) & nibbleMask);
    c12c:	2a 81       	ldd	r18, Y+2	; 0x02
    c12e:	32 2f       	mov	r19, r18
    c130:	3f 70       	andi	r19, 0x0F	; 15
    c132:	f4 01       	movw	r30, r8
    c134:	30 83       	st	Z, r19
	*state = (PMDuint8)((value >> 12) & nibbleMask);
    c136:	22 95       	swap	r18
    c138:	2f 70       	andi	r18, 0x0F	; 15
    c13a:	f8 01       	movw	r30, r16
    c13c:	20 83       	st	Z, r18

	axis_handle->axis = axis;
    c13e:	f7 01       	movw	r30, r14
    c140:	73 82       	std	Z+3, r7	; 0x03
    c142:	62 82       	std	Z+2, r6	; 0x02

	return result;
}
    c144:	0f 90       	pop	r0
    c146:	0f 90       	pop	r0
    c148:	cf 91       	pop	r28
    c14a:	df 91       	pop	r29
    c14c:	1f 91       	pop	r17
    c14e:	0f 91       	pop	r16
    c150:	ff 90       	pop	r15
    c152:	ef 90       	pop	r14
    c154:	df 90       	pop	r13
    c156:	cf 90       	pop	r12
    c158:	bf 90       	pop	r11
    c15a:	af 90       	pop	r10
    c15c:	9f 90       	pop	r9
    c15e:	8f 90       	pop	r8
    c160:	7f 90       	pop	r7
    c162:	6f 90       	pop	r6
    c164:	08 95       	ret

0000c166 <PMDGetTraceStart>:

	return result;
}

PMDresult PMDGetTraceStart(PMDAxisHandle* axis_handle, PMDAxis *traceAxis, PMDuint8* condition, PMDuint8* bit, PMDuint8* state)
{
    c166:	6f 92       	push	r6
    c168:	7f 92       	push	r7
    c16a:	8f 92       	push	r8
    c16c:	9f 92       	push	r9
    c16e:	af 92       	push	r10
    c170:	bf 92       	push	r11
    c172:	cf 92       	push	r12
    c174:	df 92       	push	r13
    c176:	ef 92       	push	r14
    c178:	ff 92       	push	r15
    c17a:	0f 93       	push	r16
    c17c:	1f 93       	push	r17
    c17e:	df 93       	push	r29
    c180:	cf 93       	push	r28
    c182:	00 d0       	rcall	.+0      	; 0xc184 <PMDGetTraceStart+0x1e>
    c184:	cd b7       	in	r28, 0x3d	; 61
    c186:	de b7       	in	r29, 0x3e	; 62
    c188:	7c 01       	movw	r14, r24
    c18a:	6b 01       	movw	r12, r22
    c18c:	5a 01       	movw	r10, r20
    c18e:	49 01       	movw	r8, r18
	PMDuint16 result;
	PMDuint16 value;
	PMDAxis axis = axis_handle->axis;
    c190:	fc 01       	movw	r30, r24
    c192:	62 80       	ldd	r6, Z+2	; 0x02
    c194:	73 80       	ldd	r7, Z+3	; 0x03

	// set the axis number to zero
	axis_handle->axis = 0;
    c196:	13 82       	std	Z+3, r1	; 0x03
    c198:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetWord(axis_handle, PMDOPGetTraceStart, &value);
    c19a:	63 eb       	ldi	r22, 0xB3	; 179
    c19c:	70 e0       	ldi	r23, 0x00	; 0
    c19e:	ae 01       	movw	r20, r28
    c1a0:	4f 5f       	subi	r20, 0xFF	; 255
    c1a2:	5f 4f       	sbci	r21, 0xFF	; 255
    c1a4:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
	*traceAxis = (PMDAxis)((value & nibbleMask));
    c1a8:	29 81       	ldd	r18, Y+1	; 0x01
    c1aa:	3a 81       	ldd	r19, Y+2	; 0x02
    c1ac:	a9 01       	movw	r20, r18
    c1ae:	4f 70       	andi	r20, 0x0F	; 15
    c1b0:	50 70       	andi	r21, 0x00	; 0
    c1b2:	f6 01       	movw	r30, r12
    c1b4:	51 83       	std	Z+1, r21	; 0x01
    c1b6:	40 83       	st	Z, r20
	*condition = (PMDuint8)((value >> 4) & nibbleMask);
    c1b8:	b4 e0       	ldi	r27, 0x04	; 4
    c1ba:	36 95       	lsr	r19
    c1bc:	27 95       	ror	r18
    c1be:	ba 95       	dec	r27
    c1c0:	e1 f7       	brne	.-8      	; 0xc1ba <PMDGetTraceStart+0x54>
    c1c2:	2f 70       	andi	r18, 0x0F	; 15
    c1c4:	f5 01       	movw	r30, r10
    c1c6:	20 83       	st	Z, r18
	*bit = (PMDuint8)((value >> 8) & nibbleMask);
    c1c8:	2a 81       	ldd	r18, Y+2	; 0x02
    c1ca:	32 2f       	mov	r19, r18
    c1cc:	3f 70       	andi	r19, 0x0F	; 15
    c1ce:	f4 01       	movw	r30, r8
    c1d0:	30 83       	st	Z, r19
	*state = (PMDuint8)((value >> 12) & nibbleMask);
    c1d2:	22 95       	swap	r18
    c1d4:	2f 70       	andi	r18, 0x0F	; 15
    c1d6:	f8 01       	movw	r30, r16
    c1d8:	20 83       	st	Z, r18

	axis_handle->axis = axis;
    c1da:	f7 01       	movw	r30, r14
    c1dc:	73 82       	std	Z+3, r7	; 0x03
    c1de:	62 82       	std	Z+2, r6	; 0x02

	return result;
}
    c1e0:	0f 90       	pop	r0
    c1e2:	0f 90       	pop	r0
    c1e4:	cf 91       	pop	r28
    c1e6:	df 91       	pop	r29
    c1e8:	1f 91       	pop	r17
    c1ea:	0f 91       	pop	r16
    c1ec:	ff 90       	pop	r15
    c1ee:	ef 90       	pop	r14
    c1f0:	df 90       	pop	r13
    c1f2:	cf 90       	pop	r12
    c1f4:	bf 90       	pop	r11
    c1f6:	af 90       	pop	r10
    c1f8:	9f 90       	pop	r9
    c1fa:	8f 90       	pop	r8
    c1fc:	7f 90       	pop	r7
    c1fe:	6f 90       	pop	r6
    c200:	08 95       	ret

0000c202 <PMDGetTracePeriod>:

	return result;
}

PMDresult PMDGetTracePeriod(PMDAxisHandle* axis_handle, PMDuint16* tracePeriod)
{
    c202:	ef 92       	push	r14
    c204:	ff 92       	push	r15
    c206:	0f 93       	push	r16
    c208:	1f 93       	push	r17
    c20a:	8c 01       	movw	r16, r24
    c20c:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    c20e:	fc 01       	movw	r30, r24
    c210:	e2 80       	ldd	r14, Z+2	; 0x02
    c212:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    c214:	13 82       	std	Z+3, r1	; 0x03
    c216:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetWord(axis_handle, PMDOPGetTracePeriod, tracePeriod);
    c218:	69 eb       	ldi	r22, 0xB9	; 185
    c21a:	70 e0       	ldi	r23, 0x00	; 0
    c21c:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>

	axis_handle->axis = axis;
    c220:	f8 01       	movw	r30, r16
    c222:	f3 82       	std	Z+3, r15	; 0x03
    c224:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    c226:	1f 91       	pop	r17
    c228:	0f 91       	pop	r16
    c22a:	ff 90       	pop	r15
    c22c:	ef 90       	pop	r14
    c22e:	08 95       	ret

0000c230 <PMDGetTraceMode>:

	return result;
}

PMDresult PMDGetTraceMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c230:	ef 92       	push	r14
    c232:	ff 92       	push	r15
    c234:	0f 93       	push	r16
    c236:	1f 93       	push	r17
    c238:	8c 01       	movw	r16, r24
    c23a:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    c23c:	fc 01       	movw	r30, r24
    c23e:	e2 80       	ldd	r14, Z+2	; 0x02
    c240:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    c242:	13 82       	std	Z+3, r1	; 0x03
    c244:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetWord(axis_handle, PMDOPGetTraceMode, mode);
    c246:	61 eb       	ldi	r22, 0xB1	; 177
    c248:	70 e0       	ldi	r23, 0x00	; 0
    c24a:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>

	axis_handle->axis = axis;
    c24e:	f8 01       	movw	r30, r16
    c250:	f3 82       	std	Z+3, r15	; 0x03
    c252:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    c254:	1f 91       	pop	r17
    c256:	0f 91       	pop	r16
    c258:	ff 90       	pop	r15
    c25a:	ef 90       	pop	r14
    c25c:	08 95       	ret

0000c25e <PMDGetPhaseCorrectionMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseCorrectionMode, mode);
}

PMDresult PMDGetPhaseCorrectionMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c25e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseCorrectionMode, mode);
    c260:	69 ee       	ldi	r22, 0xE9	; 233
    c262:	70 e0       	ldi	r23, 0x00	; 0
    c264:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c268:	08 95       	ret

0000c26a <PMDGetPhaseAngle>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseAngle, phaseAngle);
}

PMDresult PMDGetPhaseAngle(PMDAxisHandle* axis_handle, PMDuint16* phaseAngle)
{
    c26a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseAngle, phaseAngle);
    c26c:	6c e2       	ldi	r22, 0x2C	; 44
    c26e:	70 e0       	ldi	r23, 0x00	; 0
    c270:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c274:	08 95       	ret

0000c276 <PMDGetPhaseOffset>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseOffset, phaseOffset);
}

PMDresult PMDGetPhaseOffset(PMDAxisHandle* axis_handle, PMDuint16* phaseOffset)
{
    c276:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseOffset, phaseOffset);
    c278:	6b e7       	ldi	r22, 0x7B	; 123
    c27a:	70 e0       	ldi	r23, 0x00	; 0
    c27c:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c280:	08 95       	ret

0000c282 <PMDGetPhaseInitializeTime>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseInitializeTime, phaseInitTime);
}

PMDresult PMDGetPhaseInitializeTime(PMDAxisHandle* axis_handle, PMDuint16* phaseInitTime)
{
    c282:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseInitializeTime, phaseInitTime);
    c284:	6c e7       	ldi	r22, 0x7C	; 124
    c286:	70 e0       	ldi	r23, 0x00	; 0
    c288:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c28c:	08 95       	ret

0000c28e <PMDGetPhaseCounts>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseCounts, phaseCounts);
}

PMDresult PMDGetPhaseCounts(PMDAxisHandle* axis_handle, PMDuint16* phaseCounts)
{
    c28e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseCounts, phaseCounts);
    c290:	6d e7       	ldi	r22, 0x7D	; 125
    c292:	70 e0       	ldi	r23, 0x00	; 0
    c294:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c298:	08 95       	ret

0000c29a <PMDGetPhasePrescale>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhasePrescale, phasePrescale);
}

PMDresult PMDGetPhasePrescale(PMDAxisHandle* axis_handle, PMDuint16* phasePrescale)
{
    c29a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhasePrescale, phasePrescale);
    c29c:	67 ee       	ldi	r22, 0xE7	; 231
    c29e:	70 e0       	ldi	r23, 0x00	; 0
    c2a0:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c2a4:	08 95       	ret

0000c2a6 <PMDGetPhaseInitializeMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseInitializeMode, mode);
}

PMDresult PMDGetPhaseInitializeMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c2a6:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseInitializeMode, mode);
    c2a8:	65 ee       	ldi	r22, 0xE5	; 229
    c2aa:	70 e0       	ldi	r23, 0x00	; 0
    c2ac:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c2b0:	08 95       	ret

0000c2b2 <PMDGetNumberPhases>:
{
	return SendCommandWord(axis_handle, PMDOPSetNumberPhases, numberPhases);
}

PMDresult PMDGetNumberPhases(PMDAxisHandle* axis_handle, PMDuint16* numberPhases)
{
    c2b2:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetNumberPhases, numberPhases);
    c2b4:	66 e8       	ldi	r22, 0x86	; 134
    c2b6:	70 e0       	ldi	r23, 0x00	; 0
    c2b8:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c2bc:	08 95       	ret

0000c2be <PMDGetCommutationMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetCommutationMode, mode);
}

PMDresult PMDGetCommutationMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c2be:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetCommutationMode, mode);
    c2c0:	63 ee       	ldi	r22, 0xE3	; 227
    c2c2:	70 e0       	ldi	r23, 0x00	; 0
    c2c4:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c2c8:	08 95       	ret

0000c2ca <PMDGetCurrentMotorCommand>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetMotorCommand, (PMDuint16*)motorCommand);
}

PMDresult PMDGetCurrentMotorCommand(PMDAxisHandle* axis_handle, PMDint16* motorCommand)
{
    c2ca:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetCurrentMotorCommand, (PMDuint16*)motorCommand);
    c2cc:	6a e3       	ldi	r22, 0x3A	; 58
    c2ce:	70 e0       	ldi	r23, 0x00	; 0
    c2d0:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c2d4:	08 95       	ret

0000c2d6 <PMDGetMotorCommand>:
{
	return SendCommandWord(axis_handle, PMDOPSetMotorCommand, (PMDuint16)motorCommand);
}

PMDresult PMDGetMotorCommand(PMDAxisHandle* axis_handle, PMDint16* motorCommand)
{
    c2d6:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetMotorCommand, (PMDuint16*)motorCommand);
    c2d8:	69 e6       	ldi	r22, 0x69	; 105
    c2da:	70 e0       	ldi	r23, 0x00	; 0
    c2dc:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c2e0:	08 95       	ret

0000c2e2 <PMDGetMotorMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetMotorMode, mode);
}

PMDresult PMDGetMotorMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c2e2:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetMotorMode, mode);
    c2e4:	6d ed       	ldi	r22, 0xDD	; 221
    c2e6:	70 e0       	ldi	r23, 0x00	; 0
    c2e8:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c2ec:	08 95       	ret

0000c2ee <PMDGetOutputMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetOutputMode, mode);
}

PMDresult PMDGetOutputMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c2ee:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetOutputMode, mode);
    c2f0:	6e e6       	ldi	r22, 0x6E	; 110
    c2f2:	70 e0       	ldi	r23, 0x00	; 0
    c2f4:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c2f8:	08 95       	ret

0000c2fa <PMDGetEncoderModulus>:
{
	return SendCommandWord(axis_handle, PMDOPSetEncoderModulus, modulus);
}

PMDresult PMDGetEncoderModulus(PMDAxisHandle* axis_handle, PMDuint16* modulus)
{
    c2fa:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetEncoderModulus, modulus);
    c2fc:	6e e8       	ldi	r22, 0x8E	; 142
    c2fe:	70 e0       	ldi	r23, 0x00	; 0
    c300:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c304:	08 95       	ret

0000c306 <PMDGetEncoderSource>:
{
	return SendCommandWord(axis_handle, PMDOPSetEncoderSource, encoderSource);
}

PMDresult PMDGetEncoderSource(PMDAxisHandle* axis_handle, PMDuint16* encoderSource)
{
    c306:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetEncoderSource, encoderSource);
    c308:	6b ed       	ldi	r22, 0xDB	; 219
    c30a:	70 e0       	ldi	r23, 0x00	; 0
    c30c:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c310:	08 95       	ret

0000c312 <PMDGetCaptureSource>:
{
	return SendCommandWord(axis_handle, PMDOPSetCaptureSource, captureSource);
}

PMDresult PMDGetCaptureSource(PMDAxisHandle* axis_handle, PMDuint16* captureSource)
{
    c312:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetCaptureSource, captureSource);
    c314:	69 ed       	ldi	r22, 0xD9	; 217
    c316:	70 e0       	ldi	r23, 0x00	; 0
    c318:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c31c:	08 95       	ret

0000c31e <PMDGetActualPositionUnits>:
{
	return SendCommandWord(axis_handle, PMDOPSetActualPositionUnits, mode);
}

PMDresult PMDGetActualPositionUnits(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c31e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetActualPositionUnits, mode);
    c320:	6f eb       	ldi	r22, 0xBF	; 191
    c322:	70 e0       	ldi	r23, 0x00	; 0
    c324:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c328:	08 95       	ret

0000c32a <PMDGetSignalStatus>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetSignalSense, mask);
}

PMDresult PMDGetSignalStatus(PMDAxisHandle* axis_handle, PMDuint16* signalStatus)
{
    c32a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSignalStatus, signalStatus);
    c32c:	64 ea       	ldi	r22, 0xA4	; 164
    c32e:	70 e0       	ldi	r23, 0x00	; 0
    c330:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c334:	08 95       	ret

0000c336 <PMDGetSignalSense>:
{
	return SendCommandWord(axis_handle, PMDOPSetSignalSense, mask);
}

PMDresult PMDGetSignalSense(PMDAxisHandle* axis_handle, PMDuint16* mask)
{
    c336:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSignalSense, mask);
    c338:	63 ea       	ldi	r22, 0xA3	; 163
    c33a:	70 e0       	ldi	r23, 0x00	; 0
    c33c:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c340:	08 95       	ret

0000c342 <PMDGetActivityStatus>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetEventStatus, eventStatus);
}

PMDresult PMDGetActivityStatus(PMDAxisHandle* axis_handle, PMDuint16* activityStatus)
{
    c342:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetActivityStatus, activityStatus);
    c344:	66 ea       	ldi	r22, 0xA6	; 166
    c346:	70 e0       	ldi	r23, 0x00	; 0
    c348:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c34c:	08 95       	ret

0000c34e <PMDGetEventStatus>:
{
	return SendCommandWord(axis_handle, PMDOPResetEventStatus, eventStatus);
}

PMDresult PMDGetEventStatus(PMDAxisHandle* axis_handle, PMDuint16* eventStatus)
{
    c34e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetEventStatus, eventStatus);
    c350:	61 e3       	ldi	r22, 0x31	; 49
    c352:	70 e0       	ldi	r23, 0x00	; 0
    c354:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c358:	08 95       	ret

0000c35a <PMDGetInterruptAxis>:

	return result;
}

PMDresult PMDGetInterruptAxis(PMDAxisHandle* axis_handle, PMDuint16* interruptingAxisMask)
{
    c35a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetInterruptAxis, interruptingAxisMask);
    c35c:	61 ee       	ldi	r22, 0xE1	; 225
    c35e:	70 e0       	ldi	r23, 0x00	; 0
    c360:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c364:	08 95       	ret

0000c366 <PMDGetInterruptMask>:
{
	return SendCommandWord(axis_handle, PMDOPSetInterruptMask, interruptMask);
}

PMDresult PMDGetInterruptMask(PMDAxisHandle* axis_handle, PMDuint16* interruptMask)
{
    c366:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetInterruptMask, interruptMask);
    c368:	66 e5       	ldi	r22, 0x56	; 86
    c36a:	70 e0       	ldi	r23, 0x00	; 0
    c36c:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c370:	08 95       	ret

0000c372 <PMDGetSampleTime>:
{
	return SendCommandWord(axis_handle, PMDOPSetSampleTime, sampleTime);
}

PMDresult PMDGetSampleTime(PMDAxisHandle* axis_handle, PMDuint16* sampleTime)
{
    c372:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSampleTime, sampleTime);
    c374:	61 e6       	ldi	r22, 0x61	; 97
    c376:	70 e0       	ldi	r23, 0x00	; 0
    c378:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c37c:	08 95       	ret

0000c37e <PMDGetDerivative>:
{
	return SendCommand(axis_handle, PMDOPClearPositionError);
}

PMDresult PMDGetDerivative(PMDAxisHandle* axis_handle, PMDint16* derivative)
{
    c37e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetDerivative, (PMDuint16*)derivative);
    c380:	6b e9       	ldi	r22, 0x9B	; 155
    c382:	70 e0       	ldi	r23, 0x00	; 0
    c384:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c388:	08 95       	ret

0000c38a <PMDGetMotionCompleteMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetMotionCompleteMode, mode);
}

PMDresult PMDGetMotionCompleteMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c38a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetMotionCompleteMode, mode);
    c38c:	6c ee       	ldi	r22, 0xEC	; 236
    c38e:	70 e0       	ldi	r23, 0x00	; 0
    c390:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c394:	08 95       	ret

0000c396 <PMDGetTrackingWindow>:
{
	return SendCommandWord(axis_handle, PMDOPSetTrackingWindow, trackingWindow);
}

PMDresult PMDGetTrackingWindow(PMDAxisHandle* axis_handle, PMDuint16* trackingWindow)
{
    c396:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetTrackingWindow, trackingWindow);
    c398:	69 ea       	ldi	r22, 0xA9	; 169
    c39a:	70 e0       	ldi	r23, 0x00	; 0
    c39c:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c3a0:	08 95       	ret

0000c3a2 <PMDGetSettleWindow>:
{
	return SendCommandWord(axis_handle, PMDOPSetSettleWindow, settleWindow);
}

PMDresult PMDGetSettleWindow(PMDAxisHandle* axis_handle, PMDuint16* settleWindow)
{
    c3a2:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSettleWindow, settleWindow);
    c3a4:	6d eb       	ldi	r22, 0xBD	; 189
    c3a6:	70 e0       	ldi	r23, 0x00	; 0
    c3a8:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c3ac:	08 95       	ret

0000c3ae <PMDGetSettleTime>:
{
	return SendCommandWord(axis_handle, PMDOPSetSettleTime, settleTime);
}

PMDresult PMDGetSettleTime(PMDAxisHandle* axis_handle, PMDuint16* settleTime)
{
    c3ae:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSettleTime, settleTime);
    c3b0:	6b ea       	ldi	r22, 0xAB	; 171
    c3b2:	70 e0       	ldi	r23, 0x00	; 0
    c3b4:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c3b8:	08 95       	ret

0000c3ba <PMDGetDerivativeTime>:
{
	return SendCommandWord(axis_handle, PMDOPSetDerivativeTime, derivativeTime);
}

PMDresult PMDGetDerivativeTime(PMDAxisHandle* axis_handle, PMDuint16* derivativeTime)
{
    c3ba:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetDerivativeTime, derivativeTime);
    c3bc:	6d e9       	ldi	r22, 0x9D	; 157
    c3be:	70 e0       	ldi	r23, 0x00	; 0
    c3c0:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c3c4:	08 95       	ret

0000c3c6 <PMDGetAutoStopMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetAutoStopMode, mode);
}

PMDresult PMDGetAutoStopMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c3c6:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetAutoStopMode, mode);
    c3c8:	63 ed       	ldi	r22, 0xD3	; 211
    c3ca:	70 e0       	ldi	r23, 0x00	; 0
    c3cc:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c3d0:	08 95       	ret

0000c3d2 <PMDGetMotorBias>:
{
	return SendCommandWord(axis_handle, PMDOPSetMotorBias, (PMDuint16)bias);
}

PMDresult PMDGetMotorBias(PMDAxisHandle* axis_handle, PMDint16* bias)
{
    c3d2:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetMotorBias, (PMDuint16*)bias);
    c3d4:	6d e2       	ldi	r22, 0x2D	; 45
    c3d6:	70 e0       	ldi	r23, 0x00	; 0
    c3d8:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c3dc:	08 95       	ret

0000c3de <PMDGetMotorLimit>:
{
	return SendCommandWord(axis_handle, PMDOPSetMotorLimit, limit);
}

PMDresult PMDGetMotorLimit(PMDAxisHandle* axis_handle, PMDuint16* limit)
{
    c3de:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetMotorLimit, limit);
    c3e0:	67 e0       	ldi	r22, 0x07	; 7
    c3e2:	70 e0       	ldi	r23, 0x00	; 0
    c3e4:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c3e8:	08 95       	ret

0000c3ea <PMDGetLimitSwitchMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetLimitSwitchMode, mode);
}

PMDresult PMDGetLimitSwitchMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c3ea:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetLimitSwitchMode, mode);
    c3ec:	61 e8       	ldi	r22, 0x81	; 129
    c3ee:	70 e0       	ldi	r23, 0x00	; 0
    c3f0:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c3f4:	08 95       	ret

0000c3f6 <PMDGetKout>:
{
	return SendCommandWord(axis_handle, PMDOPSetKout, kout);
}

PMDresult PMDGetKout(PMDAxisHandle* axis_handle, PMDuint16* kout)
{
    c3f6:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKout, kout);
    c3f8:	6f e9       	ldi	r22, 0x9F	; 159
    c3fa:	70 e0       	ldi	r23, 0x00	; 0
    c3fc:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c400:	08 95       	ret

0000c402 <PMDGetKaff>:
{
	return SendCommandWord(axis_handle, PMDOPSetKaff, kaff);
}

PMDresult PMDGetKaff(PMDAxisHandle* axis_handle, PMDuint16* kaff)
{
    c402:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKaff, kaff);
    c404:	64 e9       	ldi	r22, 0x94	; 148
    c406:	70 e0       	ldi	r23, 0x00	; 0
    c408:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c40c:	08 95       	ret

0000c40e <PMDGetKvff>:
{
	return SendCommandWord(axis_handle, PMDOPSetKvff, kvff);
}

PMDresult PMDGetKvff(PMDAxisHandle* axis_handle, PMDuint16* kvff)
{
    c40e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKvff, kvff);
    c410:	64 e5       	ldi	r22, 0x54	; 84
    c412:	70 e0       	ldi	r23, 0x00	; 0
    c414:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c418:	08 95       	ret

0000c41a <PMDGetKi>:
{
	return SendCommandWord(axis_handle, PMDOPSetKi, ki);
}

PMDresult PMDGetKi(PMDAxisHandle* axis_handle, PMDuint16* ki)
{
    c41a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKi, ki);
    c41c:	61 e5       	ldi	r22, 0x51	; 81
    c41e:	70 e0       	ldi	r23, 0x00	; 0
    c420:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c424:	08 95       	ret

0000c426 <PMDGetKd>:
{
	return SendCommandWord(axis_handle, PMDOPSetKd, kd);
}

PMDresult PMDGetKd(PMDAxisHandle* axis_handle, PMDuint16* kd)
{
    c426:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKd, kd);
    c428:	62 e5       	ldi	r22, 0x52	; 82
    c42a:	70 e0       	ldi	r23, 0x00	; 0
    c42c:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c430:	08 95       	ret

0000c432 <PMDGetKp>:
{
	return SendCommandWord(axis_handle, PMDOPSetKp, kp);
}

PMDresult PMDGetKp(PMDAxisHandle* axis_handle, PMDuint16* kp)
{
    c432:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKp, kp);
    c434:	60 e5       	ldi	r22, 0x50	; 80
    c436:	70 e0       	ldi	r23, 0x00	; 0
    c438:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c43c:	08 95       	ret

0000c43e <PMDGetStopMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetStopMode, mode);
}

PMDresult PMDGetStopMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c43e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetStopMode, mode);
    c440:	61 ed       	ldi	r22, 0xD1	; 209
    c442:	70 e0       	ldi	r23, 0x00	; 0
    c444:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c448:	08 95       	ret

0000c44a <PMDGetGearMaster>:
	PMDuint16 value = (PMDuint16)((masterAxis & nibbleMask) | ((source & nibbleMask) << 8));
	return SendCommandWord(axis_handle, PMDOPSetGearMaster, value);
}

PMDresult PMDGetGearMaster(PMDAxisHandle* axis_handle, PMDAxis* masterAxis, PMDuint8* source)
{
    c44a:	ef 92       	push	r14
    c44c:	ff 92       	push	r15
    c44e:	0f 93       	push	r16
    c450:	1f 93       	push	r17
    c452:	df 93       	push	r29
    c454:	cf 93       	push	r28
    c456:	00 d0       	rcall	.+0      	; 0xc458 <PMDGetGearMaster+0xe>
    c458:	cd b7       	in	r28, 0x3d	; 61
    c45a:	de b7       	in	r29, 0x3e	; 62
    c45c:	8b 01       	movw	r16, r22
    c45e:	7a 01       	movw	r14, r20
	PMDuint16 result;
	PMDuint16 value;

	result = SendCommandGetWord(axis_handle, PMDOPGetGearMaster, &value);
    c460:	6f ea       	ldi	r22, 0xAF	; 175
    c462:	70 e0       	ldi	r23, 0x00	; 0
    c464:	ae 01       	movw	r20, r28
    c466:	4f 5f       	subi	r20, 0xFF	; 255
    c468:	5f 4f       	sbci	r21, 0xFF	; 255
    c46a:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
	*masterAxis = (PMDAxis)(value & nibbleMask);
    c46e:	29 81       	ldd	r18, Y+1	; 0x01
    c470:	3a 81       	ldd	r19, Y+2	; 0x02
    c472:	2f 70       	andi	r18, 0x0F	; 15
    c474:	30 70       	andi	r19, 0x00	; 0
    c476:	f8 01       	movw	r30, r16
    c478:	31 83       	std	Z+1, r19	; 0x01
    c47a:	20 83       	st	Z, r18
	*source = (PMDuint8)((value >> 8) & nibbleMask);
    c47c:	2a 81       	ldd	r18, Y+2	; 0x02
    c47e:	2f 70       	andi	r18, 0x0F	; 15
    c480:	f7 01       	movw	r30, r14
    c482:	20 83       	st	Z, r18

	return result;
}
    c484:	0f 90       	pop	r0
    c486:	0f 90       	pop	r0
    c488:	cf 91       	pop	r28
    c48a:	df 91       	pop	r29
    c48c:	1f 91       	pop	r17
    c48e:	0f 91       	pop	r16
    c490:	ff 90       	pop	r15
    c492:	ef 90       	pop	r14
    c494:	08 95       	ret

0000c496 <PMDGetProfileMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetProfileMode, mode);
}

PMDresult PMDGetProfileMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    c496:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetProfileMode, mode);
    c498:	61 ea       	ldi	r22, 0xA1	; 161
    c49a:	70 e0       	ldi	r23, 0x00	; 0
    c49c:	0e 94 5b 6c 	call	0xd8b6	; 0xd8b6 <SendCommandGetWord>
}
    c4a0:	08 95       	ret

0000c4a2 <PMDSetSynchronizationMode>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetStepRange, range);
}

PMDresult PMDSetSynchronizationMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c4a2:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetSynchronizationMode, mode);
    c4a4:	62 ef       	ldi	r22, 0xF2	; 242
    c4a6:	70 e0       	ldi	r23, 0x00	; 0
    c4a8:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c4ac:	08 95       	ret

0000c4ae <PMDSetStepRange>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetChecksum, checksum);
}

PMDresult PMDSetStepRange(PMDAxisHandle* axis_handle, PMDuint16 range)
{
    c4ae:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetStepRange, range);
    c4b0:	6f ec       	ldi	r22, 0xCF	; 207
    c4b2:	70 e0       	ldi	r23, 0x00	; 0
    c4b4:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c4b8:	08 95       	ret

0000c4ba <PMDSetDiagnosticPortMode>:

	return result;
}

PMDresult PMDSetDiagnosticPortMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c4ba:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetDiagnosticPortMode, mode);
    c4bc:	69 e8       	ldi	r22, 0x89	; 137
    c4be:	70 e0       	ldi	r23, 0x00	; 0
    c4c0:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c4c4:	08 95       	ret

0000c4c6 <PMDSetSerialPortMode>:
	return SendCommandGetWord(axis_handle, PMDOPGetHostIOError, hostIOError);
}

PMDresult PMDSetSerialPortMode(PMDAxisHandle* axis_handle, PMDuint8 baud, PMDuint8 parity, 
					PMDuint8 stopBits, PMDuint8 protocol, PMDuint8 multiDropID)
{
    c4c6:	ef 92       	push	r14
    c4c8:	0f 93       	push	r16
    c4ca:	1f 93       	push	r17

	serialData = (PMDuint16)(baud | (parity << 4) | (stopBits << 6) | 
		(protocol << 7) | 
		// bits 9 and 10 are resereved for future use
		(multiDropID << 11));
	return SendCommandWord(axis_handle, PMDOPSetSerialPortMode, serialData);
    c4cc:	50 e0       	ldi	r21, 0x00	; 0
    c4ce:	74 e0       	ldi	r23, 0x04	; 4
    c4d0:	44 0f       	add	r20, r20
    c4d2:	55 1f       	adc	r21, r21
    c4d4:	7a 95       	dec	r23
    c4d6:	e1 f7       	brne	.-8      	; 0xc4d0 <PMDSetSerialPortMode+0xa>
    c4d8:	70 e0       	ldi	r23, 0x00	; 0
    c4da:	46 2b       	or	r20, r22
    c4dc:	57 2b       	or	r21, r23
    c4de:	30 e0       	ldi	r19, 0x00	; 0
    c4e0:	66 e0       	ldi	r22, 0x06	; 6
    c4e2:	22 0f       	add	r18, r18
    c4e4:	33 1f       	adc	r19, r19
    c4e6:	6a 95       	dec	r22
    c4e8:	e1 f7       	brne	.-8      	; 0xc4e2 <PMDSetSerialPortMode+0x1c>
    c4ea:	42 2b       	or	r20, r18
    c4ec:	53 2b       	or	r21, r19
    c4ee:	10 e0       	ldi	r17, 0x00	; 0
    c4f0:	16 95       	lsr	r17
    c4f2:	10 2f       	mov	r17, r16
    c4f4:	00 27       	eor	r16, r16
    c4f6:	17 95       	ror	r17
    c4f8:	07 95       	ror	r16
    c4fa:	40 2b       	or	r20, r16
    c4fc:	51 2b       	or	r21, r17
    c4fe:	3e 2d       	mov	r19, r14
    c500:	33 0f       	add	r19, r19
    c502:	33 0f       	add	r19, r19
    c504:	33 0f       	add	r19, r19
    c506:	20 e0       	ldi	r18, 0x00	; 0
    c508:	42 2b       	or	r20, r18
    c50a:	53 2b       	or	r21, r19
    c50c:	6b e8       	ldi	r22, 0x8B	; 139
    c50e:	70 e0       	ldi	r23, 0x00	; 0
    c510:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c514:	1f 91       	pop	r17
    c516:	0f 91       	pop	r16
    c518:	ef 90       	pop	r14
    c51a:	08 95       	ret

0000c51c <PMDSetAxisOutSource>:
PMDresult PMDSetAxisOutSource(PMDAxisHandle* axis_handle, PMDAxis sourceAxis, PMDuint8 bit, PMDuint8 sourceRegister)
{
	PMDuint16 value = (PMDuint16)((sourceAxis & nibbleMask) | ((bit & nibbleMask) << 4) 
		| ((sourceRegister & nibbleMask) << 8));
		
	return SendCommandWord(axis_handle, PMDOPSetAxisOutSource, value);
    c51c:	50 e0       	ldi	r21, 0x00	; 0
    c51e:	f4 e0       	ldi	r31, 0x04	; 4
    c520:	44 0f       	add	r20, r20
    c522:	55 1f       	adc	r21, r21
    c524:	fa 95       	dec	r31
    c526:	e1 f7       	brne	.-8      	; 0xc520 <PMDSetAxisOutSource+0x4>
    c528:	50 70       	andi	r21, 0x00	; 0
    c52a:	6f 70       	andi	r22, 0x0F	; 15
    c52c:	70 70       	andi	r23, 0x00	; 0
    c52e:	46 2b       	or	r20, r22
    c530:	57 2b       	or	r21, r23
    c532:	30 e0       	ldi	r19, 0x00	; 0
    c534:	2f 70       	andi	r18, 0x0F	; 15
    c536:	30 70       	andi	r19, 0x00	; 0
    c538:	32 2f       	mov	r19, r18
    c53a:	22 27       	eor	r18, r18
    c53c:	42 2b       	or	r20, r18
    c53e:	53 2b       	or	r21, r19
    c540:	6d ee       	ldi	r22, 0xED	; 237
    c542:	70 e0       	ldi	r23, 0x00	; 0
    c544:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c548:	08 95       	ret

0000c54a <PMDSetAxisMode>:
}


// Miscellaneous
PMDresult PMDSetAxisMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c54a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetAxisMode, mode);
    c54c:	67 e8       	ldi	r22, 0x87	; 135
    c54e:	70 e0       	ldi	r23, 0x00	; 0
    c550:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c554:	08 95       	ret

0000c556 <PMDSetTraceStop>:

	return result;
}

PMDresult PMDSetTraceStop(PMDAxisHandle* axis_handle, PMDAxis traceAxis, PMDuint8 condition, PMDuint8 bit, PMDuint8 state)
{
    c556:	0f 93       	push	r16
    c558:	1f 93       	push	r17
    c55a:	cf 93       	push	r28
    c55c:	df 93       	push	r29
    c55e:	ec 01       	movw	r28, r24
    c560:	82 2f       	mov	r24, r18
    c562:	50 2f       	mov	r21, r16
	PMDuint16 value = (PMDuint16)((traceAxis & nibbleMask) | ((condition & nibbleMask) << 4));
    c564:	e4 2f       	mov	r30, r20
    c566:	f0 e0       	ldi	r31, 0x00	; 0
    c568:	b4 e0       	ldi	r27, 0x04	; 4
    c56a:	ee 0f       	add	r30, r30
    c56c:	ff 1f       	adc	r31, r31
    c56e:	ba 95       	dec	r27
    c570:	e1 f7       	brne	.-8      	; 0xc56a <PMDSetTraceStop+0x14>
    c572:	f0 70       	andi	r31, 0x00	; 0
    c574:	6f 70       	andi	r22, 0x0F	; 15
    c576:	70 70       	andi	r23, 0x00	; 0
    c578:	e6 2b       	or	r30, r22
    c57a:	f7 2b       	or	r31, r23
	PMDAxis axis = axis_handle->axis;
    c57c:	0a 81       	ldd	r16, Y+2	; 0x02
    c57e:	1b 81       	ldd	r17, Y+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    c580:	1b 82       	std	Y+3, r1	; 0x03
    c582:	1a 82       	std	Y+2, r1	; 0x02
	
	switch(condition)
    c584:	42 50       	subi	r20, 0x02	; 2
    c586:	43 30       	cpi	r20, 0x03	; 3
    c588:	68 f4       	brcc	.+26     	; 0xc5a4 <PMDSetTraceStop+0x4e>
	{
	case PMDTraceConditionEventStatus:
	case PMDTraceConditionActivityStatus:
	case PMDTraceConditionSignalStatus:
		value |= ((bit & nibbleMask) << 8) | ((state & nibbleMask) << 12);
    c58a:	35 2f       	mov	r19, r21
    c58c:	32 95       	swap	r19
    c58e:	30 7f       	andi	r19, 0xF0	; 240
    c590:	20 e0       	ldi	r18, 0x00	; 0
    c592:	90 e0       	ldi	r25, 0x00	; 0
    c594:	8f 70       	andi	r24, 0x0F	; 15
    c596:	90 70       	andi	r25, 0x00	; 0
    c598:	98 2f       	mov	r25, r24
    c59a:	88 27       	eor	r24, r24
    c59c:	28 2b       	or	r18, r24
    c59e:	39 2b       	or	r19, r25
    c5a0:	e2 2b       	or	r30, r18
    c5a2:	f3 2b       	or	r31, r19
		break;
	default:
		break;
	}
	result = SendCommandWord(axis_handle, PMDOPSetTraceStop, value);
    c5a4:	ce 01       	movw	r24, r28
    c5a6:	64 eb       	ldi	r22, 0xB4	; 180
    c5a8:	70 e0       	ldi	r23, 0x00	; 0
    c5aa:	af 01       	movw	r20, r30
    c5ac:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>

	axis_handle->axis = axis;
    c5b0:	1b 83       	std	Y+3, r17	; 0x03
    c5b2:	0a 83       	std	Y+2, r16	; 0x02

	return result;
}
    c5b4:	df 91       	pop	r29
    c5b6:	cf 91       	pop	r28
    c5b8:	1f 91       	pop	r17
    c5ba:	0f 91       	pop	r16
    c5bc:	08 95       	ret

0000c5be <PMDSetTraceStart>:

	return result;
}

PMDresult PMDSetTraceStart(PMDAxisHandle* axis_handle, PMDAxis traceAxis, PMDuint8 condition, PMDuint8 bit, PMDuint8 state)
{
    c5be:	0f 93       	push	r16
    c5c0:	1f 93       	push	r17
    c5c2:	cf 93       	push	r28
    c5c4:	df 93       	push	r29
    c5c6:	ec 01       	movw	r28, r24
    c5c8:	82 2f       	mov	r24, r18
    c5ca:	50 2f       	mov	r21, r16
	PMDuint16 value = (PMDuint16)((traceAxis & nibbleMask) | ((condition & nibbleMask) << 4));
    c5cc:	e4 2f       	mov	r30, r20
    c5ce:	f0 e0       	ldi	r31, 0x00	; 0
    c5d0:	a4 e0       	ldi	r26, 0x04	; 4
    c5d2:	ee 0f       	add	r30, r30
    c5d4:	ff 1f       	adc	r31, r31
    c5d6:	aa 95       	dec	r26
    c5d8:	e1 f7       	brne	.-8      	; 0xc5d2 <PMDSetTraceStart+0x14>
    c5da:	f0 70       	andi	r31, 0x00	; 0
    c5dc:	6f 70       	andi	r22, 0x0F	; 15
    c5de:	70 70       	andi	r23, 0x00	; 0
    c5e0:	e6 2b       	or	r30, r22
    c5e2:	f7 2b       	or	r31, r23
	PMDAxis axis = axis_handle->axis;
    c5e4:	0a 81       	ldd	r16, Y+2	; 0x02
    c5e6:	1b 81       	ldd	r17, Y+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    c5e8:	1b 82       	std	Y+3, r1	; 0x03
    c5ea:	1a 82       	std	Y+2, r1	; 0x02
	
	switch(condition)
    c5ec:	42 50       	subi	r20, 0x02	; 2
    c5ee:	43 30       	cpi	r20, 0x03	; 3
    c5f0:	68 f4       	brcc	.+26     	; 0xc60c <PMDSetTraceStart+0x4e>
	{
	case PMDTraceConditionEventStatus:
	case PMDTraceConditionActivityStatus:
	case PMDTraceConditionSignalStatus:
		value |= ((bit & nibbleMask) << 8) | ((state & nibbleMask) << 12);
    c5f2:	35 2f       	mov	r19, r21
    c5f4:	32 95       	swap	r19
    c5f6:	30 7f       	andi	r19, 0xF0	; 240
    c5f8:	20 e0       	ldi	r18, 0x00	; 0
    c5fa:	90 e0       	ldi	r25, 0x00	; 0
    c5fc:	8f 70       	andi	r24, 0x0F	; 15
    c5fe:	90 70       	andi	r25, 0x00	; 0
    c600:	98 2f       	mov	r25, r24
    c602:	88 27       	eor	r24, r24
    c604:	28 2b       	or	r18, r24
    c606:	39 2b       	or	r19, r25
    c608:	e2 2b       	or	r30, r18
    c60a:	f3 2b       	or	r31, r19
		break;
	default:
		break;
	}
	result = SendCommandWord(axis_handle, PMDOPSetTraceStart, value);
    c60c:	ce 01       	movw	r24, r28
    c60e:	62 eb       	ldi	r22, 0xB2	; 178
    c610:	70 e0       	ldi	r23, 0x00	; 0
    c612:	af 01       	movw	r20, r30
    c614:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>

	axis_handle->axis = axis;
    c618:	1b 83       	std	Y+3, r17	; 0x03
    c61a:	0a 83       	std	Y+2, r16	; 0x02

	return result;
}
    c61c:	df 91       	pop	r29
    c61e:	cf 91       	pop	r28
    c620:	1f 91       	pop	r17
    c622:	0f 91       	pop	r16
    c624:	08 95       	ret

0000c626 <PMDSetTracePeriod>:

	return result;
}

PMDresult PMDSetTracePeriod(PMDAxisHandle* axis_handle, PMDuint16 tracePeriod)
{
    c626:	ef 92       	push	r14
    c628:	ff 92       	push	r15
    c62a:	0f 93       	push	r16
    c62c:	1f 93       	push	r17
    c62e:	8c 01       	movw	r16, r24
    c630:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    c632:	fc 01       	movw	r30, r24
    c634:	e2 80       	ldd	r14, Z+2	; 0x02
    c636:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    c638:	13 82       	std	Z+3, r1	; 0x03
    c63a:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandWord(axis_handle, PMDOPSetTracePeriod, tracePeriod);
    c63c:	68 eb       	ldi	r22, 0xB8	; 184
    c63e:	70 e0       	ldi	r23, 0x00	; 0
    c640:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>

	axis_handle->axis = axis;
    c644:	f8 01       	movw	r30, r16
    c646:	f3 82       	std	Z+3, r15	; 0x03
    c648:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    c64a:	1f 91       	pop	r17
    c64c:	0f 91       	pop	r16
    c64e:	ff 90       	pop	r15
    c650:	ef 90       	pop	r14
    c652:	08 95       	ret

0000c654 <PMDSetTraceMode>:
}


// Trace Operations
PMDresult PMDSetTraceMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c654:	ef 92       	push	r14
    c656:	ff 92       	push	r15
    c658:	0f 93       	push	r16
    c65a:	1f 93       	push	r17
    c65c:	8c 01       	movw	r16, r24
    c65e:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    c660:	fc 01       	movw	r30, r24
    c662:	e2 80       	ldd	r14, Z+2	; 0x02
    c664:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    c666:	13 82       	std	Z+3, r1	; 0x03
    c668:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandWord(axis_handle, PMDOPSetTraceMode, mode);
    c66a:	60 eb       	ldi	r22, 0xB0	; 176
    c66c:	70 e0       	ldi	r23, 0x00	; 0
    c66e:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>

	axis_handle->axis = axis;
    c672:	f8 01       	movw	r30, r16
    c674:	f3 82       	std	Z+3, r15	; 0x03
    c676:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    c678:	1f 91       	pop	r17
    c67a:	0f 91       	pop	r16
    c67c:	ff 90       	pop	r15
    c67e:	ef 90       	pop	r14
    c680:	08 95       	ret

0000c682 <PMDSetPhaseCorrectionMode>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseAngle, phaseAngle);
}

PMDresult PMDSetPhaseCorrectionMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c682:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseCorrectionMode, mode);
    c684:	68 ee       	ldi	r22, 0xE8	; 232
    c686:	70 e0       	ldi	r23, 0x00	; 0
    c688:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c68c:	08 95       	ret

0000c68e <PMDSetPhaseAngle>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseOffset, phaseOffset);
}

PMDresult PMDSetPhaseAngle(PMDAxisHandle* axis_handle, PMDuint16 phaseAngle)
{
    c68e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseAngle, phaseAngle);
    c690:	64 e8       	ldi	r22, 0x84	; 132
    c692:	70 e0       	ldi	r23, 0x00	; 0
    c694:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c698:	08 95       	ret

0000c69a <PMDSetPhaseOffset>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseInitializeTime, phaseInitTime);
}

PMDresult PMDSetPhaseOffset(PMDAxisHandle* axis_handle, PMDuint16 phaseOffset)
{
    c69a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseOffset, phaseOffset);
    c69c:	66 e7       	ldi	r22, 0x76	; 118
    c69e:	70 e0       	ldi	r23, 0x00	; 0
    c6a0:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c6a4:	08 95       	ret

0000c6a6 <PMDSetPhaseInitializeTime>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseCounts, phaseCounts);
}

PMDresult PMDSetPhaseInitializeTime(PMDAxisHandle* axis_handle, PMDuint16 phaseInitTime)
{
    c6a6:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseInitializeTime, phaseInitTime);
    c6a8:	62 e7       	ldi	r22, 0x72	; 114
    c6aa:	70 e0       	ldi	r23, 0x00	; 0
    c6ac:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c6b0:	08 95       	ret

0000c6b2 <PMDSetPhaseCounts>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhasePrescale, phasePrescale);
}

PMDresult PMDSetPhaseCounts(PMDAxisHandle* axis_handle, PMDuint16 phaseCounts)
{
    c6b2:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseCounts, phaseCounts);
    c6b4:	65 e7       	ldi	r22, 0x75	; 117
    c6b6:	70 e0       	ldi	r23, 0x00	; 0
    c6b8:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c6bc:	08 95       	ret

0000c6be <PMDSetPhasePrescale>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseInitializeMode, mode);
}

PMDresult PMDSetPhasePrescale(PMDAxisHandle* axis_handle, PMDuint16 phasePrescale)
{
    c6be:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhasePrescale, phasePrescale);
    c6c0:	66 ee       	ldi	r22, 0xE6	; 230
    c6c2:	70 e0       	ldi	r23, 0x00	; 0
    c6c4:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c6c8:	08 95       	ret

0000c6ca <PMDSetPhaseInitializeMode>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetNumberPhases, numberPhases);
}

PMDresult PMDSetPhaseInitializeMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c6ca:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseInitializeMode, mode);
    c6cc:	64 ee       	ldi	r22, 0xE4	; 228
    c6ce:	70 e0       	ldi	r23, 0x00	; 0
    c6d0:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c6d4:	08 95       	ret

0000c6d6 <PMDSetNumberPhases>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetCommutationMode, mode);
}

PMDresult PMDSetNumberPhases(PMDAxisHandle* axis_handle, PMDuint16 numberPhases)
{
    c6d6:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetNumberPhases, numberPhases);
    c6d8:	65 e8       	ldi	r22, 0x85	; 133
    c6da:	70 e0       	ldi	r23, 0x00	; 0
    c6dc:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c6e0:	08 95       	ret

0000c6e2 <PMDSetCommutationMode>:
}


// Commutation
PMDresult PMDSetCommutationMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c6e2:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetCommutationMode, mode);
    c6e4:	62 ee       	ldi	r22, 0xE2	; 226
    c6e6:	70 e0       	ldi	r23, 0x00	; 0
    c6e8:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c6ec:	08 95       	ret

0000c6ee <PMDSetMotorCommand>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetMotorMode, mode);
}

PMDresult PMDSetMotorCommand(PMDAxisHandle* axis_handle, PMDint16 motorCommand)
{
    c6ee:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetMotorCommand, (PMDuint16)motorCommand);
    c6f0:	67 e7       	ldi	r22, 0x77	; 119
    c6f2:	70 e0       	ldi	r23, 0x00	; 0
    c6f4:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c6f8:	08 95       	ret

0000c6fa <PMDSetMotorMode>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetOutputMode, mode);
}

PMDresult PMDSetMotorMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c6fa:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetMotorMode, mode);
    c6fc:	6c ed       	ldi	r22, 0xDC	; 220
    c6fe:	70 e0       	ldi	r23, 0x00	; 0
    c700:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c704:	08 95       	ret

0000c706 <PMDSetOutputMode>:
}


// Motor
PMDresult PMDSetOutputMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c706:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetOutputMode, mode);
    c708:	60 ee       	ldi	r22, 0xE0	; 224
    c70a:	70 e0       	ldi	r23, 0x00	; 0
    c70c:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c710:	08 95       	ret

0000c712 <PMDSetEncoderModulus>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetEncoderSource, encoderSource);
}

PMDresult PMDSetEncoderModulus(PMDAxisHandle* axis_handle, PMDuint16 modulus)
{
    c712:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetEncoderModulus, modulus);
    c714:	6d e8       	ldi	r22, 0x8D	; 141
    c716:	70 e0       	ldi	r23, 0x00	; 0
    c718:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c71c:	08 95       	ret

0000c71e <PMDSetEncoderSource>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetCaptureSource, captureSource);
}

PMDresult PMDSetEncoderSource(PMDAxisHandle* axis_handle, PMDuint16 encoderSource)
{
    c71e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetEncoderSource, encoderSource);
    c720:	6a ed       	ldi	r22, 0xDA	; 218
    c722:	70 e0       	ldi	r23, 0x00	; 0
    c724:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c728:	08 95       	ret

0000c72a <PMDSetCaptureSource>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetActualPositionUnits, mode);
}

PMDresult PMDSetCaptureSource(PMDAxisHandle* axis_handle, PMDuint16 captureSource)
{
    c72a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetCaptureSource, captureSource);
    c72c:	68 ed       	ldi	r22, 0xD8	; 216
    c72e:	70 e0       	ldi	r23, 0x00	; 0
    c730:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c734:	08 95       	ret

0000c736 <PMDSetActualPositionUnits>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetActualPosition, (PMDuint32*)position);
}

PMDresult PMDSetActualPositionUnits(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c736:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetActualPositionUnits, mode);
    c738:	6e eb       	ldi	r22, 0xBE	; 190
    c73a:	70 e0       	ldi	r23, 0x00	; 0
    c73c:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c740:	08 95       	ret

0000c742 <PMDSetSignalSense>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetActivityStatus, activityStatus);
}

PMDresult PMDSetSignalSense(PMDAxisHandle* axis_handle, PMDuint16 mask)
{
    c742:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetSignalSense, mask);
    c744:	62 ea       	ldi	r22, 0xA2	; 162
    c746:	70 e0       	ldi	r23, 0x00	; 0
    c748:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c74c:	08 95       	ret

0000c74e <PMDResetEventStatus>:
}


// Status Register Control
PMDresult PMDResetEventStatus(PMDAxisHandle* axis_handle, PMDuint16 eventStatus)
{
    c74e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPResetEventStatus, eventStatus);
    c750:	64 e3       	ldi	r22, 0x34	; 52
    c752:	70 e0       	ldi	r23, 0x00	; 0
    c754:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c758:	08 95       	ret

0000c75a <PMDSetInterruptMask>:
}


// Interrupt Processing
PMDresult PMDSetInterruptMask(PMDAxisHandle* axis_handle, PMDuint16 interruptMask)
{
    c75a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetInterruptMask, interruptMask);
    c75c:	6f e2       	ldi	r22, 0x2F	; 47
    c75e:	70 e0       	ldi	r23, 0x00	; 0
    c760:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c764:	08 95       	ret

0000c766 <PMDMultiUpdate>:
{
	return SendCommand(axis_handle, PMDOPUpdate);
}

PMDresult PMDMultiUpdate(PMDAxisHandle* axis_handle, PMDuint16 axisMask)
{
    c766:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPMultiUpdate, axisMask);
    c768:	6b e5       	ldi	r22, 0x5B	; 91
    c76a:	70 e0       	ldi	r23, 0x00	; 0
    c76c:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c770:	08 95       	ret

0000c772 <PMDSetSampleTime>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetPositionError, (PMDuint32*)error);
}

PMDresult PMDSetSampleTime(PMDAxisHandle* axis_handle, PMDuint16 sampleTime)
{
    c772:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetSampleTime, sampleTime);
    c774:	68 e3       	ldi	r22, 0x38	; 56
    c776:	70 e0       	ldi	r23, 0x00	; 0
    c778:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c77c:	08 95       	ret

0000c77e <PMDSetMotionCompleteMode>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetTrackingWindow, trackingWindow);
}

PMDresult PMDSetMotionCompleteMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c77e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetMotionCompleteMode, mode);
    c780:	6b ee       	ldi	r22, 0xEB	; 235
    c782:	70 e0       	ldi	r23, 0x00	; 0
    c784:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c788:	08 95       	ret

0000c78a <PMDSetTrackingWindow>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetSettleWindow, settleWindow);
}

PMDresult PMDSetTrackingWindow(PMDAxisHandle* axis_handle, PMDuint16 trackingWindow)
{
    c78a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetTrackingWindow, trackingWindow);
    c78c:	68 ea       	ldi	r22, 0xA8	; 168
    c78e:	70 e0       	ldi	r23, 0x00	; 0
    c790:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c794:	08 95       	ret

0000c796 <PMDSetSettleWindow>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetSettleTime, settleTime);
}

PMDresult PMDSetSettleWindow(PMDAxisHandle* axis_handle, PMDuint16 settleWindow)
{
    c796:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetSettleWindow, settleWindow);
    c798:	6c eb       	ldi	r22, 0xBC	; 188
    c79a:	70 e0       	ldi	r23, 0x00	; 0
    c79c:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c7a0:	08 95       	ret

0000c7a2 <PMDSetSettleTime>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetDerivativeTime, derivativeTime);
}

PMDresult PMDSetSettleTime(PMDAxisHandle* axis_handle, PMDuint16 settleTime)
{
    c7a2:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetSettleTime, settleTime);
    c7a4:	6a ea       	ldi	r22, 0xAA	; 170
    c7a6:	70 e0       	ldi	r23, 0x00	; 0
    c7a8:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c7ac:	08 95       	ret

0000c7ae <PMDSetDerivativeTime>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetAutoStopMode, mode);
}

PMDresult PMDSetDerivativeTime(PMDAxisHandle* axis_handle, PMDuint16 derivativeTime)
{
    c7ae:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetDerivativeTime, derivativeTime);
    c7b0:	6c e9       	ldi	r22, 0x9C	; 156
    c7b2:	70 e0       	ldi	r23, 0x00	; 0
    c7b4:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c7b8:	08 95       	ret

0000c7ba <PMDSetAutoStopMode>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetPositionErrorLimit, limit);
}

PMDresult PMDSetAutoStopMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c7ba:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetAutoStopMode, mode);
    c7bc:	62 ed       	ldi	r22, 0xD2	; 210
    c7be:	70 e0       	ldi	r23, 0x00	; 0
    c7c0:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c7c4:	08 95       	ret

0000c7c6 <PMDSetMotorBias>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetMotorLimit, limit);
}

PMDresult PMDSetMotorBias(PMDAxisHandle* axis_handle, PMDint16 bias)
{
    c7c6:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetMotorBias, (PMDuint16)bias);
    c7c8:	6f e0       	ldi	r22, 0x0F	; 15
    c7ca:	70 e0       	ldi	r23, 0x00	; 0
    c7cc:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c7d0:	08 95       	ret

0000c7d2 <PMDSetMotorLimit>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetLimitSwitchMode, mode);
}

PMDresult PMDSetMotorLimit(PMDAxisHandle* axis_handle, PMDuint16 limit)
{
    c7d2:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetMotorLimit, limit);
    c7d4:	66 e0       	ldi	r22, 0x06	; 6
    c7d6:	70 e0       	ldi	r23, 0x00	; 0
    c7d8:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c7dc:	08 95       	ret

0000c7de <PMDSetLimitSwitchMode>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetIntegrationLimit, limit);
}

PMDresult PMDSetLimitSwitchMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c7de:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetLimitSwitchMode, mode);
    c7e0:	60 e8       	ldi	r22, 0x80	; 128
    c7e2:	70 e0       	ldi	r23, 0x00	; 0
    c7e4:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c7e8:	08 95       	ret

0000c7ea <PMDSetKout>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKaff, kaff);
}

PMDresult PMDSetKout(PMDAxisHandle* axis_handle, PMDuint16 kout)
{
    c7ea:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKout, kout);
    c7ec:	6e e9       	ldi	r22, 0x9E	; 158
    c7ee:	70 e0       	ldi	r23, 0x00	; 0
    c7f0:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c7f4:	08 95       	ret

0000c7f6 <PMDSetKaff>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKvff, kvff);
}

PMDresult PMDSetKaff(PMDAxisHandle* axis_handle, PMDuint16 kaff)
{
    c7f6:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKaff, kaff);
    c7f8:	63 e9       	ldi	r22, 0x93	; 147
    c7fa:	70 e0       	ldi	r23, 0x00	; 0
    c7fc:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c800:	08 95       	ret

0000c802 <PMDSetKvff>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKi, ki);
}

PMDresult PMDSetKvff(PMDAxisHandle* axis_handle, PMDuint16 kvff)
{
    c802:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKvff, kvff);
    c804:	6b e2       	ldi	r22, 0x2B	; 43
    c806:	70 e0       	ldi	r23, 0x00	; 0
    c808:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c80c:	08 95       	ret

0000c80e <PMDSetKi>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKd, kd);
}

PMDresult PMDSetKi(PMDAxisHandle* axis_handle, PMDuint16 ki)
{
    c80e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKi, ki);
    c810:	66 e2       	ldi	r22, 0x26	; 38
    c812:	70 e0       	ldi	r23, 0x00	; 0
    c814:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c818:	08 95       	ret

0000c81a <PMDSetKd>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKp, kp);
}

PMDresult PMDSetKd(PMDAxisHandle* axis_handle, PMDuint16 kd)
{
    c81a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKd, kd);
    c81c:	67 e2       	ldi	r22, 0x27	; 39
    c81e:	70 e0       	ldi	r23, 0x00	; 0
    c820:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c824:	08 95       	ret

0000c826 <PMDSetKp>:
}


// Servo Filter
PMDresult PMDSetKp(PMDAxisHandle* axis_handle, PMDuint16 kp)
{
    c826:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKp, kp);
    c828:	65 e2       	ldi	r22, 0x25	; 37
    c82a:	70 e0       	ldi	r23, 0x00	; 0
    c82c:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c830:	08 95       	ret

0000c832 <PMDSetStopMode>:

	return result;
}

PMDresult PMDSetStopMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c832:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetStopMode, mode);
    c834:	60 ed       	ldi	r22, 0xD0	; 208
    c836:	70 e0       	ldi	r23, 0x00	; 0
    c838:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c83c:	08 95       	ret

0000c83e <PMDSetGearMaster>:
}

PMDresult PMDSetGearMaster(PMDAxisHandle* axis_handle, PMDAxis masterAxis, PMDuint8 source)
{
	PMDuint16 value = (PMDuint16)((masterAxis & nibbleMask) | ((source & nibbleMask) << 8));
	return SendCommandWord(axis_handle, PMDOPSetGearMaster, value);
    c83e:	50 e0       	ldi	r21, 0x00	; 0
    c840:	4f 70       	andi	r20, 0x0F	; 15
    c842:	50 70       	andi	r21, 0x00	; 0
    c844:	54 2f       	mov	r21, r20
    c846:	44 27       	eor	r20, r20
    c848:	6f 70       	andi	r22, 0x0F	; 15
    c84a:	70 70       	andi	r23, 0x00	; 0
    c84c:	46 2b       	or	r20, r22
    c84e:	57 2b       	or	r21, r23
    c850:	6e ea       	ldi	r22, 0xAE	; 174
    c852:	70 e0       	ldi	r23, 0x00	; 0
    c854:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c858:	08 95       	ret

0000c85a <PMDSetProfileMode>:



// Profile Generation
PMDresult PMDSetProfileMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    c85a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetProfileMode, mode);
    c85c:	60 ea       	ldi	r22, 0xA0	; 160
    c85e:	70 e0       	ldi	r23, 0x00	; 0
    c860:	0e 94 84 6b 	call	0xd708	; 0xd708 <SendCommandWord>
}
    c864:	08 95       	ret

0000c866 <PMDGetChecksum>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetTime, numberChipCycles);
}

PMDresult PMDGetChecksum(PMDAxisHandle* axis_handle, PMDuint32* checksum)
{
    c866:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetChecksum, checksum);
    c868:	68 ef       	ldi	r22, 0xF8	; 248
    c86a:	70 e0       	ldi	r23, 0x00	; 0
    c86c:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c870:	08 95       	ret

0000c872 <PMDGetTime>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetDiagnosticPortMode, mode);
}

PMDresult PMDGetTime(PMDAxisHandle* axis_handle, PMDuint32* numberChipCycles)
{
    c872:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetTime, numberChipCycles);
    c874:	6e e3       	ldi	r22, 0x3E	; 62
    c876:	70 e0       	ldi	r23, 0x00	; 0
    c878:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c87c:	08 95       	ret

0000c87e <PMDGetTraceCount>:

	return result;
}

PMDresult PMDGetTraceCount(PMDAxisHandle* axis_handle, PMDuint32* count)
{
    c87e:	ef 92       	push	r14
    c880:	ff 92       	push	r15
    c882:	0f 93       	push	r16
    c884:	1f 93       	push	r17
    c886:	8c 01       	movw	r16, r24
    c888:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    c88a:	fc 01       	movw	r30, r24
    c88c:	e2 80       	ldd	r14, Z+2	; 0x02
    c88e:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    c890:	13 82       	std	Z+3, r1	; 0x03
    c892:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetLong(axis_handle, PMDOPGetTraceCount, count);
    c894:	6b eb       	ldi	r22, 0xBB	; 187
    c896:	70 e0       	ldi	r23, 0x00	; 0
    c898:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>

	axis_handle->axis = axis;
    c89c:	f8 01       	movw	r30, r16
    c89e:	f3 82       	std	Z+3, r15	; 0x03
    c8a0:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    c8a2:	1f 91       	pop	r17
    c8a4:	0f 91       	pop	r16
    c8a6:	ff 90       	pop	r15
    c8a8:	ef 90       	pop	r14
    c8aa:	08 95       	ret

0000c8ac <PMDGetCaptureValue>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetActualVelocity, (PMDuint32*)actualValue);
}

PMDresult PMDGetCaptureValue(PMDAxisHandle* axis_handle, PMDint32* captureValue)
{
    c8ac:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetCaptureValue, (PMDuint32*)captureValue);
    c8ae:	66 e3       	ldi	r22, 0x36	; 54
    c8b0:	70 e0       	ldi	r23, 0x00	; 0
    c8b2:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c8b6:	08 95       	ret

0000c8b8 <PMDGetActualVelocity>:
{
	return SendCommandGetWordWord(axis_handle, PMDOPGetEncoderToStepRatio, encoderCounts, steps);
}

PMDresult PMDGetActualVelocity(PMDAxisHandle* axis_handle, PMDint32* actualValue)
{
    c8b8:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetActualVelocity, (PMDuint32*)actualValue);
    c8ba:	6d ea       	ldi	r22, 0xAD	; 173
    c8bc:	70 e0       	ldi	r23, 0x00	; 0
    c8be:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c8c2:	08 95       	ret

0000c8c4 <PMDGetActualPosition>:
{
	return SendCommandLong(axis_handle, PMDOPSetActualPosition, (PMDuint32)position);
}

PMDresult PMDGetActualPosition(PMDAxisHandle* axis_handle, PMDint32* position)
{
    c8c4:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetActualPosition, (PMDuint32*)position);
    c8c6:	67 e3       	ldi	r22, 0x37	; 55
    c8c8:	70 e0       	ldi	r23, 0x00	; 0
    c8ca:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c8ce:	08 95       	ret

0000c8d0 <PMDGetPositionError>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetIntegral, (PMDuint32*)integral);
}

PMDresult PMDGetPositionError(PMDAxisHandle* axis_handle, PMDint32* error)
{
    c8d0:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetPositionError, (PMDuint32*)error);
    c8d2:	69 e9       	ldi	r22, 0x99	; 153
    c8d4:	70 e0       	ldi	r23, 0x00	; 0
    c8d6:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c8da:	08 95       	ret

0000c8dc <PMDGetIntegral>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetDerivative, (PMDuint16*)derivative);
}

PMDresult PMDGetIntegral(PMDAxisHandle* axis_handle, PMDint32* integral)
{
    c8dc:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetIntegral, (PMDuint32*)integral);
    c8de:	6a e9       	ldi	r22, 0x9A	; 154
    c8e0:	70 e0       	ldi	r23, 0x00	; 0
    c8e2:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c8e6:	08 95       	ret

0000c8e8 <PMDGetPositionErrorLimit>:
{
	return SendCommandLong(axis_handle, PMDOPSetPositionErrorLimit, limit);
}

PMDresult PMDGetPositionErrorLimit(PMDAxisHandle* axis_handle, PMDuint32* limit)
{
    c8e8:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetPositionErrorLimit, limit);
    c8ea:	68 e9       	ldi	r22, 0x98	; 152
    c8ec:	70 e0       	ldi	r23, 0x00	; 0
    c8ee:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c8f2:	08 95       	ret

0000c8f4 <PMDGetIntegrationLimit>:
{
	return SendCommandLong(axis_handle, PMDOPSetIntegrationLimit, limit);
}

PMDresult PMDGetIntegrationLimit(PMDAxisHandle* axis_handle, PMDuint32* limit)
{
    c8f4:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetIntegrationLimit, limit);
    c8f6:	66 e9       	ldi	r22, 0x96	; 150
    c8f8:	70 e0       	ldi	r23, 0x00	; 0
    c8fa:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c8fe:	08 95       	ret

0000c900 <PMDGetCommandedAcceleration>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetCommandedVelocity, (PMDuint32*)velocity);
}

PMDresult PMDGetCommandedAcceleration(PMDAxisHandle* axis_handle, PMDint32 *acceleration)
{
    c900:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetCommandedAcceleration, (PMDuint32*)acceleration);
    c902:	67 ea       	ldi	r22, 0xA7	; 167
    c904:	70 e0       	ldi	r23, 0x00	; 0
    c906:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c90a:	08 95       	ret

0000c90c <PMDGetCommandedVelocity>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetCommandedPosition, (PMDuint32*)position);
}

PMDresult PMDGetCommandedVelocity(PMDAxisHandle* axis_handle, PMDint32* velocity)
{
    c90c:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetCommandedVelocity, (PMDuint32*)velocity);
    c90e:	6e e1       	ldi	r22, 0x1E	; 30
    c910:	70 e0       	ldi	r23, 0x00	; 0
    c912:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c916:	08 95       	ret

0000c918 <PMDGetCommandedPosition>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetStopMode, mode);
}

PMDresult PMDGetCommandedPosition(PMDAxisHandle* axis_handle, PMDint32* position)
{
    c918:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetCommandedPosition, (PMDuint32*)position);
    c91a:	6d e1       	ldi	r22, 0x1D	; 29
    c91c:	70 e0       	ldi	r23, 0x00	; 0
    c91e:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c922:	08 95       	ret

0000c924 <PMDGetGearRatio>:
{
	return SendCommandLong(axis_handle, PMDOPSetGearRatio, (PMDuint32)ratio);
}

PMDresult PMDGetGearRatio(PMDAxisHandle* axis_handle, PMDint32* ratio)
{
    c924:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetGearRatio, (PMDuint32*)ratio);
    c926:	69 e5       	ldi	r22, 0x59	; 89
    c928:	70 e0       	ldi	r23, 0x00	; 0
    c92a:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c92e:	08 95       	ret

0000c930 <PMDGetJerk>:
{
	return SendCommandLong(axis_handle, PMDOPSetJerk, jerk);
}

PMDresult PMDGetJerk(PMDAxisHandle* axis_handle, PMDuint32* jerk)
{
    c930:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetJerk, jerk);
    c932:	68 e5       	ldi	r22, 0x58	; 88
    c934:	70 e0       	ldi	r23, 0x00	; 0
    c936:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c93a:	08 95       	ret

0000c93c <PMDGetDeceleration>:
{
	return SendCommandLong(axis_handle, PMDOPSetDeceleration, deceleration);
}

PMDresult PMDGetDeceleration(PMDAxisHandle* axis_handle, PMDuint32* deceleration)
{
    c93c:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetDeceleration, deceleration);
    c93e:	62 e9       	ldi	r22, 0x92	; 146
    c940:	70 e0       	ldi	r23, 0x00	; 0
    c942:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c946:	08 95       	ret

0000c948 <PMDGetAcceleration>:
{
	return SendCommandLong(axis_handle, PMDOPSetAcceleration, acceleration);
}

PMDresult PMDGetAcceleration(PMDAxisHandle* axis_handle, PMDuint32* acceleration)
{
    c948:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetAcceleration, acceleration);
    c94a:	6c e4       	ldi	r22, 0x4C	; 76
    c94c:	70 e0       	ldi	r23, 0x00	; 0
    c94e:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c952:	08 95       	ret

0000c954 <PMDGetStartVelocity>:
{
	return SendCommandLong(axis_handle, PMDOPSetStartVelocity, velocity);
}

PMDresult PMDGetStartVelocity(PMDAxisHandle* axis_handle, PMDuint32* velocity)
{
    c954:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetStartVelocity, velocity);
    c956:	6b e6       	ldi	r22, 0x6B	; 107
    c958:	70 e0       	ldi	r23, 0x00	; 0
    c95a:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c95e:	08 95       	ret

0000c960 <PMDGetVelocity>:
{
	return SendCommandLong(axis_handle, PMDOPSetVelocity, velocity);
}

PMDresult PMDGetVelocity(PMDAxisHandle* axis_handle, PMDint32* velocity)
{
    c960:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetVelocity, (PMDuint32*)velocity);
    c962:	6b e4       	ldi	r22, 0x4B	; 75
    c964:	70 e0       	ldi	r23, 0x00	; 0
    c966:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c96a:	08 95       	ret

0000c96c <PMDGetPosition>:
{
	return SendCommandLong(axis_handle, PMDOPSetPosition, position);
}

PMDresult PMDGetPosition(PMDAxisHandle* axis_handle, PMDint32* position)
{
    c96c:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetPosition, (PMDuint32*)position);
    c96e:	6a e4       	ldi	r22, 0x4A	; 74
    c970:	70 e0       	ldi	r23, 0x00	; 0
    c972:	0e 94 d2 6c 	call	0xd9a4	; 0xd9a4 <SendCommandGetLong>
}
    c976:	08 95       	ret

0000c978 <PMDGetVersion>:
}

PMDresult PMDGetVersion(PMDAxisHandle* axis_handle, PMDuint16 *generation, PMDuint16 *motorType, 
						PMDuint16 *numberAxes, PMDuint16 *special,
						PMDuint16 *custom, PMDuint16 *major, PMDuint16 *minor)
{
    c978:	2f 92       	push	r2
    c97a:	3f 92       	push	r3
    c97c:	4f 92       	push	r4
    c97e:	5f 92       	push	r5
    c980:	6f 92       	push	r6
    c982:	7f 92       	push	r7
    c984:	8f 92       	push	r8
    c986:	9f 92       	push	r9
    c988:	af 92       	push	r10
    c98a:	bf 92       	push	r11
    c98c:	cf 92       	push	r12
    c98e:	df 92       	push	r13
    c990:	ef 92       	push	r14
    c992:	ff 92       	push	r15
    c994:	0f 93       	push	r16
    c996:	1f 93       	push	r17
    c998:	df 93       	push	r29
    c99a:	cf 93       	push	r28
    c99c:	00 d0       	rcall	.+0      	; 0xc99e <PMDGetVersion+0x26>
    c99e:	00 d0       	rcall	.+0      	; 0xc9a0 <PMDGetVersion+0x28>
    c9a0:	cd b7       	in	r28, 0x3d	; 61
    c9a2:	de b7       	in	r29, 0x3e	; 62
    c9a4:	4b 01       	movw	r8, r22
    c9a6:	3a 01       	movw	r6, r20
    c9a8:	29 01       	movw	r4, r18
    c9aa:	18 01       	movw	r2, r16
    c9ac:	87 01       	movw	r16, r14
    c9ae:	76 01       	movw	r14, r12
	PMDuint16 chip = 0, software = 0;
    c9b0:	1a 82       	std	Y+2, r1	; 0x02
    c9b2:	19 82       	std	Y+1, r1	; 0x01
    c9b4:	1c 82       	std	Y+4, r1	; 0x04
    c9b6:	1b 82       	std	Y+3, r1	; 0x03
	PMDuint16 result;

	result = SendCommandGetWordWord(axis_handle, PMDOPGetVersion, &chip, &software);
    c9b8:	6f e8       	ldi	r22, 0x8F	; 143
    c9ba:	70 e0       	ldi	r23, 0x00	; 0
    c9bc:	ae 01       	movw	r20, r28
    c9be:	4f 5f       	subi	r20, 0xFF	; 255
    c9c0:	5f 4f       	sbci	r21, 0xFF	; 255
    c9c2:	9e 01       	movw	r18, r28
    c9c4:	2d 5f       	subi	r18, 0xFD	; 253
    c9c6:	3f 4f       	sbci	r19, 0xFF	; 255
    c9c8:	0e 94 90 6c 	call	0xd920	; 0xd920 <SendCommandGetWordWord>

	*generation = (PMDuint16)((chip & 0xF000) >> 12);
    c9cc:	2a 81       	ldd	r18, Y+2	; 0x02
    c9ce:	22 95       	swap	r18
    c9d0:	2f 70       	andi	r18, 0x0F	; 15
    c9d2:	f4 01       	movw	r30, r8
    c9d4:	20 83       	st	Z, r18
    c9d6:	11 82       	std	Z+1, r1	; 0x01
	*motorType = (PMDuint16)((chip & 0x0F00) >> 8);
    c9d8:	49 81       	ldd	r20, Y+1	; 0x01
    c9da:	5a 81       	ldd	r21, Y+2	; 0x02
    c9dc:	9a 01       	movw	r18, r20
    c9de:	20 70       	andi	r18, 0x00	; 0
    c9e0:	3f 70       	andi	r19, 0x0F	; 15
    c9e2:	f3 01       	movw	r30, r6
    c9e4:	30 83       	st	Z, r19
    c9e6:	11 82       	std	Z+1, r1	; 0x01
	*numberAxes = (PMDuint16)((chip & 0x00F0) >> 4);
    c9e8:	9a 01       	movw	r18, r20
    c9ea:	20 7f       	andi	r18, 0xF0	; 240
    c9ec:	30 70       	andi	r19, 0x00	; 0
    c9ee:	64 e0       	ldi	r22, 0x04	; 4
    c9f0:	36 95       	lsr	r19
    c9f2:	27 95       	ror	r18
    c9f4:	6a 95       	dec	r22
    c9f6:	e1 f7       	brne	.-8      	; 0xc9f0 <PMDGetVersion+0x78>
    c9f8:	f2 01       	movw	r30, r4
    c9fa:	31 83       	std	Z+1, r19	; 0x01
    c9fc:	20 83       	st	Z, r18
	*special = (PMDuint16)(chip & 0x000F);
    c9fe:	4f 70       	andi	r20, 0x0F	; 15
    ca00:	50 70       	andi	r21, 0x00	; 0
    ca02:	f1 01       	movw	r30, r2
    ca04:	51 83       	std	Z+1, r21	; 0x01
    ca06:	40 83       	st	Z, r20

	*custom = (PMDuint16)((software & 0xFF00) >> 8);
    ca08:	2c 81       	ldd	r18, Y+4	; 0x04
    ca0a:	f8 01       	movw	r30, r16
    ca0c:	20 83       	st	Z, r18
    ca0e:	11 82       	std	Z+1, r1	; 0x01
	*major = (PMDuint16)((software & 0x00F0) >> 4);
    ca10:	4b 81       	ldd	r20, Y+3	; 0x03
    ca12:	5c 81       	ldd	r21, Y+4	; 0x04
    ca14:	9a 01       	movw	r18, r20
    ca16:	20 7f       	andi	r18, 0xF0	; 240
    ca18:	30 70       	andi	r19, 0x00	; 0
    ca1a:	14 e0       	ldi	r17, 0x04	; 4
    ca1c:	36 95       	lsr	r19
    ca1e:	27 95       	ror	r18
    ca20:	1a 95       	dec	r17
    ca22:	e1 f7       	brne	.-8      	; 0xca1c <PMDGetVersion+0xa4>
    ca24:	f7 01       	movw	r30, r14
    ca26:	31 83       	std	Z+1, r19	; 0x01
    ca28:	20 83       	st	Z, r18
	*minor = (PMDuint16)(software & 0x000F);
    ca2a:	4f 70       	andi	r20, 0x0F	; 15
    ca2c:	50 70       	andi	r21, 0x00	; 0
    ca2e:	f5 01       	movw	r30, r10
    ca30:	51 83       	std	Z+1, r21	; 0x01
    ca32:	40 83       	st	Z, r20

	return result;
}
    ca34:	0f 90       	pop	r0
    ca36:	0f 90       	pop	r0
    ca38:	0f 90       	pop	r0
    ca3a:	0f 90       	pop	r0
    ca3c:	cf 91       	pop	r28
    ca3e:	df 91       	pop	r29
    ca40:	1f 91       	pop	r17
    ca42:	0f 91       	pop	r16
    ca44:	ff 90       	pop	r15
    ca46:	ef 90       	pop	r14
    ca48:	df 90       	pop	r13
    ca4a:	cf 90       	pop	r12
    ca4c:	bf 90       	pop	r11
    ca4e:	af 90       	pop	r10
    ca50:	9f 90       	pop	r9
    ca52:	8f 90       	pop	r8
    ca54:	7f 90       	pop	r7
    ca56:	6f 90       	pop	r6
    ca58:	5f 90       	pop	r5
    ca5a:	4f 90       	pop	r4
    ca5c:	3f 90       	pop	r3
    ca5e:	2f 90       	pop	r2
    ca60:	08 95       	ret

0000ca62 <PMDGetEncoderToStepRatio>:
{
	return SendCommandWordWord(axis_handle, PMDOPSetEncoderToStepRatio, encoderCounts, steps);
}

PMDresult PMDGetEncoderToStepRatio(PMDAxisHandle* axis_handle, PMDuint16* encoderCounts, PMDuint16* steps)
{
    ca62:	fb 01       	movw	r30, r22
    ca64:	9a 01       	movw	r18, r20
	return SendCommandGetWordWord(axis_handle, PMDOPGetEncoderToStepRatio, encoderCounts, steps);
    ca66:	6f ed       	ldi	r22, 0xDF	; 223
    ca68:	70 e0       	ldi	r23, 0x00	; 0
    ca6a:	af 01       	movw	r20, r30
    ca6c:	0e 94 90 6c 	call	0xd920	; 0xd920 <SendCommandGetWordWord>
}
    ca70:	08 95       	ret

0000ca72 <PMDNoOperation>:
	
}

PMDresult PMDNoOperation(PMDAxisHandle* axis_handle)
{
	return SendCommand(axis_handle, PMDOPNoOperation);
    ca72:	60 e0       	ldi	r22, 0x00	; 0
    ca74:	70 e0       	ldi	r23, 0x00	; 0
    ca76:	0e 94 5d 6b 	call	0xd6ba	; 0xd6ba <SendCommand>
}
    ca7a:	08 95       	ret

0000ca7c <PMDReset>:
{
	return SendCommandWordGetWord(axis_handle, PMDOPReadAnalog, analogID, data);
}

PMDresult PMDReset(PMDAxisHandle* axis_handle)
{
    ca7c:	ef 92       	push	r14
    ca7e:	ff 92       	push	r15
    ca80:	0f 93       	push	r16
    ca82:	1f 93       	push	r17
    ca84:	8c 01       	movw	r16, r24
    PMDAxis	axis = axis_handle->axis;
    ca86:	fc 01       	movw	r30, r24
    ca88:	e2 80       	ldd	r14, Z+2	; 0x02
    ca8a:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// for the reset command, the axis number MUST be zero
	axis_handle->axis = 0;
    ca8c:	13 82       	std	Z+3, r1	; 0x03
    ca8e:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommand(axis_handle, PMDOPReset);
    ca90:	69 e3       	ldi	r22, 0x39	; 57
    ca92:	70 e0       	ldi	r23, 0x00	; 0
    ca94:	0e 94 5d 6b 	call	0xd6ba	; 0xd6ba <SendCommand>

	axis_handle->axis = axis;
    ca98:	f8 01       	movw	r30, r16
    ca9a:	f3 82       	std	Z+3, r15	; 0x03
    ca9c:	e2 82       	std	Z+2, r14	; 0x02

	return result;
	
}
    ca9e:	1f 91       	pop	r17
    caa0:	0f 91       	pop	r16
    caa2:	ff 90       	pop	r15
    caa4:	ef 90       	pop	r14
    caa6:	08 95       	ret

0000caa8 <PMDInitializePhase>:
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseCorrectionMode, mode);
}

PMDresult PMDInitializePhase(PMDAxisHandle* axis_handle)
{
	return SendCommand(axis_handle, PMDOPInitializePhase);
    caa8:	6a e7       	ldi	r22, 0x7A	; 122
    caaa:	70 e0       	ldi	r23, 0x00	; 0
    caac:	0e 94 5d 6b 	call	0xd6ba	; 0xd6ba <SendCommand>
}
    cab0:	08 95       	ret

0000cab2 <PMDClearInterrupt>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetInterruptMask, interruptMask);
}

PMDresult PMDClearInterrupt(PMDAxisHandle* axis_handle)
{
    cab2:	ef 92       	push	r14
    cab4:	ff 92       	push	r15
    cab6:	0f 93       	push	r16
    cab8:	1f 93       	push	r17
    caba:	8c 01       	movw	r16, r24
	PMDAxis axis = axis_handle->axis;
    cabc:	fc 01       	movw	r30, r24
    cabe:	e2 80       	ldd	r14, Z+2	; 0x02
    cac0:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// for the ClearInterrupt command, the axis number MUST be zero
	axis_handle->axis = 0;
    cac2:	13 82       	std	Z+3, r1	; 0x03
    cac4:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommand(axis_handle, PMDOPClearInterrupt);
    cac6:	6c ea       	ldi	r22, 0xAC	; 172
    cac8:	70 e0       	ldi	r23, 0x00	; 0
    caca:	0e 94 5d 6b 	call	0xd6ba	; 0xd6ba <SendCommand>

	axis_handle->axis = axis;
    cace:	f8 01       	movw	r30, r16
    cad0:	f3 82       	std	Z+3, r15	; 0x03
    cad2:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    cad4:	1f 91       	pop	r17
    cad6:	0f 91       	pop	r16
    cad8:	ff 90       	pop	r15
    cada:	ef 90       	pop	r14
    cadc:	08 95       	ret

0000cade <PMDUpdate>:
	return SendCommandWordGetLong(axis_handle, PMDOPGetBreakpointValue, breakpointID, (PMDuint32*)breakpointValue);
}

PMDresult PMDUpdate(PMDAxisHandle* axis_handle)
{
	return SendCommand(axis_handle, PMDOPUpdate);
    cade:	6a e1       	ldi	r22, 0x1A	; 26
    cae0:	70 e0       	ldi	r23, 0x00	; 0
    cae2:	0e 94 5d 6b 	call	0xd6ba	; 0xd6ba <SendCommand>
}
    cae6:	08 95       	ret

0000cae8 <PMDClearPositionError>:
	return SendCommandGetWord(axis_handle, PMDOPGetMotionCompleteMode, mode);
}

PMDresult PMDClearPositionError(PMDAxisHandle* axis_handle)
{
	return SendCommand(axis_handle, PMDOPClearPositionError);
    cae8:	67 e4       	ldi	r22, 0x47	; 71
    caea:	70 e0       	ldi	r23, 0x00	; 0
    caec:	0e 94 5d 6b 	call	0xd6ba	; 0xd6ba <SendCommand>
}
    caf0:	08 95       	ret

0000caf2 <PMDReadAnalog>:
{
	return SendCommandWordGetWord(axis_handle, PMDOPReadIO, address, data);
}

PMDresult PMDReadAnalog(PMDAxisHandle* axis_handle, PMDuint16 analogID, PMDuint16* data)
{
    caf2:	fb 01       	movw	r30, r22
    caf4:	9a 01       	movw	r18, r20
	return SendCommandWordGetWord(axis_handle, PMDOPReadAnalog, analogID, data);
    caf6:	6f ee       	ldi	r22, 0xEF	; 239
    caf8:	70 e0       	ldi	r23, 0x00	; 0
    cafa:	af 01       	movw	r20, r30
    cafc:	0e 94 1d 6d 	call	0xda3a	; 0xda3a <SendCommandWordGetWord>
}
    cb00:	08 95       	ret

0000cb02 <PMDReadIO>:
{
	return SendCommandWordWord(axis_handle, PMDOPWriteIO, address, data);
}

PMDresult PMDReadIO(PMDAxisHandle* axis_handle, PMDuint16 address, PMDuint16* data)
{
    cb02:	fb 01       	movw	r30, r22
    cb04:	9a 01       	movw	r18, r20
	return SendCommandWordGetWord(axis_handle, PMDOPReadIO, address, data);
    cb06:	63 e8       	ldi	r22, 0x83	; 131
    cb08:	70 e0       	ldi	r23, 0x00	; 0
    cb0a:	af 01       	movw	r20, r30
    cb0c:	0e 94 1d 6d 	call	0xda3a	; 0xda3a <SendCommandWordGetWord>
}
    cb10:	08 95       	ret

0000cb12 <PMDGetTraceVariable>:

	return result;
}

PMDresult PMDGetTraceVariable(PMDAxisHandle* axis_handle, PMDuint16 traceID, PMDAxis *traceAxis, PMDuint8* variable)
{
    cb12:	af 92       	push	r10
    cb14:	bf 92       	push	r11
    cb16:	cf 92       	push	r12
    cb18:	df 92       	push	r13
    cb1a:	ef 92       	push	r14
    cb1c:	ff 92       	push	r15
    cb1e:	0f 93       	push	r16
    cb20:	1f 93       	push	r17
    cb22:	df 93       	push	r29
    cb24:	cf 93       	push	r28
    cb26:	00 d0       	rcall	.+0      	; 0xcb28 <PMDGetTraceVariable+0x16>
    cb28:	cd b7       	in	r28, 0x3d	; 61
    cb2a:	de b7       	in	r29, 0x3e	; 62
    cb2c:	8c 01       	movw	r16, r24
    cb2e:	fb 01       	movw	r30, r22
    cb30:	7a 01       	movw	r14, r20
    cb32:	69 01       	movw	r12, r18
	PMDAxis axis = axis_handle->axis;
    cb34:	dc 01       	movw	r26, r24
    cb36:	12 96       	adiw	r26, 0x02	; 2
    cb38:	ad 90       	ld	r10, X+
    cb3a:	bc 90       	ld	r11, X
    cb3c:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;
	PMDuint16 value;

	// set the axis number to zero
	axis_handle->axis = 0;
    cb3e:	13 96       	adiw	r26, 0x03	; 3
    cb40:	1c 92       	st	X, r1
    cb42:	1e 92       	st	-X, r1
    cb44:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetWord(axis_handle, PMDOPGetTraceVariable, traceID, &value);
    cb46:	67 eb       	ldi	r22, 0xB7	; 183
    cb48:	70 e0       	ldi	r23, 0x00	; 0
    cb4a:	af 01       	movw	r20, r30
    cb4c:	9e 01       	movw	r18, r28
    cb4e:	2f 5f       	subi	r18, 0xFF	; 255
    cb50:	3f 4f       	sbci	r19, 0xFF	; 255
    cb52:	0e 94 1d 6d 	call	0xda3a	; 0xda3a <SendCommandWordGetWord>
	*traceAxis = (PMDAxis)(value & nibbleMask);
    cb56:	29 81       	ldd	r18, Y+1	; 0x01
    cb58:	3a 81       	ldd	r19, Y+2	; 0x02
    cb5a:	2f 70       	andi	r18, 0x0F	; 15
    cb5c:	30 70       	andi	r19, 0x00	; 0
    cb5e:	f7 01       	movw	r30, r14
    cb60:	31 83       	std	Z+1, r19	; 0x01
    cb62:	20 83       	st	Z, r18
	*variable = (PMDuint8)((value >> 8) & byteMask);
    cb64:	2a 81       	ldd	r18, Y+2	; 0x02
    cb66:	d6 01       	movw	r26, r12
    cb68:	2c 93       	st	X, r18

	axis_handle->axis = axis;
    cb6a:	f8 01       	movw	r30, r16
    cb6c:	b3 82       	std	Z+3, r11	; 0x03
    cb6e:	a2 82       	std	Z+2, r10	; 0x02

	return result;
}
    cb70:	0f 90       	pop	r0
    cb72:	0f 90       	pop	r0
    cb74:	cf 91       	pop	r28
    cb76:	df 91       	pop	r29
    cb78:	1f 91       	pop	r17
    cb7a:	0f 91       	pop	r16
    cb7c:	ff 90       	pop	r15
    cb7e:	ef 90       	pop	r14
    cb80:	df 90       	pop	r13
    cb82:	cf 90       	pop	r12
    cb84:	bf 90       	pop	r11
    cb86:	af 90       	pop	r10
    cb88:	08 95       	ret

0000cb8a <PMDGetBufferFunction>:
{
	return SendCommandWordWord(axis_handle, PMDOPSetBufferFunction, function, (PMDuint16)bufferID);
}

PMDresult PMDGetBufferFunction(PMDAxisHandle* axis_handle, PMDuint16 function, PMDint16* bufferID)
{
    cb8a:	fb 01       	movw	r30, r22
    cb8c:	9a 01       	movw	r18, r20
	return SendCommandWordGetWord(axis_handle, PMDOPGetBufferFunction, function, (PMDuint16*)bufferID);
    cb8e:	6b ec       	ldi	r22, 0xCB	; 203
    cb90:	70 e0       	ldi	r23, 0x00	; 0
    cb92:	af 01       	movw	r20, r30
    cb94:	0e 94 1d 6d 	call	0xda3a	; 0xda3a <SendCommandWordGetWord>
}
    cb98:	08 95       	ret

0000cb9a <PMDGetPhaseCommand>:
{
	return SendCommand(axis_handle, PMDOPInitializePhase);
}

PMDresult PMDGetPhaseCommand(PMDAxisHandle* axis_handle, PMDuint16 phase, PMDint16* command)
{
    cb9a:	fb 01       	movw	r30, r22
    cb9c:	9a 01       	movw	r18, r20
	return SendCommandWordGetWord(axis_handle, PMDOPGetPhaseCommand, phase, (PMDuint16*)command);
    cb9e:	6a ee       	ldi	r22, 0xEA	; 234
    cba0:	70 e0       	ldi	r23, 0x00	; 0
    cba2:	af 01       	movw	r20, r30
    cba4:	0e 94 1d 6d 	call	0xda3a	; 0xda3a <SendCommandWordGetWord>
}
    cba8:	08 95       	ret

0000cbaa <PMDGetBreakpoint>:
	return SendCommandWordWord(axis_handle, PMDOPSetBreakpoint, breakpointID, value);
}

PMDresult PMDGetBreakpoint(PMDAxisHandle* axis_handle, PMDuint16 breakpointID, 
						   PMDAxis* breakAxis, PMDuint8* action, PMDuint8* trigger)
{
    cbaa:	cf 92       	push	r12
    cbac:	df 92       	push	r13
    cbae:	ef 92       	push	r14
    cbb0:	ff 92       	push	r15
    cbb2:	0f 93       	push	r16
    cbb4:	1f 93       	push	r17
    cbb6:	df 93       	push	r29
    cbb8:	cf 93       	push	r28
    cbba:	00 d0       	rcall	.+0      	; 0xcbbc <PMDGetBreakpoint+0x12>
    cbbc:	cd b7       	in	r28, 0x3d	; 61
    cbbe:	de b7       	in	r29, 0x3e	; 62
    cbc0:	fb 01       	movw	r30, r22
    cbc2:	7a 01       	movw	r14, r20
    cbc4:	69 01       	movw	r12, r18
	PMDuint16 result;
	PMDuint16 value;

	result = SendCommandWordGetWord(axis_handle, PMDOPGetBreakpoint, breakpointID, &value);
    cbc6:	65 ed       	ldi	r22, 0xD5	; 213
    cbc8:	70 e0       	ldi	r23, 0x00	; 0
    cbca:	af 01       	movw	r20, r30
    cbcc:	9e 01       	movw	r18, r28
    cbce:	2f 5f       	subi	r18, 0xFF	; 255
    cbd0:	3f 4f       	sbci	r19, 0xFF	; 255
    cbd2:	0e 94 1d 6d 	call	0xda3a	; 0xda3a <SendCommandWordGetWord>

	*breakAxis = (PMDAxis)(value & nibbleMask);
    cbd6:	29 81       	ldd	r18, Y+1	; 0x01
    cbd8:	3a 81       	ldd	r19, Y+2	; 0x02
    cbda:	a9 01       	movw	r20, r18
    cbdc:	4f 70       	andi	r20, 0x0F	; 15
    cbde:	50 70       	andi	r21, 0x00	; 0
    cbe0:	f7 01       	movw	r30, r14
    cbe2:	51 83       	std	Z+1, r21	; 0x01
    cbe4:	40 83       	st	Z, r20
	*action = (PMDuint8)((value >> 4) & nibbleMask);
    cbe6:	74 e0       	ldi	r23, 0x04	; 4
    cbe8:	36 95       	lsr	r19
    cbea:	27 95       	ror	r18
    cbec:	7a 95       	dec	r23
    cbee:	e1 f7       	brne	.-8      	; 0xcbe8 <PMDGetBreakpoint+0x3e>
    cbf0:	2f 70       	andi	r18, 0x0F	; 15
    cbf2:	f6 01       	movw	r30, r12
    cbf4:	20 83       	st	Z, r18
	*trigger = (PMDuint8)((value >> 8) & byteMask);
    cbf6:	2a 81       	ldd	r18, Y+2	; 0x02
    cbf8:	f8 01       	movw	r30, r16
    cbfa:	20 83       	st	Z, r18

	return result;
}
    cbfc:	0f 90       	pop	r0
    cbfe:	0f 90       	pop	r0
    cc00:	cf 91       	pop	r28
    cc02:	df 91       	pop	r29
    cc04:	1f 91       	pop	r17
    cc06:	0f 91       	pop	r16
    cc08:	ff 90       	pop	r15
    cc0a:	ef 90       	pop	r14
    cc0c:	df 90       	pop	r13
    cc0e:	cf 90       	pop	r12
    cc10:	08 95       	ret

0000cc12 <PMDWriteIO>:

	return result;
}

PMDresult PMDWriteIO(PMDAxisHandle* axis_handle, PMDuint16 address, PMDuint16 data)
{
    cc12:	fb 01       	movw	r30, r22
    cc14:	9a 01       	movw	r18, r20
	return SendCommandWordWord(axis_handle, PMDOPWriteIO, address, data);
    cc16:	62 e8       	ldi	r22, 0x82	; 130
    cc18:	70 e0       	ldi	r23, 0x00	; 0
    cc1a:	af 01       	movw	r20, r30
    cc1c:	0e 94 b0 6b 	call	0xd760	; 0xd760 <SendCommandWordWord>
}
    cc20:	08 95       	ret

0000cc22 <PMDSetTraceVariable>:

	return result;
}

PMDresult PMDSetTraceVariable(PMDAxisHandle* axis_handle, PMDuint16 traceID, PMDAxis traceAxis, PMDuint8 variable)
{
    cc22:	ef 92       	push	r14
    cc24:	ff 92       	push	r15
    cc26:	0f 93       	push	r16
    cc28:	1f 93       	push	r17
    cc2a:	8c 01       	movw	r16, r24
    cc2c:	fb 01       	movw	r30, r22
    cc2e:	82 2f       	mov	r24, r18
	PMDAxis axis = axis_handle->axis;
    cc30:	d8 01       	movw	r26, r16
    cc32:	12 96       	adiw	r26, 0x02	; 2
    cc34:	ed 90       	ld	r14, X+
    cc36:	fc 90       	ld	r15, X
    cc38:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;
	PMDuint16 value;

	// set the axis number to zero
	axis_handle->axis = 0;
    cc3a:	13 96       	adiw	r26, 0x03	; 3
    cc3c:	1c 92       	st	X, r1
    cc3e:	1e 92       	st	-X, r1
    cc40:	12 97       	sbiw	r26, 0x02	; 2

	value = (PMDuint16)((traceAxis & nibbleMask) | ((variable & byteMask) << 8));
	result = SendCommandWordWord(axis_handle, PMDOPSetTraceVariable, traceID, value);
    cc42:	38 2f       	mov	r19, r24
    cc44:	20 e0       	ldi	r18, 0x00	; 0
    cc46:	4f 70       	andi	r20, 0x0F	; 15
    cc48:	50 70       	andi	r21, 0x00	; 0
    cc4a:	24 2b       	or	r18, r20
    cc4c:	35 2b       	or	r19, r21
    cc4e:	c8 01       	movw	r24, r16
    cc50:	66 eb       	ldi	r22, 0xB6	; 182
    cc52:	70 e0       	ldi	r23, 0x00	; 0
    cc54:	af 01       	movw	r20, r30
    cc56:	0e 94 b0 6b 	call	0xd760	; 0xd760 <SendCommandWordWord>

	axis_handle->axis = axis;
    cc5a:	f8 01       	movw	r30, r16
    cc5c:	f3 82       	std	Z+3, r15	; 0x03
    cc5e:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    cc60:	1f 91       	pop	r17
    cc62:	0f 91       	pop	r16
    cc64:	ff 90       	pop	r15
    cc66:	ef 90       	pop	r14
    cc68:	08 95       	ret

0000cc6a <PMDSetBufferFunction>:

	return result;
}

PMDresult PMDSetBufferFunction(PMDAxisHandle* axis_handle, PMDuint16 function, PMDint16 bufferID)
{
    cc6a:	fb 01       	movw	r30, r22
    cc6c:	9a 01       	movw	r18, r20
	return SendCommandWordWord(axis_handle, PMDOPSetBufferFunction, function, (PMDuint16)bufferID);
    cc6e:	6a ec       	ldi	r22, 0xCA	; 202
    cc70:	70 e0       	ldi	r23, 0x00	; 0
    cc72:	af 01       	movw	r20, r30
    cc74:	0e 94 b0 6b 	call	0xd760	; 0xd760 <SendCommandWordWord>
}
    cc78:	08 95       	ret

0000cc7a <PMDSetEncoderToStepRatio>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetEncoderModulus, modulus);
}

PMDresult PMDSetEncoderToStepRatio(PMDAxisHandle* axis_handle, PMDuint16 encoderCounts, PMDuint16 steps)
{
    cc7a:	fb 01       	movw	r30, r22
    cc7c:	9a 01       	movw	r18, r20
	return SendCommandWordWord(axis_handle, PMDOPSetEncoderToStepRatio, encoderCounts, steps);
    cc7e:	6e ed       	ldi	r22, 0xDE	; 222
    cc80:	70 e0       	ldi	r23, 0x00	; 0
    cc82:	af 01       	movw	r20, r30
    cc84:	0e 94 b0 6b 	call	0xd760	; 0xd760 <SendCommandWordWord>
}
    cc88:	08 95       	ret

0000cc8a <PMDSetBreakpoint>:


// Parameter Update & Breakpoints
PMDresult PMDSetBreakpoint(PMDAxisHandle* axis_handle, PMDuint16 breakpointID, 
						   PMDAxis breakAxis, PMDuint8 action, PMDuint8 trigger)
{
    cc8a:	0f 93       	push	r16
    cc8c:	fb 01       	movw	r30, r22
	PMDuint16 value = (PMDuint16)((breakAxis & nibbleMask) | 
		((action & nibbleMask) << 4) | ((trigger & byteMask) << 8));
	return SendCommandWordWord(axis_handle, PMDOPSetBreakpoint, breakpointID, value);
    cc8e:	30 e0       	ldi	r19, 0x00	; 0
    cc90:	a4 e0       	ldi	r26, 0x04	; 4
    cc92:	22 0f       	add	r18, r18
    cc94:	33 1f       	adc	r19, r19
    cc96:	aa 95       	dec	r26
    cc98:	e1 f7       	brne	.-8      	; 0xcc92 <PMDSetBreakpoint+0x8>
    cc9a:	30 70       	andi	r19, 0x00	; 0
    cc9c:	70 2f       	mov	r23, r16
    cc9e:	60 e0       	ldi	r22, 0x00	; 0
    cca0:	26 2b       	or	r18, r22
    cca2:	37 2b       	or	r19, r23
    cca4:	4f 70       	andi	r20, 0x0F	; 15
    cca6:	50 70       	andi	r21, 0x00	; 0
    cca8:	24 2b       	or	r18, r20
    ccaa:	35 2b       	or	r19, r21
    ccac:	64 ed       	ldi	r22, 0xD4	; 212
    ccae:	70 e0       	ldi	r23, 0x00	; 0
    ccb0:	af 01       	movw	r20, r30
    ccb2:	0e 94 b0 6b 	call	0xd760	; 0xd760 <SendCommandWordWord>
}
    ccb6:	0f 91       	pop	r16
    ccb8:	08 95       	ret

0000ccba <PMDGetBufferReadIndex>:

	return result;
}

PMDresult PMDGetBufferReadIndex(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32* readIndex)
{
    ccba:	ef 92       	push	r14
    ccbc:	ff 92       	push	r15
    ccbe:	0f 93       	push	r16
    ccc0:	1f 93       	push	r17
    ccc2:	8c 01       	movw	r16, r24
    ccc4:	fb 01       	movw	r30, r22
    ccc6:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    ccc8:	dc 01       	movw	r26, r24
    ccca:	12 96       	adiw	r26, 0x02	; 2
    cccc:	ed 90       	ld	r14, X+
    ccce:	fc 90       	ld	r15, X
    ccd0:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    ccd2:	13 96       	adiw	r26, 0x03	; 3
    ccd4:	1c 92       	st	X, r1
    ccd6:	1e 92       	st	-X, r1
    ccd8:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetLong(axis_handle, PMDOPGetBufferReadIndex, bufferID, readIndex);
    ccda:	67 ec       	ldi	r22, 0xC7	; 199
    ccdc:	70 e0       	ldi	r23, 0x00	; 0
    ccde:	af 01       	movw	r20, r30
    cce0:	0e 94 57 6d 	call	0xdaae	; 0xdaae <SendCommandWordGetLong>

	axis_handle->axis = axis;
    cce4:	f8 01       	movw	r30, r16
    cce6:	f3 82       	std	Z+3, r15	; 0x03
    cce8:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    ccea:	1f 91       	pop	r17
    ccec:	0f 91       	pop	r16
    ccee:	ff 90       	pop	r15
    ccf0:	ef 90       	pop	r14
    ccf2:	08 95       	ret

0000ccf4 <PMDGetBufferWriteIndex>:

	return result;
}

PMDresult PMDGetBufferWriteIndex(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32* writeIndex)
{
    ccf4:	ef 92       	push	r14
    ccf6:	ff 92       	push	r15
    ccf8:	0f 93       	push	r16
    ccfa:	1f 93       	push	r17
    ccfc:	8c 01       	movw	r16, r24
    ccfe:	fb 01       	movw	r30, r22
    cd00:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    cd02:	dc 01       	movw	r26, r24
    cd04:	12 96       	adiw	r26, 0x02	; 2
    cd06:	ed 90       	ld	r14, X+
    cd08:	fc 90       	ld	r15, X
    cd0a:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    cd0c:	13 96       	adiw	r26, 0x03	; 3
    cd0e:	1c 92       	st	X, r1
    cd10:	1e 92       	st	-X, r1
    cd12:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetLong(axis_handle, PMDOPGetBufferWriteIndex, bufferID, writeIndex);
    cd14:	65 ec       	ldi	r22, 0xC5	; 197
    cd16:	70 e0       	ldi	r23, 0x00	; 0
    cd18:	af 01       	movw	r20, r30
    cd1a:	0e 94 57 6d 	call	0xdaae	; 0xdaae <SendCommandWordGetLong>

	axis_handle->axis = axis;
    cd1e:	f8 01       	movw	r30, r16
    cd20:	f3 82       	std	Z+3, r15	; 0x03
    cd22:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    cd24:	1f 91       	pop	r17
    cd26:	0f 91       	pop	r16
    cd28:	ff 90       	pop	r15
    cd2a:	ef 90       	pop	r14
    cd2c:	08 95       	ret

0000cd2e <PMDReadBuffer>:

	return result;
}

PMDresult PMDReadBuffer(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDint32* data)
{
    cd2e:	ef 92       	push	r14
    cd30:	ff 92       	push	r15
    cd32:	0f 93       	push	r16
    cd34:	1f 93       	push	r17
    cd36:	8c 01       	movw	r16, r24
    cd38:	fb 01       	movw	r30, r22
    cd3a:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    cd3c:	dc 01       	movw	r26, r24
    cd3e:	12 96       	adiw	r26, 0x02	; 2
    cd40:	ed 90       	ld	r14, X+
    cd42:	fc 90       	ld	r15, X
    cd44:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    cd46:	13 96       	adiw	r26, 0x03	; 3
    cd48:	1c 92       	st	X, r1
    cd4a:	1e 92       	st	-X, r1
    cd4c:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetLong(axis_handle, PMDOPReadBuffer, bufferID, (PMDuint32*)data);
    cd4e:	69 ec       	ldi	r22, 0xC9	; 201
    cd50:	70 e0       	ldi	r23, 0x00	; 0
    cd52:	af 01       	movw	r20, r30
    cd54:	0e 94 57 6d 	call	0xdaae	; 0xdaae <SendCommandWordGetLong>

	axis_handle->axis = axis;
    cd58:	f8 01       	movw	r30, r16
    cd5a:	f3 82       	std	Z+3, r15	; 0x03
    cd5c:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    cd5e:	1f 91       	pop	r17
    cd60:	0f 91       	pop	r16
    cd62:	ff 90       	pop	r15
    cd64:	ef 90       	pop	r14
    cd66:	08 95       	ret

0000cd68 <PMDGetBufferLength>:

	return result;
}

PMDresult PMDGetBufferLength(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32* bufferLength)
{
    cd68:	ef 92       	push	r14
    cd6a:	ff 92       	push	r15
    cd6c:	0f 93       	push	r16
    cd6e:	1f 93       	push	r17
    cd70:	8c 01       	movw	r16, r24
    cd72:	fb 01       	movw	r30, r22
    cd74:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    cd76:	dc 01       	movw	r26, r24
    cd78:	12 96       	adiw	r26, 0x02	; 2
    cd7a:	ed 90       	ld	r14, X+
    cd7c:	fc 90       	ld	r15, X
    cd7e:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    cd80:	13 96       	adiw	r26, 0x03	; 3
    cd82:	1c 92       	st	X, r1
    cd84:	1e 92       	st	-X, r1
    cd86:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetLong(axis_handle, PMDOPGetBufferLength, bufferID, bufferLength);
    cd88:	63 ec       	ldi	r22, 0xC3	; 195
    cd8a:	70 e0       	ldi	r23, 0x00	; 0
    cd8c:	af 01       	movw	r20, r30
    cd8e:	0e 94 57 6d 	call	0xdaae	; 0xdaae <SendCommandWordGetLong>

	axis_handle->axis = axis;
    cd92:	f8 01       	movw	r30, r16
    cd94:	f3 82       	std	Z+3, r15	; 0x03
    cd96:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    cd98:	1f 91       	pop	r17
    cd9a:	0f 91       	pop	r16
    cd9c:	ff 90       	pop	r15
    cd9e:	ef 90       	pop	r14
    cda0:	08 95       	ret

0000cda2 <PMDGetBufferStart>:

	return result;
}

PMDresult PMDGetBufferStart(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32* bufferStart)
{
    cda2:	ef 92       	push	r14
    cda4:	ff 92       	push	r15
    cda6:	0f 93       	push	r16
    cda8:	1f 93       	push	r17
    cdaa:	8c 01       	movw	r16, r24
    cdac:	fb 01       	movw	r30, r22
    cdae:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    cdb0:	dc 01       	movw	r26, r24
    cdb2:	12 96       	adiw	r26, 0x02	; 2
    cdb4:	ed 90       	ld	r14, X+
    cdb6:	fc 90       	ld	r15, X
    cdb8:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    cdba:	13 96       	adiw	r26, 0x03	; 3
    cdbc:	1c 92       	st	X, r1
    cdbe:	1e 92       	st	-X, r1
    cdc0:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetLong(axis_handle, PMDOPGetBufferStart, bufferID, bufferStart);
    cdc2:	61 ec       	ldi	r22, 0xC1	; 193
    cdc4:	70 e0       	ldi	r23, 0x00	; 0
    cdc6:	af 01       	movw	r20, r30
    cdc8:	0e 94 57 6d 	call	0xdaae	; 0xdaae <SendCommandWordGetLong>

	axis_handle->axis = axis;
    cdcc:	f8 01       	movw	r30, r16
    cdce:	f3 82       	std	Z+3, r15	; 0x03
    cdd0:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    cdd2:	1f 91       	pop	r17
    cdd4:	0f 91       	pop	r16
    cdd6:	ff 90       	pop	r15
    cdd8:	ef 90       	pop	r14
    cdda:	08 95       	ret

0000cddc <PMDGetBreakpointValue>:
{
	return SendCommandWordLong(axis_handle, PMDOPSetBreakpointValue, breakpointID, (PMDuint32)breakpointValue);
}

PMDresult PMDGetBreakpointValue(PMDAxisHandle* axis_handle, PMDuint16 breakpointID, PMDint32* breakpointValue)
{
    cddc:	fb 01       	movw	r30, r22
    cdde:	9a 01       	movw	r18, r20
	return SendCommandWordGetLong(axis_handle, PMDOPGetBreakpointValue, breakpointID, (PMDuint32*)breakpointValue);
    cde0:	67 ed       	ldi	r22, 0xD7	; 215
    cde2:	70 e0       	ldi	r23, 0x00	; 0
    cde4:	af 01       	movw	r20, r30
    cde6:	0e 94 57 6d 	call	0xdaae	; 0xdaae <SendCommandWordGetLong>
}
    cdea:	08 95       	ret

0000cdec <PMDSetBufferReadIndex>:

	return result;
}

PMDresult PMDSetBufferReadIndex(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32 readIndex)
{
    cdec:	cf 92       	push	r12
    cdee:	df 92       	push	r13
    cdf0:	ef 92       	push	r14
    cdf2:	ff 92       	push	r15
    cdf4:	0f 93       	push	r16
    cdf6:	1f 93       	push	r17
    cdf8:	7c 01       	movw	r14, r24
    cdfa:	fb 01       	movw	r30, r22
    cdfc:	89 01       	movw	r16, r18
    cdfe:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    ce00:	dc 01       	movw	r26, r24
    ce02:	12 96       	adiw	r26, 0x02	; 2
    ce04:	cd 90       	ld	r12, X+
    ce06:	dc 90       	ld	r13, X
    ce08:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    ce0a:	13 96       	adiw	r26, 0x03	; 3
    ce0c:	1c 92       	st	X, r1
    ce0e:	1e 92       	st	-X, r1
    ce10:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordLong(axis_handle, PMDOPSetBufferReadIndex, bufferID, readIndex);
    ce12:	66 ec       	ldi	r22, 0xC6	; 198
    ce14:	70 e0       	ldi	r23, 0x00	; 0
    ce16:	af 01       	movw	r20, r30
    ce18:	0e 94 1d 6c 	call	0xd83a	; 0xd83a <SendCommandWordLong>

	axis_handle->axis = axis;
    ce1c:	f7 01       	movw	r30, r14
    ce1e:	d3 82       	std	Z+3, r13	; 0x03
    ce20:	c2 82       	std	Z+2, r12	; 0x02

	return result;
}
    ce22:	1f 91       	pop	r17
    ce24:	0f 91       	pop	r16
    ce26:	ff 90       	pop	r15
    ce28:	ef 90       	pop	r14
    ce2a:	df 90       	pop	r13
    ce2c:	cf 90       	pop	r12
    ce2e:	08 95       	ret

0000ce30 <PMDSetBufferWriteIndex>:

	return result;
}

PMDresult PMDSetBufferWriteIndex(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32 writeIndex)
{
    ce30:	cf 92       	push	r12
    ce32:	df 92       	push	r13
    ce34:	ef 92       	push	r14
    ce36:	ff 92       	push	r15
    ce38:	0f 93       	push	r16
    ce3a:	1f 93       	push	r17
    ce3c:	7c 01       	movw	r14, r24
    ce3e:	fb 01       	movw	r30, r22
    ce40:	89 01       	movw	r16, r18
    ce42:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    ce44:	dc 01       	movw	r26, r24
    ce46:	12 96       	adiw	r26, 0x02	; 2
    ce48:	cd 90       	ld	r12, X+
    ce4a:	dc 90       	ld	r13, X
    ce4c:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    ce4e:	13 96       	adiw	r26, 0x03	; 3
    ce50:	1c 92       	st	X, r1
    ce52:	1e 92       	st	-X, r1
    ce54:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordLong(axis_handle, PMDOPSetBufferWriteIndex, bufferID, writeIndex);
    ce56:	64 ec       	ldi	r22, 0xC4	; 196
    ce58:	70 e0       	ldi	r23, 0x00	; 0
    ce5a:	af 01       	movw	r20, r30
    ce5c:	0e 94 1d 6c 	call	0xd83a	; 0xd83a <SendCommandWordLong>

	axis_handle->axis = axis;
    ce60:	f7 01       	movw	r30, r14
    ce62:	d3 82       	std	Z+3, r13	; 0x03
    ce64:	c2 82       	std	Z+2, r12	; 0x02

	return result;
}
    ce66:	1f 91       	pop	r17
    ce68:	0f 91       	pop	r16
    ce6a:	ff 90       	pop	r15
    ce6c:	ef 90       	pop	r14
    ce6e:	df 90       	pop	r13
    ce70:	cf 90       	pop	r12
    ce72:	08 95       	ret

0000ce74 <PMDWriteBuffer>:
{
	return SendCommandWordGetWord(axis_handle, PMDOPGetBufferFunction, function, (PMDuint16*)bufferID);
}

PMDresult PMDWriteBuffer(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDint32 data)
{
    ce74:	cf 92       	push	r12
    ce76:	df 92       	push	r13
    ce78:	ef 92       	push	r14
    ce7a:	ff 92       	push	r15
    ce7c:	0f 93       	push	r16
    ce7e:	1f 93       	push	r17
    ce80:	7c 01       	movw	r14, r24
    ce82:	fb 01       	movw	r30, r22
    ce84:	89 01       	movw	r16, r18
    ce86:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    ce88:	dc 01       	movw	r26, r24
    ce8a:	12 96       	adiw	r26, 0x02	; 2
    ce8c:	cd 90       	ld	r12, X+
    ce8e:	dc 90       	ld	r13, X
    ce90:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    ce92:	13 96       	adiw	r26, 0x03	; 3
    ce94:	1c 92       	st	X, r1
    ce96:	1e 92       	st	-X, r1
    ce98:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordLong(axis_handle, PMDOPWriteBuffer, bufferID, (PMDuint32)data);
    ce9a:	68 ec       	ldi	r22, 0xC8	; 200
    ce9c:	70 e0       	ldi	r23, 0x00	; 0
    ce9e:	af 01       	movw	r20, r30
    cea0:	0e 94 1d 6c 	call	0xd83a	; 0xd83a <SendCommandWordLong>

	axis_handle->axis = axis;
    cea4:	f7 01       	movw	r30, r14
    cea6:	d3 82       	std	Z+3, r13	; 0x03
    cea8:	c2 82       	std	Z+2, r12	; 0x02

	return result;
}
    ceaa:	1f 91       	pop	r17
    ceac:	0f 91       	pop	r16
    ceae:	ff 90       	pop	r15
    ceb0:	ef 90       	pop	r14
    ceb2:	df 90       	pop	r13
    ceb4:	cf 90       	pop	r12
    ceb6:	08 95       	ret

0000ceb8 <PMDSetBufferLength>:

	return result;
}

PMDresult PMDSetBufferLength(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32 bufferLength)
{
    ceb8:	cf 92       	push	r12
    ceba:	df 92       	push	r13
    cebc:	ef 92       	push	r14
    cebe:	ff 92       	push	r15
    cec0:	0f 93       	push	r16
    cec2:	1f 93       	push	r17
    cec4:	7c 01       	movw	r14, r24
    cec6:	fb 01       	movw	r30, r22
    cec8:	89 01       	movw	r16, r18
    ceca:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    cecc:	dc 01       	movw	r26, r24
    cece:	12 96       	adiw	r26, 0x02	; 2
    ced0:	cd 90       	ld	r12, X+
    ced2:	dc 90       	ld	r13, X
    ced4:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    ced6:	13 96       	adiw	r26, 0x03	; 3
    ced8:	1c 92       	st	X, r1
    ceda:	1e 92       	st	-X, r1
    cedc:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordLong(axis_handle, PMDOPSetBufferLength, bufferID, bufferLength);
    cede:	62 ec       	ldi	r22, 0xC2	; 194
    cee0:	70 e0       	ldi	r23, 0x00	; 0
    cee2:	af 01       	movw	r20, r30
    cee4:	0e 94 1d 6c 	call	0xd83a	; 0xd83a <SendCommandWordLong>

	axis_handle->axis = axis;
    cee8:	f7 01       	movw	r30, r14
    ceea:	d3 82       	std	Z+3, r13	; 0x03
    ceec:	c2 82       	std	Z+2, r12	; 0x02

	return result;
}
    ceee:	1f 91       	pop	r17
    cef0:	0f 91       	pop	r16
    cef2:	ff 90       	pop	r15
    cef4:	ef 90       	pop	r14
    cef6:	df 90       	pop	r13
    cef8:	cf 90       	pop	r12
    cefa:	08 95       	ret

0000cefc <PMDSetBufferStart>:
}


// External Memory
PMDresult PMDSetBufferStart(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32 bufferStart)
{
    cefc:	cf 92       	push	r12
    cefe:	df 92       	push	r13
    cf00:	ef 92       	push	r14
    cf02:	ff 92       	push	r15
    cf04:	0f 93       	push	r16
    cf06:	1f 93       	push	r17
    cf08:	7c 01       	movw	r14, r24
    cf0a:	fb 01       	movw	r30, r22
    cf0c:	89 01       	movw	r16, r18
    cf0e:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    cf10:	dc 01       	movw	r26, r24
    cf12:	12 96       	adiw	r26, 0x02	; 2
    cf14:	cd 90       	ld	r12, X+
    cf16:	dc 90       	ld	r13, X
    cf18:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    cf1a:	13 96       	adiw	r26, 0x03	; 3
    cf1c:	1c 92       	st	X, r1
    cf1e:	1e 92       	st	-X, r1
    cf20:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordLong(axis_handle, PMDOPSetBufferStart, bufferID, bufferStart);
    cf22:	60 ec       	ldi	r22, 0xC0	; 192
    cf24:	70 e0       	ldi	r23, 0x00	; 0
    cf26:	af 01       	movw	r20, r30
    cf28:	0e 94 1d 6c 	call	0xd83a	; 0xd83a <SendCommandWordLong>

	axis_handle->axis = axis;
    cf2c:	f7 01       	movw	r30, r14
    cf2e:	d3 82       	std	Z+3, r13	; 0x03
    cf30:	c2 82       	std	Z+2, r12	; 0x02

	return result;
}
    cf32:	1f 91       	pop	r17
    cf34:	0f 91       	pop	r16
    cf36:	ff 90       	pop	r15
    cf38:	ef 90       	pop	r14
    cf3a:	df 90       	pop	r13
    cf3c:	cf 90       	pop	r12
    cf3e:	08 95       	ret

0000cf40 <PMDSetBreakpointValue>:

	return result;
}

PMDresult PMDSetBreakpointValue(PMDAxisHandle* axis_handle, PMDuint16 breakpointID, PMDint32 breakpointValue)
{
    cf40:	0f 93       	push	r16
    cf42:	1f 93       	push	r17
    cf44:	fb 01       	movw	r30, r22
    cf46:	89 01       	movw	r16, r18
    cf48:	9a 01       	movw	r18, r20
	return SendCommandWordLong(axis_handle, PMDOPSetBreakpointValue, breakpointID, (PMDuint32)breakpointValue);
    cf4a:	66 ed       	ldi	r22, 0xD6	; 214
    cf4c:	70 e0       	ldi	r23, 0x00	; 0
    cf4e:	af 01       	movw	r20, r30
    cf50:	0e 94 1d 6c 	call	0xd83a	; 0xd83a <SendCommandWordLong>
}
    cf54:	1f 91       	pop	r17
    cf56:	0f 91       	pop	r16
    cf58:	08 95       	ret

0000cf5a <PMDSetActualPosition>:
{
	return SendCommandLong(axis_handle, PMDOPAdjustActualPosition, (PMDuint32)position);
}

PMDresult PMDSetActualPosition(PMDAxisHandle* axis_handle, PMDint32 position)
{
    cf5a:	9a 01       	movw	r18, r20
    cf5c:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetActualPosition, (PMDuint32)position);
    cf5e:	6d e4       	ldi	r22, 0x4D	; 77
    cf60:	70 e0       	ldi	r23, 0x00	; 0
    cf62:	0e 94 e1 6b 	call	0xd7c2	; 0xd7c2 <SendCommandLong>
}
    cf66:	08 95       	ret

0000cf68 <PMDAdjustActualPosition>:
}


// Encoder
PMDresult PMDAdjustActualPosition(PMDAxisHandle* axis_handle, PMDint32 position)
{
    cf68:	9a 01       	movw	r18, r20
    cf6a:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPAdjustActualPosition, (PMDuint32)position);
    cf6c:	65 ef       	ldi	r22, 0xF5	; 245
    cf6e:	70 e0       	ldi	r23, 0x00	; 0
    cf70:	0e 94 e1 6b 	call	0xd7c2	; 0xd7c2 <SendCommandLong>
}
    cf74:	08 95       	ret

0000cf76 <PMDSetPositionErrorLimit>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetMotorBias, (PMDuint16*)bias);
}

PMDresult PMDSetPositionErrorLimit(PMDAxisHandle* axis_handle, PMDuint32 limit)
{
    cf76:	9a 01       	movw	r18, r20
    cf78:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetPositionErrorLimit, limit);
    cf7a:	67 e9       	ldi	r22, 0x97	; 151
    cf7c:	70 e0       	ldi	r23, 0x00	; 0
    cf7e:	0e 94 e1 6b 	call	0xd7c2	; 0xd7c2 <SendCommandLong>
}
    cf82:	08 95       	ret

0000cf84 <PMDSetIntegrationLimit>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKout, kout);
}

PMDresult PMDSetIntegrationLimit(PMDAxisHandle* axis_handle, PMDuint32 limit)
{
    cf84:	9a 01       	movw	r18, r20
    cf86:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetIntegrationLimit, limit);
    cf88:	65 e9       	ldi	r22, 0x95	; 149
    cf8a:	70 e0       	ldi	r23, 0x00	; 0
    cf8c:	0e 94 e1 6b 	call	0xd7c2	; 0xd7c2 <SendCommandLong>
}
    cf90:	08 95       	ret

0000cf92 <PMDSetGearRatio>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetJerk, jerk);
}

PMDresult PMDSetGearRatio(PMDAxisHandle* axis_handle, PMDint32 ratio)
{
    cf92:	9a 01       	movw	r18, r20
    cf94:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetGearRatio, (PMDuint32)ratio);
    cf96:	64 e1       	ldi	r22, 0x14	; 20
    cf98:	70 e0       	ldi	r23, 0x00	; 0
    cf9a:	0e 94 e1 6b 	call	0xd7c2	; 0xd7c2 <SendCommandLong>
}
    cf9e:	08 95       	ret

0000cfa0 <PMDSetJerk>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetDeceleration, deceleration);
}

PMDresult PMDSetJerk(PMDAxisHandle* axis_handle, PMDuint32 jerk)
{
    cfa0:	9a 01       	movw	r18, r20
    cfa2:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetJerk, jerk);
    cfa4:	63 e1       	ldi	r22, 0x13	; 19
    cfa6:	70 e0       	ldi	r23, 0x00	; 0
    cfa8:	0e 94 e1 6b 	call	0xd7c2	; 0xd7c2 <SendCommandLong>
}
    cfac:	08 95       	ret

0000cfae <PMDSetDeceleration>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetAcceleration, acceleration);
}

PMDresult PMDSetDeceleration(PMDAxisHandle* axis_handle, PMDuint32 deceleration)
{
    cfae:	9a 01       	movw	r18, r20
    cfb0:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetDeceleration, deceleration);
    cfb2:	61 e9       	ldi	r22, 0x91	; 145
    cfb4:	70 e0       	ldi	r23, 0x00	; 0
    cfb6:	0e 94 e1 6b 	call	0xd7c2	; 0xd7c2 <SendCommandLong>
}
    cfba:	08 95       	ret

0000cfbc <PMDSetAcceleration>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetStartVelocity, velocity);
}

PMDresult PMDSetAcceleration(PMDAxisHandle* axis_handle, PMDuint32 acceleration)
{
    cfbc:	9a 01       	movw	r18, r20
    cfbe:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetAcceleration, acceleration);
    cfc0:	60 e9       	ldi	r22, 0x90	; 144
    cfc2:	70 e0       	ldi	r23, 0x00	; 0
    cfc4:	0e 94 e1 6b 	call	0xd7c2	; 0xd7c2 <SendCommandLong>
}
    cfc8:	08 95       	ret

0000cfca <PMDSetStartVelocity>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetVelocity, (PMDuint32*)velocity);
}

PMDresult PMDSetStartVelocity(PMDAxisHandle* axis_handle, PMDuint32 velocity)
{
    cfca:	9a 01       	movw	r18, r20
    cfcc:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetStartVelocity, velocity);
    cfce:	6a e6       	ldi	r22, 0x6A	; 106
    cfd0:	70 e0       	ldi	r23, 0x00	; 0
    cfd2:	0e 94 e1 6b 	call	0xd7c2	; 0xd7c2 <SendCommandLong>
}
    cfd6:	08 95       	ret

0000cfd8 <PMDSetVelocity>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetPosition, (PMDuint32*)position);
}

PMDresult PMDSetVelocity(PMDAxisHandle* axis_handle, PMDint32 velocity)
{
    cfd8:	9a 01       	movw	r18, r20
    cfda:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetVelocity, velocity);
    cfdc:	61 e1       	ldi	r22, 0x11	; 17
    cfde:	70 e0       	ldi	r23, 0x00	; 0
    cfe0:	0e 94 e1 6b 	call	0xd7c2	; 0xd7c2 <SendCommandLong>
}
    cfe4:	08 95       	ret

0000cfe6 <PMDSetPosition>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetProfileMode, mode);
}

PMDresult PMDSetPosition(PMDAxisHandle* axis_handle, PMDint32 position)
{
    cfe6:	9a 01       	movw	r18, r20
    cfe8:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetPosition, position);
    cfea:	60 e1       	ldi	r22, 0x10	; 16
    cfec:	70 e0       	ldi	r23, 0x00	; 0
    cfee:	0e 94 e1 6b 	call	0xd7c2	; 0xd7c2 <SendCommandLong>
}
    cff2:	08 95       	ret

0000cff4 <Axis2PMDChipset>:


//**********************************************************************************************
int16 Axis2PMDChipset(tAxis Axis) 
{
	switch(Axis) 
    cff4:	84 30       	cpi	r24, 0x04	; 4
    cff6:	91 05       	cpc	r25, r1
    cff8:	4c f0       	brlt	.+18     	; 0xd00c <Axis2PMDChipset+0x18>
    cffa:	88 30       	cpi	r24, 0x08	; 8
    cffc:	91 05       	cpc	r25, r1
    cffe:	1c f0       	brlt	.+6      	; 0xd006 <Axis2PMDChipset+0x12>
    d000:	0c 97       	sbiw	r24, 0x0c	; 12
    d002:	24 f4       	brge	.+8      	; 0xd00c <Axis2PMDChipset+0x18>
    d004:	06 c0       	rjmp	.+12     	; 0xd012 <Axis2PMDChipset+0x1e>
    d006:	21 e0       	ldi	r18, 0x01	; 1
    d008:	30 e0       	ldi	r19, 0x00	; 0
    d00a:	05 c0       	rjmp	.+10     	; 0xd016 <Axis2PMDChipset+0x22>
    d00c:	20 e0       	ldi	r18, 0x00	; 0
    d00e:	30 e0       	ldi	r19, 0x00	; 0
    d010:	02 c0       	rjmp	.+4      	; 0xd016 <Axis2PMDChipset+0x22>
    d012:	22 e0       	ldi	r18, 0x02	; 2
    d014:	30 e0       	ldi	r19, 0x00	; 0
		case AxisAux7 			: 	return PMDChipSet3;       	// aux7
		
		default 					: 	return PMDChipSet1;
	}
  return PMDChipSet1;  // we must return something to avoid compiler warning
} // Axis2PMDChipset
    d016:	c9 01       	movw	r24, r18
    d018:	08 95       	ret

0000d01a <Axis2PMDAxis>:
//**********************************************************************************************
// mapping which (logical) axis is to find on which chipset axis:

int16 Axis2PMDAxis(tAxis Axis) 
{
	switch(Axis) 
    d01a:	86 30       	cpi	r24, 0x06	; 6
    d01c:	91 05       	cpc	r25, r1
    d01e:	39 f1       	breq	.+78     	; 0xd06e <Axis2PMDAxis+0x54>
    d020:	87 30       	cpi	r24, 0x07	; 7
    d022:	91 05       	cpc	r25, r1
    d024:	7c f4       	brge	.+30     	; 0xd044 <Axis2PMDAxis+0x2a>
    d026:	82 30       	cpi	r24, 0x02	; 2
    d028:	91 05       	cpc	r25, r1
    d02a:	09 f1       	breq	.+66     	; 0xd06e <Axis2PMDAxis+0x54>
    d02c:	83 30       	cpi	r24, 0x03	; 3
    d02e:	91 05       	cpc	r25, r1
    d030:	1c f4       	brge	.+6      	; 0xd038 <Axis2PMDAxis+0x1e>
    d032:	01 97       	sbiw	r24, 0x01	; 1
    d034:	c9 f4       	brne	.+50     	; 0xd068 <Axis2PMDAxis+0x4e>
    d036:	15 c0       	rjmp	.+42     	; 0xd062 <Axis2PMDAxis+0x48>
    d038:	83 30       	cpi	r24, 0x03	; 3
    d03a:	91 05       	cpc	r25, r1
    d03c:	d9 f0       	breq	.+54     	; 0xd074 <Axis2PMDAxis+0x5a>
    d03e:	05 97       	sbiw	r24, 0x05	; 5
    d040:	99 f4       	brne	.+38     	; 0xd068 <Axis2PMDAxis+0x4e>
    d042:	0f c0       	rjmp	.+30     	; 0xd062 <Axis2PMDAxis+0x48>
    d044:	89 30       	cpi	r24, 0x09	; 9
    d046:	91 05       	cpc	r25, r1
    d048:	61 f0       	breq	.+24     	; 0xd062 <Axis2PMDAxis+0x48>
    d04a:	8a 30       	cpi	r24, 0x0A	; 10
    d04c:	91 05       	cpc	r25, r1
    d04e:	1c f4       	brge	.+6      	; 0xd056 <Axis2PMDAxis+0x3c>
    d050:	07 97       	sbiw	r24, 0x07	; 7
    d052:	51 f4       	brne	.+20     	; 0xd068 <Axis2PMDAxis+0x4e>
    d054:	0f c0       	rjmp	.+30     	; 0xd074 <Axis2PMDAxis+0x5a>
    d056:	8a 30       	cpi	r24, 0x0A	; 10
    d058:	91 05       	cpc	r25, r1
    d05a:	49 f0       	breq	.+18     	; 0xd06e <Axis2PMDAxis+0x54>
    d05c:	0b 97       	sbiw	r24, 0x0b	; 11
    d05e:	21 f4       	brne	.+8      	; 0xd068 <Axis2PMDAxis+0x4e>
    d060:	09 c0       	rjmp	.+18     	; 0xd074 <Axis2PMDAxis+0x5a>
    d062:	21 e0       	ldi	r18, 0x01	; 1
    d064:	30 e0       	ldi	r19, 0x00	; 0
    d066:	08 c0       	rjmp	.+16     	; 0xd078 <Axis2PMDAxis+0x5e>
    d068:	20 e0       	ldi	r18, 0x00	; 0
    d06a:	30 e0       	ldi	r19, 0x00	; 0
    d06c:	05 c0       	rjmp	.+10     	; 0xd078 <Axis2PMDAxis+0x5e>
    d06e:	22 e0       	ldi	r18, 0x02	; 2
    d070:	30 e0       	ldi	r19, 0x00	; 0
    d072:	02 c0       	rjmp	.+4      	; 0xd078 <Axis2PMDAxis+0x5e>
    d074:	23 e0       	ldi	r18, 0x03	; 3
    d076:	30 e0       	ldi	r19, 0x00	; 0
		case AxisAux6 		: 	return PMDAxis3;       
		case AxisAux7 		: 	return PMDAxis4;      	
		default 			:   return PMDAxis1;
	}
  return PMDAxis1;  // we must return something
} // Axis2PMDAxis
    d078:	c9 01       	movw	r24, r18
    d07a:	08 95       	ret

0000d07c <PMDParallel_GetStatus>:
//********************************************************************************************************************


PMDuint16 PMDParallel_GetStatus(void* transport_data)
{
	PMDParallelIOTransportData* PIOtransport_data = (PMDParallelIOTransportData*)transport_data;
    d07c:	fc 01       	movw	r30, r24

	return PIOtransport_data->InPStatus(PIOtransport_data->dcs_Port);
    d07e:	22 8d       	ldd	r18, Z+26	; 0x1a
    d080:	33 8d       	ldd	r19, Z+27	; 0x1b
    d082:	80 81       	ld	r24, Z
    d084:	91 81       	ldd	r25, Z+1	; 0x01
    d086:	f9 01       	movw	r30, r18
    d088:	09 95       	icall
}
    d08a:	08 95       	ret

0000d08c <PMDParallel_IsReady>:
	
//********************************************************************************************************************
PMDuint16 PMDParallel_IsReady(void* transport_data)
{
    d08c:	0f 93       	push	r16
    d08e:	1f 93       	push	r17
	PMDParallelIOTransportData* PIOtransport_data = (PMDParallelIOTransportData*)transport_data;
    d090:	8c 01       	movw	r16, r24

	return ((PIOtransport_data->InPStatus(PIOtransport_data->dcs_Port)
    d092:	dc 01       	movw	r26, r24
    d094:	5a 96       	adiw	r26, 0x1a	; 26
    d096:	ed 91       	ld	r30, X+
    d098:	fc 91       	ld	r31, X
    d09a:	5b 97       	sbiw	r26, 0x1b	; 27
    d09c:	8d 91       	ld	r24, X+
    d09e:	9c 91       	ld	r25, X
    d0a0:	09 95       	icall
    d0a2:	40 e0       	ldi	r20, 0x00	; 0
    d0a4:	50 e0       	ldi	r21, 0x00	; 0
    d0a6:	f8 01       	movw	r30, r16
    d0a8:	22 81       	ldd	r18, Z+2	; 0x02
    d0aa:	33 81       	ldd	r19, Z+3	; 0x03
    d0ac:	28 23       	and	r18, r24
    d0ae:	39 23       	and	r19, r25
    d0b0:	84 81       	ldd	r24, Z+4	; 0x04
    d0b2:	95 81       	ldd	r25, Z+5	; 0x05
    d0b4:	28 17       	cp	r18, r24
    d0b6:	39 07       	cpc	r19, r25
    d0b8:	11 f4       	brne	.+4      	; 0xd0be <PMDParallel_IsReady+0x32>
    d0ba:	41 e0       	ldi	r20, 0x01	; 1
    d0bc:	50 e0       	ldi	r21, 0x00	; 0
		& PIOtransport_data->readyMask) == PIOtransport_data->readyValue);
}
    d0be:	ca 01       	movw	r24, r20
    d0c0:	1f 91       	pop	r17
    d0c2:	0f 91       	pop	r16
    d0c4:	08 95       	ret

0000d0c6 <PMDParallel_HasInterrupt>:

//********************************************************************************************************************				 
PMDuint16 PMDParallel_HasInterrupt(void* transport_data)
{
    d0c6:	0f 93       	push	r16
    d0c8:	1f 93       	push	r17
	PMDParallelIOTransportData* PIOtransport_data = (PMDParallelIOTransportData*)transport_data;
    d0ca:	8c 01       	movw	r16, r24

	return ((PIOtransport_data->InPStatus(PIOtransport_data->dcs_Port) 
    d0cc:	dc 01       	movw	r26, r24
    d0ce:	5a 96       	adiw	r26, 0x1a	; 26
    d0d0:	ed 91       	ld	r30, X+
    d0d2:	fc 91       	ld	r31, X
    d0d4:	5b 97       	sbiw	r26, 0x1b	; 27
    d0d6:	8d 91       	ld	r24, X+
    d0d8:	9c 91       	ld	r25, X
    d0da:	09 95       	icall
    d0dc:	40 e0       	ldi	r20, 0x00	; 0
    d0de:	50 e0       	ldi	r21, 0x00	; 0
    d0e0:	f8 01       	movw	r30, r16
    d0e2:	26 81       	ldd	r18, Z+6	; 0x06
    d0e4:	37 81       	ldd	r19, Z+7	; 0x07
    d0e6:	28 23       	and	r18, r24
    d0e8:	39 23       	and	r19, r25
    d0ea:	80 85       	ldd	r24, Z+8	; 0x08
    d0ec:	91 85       	ldd	r25, Z+9	; 0x09
    d0ee:	28 17       	cp	r18, r24
    d0f0:	39 07       	cpc	r19, r25
    d0f2:	11 f4       	brne	.+4      	; 0xd0f8 <PMDParallel_HasInterrupt+0x32>
    d0f4:	41 e0       	ldi	r20, 0x01	; 1
    d0f6:	50 e0       	ldi	r21, 0x00	; 0
		& PIOtransport_data->hostInterruptMask) == PIOtransport_data->hostInterruptValue);
}
    d0f8:	ca 01       	movw	r24, r20
    d0fa:	1f 91       	pop	r17
    d0fc:	0f 91       	pop	r16
    d0fe:	08 95       	ret

0000d100 <PMDParallel_HasError>:
		
//********************************************************************************************************************
PMDuint16 PMDParallel_HasError(void* transport_data)
{
    d100:	0f 93       	push	r16
    d102:	1f 93       	push	r17
	PMDParallelIOTransportData* PIOtransport_data = (PMDParallelIOTransportData*)transport_data;
    d104:	8c 01       	movw	r16, r24

	return ((PIOtransport_data->InPStatus(PIOtransport_data->dcs_Port) 
    d106:	dc 01       	movw	r26, r24
    d108:	5a 96       	adiw	r26, 0x1a	; 26
    d10a:	ed 91       	ld	r30, X+
    d10c:	fc 91       	ld	r31, X
    d10e:	5b 97       	sbiw	r26, 0x1b	; 27
    d110:	8d 91       	ld	r24, X+
    d112:	9c 91       	ld	r25, X
    d114:	09 95       	icall
    d116:	40 e0       	ldi	r20, 0x00	; 0
    d118:	50 e0       	ldi	r21, 0x00	; 0
    d11a:	f8 01       	movw	r30, r16
    d11c:	22 85       	ldd	r18, Z+10	; 0x0a
    d11e:	33 85       	ldd	r19, Z+11	; 0x0b
    d120:	28 23       	and	r18, r24
    d122:	39 23       	and	r19, r25
    d124:	84 85       	ldd	r24, Z+12	; 0x0c
    d126:	95 85       	ldd	r25, Z+13	; 0x0d
    d128:	28 17       	cp	r18, r24
    d12a:	39 07       	cpc	r19, r25
    d12c:	11 f4       	brne	.+4      	; 0xd132 <PMDParallel_HasError+0x32>
    d12e:	41 e0       	ldi	r20, 0x01	; 1
    d130:	50 e0       	ldi	r21, 0x00	; 0
		& PIOtransport_data->commandStatusMask) == PIOtransport_data->commandStatusValue);
}
    d132:	ca 01       	movw	r24, r20
    d134:	1f 91       	pop	r17
    d136:	0f 91       	pop	r16
    d138:	08 95       	ret

0000d13a <PMDParallel_HardReset>:
{

    PMDParallelIOTransportData* PIOtransport_data = (PMDParallelIOTransportData*)transport_data;
	//le debe de entar transport_data por que proviene 
	//de una axis ya inicualizada correctamente
	PIOtransport_data->Hard();
    d13a:	dc 01       	movw	r26, r24
    d13c:	56 96       	adiw	r26, 0x16	; 22
    d13e:	ed 91       	ld	r30, X+
    d140:	fc 91       	ld	r31, X
    d142:	57 97       	sbiw	r26, 0x17	; 23
    d144:	09 95       	icall
 
    return PMD_NOERROR;
    
}
    d146:	80 e0       	ldi	r24, 0x00	; 0
    d148:	90 e0       	ldi	r25, 0x00	; 0
    d14a:	08 95       	ret

0000d14c <PMDParallel_InitData>:
{
    free(transport_data);
}	
//********************************************************************************************************************				 	 
void PMDParallel_InitData(PMDParallelIOTransportData* transport_data, int16 IOMode)
{
    d14c:	fc 01       	movw	r30, r24
	// assign default values


	transport_data->readyMask = 0x8000;
    d14e:	80 e0       	ldi	r24, 0x00	; 0
    d150:	90 e8       	ldi	r25, 0x80	; 128
    d152:	93 83       	std	Z+3, r25	; 0x03
    d154:	82 83       	std	Z+2, r24	; 0x02
	transport_data->readyValue = 0x8000;
    d156:	95 83       	std	Z+5, r25	; 0x05
    d158:	84 83       	std	Z+4, r24	; 0x04
	transport_data->hostInterruptMask = 0x4000;
    d15a:	80 e0       	ldi	r24, 0x00	; 0
    d15c:	90 e4       	ldi	r25, 0x40	; 64
    d15e:	97 83       	std	Z+7, r25	; 0x07
    d160:	86 83       	std	Z+6, r24	; 0x06
	transport_data->hostInterruptValue = 0x4000;
    d162:	91 87       	std	Z+9, r25	; 0x09
    d164:	80 87       	std	Z+8, r24	; 0x08
	transport_data->commandStatusMask = 0x2000;
    d166:	80 e0       	ldi	r24, 0x00	; 0
    d168:	90 e2       	ldi	r25, 0x20	; 32
    d16a:	93 87       	std	Z+11, r25	; 0x0b
    d16c:	82 87       	std	Z+10, r24	; 0x0a
	transport_data->commandStatusValue = 0x2000;
    d16e:	95 87       	std	Z+13, r25	; 0x0d
    d170:	84 87       	std	Z+12, r24	; 0x0c

	// by default always verify the checksum
	transport_data->bVerifyChecksum = 1;
    d172:	81 e0       	ldi	r24, 0x01	; 1
    d174:	90 e0       	ldi	r25, 0x00	; 0
    d176:	97 87       	std	Z+15, r25	; 0x0f
    d178:	86 87       	std	Z+14, r24	; 0x0e
	// by default disable diagnostics
	// Modificado por David
	// Activo los diagnosticos
	transport_data->bDiagnostics = 1;
    d17a:	91 8b       	std	Z+17, r25	; 0x11
    d17c:	80 8b       	std	Z+16, r24	; 0x10

	// assign default handlers/masks according to IO mode
	switch (IOMode)
    d17e:	61 30       	cpi	r22, 0x01	; 1
    d180:	71 05       	cpc	r23, r1
    d182:	a1 f4       	brne	.+40     	; 0xd1ac <PMDParallel_InitData+0x60>
	{
	case PMDParallelIOMode_8_16:
		transport_data->OutPData = OutP8Bit ;
    d184:	84 e5       	ldi	r24, 0x54	; 84
    d186:	9b e6       	ldi	r25, 0x6B	; 107
    d188:	93 8b       	std	Z+19, r25	; 0x13
    d18a:	82 8b       	std	Z+18, r24	; 0x12
		transport_data->OutPCmd = OutP8BitCmd;
    d18c:	81 e5       	ldi	r24, 0x51	; 81
    d18e:	9b e6       	ldi	r25, 0x6B	; 107
    d190:	95 8b       	std	Z+21, r25	; 0x15
    d192:	84 8b       	std	Z+20, r24	; 0x14
		transport_data->InPData = InP8Bit;
    d194:	8e e4       	ldi	r24, 0x4E	; 78
    d196:	9b e6       	ldi	r25, 0x6B	; 107
    d198:	91 8f       	std	Z+25, r25	; 0x19
    d19a:	80 8f       	std	Z+24, r24	; 0x18
		transport_data->InPStatus = InP8BitStatus;
    d19c:	8b e4       	ldi	r24, 0x4B	; 75
    d19e:	9b e6       	ldi	r25, 0x6B	; 107
    d1a0:	93 8f       	std	Z+27, r25	; 0x1b
    d1a2:	82 8f       	std	Z+26, r24	; 0x1a
		transport_data->Hard = OutP8BitHard;
    d1a4:	88 e4       	ldi	r24, 0x48	; 72
    d1a6:	9b e6       	ldi	r25, 0x6B	; 107
    d1a8:	97 8b       	std	Z+23, r25	; 0x17
    d1aa:	86 8b       	std	Z+22, r24	; 0x16
    d1ac:	08 95       	ret

0000d1ae <PMDParallel_Init>:
}


//********************************************************************************************************************				 	 
void PMDParallel_Init(PMDIOTransport* transport)
{
    d1ae:	fc 01       	movw	r30, r24
	// setup function pointers
	transport->SendCommand = PMDParallel_Send;
    d1b0:	8f e8       	ldi	r24, 0x8F	; 143
    d1b2:	99 e6       	ldi	r25, 0x69	; 105
    d1b4:	91 83       	std	Z+1, r25	; 0x01
    d1b6:	80 83       	st	Z, r24
	transport->GetStatus = PMDParallel_GetStatus;
    d1b8:	8e e3       	ldi	r24, 0x3E	; 62
    d1ba:	98 e6       	ldi	r25, 0x68	; 104
    d1bc:	95 83       	std	Z+5, r25	; 0x05
    d1be:	84 83       	std	Z+4, r24	; 0x04
	transport->IsReady = PMDParallel_IsReady;
    d1c0:	86 e4       	ldi	r24, 0x46	; 70
    d1c2:	98 e6       	ldi	r25, 0x68	; 104
    d1c4:	97 83       	std	Z+7, r25	; 0x07
    d1c6:	86 83       	std	Z+6, r24	; 0x06
	transport->HasInterrupt = PMDParallel_HasInterrupt;
    d1c8:	83 e6       	ldi	r24, 0x63	; 99
    d1ca:	98 e6       	ldi	r25, 0x68	; 104
    d1cc:	91 87       	std	Z+9, r25	; 0x09
    d1ce:	80 87       	std	Z+8, r24	; 0x08
	transport->HasError = PMDParallel_HasError;
    d1d0:	80 e8       	ldi	r24, 0x80	; 128
    d1d2:	98 e6       	ldi	r25, 0x68	; 104
    d1d4:	93 87       	std	Z+11, r25	; 0x0b
    d1d6:	82 87       	std	Z+10, r24	; 0x0a
  	transport->HardReset = PMDParallel_HardReset;
    d1d8:	8d e9       	ldi	r24, 0x9D	; 157
    d1da:	98 e6       	ldi	r25, 0x68	; 104
    d1dc:	95 87       	std	Z+13, r25	; 0x0d
    d1de:	84 87       	std	Z+12, r24	; 0x0c

	transport->Close = PMDParallel_Close;
    d1e0:	80 e3       	ldi	r24, 0x30	; 48
    d1e2:	99 e6       	ldi	r25, 0x69	; 105
    d1e4:	93 83       	std	Z+3, r25	; 0x03
    d1e6:	82 83       	std	Z+2, r24	; 0x02
} 
    d1e8:	08 95       	ret

0000d1ea <PMDSetupAxisInterface_Parallel>:

//********************************************************************************************************************	

PMDuint16 PMDSetupAxisInterface_Parallel(PMDAxisHandle* axis_handle, PMDAxis axis_number, PMDuint16 PMDChipSet)
{
    d1ea:	cf 92       	push	r12
    d1ec:	df 92       	push	r13
    d1ee:	ef 92       	push	r14
    d1f0:	ff 92       	push	r15
    d1f2:	0f 93       	push	r16
    d1f4:	1f 93       	push	r17
    d1f6:	cf 93       	push	r28
    d1f8:	df 93       	push	r29
    d1fa:	8c 01       	movw	r16, r24
    d1fc:	6b 01       	movw	r12, r22
    d1fe:	7a 01       	movw	r14, r20
	PMDParallelIOTransportData* transport_data;
	
	
	transport_data = (PMDParallelIOTransportData*) malloc( sizeof( PMDParallelIOTransportData ) );
    d200:	8c e1       	ldi	r24, 0x1C	; 28
    d202:	90 e0       	ldi	r25, 0x00	; 0
    d204:	0e 94 fd 85 	call	0x10bfa	; 0x10bfa <malloc>
    d208:	ec 01       	movw	r28, r24
	memset(transport_data, 0, sizeof(PMDParallelIOTransportData));
    d20a:	8c e1       	ldi	r24, 0x1C	; 28
    d20c:	fe 01       	movw	r30, r28
    d20e:	11 92       	st	Z+, r1
    d210:	8a 95       	dec	r24
    d212:	e9 f7       	brne	.-6      	; 0xd20e <PMDSetupAxisInterface_Parallel+0x24>
    
	if(transport_data == 0) return rcNoMemory;  // check if operation succeeded
    d214:	20 97       	sbiw	r28, 0x00	; 0
    d216:	19 f4       	brne	.+6      	; 0xd21e <PMDSetupAxisInterface_Parallel+0x34>
    d218:	28 e0       	ldi	r18, 0x08	; 8
    d21a:	30 e0       	ldi	r19, 0x00	; 0
    d21c:	17 c0       	rjmp	.+46     	; 0xd24c <PMDSetupAxisInterface_Parallel+0x62>

	// set the axis we are talking to with this handle
	axis_handle->axis = axis_number;
    d21e:	f8 01       	movw	r30, r16
    d220:	d3 82       	std	Z+3, r13	; 0x03
    d222:	c2 82       	std	Z+2, r12	; 0x02
	

	// if required the transport data defaults can be changed here
	// e.g. board IO address (dataPort,commandPort,statusPort)
	//transport_data->dataPort = board_address;
	transport_data->dcs_Port = PMDChipSet;  // actual port is treated in low-level function in basicIO.h
    d224:	f9 82       	std	Y+1, r15	; 0x01
    d226:	e8 82       	st	Y, r14
	axis_handle->chipset=PMDChipSet;
    d228:	f1 82       	std	Z+1, r15	; 0x01
    d22a:	e0 82       	st	Z, r14

	// the transport data is initialized first to setup the defaults
	// make sure the IO mode is set correctly
	PMDParallel_InitData(transport_data, PMDParallelIOMode_8_16);
    d22c:	ce 01       	movw	r24, r28
    d22e:	61 e0       	ldi	r22, 0x01	; 1
    d230:	70 e0       	ldi	r23, 0x00	; 0
    d232:	0e 94 a6 68 	call	0xd14c	; 0xd14c <PMDParallel_InitData>

	axis_handle->transport_data = (void*) transport_data;
    d236:	02 5a       	subi	r16, 0xA2	; 162
    d238:	1f 4f       	sbci	r17, 0xFF	; 255
    d23a:	f8 01       	movw	r30, r16
    d23c:	d1 83       	std	Z+1, r29	; 0x01
    d23e:	c0 83       	st	Z, r28

	// initialize the transport (inits function pointers)
	PMDParallel_Init(&axis_handle->transport);
    d240:	c8 01       	movw	r24, r16
    d242:	0e 97       	sbiw	r24, 0x0e	; 14
    d244:	0e 94 d7 68 	call	0xd1ae	; 0xd1ae <PMDParallel_Init>
    d248:	20 e0       	ldi	r18, 0x00	; 0
    d24a:	30 e0       	ldi	r19, 0x00	; 0

 return rcOK;
}
    d24c:	c9 01       	movw	r24, r18
    d24e:	df 91       	pop	r29
    d250:	cf 91       	pop	r28
    d252:	1f 91       	pop	r17
    d254:	0f 91       	pop	r16
    d256:	ff 90       	pop	r15
    d258:	ef 90       	pop	r14
    d25a:	df 90       	pop	r13
    d25c:	cf 90       	pop	r12
    d25e:	08 95       	ret

0000d260 <PMDParallel_Close>:


//********************************************************************************************************************				 	 
void PMDParallel_Close(void* transport_data)
{
    free(transport_data);
    d260:	0e 94 aa 86 	call	0x10d54	; 0x10d54 <free>
}	
    d264:	08 95       	ret

0000d266 <PMDParallel_WaitForReady>:
//********************************************************************************************************************				 	
//Esta Funcion Verifica que el Dato retornado por la Funcion Read_Status_Register contenga en el Bit 15 
//(HostRdy signal) un Valor igual a 1, indicando al HOST que El PMD esta Listo para Operaciones.

PMDuint16 PMDParallel_WaitForReady(PMDParallelIOTransportData* transport_data)
{
    d266:	0f 93       	push	r16
    d268:	1f 93       	push	r17
    d26a:	cf 93       	push	r28
    d26c:	df 93       	push	r29
    d26e:	ec 01       	movw	r28, r24
    d270:	00 ee       	ldi	r16, 0xE0	; 224
    d272:	1e e2       	ldi	r17, 0x2E	; 46
  		timer 		= 12000; 																      
		
		for(;;) 
		{
			// poll ready port, if not ready, loop
    		in_val = transport_data->InPStatus(transport_data->dcs_Port);
    d274:	ea 8d       	ldd	r30, Y+26	; 0x1a
    d276:	fb 8d       	ldd	r31, Y+27	; 0x1b
    d278:	88 81       	ld	r24, Y
    d27a:	99 81       	ldd	r25, Y+1	; 0x01
    d27c:	09 95       	icall
    d27e:	9c 01       	movw	r18, r24
    		if ((in_val != 0xFFFF) && ((in_val & transport_data->readyMask) == transport_data->readyValue))
    d280:	8f ef       	ldi	r24, 0xFF	; 255
    d282:	2f 3f       	cpi	r18, 0xFF	; 255
    d284:	38 07       	cpc	r19, r24
    d286:	61 f0       	breq	.+24     	; 0xd2a0 <PMDParallel_WaitForReady+0x3a>
    d288:	8a 81       	ldd	r24, Y+2	; 0x02
    d28a:	9b 81       	ldd	r25, Y+3	; 0x03
    d28c:	82 23       	and	r24, r18
    d28e:	93 23       	and	r25, r19
    d290:	2c 81       	ldd	r18, Y+4	; 0x04
    d292:	3d 81       	ldd	r19, Y+5	; 0x05
    d294:	82 17       	cp	r24, r18
    d296:	93 07       	cpc	r25, r19
    d298:	19 f4       	brne	.+6      	; 0xd2a0 <PMDParallel_WaitForReady+0x3a>
    d29a:	20 e0       	ldi	r18, 0x00	; 0
    d29c:	30 e0       	ldi	r19, 0x00	; 0
    d29e:	0c c0       	rjmp	.+24     	; 0xd2b8 <PMDParallel_WaitForReady+0x52>
				return PMD_ERR_OK;
			else// not ready 
			{ 
				timer--;
    d2a0:	01 50       	subi	r16, 0x01	; 1
    d2a2:	10 40       	sbci	r17, 0x00	; 0
				if(timer == 0) 
    d2a4:	39 f7       	brne	.-50     	; 0xd274 <PMDParallel_WaitForReady+0xe>
				{
					/* se enciende el LED Rojo*/
					Led_on(Rojo);
    d2a6:	81 e0       	ldi	r24, 0x01	; 1
    d2a8:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
					printf("PMDParallel_WaitForReady=> 40ms Timeout Error\n");
    d2ac:	8f ed       	ldi	r24, 0xDF	; 223
    d2ae:	94 e7       	ldi	r25, 0x74	; 116
    d2b0:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    d2b4:	2d ef       	ldi	r18, 0xFD	; 253
    d2b6:	3f e7       	ldi	r19, 0x7F	; 127
        if ((in_val != 0xFFFF) 
			&& ((in_val & transport_data->readyMask) == transport_data->readyValue))
                return PMD_ERR_OK;
    }
#endif
} 
    d2b8:	c9 01       	movw	r24, r18
    d2ba:	df 91       	pop	r29
    d2bc:	cf 91       	pop	r28
    d2be:	1f 91       	pop	r17
    d2c0:	0f 91       	pop	r16
    d2c2:	08 95       	ret

0000d2c4 <PMDParallel_GetCommandStatus>:
//********************************************************************************************************************				 	
// wait for the PMDs to be ready for the next command
PMDuint16 PMDParallel_GetCommandStatus(PMDParallelIOTransportData* transport_data)
{
    d2c4:	0f 93       	push	r16
    d2c6:	1f 93       	push	r17
    d2c8:	cf 93       	push	r28
    d2ca:	df 93       	push	r29
    d2cc:	ec 01       	movw	r28, r24
	PMDuint16 result;
	int16     in_val;

	if((result = PMDParallel_WaitForReady(transport_data)) != PMD_ERR_OK)
    d2ce:	0e 94 33 69 	call	0xd266	; 0xd266 <PMDParallel_WaitForReady>
    d2d2:	8c 01       	movw	r16, r24
    d2d4:	00 97       	sbiw	r24, 0x00	; 0
    d2d6:	29 f0       	breq	.+10     	; 0xd2e2 <PMDParallel_GetCommandStatus+0x1e>
	{
	    printf("PMDParallel_GetCommandStatus=> Wait Status Register Timeout \n");    
    d2d8:	8d e0       	ldi	r24, 0x0D	; 13
    d2da:	95 e7       	ldi	r25, 0x75	; 117
    d2dc:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    d2e0:	18 c0       	rjmp	.+48     	; 0xd312 <PMDParallel_GetCommandStatus+0x4e>

	//En este punto Verifica que el Dato retornado por la Funcion Read_Status_Register contenga en el Bit 13 
	//(HostIOError signal) un Valor igual a 1, indicando  que El PMD contiene un HOST I/O Error (ver seccion 
	//10.3.3 del Manual de Usuario). 
	
	in_val = transport_data->InPStatus(transport_data->dcs_Port);
    d2e2:	ea 8d       	ldd	r30, Y+26	; 0x1a
    d2e4:	fb 8d       	ldd	r31, Y+27	; 0x1b
    d2e6:	88 81       	ld	r24, Y
    d2e8:	99 81       	ldd	r25, Y+1	; 0x01
    d2ea:	09 95       	icall
	if ((in_val & transport_data->commandStatusMask) == transport_data->commandStatusValue)
    d2ec:	2a 85       	ldd	r18, Y+10	; 0x0a
    d2ee:	3b 85       	ldd	r19, Y+11	; 0x0b
    d2f0:	28 23       	and	r18, r24
    d2f2:	39 23       	and	r19, r25
    d2f4:	8c 85       	ldd	r24, Y+12	; 0x0c
    d2f6:	9d 85       	ldd	r25, Y+13	; 0x0d
    d2f8:	28 17       	cp	r18, r24
    d2fa:	39 07       	cpc	r19, r25
    d2fc:	51 f4       	brne	.+20     	; 0xd312 <PMDParallel_GetCommandStatus+0x4e>
	{
		if (transport_data->bDiagnostics)
    d2fe:	88 89       	ldd	r24, Y+16	; 0x10
    d300:	99 89       	ldd	r25, Y+17	; 0x11
    d302:	89 2b       	or	r24, r25
    d304:	21 f0       	breq	.+8      	; 0xd30e <PMDParallel_GetCommandStatus+0x4a>
				printf("PMDParallel_GetCommandStatus=> C-Motion: Command Error bit set.\n");
    d306:	8a e4       	ldi	r24, 0x4A	; 74
    d308:	95 e7       	ldi	r25, 0x75	; 117
    d30a:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    d30e:	0f ef       	ldi	r16, 0xFF	; 255
    d310:	1f e7       	ldi	r17, 0x7F	; 127
		return PMD_ERR_CommandError;
	}
	return PMD_ERR_OK;
} 
    d312:	c8 01       	movw	r24, r16
    d314:	df 91       	pop	r29
    d316:	cf 91       	pop	r28
    d318:	1f 91       	pop	r17
    d31a:	0f 91       	pop	r16
    d31c:	08 95       	ret

0000d31e <PMDParallel_Send>:

//result=MD_ERR_CommTimeoutError o  PMD_ERR_OK

PMDuint16 PMDParallel_Send(PMDParallelIOTransportData* transport_data, 
							  PMDuint8 xCt, PMDuint16* xDat, PMDuint8 rCt, PMDuint16* rDat)
{
    d31e:	2f 92       	push	r2
    d320:	3f 92       	push	r3
    d322:	4f 92       	push	r4
    d324:	5f 92       	push	r5
    d326:	6f 92       	push	r6
    d328:	7f 92       	push	r7
    d32a:	8f 92       	push	r8
    d32c:	9f 92       	push	r9
    d32e:	af 92       	push	r10
    d330:	bf 92       	push	r11
    d332:	cf 92       	push	r12
    d334:	df 92       	push	r13
    d336:	ef 92       	push	r14
    d338:	ff 92       	push	r15
    d33a:	0f 93       	push	r16
    d33c:	1f 93       	push	r17
    d33e:	df 93       	push	r29
    d340:	cf 93       	push	r28
    d342:	cd b7       	in	r28, 0x3d	; 61
    d344:	de b7       	in	r29, 0x3e	; 62
    d346:	27 97       	sbiw	r28, 0x07	; 7
    d348:	0f b6       	in	r0, 0x3f	; 63
    d34a:	f8 94       	cli
    d34c:	de bf       	out	0x3e, r29	; 62
    d34e:	0f be       	out	0x3f, r0	; 63
    d350:	cd bf       	out	0x3d, r28	; 61
    d352:	6c 01       	movw	r12, r24
    d354:	6d 83       	std	Y+5, r22	; 0x05
    d356:	2a 01       	movw	r4, r20
    d358:	32 2e       	mov	r3, r18
    d35a:	70 2e       	mov	r7, r16
    d35c:	61 2e       	mov	r6, r17

    PMDuint16 result;
	PMDuint16 commandstatus = PMD_ERR_OK;
    PMDuint16 index;
    long messageChecksum=0;
    PMDuint16 chipsetChecksum=0;
    d35e:	1a 82       	std	Y+2, r1	; 0x02
    d360:	19 82       	std	Y+1, r1	; 0x01

	result=PMD_ERR_PMDNotInitialized;
///////////////////////////////ESCRIBE UN COMANDO/////////////////////////////////////////  
    if((result = PMDParallel_WaitForReady(transport_data)) == PMD_ERR_OK) //Esta readey
    d362:	0e 94 33 69 	call	0xd266	; 0xd266 <PMDParallel_WaitForReady>
    d366:	5c 01       	movw	r10, r24
    d368:	00 97       	sbiw	r24, 0x00	; 0
    d36a:	91 f5       	brne	.+100    	; 0xd3d0 <PMDParallel_Send+0xb2>
    {  
		// put the command into the PMD1/PMD2/PMD3
		transport_data->OutPCmd(transport_data->dcs_Port, xDat[0]);
    d36c:	d2 01       	movw	r26, r4
    d36e:	6d 91       	ld	r22, X+
    d370:	7c 91       	ld	r23, X
    d372:	d6 01       	movw	r26, r12
    d374:	54 96       	adiw	r26, 0x14	; 20
    d376:	ed 91       	ld	r30, X+
    d378:	fc 91       	ld	r31, X
    d37a:	55 97       	sbiw	r26, 0x15	; 21
    d37c:	8d 91       	ld	r24, X+
    d37e:	9c 91       	ld	r25, X
    d380:	09 95       	icall
    d382:	72 01       	movw	r14, r4
    d384:	01 e0       	ldi	r16, 0x01	; 1
    d386:	10 e0       	ldi	r17, 0x00	; 0
		
		// put the data into the PMD1/PMD2/PMD3
		// one word at a time
        for(index=1; index<xCt; index++)
    d388:	bd 81       	ldd	r27, Y+5	; 0x05
    d38a:	8b 2e       	mov	r8, r27
    d38c:	99 24       	eor	r9, r9
    d38e:	18 c0       	rjmp	.+48     	; 0xd3c0 <PMDParallel_Send+0xa2>
        {
			if((result = PMDParallel_WaitForReady(transport_data)) != PMD_ERR_OK)
    d390:	c6 01       	movw	r24, r12
    d392:	0e 94 33 69 	call	0xd266	; 0xd266 <PMDParallel_WaitForReady>
    d396:	e2 e0       	ldi	r30, 0x02	; 2
    d398:	f0 e0       	ldi	r31, 0x00	; 0
    d39a:	ee 0e       	add	r14, r30
    d39c:	ff 1e       	adc	r15, r31
    d39e:	00 97       	sbiw	r24, 0x00	; 0
    d3a0:	11 f0       	breq	.+4      	; 0xd3a6 <PMDParallel_Send+0x88>
    d3a2:	5c 01       	movw	r10, r24
    d3a4:	19 c0       	rjmp	.+50     	; 0xd3d8 <PMDParallel_Send+0xba>
				break;
			
			transport_data->OutPData(transport_data->dcs_Port,xDat[index]);
    d3a6:	d7 01       	movw	r26, r14
    d3a8:	6d 91       	ld	r22, X+
    d3aa:	7c 91       	ld	r23, X
    d3ac:	d6 01       	movw	r26, r12
    d3ae:	52 96       	adiw	r26, 0x12	; 18
    d3b0:	ed 91       	ld	r30, X+
    d3b2:	fc 91       	ld	r31, X
    d3b4:	53 97       	sbiw	r26, 0x13	; 19
    d3b6:	8d 91       	ld	r24, X+
    d3b8:	9c 91       	ld	r25, X
    d3ba:	09 95       	icall
		// put the command into the PMD1/PMD2/PMD3
		transport_data->OutPCmd(transport_data->dcs_Port, xDat[0]);
		
		// put the data into the PMD1/PMD2/PMD3
		// one word at a time
        for(index=1; index<xCt; index++)
    d3bc:	0f 5f       	subi	r16, 0xFF	; 255
    d3be:	1f 4f       	sbci	r17, 0xFF	; 255
    d3c0:	08 15       	cp	r16, r8
    d3c2:	19 05       	cpc	r17, r9
    d3c4:	28 f3       	brcs	.-54     	; 0xd390 <PMDParallel_Send+0x72>
			
			transport_data->OutPData(transport_data->dcs_Port,xDat[index]);
        }
		
		if(result == PMD_ERR_OK)
			commandstatus = PMDParallel_GetCommandStatus(transport_data);
    d3c6:	c6 01       	movw	r24, r12
    d3c8:	0e 94 62 69 	call	0xd2c4	; 0xd2c4 <PMDParallel_GetCommandStatus>
    d3cc:	4c 01       	movw	r8, r24
    d3ce:	06 c0       	rjmp	.+12     	; 0xd3dc <PMDParallel_Send+0xbe>
		
		
    }
	else
	   printf("PMDParallel_Send=> Error Envio Datos o Comando \n");    
    d3d0:	8a e8       	ldi	r24, 0x8A	; 138
    d3d2:	95 e7       	ldi	r25, 0x75	; 117
    d3d4:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    d3d8:	88 24       	eor	r8, r8
    d3da:	99 24       	eor	r9, r9
    d3dc:	87 2d       	mov	r24, r7
    d3de:	96 2d       	mov	r25, r6
    d3e0:	9c 01       	movw	r18, r24
    d3e2:	39 01       	movw	r6, r18
    d3e4:	79 01       	movw	r14, r18
    d3e6:	00 e0       	ldi	r16, 0x00	; 0
    d3e8:	10 e0       	ldi	r17, 0x00	; 0
	//no tiene sentido que halla error seguido de un reset.
	
	
	/////////////////////////////LEE DATOS //////////////////////////////
    // get the data from the DK2000
    for(index=0; index<rCt; index++)
    d3ea:	23 2c       	mov	r2, r3
    d3ec:	33 24       	eor	r3, r3
    d3ee:	19 c0       	rjmp	.+50     	; 0xd422 <PMDParallel_Send+0x104>
    {
        if((result = PMDParallel_WaitForReady(transport_data)) != PMD_ERR_OK)
    d3f0:	c6 01       	movw	r24, r12
    d3f2:	0e 94 33 69 	call	0xd266	; 0xd266 <PMDParallel_WaitForReady>
    d3f6:	5c 01       	movw	r10, r24
    d3f8:	00 97       	sbiw	r24, 0x00	; 0
    d3fa:	29 f0       	breq	.+10     	; 0xd406 <PMDParallel_Send+0xe8>
	    {
	       printf("PMDParallel_Send=> Error datos recibidos\n");    
    d3fc:	8a eb       	ldi	r24, 0xBA	; 186
    d3fe:	95 e7       	ldi	r25, 0x75	; 117
    d400:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    d404:	11 c0       	rjmp	.+34     	; 0xd428 <PMDParallel_Send+0x10a>
          break;
		} 
        
		rDat[index] = transport_data->InPData(transport_data->dcs_Port);
    d406:	d6 01       	movw	r26, r12
    d408:	58 96       	adiw	r26, 0x18	; 24
    d40a:	ed 91       	ld	r30, X+
    d40c:	fc 91       	ld	r31, X
    d40e:	59 97       	sbiw	r26, 0x19	; 25
    d410:	8d 91       	ld	r24, X+
    d412:	9c 91       	ld	r25, X
    d414:	09 95       	icall
    d416:	f7 01       	movw	r30, r14
    d418:	81 93       	st	Z+, r24
    d41a:	91 93       	st	Z+, r25
    d41c:	7f 01       	movw	r14, r30
	//no tiene sentido que halla error seguido de un reset.
	
	
	/////////////////////////////LEE DATOS //////////////////////////////
    // get the data from the DK2000
    for(index=0; index<rCt; index++)
    d41e:	0f 5f       	subi	r16, 0xFF	; 255
    d420:	1f 4f       	sbci	r17, 0xFF	; 255
    d422:	02 15       	cp	r16, r2
    d424:	13 05       	cpc	r17, r3
    d426:	20 f3       	brcs	.-56     	; 0xd3f0 <PMDParallel_Send+0xd2>
		} 
        
		rDat[index] = transport_data->InPData(transport_data->dcs_Port);
    }
///////////////////////////VERIFICACIONES/////////////////////////////////    
    if(transport_data->bVerifyChecksum)
    d428:	d6 01       	movw	r26, r12
    d42a:	1e 96       	adiw	r26, 0x0e	; 14
    d42c:	8d 91       	ld	r24, X+
    d42e:	9c 91       	ld	r25, X
    d430:	1f 97       	sbiw	r26, 0x0f	; 15
    d432:	89 2b       	or	r24, r25
    d434:	09 f4       	brne	.+2      	; 0xd438 <PMDParallel_Send+0x11a>
    d436:	c2 c0       	rjmp	.+388    	; 0xd5bc <PMDParallel_Send+0x29e>
    d438:	5c 82       	std	Y+4, r5	; 0x04
    d43a:	4b 82       	std	Y+3, r4	; 0x03
    d43c:	f2 01       	movw	r30, r4
    d43e:	20 e0       	ldi	r18, 0x00	; 0
    d440:	30 e0       	ldi	r19, 0x00	; 0
    d442:	ee 24       	eor	r14, r14
    d444:	ff 24       	eor	r15, r15
    d446:	87 01       	movw	r16, r14
	{
		for(index=0; index<xCt; index++)
    d448:	9d 81       	ldd	r25, Y+5	; 0x05
    d44a:	89 2f       	mov	r24, r25
    d44c:	90 e0       	ldi	r25, 0x00	; 0
    d44e:	9f 83       	std	Y+7, r25	; 0x07
    d450:	8e 83       	std	Y+6, r24	; 0x06
    d452:	0a c0       	rjmp	.+20     	; 0xd468 <PMDParallel_Send+0x14a>
			messageChecksum += xDat[index];
    d454:	81 91       	ld	r24, Z+
    d456:	91 91       	ld	r25, Z+
    d458:	a0 e0       	ldi	r26, 0x00	; 0
    d45a:	b0 e0       	ldi	r27, 0x00	; 0
    d45c:	e8 0e       	add	r14, r24
    d45e:	f9 1e       	adc	r15, r25
    d460:	0a 1f       	adc	r16, r26
    d462:	1b 1f       	adc	r17, r27
		rDat[index] = transport_data->InPData(transport_data->dcs_Port);
    }
///////////////////////////VERIFICACIONES/////////////////////////////////    
    if(transport_data->bVerifyChecksum)
	{
		for(index=0; index<xCt; index++)
    d464:	2f 5f       	subi	r18, 0xFF	; 255
    d466:	3f 4f       	sbci	r19, 0xFF	; 255
    d468:	ae 81       	ldd	r26, Y+6	; 0x06
    d46a:	bf 81       	ldd	r27, Y+7	; 0x07
    d46c:	2a 17       	cp	r18, r26
    d46e:	3b 07       	cpc	r19, r27
    d470:	88 f3       	brcs	.-30     	; 0xd454 <PMDParallel_Send+0x136>
    d472:	20 e0       	ldi	r18, 0x00	; 0
    d474:	30 e0       	ldi	r19, 0x00	; 0
    d476:	0c c0       	rjmp	.+24     	; 0xd490 <PMDParallel_Send+0x172>
			messageChecksum += xDat[index];
		  
		for(index=0; index<rCt; index++)
			messageChecksum += rDat[index];
    d478:	f3 01       	movw	r30, r6
    d47a:	81 91       	ld	r24, Z+
    d47c:	91 91       	ld	r25, Z+
    d47e:	3f 01       	movw	r6, r30
    d480:	a0 e0       	ldi	r26, 0x00	; 0
    d482:	b0 e0       	ldi	r27, 0x00	; 0
    d484:	e8 0e       	add	r14, r24
    d486:	f9 1e       	adc	r15, r25
    d488:	0a 1f       	adc	r16, r26
    d48a:	1b 1f       	adc	r17, r27
    if(transport_data->bVerifyChecksum)
	{
		for(index=0; index<xCt; index++)
			messageChecksum += xDat[index];
		  
		for(index=0; index<rCt; index++)
    d48c:	2f 5f       	subi	r18, 0xFF	; 255
    d48e:	3f 4f       	sbci	r19, 0xFF	; 255
    d490:	22 15       	cp	r18, r2
    d492:	33 05       	cpc	r19, r3
    d494:	88 f3       	brcs	.-30     	; 0xd478 <PMDParallel_Send+0x15a>
       result = PMD_ERR_PMDNotInitialized;

        // get the data from the jarboter Controller
        for(index=0; index<length; index++)
        {
            if((result = PMDParallel_WaitForReady(transport_data)) != PMD_ERR_OK)
    d496:	c6 01       	movw	r24, r12
    d498:	0e 94 33 69 	call	0xd266	; 0xd266 <PMDParallel_WaitForReady>
    d49c:	5c 01       	movw	r10, r24
    d49e:	00 97       	sbiw	r24, 0x00	; 0
    d4a0:	29 f0       	breq	.+10     	; 0xd4ac <PMDParallel_Send+0x18e>
			{
			    printf("PMDParallel_ReceiveResponse=> wait for Cheksum timeout \n");		
    d4a2:	83 ee       	ldi	r24, 0xE3	; 227
    d4a4:	95 e7       	ldi	r25, 0x75	; 117
    d4a6:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    d4aa:	88 c0       	rjmp	.+272    	; 0xd5bc <PMDParallel_Send+0x29e>
			messageChecksum += xDat[index];
		  
		for(index=0; index<rCt; index++)
			messageChecksum += rDat[index];
		 
		messageChecksum = messageChecksum & 0xFFFF;
    d4ac:	8f ef       	ldi	r24, 0xFF	; 255
    d4ae:	9f ef       	ldi	r25, 0xFF	; 255
    d4b0:	a0 e0       	ldi	r26, 0x00	; 0
    d4b2:	b0 e0       	ldi	r27, 0x00	; 0
    d4b4:	e8 22       	and	r14, r24
    d4b6:	f9 22       	and	r15, r25
    d4b8:	0a 23       	and	r16, r26
    d4ba:	1b 23       	and	r17, r27
			{
			    printf("PMDParallel_ReceiveResponse=> wait for Cheksum timeout \n");		
                break;
			}
            
			buffer[index] = transport_data->InPData(transport_data->dcs_Port);
    d4bc:	d6 01       	movw	r26, r12
    d4be:	58 96       	adiw	r26, 0x18	; 24
    d4c0:	ed 91       	ld	r30, X+
    d4c2:	fc 91       	ld	r31, X
    d4c4:	59 97       	sbiw	r26, 0x19	; 25
    d4c6:	8d 91       	ld	r24, X+
    d4c8:	9c 91       	ld	r25, X
    d4ca:	09 95       	icall
    d4cc:	9c 01       	movw	r18, r24
    d4ce:	9a 83       	std	Y+2, r25	; 0x02
    d4d0:	89 83       	std	Y+1, r24	; 0x01
			messageChecksum += rDat[index];
		 
		messageChecksum = messageChecksum & 0xFFFF;
		
		result = PMDParallel_ReceiveResponse(transport_data, 1, &chipsetChecksum);
		if ( result == PMD_ERR_OK && messageChecksum != chipsetChecksum )
    d4d2:	a0 e0       	ldi	r26, 0x00	; 0
    d4d4:	b0 e0       	ldi	r27, 0x00	; 0
    d4d6:	e8 16       	cp	r14, r24
    d4d8:	f9 06       	cpc	r15, r25
    d4da:	0a 07       	cpc	r16, r26
    d4dc:	1b 07       	cpc	r17, r27
    d4de:	09 f4       	brne	.+2      	; 0xd4e2 <PMDParallel_Send+0x1c4>
    d4e0:	6d c0       	rjmp	.+218    	; 0xd5bc <PMDParallel_Send+0x29e>
		{			
			if (transport_data->bDiagnostics)
    d4e2:	f6 01       	movw	r30, r12
    d4e4:	80 89       	ldd	r24, Z+16	; 0x10
    d4e6:	91 89       	ldd	r25, Z+17	; 0x11
    d4e8:	89 2b       	or	r24, r25
    d4ea:	09 f4       	brne	.+2      	; 0xd4ee <PMDParallel_Send+0x1d0>
    d4ec:	62 c0       	rjmp	.+196    	; 0xd5b2 <PMDParallel_Send+0x294>
			{	
				printf("PMDParallel_Send=> Checksum failure.  expected: %ld  got: %x\n",messageChecksum,chipsetChecksum);
    d4ee:	8d b7       	in	r24, 0x3d	; 61
    d4f0:	9e b7       	in	r25, 0x3e	; 62
    d4f2:	08 97       	sbiw	r24, 0x08	; 8
    d4f4:	0f b6       	in	r0, 0x3f	; 63
    d4f6:	f8 94       	cli
    d4f8:	9e bf       	out	0x3e, r25	; 62
    d4fa:	0f be       	out	0x3f, r0	; 63
    d4fc:	8d bf       	out	0x3d, r24	; 61
    d4fe:	ed b7       	in	r30, 0x3d	; 61
    d500:	fe b7       	in	r31, 0x3e	; 62
    d502:	31 96       	adiw	r30, 0x01	; 1
    d504:	8b e1       	ldi	r24, 0x1B	; 27
    d506:	96 e7       	ldi	r25, 0x76	; 118
    d508:	ad b7       	in	r26, 0x3d	; 61
    d50a:	be b7       	in	r27, 0x3e	; 62
    d50c:	12 96       	adiw	r26, 0x02	; 2
    d50e:	9c 93       	st	X, r25
    d510:	8e 93       	st	-X, r24
    d512:	11 97       	sbiw	r26, 0x01	; 1
    d514:	e2 82       	std	Z+2, r14	; 0x02
    d516:	f3 82       	std	Z+3, r15	; 0x03
    d518:	04 83       	std	Z+4, r16	; 0x04
    d51a:	15 83       	std	Z+5, r17	; 0x05
    d51c:	37 83       	std	Z+7, r19	; 0x07
    d51e:	26 83       	std	Z+6, r18	; 0x06
    d520:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
				
				printf("PMDParallel_Send=> C-Motion: %s ",PMDGetOpcodeText(xDat[0]));
    d524:	ed b7       	in	r30, 0x3d	; 61
    d526:	fe b7       	in	r31, 0x3e	; 62
    d528:	38 96       	adiw	r30, 0x08	; 8
    d52a:	0f b6       	in	r0, 0x3f	; 63
    d52c:	f8 94       	cli
    d52e:	fe bf       	out	0x3e, r31	; 62
    d530:	0f be       	out	0x3f, r0	; 63
    d532:	ed bf       	out	0x3d, r30	; 61
    d534:	d2 01       	movw	r26, r4
    d536:	8d 91       	ld	r24, X+
    d538:	9c 91       	ld	r25, X
    d53a:	0e 94 bd 21 	call	0x437a	; 0x437a <PMDGetOpcodeText>
    d53e:	00 d0       	rcall	.+0      	; 0xd540 <PMDParallel_Send+0x222>
    d540:	00 d0       	rcall	.+0      	; 0xd542 <PMDParallel_Send+0x224>
    d542:	29 e5       	ldi	r18, 0x59	; 89
    d544:	36 e7       	ldi	r19, 0x76	; 118
    d546:	ed b7       	in	r30, 0x3d	; 61
    d548:	fe b7       	in	r31, 0x3e	; 62
    d54a:	32 83       	std	Z+2, r19	; 0x02
    d54c:	21 83       	std	Z+1, r18	; 0x01
    d54e:	94 83       	std	Z+4, r25	; 0x04
    d550:	83 83       	std	Z+3, r24	; 0x03
    d552:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    d556:	00 e0       	ldi	r16, 0x00	; 0
    d558:	10 e0       	ldi	r17, 0x00	; 0
    d55a:	0f 90       	pop	r0
    d55c:	0f 90       	pop	r0
    d55e:	0f 90       	pop	r0
    d560:	0f 90       	pop	r0
				
				for(index=0; index<xCt; index++)
					printf("%X ",xDat[index]);
    d562:	2a e7       	ldi	r18, 0x7A	; 122
    d564:	e2 2e       	mov	r14, r18
    d566:	26 e7       	ldi	r18, 0x76	; 118
    d568:	f2 2e       	mov	r15, r18
    d56a:	1a c0       	rjmp	.+52     	; 0xd5a0 <PMDParallel_Send+0x282>
    d56c:	00 d0       	rcall	.+0      	; 0xd56e <PMDParallel_Send+0x250>
    d56e:	00 d0       	rcall	.+0      	; 0xd570 <PMDParallel_Send+0x252>
    d570:	ad b7       	in	r26, 0x3d	; 61
    d572:	be b7       	in	r27, 0x3e	; 62
    d574:	12 96       	adiw	r26, 0x02	; 2
    d576:	fc 92       	st	X, r15
    d578:	ee 92       	st	-X, r14
    d57a:	11 97       	sbiw	r26, 0x01	; 1
    d57c:	eb 81       	ldd	r30, Y+3	; 0x03
    d57e:	fc 81       	ldd	r31, Y+4	; 0x04
    d580:	81 91       	ld	r24, Z+
    d582:	91 91       	ld	r25, Z+
    d584:	fc 83       	std	Y+4, r31	; 0x04
    d586:	eb 83       	std	Y+3, r30	; 0x03
    d588:	14 96       	adiw	r26, 0x04	; 4
    d58a:	9c 93       	st	X, r25
    d58c:	8e 93       	st	-X, r24
    d58e:	13 97       	sbiw	r26, 0x03	; 3
    d590:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
			{	
				printf("PMDParallel_Send=> Checksum failure.  expected: %ld  got: %x\n",messageChecksum,chipsetChecksum);
				
				printf("PMDParallel_Send=> C-Motion: %s ",PMDGetOpcodeText(xDat[0]));
				
				for(index=0; index<xCt; index++)
    d594:	0f 5f       	subi	r16, 0xFF	; 255
    d596:	1f 4f       	sbci	r17, 0xFF	; 255
    d598:	0f 90       	pop	r0
    d59a:	0f 90       	pop	r0
    d59c:	0f 90       	pop	r0
    d59e:	0f 90       	pop	r0
    d5a0:	2e 81       	ldd	r18, Y+6	; 0x06
    d5a2:	3f 81       	ldd	r19, Y+7	; 0x07
    d5a4:	02 17       	cp	r16, r18
    d5a6:	13 07       	cpc	r17, r19
    d5a8:	08 f3       	brcs	.-62     	; 0xd56c <PMDParallel_Send+0x24e>
					printf("%X ",xDat[index]);
				
				printf("\n");
    d5aa:	8a e0       	ldi	r24, 0x0A	; 10
    d5ac:	90 e0       	ldi	r25, 0x00	; 0
    d5ae:	0e 94 0d 89 	call	0x1121a	; 0x1121a <putchar>
    d5b2:	9e ef       	ldi	r25, 0xFE	; 254
    d5b4:	89 2e       	mov	r8, r25
    d5b6:	9f e7       	ldi	r25, 0x7F	; 127
    d5b8:	99 2e       	mov	r9, r25
    d5ba:	50 c0       	rjmp	.+160    	; 0xd65c <PMDParallel_Send+0x33e>
		    }  
			return PMD_ERR_ChecksumError;
		}
	}
	
	if (commandstatus!=PMD_ERR_OK)
    d5bc:	81 14       	cp	r8, r1
    d5be:	91 04       	cpc	r9, r1
    d5c0:	11 f4       	brne	.+4      	; 0xd5c6 <PMDParallel_Send+0x2a8>
    d5c2:	45 01       	movw	r8, r10
    d5c4:	4b c0       	rjmp	.+150    	; 0xd65c <PMDParallel_Send+0x33e>
	{
		if (transport_data->bDiagnostics)
    d5c6:	d6 01       	movw	r26, r12
    d5c8:	50 96       	adiw	r26, 0x10	; 16
    d5ca:	8d 91       	ld	r24, X+
    d5cc:	9c 91       	ld	r25, X
    d5ce:	51 97       	sbiw	r26, 0x11	; 17
    d5d0:	89 2b       	or	r24, r25
    d5d2:	09 f4       	brne	.+2      	; 0xd5d6 <PMDParallel_Send+0x2b8>
    d5d4:	43 c0       	rjmp	.+134    	; 0xd65c <PMDParallel_Send+0x33e>
		{
			printf("PMDParallel_Send=> Host I/O Error \n");
    d5d6:	8e e7       	ldi	r24, 0x7E	; 126
    d5d8:	96 e7       	ldi	r25, 0x76	; 118
    d5da:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
			printf("PMDParallel_Send=> C-Motion: %s ",PMDGetOpcodeText(xDat[0]));
    d5de:	f2 01       	movw	r30, r4
    d5e0:	80 81       	ld	r24, Z
    d5e2:	91 81       	ldd	r25, Z+1	; 0x01
    d5e4:	0e 94 bd 21 	call	0x437a	; 0x437a <PMDGetOpcodeText>
    d5e8:	00 d0       	rcall	.+0      	; 0xd5ea <PMDParallel_Send+0x2cc>
    d5ea:	00 d0       	rcall	.+0      	; 0xd5ec <PMDParallel_Send+0x2ce>
    d5ec:	29 e5       	ldi	r18, 0x59	; 89
    d5ee:	36 e7       	ldi	r19, 0x76	; 118
    d5f0:	ad b7       	in	r26, 0x3d	; 61
    d5f2:	be b7       	in	r27, 0x3e	; 62
    d5f4:	12 96       	adiw	r26, 0x02	; 2
    d5f6:	3c 93       	st	X, r19
    d5f8:	2e 93       	st	-X, r18
    d5fa:	11 97       	sbiw	r26, 0x01	; 1
    d5fc:	14 96       	adiw	r26, 0x04	; 4
    d5fe:	9c 93       	st	X, r25
    d600:	8e 93       	st	-X, r24
    d602:	13 97       	sbiw	r26, 0x03	; 3
    d604:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    d608:	72 01       	movw	r14, r4
    d60a:	00 e0       	ldi	r16, 0x00	; 0
    d60c:	10 e0       	ldi	r17, 0x00	; 0
    d60e:	0f 90       	pop	r0
    d610:	0f 90       	pop	r0
    d612:	0f 90       	pop	r0
    d614:	0f 90       	pop	r0
			
			for(index=0; index<xCt; index++)
    d616:	bd 81       	ldd	r27, Y+5	; 0x05
    d618:	cb 2e       	mov	r12, r27
    d61a:	dd 24       	eor	r13, r13
				printf("%X ",xDat[index]);
    d61c:	8a e7       	ldi	r24, 0x7A	; 122
    d61e:	a8 2e       	mov	r10, r24
    d620:	86 e7       	ldi	r24, 0x76	; 118
    d622:	b8 2e       	mov	r11, r24
    d624:	14 c0       	rjmp	.+40     	; 0xd64e <PMDParallel_Send+0x330>
    d626:	00 d0       	rcall	.+0      	; 0xd628 <PMDParallel_Send+0x30a>
    d628:	00 d0       	rcall	.+0      	; 0xd62a <PMDParallel_Send+0x30c>
    d62a:	ed b7       	in	r30, 0x3d	; 61
    d62c:	fe b7       	in	r31, 0x3e	; 62
    d62e:	b2 82       	std	Z+2, r11	; 0x02
    d630:	a1 82       	std	Z+1, r10	; 0x01
    d632:	d7 01       	movw	r26, r14
    d634:	8d 91       	ld	r24, X+
    d636:	9d 91       	ld	r25, X+
    d638:	7d 01       	movw	r14, r26
    d63a:	94 83       	std	Z+4, r25	; 0x04
    d63c:	83 83       	std	Z+3, r24	; 0x03
    d63e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
		if (transport_data->bDiagnostics)
		{
			printf("PMDParallel_Send=> Host I/O Error \n");
			printf("PMDParallel_Send=> C-Motion: %s ",PMDGetOpcodeText(xDat[0]));
			
			for(index=0; index<xCt; index++)
    d642:	0f 5f       	subi	r16, 0xFF	; 255
    d644:	1f 4f       	sbci	r17, 0xFF	; 255
    d646:	0f 90       	pop	r0
    d648:	0f 90       	pop	r0
    d64a:	0f 90       	pop	r0
    d64c:	0f 90       	pop	r0
    d64e:	0c 15       	cp	r16, r12
    d650:	1d 05       	cpc	r17, r13
    d652:	48 f3       	brcs	.-46     	; 0xd626 <PMDParallel_Send+0x308>
				printf("%X ",xDat[index]);
			
			printf("\n");
    d654:	8a e0       	ldi	r24, 0x0A	; 10
    d656:	90 e0       	ldi	r25, 0x00	; 0
    d658:	0e 94 0d 89 	call	0x1121a	; 0x1121a <putchar>
		}
		return commandstatus;
	}
	
	return result;
}
    d65c:	c4 01       	movw	r24, r8
    d65e:	27 96       	adiw	r28, 0x07	; 7
    d660:	0f b6       	in	r0, 0x3f	; 63
    d662:	f8 94       	cli
    d664:	de bf       	out	0x3e, r29	; 62
    d666:	0f be       	out	0x3f, r0	; 63
    d668:	cd bf       	out	0x3d, r28	; 61
    d66a:	cf 91       	pop	r28
    d66c:	df 91       	pop	r29
    d66e:	1f 91       	pop	r17
    d670:	0f 91       	pop	r16
    d672:	ff 90       	pop	r15
    d674:	ef 90       	pop	r14
    d676:	df 90       	pop	r13
    d678:	cf 90       	pop	r12
    d67a:	bf 90       	pop	r11
    d67c:	af 90       	pop	r10
    d67e:	9f 90       	pop	r9
    d680:	8f 90       	pop	r8
    d682:	7f 90       	pop	r7
    d684:	6f 90       	pop	r6
    d686:	5f 90       	pop	r5
    d688:	4f 90       	pop	r4
    d68a:	3f 90       	pop	r3
    d68c:	2f 90       	pop	r2
    d68e:	08 95       	ret

0000d690 <OutP8BitHard>:
}

//******************************************************************************************************************** 
void OutP8BitHard(void) 
{
  writePMDreset(); 
    d690:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <writePMDreset>
}
    d694:	08 95       	ret

0000d696 <InP8BitStatus>:
  return readPMDdata(PMDChipSet);
}
//********************************************************************************************************************
PMDuint16 InP8BitStatus(PMDuint16 PMDChipSet) 
{
  return readPMDstatus(PMDChipSet);
    d696:	0e 94 91 26 	call	0x4d22	; 0x4d22 <readPMDstatus>
}
    d69a:	08 95       	ret

0000d69c <InP8Bit>:
}

//********************************************************************************************************************
PMDuint16 InP8Bit(PMDuint16 PMDChipSet) 
{
  return readPMDdata(PMDChipSet);
    d69c:	0e 94 16 26 	call	0x4c2c	; 0x4c2c <readPMDdata>
}
    d6a0:	08 95       	ret

0000d6a2 <OutP8BitCmd>:


//********************************************************************************************************************
void OutP8BitCmd(PMDuint16 PMDChipSet, PMDuint16 dataword) 
{
  writePMDcommand(PMDChipSet,dataword);   // low-level function, provided by basicIO.h
    d6a2:	0e 94 66 25 	call	0x4acc	; 0x4acc <writePMDcommand>
}
    d6a6:	08 95       	ret

0000d6a8 <OutP8Bit>:
 
 
 //********************************************************************************************************************
void OutP8Bit(PMDuint16 PMDChipSet, PMDuint16 dataword) 
{
  writePMDdata(PMDChipSet,dataword);
    d6a8:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <writePMDdata>
}
    d6ac:	08 95       	ret

0000d6ae <BuildCommand>:
#include <avr/io.h>
#include "PMDtrans.h"


PMDuint16 BuildCommand(PMDuint16 OPCode, PMDAxis axis)
{
    d6ae:	36 2f       	mov	r19, r22
    d6b0:	20 e0       	ldi	r18, 0x00	; 0
    d6b2:	28 2b       	or	r18, r24
    d6b4:	39 2b       	or	r19, r25
	return ((PMDuint16)((PMDuint32)OPCode | ((PMDuint32)axis << 8)));
}
    d6b6:	c9 01       	movw	r24, r18
    d6b8:	08 95       	ret

0000d6ba <SendCommand>:




PMDuint16 SendCommand(PMDAxisHandle* axis_handle, PMDuint16 OPCode)
{
    d6ba:	0f 93       	push	r16
    d6bc:	1f 93       	push	r17
    d6be:	df 93       	push	r29
    d6c0:	cf 93       	push	r28
    d6c2:	00 d0       	rcall	.+0      	; 0xd6c4 <SendCommand+0xa>
    d6c4:	cd b7       	in	r28, 0x3d	; 61
    d6c6:	de b7       	in	r29, 0x3e	; 62
    d6c8:	fc 01       	movw	r30, r24
        PMDuint16 buffer[1];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
    d6ca:	92 81       	ldd	r25, Z+2	; 0x02
    d6cc:	80 e0       	ldi	r24, 0x00	; 0
    d6ce:	86 2b       	or	r24, r22
    d6d0:	97 2b       	or	r25, r23
    d6d2:	9a 83       	std	Y+2, r25	; 0x02
    d6d4:	89 83       	std	Y+1, r24	; 0x01

        return axis_handle->transport.SendCommand(axis_handle->transport_data, 1, buffer, 0, PMDnull);
    d6d6:	df 01       	movw	r26, r30
    d6d8:	a2 5a       	subi	r26, 0xA2	; 162
    d6da:	bf 4f       	sbci	r27, 0xFF	; 255
    d6dc:	e0 5b       	subi	r30, 0xB0	; 176
    d6de:	ff 4f       	sbci	r31, 0xFF	; 255
    d6e0:	01 90       	ld	r0, Z+
    d6e2:	f0 81       	ld	r31, Z
    d6e4:	e0 2d       	mov	r30, r0
    d6e6:	8d 91       	ld	r24, X+
    d6e8:	9c 91       	ld	r25, X
    d6ea:	61 e0       	ldi	r22, 0x01	; 1
    d6ec:	ae 01       	movw	r20, r28
    d6ee:	4f 5f       	subi	r20, 0xFF	; 255
    d6f0:	5f 4f       	sbci	r21, 0xFF	; 255
    d6f2:	20 e0       	ldi	r18, 0x00	; 0
    d6f4:	00 e0       	ldi	r16, 0x00	; 0
    d6f6:	10 e0       	ldi	r17, 0x00	; 0
    d6f8:	09 95       	icall
}
    d6fa:	0f 90       	pop	r0
    d6fc:	0f 90       	pop	r0
    d6fe:	cf 91       	pop	r28
    d700:	df 91       	pop	r29
    d702:	1f 91       	pop	r17
    d704:	0f 91       	pop	r16
    d706:	08 95       	ret

0000d708 <SendCommandWord>:


PMDuint16 SendCommandWord(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 data1)
{
    d708:	0f 93       	push	r16
    d70a:	1f 93       	push	r17
    d70c:	df 93       	push	r29
    d70e:	cf 93       	push	r28
    d710:	00 d0       	rcall	.+0      	; 0xd712 <SendCommandWord+0xa>
    d712:	00 d0       	rcall	.+0      	; 0xd714 <SendCommandWord+0xc>
    d714:	cd b7       	in	r28, 0x3d	; 61
    d716:	de b7       	in	r29, 0x3e	; 62
    d718:	fc 01       	movw	r30, r24
        PMDuint16 buffer[2];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
    d71a:	92 81       	ldd	r25, Z+2	; 0x02
    d71c:	80 e0       	ldi	r24, 0x00	; 0
    d71e:	86 2b       	or	r24, r22
    d720:	97 2b       	or	r25, r23
    d722:	9a 83       	std	Y+2, r25	; 0x02
    d724:	89 83       	std	Y+1, r24	; 0x01
        buffer[1] = (PMDuint16)data1;
    d726:	5c 83       	std	Y+4, r21	; 0x04
    d728:	4b 83       	std	Y+3, r20	; 0x03

        return axis_handle->transport.SendCommand(axis_handle->transport_data, 2, buffer, 0, PMDnull);
    d72a:	df 01       	movw	r26, r30
    d72c:	a2 5a       	subi	r26, 0xA2	; 162
    d72e:	bf 4f       	sbci	r27, 0xFF	; 255
    d730:	e0 5b       	subi	r30, 0xB0	; 176
    d732:	ff 4f       	sbci	r31, 0xFF	; 255
    d734:	01 90       	ld	r0, Z+
    d736:	f0 81       	ld	r31, Z
    d738:	e0 2d       	mov	r30, r0
    d73a:	8d 91       	ld	r24, X+
    d73c:	9c 91       	ld	r25, X
    d73e:	62 e0       	ldi	r22, 0x02	; 2
    d740:	ae 01       	movw	r20, r28
    d742:	4f 5f       	subi	r20, 0xFF	; 255
    d744:	5f 4f       	sbci	r21, 0xFF	; 255
    d746:	20 e0       	ldi	r18, 0x00	; 0
    d748:	00 e0       	ldi	r16, 0x00	; 0
    d74a:	10 e0       	ldi	r17, 0x00	; 0
    d74c:	09 95       	icall
}
    d74e:	0f 90       	pop	r0
    d750:	0f 90       	pop	r0
    d752:	0f 90       	pop	r0
    d754:	0f 90       	pop	r0
    d756:	cf 91       	pop	r28
    d758:	df 91       	pop	r29
    d75a:	1f 91       	pop	r17
    d75c:	0f 91       	pop	r16
    d75e:	08 95       	ret

0000d760 <SendCommandWordWord>:


PMDuint16 SendCommandWordWord(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 data1, PMDuint16 data2)
{
    d760:	0f 93       	push	r16
    d762:	1f 93       	push	r17
    d764:	df 93       	push	r29
    d766:	cf 93       	push	r28
    d768:	00 d0       	rcall	.+0      	; 0xd76a <SendCommandWordWord+0xa>
    d76a:	00 d0       	rcall	.+0      	; 0xd76c <SendCommandWordWord+0xc>
    d76c:	00 d0       	rcall	.+0      	; 0xd76e <SendCommandWordWord+0xe>
    d76e:	cd b7       	in	r28, 0x3d	; 61
    d770:	de b7       	in	r29, 0x3e	; 62
    d772:	fc 01       	movw	r30, r24
        PMDuint16 buffer[3];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
    d774:	92 81       	ldd	r25, Z+2	; 0x02
    d776:	80 e0       	ldi	r24, 0x00	; 0
    d778:	86 2b       	or	r24, r22
    d77a:	97 2b       	or	r25, r23
    d77c:	9a 83       	std	Y+2, r25	; 0x02
    d77e:	89 83       	std	Y+1, r24	; 0x01
        buffer[1] = (PMDuint16)data1;
    d780:	5c 83       	std	Y+4, r21	; 0x04
    d782:	4b 83       	std	Y+3, r20	; 0x03
        buffer[2] = (PMDuint16)data2;
    d784:	3e 83       	std	Y+6, r19	; 0x06
    d786:	2d 83       	std	Y+5, r18	; 0x05

        return axis_handle->transport.SendCommand(axis_handle->transport_data, 3, buffer, 0, PMDnull);
    d788:	df 01       	movw	r26, r30
    d78a:	a2 5a       	subi	r26, 0xA2	; 162
    d78c:	bf 4f       	sbci	r27, 0xFF	; 255
    d78e:	e0 5b       	subi	r30, 0xB0	; 176
    d790:	ff 4f       	sbci	r31, 0xFF	; 255
    d792:	01 90       	ld	r0, Z+
    d794:	f0 81       	ld	r31, Z
    d796:	e0 2d       	mov	r30, r0
    d798:	8d 91       	ld	r24, X+
    d79a:	9c 91       	ld	r25, X
    d79c:	63 e0       	ldi	r22, 0x03	; 3
    d79e:	ae 01       	movw	r20, r28
    d7a0:	4f 5f       	subi	r20, 0xFF	; 255
    d7a2:	5f 4f       	sbci	r21, 0xFF	; 255
    d7a4:	20 e0       	ldi	r18, 0x00	; 0
    d7a6:	00 e0       	ldi	r16, 0x00	; 0
    d7a8:	10 e0       	ldi	r17, 0x00	; 0
    d7aa:	09 95       	icall
}
    d7ac:	26 96       	adiw	r28, 0x06	; 6
    d7ae:	0f b6       	in	r0, 0x3f	; 63
    d7b0:	f8 94       	cli
    d7b2:	de bf       	out	0x3e, r29	; 62
    d7b4:	0f be       	out	0x3f, r0	; 63
    d7b6:	cd bf       	out	0x3d, r28	; 61
    d7b8:	cf 91       	pop	r28
    d7ba:	df 91       	pop	r29
    d7bc:	1f 91       	pop	r17
    d7be:	0f 91       	pop	r16
    d7c0:	08 95       	ret

0000d7c2 <SendCommandLong>:


PMDuint16 SendCommandLong(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint32 data1)
{
    d7c2:	0f 93       	push	r16
    d7c4:	1f 93       	push	r17
    d7c6:	df 93       	push	r29
    d7c8:	cf 93       	push	r28
    d7ca:	cd b7       	in	r28, 0x3d	; 61
    d7cc:	de b7       	in	r29, 0x3e	; 62
    d7ce:	2a 97       	sbiw	r28, 0x0a	; 10
    d7d0:	0f b6       	in	r0, 0x3f	; 63
    d7d2:	f8 94       	cli
    d7d4:	de bf       	out	0x3e, r29	; 62
    d7d6:	0f be       	out	0x3f, r0	; 63
    d7d8:	cd bf       	out	0x3d, r28	; 61
    d7da:	fc 01       	movw	r30, r24
    d7dc:	2f 83       	std	Y+7, r18	; 0x07
    d7de:	38 87       	std	Y+8, r19	; 0x08
    d7e0:	49 87       	std	Y+9, r20	; 0x09
    d7e2:	5a 87       	std	Y+10, r21	; 0x0a
        PMDuint16 buffer[3];
        PMDuint16* ptr;
		PMDuint32* temp;

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
    d7e4:	92 81       	ldd	r25, Z+2	; 0x02
    d7e6:	80 e0       	ldi	r24, 0x00	; 0
    d7e8:	86 2b       	or	r24, r22
    d7ea:	97 2b       	or	r25, r23
    d7ec:	9a 83       	std	Y+2, r25	; 0x02
    d7ee:	89 83       	std	Y+1, r24	; 0x01
		temp=&data1;
        ptr = (PMDuint16 *)temp;
        buffer[1]=*(ptr+1); //Write MSW first
    d7f0:	89 85       	ldd	r24, Y+9	; 0x09
    d7f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    d7f4:	9c 83       	std	Y+4, r25	; 0x04
    d7f6:	8b 83       	std	Y+3, r24	; 0x03
        buffer[2]=*ptr;
    d7f8:	8f 81       	ldd	r24, Y+7	; 0x07
    d7fa:	98 85       	ldd	r25, Y+8	; 0x08
    d7fc:	9e 83       	std	Y+6, r25	; 0x06
    d7fe:	8d 83       	std	Y+5, r24	; 0x05

        return axis_handle->transport.SendCommand(axis_handle->transport_data, 3, buffer, 0, PMDnull);
    d800:	df 01       	movw	r26, r30
    d802:	a2 5a       	subi	r26, 0xA2	; 162
    d804:	bf 4f       	sbci	r27, 0xFF	; 255
    d806:	e0 5b       	subi	r30, 0xB0	; 176
    d808:	ff 4f       	sbci	r31, 0xFF	; 255
    d80a:	01 90       	ld	r0, Z+
    d80c:	f0 81       	ld	r31, Z
    d80e:	e0 2d       	mov	r30, r0
    d810:	8d 91       	ld	r24, X+
    d812:	9c 91       	ld	r25, X
    d814:	63 e0       	ldi	r22, 0x03	; 3
    d816:	ae 01       	movw	r20, r28
    d818:	4f 5f       	subi	r20, 0xFF	; 255
    d81a:	5f 4f       	sbci	r21, 0xFF	; 255
    d81c:	20 e0       	ldi	r18, 0x00	; 0
    d81e:	00 e0       	ldi	r16, 0x00	; 0
    d820:	10 e0       	ldi	r17, 0x00	; 0
    d822:	09 95       	icall
}
    d824:	2a 96       	adiw	r28, 0x0a	; 10
    d826:	0f b6       	in	r0, 0x3f	; 63
    d828:	f8 94       	cli
    d82a:	de bf       	out	0x3e, r29	; 62
    d82c:	0f be       	out	0x3f, r0	; 63
    d82e:	cd bf       	out	0x3d, r28	; 61
    d830:	cf 91       	pop	r28
    d832:	df 91       	pop	r29
    d834:	1f 91       	pop	r17
    d836:	0f 91       	pop	r16
    d838:	08 95       	ret

0000d83a <SendCommandWordLong>:


PMDuint16 SendCommandWordLong(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 data1, PMDuint32 data2)
{
    d83a:	0f 93       	push	r16
    d83c:	1f 93       	push	r17
    d83e:	df 93       	push	r29
    d840:	cf 93       	push	r28
    d842:	cd b7       	in	r28, 0x3d	; 61
    d844:	de b7       	in	r29, 0x3e	; 62
    d846:	2c 97       	sbiw	r28, 0x0c	; 12
    d848:	0f b6       	in	r0, 0x3f	; 63
    d84a:	f8 94       	cli
    d84c:	de bf       	out	0x3e, r29	; 62
    d84e:	0f be       	out	0x3f, r0	; 63
    d850:	cd bf       	out	0x3d, r28	; 61
    d852:	fc 01       	movw	r30, r24
    d854:	09 87       	std	Y+9, r16	; 0x09
    d856:	1a 87       	std	Y+10, r17	; 0x0a
    d858:	2b 87       	std	Y+11, r18	; 0x0b
    d85a:	3c 87       	std	Y+12, r19	; 0x0c
        PMDuint16 buffer[4];
        PMDuint16 *ptr;
		PMDuint32 *temp;

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
    d85c:	92 81       	ldd	r25, Z+2	; 0x02
    d85e:	80 e0       	ldi	r24, 0x00	; 0
    d860:	86 2b       	or	r24, r22
    d862:	97 2b       	or	r25, r23
    d864:	9a 83       	std	Y+2, r25	; 0x02
    d866:	89 83       	std	Y+1, r24	; 0x01
        buffer[1] = data1;
    d868:	5c 83       	std	Y+4, r21	; 0x04
    d86a:	4b 83       	std	Y+3, r20	; 0x03
		temp=&data2;
        ptr = (PMDuint16 *)temp;
        buffer[2]=*(ptr+1); //Write MSW first
    d86c:	8b 85       	ldd	r24, Y+11	; 0x0b
    d86e:	9c 85       	ldd	r25, Y+12	; 0x0c
    d870:	9e 83       	std	Y+6, r25	; 0x06
    d872:	8d 83       	std	Y+5, r24	; 0x05
        buffer[3]=*ptr;
    d874:	89 85       	ldd	r24, Y+9	; 0x09
    d876:	9a 85       	ldd	r25, Y+10	; 0x0a
    d878:	98 87       	std	Y+8, r25	; 0x08
    d87a:	8f 83       	std	Y+7, r24	; 0x07

        return axis_handle->transport.SendCommand(axis_handle->transport_data, 4, buffer, 0, PMDnull);
    d87c:	df 01       	movw	r26, r30
    d87e:	a2 5a       	subi	r26, 0xA2	; 162
    d880:	bf 4f       	sbci	r27, 0xFF	; 255
    d882:	e0 5b       	subi	r30, 0xB0	; 176
    d884:	ff 4f       	sbci	r31, 0xFF	; 255
    d886:	01 90       	ld	r0, Z+
    d888:	f0 81       	ld	r31, Z
    d88a:	e0 2d       	mov	r30, r0
    d88c:	8d 91       	ld	r24, X+
    d88e:	9c 91       	ld	r25, X
    d890:	64 e0       	ldi	r22, 0x04	; 4
    d892:	ae 01       	movw	r20, r28
    d894:	4f 5f       	subi	r20, 0xFF	; 255
    d896:	5f 4f       	sbci	r21, 0xFF	; 255
    d898:	20 e0       	ldi	r18, 0x00	; 0
    d89a:	00 e0       	ldi	r16, 0x00	; 0
    d89c:	10 e0       	ldi	r17, 0x00	; 0
    d89e:	09 95       	icall
}
    d8a0:	2c 96       	adiw	r28, 0x0c	; 12
    d8a2:	0f b6       	in	r0, 0x3f	; 63
    d8a4:	f8 94       	cli
    d8a6:	de bf       	out	0x3e, r29	; 62
    d8a8:	0f be       	out	0x3f, r0	; 63
    d8aa:	cd bf       	out	0x3d, r28	; 61
    d8ac:	cf 91       	pop	r28
    d8ae:	df 91       	pop	r29
    d8b0:	1f 91       	pop	r17
    d8b2:	0f 91       	pop	r16
    d8b4:	08 95       	ret

0000d8b6 <SendCommandGetWord>:


PMDuint16 SendCommandGetWord(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 *data1)
{
    d8b6:	ef 92       	push	r14
    d8b8:	ff 92       	push	r15
    d8ba:	0f 93       	push	r16
    d8bc:	1f 93       	push	r17
    d8be:	df 93       	push	r29
    d8c0:	cf 93       	push	r28
    d8c2:	00 d0       	rcall	.+0      	; 0xd8c4 <SendCommandGetWord+0xe>
    d8c4:	00 d0       	rcall	.+0      	; 0xd8c6 <SendCommandGetWord+0x10>
    d8c6:	cd b7       	in	r28, 0x3d	; 61
    d8c8:	de b7       	in	r29, 0x3e	; 62
    d8ca:	fc 01       	movw	r30, r24
    d8cc:	7a 01       	movw	r14, r20
        PMDuint16 result = PMD_ERR_OK;
        PMDuint16 buffer[2];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
    d8ce:	92 81       	ldd	r25, Z+2	; 0x02
    d8d0:	80 e0       	ldi	r24, 0x00	; 0
    d8d2:	86 2b       	or	r24, r22
    d8d4:	97 2b       	or	r25, r23
    d8d6:	9a 83       	std	Y+2, r25	; 0x02
    d8d8:	89 83       	std	Y+1, r24	; 0x01

        result = axis_handle->transport.SendCommand(axis_handle->transport_data, 1, buffer, 1, buffer+1);
    d8da:	df 01       	movw	r26, r30
    d8dc:	a2 5a       	subi	r26, 0xA2	; 162
    d8de:	bf 4f       	sbci	r27, 0xFF	; 255
    d8e0:	e0 5b       	subi	r30, 0xB0	; 176
    d8e2:	ff 4f       	sbci	r31, 0xFF	; 255
    d8e4:	01 90       	ld	r0, Z+
    d8e6:	f0 81       	ld	r31, Z
    d8e8:	e0 2d       	mov	r30, r0
    d8ea:	8d 91       	ld	r24, X+
    d8ec:	9c 91       	ld	r25, X
    d8ee:	61 e0       	ldi	r22, 0x01	; 1
    d8f0:	ae 01       	movw	r20, r28
    d8f2:	4f 5f       	subi	r20, 0xFF	; 255
    d8f4:	5f 4f       	sbci	r21, 0xFF	; 255
    d8f6:	21 e0       	ldi	r18, 0x01	; 1
    d8f8:	8e 01       	movw	r16, r28
    d8fa:	0d 5f       	subi	r16, 0xFD	; 253
    d8fc:	1f 4f       	sbci	r17, 0xFF	; 255
    d8fe:	09 95       	icall

        *data1 = (PMDuint16)buffer[1];
    d900:	2b 81       	ldd	r18, Y+3	; 0x03
    d902:	3c 81       	ldd	r19, Y+4	; 0x04
    d904:	f7 01       	movw	r30, r14
    d906:	31 83       	std	Z+1, r19	; 0x01
    d908:	20 83       	st	Z, r18

        return result;
}
    d90a:	0f 90       	pop	r0
    d90c:	0f 90       	pop	r0
    d90e:	0f 90       	pop	r0
    d910:	0f 90       	pop	r0
    d912:	cf 91       	pop	r28
    d914:	df 91       	pop	r29
    d916:	1f 91       	pop	r17
    d918:	0f 91       	pop	r16
    d91a:	ff 90       	pop	r15
    d91c:	ef 90       	pop	r14
    d91e:	08 95       	ret

0000d920 <SendCommandGetWordWord>:

PMDuint16 SendCommandGetWordWord(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 *data1, PMDuint16 *data2)
{
    d920:	cf 92       	push	r12
    d922:	df 92       	push	r13
    d924:	ef 92       	push	r14
    d926:	ff 92       	push	r15
    d928:	0f 93       	push	r16
    d92a:	1f 93       	push	r17
    d92c:	df 93       	push	r29
    d92e:	cf 93       	push	r28
    d930:	00 d0       	rcall	.+0      	; 0xd932 <SendCommandGetWordWord+0x12>
    d932:	00 d0       	rcall	.+0      	; 0xd934 <SendCommandGetWordWord+0x14>
    d934:	00 d0       	rcall	.+0      	; 0xd936 <SendCommandGetWordWord+0x16>
    d936:	cd b7       	in	r28, 0x3d	; 61
    d938:	de b7       	in	r29, 0x3e	; 62
    d93a:	fc 01       	movw	r30, r24
    d93c:	7a 01       	movw	r14, r20
    d93e:	69 01       	movw	r12, r18
        PMDuint16 result = PMD_ERR_OK;
        PMDuint16 buffer[3];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
    d940:	92 81       	ldd	r25, Z+2	; 0x02
    d942:	80 e0       	ldi	r24, 0x00	; 0
    d944:	86 2b       	or	r24, r22
    d946:	97 2b       	or	r25, r23
    d948:	9a 83       	std	Y+2, r25	; 0x02
    d94a:	89 83       	std	Y+1, r24	; 0x01

        result = axis_handle->transport.SendCommand(axis_handle->transport_data, 1, buffer, 2, buffer+1);
    d94c:	df 01       	movw	r26, r30
    d94e:	a2 5a       	subi	r26, 0xA2	; 162
    d950:	bf 4f       	sbci	r27, 0xFF	; 255
    d952:	e0 5b       	subi	r30, 0xB0	; 176
    d954:	ff 4f       	sbci	r31, 0xFF	; 255
    d956:	01 90       	ld	r0, Z+
    d958:	f0 81       	ld	r31, Z
    d95a:	e0 2d       	mov	r30, r0
    d95c:	8d 91       	ld	r24, X+
    d95e:	9c 91       	ld	r25, X
    d960:	61 e0       	ldi	r22, 0x01	; 1
    d962:	ae 01       	movw	r20, r28
    d964:	4f 5f       	subi	r20, 0xFF	; 255
    d966:	5f 4f       	sbci	r21, 0xFF	; 255
    d968:	22 e0       	ldi	r18, 0x02	; 2
    d96a:	8e 01       	movw	r16, r28
    d96c:	0d 5f       	subi	r16, 0xFD	; 253
    d96e:	1f 4f       	sbci	r17, 0xFF	; 255
    d970:	09 95       	icall

        *data1 = (PMDuint16)buffer[1];
    d972:	2b 81       	ldd	r18, Y+3	; 0x03
    d974:	3c 81       	ldd	r19, Y+4	; 0x04
    d976:	f7 01       	movw	r30, r14
    d978:	31 83       	std	Z+1, r19	; 0x01
    d97a:	20 83       	st	Z, r18
        *data2 = (PMDuint16)buffer[2];
    d97c:	2d 81       	ldd	r18, Y+5	; 0x05
    d97e:	3e 81       	ldd	r19, Y+6	; 0x06
    d980:	f6 01       	movw	r30, r12
    d982:	31 83       	std	Z+1, r19	; 0x01
    d984:	20 83       	st	Z, r18

        return result;
}
    d986:	26 96       	adiw	r28, 0x06	; 6
    d988:	0f b6       	in	r0, 0x3f	; 63
    d98a:	f8 94       	cli
    d98c:	de bf       	out	0x3e, r29	; 62
    d98e:	0f be       	out	0x3f, r0	; 63
    d990:	cd bf       	out	0x3d, r28	; 61
    d992:	cf 91       	pop	r28
    d994:	df 91       	pop	r29
    d996:	1f 91       	pop	r17
    d998:	0f 91       	pop	r16
    d99a:	ff 90       	pop	r15
    d99c:	ef 90       	pop	r14
    d99e:	df 90       	pop	r13
    d9a0:	cf 90       	pop	r12
    d9a2:	08 95       	ret

0000d9a4 <SendCommandGetLong>:


PMDuint16 SendCommandGetLong(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint32 *data1)
{
    d9a4:	cf 92       	push	r12
    d9a6:	df 92       	push	r13
    d9a8:	ef 92       	push	r14
    d9aa:	ff 92       	push	r15
    d9ac:	0f 93       	push	r16
    d9ae:	1f 93       	push	r17
    d9b0:	df 93       	push	r29
    d9b2:	cf 93       	push	r28
    d9b4:	00 d0       	rcall	.+0      	; 0xd9b6 <SendCommandGetLong+0x12>
    d9b6:	00 d0       	rcall	.+0      	; 0xd9b8 <SendCommandGetLong+0x14>
    d9b8:	00 d0       	rcall	.+0      	; 0xd9ba <SendCommandGetLong+0x16>
    d9ba:	cd b7       	in	r28, 0x3d	; 61
    d9bc:	de b7       	in	r29, 0x3e	; 62
    d9be:	fc 01       	movw	r30, r24
    d9c0:	6a 01       	movw	r12, r20
        PMDuint16 result = PMD_ERR_OK;
        PMDuint16 buffer[3];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
    d9c2:	92 81       	ldd	r25, Z+2	; 0x02
    d9c4:	80 e0       	ldi	r24, 0x00	; 0
    d9c6:	86 2b       	or	r24, r22
    d9c8:	97 2b       	or	r25, r23
    d9ca:	9a 83       	std	Y+2, r25	; 0x02
    d9cc:	89 83       	std	Y+1, r24	; 0x01

        result = axis_handle->transport.SendCommand(axis_handle->transport_data, 1, buffer, 2, buffer+1);
    d9ce:	df 01       	movw	r26, r30
    d9d0:	a2 5a       	subi	r26, 0xA2	; 162
    d9d2:	bf 4f       	sbci	r27, 0xFF	; 255
    d9d4:	e0 5b       	subi	r30, 0xB0	; 176
    d9d6:	ff 4f       	sbci	r31, 0xFF	; 255
    d9d8:	01 90       	ld	r0, Z+
    d9da:	f0 81       	ld	r31, Z
    d9dc:	e0 2d       	mov	r30, r0
    d9de:	8d 91       	ld	r24, X+
    d9e0:	9c 91       	ld	r25, X
    d9e2:	61 e0       	ldi	r22, 0x01	; 1
    d9e4:	ae 01       	movw	r20, r28
    d9e6:	4f 5f       	subi	r20, 0xFF	; 255
    d9e8:	5f 4f       	sbci	r21, 0xFF	; 255
    d9ea:	22 e0       	ldi	r18, 0x02	; 2
    d9ec:	8e 01       	movw	r16, r28
    d9ee:	0d 5f       	subi	r16, 0xFD	; 253
    d9f0:	1f 4f       	sbci	r17, 0xFF	; 255
    d9f2:	09 95       	icall

        *data1 = ((PMDuint32)buffer[1])<<16 | ((PMDuint32)buffer[2]);
    d9f4:	2b 81       	ldd	r18, Y+3	; 0x03
    d9f6:	3c 81       	ldd	r19, Y+4	; 0x04
    d9f8:	40 e0       	ldi	r20, 0x00	; 0
    d9fa:	50 e0       	ldi	r21, 0x00	; 0
    d9fc:	a9 01       	movw	r20, r18
    d9fe:	33 27       	eor	r19, r19
    da00:	22 27       	eor	r18, r18
    da02:	ed 80       	ldd	r14, Y+5	; 0x05
    da04:	fe 80       	ldd	r15, Y+6	; 0x06
    da06:	00 e0       	ldi	r16, 0x00	; 0
    da08:	10 e0       	ldi	r17, 0x00	; 0
    da0a:	2e 29       	or	r18, r14
    da0c:	3f 29       	or	r19, r15
    da0e:	40 2b       	or	r20, r16
    da10:	51 2b       	or	r21, r17
    da12:	f6 01       	movw	r30, r12
    da14:	20 83       	st	Z, r18
    da16:	31 83       	std	Z+1, r19	; 0x01
    da18:	42 83       	std	Z+2, r20	; 0x02
    da1a:	53 83       	std	Z+3, r21	; 0x03

        return result;
}
    da1c:	26 96       	adiw	r28, 0x06	; 6
    da1e:	0f b6       	in	r0, 0x3f	; 63
    da20:	f8 94       	cli
    da22:	de bf       	out	0x3e, r29	; 62
    da24:	0f be       	out	0x3f, r0	; 63
    da26:	cd bf       	out	0x3d, r28	; 61
    da28:	cf 91       	pop	r28
    da2a:	df 91       	pop	r29
    da2c:	1f 91       	pop	r17
    da2e:	0f 91       	pop	r16
    da30:	ff 90       	pop	r15
    da32:	ef 90       	pop	r14
    da34:	df 90       	pop	r13
    da36:	cf 90       	pop	r12
    da38:	08 95       	ret

0000da3a <SendCommandWordGetWord>:

PMDuint16 SendCommandWordGetWord(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 data1, PMDuint16 *data2)
{
    da3a:	ef 92       	push	r14
    da3c:	ff 92       	push	r15
    da3e:	0f 93       	push	r16
    da40:	1f 93       	push	r17
    da42:	df 93       	push	r29
    da44:	cf 93       	push	r28
    da46:	00 d0       	rcall	.+0      	; 0xda48 <SendCommandWordGetWord+0xe>
    da48:	00 d0       	rcall	.+0      	; 0xda4a <SendCommandWordGetWord+0x10>
    da4a:	00 d0       	rcall	.+0      	; 0xda4c <SendCommandWordGetWord+0x12>
    da4c:	cd b7       	in	r28, 0x3d	; 61
    da4e:	de b7       	in	r29, 0x3e	; 62
    da50:	fc 01       	movw	r30, r24
    da52:	79 01       	movw	r14, r18
        PMDuint16 result = PMD_ERR_OK;
        PMDuint16 buffer[3];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
    da54:	92 81       	ldd	r25, Z+2	; 0x02
    da56:	80 e0       	ldi	r24, 0x00	; 0
    da58:	86 2b       	or	r24, r22
    da5a:	97 2b       	or	r25, r23
    da5c:	9a 83       	std	Y+2, r25	; 0x02
    da5e:	89 83       	std	Y+1, r24	; 0x01
        buffer[1] = (PMDuint16)data1;
    da60:	5c 83       	std	Y+4, r21	; 0x04
    da62:	4b 83       	std	Y+3, r20	; 0x03

        result = axis_handle->transport.SendCommand(axis_handle->transport_data, 2, buffer, 1, buffer+2);
    da64:	df 01       	movw	r26, r30
    da66:	a2 5a       	subi	r26, 0xA2	; 162
    da68:	bf 4f       	sbci	r27, 0xFF	; 255
    da6a:	e0 5b       	subi	r30, 0xB0	; 176
    da6c:	ff 4f       	sbci	r31, 0xFF	; 255
    da6e:	01 90       	ld	r0, Z+
    da70:	f0 81       	ld	r31, Z
    da72:	e0 2d       	mov	r30, r0
    da74:	8d 91       	ld	r24, X+
    da76:	9c 91       	ld	r25, X
    da78:	62 e0       	ldi	r22, 0x02	; 2
    da7a:	ae 01       	movw	r20, r28
    da7c:	4f 5f       	subi	r20, 0xFF	; 255
    da7e:	5f 4f       	sbci	r21, 0xFF	; 255
    da80:	21 e0       	ldi	r18, 0x01	; 1
    da82:	8e 01       	movw	r16, r28
    da84:	0b 5f       	subi	r16, 0xFB	; 251
    da86:	1f 4f       	sbci	r17, 0xFF	; 255
    da88:	09 95       	icall

        *data2 = (PMDuint16)buffer[2];
    da8a:	2d 81       	ldd	r18, Y+5	; 0x05
    da8c:	3e 81       	ldd	r19, Y+6	; 0x06
    da8e:	f7 01       	movw	r30, r14
    da90:	31 83       	std	Z+1, r19	; 0x01
    da92:	20 83       	st	Z, r18

        return result;
}
    da94:	26 96       	adiw	r28, 0x06	; 6
    da96:	0f b6       	in	r0, 0x3f	; 63
    da98:	f8 94       	cli
    da9a:	de bf       	out	0x3e, r29	; 62
    da9c:	0f be       	out	0x3f, r0	; 63
    da9e:	cd bf       	out	0x3d, r28	; 61
    daa0:	cf 91       	pop	r28
    daa2:	df 91       	pop	r29
    daa4:	1f 91       	pop	r17
    daa6:	0f 91       	pop	r16
    daa8:	ff 90       	pop	r15
    daaa:	ef 90       	pop	r14
    daac:	08 95       	ret

0000daae <SendCommandWordGetLong>:

PMDuint16 SendCommandWordGetLong(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 data1, PMDuint32 *data2)
{
    daae:	cf 92       	push	r12
    dab0:	df 92       	push	r13
    dab2:	ef 92       	push	r14
    dab4:	ff 92       	push	r15
    dab6:	0f 93       	push	r16
    dab8:	1f 93       	push	r17
    daba:	df 93       	push	r29
    dabc:	cf 93       	push	r28
    dabe:	cd b7       	in	r28, 0x3d	; 61
    dac0:	de b7       	in	r29, 0x3e	; 62
    dac2:	28 97       	sbiw	r28, 0x08	; 8
    dac4:	0f b6       	in	r0, 0x3f	; 63
    dac6:	f8 94       	cli
    dac8:	de bf       	out	0x3e, r29	; 62
    daca:	0f be       	out	0x3f, r0	; 63
    dacc:	cd bf       	out	0x3d, r28	; 61
    dace:	fc 01       	movw	r30, r24
    dad0:	69 01       	movw	r12, r18
        PMDuint16 result = PMD_ERR_OK;
        PMDuint16 buffer[4];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
    dad2:	92 81       	ldd	r25, Z+2	; 0x02
    dad4:	80 e0       	ldi	r24, 0x00	; 0
    dad6:	86 2b       	or	r24, r22
    dad8:	97 2b       	or	r25, r23
    dada:	9a 83       	std	Y+2, r25	; 0x02
    dadc:	89 83       	std	Y+1, r24	; 0x01
        buffer[1] = (PMDuint16)data1;
    dade:	5c 83       	std	Y+4, r21	; 0x04
    dae0:	4b 83       	std	Y+3, r20	; 0x03

        result = axis_handle->transport.SendCommand(axis_handle->transport_data, 2, buffer, 2, buffer+2);
    dae2:	df 01       	movw	r26, r30
    dae4:	a2 5a       	subi	r26, 0xA2	; 162
    dae6:	bf 4f       	sbci	r27, 0xFF	; 255
    dae8:	e0 5b       	subi	r30, 0xB0	; 176
    daea:	ff 4f       	sbci	r31, 0xFF	; 255
    daec:	01 90       	ld	r0, Z+
    daee:	f0 81       	ld	r31, Z
    daf0:	e0 2d       	mov	r30, r0
    daf2:	8d 91       	ld	r24, X+
    daf4:	9c 91       	ld	r25, X
    daf6:	62 e0       	ldi	r22, 0x02	; 2
    daf8:	ae 01       	movw	r20, r28
    dafa:	4f 5f       	subi	r20, 0xFF	; 255
    dafc:	5f 4f       	sbci	r21, 0xFF	; 255
    dafe:	22 e0       	ldi	r18, 0x02	; 2
    db00:	8e 01       	movw	r16, r28
    db02:	0b 5f       	subi	r16, 0xFB	; 251
    db04:	1f 4f       	sbci	r17, 0xFF	; 255
    db06:	09 95       	icall

        *data2 = ((PMDuint32)buffer[2])<<16 | ((PMDuint32)buffer[3]);
    db08:	2d 81       	ldd	r18, Y+5	; 0x05
    db0a:	3e 81       	ldd	r19, Y+6	; 0x06
    db0c:	40 e0       	ldi	r20, 0x00	; 0
    db0e:	50 e0       	ldi	r21, 0x00	; 0
    db10:	a9 01       	movw	r20, r18
    db12:	33 27       	eor	r19, r19
    db14:	22 27       	eor	r18, r18
    db16:	ef 80       	ldd	r14, Y+7	; 0x07
    db18:	f8 84       	ldd	r15, Y+8	; 0x08
    db1a:	00 e0       	ldi	r16, 0x00	; 0
    db1c:	10 e0       	ldi	r17, 0x00	; 0
    db1e:	2e 29       	or	r18, r14
    db20:	3f 29       	or	r19, r15
    db22:	40 2b       	or	r20, r16
    db24:	51 2b       	or	r21, r17
    db26:	f6 01       	movw	r30, r12
    db28:	20 83       	st	Z, r18
    db2a:	31 83       	std	Z+1, r19	; 0x01
    db2c:	42 83       	std	Z+2, r20	; 0x02
    db2e:	53 83       	std	Z+3, r21	; 0x03

        return result;
}
    db30:	28 96       	adiw	r28, 0x08	; 8
    db32:	0f b6       	in	r0, 0x3f	; 63
    db34:	f8 94       	cli
    db36:	de bf       	out	0x3e, r29	; 62
    db38:	0f be       	out	0x3f, r0	; 63
    db3a:	cd bf       	out	0x3d, r28	; 61
    db3c:	cf 91       	pop	r28
    db3e:	df 91       	pop	r29
    db40:	1f 91       	pop	r17
    db42:	0f 91       	pop	r16
    db44:	ff 90       	pop	r15
    db46:	ef 90       	pop	r14
    db48:	df 90       	pop	r13
    db4a:	cf 90       	pop	r12
    db4c:	08 95       	ret

0000db4e <uart_init>:
{
#if F_CPU < 2000000UL && defined(U2X)
  UCSRA = _BV(U2X);             /* improve baud rate error by using 2x clk */
  UBRRL = (F_CPU / (8UL * UART_BAUD)) - 1;
#else
  UBRRL = (F_CPU / (16UL * UART_BAUD)) - 1;
    db4e:	83 e3       	ldi	r24, 0x33	; 51
    db50:	80 93 d4 00 	sts	0x00D4, r24
#endif
  UCSRB = _BV(TXEN) | _BV(RXEN); /* tx/rx enable */
    db54:	88 e1       	ldi	r24, 0x18	; 24
    db56:	80 93 d1 00 	sts	0x00D1, r24
}
    db5a:	08 95       	ret

0000db5c <uart_putchar>:
 * Send character c down the UART Tx, wait until tx holding register
 * is empty.
 */
int
uart_putchar(char c, FILE *stream)
{
    db5c:	1f 93       	push	r17
    db5e:	18 2f       	mov	r17, r24

  if (c == '\n')
    db60:	8a 30       	cpi	r24, 0x0A	; 10
    db62:	19 f4       	brne	.+6      	; 0xdb6a <uart_putchar+0xe>
    uart_putchar('\r', stream);
    db64:	8d e0       	ldi	r24, 0x0D	; 13
    db66:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
  loop_until_bit_is_set(UCSRA, UDRE);
    db6a:	80 91 d0 00 	lds	r24, 0x00D0
    db6e:	85 ff       	sbrs	r24, 5
    db70:	fc cf       	rjmp	.-8      	; 0xdb6a <uart_putchar+0xe>
  UDR = c;
    db72:	10 93 d6 00 	sts	0x00D6, r17

  return 0;
}
    db76:	80 e0       	ldi	r24, 0x00	; 0
    db78:	90 e0       	ldi	r25, 0x00	; 0
    db7a:	1f 91       	pop	r17
    db7c:	08 95       	ret

0000db7e <uart_getchar>:
 * Successive calls to uart_getchar() will be satisfied from the
 * internal buffer until that buffer is emptied again.
 */
int
uart_getchar(FILE *stream)
{
    db7e:	ef 92       	push	r14
    db80:	ff 92       	push	r15
    db82:	0f 93       	push	r16
    db84:	1f 93       	push	r17
    db86:	cf 93       	push	r28
    db88:	df 93       	push	r29
    db8a:	7c 01       	movw	r14, r24
  uint8_t c;
  char *cp, *cp2;
  static char b[RX_BUFSIZE];
  static char *rxp;

  if (rxp == 0)
    db8c:	80 91 bb 7b 	lds	r24, 0x7BBB
    db90:	90 91 bc 7b 	lds	r25, 0x7BBC
    db94:	89 2b       	or	r24, r25
    db96:	09 f0       	breq	.+2      	; 0xdb9a <uart_getchar+0x1c>
    db98:	9f c0       	rjmp	.+318    	; 0xdcd8 <uart_getchar+0x15a>
    db9a:	0d eb       	ldi	r16, 0xBD	; 189
    db9c:	1b e7       	ldi	r17, 0x7B	; 123
    for (cp = b;;)
      {
	loop_until_bit_is_set(UCSRA, RXC);
    db9e:	80 91 d0 00 	lds	r24, 0x00D0
    dba2:	87 ff       	sbrs	r24, 7
    dba4:	fc cf       	rjmp	.-8      	; 0xdb9e <uart_getchar+0x20>
	if (UCSRA & _BV(FE))
    dba6:	80 91 d0 00 	lds	r24, 0x00D0
    dbaa:	84 ff       	sbrs	r24, 4
    dbac:	03 c0       	rjmp	.+6      	; 0xdbb4 <uart_getchar+0x36>
    dbae:	2e ef       	ldi	r18, 0xFE	; 254
    dbb0:	3f ef       	ldi	r19, 0xFF	; 255
    dbb2:	a6 c0       	rjmp	.+332    	; 0xdd00 <uart_getchar+0x182>
	  return _FDEV_EOF;
	if (UCSRA & _BV(DOR))
    dbb4:	80 91 d0 00 	lds	r24, 0x00D0
    dbb8:	83 fd       	sbrc	r24, 3
    dbba:	a0 c0       	rjmp	.+320    	; 0xdcfc <uart_getchar+0x17e>
	  return _FDEV_ERR;
	c = UDR;
    dbbc:	90 91 d6 00 	lds	r25, 0x00D6
	/* behaviour similar to Unix stty ICRNL */
	if (c == '\r')
    dbc0:	9d 30       	cpi	r25, 0x0D	; 13
    dbc2:	11 f0       	breq	.+4      	; 0xdbc8 <uart_getchar+0x4a>
	  c = '\n';
	if (c == '\n')
    dbc4:	9a 30       	cpi	r25, 0x0A	; 10
    dbc6:	69 f4       	brne	.+26     	; 0xdbe2 <uart_getchar+0x64>
	  {
	    *cp = c;
    dbc8:	8a e0       	ldi	r24, 0x0A	; 10
    dbca:	f8 01       	movw	r30, r16
    dbcc:	80 83       	st	Z, r24
	    uart_putchar(c, stream);
    dbce:	b7 01       	movw	r22, r14
    dbd0:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
	    rxp = b;
    dbd4:	8d eb       	ldi	r24, 0xBD	; 189
    dbd6:	9b e7       	ldi	r25, 0x7B	; 123
    dbd8:	90 93 bc 7b 	sts	0x7BBC, r25
    dbdc:	80 93 bb 7b 	sts	0x7BBB, r24
    dbe0:	7b c0       	rjmp	.+246    	; 0xdcd8 <uart_getchar+0x15a>
	    break;
	  }
	else if (c == '\t')
    dbe2:	99 30       	cpi	r25, 0x09	; 9
    dbe4:	09 f4       	brne	.+2      	; 0xdbe8 <uart_getchar+0x6a>
    dbe6:	90 e2       	ldi	r25, 0x20	; 32
	  c = ' ';

	if ((c >= (uint8_t)' ' && c <= (uint8_t)'\x7e') ||
    dbe8:	89 2f       	mov	r24, r25
    dbea:	80 52       	subi	r24, 0x20	; 32
    dbec:	8f 35       	cpi	r24, 0x5F	; 95
    dbee:	10 f0       	brcs	.+4      	; 0xdbf4 <uart_getchar+0x76>
    dbf0:	90 3a       	cpi	r25, 0xA0	; 160
    dbf2:	70 f0       	brcs	.+28     	; 0xdc10 <uart_getchar+0x92>
	    c >= (uint8_t)'\xa0')
	  {
	    if (cp == b + RX_BUFSIZE - 1)
    dbf4:	fc e7       	ldi	r31, 0x7C	; 124
    dbf6:	0c 30       	cpi	r16, 0x0C	; 12
    dbf8:	1f 07       	cpc	r17, r31
    dbfa:	11 f4       	brne	.+4      	; 0xdc00 <uart_getchar+0x82>
	      uart_putchar('\a', stream);
    dbfc:	87 e0       	ldi	r24, 0x07	; 7
    dbfe:	04 c0       	rjmp	.+8      	; 0xdc08 <uart_getchar+0x8a>
	    else
	      {
		*cp++ = c;
    dc00:	f8 01       	movw	r30, r16
    dc02:	91 93       	st	Z+, r25
    dc04:	8f 01       	movw	r16, r30
		uart_putchar(c, stream);
    dc06:	89 2f       	mov	r24, r25
    dc08:	b7 01       	movw	r22, r14
    dc0a:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
    dc0e:	c7 cf       	rjmp	.-114    	; 0xdb9e <uart_getchar+0x20>
	      }
	    continue;
	  }

	switch (c)
    dc10:	92 31       	cpi	r25, 0x12	; 18
    dc12:	39 f1       	breq	.+78     	; 0xdc62 <uart_getchar+0xe4>
    dc14:	93 31       	cpi	r25, 0x13	; 19
    dc16:	38 f4       	brcc	.+14     	; 0xdc26 <uart_getchar+0xa8>
    dc18:	93 30       	cpi	r25, 0x03	; 3
    dc1a:	09 f4       	brne	.+2      	; 0xdc1e <uart_getchar+0xa0>
    dc1c:	6f c0       	rjmp	.+222    	; 0xdcfc <uart_getchar+0x17e>
    dc1e:	98 30       	cpi	r25, 0x08	; 8
    dc20:	09 f0       	breq	.+2      	; 0xdc24 <uart_getchar+0xa6>
    dc22:	bd cf       	rjmp	.-134    	; 0xdb9e <uart_getchar+0x20>
    dc24:	09 c0       	rjmp	.+18     	; 0xdc38 <uart_getchar+0xba>
    dc26:	97 31       	cpi	r25, 0x17	; 23
    dc28:	09 f4       	brne	.+2      	; 0xdc2c <uart_getchar+0xae>
    dc2a:	4b c0       	rjmp	.+150    	; 0xdcc2 <uart_getchar+0x144>
    dc2c:	9f 37       	cpi	r25, 0x7F	; 127
    dc2e:	21 f0       	breq	.+8      	; 0xdc38 <uart_getchar+0xba>
    dc30:	95 31       	cpi	r25, 0x15	; 21
    dc32:	09 f0       	breq	.+2      	; 0xdc36 <uart_getchar+0xb8>
    dc34:	b4 cf       	rjmp	.-152    	; 0xdb9e <uart_getchar+0x20>
    dc36:	32 c0       	rjmp	.+100    	; 0xdc9c <uart_getchar+0x11e>
	  case 'c' & 0x1f:
	    return -1;

	  case '\b':
	  case '\x7f':
	    if (cp > b)
    dc38:	fb e7       	ldi	r31, 0x7B	; 123
    dc3a:	0d 3b       	cpi	r16, 0xBD	; 189
    dc3c:	1f 07       	cpc	r17, r31
    dc3e:	09 f0       	breq	.+2      	; 0xdc42 <uart_getchar+0xc4>
    dc40:	08 f4       	brcc	.+2      	; 0xdc44 <uart_getchar+0xc6>
    dc42:	ad cf       	rjmp	.-166    	; 0xdb9e <uart_getchar+0x20>
	      {
		uart_putchar('\b', stream);
    dc44:	88 e0       	ldi	r24, 0x08	; 8
    dc46:	b7 01       	movw	r22, r14
    dc48:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
		uart_putchar(' ', stream);
    dc4c:	80 e2       	ldi	r24, 0x20	; 32
    dc4e:	b7 01       	movw	r22, r14
    dc50:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
		uart_putchar('\b', stream);
    dc54:	88 e0       	ldi	r24, 0x08	; 8
    dc56:	b7 01       	movw	r22, r14
    dc58:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
		cp--;
    dc5c:	01 50       	subi	r16, 0x01	; 1
    dc5e:	10 40       	sbci	r17, 0x00	; 0
    dc60:	9e cf       	rjmp	.-196    	; 0xdb9e <uart_getchar+0x20>
	      }
	    break;

	  case 'r' & 0x1f:
	    uart_putchar('\r', stream);
    dc62:	8d e0       	ldi	r24, 0x0D	; 13
    dc64:	b7 01       	movw	r22, r14
    dc66:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
    dc6a:	cd eb       	ldi	r28, 0xBD	; 189
    dc6c:	db e7       	ldi	r29, 0x7B	; 123
    dc6e:	04 c0       	rjmp	.+8      	; 0xdc78 <uart_getchar+0xfa>
	    for (cp2 = b; cp2 < cp; cp2++)
	      uart_putchar(*cp2, stream);
    dc70:	89 91       	ld	r24, Y+
    dc72:	b7 01       	movw	r22, r14
    dc74:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
	      }
	    break;

	  case 'r' & 0x1f:
	    uart_putchar('\r', stream);
	    for (cp2 = b; cp2 < cp; cp2++)
    dc78:	c0 17       	cp	r28, r16
    dc7a:	d1 07       	cpc	r29, r17
    dc7c:	c8 f3       	brcs	.-14     	; 0xdc70 <uart_getchar+0xf2>
    dc7e:	8f cf       	rjmp	.-226    	; 0xdb9e <uart_getchar+0x20>
	    break;

	  case 'u' & 0x1f:
	    while (cp > b)
	      {
		uart_putchar('\b', stream);
    dc80:	88 e0       	ldi	r24, 0x08	; 8
    dc82:	b7 01       	movw	r22, r14
    dc84:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
		uart_putchar(' ', stream);
    dc88:	80 e2       	ldi	r24, 0x20	; 32
    dc8a:	b7 01       	movw	r22, r14
    dc8c:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
		uart_putchar('\b', stream);
    dc90:	88 e0       	ldi	r24, 0x08	; 8
    dc92:	b7 01       	movw	r22, r14
    dc94:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
		cp--;
    dc98:	01 50       	subi	r16, 0x01	; 1
    dc9a:	10 40       	sbci	r17, 0x00	; 0
	    for (cp2 = b; cp2 < cp; cp2++)
	      uart_putchar(*cp2, stream);
	    break;

	  case 'u' & 0x1f:
	    while (cp > b)
    dc9c:	8b e7       	ldi	r24, 0x7B	; 123
    dc9e:	0d 3b       	cpi	r16, 0xBD	; 189
    dca0:	18 07       	cpc	r17, r24
    dca2:	09 f0       	breq	.+2      	; 0xdca6 <uart_getchar+0x128>
    dca4:	68 f7       	brcc	.-38     	; 0xdc80 <uart_getchar+0x102>
    dca6:	7b cf       	rjmp	.-266    	; 0xdb9e <uart_getchar+0x20>
	    break;

	  case 'w' & 0x1f:
	    while (cp > b && cp[-1] != ' ')
	      {
		uart_putchar('\b', stream);
    dca8:	88 e0       	ldi	r24, 0x08	; 8
    dcaa:	b7 01       	movw	r22, r14
    dcac:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
		uart_putchar(' ', stream);
    dcb0:	80 e2       	ldi	r24, 0x20	; 32
    dcb2:	b7 01       	movw	r22, r14
    dcb4:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
		uart_putchar('\b', stream);
    dcb8:	88 e0       	ldi	r24, 0x08	; 8
    dcba:	b7 01       	movw	r22, r14
    dcbc:	0e 94 ae 6d 	call	0xdb5c	; 0xdb5c <uart_putchar>
    dcc0:	8e 01       	movw	r16, r28
		cp--;
	      }
	    break;

	  case 'w' & 0x1f:
	    while (cp > b && cp[-1] != ' ')
    dcc2:	eb e7       	ldi	r30, 0x7B	; 123
    dcc4:	0d 3b       	cpi	r16, 0xBD	; 189
    dcc6:	1e 07       	cpc	r17, r30
    dcc8:	09 f0       	breq	.+2      	; 0xdccc <uart_getchar+0x14e>
    dcca:	08 f4       	brcc	.+2      	; 0xdcce <uart_getchar+0x150>
    dccc:	68 cf       	rjmp	.-304    	; 0xdb9e <uart_getchar+0x20>
    dcce:	e8 01       	movw	r28, r16
    dcd0:	8a 91       	ld	r24, -Y
    dcd2:	80 32       	cpi	r24, 0x20	; 32
    dcd4:	49 f7       	brne	.-46     	; 0xdca8 <uart_getchar+0x12a>
    dcd6:	63 cf       	rjmp	.-314    	; 0xdb9e <uart_getchar+0x20>
	      }
	    break;
	  }
      }

  c = *rxp++;
    dcd8:	e0 91 bb 7b 	lds	r30, 0x7BBB
    dcdc:	f0 91 bc 7b 	lds	r31, 0x7BBC
    dce0:	81 91       	ld	r24, Z+
    dce2:	f0 93 bc 7b 	sts	0x7BBC, r31
    dce6:	e0 93 bb 7b 	sts	0x7BBB, r30
  if (c == '\n')
    dcea:	8a 30       	cpi	r24, 0x0A	; 10
    dcec:	21 f4       	brne	.+8      	; 0xdcf6 <uart_getchar+0x178>
    rxp = 0;
    dcee:	10 92 bc 7b 	sts	0x7BBC, r1
    dcf2:	10 92 bb 7b 	sts	0x7BBB, r1

  return c;
    dcf6:	28 2f       	mov	r18, r24
    dcf8:	30 e0       	ldi	r19, 0x00	; 0
    dcfa:	02 c0       	rjmp	.+4      	; 0xdd00 <uart_getchar+0x182>
    dcfc:	2f ef       	ldi	r18, 0xFF	; 255
    dcfe:	3f ef       	ldi	r19, 0xFF	; 255
}
    dd00:	c9 01       	movw	r24, r18
    dd02:	df 91       	pop	r29
    dd04:	cf 91       	pop	r28
    dd06:	1f 91       	pop	r17
    dd08:	0f 91       	pop	r16
    dd0a:	ff 90       	pop	r15
    dd0c:	ef 90       	pop	r14
    dd0e:	08 95       	ret

0000dd10 <hd44780_outnibble>:
/*
 * Send one nibble out to the LCD controller.
 */
static void
hd44780_outnibble(uint8_t n, uint8_t rs)
{
    dd10:	98 2f       	mov	r25, r24
	uint8_t x;

	HD44780_PORTOUT &= ~_BV(HD44780_RW);
    dd12:	2c 98       	cbi	0x05, 4	; 5
	if (rs)
    dd14:	66 23       	and	r22, r22
    dd16:	11 f0       	breq	.+4      	; 0xdd1c <hd44780_outnibble+0xc>
		HD44780_PORTOUT |= _BV(HD44780_RS);
    dd18:	2e 9a       	sbi	0x05, 6	; 5
    dd1a:	01 c0       	rjmp	.+2      	; 0xdd1e <hd44780_outnibble+0xe>
	else
		HD44780_PORTOUT &= ~_BV(HD44780_RS);
    dd1c:	2e 98       	cbi	0x05, 6	; 5
  
	x = (HD44780_PORTOUT & ~HD44780_DATABITS) | ((n << HD44780_D4) & HD44780_DATABITS);
    dd1e:	85 b1       	in	r24, 0x05	; 5
    dd20:	9f 70       	andi	r25, 0x0F	; 15
    dd22:	80 7f       	andi	r24, 0xF0	; 240
    dd24:	89 2b       	or	r24, r25
	HD44780_PORTOUT = x;
    dd26:	85 b9       	out	0x05, r24	; 5
static inline uint8_t
hd44780_pulse_e(bool readback)
{
	uint8_t x;

	HD44780_PORTOUT |= _BV(HD44780_E);
    dd28:	2d 9a       	sbi	0x05, 5	; 5
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    dd2a:	81 e0       	ldi	r24, 0x01	; 1
    dd2c:	8a 95       	dec	r24
    dd2e:	f1 f7       	brne	.-4      	; 0xdd2c <hd44780_outnibble+0x1c>
	#endif
	if (readback)
		x = HD44780_PORTIN & HD44780_DATABITS;
	else
		x = 0;
	HD44780_PORTOUT &= ~_BV(HD44780_E);
    dd30:	2d 98       	cbi	0x05, 5	; 5
		HD44780_PORTOUT &= ~_BV(HD44780_RS);
  
	x = (HD44780_PORTOUT & ~HD44780_DATABITS) | ((n << HD44780_D4) & HD44780_DATABITS);
	HD44780_PORTOUT = x;
	(void)hd44780_pulse_e(false);
}
    dd32:	08 95       	ret

0000dd34 <hd44780_outbyte>:
/*
 * Send one byte to the LCD controller.  As we are in 4-bit mode, we
 * have to send two nibbles.
 */
void hd44780_outbyte(uint8_t b, uint8_t rs)
{
    dd34:	0f 93       	push	r16
    dd36:	1f 93       	push	r17
    dd38:	18 2f       	mov	r17, r24
    dd3a:	06 2f       	mov	r16, r22
	hd44780_outnibble(b >> 4, rs);
    dd3c:	82 95       	swap	r24
    dd3e:	8f 70       	andi	r24, 0x0F	; 15
    dd40:	0e 94 88 6e 	call	0xdd10	; 0xdd10 <hd44780_outnibble>
	hd44780_outnibble(b & 0xf, rs);
    dd44:	81 2f       	mov	r24, r17
    dd46:	8f 70       	andi	r24, 0x0F	; 15
    dd48:	60 2f       	mov	r22, r16
    dd4a:	0e 94 88 6e 	call	0xdd10	; 0xdd10 <hd44780_outnibble>
}
    dd4e:	1f 91       	pop	r17
    dd50:	0f 91       	pop	r16
    dd52:	08 95       	ret

0000dd54 <hd44780_innibble>:
 */
static uint8_t hd44780_innibble(uint8_t rs)
{
	uint8_t x;

	HD44780_PORTOUT |= _BV(HD44780_RW);
    dd54:	2c 9a       	sbi	0x05, 4	; 5
	HD44780_DDR &= ~HD44780_DATABITS;
    dd56:	94 b1       	in	r25, 0x04	; 4
    dd58:	90 7f       	andi	r25, 0xF0	; 240
    dd5a:	94 b9       	out	0x04, r25	; 4
	if (rs)
    dd5c:	88 23       	and	r24, r24
    dd5e:	11 f0       	breq	.+4      	; 0xdd64 <hd44780_innibble+0x10>
		HD44780_PORTOUT |= _BV(HD44780_RS);
    dd60:	2e 9a       	sbi	0x05, 6	; 5
    dd62:	01 c0       	rjmp	.+2      	; 0xdd66 <hd44780_innibble+0x12>
	else
		HD44780_PORTOUT &= ~_BV(HD44780_RS);
    dd64:	2e 98       	cbi	0x05, 6	; 5
static inline uint8_t
hd44780_pulse_e(bool readback)
{
	uint8_t x;

	HD44780_PORTOUT |= _BV(HD44780_E);
    dd66:	2d 9a       	sbi	0x05, 5	; 5
    dd68:	81 e0       	ldi	r24, 0x01	; 1
    dd6a:	8a 95       	dec	r24
    dd6c:	f1 f7       	brne	.-4      	; 0xdd6a <hd44780_innibble+0x16>
					__asm__ volatile("nop");
				#    endif /* F_CPU > 2000000UL */
			#  endif /* F_CPU > 1000000UL */
	#endif
	if (readback)
		x = HD44780_PORTIN & HD44780_DATABITS;
    dd6e:	83 b1       	in	r24, 0x03	; 3
	else
		x = 0;
	HD44780_PORTOUT &= ~_BV(HD44780_E);
    dd70:	2d 98       	cbi	0x05, 5	; 5
		HD44780_PORTOUT |= _BV(HD44780_RS);
	else
		HD44780_PORTOUT &= ~_BV(HD44780_RS);
  
	x = hd44780_pulse_e(true);
	HD44780_DDR |= HD44780_DATABITS;
    dd72:	94 b1       	in	r25, 0x04	; 4
    dd74:	9f 60       	ori	r25, 0x0F	; 15
    dd76:	94 b9       	out	0x04, r25	; 4
	HD44780_PORTOUT &= ~_BV(HD44780_RW);
    dd78:	2c 98       	cbi	0x05, 4	; 5

	return (x & HD44780_DATABITS) >> HD44780_D4;
}
    dd7a:	8f 70       	andi	r24, 0x0F	; 15
    dd7c:	08 95       	ret

0000dd7e <hd44780_inbyte>:
/*
 * Read one byte (i.e. two nibbles) from the LCD controller.
 */
uint8_t
hd44780_inbyte(uint8_t rs)
{
    dd7e:	0f 93       	push	r16
    dd80:	1f 93       	push	r17
    dd82:	18 2f       	mov	r17, r24
  uint8_t x;

  x = hd44780_innibble(rs) << 4;
    dd84:	0e 94 aa 6e 	call	0xdd54	; 0xdd54 <hd44780_innibble>
    dd88:	08 2f       	mov	r16, r24
    dd8a:	02 95       	swap	r16
    dd8c:	00 7f       	andi	r16, 0xF0	; 240
  x |= hd44780_innibble(rs);
    dd8e:	81 2f       	mov	r24, r17
    dd90:	0e 94 aa 6e 	call	0xdd54	; 0xdd54 <hd44780_innibble>

  return x;
}
    dd94:	80 2b       	or	r24, r16
    dd96:	1f 91       	pop	r17
    dd98:	0f 91       	pop	r16
    dd9a:	08 95       	ret

0000dd9c <hd44780_wait_ready>:
 * Wait until the busy flag is cleared.
 */
void
hd44780_wait_ready(void)
{
  while (hd44780_incmd() & HD44780_BUSYFLAG) ;
    dd9c:	80 e0       	ldi	r24, 0x00	; 0
    dd9e:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <hd44780_inbyte>
    dda2:	87 fd       	sbrc	r24, 7
    dda4:	fb cf       	rjmp	.-10     	; 0xdd9c <hd44780_wait_ready>
}
    dda6:	08 95       	ret

0000dda8 <hd44780_init>:
 */
void
hd44780_init(void)
{

	HD44780_DDR = _BV(HD44780_RS) | _BV(HD44780_RW) | _BV(HD44780_E) | HD44780_DATABITS;
    dda8:	8f e7       	ldi	r24, 0x7F	; 127
    ddaa:	84 b9       	out	0x04, r24	; 4
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    ddac:	80 e3       	ldi	r24, 0x30	; 48
    ddae:	95 e7       	ldi	r25, 0x75	; 117
    ddb0:	01 97       	sbiw	r24, 0x01	; 1
    ddb2:	f1 f7       	brne	.-4      	; 0xddb0 <hd44780_init+0x8>
	_delay_ms(15);		/* 40 ms needed for Vcc = 2.7 V */
	hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
    ddb4:	83 e0       	ldi	r24, 0x03	; 3
    ddb6:	60 e0       	ldi	r22, 0x00	; 0
    ddb8:	0e 94 88 6e 	call	0xdd10	; 0xdd10 <hd44780_outnibble>
    ddbc:	88 e0       	ldi	r24, 0x08	; 8
    ddbe:	90 e2       	ldi	r25, 0x20	; 32
    ddc0:	01 97       	sbiw	r24, 0x01	; 1
    ddc2:	f1 f7       	brne	.-4      	; 0xddc0 <hd44780_init+0x18>
	_delay_ms(4.1);
	hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
    ddc4:	83 e0       	ldi	r24, 0x03	; 3
    ddc6:	60 e0       	ldi	r22, 0x00	; 0
    ddc8:	0e 94 88 6e 	call	0xdd10	; 0xdd10 <hd44780_outnibble>
    ddcc:	88 ec       	ldi	r24, 0xC8	; 200
    ddce:	90 e0       	ldi	r25, 0x00	; 0
    ddd0:	01 97       	sbiw	r24, 0x01	; 1
    ddd2:	f1 f7       	brne	.-4      	; 0xddd0 <hd44780_init+0x28>
	_delay_ms(0.1);
	hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
    ddd4:	83 e0       	ldi	r24, 0x03	; 3
    ddd6:	60 e0       	ldi	r22, 0x00	; 0
    ddd8:	0e 94 88 6e 	call	0xdd10	; 0xdd10 <hd44780_outnibble>

	hd44780_outnibble(HD44780_FNSET(0, 1, 0) >> 4, 0);
    dddc:	82 e0       	ldi	r24, 0x02	; 2
    ddde:	60 e0       	ldi	r22, 0x00	; 0
    dde0:	0e 94 88 6e 	call	0xdd10	; 0xdd10 <hd44780_outnibble>
	hd44780_wait_ready();
    dde4:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>
	hd44780_outcmd(HD44780_FNSET(0, 1, 0));
    dde8:	88 e2       	ldi	r24, 0x28	; 40
    ddea:	60 e0       	ldi	r22, 0x00	; 0
    ddec:	0e 94 9a 6e 	call	0xdd34	; 0xdd34 <hd44780_outbyte>
	hd44780_wait_ready();
    ddf0:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>
	hd44780_outcmd(HD44780_DISPCTL(0, 0, 0));
    ddf4:	88 e0       	ldi	r24, 0x08	; 8
    ddf6:	60 e0       	ldi	r22, 0x00	; 0
    ddf8:	0e 94 9a 6e 	call	0xdd34	; 0xdd34 <hd44780_outbyte>
	hd44780_wait_ready();
    ddfc:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>
}
    de00:	08 95       	ret

0000de02 <lcd_putchar>:
 */


int
lcd_putchar(char c, FILE *unused)
{
    de02:	1f 93       	push	r17
    de04:	18 2f       	mov	r17, r24
	static bool nl_seen;
	
	uint8 addr;

	if (nl_seen && c != '\n')
    de06:	80 91 0d 7c 	lds	r24, 0x7C0D
    de0a:	88 23       	and	r24, r24
    de0c:	b9 f0       	breq	.+46     	; 0xde3c <lcd_putchar+0x3a>
    de0e:	1a 30       	cpi	r17, 0x0A	; 10
    de10:	b9 f0       	breq	.+46     	; 0xde40 <lcd_putchar+0x3e>
	{
		
		// First character after newline, clear display and home cursor.
		
		hd44780_wait_ready();
    de12:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>
		hd44780_outcmd(HD44780_CLR);
    de16:	81 e0       	ldi	r24, 0x01	; 1
    de18:	60 e0       	ldi	r22, 0x00	; 0
    de1a:	0e 94 9a 6e 	call	0xdd34	; 0xdd34 <hd44780_outbyte>
		hd44780_wait_ready();
    de1e:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>
		hd44780_outcmd(HD44780_HOME);
    de22:	82 e0       	ldi	r24, 0x02	; 2
    de24:	60 e0       	ldi	r22, 0x00	; 0
    de26:	0e 94 9a 6e 	call	0xdd34	; 0xdd34 <hd44780_outbyte>
		hd44780_wait_ready();
    de2a:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>
		hd44780_outcmd(HD44780_DDADDR(0));
    de2e:	80 e8       	ldi	r24, 0x80	; 128
    de30:	60 e0       	ldi	r22, 0x00	; 0
    de32:	0e 94 9a 6e 	call	0xdd34	; 0xdd34 <hd44780_outbyte>
		
		nl_seen = false;
    de36:	10 92 0d 7c 	sts	0x7C0D, r1
    de3a:	06 c0       	rjmp	.+12     	; 0xde48 <lcd_putchar+0x46>
	}
	if (c == '\n')
    de3c:	1a 30       	cpi	r17, 0x0A	; 10
    de3e:	21 f4       	brne	.+8      	; 0xde48 <lcd_putchar+0x46>
    {
		nl_seen = true;
    de40:	81 e0       	ldi	r24, 0x01	; 1
    de42:	80 93 0d 7c 	sts	0x7C0D, r24
    de46:	23 c0       	rjmp	.+70     	; 0xde8e <lcd_putchar+0x8c>
    }
	else
    {
		
		hd44780_wait_ready();
    de48:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>
		/* Leo el Address Counter */
		addr = hd44780_incmd();
    de4c:	80 e0       	ldi	r24, 0x00	; 0
    de4e:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <hd44780_inbyte>
		/* Obtengo solo el Address counter */
		addr = addr & (0x7F);
    de52:	8f 77       	andi	r24, 0x7F	; 127
		
		/* Comparo si el address counter llego a la ultima columna de la primera linea del display*/
		if (addr == 0x0F)
    de54:	8f 30       	cpi	r24, 0x0F	; 15
    de56:	21 f4       	brne	.+8      	; 0xde60 <lcd_putchar+0x5e>
		{
			hd44780_wait_ready();
    de58:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>
			/* Envio el address counter a la primera columna de la segunda linea del display*/
			hd44780_outcmd(HD44780_DDADDR(0x40));
    de5c:	80 ec       	ldi	r24, 0xC0	; 192
    de5e:	05 c0       	rjmp	.+10     	; 0xde6a <lcd_putchar+0x68>
			
		}
		
		/* Comparo si el address counter llego a la ultima columna de la segunda linea del display*/
		if (addr == 0x4F)
    de60:	8f 34       	cpi	r24, 0x4F	; 79
    de62:	31 f4       	brne	.+12     	; 0xde70 <lcd_putchar+0x6e>
		{
			hd44780_wait_ready();
    de64:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>
			/* Limpio el display y posiciono el cursor en la primera columna de la primera linea. */
			hd44780_outcmd(HD44780_CLR);
    de68:	81 e0       	ldi	r24, 0x01	; 1
    de6a:	60 e0       	ldi	r22, 0x00	; 0
    de6c:	0e 94 9a 6e 	call	0xdd34	; 0xdd34 <hd44780_outbyte>
			
		}
		
		
		hd44780_wait_ready();
    de70:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>
		hd44780_outdata(c);
    de74:	81 2f       	mov	r24, r17
    de76:	61 e0       	ldi	r22, 0x01	; 1
    de78:	0e 94 9a 6e 	call	0xdd34	; 0xdd34 <hd44780_outbyte>
    de7c:	88 ee       	ldi	r24, 0xE8	; 232
    de7e:	93 e0       	ldi	r25, 0x03	; 3
    de80:	28 ec       	ldi	r18, 0xC8	; 200
    de82:	30 e0       	ldi	r19, 0x00	; 0
    de84:	f9 01       	movw	r30, r18
    de86:	31 97       	sbiw	r30, 0x01	; 1
    de88:	f1 f7       	brne	.-4      	; 0xde86 <lcd_putchar+0x84>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    de8a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    de8c:	d9 f7       	brne	.-10     	; 0xde84 <lcd_putchar+0x82>
		_delay_ms(100);
	}

	return 0;
}
    de8e:	80 e0       	ldi	r24, 0x00	; 0
    de90:	90 e0       	ldi	r25, 0x00	; 0
    de92:	1f 91       	pop	r17
    de94:	08 95       	ret

0000de96 <lcd_init>:
 */
void
lcd_init(void)
{

  hd44780_init();
    de96:	0e 94 d4 6e 	call	0xdda8	; 0xdda8 <hd44780_init>

  /*
   * Clear the display.
   */
  hd44780_outcmd(HD44780_CLR);
    de9a:	81 e0       	ldi	r24, 0x01	; 1
    de9c:	60 e0       	ldi	r22, 0x00	; 0
    de9e:	0e 94 9a 6e 	call	0xdd34	; 0xdd34 <hd44780_outbyte>
  hd44780_wait_ready();
    dea2:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>

  /*
   * Entry mode: auto-increment address counter, no display shift in
   * effect.
   */
  hd44780_outcmd(HD44780_ENTMODE(1, 0));
    dea6:	86 e0       	ldi	r24, 0x06	; 6
    dea8:	60 e0       	ldi	r22, 0x00	; 0
    deaa:	0e 94 9a 6e 	call	0xdd34	; 0xdd34 <hd44780_outbyte>
  hd44780_wait_ready();
    deae:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>

  /*
   * Enable display, activate non-blinking cursor.
   */
  hd44780_outcmd(HD44780_DISPCTL(1, 1, 0));
    deb2:	8e e0       	ldi	r24, 0x0E	; 14
    deb4:	60 e0       	ldi	r22, 0x00	; 0
    deb6:	0e 94 9a 6e 	call	0xdd34	; 0xdd34 <hd44780_outbyte>
  hd44780_wait_ready();
    deba:	0e 94 ce 6e 	call	0xdd9c	; 0xdd9c <hd44780_wait_ready>
}
    debe:	08 95       	ret

0000dec0 <TWI_init>:
{

  /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
#if defined(TWPS0)
  /* has prescaler (mega128 & newer) */
  TWSR = 0;
    dec0:	10 92 b9 00 	sts	0x00B9, r1
#endif

#if F_CPU < 3600000UL
  TWBR = 10;			/* smallest TWBR value*/
#else
  TWBR = (F_CPU / 400000UL - 16) / 2;
    dec4:	82 e0       	ldi	r24, 0x02	; 2
    dec6:	80 93 b8 00 	sts	0x00B8, r24
#endif
}
    deca:	08 95       	ret

0000decc <read_bytes_I2C>:

/*****************************************************************************************************/
int16 read_bytes_I2C(uint8 sla, uint32 eeaddr, int16 len, uint8 *buf)
{
    decc:	0f 93       	push	r16
    dece:	1f 93       	push	r17
    ded0:	cf 93       	push	r28
    ded2:	df 93       	push	r29
    ded4:	f8 2f       	mov	r31, r24
    ded6:	e8 01       	movw	r28, r16
				goto error;								/* must send stop condition */
		}
		
		
		#ifdef TWI_ADDRH
			TWDR =(uint8)((eeaddr>>8)&0xFF);			/* high 8 bits of addr if define TWI_ADDRH*/
    ded8:	bb 27       	eor	r27, r27
    deda:	a7 2f       	mov	r26, r23
    dedc:	96 2f       	mov	r25, r22
    dede:	85 2f       	mov	r24, r21
    dee0:	98 2f       	mov	r25, r24
		if (n++ >= MAX_ITER)
			return -1;
	begin:
		
		/* send start condition TWCR = Registro que controla el TWI*/
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); 
    dee2:	a4 ea       	ldi	r26, 0xA4	; 164
		}	
		
		
		/**< send SLA+W */
		TWDR = sla | TW_WRITE; 							/* LO coloca para lectura*/
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
    dee4:	e4 e8       	ldi	r30, 0x84	; 132
			default:
				goto error;
		}
		
		/* send SLA+R */
		TWDR = sla | TW_READ;
    dee6:	1f 2f       	mov	r17, r31
    dee8:	11 60       	ori	r17, 0x01	; 1
		if (n++ >= MAX_ITER)
			return -1;
	begin:
		
		/* send start condition TWCR = Registro que controla el TWI*/
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); 
    deea:	a0 93 bc 00 	sts	0x00BC, r26
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
    deee:	80 91 bc 00 	lds	r24, 0x00BC
    def2:	87 ff       	sbrs	r24, 7
    def4:	fc cf       	rjmp	.-8      	; 0xdeee <read_bytes_I2C+0x22>
		switch ((twst = TW_STATUS))
    def6:	80 91 b9 00 	lds	r24, 0x00B9
    defa:	88 7f       	andi	r24, 0xF8	; 248
    defc:	80 31       	cpi	r24, 0x10	; 16
    defe:	49 f0       	breq	.+18     	; 0xdf12 <read_bytes_I2C+0x46>
    df00:	88 33       	cpi	r24, 0x38	; 56
    df02:	99 f3       	breq	.-26     	; 0xdeea <read_bytes_I2C+0x1e>
    df04:	88 30       	cpi	r24, 0x08	; 8
    df06:	29 f0       	breq	.+10     	; 0xdf12 <read_bytes_I2C+0x46>
    df08:	80 93 1c 82 	sts	0x821C, r24
    df0c:	4f ef       	ldi	r20, 0xFF	; 255
    df0e:	5f ef       	ldi	r21, 0xFF	; 255
    df10:	8a c0       	rjmp	.+276    	; 0xe026 <read_bytes_I2C+0x15a>
														/* NB: do /not/ send stop condition */
		}	
		
		
		/**< send SLA+W */
		TWDR = sla | TW_WRITE; 							/* LO coloca para lectura*/
    df12:	f0 93 bb 00 	sts	0x00BB, r31
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
    df16:	e0 93 bc 00 	sts	0x00BC, r30
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
    df1a:	80 91 bc 00 	lds	r24, 0x00BC
    df1e:	87 ff       	sbrs	r24, 7
    df20:	fc cf       	rjmp	.-8      	; 0xdf1a <read_bytes_I2C+0x4e>
		switch ((twst = TW_STATUS))
    df22:	80 91 b9 00 	lds	r24, 0x00B9
    df26:	88 7f       	andi	r24, 0xF8	; 248
    df28:	80 32       	cpi	r24, 0x20	; 32
    df2a:	f9 f2       	breq	.-66     	; 0xdeea <read_bytes_I2C+0x1e>
    df2c:	88 33       	cpi	r24, 0x38	; 56
    df2e:	e9 f2       	breq	.-70     	; 0xdeea <read_bytes_I2C+0x1e>
    df30:	88 31       	cpi	r24, 0x18	; 24
    df32:	09 f0       	breq	.+2      	; 0xdf36 <read_bytes_I2C+0x6a>
    df34:	4a c0       	rjmp	.+148    	; 0xdfca <read_bytes_I2C+0xfe>
				goto error;								/* must send stop condition */
		}
		
		
		#ifdef TWI_ADDRH
			TWDR =(uint8)((eeaddr>>8)&0xFF);			/* high 8 bits of addr if define TWI_ADDRH*/
    df36:	90 93 bb 00 	sts	0x00BB, r25
			TWCR = _BV(TWINT) | _BV(TWEN); 			/* clear interrupt to start transmission */
    df3a:	e0 93 bc 00 	sts	0x00BC, r30
			while ((TWCR & _BV(TWINT)) == 0) ; 		/* wait for transmission */
    df3e:	80 91 bc 00 	lds	r24, 0x00BC
    df42:	87 ff       	sbrs	r24, 7
    df44:	fc cf       	rjmp	.-8      	; 0xdf3e <read_bytes_I2C+0x72>
			switch ((twst = TW_STATUS))
    df46:	80 91 b9 00 	lds	r24, 0x00B9
    df4a:	88 7f       	andi	r24, 0xF8	; 248
    df4c:	80 33       	cpi	r24, 0x30	; 48
    df4e:	c1 f1       	breq	.+112    	; 0xdfc0 <read_bytes_I2C+0xf4>
    df50:	88 33       	cpi	r24, 0x38	; 56
    df52:	59 f2       	breq	.-106    	; 0xdeea <read_bytes_I2C+0x1e>
    df54:	88 32       	cpi	r24, 0x28	; 40
    df56:	c9 f5       	brne	.+114    	; 0xdfca <read_bytes_I2C+0xfe>
			}			
		#endif
		
		
     
		TWDR = (uint8)(eeaddr&0xFF);      				/* low 8 bits of addr */
    df58:	40 93 bb 00 	sts	0x00BB, r20
		TWCR = _BV(TWINT) | _BV(TWEN);     			/* clear interrupt to start transmission */
    df5c:	e0 93 bc 00 	sts	0x00BC, r30
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
    df60:	80 91 bc 00 	lds	r24, 0x00BC
    df64:	87 ff       	sbrs	r24, 7
    df66:	fc cf       	rjmp	.-8      	; 0xdf60 <read_bytes_I2C+0x94>
		switch ((twst = TW_STATUS))
    df68:	80 91 b9 00 	lds	r24, 0x00B9
    df6c:	88 7f       	andi	r24, 0xF8	; 248
    df6e:	80 33       	cpi	r24, 0x30	; 48
    df70:	39 f1       	breq	.+78     	; 0xdfc0 <read_bytes_I2C+0xf4>
    df72:	88 33       	cpi	r24, 0x38	; 56
    df74:	09 f4       	brne	.+2      	; 0xdf78 <read_bytes_I2C+0xac>
    df76:	b9 cf       	rjmp	.-142    	; 0xdeea <read_bytes_I2C+0x1e>
    df78:	88 32       	cpi	r24, 0x28	; 40
    df7a:	39 f5       	brne	.+78     	; 0xdfca <read_bytes_I2C+0xfe>
		}
		
		
		/* 2. Next cycle(s): master receiver mode*/
		
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); 	/* send (rep.) start condition */
    df7c:	a0 93 bc 00 	sts	0x00BC, r26
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
    df80:	80 91 bc 00 	lds	r24, 0x00BC
    df84:	87 ff       	sbrs	r24, 7
    df86:	fc cf       	rjmp	.-8      	; 0xdf80 <read_bytes_I2C+0xb4>
		switch ((twst = TW_STATUS))
    df88:	80 91 b9 00 	lds	r24, 0x00B9
    df8c:	88 7f       	andi	r24, 0xF8	; 248
    df8e:	80 31       	cpi	r24, 0x10	; 16
    df90:	29 f0       	breq	.+10     	; 0xdf9c <read_bytes_I2C+0xd0>
    df92:	88 33       	cpi	r24, 0x38	; 56
    df94:	09 f4       	brne	.+2      	; 0xdf98 <read_bytes_I2C+0xcc>
    df96:	a9 cf       	rjmp	.-174    	; 0xdeea <read_bytes_I2C+0x1e>
    df98:	88 30       	cpi	r24, 0x08	; 8
    df9a:	b9 f4       	brne	.+46     	; 0xdfca <read_bytes_I2C+0xfe>
			default:
				goto error;
		}
		
		/* send SLA+R */
		TWDR = sla | TW_READ;
    df9c:	10 93 bb 00 	sts	0x00BB, r17
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
    dfa0:	e0 93 bc 00 	sts	0x00BC, r30
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
    dfa4:	80 91 bc 00 	lds	r24, 0x00BC
    dfa8:	87 ff       	sbrs	r24, 7
    dfaa:	fc cf       	rjmp	.-8      	; 0xdfa4 <read_bytes_I2C+0xd8>
		switch ((twst = TW_STATUS))
    dfac:	80 91 b9 00 	lds	r24, 0x00B9
    dfb0:	88 7f       	andi	r24, 0xF8	; 248
    dfb2:	80 34       	cpi	r24, 0x40	; 64
    dfb4:	69 f0       	breq	.+26     	; 0xdfd0 <read_bytes_I2C+0x104>
    dfb6:	88 34       	cpi	r24, 0x48	; 72
    dfb8:	19 f0       	breq	.+6      	; 0xdfc0 <read_bytes_I2C+0xf4>
    dfba:	88 33       	cpi	r24, 0x38	; 56
    dfbc:	31 f4       	brne	.+12     	; 0xdfca <read_bytes_I2C+0xfe>
    dfbe:	95 cf       	rjmp	.-214    	; 0xdeea <read_bytes_I2C+0x1e>
    dfc0:	80 93 1c 82 	sts	0x821C, r24
    dfc4:	40 e0       	ldi	r20, 0x00	; 0
    dfc6:	50 e0       	ldi	r21, 0x00	; 0
    dfc8:	2b c0       	rjmp	.+86     	; 0xe020 <read_bytes_I2C+0x154>
    dfca:	80 93 1c 82 	sts	0x821C, r24
    dfce:	19 c0       	rjmp	.+50     	; 0xe002 <read_bytes_I2C+0x136>
    dfd0:	80 93 1c 82 	sts	0x821C, r24
    dfd4:	94 ec       	ldi	r25, 0xC4	; 196
    dfd6:	40 e0       	ldi	r20, 0x00	; 0
    dfd8:	50 e0       	ldi	r21, 0x00	; 0
    dfda:	1f c0       	rjmp	.+62     	; 0xe01a <read_bytes_I2C+0x14e>
				goto error;
		}		
		
		for (twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);len > 0;len--)
		{
			if (len == 1)
    dfdc:	21 30       	cpi	r18, 0x01	; 1
    dfde:	31 05       	cpc	r19, r1
    dfe0:	09 f4       	brne	.+2      	; 0xdfe4 <read_bytes_I2C+0x118>
    dfe2:	94 e8       	ldi	r25, 0x84	; 132
				twcr = _BV(TWINT) | _BV(TWEN); 		/* send NAK this time */
			
			TWCR = twcr;								/* clear int to start transmission */
    dfe4:	90 93 bc 00 	sts	0x00BC, r25
			while ((TWCR & _BV(TWINT)) == 0) ; 		/* wait for transmission */
    dfe8:	80 91 bc 00 	lds	r24, 0x00BC
    dfec:	87 ff       	sbrs	r24, 7
    dfee:	fc cf       	rjmp	.-8      	; 0xdfe8 <read_bytes_I2C+0x11c>
			switch ((twst = TW_STATUS))
    dff0:	80 91 b9 00 	lds	r24, 0x00B9
    dff4:	88 7f       	andi	r24, 0xF8	; 248
    dff6:	80 93 1c 82 	sts	0x821C, r24
    dffa:	80 35       	cpi	r24, 0x50	; 80
    dffc:	39 f0       	breq	.+14     	; 0xe00c <read_bytes_I2C+0x140>
    dffe:	88 35       	cpi	r24, 0x58	; 88
    e000:	19 f0       	breq	.+6      	; 0xe008 <read_bytes_I2C+0x13c>
    e002:	4f ef       	ldi	r20, 0xFF	; 255
    e004:	5f ef       	ldi	r21, 0xFF	; 255
    e006:	0c c0       	rjmp	.+24     	; 0xe020 <read_bytes_I2C+0x154>
    e008:	20 e0       	ldi	r18, 0x00	; 0
    e00a:	30 e0       	ldi	r19, 0x00	; 0
			{
				case TW_MR_DATA_NACK:
					len = 0;							/* force end of loop */
				/* FALLTHROUGH */
				case TW_MR_DATA_ACK:
					*buf++ = TWDR;
    e00c:	80 91 bb 00 	lds	r24, 0x00BB
    e010:	89 93       	st	Y+, r24
					rv++;
    e012:	4f 5f       	subi	r20, 0xFF	; 255
    e014:	5f 4f       	sbci	r21, 0xFF	; 255
				
			default:
				goto error;
		}		
		
		for (twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);len > 0;len--)
    e016:	21 50       	subi	r18, 0x01	; 1
    e018:	30 40       	sbci	r19, 0x00	; 0
    e01a:	12 16       	cp	r1, r18
    e01c:	13 06       	cpc	r1, r19
    e01e:	f4 f2       	brlt	.-68     	; 0xdfdc <read_bytes_I2C+0x110>
		}
		
		
	quit:
		
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN); /* send stop condition */
    e020:	84 e9       	ldi	r24, 0x94	; 148
    e022:	80 93 bc 00 	sts	0x00BC, r24
		return rv;
		
	error:
		rv = -1;
		goto quit;
}
    e026:	ca 01       	movw	r24, r20
    e028:	df 91       	pop	r29
    e02a:	cf 91       	pop	r28
    e02c:	1f 91       	pop	r17
    e02e:	0f 91       	pop	r16
    e030:	08 95       	ret

0000e032 <write_page_I2C>:

/*****************************************************************************************************/
int16 write_page_I2C(uint8 PAGE_SIZE,uint8 sla, uint32 eeaddr, int16 len, uint8 *buf)
{
    e032:	af 92       	push	r10
    e034:	bf 92       	push	r11
    e036:	cf 92       	push	r12
    e038:	df 92       	push	r13
    e03a:	ef 92       	push	r14
    e03c:	ff 92       	push	r15
    e03e:	0f 93       	push	r16
    e040:	1f 93       	push	r17
    e042:	cf 93       	push	r28
    e044:	df 93       	push	r29
    e046:	59 01       	movw	r10, r18
    e048:	6a 01       	movw	r12, r20
    e04a:	f8 01       	movw	r30, r16
    e04c:	e7 01       	movw	r28, r14
	uint8  n = 0;
	int16 rv = 0;
	uint16 endaddr;

	/* si la direccion mas la cantidad de datos en menor a  el tamao de pagina*/
	if (eeaddr + len <  (eeaddr | (PAGE_SIZE - 1)) )  
    e04e:	08 2f       	mov	r16, r24
    e050:	10 e0       	ldi	r17, 0x00	; 0
    e052:	01 50       	subi	r16, 0x01	; 1
    e054:	10 40       	sbci	r17, 0x00	; 0
    e056:	9f 01       	movw	r18, r30
    e058:	44 27       	eor	r20, r20
    e05a:	37 fd       	sbrc	r19, 7
    e05c:	40 95       	com	r20
    e05e:	54 2f       	mov	r21, r20
    e060:	2a 0d       	add	r18, r10
    e062:	3b 1d       	adc	r19, r11
    e064:	4c 1d       	adc	r20, r12
    e066:	5d 1d       	adc	r21, r13
    e068:	c8 01       	movw	r24, r16
    e06a:	aa 27       	eor	r26, r26
    e06c:	97 fd       	sbrc	r25, 7
    e06e:	a0 95       	com	r26
    e070:	ba 2f       	mov	r27, r26
    e072:	8a 29       	or	r24, r10
    e074:	9b 29       	or	r25, r11
    e076:	ac 29       	or	r26, r12
    e078:	bd 29       	or	r27, r13
    e07a:	28 17       	cp	r18, r24
    e07c:	39 07       	cpc	r19, r25
    e07e:	4a 07       	cpc	r20, r26
    e080:	5b 07       	cpc	r21, r27
    e082:	20 f4       	brcc	.+8      	; 0xe08c <write_page_I2C+0x5a>
		endaddr = eeaddr + len;
    e084:	8f 01       	movw	r16, r30
    e086:	0a 0d       	add	r16, r10
    e088:	1b 1d       	adc	r17, r11
    e08a:	04 c0       	rjmp	.+8      	; 0xe094 <write_page_I2C+0x62>
	else
		/* Entonces colocar el final hasta el fin de pagina*/
		endaddr = (eeaddr | (PAGE_SIZE - 1)) + 1;  
    e08c:	0a 29       	or	r16, r10
    e08e:	1b 29       	or	r17, r11
    e090:	0f 5f       	subi	r16, 0xFF	; 255
    e092:	1f 4f       	sbci	r17, 0xFF	; 255
			default:
				goto error;								/* must send stop condition */
		}	
			
		#ifdef TWI_ADDRH
			TWDR =(uint8)((eeaddr>>8)&0xFF);			/* high 8 bits of addr if define TWI_ADDRH*/
    e094:	bb 27       	eor	r27, r27
    e096:	ad 2d       	mov	r26, r13
    e098:	9c 2d       	mov	r25, r12
    e09a:	8b 2d       	mov	r24, r11
    e09c:	98 2f       	mov	r25, r24
		if (n++ >= MAX_ITER)
			return -1;
	begin:
		
		
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); 	/* send start condition */
    e09e:	34 ea       	ldi	r19, 0xA4	; 164
														/* NB: do /not/ send stop condition */
		}
		
		/* send SLA+W */
		TWDR = sla | TW_WRITE;
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
    e0a0:	24 e8       	ldi	r18, 0x84	; 132
		if (n++ >= MAX_ITER)
			return -1;
	begin:
		
		
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); 	/* send start condition */
    e0a2:	30 93 bc 00 	sts	0x00BC, r19
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
    e0a6:	80 91 bc 00 	lds	r24, 0x00BC
    e0aa:	87 ff       	sbrs	r24, 7
    e0ac:	fc cf       	rjmp	.-8      	; 0xe0a6 <write_page_I2C+0x74>
		twst = TW_STATUS;
    e0ae:	80 91 b9 00 	lds	r24, 0x00B9
    e0b2:	88 7f       	andi	r24, 0xF8	; 248
		
		switch (twst)
    e0b4:	80 31       	cpi	r24, 0x10	; 16
    e0b6:	49 f0       	breq	.+18     	; 0xe0ca <write_page_I2C+0x98>
    e0b8:	88 33       	cpi	r24, 0x38	; 56
    e0ba:	99 f3       	breq	.-26     	; 0xe0a2 <write_page_I2C+0x70>
    e0bc:	88 30       	cpi	r24, 0x08	; 8
    e0be:	29 f0       	breq	.+10     	; 0xe0ca <write_page_I2C+0x98>
    e0c0:	80 93 1c 82 	sts	0x821C, r24
    e0c4:	6f ef       	ldi	r22, 0xFF	; 255
    e0c6:	7f ef       	ldi	r23, 0xFF	; 255
    e0c8:	64 c0       	rjmp	.+200    	; 0xe192 <write_page_I2C+0x160>
				return -1;								/* error: not in start condition */
														/* NB: do /not/ send stop condition */
		}
		
		/* send SLA+W */
		TWDR = sla | TW_WRITE;
    e0ca:	60 93 bb 00 	sts	0x00BB, r22
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
    e0ce:	20 93 bc 00 	sts	0x00BC, r18
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
    e0d2:	80 91 bc 00 	lds	r24, 0x00BC
    e0d6:	87 ff       	sbrs	r24, 7
    e0d8:	fc cf       	rjmp	.-8      	; 0xe0d2 <write_page_I2C+0xa0>
		twst = TW_STATUS;
    e0da:	80 91 b9 00 	lds	r24, 0x00B9
    e0de:	88 7f       	andi	r24, 0xF8	; 248
		
		switch (twst)
    e0e0:	80 32       	cpi	r24, 0x20	; 32
    e0e2:	f9 f2       	breq	.-66     	; 0xe0a2 <write_page_I2C+0x70>
    e0e4:	88 33       	cpi	r24, 0x38	; 56
    e0e6:	e9 f2       	breq	.-70     	; 0xe0a2 <write_page_I2C+0x70>
    e0e8:	88 31       	cpi	r24, 0x18	; 24
    e0ea:	49 f5       	brne	.+82     	; 0xe13e <write_page_I2C+0x10c>
			default:
				goto error;								/* must send stop condition */
		}	
			
		#ifdef TWI_ADDRH
			TWDR =(uint8)((eeaddr>>8)&0xFF);			/* high 8 bits of addr if define TWI_ADDRH*/
    e0ec:	90 93 bb 00 	sts	0x00BB, r25
			TWCR = _BV(TWINT) | _BV(TWEN); 			/* clear interrupt to start transmission */
    e0f0:	20 93 bc 00 	sts	0x00BC, r18
			while ((TWCR & _BV(TWINT)) == 0) ; 		/* wait for transmission */
    e0f4:	80 91 bc 00 	lds	r24, 0x00BC
    e0f8:	87 ff       	sbrs	r24, 7
    e0fa:	fc cf       	rjmp	.-8      	; 0xe0f4 <write_page_I2C+0xc2>
			twst = TW_STATUS;
    e0fc:	80 91 b9 00 	lds	r24, 0x00B9
    e100:	88 7f       	andi	r24, 0xF8	; 248
			
			switch (twst)
    e102:	80 33       	cpi	r24, 0x30	; 48
    e104:	b9 f0       	breq	.+46     	; 0xe134 <write_page_I2C+0x102>
    e106:	88 33       	cpi	r24, 0x38	; 56
    e108:	61 f2       	breq	.-104    	; 0xe0a2 <write_page_I2C+0x70>
    e10a:	88 32       	cpi	r24, 0x28	; 40
    e10c:	c1 f4       	brne	.+48     	; 0xe13e <write_page_I2C+0x10c>
				default:
					goto error;							/* must send stop condition */
			}
		#endif
		
		TWDR = (uint8)(eeaddr&0xFF);					/* low 8 bits of addr */
    e10e:	a0 92 bb 00 	sts	0x00BB, r10
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
    e112:	20 93 bc 00 	sts	0x00BC, r18
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
    e116:	80 91 bc 00 	lds	r24, 0x00BC
    e11a:	87 ff       	sbrs	r24, 7
    e11c:	fc cf       	rjmp	.-8      	; 0xe116 <write_page_I2C+0xe4>
		twst = TW_STATUS;
    e11e:	80 91 b9 00 	lds	r24, 0x00B9
    e122:	88 7f       	andi	r24, 0xF8	; 248
		
		switch (twst)
    e124:	80 33       	cpi	r24, 0x30	; 48
    e126:	31 f0       	breq	.+12     	; 0xe134 <write_page_I2C+0x102>
    e128:	88 33       	cpi	r24, 0x38	; 56
    e12a:	09 f4       	brne	.+2      	; 0xe12e <write_page_I2C+0xfc>
    e12c:	ba cf       	rjmp	.-140    	; 0xe0a2 <write_page_I2C+0x70>
    e12e:	88 32       	cpi	r24, 0x28	; 40
    e130:	31 f4       	brne	.+12     	; 0xe13e <write_page_I2C+0x10c>
    e132:	08 c0       	rjmp	.+16     	; 0xe144 <write_page_I2C+0x112>
    e134:	80 93 1c 82 	sts	0x821C, r24
    e138:	60 e0       	ldi	r22, 0x00	; 0
    e13a:	70 e0       	ldi	r23, 0x00	; 0
    e13c:	27 c0       	rjmp	.+78     	; 0xe18c <write_page_I2C+0x15a>
    e13e:	80 93 1c 82 	sts	0x821C, r24
    e142:	18 c0       	rjmp	.+48     	; 0xe174 <write_page_I2C+0x142>
    e144:	80 93 1c 82 	sts	0x821C, r24
		endaddr = eeaddr + len;
	else
		/* Entonces colocar el final hasta el fin de pagina*/
		endaddr = (eeaddr | (PAGE_SIZE - 1)) + 1;  
	
	len = endaddr - eeaddr;
    e148:	0a 19       	sub	r16, r10
    e14a:	1b 09       	sbc	r17, r11
    e14c:	60 e0       	ldi	r22, 0x00	; 0
    e14e:	70 e0       	ldi	r23, 0x00	; 0
		}
		
		for (; len > 0; len--)
		{
			TWDR = *buf++;
			TWCR = _BV(TWINT) | _BV(TWEN); 			/* start transmission */
    e150:	24 e8       	ldi	r18, 0x84	; 132
    e152:	16 c0       	rjmp	.+44     	; 0xe180 <write_page_I2C+0x14e>
				goto error;								/* must send stop condition */
		}
		
		for (; len > 0; len--)
		{
			TWDR = *buf++;
    e154:	88 81       	ld	r24, Y
    e156:	80 93 bb 00 	sts	0x00BB, r24
			TWCR = _BV(TWINT) | _BV(TWEN); 			/* start transmission */
    e15a:	20 93 bc 00 	sts	0x00BC, r18
			while ((TWCR & _BV(TWINT)) == 0) ; 		/* wait for transmission */
    e15e:	80 91 bc 00 	lds	r24, 0x00BC
    e162:	87 ff       	sbrs	r24, 7
    e164:	fc cf       	rjmp	.-8      	; 0xe15e <write_page_I2C+0x12c>
			switch ((twst = TW_STATUS))
    e166:	80 91 b9 00 	lds	r24, 0x00B9
    e16a:	88 7f       	andi	r24, 0xF8	; 248
    e16c:	80 93 1c 82 	sts	0x821C, r24
    e170:	88 32       	cpi	r24, 0x28	; 40
    e172:	19 f0       	breq	.+6      	; 0xe17a <write_page_I2C+0x148>
    e174:	6f ef       	ldi	r22, 0xFF	; 255
    e176:	7f ef       	ldi	r23, 0xFF	; 255
    e178:	09 c0       	rjmp	.+18     	; 0xe18c <write_page_I2C+0x15a>
				goto error;								/* must send stop condition */
		}
		
		for (; len > 0; len--)
		{
			TWDR = *buf++;
    e17a:	21 96       	adiw	r28, 0x01	; 1
			{
				case TW_MT_DATA_NACK:
					goto error;							/* device write protected -- Note [16] */
					
				case TW_MT_DATA_ACK:
					rv++;
    e17c:	6f 5f       	subi	r22, 0xFF	; 255
    e17e:	7f 4f       	sbci	r23, 0xFF	; 255
				
			default:
				goto error;								/* must send stop condition */
		}
		
		for (; len > 0; len--)
    e180:	c8 01       	movw	r24, r16
    e182:	86 1b       	sub	r24, r22
    e184:	97 0b       	sbc	r25, r23
    e186:	18 16       	cp	r1, r24
    e188:	19 06       	cpc	r1, r25
    e18a:	24 f3       	brlt	.-56     	; 0xe154 <write_page_I2C+0x122>
				default:
					goto error;
			}
		}
	quit:
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN); 	/* send stop condition */
    e18c:	84 e9       	ldi	r24, 0x94	; 148
    e18e:	80 93 bc 00 	sts	0x00BC, r24
			return rv;
		
	error:
		rv = -1;
		goto quit;
}
    e192:	cb 01       	movw	r24, r22
    e194:	df 91       	pop	r29
    e196:	cf 91       	pop	r28
    e198:	1f 91       	pop	r17
    e19a:	0f 91       	pop	r16
    e19c:	ff 90       	pop	r15
    e19e:	ef 90       	pop	r14
    e1a0:	df 90       	pop	r13
    e1a2:	cf 90       	pop	r12
    e1a4:	bf 90       	pop	r11
    e1a6:	af 90       	pop	r10
    e1a8:	08 95       	ret

0000e1aa <error>:
}
/*****************************************************************************************************/
void error(void)
{

  printf("error=> TWI status %#x\n", twst);
    e1aa:	00 d0       	rcall	.+0      	; 0xe1ac <error+0x2>
    e1ac:	00 d0       	rcall	.+0      	; 0xe1ae <error+0x4>
    e1ae:	ed b7       	in	r30, 0x3d	; 61
    e1b0:	fe b7       	in	r31, 0x3e	; 62
    e1b2:	31 96       	adiw	r30, 0x01	; 1
    e1b4:	81 ea       	ldi	r24, 0xA1	; 161
    e1b6:	96 e7       	ldi	r25, 0x76	; 118
    e1b8:	ad b7       	in	r26, 0x3d	; 61
    e1ba:	be b7       	in	r27, 0x3e	; 62
    e1bc:	12 96       	adiw	r26, 0x02	; 2
    e1be:	9c 93       	st	X, r25
    e1c0:	8e 93       	st	-X, r24
    e1c2:	11 97       	sbiw	r26, 0x01	; 1
    e1c4:	80 91 1c 82 	lds	r24, 0x821C
    e1c8:	82 83       	std	Z+2, r24	; 0x02
    e1ca:	13 82       	std	Z+3, r1	; 0x03
    e1cc:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
  exit(0);
    e1d0:	0f 90       	pop	r0
    e1d2:	0f 90       	pop	r0
    e1d4:	0f 90       	pop	r0
    e1d6:	0f 90       	pop	r0
    e1d8:	80 e0       	ldi	r24, 0x00	; 0
    e1da:	90 e0       	ldi	r25, 0x00	; 0
    e1dc:	0e 94 0e 8a 	call	0x1141c	; 0x1141c <_exit>

0000e1e0 <write_bytes_I2C>:
		rv = -1;
		goto quit;
}
/*****************************************************************************************************/
int16 write_bytes_I2C(uint8 PAGE_SIZE,uint8 sla, uint32 eeaddr, int16 len, uint8 *buf)
{
    e1e0:	4f 92       	push	r4
    e1e2:	5f 92       	push	r5
    e1e4:	6f 92       	push	r6
    e1e6:	7f 92       	push	r7
    e1e8:	8f 92       	push	r8
    e1ea:	9f 92       	push	r9
    e1ec:	af 92       	push	r10
    e1ee:	bf 92       	push	r11
    e1f0:	cf 92       	push	r12
    e1f2:	df 92       	push	r13
    e1f4:	ef 92       	push	r14
    e1f6:	ff 92       	push	r15
    e1f8:	0f 93       	push	r16
    e1fa:	1f 93       	push	r17
    e1fc:	cf 93       	push	r28
    e1fe:	df 93       	push	r29
    e200:	48 2e       	mov	r4, r24
    e202:	56 2e       	mov	r5, r22
    e204:	59 01       	movw	r10, r18
    e206:	6a 01       	movw	r12, r20
    e208:	48 01       	movw	r8, r16
    e20a:	37 01       	movw	r6, r14
    e20c:	c0 e0       	ldi	r28, 0x00	; 0
    e20e:	d0 e0       	ldi	r29, 0x00	; 0
	total = 0;
  
	do
    {
		
		rv = write_page_I2C(PAGE_SIZE,sla, eeaddr, len, buf);
    e210:	84 2d       	mov	r24, r4
    e212:	65 2d       	mov	r22, r5
    e214:	a6 01       	movw	r20, r12
    e216:	95 01       	movw	r18, r10
    e218:	84 01       	movw	r16, r8
    e21a:	73 01       	movw	r14, r6
    e21c:	0e 94 19 70 	call	0xe032	; 0xe032 <write_page_I2C>
    e220:	9c 01       	movw	r18, r24
		if (rv == -1)
    e222:	8f ef       	ldi	r24, 0xFF	; 255
    e224:	2f 3f       	cpi	r18, 0xFF	; 255
    e226:	38 07       	cpc	r19, r24
    e228:	29 f4       	brne	.+10     	; 0xe234 <write_bytes_I2C+0x54>
		{
			error();
    e22a:	0e 94 d5 70 	call	0xe1aa	; 0xe1aa <error>
    e22e:	cf ef       	ldi	r28, 0xFF	; 255
    e230:	df ef       	ldi	r29, 0xFF	; 255
    e232:	13 c0       	rjmp	.+38     	; 0xe25a <write_bytes_I2C+0x7a>
			return -1;
		}
	  
		eeaddr += rv;
		len -= rv;
    e234:	82 1a       	sub	r8, r18
    e236:	93 0a       	sbc	r9, r19
		buf += rv;
		total += rv;
    e238:	c2 0f       	add	r28, r18
    e23a:	d3 1f       	adc	r29, r19
    }
  while (len > 0);
    e23c:	18 14       	cp	r1, r8
    e23e:	19 04       	cpc	r1, r9
    e240:	64 f4       	brge	.+24     	; 0xe25a <write_bytes_I2C+0x7a>
		{
			error();
			return -1;
		}
	  
		eeaddr += rv;
    e242:	c9 01       	movw	r24, r18
    e244:	aa 27       	eor	r26, r26
    e246:	97 fd       	sbrc	r25, 7
    e248:	a0 95       	com	r26
    e24a:	ba 2f       	mov	r27, r26
    e24c:	a8 0e       	add	r10, r24
    e24e:	b9 1e       	adc	r11, r25
    e250:	ca 1e       	adc	r12, r26
    e252:	db 1e       	adc	r13, r27
		len -= rv;
		buf += rv;
    e254:	62 0e       	add	r6, r18
    e256:	73 1e       	adc	r7, r19
    e258:	db cf       	rjmp	.-74     	; 0xe210 <write_bytes_I2C+0x30>
		total += rv;
    }
  while (len > 0);

  return total;
}
    e25a:	ce 01       	movw	r24, r28
    e25c:	df 91       	pop	r29
    e25e:	cf 91       	pop	r28
    e260:	1f 91       	pop	r17
    e262:	0f 91       	pop	r16
    e264:	ff 90       	pop	r15
    e266:	ef 90       	pop	r14
    e268:	df 90       	pop	r13
    e26a:	cf 90       	pop	r12
    e26c:	bf 90       	pop	r11
    e26e:	af 90       	pop	r10
    e270:	9f 90       	pop	r9
    e272:	8f 90       	pop	r8
    e274:	7f 90       	pop	r7
    e276:	6f 90       	pop	r6
    e278:	5f 90       	pop	r5
    e27a:	4f 90       	pop	r4
    e27c:	08 95       	ret

0000e27e <ee24xx_write_bytes>:
 
	return rv;
}
/*****************************************************************************************************/
int16 ee24xx_write_bytes(uint32 eeaddr, int16 len, uint8 *buf)	
{
    e27e:	af 92       	push	r10
    e280:	bf 92       	push	r11
    e282:	cf 92       	push	r12
    e284:	df 92       	push	r13
    e286:	ef 92       	push	r14
    e288:	ff 92       	push	r15
    e28a:	0f 93       	push	r16
    e28c:	1f 93       	push	r17
    e28e:	5b 01       	movw	r10, r22
    e290:	6c 01       	movw	r12, r24
    e292:	8a 01       	movw	r16, r20
    e294:	79 01       	movw	r14, r18
	sla = TWI_SLA_24LC1025 | (((eeaddr >> 16) & 0x01) << 3); 
	
	/* the 24LC1025 EEPROM permits a 128-byte writes in a page  */
	PAGE_SIZE=128;
	
	rv= write_bytes_I2C(PAGE_SIZE,sla, eeaddr, len, buf);
    e296:	96 01       	movw	r18, r12
    e298:	44 27       	eor	r20, r20
    e29a:	55 27       	eor	r21, r21
    e29c:	21 70       	andi	r18, 0x01	; 1
    e29e:	22 0f       	add	r18, r18
    e2a0:	22 0f       	add	r18, r18
    e2a2:	22 0f       	add	r18, r18
    e2a4:	20 6a       	ori	r18, 0xA0	; 160
    e2a6:	80 e8       	ldi	r24, 0x80	; 128
    e2a8:	62 2f       	mov	r22, r18
    e2aa:	a6 01       	movw	r20, r12
    e2ac:	95 01       	movw	r18, r10
    e2ae:	0e 94 f0 70 	call	0xe1e0	; 0xe1e0 <write_bytes_I2C>
    e2b2:	8c 01       	movw	r16, r24
	
	if (rv == -1)
    e2b4:	8f ef       	ldi	r24, 0xFF	; 255
    e2b6:	0f 3f       	cpi	r16, 0xFF	; 255
    e2b8:	18 07       	cpc	r17, r24
    e2ba:	11 f4       	brne	.+4      	; 0xe2c0 <ee24xx_write_bytes+0x42>
	{
		error();
    e2bc:	0e 94 d5 70 	call	0xe1aa	; 0xe1aa <error>
		return -1;
	}
 
	return rv;	
    e2c0:	c8 01       	movw	r24, r16
    e2c2:	1f 91       	pop	r17
    e2c4:	0f 91       	pop	r16
    e2c6:	ff 90       	pop	r15
    e2c8:	ef 90       	pop	r14
    e2ca:	df 90       	pop	r13
    e2cc:	cf 90       	pop	r12
    e2ce:	bf 90       	pop	r11
    e2d0:	af 90       	pop	r10
    e2d2:	08 95       	ret

0000e2d4 <ee24xx_read_bytes>:
#include "types.h"
#include "tw_eeprom.h"

/*****************************************************************************************************/
int16 ee24xx_read_bytes(uint32 eeaddr, int16 len, uint8 *buf)
{
    e2d4:	cf 92       	push	r12
    e2d6:	df 92       	push	r13
    e2d8:	ef 92       	push	r14
    e2da:	ff 92       	push	r15
    e2dc:	0f 93       	push	r16
    e2de:	1f 93       	push	r17
    e2e0:	6b 01       	movw	r12, r22
    e2e2:	7c 01       	movw	r14, r24
    e2e4:	fa 01       	movw	r30, r20
    e2e6:	89 01       	movw	r16, r18
	
	/* patch high bits of EEPROM address into SLA 
		 Acomodo a B0*/
	sla = TWI_SLA_24LC1025 | (((eeaddr >> 16) & 0x01) << 3); 
	
	rv=	read_bytes_I2C(sla,eeaddr,len,buf);	
    e2e8:	c7 01       	movw	r24, r14
    e2ea:	aa 27       	eor	r26, r26
    e2ec:	bb 27       	eor	r27, r27
    e2ee:	81 70       	andi	r24, 0x01	; 1
    e2f0:	88 0f       	add	r24, r24
    e2f2:	88 0f       	add	r24, r24
    e2f4:	88 0f       	add	r24, r24
    e2f6:	80 6a       	ori	r24, 0xA0	; 160
    e2f8:	b7 01       	movw	r22, r14
    e2fa:	a6 01       	movw	r20, r12
    e2fc:	9f 01       	movw	r18, r30
    e2fe:	0e 94 66 6f 	call	0xdecc	; 0xdecc <read_bytes_I2C>
    e302:	8c 01       	movw	r16, r24
	
	if (rv == -1)
    e304:	8f ef       	ldi	r24, 0xFF	; 255
    e306:	0f 3f       	cpi	r16, 0xFF	; 255
    e308:	18 07       	cpc	r17, r24
    e30a:	11 f4       	brne	.+4      	; 0xe310 <ee24xx_read_bytes+0x3c>
	{
		error();
    e30c:	0e 94 d5 70 	call	0xe1aa	; 0xe1aa <error>
		return -1;
	}
 
	return rv;
}
    e310:	c8 01       	movw	r24, r16
    e312:	1f 91       	pop	r17
    e314:	0f 91       	pop	r16
    e316:	ff 90       	pop	r15
    e318:	ef 90       	pop	r14
    e31a:	df 90       	pop	r13
    e31c:	cf 90       	pop	r12
    e31e:	08 95       	ret

0000e320 <RCT_task>:
	int maxdata;
	#ifdef DEBUG_TAREAS_PROG
	int i;
	#endif
  
	switch (TASK)
    e320:	81 30       	cpi	r24, 0x01	; 1
    e322:	41 f0       	breq	.+16     	; 0xe334 <RCT_task+0x14>
    e324:	81 30       	cpi	r24, 0x01	; 1
    e326:	18 f0       	brcs	.+6      	; 0xe32e <RCT_task+0xe>
    e328:	82 30       	cpi	r24, 0x02	; 2
    e32a:	11 f5       	brne	.+68     	; 0xe370 <RCT_task+0x50>
    e32c:	06 c0       	rjmp	.+12     	; 0xe33a <RCT_task+0x1a>
	{
		case (TAST_Opengripper):
			openGripper();  
    e32e:	0e 94 69 76 	call	0xecd2	; 0xecd2 <openGripper>
    e332:	08 95       	ret
		break;
		
		case (TAST_Closegripper):
			closeGripper();
    e334:	0e 94 9a 76 	call	0xed34	; 0xed34 <closeGripper>
    e338:	08 95       	ret
		
		case (TAST_IDVectorTrajectory):
			#ifdef DEBUG_TAREAS_PROG
			printf("RCT_task=> FlagrxVectorok %d\n",FlagrxVectorok);
			#endif
			if(FlagrxVectorok)
    e33a:	80 91 b2 7b 	lds	r24, 0x7BB2
    e33e:	90 91 b3 7b 	lds	r25, 0x7BB3
    e342:	89 2b       	or	r24, r25
    e344:	89 f0       	breq	.+34     	; 0xe368 <RCT_task+0x48>
				printf("RCT_task=>  maxdata= %d\n",maxdata);
				for(i=0;i<maxdata;i++)
				
					printf("RCT_task=> rxvector[%d]= %d\n",i,rxvector[i]);
				#endif
				printf("RCT_task=> Ejecutando TAST_IDVectorTrajectory\n");
    e346:	89 eb       	ldi	r24, 0xB9	; 185
    e348:	96 e7       	ldi	r25, 0x76	; 118
    e34a:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
				
				/*Copiar el rxvector que se mando en la ultima transferencia
				utilizando los datos de la eeprom*/
				Vector2Trajectory(rxvector);
    e34e:	80 91 d2 80 	lds	r24, 0x80D2
    e352:	90 91 d3 80 	lds	r25, 0x80D3
    e356:	0e 94 53 75 	call	0xeaa6	; 0xeaa6 <Vector2Trajectory>
				
				/*utilizo esos datos para ejecutar la trajectoria*/
				PMDprocessTrajectory(&Trajectoryvector,0);
    e35a:	85 e2       	ldi	r24, 0x25	; 37
    e35c:	92 e8       	ldi	r25, 0x82	; 130
    e35e:	60 e0       	ldi	r22, 0x00	; 0
    e360:	70 e0       	ldi	r23, 0x00	; 0
    e362:	0e 94 96 54 	call	0xa92c	; 0xa92c <PMDprocessTrajectory>
    e366:	08 95       	ret
			}
			else 
				printf("RCT_task=> No hay una trajectoryVector Valido\n");
    e368:	87 ee       	ldi	r24, 0xE7	; 231
    e36a:	96 e7       	ldi	r25, 0x76	; 118
    e36c:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    e370:	08 95       	ret

0000e372 <read_alarm>:

	return rv;
}
/*****************************************************************************************************/
int16 read_alarm(tAlarm *alarma)
{
    e372:	0f 93       	push	r16
    e374:	1f 93       	push	r17
    e376:	8c 01       	movw	r16, r24
	
	sla= TWI_SLA_RTC;
	buffersizertc=sizeof(tAlarm)-sizeof(uint8)-sizeof(uint8);								/* Direccion del Dispositivo Esclavo*/

	/* 0x00 es el comienzo de la direccion en donde estasn los Registros de configuracion de Alarma*/
	rv= read_bytes_I2C(sla, 0x00, buffersizertc, (uint8 *)alarma);
    e378:	8e ed       	ldi	r24, 0xDE	; 222
    e37a:	40 e0       	ldi	r20, 0x00	; 0
    e37c:	50 e0       	ldi	r21, 0x00	; 0
    e37e:	60 e0       	ldi	r22, 0x00	; 0
    e380:	70 e0       	ldi	r23, 0x00	; 0
    e382:	25 e0       	ldi	r18, 0x05	; 5
    e384:	30 e0       	ldi	r19, 0x00	; 0
    e386:	0e 94 66 6f 	call	0xdecc	; 0xdecc <read_bytes_I2C>
	
	return rv;
}
    e38a:	1f 91       	pop	r17
    e38c:	0f 91       	pop	r16
    e38e:	08 95       	ret

0000e390 <read_control>:

	return rv;
}
/*****************************************************************************************************/
int16 read_control(tcontrol_RTC *ctr)
{
    e390:	0f 93       	push	r16
    e392:	1f 93       	push	r17
    e394:	8c 01       	movw	r16, r24
	int16 rv;
	
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/

	/* 0x10 es el comienzo de la direccion en donde estasn los Registros de control del RTC*/
	rv= read_bytes_I2C(sla, 0x10, sizeof(tcontrol_RTC), (uint8 *)ctr);
    e396:	8e ed       	ldi	r24, 0xDE	; 222
    e398:	40 e1       	ldi	r20, 0x10	; 16
    e39a:	50 e0       	ldi	r21, 0x00	; 0
    e39c:	60 e0       	ldi	r22, 0x00	; 0
    e39e:	70 e0       	ldi	r23, 0x00	; 0
    e3a0:	25 e0       	ldi	r18, 0x05	; 5
    e3a2:	30 e0       	ldi	r19, 0x00	; 0
    e3a4:	0e 94 66 6f 	call	0xdecc	; 0xdecc <read_bytes_I2C>
	
	return rv;
}
    e3a8:	1f 91       	pop	r17
    e3aa:	0f 91       	pop	r16
    e3ac:	08 95       	ret

0000e3ae <Read_SR>:
	return rv;
}

/*****************************************************************************************************/
int16 Read_SR(uint8* SR)
{
    e3ae:	0f 93       	push	r16
    e3b0:	1f 93       	push	r17
    e3b2:	8c 01       	movw	r16, r24
	uint8 sla;
	int16 rv;
	
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/

	rv= read_bytes_I2C(sla, SR_CCR, sizeof(uint8), (uint8 *)SR);
    e3b4:	8e ed       	ldi	r24, 0xDE	; 222
    e3b6:	4f e3       	ldi	r20, 0x3F	; 63
    e3b8:	50 e0       	ldi	r21, 0x00	; 0
    e3ba:	60 e0       	ldi	r22, 0x00	; 0
    e3bc:	70 e0       	ldi	r23, 0x00	; 0
    e3be:	21 e0       	ldi	r18, 0x01	; 1
    e3c0:	30 e0       	ldi	r19, 0x00	; 0
    e3c2:	0e 94 66 6f 	call	0xdecc	; 0xdecc <read_bytes_I2C>
	
	return rv;
}
    e3c6:	1f 91       	pop	r17
    e3c8:	0f 91       	pop	r16
    e3ca:	08 95       	ret

0000e3cc <Read_Fecha>:

	return rv;
}
/*****************************************************************************************************/
int16 Read_Fecha(tFecha *Fecha)
{
    e3cc:	0f 93       	push	r16
    e3ce:	1f 93       	push	r17
    e3d0:	8c 01       	movw	r16, r24
	int16 rv;
	
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/
	
	/* 0x30 es el comienzo de la direccion en donde estasn los Registros del RTC*/
	rv= read_bytes_I2C(sla, 0x30, sizeof(tFecha), (uint8 *)Fecha);
    e3d2:	8e ed       	ldi	r24, 0xDE	; 222
    e3d4:	40 e3       	ldi	r20, 0x30	; 48
    e3d6:	50 e0       	ldi	r21, 0x00	; 0
    e3d8:	60 e0       	ldi	r22, 0x00	; 0
    e3da:	70 e0       	ldi	r23, 0x00	; 0
    e3dc:	28 e0       	ldi	r18, 0x08	; 8
    e3de:	30 e0       	ldi	r19, 0x00	; 0
    e3e0:	0e 94 66 6f 	call	0xdecc	; 0xdecc <read_bytes_I2C>
	
	return rv;
}
    e3e4:	1f 91       	pop	r17
    e3e6:	0f 91       	pop	r16
    e3e8:	08 95       	ret

0000e3ea <isl1207_write_Conf_SR>:
	uint8 Conf_SR[2]={0x02,0x06};


/*****************************************************************************************************/
int16 isl1207_write_Conf_SR(void)
{
    e3ea:	ef 92       	push	r14
    e3ec:	ff 92       	push	r15
    e3ee:	0f 93       	push	r16
    e3f0:	1f 93       	push	r17
	PAGE_SIZE=8;									/* El tamano de Pagina en los registros de Control*/
													/* CCR es de 8 bytes*/
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/
	
	/* Escribir 02h al Status Register */
	rv= write_bytes_I2C(PAGE_SIZE,sla, SR_CCR, 1, pWSR);
    e3f2:	88 e0       	ldi	r24, 0x08	; 8
    e3f4:	6e ed       	ldi	r22, 0xDE	; 222
    e3f6:	2f e3       	ldi	r18, 0x3F	; 63
    e3f8:	30 e0       	ldi	r19, 0x00	; 0
    e3fa:	40 e0       	ldi	r20, 0x00	; 0
    e3fc:	50 e0       	ldi	r21, 0x00	; 0
    e3fe:	01 e0       	ldi	r16, 0x01	; 1
    e400:	10 e0       	ldi	r17, 0x00	; 0
    e402:	75 e1       	ldi	r23, 0x15	; 21
    e404:	e7 2e       	mov	r14, r23
    e406:	77 e7       	ldi	r23, 0x77	; 119
    e408:	f7 2e       	mov	r15, r23
    e40a:	0e 94 f0 70 	call	0xe1e0	; 0xe1e0 <write_bytes_I2C>
    e40e:	9c 01       	movw	r18, r24
	
	if(rv)
    e410:	00 97       	sbiw	r24, 0x00	; 0
    e412:	69 f0       	breq	.+26     	; 0xe42e <isl1207_write_Conf_SR+0x44>
	{
		/* Escribir 06h al Status Register */
		pWSR++;
		rv=write_bytes_I2C(PAGE_SIZE,sla, SR_CCR, 1, pWSR);
    e414:	88 e0       	ldi	r24, 0x08	; 8
    e416:	6e ed       	ldi	r22, 0xDE	; 222
    e418:	2f e3       	ldi	r18, 0x3F	; 63
    e41a:	30 e0       	ldi	r19, 0x00	; 0
    e41c:	40 e0       	ldi	r20, 0x00	; 0
    e41e:	50 e0       	ldi	r21, 0x00	; 0
    e420:	96 e1       	ldi	r25, 0x16	; 22
    e422:	e9 2e       	mov	r14, r25
    e424:	97 e7       	ldi	r25, 0x77	; 119
    e426:	f9 2e       	mov	r15, r25
    e428:	0e 94 f0 70 	call	0xe1e0	; 0xe1e0 <write_bytes_I2C>
    e42c:	9c 01       	movw	r18, r24
	}

	return rv;
}
    e42e:	c9 01       	movw	r24, r18
    e430:	1f 91       	pop	r17
    e432:	0f 91       	pop	r16
    e434:	ff 90       	pop	r15
    e436:	ef 90       	pop	r14
    e438:	08 95       	ret

0000e43a <write_alarm>:
	
	return rv;
}
/*****************************************************************************************************/
int16 write_alarm(tAlarm alarma)
{
    e43a:	ef 92       	push	r14
    e43c:	ff 92       	push	r15
    e43e:	0f 93       	push	r16
    e440:	1f 93       	push	r17
    e442:	df 93       	push	r29
    e444:	cf 93       	push	r28
    e446:	cd b7       	in	r28, 0x3d	; 61
    e448:	de b7       	in	r29, 0x3e	; 62
    e44a:	27 97       	sbiw	r28, 0x07	; 7
    e44c:	0f b6       	in	r0, 0x3f	; 63
    e44e:	f8 94       	cli
    e450:	de bf       	out	0x3e, r29	; 62
    e452:	0f be       	out	0x3f, r0	; 63
    e454:	cd bf       	out	0x3d, r28	; 61
    e456:	29 83       	std	Y+1, r18	; 0x01
    e458:	3a 83       	std	Y+2, r19	; 0x02
    e45a:	4b 83       	std	Y+3, r20	; 0x03
    e45c:	5c 83       	std	Y+4, r21	; 0x04
    e45e:	6d 83       	std	Y+5, r22	; 0x05
    e460:	7e 83       	std	Y+6, r23	; 0x06
    e462:	8f 83       	std	Y+7, r24	; 0x07
	
	PAGE_SIZE=16;									/* El tamano de Pagina en los registros de Alarma*/
													/* es de 16 bytes*/
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/
	
	rv=isl1207_write_Conf_SR();
    e464:	0e 94 f5 71 	call	0xe3ea	; 0xe3ea <isl1207_write_Conf_SR>
    e468:	9c 01       	movw	r18, r24
/*Esto es  para guardar solo hasta el campo uint8 MOA0;*/
	buffersizertc=sizeof(tAlarm)-sizeof(uint8)-sizeof(uint8);
	
	if(rv)
    e46a:	00 97       	sbiw	r24, 0x00	; 0
    e46c:	79 f0       	breq	.+30     	; 0xe48c <write_alarm+0x52>
	{
		/* 0x00 es el comienzo de la direccion en donde estan los Registros de configuracion de Alarma*/
		rv= write_bytes_I2C(PAGE_SIZE,sla, 0x00, buffersizertc,(uint8 *)&alarma);
    e46e:	80 e1       	ldi	r24, 0x10	; 16
    e470:	6e ed       	ldi	r22, 0xDE	; 222
    e472:	20 e0       	ldi	r18, 0x00	; 0
    e474:	30 e0       	ldi	r19, 0x00	; 0
    e476:	40 e0       	ldi	r20, 0x00	; 0
    e478:	50 e0       	ldi	r21, 0x00	; 0
    e47a:	05 e0       	ldi	r16, 0x05	; 5
    e47c:	10 e0       	ldi	r17, 0x00	; 0
    e47e:	7e 01       	movw	r14, r28
    e480:	08 94       	sec
    e482:	e1 1c       	adc	r14, r1
    e484:	f1 1c       	adc	r15, r1
    e486:	0e 94 f0 70 	call	0xe1e0	; 0xe1e0 <write_bytes_I2C>
    e48a:	9c 01       	movw	r18, r24
	}

	return rv;
}
    e48c:	c9 01       	movw	r24, r18
    e48e:	27 96       	adiw	r28, 0x07	; 7
    e490:	0f b6       	in	r0, 0x3f	; 63
    e492:	f8 94       	cli
    e494:	de bf       	out	0x3e, r29	; 62
    e496:	0f be       	out	0x3f, r0	; 63
    e498:	cd bf       	out	0x3d, r28	; 61
    e49a:	cf 91       	pop	r28
    e49c:	df 91       	pop	r29
    e49e:	1f 91       	pop	r17
    e4a0:	0f 91       	pop	r16
    e4a2:	ff 90       	pop	r15
    e4a4:	ef 90       	pop	r14
    e4a6:	08 95       	ret

0000e4a8 <write_control>:
	
	return rv;
}
/*****************************************************************************************************/
int16 write_control(tcontrol_RTC ctr)
{
    e4a8:	ef 92       	push	r14
    e4aa:	ff 92       	push	r15
    e4ac:	0f 93       	push	r16
    e4ae:	1f 93       	push	r17
    e4b0:	df 93       	push	r29
    e4b2:	cf 93       	push	r28
    e4b4:	00 d0       	rcall	.+0      	; 0xe4b6 <write_control+0xe>
    e4b6:	00 d0       	rcall	.+0      	; 0xe4b8 <write_control+0x10>
    e4b8:	0f 92       	push	r0
    e4ba:	cd b7       	in	r28, 0x3d	; 61
    e4bc:	de b7       	in	r29, 0x3e	; 62
    e4be:	49 83       	std	Y+1, r20	; 0x01
    e4c0:	5a 83       	std	Y+2, r21	; 0x02
    e4c2:	6b 83       	std	Y+3, r22	; 0x03
    e4c4:	7c 83       	std	Y+4, r23	; 0x04
    e4c6:	8d 83       	std	Y+5, r24	; 0x05
	
	PAGE_SIZE=8;									/* El tamano de Pagina en los registros de Control*/
													/* CCR es de 8 bytes*/
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/
	
	rv=isl1207_write_Conf_SR();
    e4c8:	0e 94 f5 71 	call	0xe3ea	; 0xe3ea <isl1207_write_Conf_SR>
    e4cc:	9c 01       	movw	r18, r24
	
	if(rv)
    e4ce:	00 97       	sbiw	r24, 0x00	; 0
    e4d0:	79 f0       	breq	.+30     	; 0xe4f0 <write_control+0x48>
	{
		/* 0x10 es el comienzo de la direccion en donde estasn los Registros de control del RTC*/
		rv= write_bytes_I2C(PAGE_SIZE,sla, 0x10, sizeof(tcontrol_RTC),(uint8 *)&ctr);
    e4d2:	88 e0       	ldi	r24, 0x08	; 8
    e4d4:	6e ed       	ldi	r22, 0xDE	; 222
    e4d6:	20 e1       	ldi	r18, 0x10	; 16
    e4d8:	30 e0       	ldi	r19, 0x00	; 0
    e4da:	40 e0       	ldi	r20, 0x00	; 0
    e4dc:	50 e0       	ldi	r21, 0x00	; 0
    e4de:	05 e0       	ldi	r16, 0x05	; 5
    e4e0:	10 e0       	ldi	r17, 0x00	; 0
    e4e2:	7e 01       	movw	r14, r28
    e4e4:	08 94       	sec
    e4e6:	e1 1c       	adc	r14, r1
    e4e8:	f1 1c       	adc	r15, r1
    e4ea:	0e 94 f0 70 	call	0xe1e0	; 0xe1e0 <write_bytes_I2C>
    e4ee:	9c 01       	movw	r18, r24
	}

	return rv;
}
    e4f0:	c9 01       	movw	r24, r18
    e4f2:	0f 90       	pop	r0
    e4f4:	0f 90       	pop	r0
    e4f6:	0f 90       	pop	r0
    e4f8:	0f 90       	pop	r0
    e4fa:	0f 90       	pop	r0
    e4fc:	cf 91       	pop	r28
    e4fe:	df 91       	pop	r29
    e500:	1f 91       	pop	r17
    e502:	0f 91       	pop	r16
    e504:	ff 90       	pop	r15
    e506:	ef 90       	pop	r14
    e508:	08 95       	ret

0000e50a <rtc_init>:
	return rv;
}

/*****************************************************************************************************/
void rtc_init(void)
{
    e50a:	df 93       	push	r29
    e50c:	cf 93       	push	r28
    e50e:	00 d0       	rcall	.+0      	; 0xe510 <rtc_init+0x6>
    e510:	00 d0       	rcall	.+0      	; 0xe512 <rtc_init+0x8>
    e512:	0f 92       	push	r0
    e514:	cd b7       	in	r28, 0x3d	; 61
    e516:	de b7       	in	r29, 0x3e	; 62
	tcontrol_RTC ctr;
	
	ctr.PWR=RTC_PWR(1,1);
    e518:	80 ec       	ldi	r24, 0xC0	; 192
    e51a:	8d 83       	std	Y+5, r24	; 0x05
	ctr.DTR=0;
    e51c:	1c 82       	std	Y+4, r1	; 0x04
	ctr.ATR=0;
    e51e:	1b 82       	std	Y+3, r1	; 0x03
	ctr.INT=RTC_INT(0,0);
    e520:	1a 82       	std	Y+2, r1	; 0x02
	ctr.BL =0x18;
    e522:	88 e1       	ldi	r24, 0x18	; 24
    e524:	89 83       	std	Y+1, r24	; 0x01
	write_control(ctr);
    e526:	48 e1       	ldi	r20, 0x18	; 24
    e528:	50 e0       	ldi	r21, 0x00	; 0
    e52a:	60 e0       	ldi	r22, 0x00	; 0
    e52c:	70 e0       	ldi	r23, 0x00	; 0
    e52e:	80 ec       	ldi	r24, 0xC0	; 192
    e530:	0e 94 54 72 	call	0xe4a8	; 0xe4a8 <write_control>
	
}
    e534:	0f 90       	pop	r0
    e536:	0f 90       	pop	r0
    e538:	0f 90       	pop	r0
    e53a:	0f 90       	pop	r0
    e53c:	0f 90       	pop	r0
    e53e:	cf 91       	pop	r28
    e540:	df 91       	pop	r29
    e542:	08 95       	ret

0000e544 <write_Fecha>:
	return rv;
}

/*****************************************************************************************************/
int16 write_Fecha(tFecha Fecha)
{
    e544:	ef 92       	push	r14
    e546:	ff 92       	push	r15
    e548:	0f 93       	push	r16
    e54a:	1f 93       	push	r17
    e54c:	df 93       	push	r29
    e54e:	cf 93       	push	r28
    e550:	cd b7       	in	r28, 0x3d	; 61
    e552:	de b7       	in	r29, 0x3e	; 62
    e554:	28 97       	sbiw	r28, 0x08	; 8
    e556:	0f b6       	in	r0, 0x3f	; 63
    e558:	f8 94       	cli
    e55a:	de bf       	out	0x3e, r29	; 62
    e55c:	0f be       	out	0x3f, r0	; 63
    e55e:	cd bf       	out	0x3d, r28	; 61
    e560:	29 83       	std	Y+1, r18	; 0x01
    e562:	3a 83       	std	Y+2, r19	; 0x02
    e564:	4b 83       	std	Y+3, r20	; 0x03
    e566:	5c 83       	std	Y+4, r21	; 0x04
    e568:	6d 83       	std	Y+5, r22	; 0x05
    e56a:	7e 83       	std	Y+6, r23	; 0x06
    e56c:	8f 83       	std	Y+7, r24	; 0x07
    e56e:	98 87       	std	Y+8, r25	; 0x08
	
	PAGE_SIZE=8;									/* El tamano de Pagina en los registros de Control*/
													/* CCR es de 8 bytes*/
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/
	
	rv=isl1207_write_Conf_SR();
    e570:	0e 94 f5 71 	call	0xe3ea	; 0xe3ea <isl1207_write_Conf_SR>
    e574:	9c 01       	movw	r18, r24
	
	if(rv)
    e576:	00 97       	sbiw	r24, 0x00	; 0
    e578:	79 f0       	breq	.+30     	; 0xe598 <write_Fecha+0x54>
	{
		/* 0x30 es el comienzo de la direccion en donde estasn los Registros del RTC*/
		rv= write_bytes_I2C(PAGE_SIZE,sla, 0x30, sizeof(tFecha),(uint8 *)&Fecha);
    e57a:	88 e0       	ldi	r24, 0x08	; 8
    e57c:	6e ed       	ldi	r22, 0xDE	; 222
    e57e:	20 e3       	ldi	r18, 0x30	; 48
    e580:	30 e0       	ldi	r19, 0x00	; 0
    e582:	40 e0       	ldi	r20, 0x00	; 0
    e584:	50 e0       	ldi	r21, 0x00	; 0
    e586:	08 e0       	ldi	r16, 0x08	; 8
    e588:	10 e0       	ldi	r17, 0x00	; 0
    e58a:	7e 01       	movw	r14, r28
    e58c:	08 94       	sec
    e58e:	e1 1c       	adc	r14, r1
    e590:	f1 1c       	adc	r15, r1
    e592:	0e 94 f0 70 	call	0xe1e0	; 0xe1e0 <write_bytes_I2C>
    e596:	9c 01       	movw	r18, r24
	}

	return rv;
}
    e598:	c9 01       	movw	r24, r18
    e59a:	28 96       	adiw	r28, 0x08	; 8
    e59c:	0f b6       	in	r0, 0x3f	; 63
    e59e:	f8 94       	cli
    e5a0:	de bf       	out	0x3e, r29	; 62
    e5a2:	0f be       	out	0x3f, r0	; 63
    e5a4:	cd bf       	out	0x3d, r28	; 61
    e5a6:	cf 91       	pop	r28
    e5a8:	df 91       	pop	r29
    e5aa:	1f 91       	pop	r17
    e5ac:	0f 91       	pop	r16
    e5ae:	ff 90       	pop	r15
    e5b0:	ef 90       	pop	r14
    e5b2:	08 95       	ret

0000e5b4 <Pose2rxTrayectoria>:
}

/*****************************************************************************************************/
/*Llena una trayectoria de un punto, para luego poder ejecutarla con teach_pendant_point() */
void Pose2rxTrayectoria(PoseRobot* EEpromPose)
{
    e5b4:	cf 93       	push	r28
    e5b6:	df 93       	push	r29
    e5b8:	ec 01       	movw	r28, r24

	
	if(FlagTrayecPuntook)
    e5ba:	80 91 0e 7c 	lds	r24, 0x7C0E
    e5be:	90 91 0f 7c 	lds	r25, 0x7C0F
    e5c2:	89 2b       	or	r24, r25
    e5c4:	31 f0       	breq	.+12     	; 0xe5d2 <Pose2rxTrayectoria+0x1e>
		free(Trajectoryvectorpunto.point);
    e5c6:	80 91 21 82 	lds	r24, 0x8221
    e5ca:	90 91 22 82 	lds	r25, 0x8222
    e5ce:	0e 94 aa 86 	call	0x10d54	; 0x10d54 <free>
	
	Trajectoryvectorpunto.point=(tpoint*)declarar(sizeof(tpoint));
    e5d2:	8d e3       	ldi	r24, 0x3D	; 61
    e5d4:	90 e0       	ldi	r25, 0x00	; 0
    e5d6:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    e5da:	fc 01       	movw	r30, r24
    e5dc:	90 93 22 82 	sts	0x8222, r25
    e5e0:	80 93 21 82 	sts	0x8221, r24
	Trajectoryvectorpunto.size=1;
    e5e4:	21 e0       	ldi	r18, 0x01	; 1
    e5e6:	30 e0       	ldi	r19, 0x00	; 0
    e5e8:	30 93 1e 82 	sts	0x821E, r19
    e5ec:	20 93 1d 82 	sts	0x821D, r18
	/* se habilitan todos los ejes para el movimiento*/
	Trajectoryvectorpunto.invalidmask=0x1F; 
    e5f0:	8f e1       	ldi	r24, 0x1F	; 31
    e5f2:	90 e0       	ldi	r25, 0x00	; 0
    e5f4:	90 93 20 82 	sts	0x8220, r25
    e5f8:	80 93 1f 82 	sts	0x821F, r24
	
	/*Velocidades tomadas de homeVelocity, no se modifico tAxisSettings
		para evitar problemas con la memoria.*/
	Trajectoryvectorpunto.point[0].axis[AxisWaist].position=EEpromPose->Pos_Waist;	
    e5fc:	8a 81       	ldd	r24, Y+2	; 0x02
    e5fe:	9b 81       	ldd	r25, Y+3	; 0x03
    e600:	ac 81       	ldd	r26, Y+4	; 0x04
    e602:	bd 81       	ldd	r27, Y+5	; 0x05
    e604:	80 83       	st	Z, r24
    e606:	91 83       	std	Z+1, r25	; 0x01
    e608:	a2 83       	std	Z+2, r26	; 0x02
    e60a:	b3 83       	std	Z+3, r27	; 0x03
	Trajectoryvectorpunto.point[0].axis[AxisWaist].velocity=//155945;//70/seg;
    e60c:	80 91 b4 7d 	lds	r24, 0x7DB4
    e610:	90 91 b5 7d 	lds	r25, 0x7DB5
    e614:	a0 91 b6 7d 	lds	r26, 0x7DB6
    e618:	b0 91 b7 7d 	lds	r27, 0x7DB7
    e61c:	84 83       	std	Z+4, r24	; 0x04
    e61e:	95 83       	std	Z+5, r25	; 0x05
    e620:	a6 83       	std	Z+6, r26	; 0x06
    e622:	b7 83       	std	Z+7, r27	; 0x07
	hAxis[AxisWaist].axisSettings.homeVelocity;
	Trajectoryvectorpunto.point[0].axis[AxisWaist].acceleration=//80;//60
    e624:	80 91 b8 7d 	lds	r24, 0x7DB8
    e628:	90 91 b9 7d 	lds	r25, 0x7DB9
    e62c:	a0 91 ba 7d 	lds	r26, 0x7DBA
    e630:	b0 91 bb 7d 	lds	r27, 0x7DBB
    e634:	80 87       	std	Z+8, r24	; 0x08
    e636:	91 87       	std	Z+9, r25	; 0x09
    e638:	a2 87       	std	Z+10, r26	; 0x0a
    e63a:	b3 87       	std	Z+11, r27	; 0x0b
	hAxis[AxisWaist].axisSettings.homeAcceleration;
	
	Trajectoryvectorpunto.point[0].axis[AxisShoulder].position=EEpromPose->Pos_Shoulder;
    e63c:	8e 81       	ldd	r24, Y+6	; 0x06
    e63e:	9f 81       	ldd	r25, Y+7	; 0x07
    e640:	a8 85       	ldd	r26, Y+8	; 0x08
    e642:	b9 85       	ldd	r27, Y+9	; 0x09
    e644:	84 87       	std	Z+12, r24	; 0x0c
    e646:	95 87       	std	Z+13, r25	; 0x0d
    e648:	a6 87       	std	Z+14, r26	; 0x0e
    e64a:	b7 87       	std	Z+15, r27	; 0x0f
	Trajectoryvectorpunto.point[0].axis[AxisShoulder].velocity=//1151798; //7/seg
    e64c:	80 91 14 7e 	lds	r24, 0x7E14
    e650:	90 91 15 7e 	lds	r25, 0x7E15
    e654:	a0 91 16 7e 	lds	r26, 0x7E16
    e658:	b0 91 17 7e 	lds	r27, 0x7E17
    e65c:	80 8b       	std	Z+16, r24	; 0x10
    e65e:	91 8b       	std	Z+17, r25	; 0x11
    e660:	a2 8b       	std	Z+18, r26	; 0x12
    e662:	b3 8b       	std	Z+19, r27	; 0x13
	hAxis[AxisShoulder].axisSettings.homeVelocity;
	Trajectoryvectorpunto.point[0].axis[AxisShoulder].acceleration=//395; //4
    e664:	80 91 18 7e 	lds	r24, 0x7E18
    e668:	90 91 19 7e 	lds	r25, 0x7E19
    e66c:	a0 91 1a 7e 	lds	r26, 0x7E1A
    e670:	b0 91 1b 7e 	lds	r27, 0x7E1B
    e674:	84 8b       	std	Z+20, r24	; 0x14
    e676:	95 8b       	std	Z+21, r25	; 0x15
    e678:	a6 8b       	std	Z+22, r26	; 0x16
    e67a:	b7 8b       	std	Z+23, r27	; 0x17
	hAxis[AxisShoulder].axisSettings.homeAcceleration;
	
	Trajectoryvectorpunto.point[0].axis[AxisElbow].position=EEpromPose->Pos_Elbow;
    e67c:	8a 85       	ldd	r24, Y+10	; 0x0a
    e67e:	9b 85       	ldd	r25, Y+11	; 0x0b
    e680:	ac 85       	ldd	r26, Y+12	; 0x0c
    e682:	bd 85       	ldd	r27, Y+13	; 0x0d
    e684:	80 8f       	std	Z+24, r24	; 0x18
    e686:	91 8f       	std	Z+25, r25	; 0x19
    e688:	a2 8f       	std	Z+26, r26	; 0x1a
    e68a:	b3 8f       	std	Z+27, r27	; 0x1b
	Trajectoryvectorpunto.point[0].axis[AxisElbow].velocity=//1151798;
    e68c:	80 91 74 7e 	lds	r24, 0x7E74
    e690:	90 91 75 7e 	lds	r25, 0x7E75
    e694:	a0 91 76 7e 	lds	r26, 0x7E76
    e698:	b0 91 77 7e 	lds	r27, 0x7E77
    e69c:	84 8f       	std	Z+28, r24	; 0x1c
    e69e:	95 8f       	std	Z+29, r25	; 0x1d
    e6a0:	a6 8f       	std	Z+30, r26	; 0x1e
    e6a2:	b7 8f       	std	Z+31, r27	; 0x1f
	hAxis[AxisElbow].axisSettings.homeVelocity;
	Trajectoryvectorpunto.point[0].axis[AxisElbow].acceleration=//395;
    e6a4:	80 91 78 7e 	lds	r24, 0x7E78
    e6a8:	90 91 79 7e 	lds	r25, 0x7E79
    e6ac:	a0 91 7a 7e 	lds	r26, 0x7E7A
    e6b0:	b0 91 7b 7e 	lds	r27, 0x7E7B
    e6b4:	80 a3       	std	Z+32, r24	; 0x20
    e6b6:	91 a3       	std	Z+33, r25	; 0x21
    e6b8:	a2 a3       	std	Z+34, r26	; 0x22
    e6ba:	b3 a3       	std	Z+35, r27	; 0x23
	hAxis[AxisElbow].axisSettings.homeAcceleration;
	
	Trajectoryvectorpunto.point[0].axis[AxisPitch].position=EEpromPose->Pos_Pitch;
    e6bc:	8e 85       	ldd	r24, Y+14	; 0x0e
    e6be:	9f 85       	ldd	r25, Y+15	; 0x0f
    e6c0:	a8 89       	ldd	r26, Y+16	; 0x10
    e6c2:	b9 89       	ldd	r27, Y+17	; 0x11
    e6c4:	84 a3       	std	Z+36, r24	; 0x24
    e6c6:	95 a3       	std	Z+37, r25	; 0x25
    e6c8:	a6 a3       	std	Z+38, r26	; 0x26
    e6ca:	b7 a3       	std	Z+39, r27	; 0x27
	Trajectoryvectorpunto.point[0].axis[AxisPitch].velocity=//108158;
    e6cc:	80 91 b4 7d 	lds	r24, 0x7DB4
    e6d0:	90 91 b5 7d 	lds	r25, 0x7DB5
    e6d4:	a0 91 b6 7d 	lds	r26, 0x7DB6
    e6d8:	b0 91 b7 7d 	lds	r27, 0x7DB7
    e6dc:	80 a7       	std	Z+40, r24	; 0x28
    e6de:	91 a7       	std	Z+41, r25	; 0x29
    e6e0:	a2 a7       	std	Z+42, r26	; 0x2a
    e6e2:	b3 a7       	std	Z+43, r27	; 0x2b
	hAxis[AxisWaist].axisSettings.homeVelocity;
	Trajectoryvectorpunto.point[0].axis[AxisPitch].acceleration=//49;
    e6e4:	80 91 b8 7d 	lds	r24, 0x7DB8
    e6e8:	90 91 b9 7d 	lds	r25, 0x7DB9
    e6ec:	a0 91 ba 7d 	lds	r26, 0x7DBA
    e6f0:	b0 91 bb 7d 	lds	r27, 0x7DBB
    e6f4:	84 a7       	std	Z+44, r24	; 0x2c
    e6f6:	95 a7       	std	Z+45, r25	; 0x2d
    e6f8:	a6 a7       	std	Z+46, r26	; 0x2e
    e6fa:	b7 a7       	std	Z+47, r27	; 0x2f
	hAxis[AxisWaist].axisSettings.homeAcceleration;
	
	Trajectoryvectorpunto.point[0].axis[AxisRoll].position=EEpromPose->Pos_Roll;
    e6fc:	8a 89       	ldd	r24, Y+18	; 0x12
    e6fe:	9b 89       	ldd	r25, Y+19	; 0x13
    e700:	ac 89       	ldd	r26, Y+20	; 0x14
    e702:	bd 89       	ldd	r27, Y+21	; 0x15
    e704:	80 ab       	std	Z+48, r24	; 0x30
    e706:	91 ab       	std	Z+49, r25	; 0x31
    e708:	a2 ab       	std	Z+50, r26	; 0x32
    e70a:	b3 ab       	std	Z+51, r27	; 0x33
	Trajectoryvectorpunto.point[0].axis[AxisRoll].velocity=//111316;   // 150000
    e70c:	80 91 34 7f 	lds	r24, 0x7F34
    e710:	90 91 35 7f 	lds	r25, 0x7F35
    e714:	a0 91 36 7f 	lds	r26, 0x7F36
    e718:	b0 91 37 7f 	lds	r27, 0x7F37
    e71c:	84 ab       	std	Z+52, r24	; 0x34
    e71e:	95 ab       	std	Z+53, r25	; 0x35
    e720:	a6 ab       	std	Z+54, r26	; 0x36
    e722:	b7 ab       	std	Z+55, r27	; 0x37
	hAxis[AxisRoll].axisSettings.homeVelocity;
	Trajectoryvectorpunto.point[0].axis[AxisRoll].acceleration=//33;  // 100
    e724:	80 91 38 7f 	lds	r24, 0x7F38
    e728:	90 91 39 7f 	lds	r25, 0x7F39
    e72c:	a0 91 3a 7f 	lds	r26, 0x7F3A
    e730:	b0 91 3b 7f 	lds	r27, 0x7F3B
    e734:	80 af       	std	Z+56, r24	; 0x38
    e736:	91 af       	std	Z+57, r25	; 0x39
    e738:	a2 af       	std	Z+58, r26	; 0x3a
    e73a:	b3 af       	std	Z+59, r27	; 0x3b
	hAxis[AxisRoll].axisSettings.homeAcceleration;
	
	FlagTrayecPuntook=1;
    e73c:	30 93 0f 7c 	sts	0x7C0F, r19
    e740:	20 93 0e 7c 	sts	0x7C0E, r18
	
}
    e744:	df 91       	pop	r29
    e746:	cf 91       	pop	r28
    e748:	08 95       	ret

0000e74a <BorrarEEPROM>:
	return 1;	
}

/*****************************************************************************************************/
int16 BorrarEEPROM(void)
{
    e74a:	df 93       	push	r29
    e74c:	cf 93       	push	r28
    e74e:	00 d0       	rcall	.+0      	; 0xe750 <BorrarEEPROM+0x6>
    e750:	cd b7       	in	r28, 0x3d	; 61
    e752:	de b7       	in	r29, 0x3e	; 62
	uint16 Num_Poses;
	int16 rv;
   
	Num_Poses=0;
    e754:	1a 82       	std	Y+2, r1	; 0x02
    e756:	19 82       	std	Y+1, r1	; 0x01
	
	/* actualizo Num_Poses */
	rv=ee24xx_write_bytes(0,sizeof(uint16),(uint8 *)&Num_Poses);	
    e758:	60 e0       	ldi	r22, 0x00	; 0
    e75a:	70 e0       	ldi	r23, 0x00	; 0
    e75c:	80 e0       	ldi	r24, 0x00	; 0
    e75e:	90 e0       	ldi	r25, 0x00	; 0
    e760:	42 e0       	ldi	r20, 0x02	; 2
    e762:	50 e0       	ldi	r21, 0x00	; 0
    e764:	9e 01       	movw	r18, r28
    e766:	2f 5f       	subi	r18, 0xFF	; 255
    e768:	3f 4f       	sbci	r19, 0xFF	; 255
    e76a:	0e 94 3f 71 	call	0xe27e	; 0xe27e <ee24xx_write_bytes>
		printf("BorrarEEPROM=> Numero de BYTES ledos corectamente en BorrarEErom => %d\n",rv);
		printf("BorrarEEPROM=> Num_Poses = %x\n",Num_Poses);
   #endif

return rv;
}
    e76e:	0f 90       	pop	r0
    e770:	0f 90       	pop	r0
    e772:	cf 91       	pop	r28
    e774:	df 91       	pop	r29
    e776:	08 95       	ret

0000e778 <Get_Num_Poses>:
	/*Utilizada para acceder a la informacion de moviento velocidades y aceleraciones max */
	extern PMDAxisHandle hAxis[DOF]; 

/*****************************************************************************************************/
int16 Get_Num_Poses(void)
{
    e778:	df 93       	push	r29
    e77a:	cf 93       	push	r28
    e77c:	00 d0       	rcall	.+0      	; 0xe77e <Get_Num_Poses+0x6>
    e77e:	cd b7       	in	r28, 0x3d	; 61
    e780:	de b7       	in	r29, 0x3e	; 62
	int16 Cpuntos=-1;
    e782:	8f ef       	ldi	r24, 0xFF	; 255
    e784:	9f ef       	ldi	r25, 0xFF	; 255
    e786:	9a 83       	std	Y+2, r25	; 0x02
    e788:	89 83       	std	Y+1, r24	; 0x01
	int16 rv=-1;
   
	rv=ee24xx_read_bytes(0,sizeof(int16),(uint8 *)&Cpuntos);
    e78a:	60 e0       	ldi	r22, 0x00	; 0
    e78c:	70 e0       	ldi	r23, 0x00	; 0
    e78e:	80 e0       	ldi	r24, 0x00	; 0
    e790:	90 e0       	ldi	r25, 0x00	; 0
    e792:	42 e0       	ldi	r20, 0x02	; 2
    e794:	50 e0       	ldi	r21, 0x00	; 0
    e796:	9e 01       	movw	r18, r28
    e798:	2f 5f       	subi	r18, 0xFF	; 255
    e79a:	3f 4f       	sbci	r19, 0xFF	; 255
    e79c:	0e 94 6a 71 	call	0xe2d4	; 0xe2d4 <ee24xx_read_bytes>
    e7a0:	9c 01       	movw	r18, r24
	
	if(rv)
    e7a2:	00 97       	sbiw	r24, 0x00	; 0
    e7a4:	39 f0       	breq	.+14     	; 0xe7b4 <Get_Num_Poses+0x3c>
	{
		#ifdef DEBUGTWI
			printf("Get_Num_Poses=> Cpuntos= %d\n",Cpuntos);
		#endif
		if(Cpuntos< MAX_POSES)
    e7a6:	89 81       	ldd	r24, Y+1	; 0x01
    e7a8:	9a 81       	ldd	r25, Y+2	; 0x02
    e7aa:	46 e1       	ldi	r20, 0x16	; 22
    e7ac:	80 34       	cpi	r24, 0x40	; 64
    e7ae:	94 07       	cpc	r25, r20
    e7b0:	0c f4       	brge	.+2      	; 0xe7b4 <Get_Num_Poses+0x3c>
    e7b2:	9c 01       	movw	r18, r24
			return Cpuntos;
	}

	return rv;
}
    e7b4:	c9 01       	movw	r24, r18
    e7b6:	0f 90       	pop	r0
    e7b8:	0f 90       	pop	r0
    e7ba:	cf 91       	pop	r28
    e7bc:	df 91       	pop	r29
    e7be:	08 95       	ret

0000e7c0 <Adicionar_PoseTWI>:
	return -1;	
	
}
/*****************************************************************************************************/
int16 Adicionar_PoseTWI(PoseRobot Pose)
{
    e7c0:	0f 93       	push	r16
    e7c2:	1f 93       	push	r17
    e7c4:	df 93       	push	r29
    e7c6:	cf 93       	push	r28
    e7c8:	00 d0       	rcall	.+0      	; 0xe7ca <Adicionar_PoseTWI+0xa>
    e7ca:	cd b7       	in	r28, 0x3d	; 61
    e7cc:	de b7       	in	r29, 0x3e	; 62
	int16 Num_Poses;
	
	
	
    /*Se obtiene el numero total de poses que hay en la memoria EEPROM*/
	Num_Poses=Get_Num_Poses();
    e7ce:	0e 94 bc 73 	call	0xe778	; 0xe778 <Get_Num_Poses>
    e7d2:	8c 01       	movw	r16, r24
	#ifdef DEBUGTWI
		printf("Adicionar_PoseTWI=> Numero Poses grabadas Adicionar_PoseTWI => %x\n",Num_Poses);
	#endif

	if(Num_Poses!=-1)
    e7d4:	8f ef       	ldi	r24, 0xFF	; 255
    e7d6:	0f 3f       	cpi	r16, 0xFF	; 255
    e7d8:	18 07       	cpc	r17, r24
    e7da:	19 f4       	brne	.+6      	; 0xe7e2 <Adicionar_PoseTWI+0x22>
    e7dc:	2f ef       	ldi	r18, 0xFF	; 255
    e7de:	3f ef       	ldi	r19, 0xFF	; 255
    e7e0:	38 c0       	rjmp	.+112    	; 0xe852 <Adicionar_PoseTWI+0x92>
	{   
		/* Num_Poses Es el numero de Poses. Cada Pose Empieza en 1 hasta MAX_Poses*/
		/*La addr no depende del ID*/
		addr=(int32)(Num_Poses)*sizeof(PoseRobot)+sizeof(int16); 
    e7e2:	b8 01       	movw	r22, r16
    e7e4:	88 27       	eor	r24, r24
    e7e6:	77 fd       	sbrc	r23, 7
    e7e8:	80 95       	com	r24
    e7ea:	98 2f       	mov	r25, r24
    e7ec:	27 e1       	ldi	r18, 0x17	; 23
    e7ee:	30 e0       	ldi	r19, 0x00	; 0
    e7f0:	40 e0       	ldi	r20, 0x00	; 0
    e7f2:	50 e0       	ldi	r21, 0x00	; 0
    e7f4:	0e 94 6e 85 	call	0x10adc	; 0x10adc <__mulsi3>
    e7f8:	9b 01       	movw	r18, r22
    e7fa:	ac 01       	movw	r20, r24
    e7fc:	6e 5f       	subi	r22, 0xFE	; 254
    e7fe:	7f 4f       	sbci	r23, 0xFF	; 255
    e800:	8f 4f       	sbci	r24, 0xFF	; 255
    e802:	9f 4f       	sbci	r25, 0xFF	; 255
		#ifdef DEBUGTWI
			printf("Adicionar_PoseTWI=> direccion actual en donde grabo la Pose => %lx\n",addr);
		#endif
			
		/*Pasar al Segundo Banco de Memoria */
		if(Num_Poses > (MAX_POSES/2))
    e804:	eb e0       	ldi	r30, 0x0B	; 11
    e806:	01 32       	cpi	r16, 0x21	; 33
    e808:	1e 07       	cpc	r17, r30
    e80a:	34 f0       	brlt	.+12     	; 0xe818 <Adicionar_PoseTWI+0x58>
			addr=addr+ADD_NUM;
    e80c:	ca 01       	movw	r24, r20
    e80e:	b9 01       	movw	r22, r18
    e810:	67 5f       	subi	r22, 0xF7	; 247
    e812:	7f 4f       	sbci	r23, 0xFF	; 255
    e814:	8f 4f       	sbci	r24, 0xFF	; 255
    e816:	9f 4f       	sbci	r25, 0xFF	; 255
	int16 Num_Poses;
	
	
	
    /*Se obtiene el numero total de poses que hay en la memoria EEPROM*/
	Num_Poses=Get_Num_Poses();
    e818:	1a 83       	std	Y+2, r17	; 0x02
    e81a:	09 83       	std	Y+1, r16	; 0x01
		/*Pasar al Segundo Banco de Memoria */
		if(Num_Poses > (MAX_POSES/2))
			addr=addr+ADD_NUM;
		
		/* grabando pose*/
		rv=ee24xx_write_bytes(addr,sizeof(PoseRobot),(uint8 *)&Pose);	
    e81c:	47 e1       	ldi	r20, 0x17	; 23
    e81e:	50 e0       	ldi	r21, 0x00	; 0
    e820:	9e 01       	movw	r18, r28
    e822:	27 5f       	subi	r18, 0xF7	; 247
    e824:	3f 4f       	sbci	r19, 0xFF	; 255
    e826:	0e 94 3f 71 	call	0xe27e	; 0xe27e <ee24xx_write_bytes>
    e82a:	9c 01       	movw	r18, r24
		#ifdef DEBUGTWI
			printf("Adicionar_PoseTWI=> Numero de datos grabados corectamente al grabar Pose => %d\n",rv);
		#endif
		
		if(rv)
    e82c:	00 97       	sbiw	r24, 0x00	; 0
    e82e:	89 f0       	breq	.+34     	; 0xe852 <Adicionar_PoseTWI+0x92>
		{
			Num_Poses++;
    e830:	89 81       	ldd	r24, Y+1	; 0x01
    e832:	9a 81       	ldd	r25, Y+2	; 0x02
    e834:	01 96       	adiw	r24, 0x01	; 1
    e836:	9a 83       	std	Y+2, r25	; 0x02
    e838:	89 83       	std	Y+1, r24	; 0x01
			
			/*Se Actualiza el Numero de Poses Escritas en EEPROM*/
			rv=ee24xx_write_bytes(0,sizeof(int16),(uint8 *)&Num_Poses);	
    e83a:	60 e0       	ldi	r22, 0x00	; 0
    e83c:	70 e0       	ldi	r23, 0x00	; 0
    e83e:	80 e0       	ldi	r24, 0x00	; 0
    e840:	90 e0       	ldi	r25, 0x00	; 0
    e842:	42 e0       	ldi	r20, 0x02	; 2
    e844:	50 e0       	ldi	r21, 0x00	; 0
    e846:	9e 01       	movw	r18, r28
    e848:	2f 5f       	subi	r18, 0xFF	; 255
    e84a:	3f 4f       	sbci	r19, 0xFF	; 255
    e84c:	0e 94 3f 71 	call	0xe27e	; 0xe27e <ee24xx_write_bytes>
    e850:	9c 01       	movw	r18, r24
			#endif		
		}		
	}
	
	return rv;
}
    e852:	c9 01       	movw	r24, r18
    e854:	0f 90       	pop	r0
    e856:	0f 90       	pop	r0
    e858:	cf 91       	pop	r28
    e85a:	df 91       	pop	r29
    e85c:	1f 91       	pop	r17
    e85e:	0f 91       	pop	r16
    e860:	08 95       	ret

0000e862 <return_id_vector>:

}

/*****************************************************************************************************/
int16 return_id_vector(void)
{
    e862:	8f 92       	push	r8
    e864:	9f 92       	push	r9
    e866:	af 92       	push	r10
    e868:	bf 92       	push	r11
    e86a:	cf 92       	push	r12
    e86c:	df 92       	push	r13
    e86e:	ef 92       	push	r14
    e870:	ff 92       	push	r15
    e872:	0f 93       	push	r16
    e874:	1f 93       	push	r17
    e876:	df 93       	push	r29
    e878:	cf 93       	push	r28
    e87a:	00 d0       	rcall	.+0      	; 0xe87c <return_id_vector+0x1a>
    e87c:	cd b7       	in	r28, 0x3d	; 61
    e87e:	de b7       	in	r29, 0x3e	; 62
	int16 Num_Poses;
	int16 id_actual=-1;
    e880:	0f ef       	ldi	r16, 0xFF	; 255
    e882:	1f ef       	ldi	r17, 0xFF	; 255
    e884:	1a 83       	std	Y+2, r17	; 0x02
    e886:	09 83       	std	Y+1, r16	; 0x01
	int32 addr; 	
	int16 i,rv=-1;
  
	/*Se Determina la cantidad de Poses en EEPROM*/	
	Num_Poses = Get_Num_Poses();
    e888:	0e 94 bc 73 	call	0xe778	; 0xe778 <Get_Num_Poses>
    e88c:	5c 01       	movw	r10, r24
	
	if (Num_Poses >=1)
    e88e:	18 16       	cp	r1, r24
    e890:	19 06       	cpc	r1, r25
    e892:	0c f0       	brlt	.+2      	; 0xe896 <return_id_vector+0x34>
    e894:	48 c0       	rjmp	.+144    	; 0xe926 <return_id_vector+0xc4>
	{	
		id_vector = declarar(sizeof(uint16)*(Num_Poses+1));
    e896:	8c 01       	movw	r16, r24
    e898:	0f 5f       	subi	r16, 0xFF	; 255
    e89a:	1f 4f       	sbci	r17, 0xFF	; 255
    e89c:	c8 01       	movw	r24, r16
    e89e:	88 0f       	add	r24, r24
    e8a0:	99 1f       	adc	r25, r25
    e8a2:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    e8a6:	fc 01       	movw	r30, r24
    e8a8:	90 93 24 82 	sts	0x8224, r25
    e8ac:	80 93 23 82 	sts	0x8223, r24
		id_vector[0]=Num_Poses+1;
    e8b0:	11 83       	std	Z+1, r17	; 0x01
    e8b2:	00 83       	st	Z, r16
    e8b4:	00 e0       	ldi	r16, 0x00	; 0
    e8b6:	10 e0       	ldi	r17, 0x00	; 0
    e8b8:	92 e0       	ldi	r25, 0x02	; 2
    e8ba:	c9 2e       	mov	r12, r25
    e8bc:	d1 2c       	mov	r13, r1
    e8be:	82 e0       	ldi	r24, 0x02	; 2
    e8c0:	e8 2e       	mov	r14, r24
    e8c2:	f1 2c       	mov	r15, r1
			
			/*Pasar al Segundo Banco de Memoria */
			if(i > (MAX_POSES/2))
				addr=addr+ ADD_NUM;
		 
			rv=ee24xx_read_bytes(addr,sizeof(uint16),(uint8*) &id_actual);			
    e8c4:	4e 01       	movw	r8, r28
    e8c6:	08 94       	sec
    e8c8:	81 1c       	adc	r8, r1
    e8ca:	91 1c       	adc	r9, r1
		
		for (i=0;i<Num_Poses;i++)
		{
			
			/*Direccion de Comienzo de cada Pose*/
			addr= (int32) ((i)*sizeof(PoseRobot)+sizeof(int16)); 
    e8cc:	b6 01       	movw	r22, r12
    e8ce:	80 e0       	ldi	r24, 0x00	; 0
    e8d0:	90 e0       	ldi	r25, 0x00	; 0
			
			/*Pasar al Segundo Banco de Memoria */
			if(i > (MAX_POSES/2))
    e8d2:	2b e0       	ldi	r18, 0x0B	; 11
    e8d4:	01 32       	cpi	r16, 0x21	; 33
    e8d6:	12 07       	cpc	r17, r18
    e8d8:	24 f0       	brlt	.+8      	; 0xe8e2 <return_id_vector+0x80>
				addr=addr+ ADD_NUM;
    e8da:	69 5f       	subi	r22, 0xF9	; 249
    e8dc:	7f 4f       	sbci	r23, 0xFF	; 255
    e8de:	8f 4f       	sbci	r24, 0xFF	; 255
    e8e0:	9f 4f       	sbci	r25, 0xFF	; 255
		 
			rv=ee24xx_read_bytes(addr,sizeof(uint16),(uint8*) &id_actual);			
    e8e2:	42 e0       	ldi	r20, 0x02	; 2
    e8e4:	50 e0       	ldi	r21, 0x00	; 0
    e8e6:	94 01       	movw	r18, r8
    e8e8:	0e 94 6a 71 	call	0xe2d4	; 0xe2d4 <ee24xx_read_bytes>
    e8ec:	9c 01       	movw	r18, r24
			
			if(rv)
    e8ee:	00 97       	sbiw	r24, 0x00	; 0
    e8f0:	59 f1       	breq	.+86     	; 0xe948 <return_id_vector+0xe6>
			{
				id_vector[i+1]=id_actual;
    e8f2:	e0 91 23 82 	lds	r30, 0x8223
    e8f6:	f0 91 24 82 	lds	r31, 0x8224
    e8fa:	ee 0d       	add	r30, r14
    e8fc:	ff 1d       	adc	r31, r15
    e8fe:	89 81       	ldd	r24, Y+1	; 0x01
    e900:	9a 81       	ldd	r25, Y+2	; 0x02
    e902:	91 83       	std	Z+1, r25	; 0x01
    e904:	80 83       	st	Z, r24
	if (Num_Poses >=1)
	{	
		id_vector = declarar(sizeof(uint16)*(Num_Poses+1));
		id_vector[0]=Num_Poses+1;
		
		for (i=0;i<Num_Poses;i++)
    e906:	0f 5f       	subi	r16, 0xFF	; 255
    e908:	1f 4f       	sbci	r17, 0xFF	; 255
    e90a:	87 e1       	ldi	r24, 0x17	; 23
    e90c:	90 e0       	ldi	r25, 0x00	; 0
    e90e:	c8 0e       	add	r12, r24
    e910:	d9 1e       	adc	r13, r25
    e912:	82 e0       	ldi	r24, 0x02	; 2
    e914:	90 e0       	ldi	r25, 0x00	; 0
    e916:	e8 0e       	add	r14, r24
    e918:	f9 1e       	adc	r15, r25
    e91a:	0a 15       	cp	r16, r10
    e91c:	1b 05       	cpc	r17, r11
    e91e:	b4 f2       	brlt	.-84     	; 0xe8cc <return_id_vector+0x6a>
    e920:	21 e0       	ldi	r18, 0x01	; 1
    e922:	30 e0       	ldi	r19, 0x00	; 0
    e924:	11 c0       	rjmp	.+34     	; 0xe948 <return_id_vector+0xe6>
				return rv; 								/* Error en la Lectura*/
		}
	}
	else
	{
		id_vector = declarar(sizeof(uint16)*(2));
    e926:	84 e0       	ldi	r24, 0x04	; 4
    e928:	90 e0       	ldi	r25, 0x00	; 0
    e92a:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    e92e:	fc 01       	movw	r30, r24
    e930:	90 93 24 82 	sts	0x8224, r25
    e934:	80 93 23 82 	sts	0x8223, r24
		id_vector[0]=2;
    e938:	82 e0       	ldi	r24, 0x02	; 2
    e93a:	90 e0       	ldi	r25, 0x00	; 0
    e93c:	91 83       	std	Z+1, r25	; 0x01
    e93e:	80 83       	st	Z, r24
		id_vector[1]=-1;
    e940:	13 83       	std	Z+3, r17	; 0x03
    e942:	02 83       	std	Z+2, r16	; 0x02
    e944:	20 e0       	ldi	r18, 0x00	; 0
    e946:	30 e0       	ldi	r19, 0x00	; 0
		return 0;										/* No hay Poses*/
	}

	return 1;	
}
    e948:	c9 01       	movw	r24, r18
    e94a:	0f 90       	pop	r0
    e94c:	0f 90       	pop	r0
    e94e:	cf 91       	pop	r28
    e950:	df 91       	pop	r29
    e952:	1f 91       	pop	r17
    e954:	0f 91       	pop	r16
    e956:	ff 90       	pop	r15
    e958:	ef 90       	pop	r14
    e95a:	df 90       	pop	r13
    e95c:	cf 90       	pop	r12
    e95e:	bf 90       	pop	r11
    e960:	af 90       	pop	r10
    e962:	9f 90       	pop	r9
    e964:	8f 90       	pop	r8
    e966:	08 95       	ret

0000e968 <Found_Id>:

	return rv;
}
/*****************************************************************************************************/
int32 Found_Id(uint16 id)
{
    e968:	4f 92       	push	r4
    e96a:	5f 92       	push	r5
    e96c:	6f 92       	push	r6
    e96e:	7f 92       	push	r7
    e970:	8f 92       	push	r8
    e972:	9f 92       	push	r9
    e974:	af 92       	push	r10
    e976:	bf 92       	push	r11
    e978:	cf 92       	push	r12
    e97a:	df 92       	push	r13
    e97c:	ef 92       	push	r14
    e97e:	ff 92       	push	r15
    e980:	0f 93       	push	r16
    e982:	1f 93       	push	r17
    e984:	df 93       	push	r29
    e986:	cf 93       	push	r28
    e988:	00 d0       	rcall	.+0      	; 0xe98a <Found_Id+0x22>
    e98a:	cd b7       	in	r28, 0x3d	; 61
    e98c:	de b7       	in	r29, 0x3e	; 62
    e98e:	3c 01       	movw	r6, r24
	int16 id_actual=-1;
    e990:	8f ef       	ldi	r24, 0xFF	; 255
    e992:	9f ef       	ldi	r25, 0xFF	; 255
    e994:	9a 83       	std	Y+2, r25	; 0x02
    e996:	89 83       	std	Y+1, r24	; 0x01
	
	
	
	/*Se Determina la cantidad de Poses en EEPROM*/
	
	Num_Poses = Get_Num_Poses();
    e998:	0e 94 bc 73 	call	0xe778	; 0xe778 <Get_Num_Poses>
    e99c:	4c 01       	movw	r8, r24
	
	if(Num_Poses >= 1)
    e99e:	18 16       	cp	r1, r24
    e9a0:	19 06       	cpc	r1, r25
    e9a2:	ac f5       	brge	.+106    	; 0xea0e <Found_Id+0xa6>
    e9a4:	cc 24       	eor	r12, r12
    e9a6:	dd 24       	eor	r13, r13
    e9a8:	32 e0       	ldi	r19, 0x02	; 2
    e9aa:	a3 2e       	mov	r10, r19
    e9ac:	b1 2c       	mov	r11, r1
			addr= (int32) ((i)*sizeof(PoseRobot)+sizeof(int16)); 
			
			if(i > (MAX_POSES/2))
				addr=addr+ ADD_NUM;
		 
			rv=ee24xx_read_bytes(addr,sizeof(uint16),(uint8*) &id_actual);
    e9ae:	2e 01       	movw	r4, r28
    e9b0:	08 94       	sec
    e9b2:	41 1c       	adc	r4, r1
    e9b4:	51 1c       	adc	r5, r1
	if(Num_Poses >= 1)
	{
		for (i=0;i< Num_Poses ;i++)
	    {
			/*Direccion de Comienzo de cada Pose*/
			addr= (int32) ((i)*sizeof(PoseRobot)+sizeof(int16)); 
    e9b6:	75 01       	movw	r14, r10
    e9b8:	00 e0       	ldi	r16, 0x00	; 0
    e9ba:	10 e0       	ldi	r17, 0x00	; 0
			
			if(i > (MAX_POSES/2))
    e9bc:	21 e2       	ldi	r18, 0x21	; 33
    e9be:	c2 16       	cp	r12, r18
    e9c0:	2b e0       	ldi	r18, 0x0B	; 11
    e9c2:	d2 06       	cpc	r13, r18
    e9c4:	44 f0       	brlt	.+16     	; 0xe9d6 <Found_Id+0x6e>
				addr=addr+ ADD_NUM;
    e9c6:	87 e0       	ldi	r24, 0x07	; 7
    e9c8:	90 e0       	ldi	r25, 0x00	; 0
    e9ca:	a0 e0       	ldi	r26, 0x00	; 0
    e9cc:	b0 e0       	ldi	r27, 0x00	; 0
    e9ce:	e8 0e       	add	r14, r24
    e9d0:	f9 1e       	adc	r15, r25
    e9d2:	0a 1f       	adc	r16, r26
    e9d4:	1b 1f       	adc	r17, r27
		 
			rv=ee24xx_read_bytes(addr,sizeof(uint16),(uint8*) &id_actual);
    e9d6:	c8 01       	movw	r24, r16
    e9d8:	b7 01       	movw	r22, r14
    e9da:	42 e0       	ldi	r20, 0x02	; 2
    e9dc:	50 e0       	ldi	r21, 0x00	; 0
    e9de:	92 01       	movw	r18, r4
    e9e0:	0e 94 6a 71 	call	0xe2d4	; 0xe2d4 <ee24xx_read_bytes>
				printf("Found_Id=> i=%d \n",i);
				printf("Found_Id=> addr=%ld \n",addr);
				printf("Found_Id=> id_actual=%d \n",id_actual);
			#endif
			
			if(rv == -1)
    e9e4:	8f 5f       	subi	r24, 0xFF	; 255
    e9e6:	9f 4f       	sbci	r25, 0xFF	; 255
    e9e8:	91 f0       	breq	.+36     	; 0xea0e <Found_Id+0xa6>
				return rv;								/* Se Produce un Error*/
			
			if(id==id_actual)			
    e9ea:	89 81       	ldd	r24, Y+1	; 0x01
    e9ec:	9a 81       	ldd	r25, Y+2	; 0x02
    e9ee:	68 16       	cp	r6, r24
    e9f0:	79 06       	cpc	r7, r25
    e9f2:	19 f4       	brne	.+6      	; 0xe9fa <Found_Id+0x92>
    e9f4:	a8 01       	movw	r20, r16
    e9f6:	97 01       	movw	r18, r14
    e9f8:	0e c0       	rjmp	.+28     	; 0xea16 <Found_Id+0xae>
	
	Num_Poses = Get_Num_Poses();
	
	if(Num_Poses >= 1)
	{
		for (i=0;i< Num_Poses ;i++)
    e9fa:	08 94       	sec
    e9fc:	c1 1c       	adc	r12, r1
    e9fe:	d1 1c       	adc	r13, r1
    ea00:	87 e1       	ldi	r24, 0x17	; 23
    ea02:	90 e0       	ldi	r25, 0x00	; 0
    ea04:	a8 0e       	add	r10, r24
    ea06:	b9 1e       	adc	r11, r25
    ea08:	c8 14       	cp	r12, r8
    ea0a:	d9 04       	cpc	r13, r9
    ea0c:	a4 f2       	brlt	.-88     	; 0xe9b6 <Found_Id+0x4e>
    ea0e:	2f ef       	ldi	r18, 0xFF	; 255
    ea10:	3f ef       	ldi	r19, 0xFF	; 255
    ea12:	4f ef       	ldi	r20, 0xFF	; 255
    ea14:	5f ef       	ldi	r21, 0xFF	; 255
				return addr;  							/* Encontro  la pose deseada*/
		}
	}
	return -1;	
	
}
    ea16:	b9 01       	movw	r22, r18
    ea18:	ca 01       	movw	r24, r20
    ea1a:	0f 90       	pop	r0
    ea1c:	0f 90       	pop	r0
    ea1e:	cf 91       	pop	r28
    ea20:	df 91       	pop	r29
    ea22:	1f 91       	pop	r17
    ea24:	0f 91       	pop	r16
    ea26:	ff 90       	pop	r15
    ea28:	ef 90       	pop	r14
    ea2a:	df 90       	pop	r13
    ea2c:	cf 90       	pop	r12
    ea2e:	bf 90       	pop	r11
    ea30:	af 90       	pop	r10
    ea32:	9f 90       	pop	r9
    ea34:	8f 90       	pop	r8
    ea36:	7f 90       	pop	r7
    ea38:	6f 90       	pop	r6
    ea3a:	5f 90       	pop	r5
    ea3c:	4f 90       	pop	r4
    ea3e:	08 95       	ret

0000ea40 <SobreEscribir_Pose>:
	
	return rv;
}
/*****************************************************************************************************/
int16 SobreEscribir_Pose(PoseRobot Pose)
{
    ea40:	df 93       	push	r29
    ea42:	cf 93       	push	r28
    ea44:	cd b7       	in	r28, 0x3d	; 61
    ea46:	de b7       	in	r29, 0x3e	; 62
	int32 addr; 	
	
	
    
	/* Se busca la direccion en donde se encuentra la Pose*/	
	addr=Found_Id(Pose.id);
    ea48:	8d 81       	ldd	r24, Y+5	; 0x05
    ea4a:	9e 81       	ldd	r25, Y+6	; 0x06
    ea4c:	0e 94 b4 74 	call	0xe968	; 0xe968 <Found_Id>
	#ifdef DEBUGTWI
		printf("SobreEscribir_Pose=> addr en SobreEscribir_Pose => %ld \n",addr);
	#endif	
	
	/* Las direcciones validas de las poses empiezan a partir de 2*/
	if(addr >= 2)									
    ea50:	62 30       	cpi	r22, 0x02	; 2
    ea52:	71 05       	cpc	r23, r1
    ea54:	81 05       	cpc	r24, r1
    ea56:	91 05       	cpc	r25, r1
    ea58:	1c f4       	brge	.+6      	; 0xea60 <SobreEscribir_Pose+0x20>
    ea5a:	2f ef       	ldi	r18, 0xFF	; 255
    ea5c:	3f ef       	ldi	r19, 0xFF	; 255
    ea5e:	08 c0       	rjmp	.+16     	; 0xea70 <SobreEscribir_Pose+0x30>
	{
		rv=ee24xx_write_bytes(addr,sizeof(PoseRobot),(uint8*) &Pose);
    ea60:	47 e1       	ldi	r20, 0x17	; 23
    ea62:	50 e0       	ldi	r21, 0x00	; 0
    ea64:	9e 01       	movw	r18, r28
    ea66:	2b 5f       	subi	r18, 0xFB	; 251
    ea68:	3f 4f       	sbci	r19, 0xFF	; 255
    ea6a:	0e 94 3f 71 	call	0xe27e	; 0xe27e <ee24xx_write_bytes>
    ea6e:	9c 01       	movw	r18, r24
		#endif	
	}	
	
	return rv;

}
    ea70:	c9 01       	movw	r24, r18
    ea72:	cf 91       	pop	r28
    ea74:	df 91       	pop	r29
    ea76:	08 95       	ret

0000ea78 <Leer_PoseTWI>:
	return rv;
}

/*****************************************************************************************************/
int16 Leer_PoseTWI(uint16 id, PoseRobot *Pose)
{
    ea78:	cf 93       	push	r28
    ea7a:	df 93       	push	r29
    ea7c:	eb 01       	movw	r28, r22
	int32 addr; 	
	
	
    
	/* Se busca la direccion en donde se encuentra la Pose */	
	addr=Found_Id(id);
    ea7e:	0e 94 b4 74 	call	0xe968	; 0xe968 <Found_Id>
	#ifdef DEBUGTWI
		printf("Leer_PoseTWI=> addr en Leer_PoseTWI => %ld \n",addr);
	#endif	
	
	/* Las direcciones validas de las poses empiezan a partir de 2*/
	if(addr >= 2)									
    ea82:	62 30       	cpi	r22, 0x02	; 2
    ea84:	71 05       	cpc	r23, r1
    ea86:	81 05       	cpc	r24, r1
    ea88:	91 05       	cpc	r25, r1
    ea8a:	1c f4       	brge	.+6      	; 0xea92 <Leer_PoseTWI+0x1a>
    ea8c:	2f ef       	ldi	r18, 0xFF	; 255
    ea8e:	3f ef       	ldi	r19, 0xFF	; 255
    ea90:	06 c0       	rjmp	.+12     	; 0xea9e <Leer_PoseTWI+0x26>
	{
		rv=ee24xx_read_bytes(addr,sizeof(PoseRobot),(uint8*) Pose);
    ea92:	47 e1       	ldi	r20, 0x17	; 23
    ea94:	50 e0       	ldi	r21, 0x00	; 0
    ea96:	9e 01       	movw	r18, r28
    ea98:	0e 94 6a 71 	call	0xe2d4	; 0xe2d4 <ee24xx_read_bytes>
    ea9c:	9c 01       	movw	r18, r24
	}	
	
	
	
	return rv;
}
    ea9e:	c9 01       	movw	r24, r18
    eaa0:	df 91       	pop	r29
    eaa2:	cf 91       	pop	r28
    eaa4:	08 95       	ret

0000eaa6 <Vector2Trajectory>:
/*****************************************************************************************************/
/*-----------------------------------------------------------------------------------------*/
/*No podemos Usa rxTrajectory */
/*Crea un trayectory utilizando las posiciones del Vector de Ids*/
int16  Vector2Trajectory(uint16 *vector)
{	
    eaa6:	2f 92       	push	r2
    eaa8:	3f 92       	push	r3
    eaaa:	4f 92       	push	r4
    eaac:	5f 92       	push	r5
    eaae:	6f 92       	push	r6
    eab0:	7f 92       	push	r7
    eab2:	8f 92       	push	r8
    eab4:	9f 92       	push	r9
    eab6:	af 92       	push	r10
    eab8:	bf 92       	push	r11
    eaba:	cf 92       	push	r12
    eabc:	df 92       	push	r13
    eabe:	ef 92       	push	r14
    eac0:	ff 92       	push	r15
    eac2:	0f 93       	push	r16
    eac4:	1f 93       	push	r17
    eac6:	df 93       	push	r29
    eac8:	cf 93       	push	r28
    eaca:	cd b7       	in	r28, 0x3d	; 61
    eacc:	de b7       	in	r29, 0x3e	; 62
    eace:	67 97       	sbiw	r28, 0x17	; 23
    ead0:	0f b6       	in	r0, 0x3f	; 63
    ead2:	f8 94       	cli
    ead4:	de bf       	out	0x3e, r29	; 62
    ead6:	0f be       	out	0x3f, r0	; 63
    ead8:	cd bf       	out	0x3d, r28	; 61
    eada:	8c 01       	movw	r16, r24
	int16 num_datos,i,rv, axis;
	uint16 id_pose;
	PoseRobot Pose;	
	extern int16 FlagrxVectorok;
	
	num_datos=vector[0];								//numero de datos del vector
    eadc:	dc 01       	movw	r26, r24
    eade:	8d 90       	ld	r8, X+
    eae0:	9c 90       	ld	r9, X
	if(FlagrxVectorok)	
    eae2:	80 91 b2 7b 	lds	r24, 0x7BB2
    eae6:	90 91 b3 7b 	lds	r25, 0x7BB3
    eaea:	89 2b       	or	r24, r25
    eaec:	31 f0       	breq	.+12     	; 0xeafa <Vector2Trajectory+0x54>
		free(Trajectoryvector.point);
    eaee:	80 91 29 82 	lds	r24, 0x8229
    eaf2:	90 91 2a 82 	lds	r25, 0x822A
    eaf6:	0e 94 aa 86 	call	0x10d54	; 0x10d54 <free>
		
	Trajectoryvector.point= declarar(sizeof(tpoint)*num_datos);//asigno memoria a los puntos
    eafa:	8d e3       	ldi	r24, 0x3D	; 61
    eafc:	90 e0       	ldi	r25, 0x00	; 0
    eafe:	fc 01       	movw	r30, r24
    eb00:	8e 9e       	mul	r8, r30
    eb02:	c0 01       	movw	r24, r0
    eb04:	8f 9e       	mul	r8, r31
    eb06:	90 0d       	add	r25, r0
    eb08:	9e 9e       	mul	r9, r30
    eb0a:	90 0d       	add	r25, r0
    eb0c:	11 24       	eor	r1, r1
    eb0e:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <declarar>
    eb12:	90 93 2a 82 	sts	0x822A, r25
    eb16:	80 93 29 82 	sts	0x8229, r24
	
	
	//lleno los campos de la trayectoria como size e invalid mask
	Trajectoryvector.size=	num_datos-1;
    eb1a:	94 01       	movw	r18, r8
    eb1c:	21 50       	subi	r18, 0x01	; 1
    eb1e:	30 40       	sbci	r19, 0x00	; 0
    eb20:	30 93 26 82 	sts	0x8226, r19
    eb24:	20 93 25 82 	sts	0x8225, r18
	Trajectoryvector.invalidmask= (WaistMask |ShoulderMask | ElbowMask | PitchMask| RollMask);
    eb28:	8f e1       	ldi	r24, 0x1F	; 31
    eb2a:	90 e0       	ldi	r25, 0x00	; 0
    eb2c:	90 93 28 82 	sts	0x8228, r25
    eb30:	80 93 27 82 	sts	0x8227, r24
	
	printf("Vector2Trajectory=> Trajectoryvector.size= %d\n",Trajectoryvector.size);
    eb34:	00 d0       	rcall	.+0      	; 0xeb36 <Vector2Trajectory+0x90>
    eb36:	00 d0       	rcall	.+0      	; 0xeb38 <Vector2Trajectory+0x92>
    eb38:	87 e1       	ldi	r24, 0x17	; 23
    eb3a:	97 e7       	ldi	r25, 0x77	; 119
    eb3c:	ad b7       	in	r26, 0x3d	; 61
    eb3e:	be b7       	in	r27, 0x3e	; 62
    eb40:	12 96       	adiw	r26, 0x02	; 2
    eb42:	9c 93       	st	X, r25
    eb44:	8e 93       	st	-X, r24
    eb46:	11 97       	sbiw	r26, 0x01	; 1
    eb48:	14 96       	adiw	r26, 0x04	; 4
    eb4a:	3c 93       	st	X, r19
    eb4c:	2e 93       	st	-X, r18
    eb4e:	13 97       	sbiw	r26, 0x03	; 3
    eb50:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Vector2Trajectory=> Trajectoryvector.invalidmask= = %d\n",Trajectoryvector.invalidmask);
    eb54:	86 e4       	ldi	r24, 0x46	; 70
    eb56:	97 e7       	ldi	r25, 0x77	; 119
    eb58:	ed b7       	in	r30, 0x3d	; 61
    eb5a:	fe b7       	in	r31, 0x3e	; 62
    eb5c:	92 83       	std	Z+2, r25	; 0x02
    eb5e:	81 83       	std	Z+1, r24	; 0x01
    eb60:	80 91 27 82 	lds	r24, 0x8227
    eb64:	90 91 28 82 	lds	r25, 0x8228
    eb68:	94 83       	std	Z+4, r25	; 0x04
    eb6a:	83 83       	std	Z+3, r24	; 0x03
    eb6c:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    eb70:	58 01       	movw	r10, r16
    eb72:	11 e0       	ldi	r17, 0x01	; 1
    eb74:	c1 2e       	mov	r12, r17
    eb76:	d1 2c       	mov	r13, r1
    eb78:	ee 24       	eor	r14, r14
    eb7a:	ff 24       	eor	r15, r15
    eb7c:	0f 90       	pop	r0
    eb7e:	0f 90       	pop	r0
    eb80:	0f 90       	pop	r0
    eb82:	0f 90       	pop	r0
	for (i=1;i<num_datos;i++)
	{
		id_pose= vector[i];								//Obtengo el Id de la Pose		
		rv=	Leer_PoseTWI(id_pose, &Pose);				//obtener la Pose del Robot almacenada en EEPROM
    eb84:	3e 01       	movw	r6, r28
    eb86:	08 94       	sec
    eb88:	61 1c       	adc	r6, r1
    eb8a:	71 1c       	adc	r7, r1
    eb8c:	82 c0       	rjmp	.+260    	; 0xec92 <Vector2Trajectory+0x1ec>
    eb8e:	d5 01       	movw	r26, r10
    eb90:	12 96       	adiw	r26, 0x02	; 2
    eb92:	8d 91       	ld	r24, X+
    eb94:	9c 91       	ld	r25, X
    eb96:	13 97       	sbiw	r26, 0x03	; 3
    eb98:	b3 01       	movw	r22, r6
    eb9a:	0e 94 3c 75 	call	0xea78	; 0xea78 <Leer_PoseTWI>
		printf("Vector2Trajectory=> Pose.Pos_Elbow = %ld\n",Pose.Pos_Elbow);
		printf("Vector2Trajectory=> Pose.Pos_Pitch = %ld\n",Pose.Pos_Pitch);
		printf("Vector2Trajectory=> Pose.Pos_Roll = %ld\n",Pose.Pos_Roll);
		printf("Vector2Trajectory=> Pose.id = %d\n",Pose.id);
		#endif
		if(rv>0)
    eb9e:	18 16       	cp	r1, r24
    eba0:	19 06       	cpc	r1, r25
    eba2:	1c f0       	brlt	.+6      	; 0xebaa <Vector2Trajectory+0x104>
    eba4:	2f ef       	ldi	r18, 0xFF	; 255
    eba6:	3f ef       	ldi	r19, 0xFF	; 255
    eba8:	7a c0       	rjmp	.+244    	; 0xec9e <Vector2Trajectory+0x1f8>
		{
			//LLeno el Campo de Posicion de la Trayectoria
			Trajectoryvector.point[(i-1)].axis[AxisWaist].position=Pose.Pos_Waist;
    ebaa:	e0 91 29 82 	lds	r30, 0x8229
    ebae:	f0 91 2a 82 	lds	r31, 0x822A
    ebb2:	ee 0d       	add	r30, r14
    ebb4:	ff 1d       	adc	r31, r15
    ebb6:	8b 81       	ldd	r24, Y+3	; 0x03
    ebb8:	9c 81       	ldd	r25, Y+4	; 0x04
    ebba:	ad 81       	ldd	r26, Y+5	; 0x05
    ebbc:	be 81       	ldd	r27, Y+6	; 0x06
    ebbe:	80 83       	st	Z, r24
    ebc0:	91 83       	std	Z+1, r25	; 0x01
    ebc2:	a2 83       	std	Z+2, r26	; 0x02
    ebc4:	b3 83       	std	Z+3, r27	; 0x03
			Trajectoryvector.point[(i-1)].axis[AxisShoulder].position=Pose.Pos_Shoulder;
    ebc6:	8f 81       	ldd	r24, Y+7	; 0x07
    ebc8:	98 85       	ldd	r25, Y+8	; 0x08
    ebca:	a9 85       	ldd	r26, Y+9	; 0x09
    ebcc:	ba 85       	ldd	r27, Y+10	; 0x0a
    ebce:	84 87       	std	Z+12, r24	; 0x0c
    ebd0:	95 87       	std	Z+13, r25	; 0x0d
    ebd2:	a6 87       	std	Z+14, r26	; 0x0e
    ebd4:	b7 87       	std	Z+15, r27	; 0x0f
			Trajectoryvector.point[(i-1)].axis[AxisElbow].position=Pose.Pos_Elbow;
    ebd6:	8b 85       	ldd	r24, Y+11	; 0x0b
    ebd8:	9c 85       	ldd	r25, Y+12	; 0x0c
    ebda:	ad 85       	ldd	r26, Y+13	; 0x0d
    ebdc:	be 85       	ldd	r27, Y+14	; 0x0e
    ebde:	80 8f       	std	Z+24, r24	; 0x18
    ebe0:	91 8f       	std	Z+25, r25	; 0x19
    ebe2:	a2 8f       	std	Z+26, r26	; 0x1a
    ebe4:	b3 8f       	std	Z+27, r27	; 0x1b
			Trajectoryvector.point[(i-1)].axis[AxisPitch].position=Pose.Pos_Pitch;
    ebe6:	8f 85       	ldd	r24, Y+15	; 0x0f
    ebe8:	98 89       	ldd	r25, Y+16	; 0x10
    ebea:	a9 89       	ldd	r26, Y+17	; 0x11
    ebec:	ba 89       	ldd	r27, Y+18	; 0x12
    ebee:	84 a3       	std	Z+36, r24	; 0x24
    ebf0:	95 a3       	std	Z+37, r25	; 0x25
    ebf2:	a6 a3       	std	Z+38, r26	; 0x26
    ebf4:	b7 a3       	std	Z+39, r27	; 0x27
			Trajectoryvector.point[(i-1)].axis[AxisRoll].position=Pose.Pos_Roll;
    ebf6:	8b 89       	ldd	r24, Y+19	; 0x13
    ebf8:	9c 89       	ldd	r25, Y+20	; 0x14
    ebfa:	ad 89       	ldd	r26, Y+21	; 0x15
    ebfc:	be 89       	ldd	r27, Y+22	; 0x16
    ebfe:	80 ab       	std	Z+48, r24	; 0x30
    ec00:	91 ab       	std	Z+49, r25	; 0x31
    ec02:	a2 ab       	std	Z+50, r26	; 0x32
    ec04:	b3 ab       	std	Z+51, r27	; 0x33
			Trajectoryvector.point[(i-1)].Gripper_Status=Pose.Gripper_Status;
    ec06:	8f 89       	ldd	r24, Y+23	; 0x17
    ec08:	84 af       	std	Z+60, r24	; 0x3c
    ec0a:	04 eb       	ldi	r16, 0xB4	; 180
    ec0c:	1d e7       	ldi	r17, 0x7D	; 125
    ec0e:	60 e0       	ldi	r22, 0x00	; 0
    ec10:	70 e0       	ldi	r23, 0x00	; 0
			
			#endif
			//LLeno los demas Campos de la Trayectoria. Velocidad y Aceleracion maximos
			for(axis=0; axis < DOF; axis++) 
			{
				Trajectoryvector.point[(i-1)].axis[axis].velocity=hAxis[axis].axisSettings.homeVelocity;
    ec12:	40 91 29 82 	lds	r20, 0x8229
    ec16:	50 91 2a 82 	lds	r21, 0x822A
    ec1a:	4e 0d       	add	r20, r14
    ec1c:	5f 1d       	adc	r21, r15
    ec1e:	9b 01       	movw	r18, r22
    ec20:	22 0f       	add	r18, r18
    ec22:	33 1f       	adc	r19, r19
    ec24:	26 0f       	add	r18, r22
    ec26:	37 1f       	adc	r19, r23
    ec28:	f9 01       	movw	r30, r18
    ec2a:	31 96       	adiw	r30, 0x01	; 1
    ec2c:	ee 0f       	add	r30, r30
    ec2e:	ff 1f       	adc	r31, r31
    ec30:	ee 0f       	add	r30, r30
    ec32:	ff 1f       	adc	r31, r31
    ec34:	e4 0f       	add	r30, r20
    ec36:	f5 1f       	adc	r31, r21
    ec38:	d8 01       	movw	r26, r16
    ec3a:	2d 90       	ld	r2, X+
    ec3c:	3d 90       	ld	r3, X+
    ec3e:	4d 90       	ld	r4, X+
    ec40:	5c 90       	ld	r5, X
    ec42:	13 97       	sbiw	r26, 0x03	; 3
    ec44:	20 82       	st	Z, r2
    ec46:	31 82       	std	Z+1, r3	; 0x01
    ec48:	42 82       	std	Z+2, r4	; 0x02
    ec4a:	53 82       	std	Z+3, r5	; 0x03
				Trajectoryvector.point[(i-1)].axis[axis].acceleration=hAxis[axis].axisSettings.homeAcceleration;
    ec4c:	22 0f       	add	r18, r18
    ec4e:	33 1f       	adc	r19, r19
    ec50:	22 0f       	add	r18, r18
    ec52:	33 1f       	adc	r19, r19
    ec54:	42 0f       	add	r20, r18
    ec56:	53 1f       	adc	r21, r19
    ec58:	14 96       	adiw	r26, 0x04	; 4
    ec5a:	8d 91       	ld	r24, X+
    ec5c:	9d 91       	ld	r25, X+
    ec5e:	0d 90       	ld	r0, X+
    ec60:	bc 91       	ld	r27, X
    ec62:	a0 2d       	mov	r26, r0
    ec64:	fa 01       	movw	r30, r20
    ec66:	80 87       	std	Z+8, r24	; 0x08
    ec68:	91 87       	std	Z+9, r25	; 0x09
    ec6a:	a2 87       	std	Z+10, r26	; 0x0a
    ec6c:	b3 87       	std	Z+11, r27	; 0x0b
			printf("Vector2Trajectory=> La posicion de %s es en packetIO.c => %ld\n",AxisName(AxisRoll),
				   Trajectoryvector->point[(i-1)].axis[AxisRoll].position);
			
			#endif
			//LLeno los demas Campos de la Trayectoria. Velocidad y Aceleracion maximos
			for(axis=0; axis < DOF; axis++) 
    ec6e:	6f 5f       	subi	r22, 0xFF	; 255
    ec70:	7f 4f       	sbci	r23, 0xFF	; 255
    ec72:	00 5a       	subi	r16, 0xA0	; 160
    ec74:	1f 4f       	sbci	r17, 0xFF	; 255
    ec76:	65 30       	cpi	r22, 0x05	; 5
    ec78:	71 05       	cpc	r23, r1
    ec7a:	59 f6       	brne	.-106    	; 0xec12 <Vector2Trajectory+0x16c>
	Trajectoryvector.size=	num_datos-1;
	Trajectoryvector.invalidmask= (WaistMask |ShoulderMask | ElbowMask | PitchMask| RollMask);
	
	printf("Vector2Trajectory=> Trajectoryvector.size= %d\n",Trajectoryvector.size);
	printf("Vector2Trajectory=> Trajectoryvector.invalidmask= = %d\n",Trajectoryvector.invalidmask);
	for (i=1;i<num_datos;i++)
    ec7c:	08 94       	sec
    ec7e:	c1 1c       	adc	r12, r1
    ec80:	d1 1c       	adc	r13, r1
    ec82:	2d e3       	ldi	r18, 0x3D	; 61
    ec84:	30 e0       	ldi	r19, 0x00	; 0
    ec86:	e2 0e       	add	r14, r18
    ec88:	f3 1e       	adc	r15, r19
    ec8a:	82 e0       	ldi	r24, 0x02	; 2
    ec8c:	90 e0       	ldi	r25, 0x00	; 0
    ec8e:	a8 0e       	add	r10, r24
    ec90:	b9 1e       	adc	r11, r25
    ec92:	c8 14       	cp	r12, r8
    ec94:	d9 04       	cpc	r13, r9
    ec96:	0c f4       	brge	.+2      	; 0xec9a <Vector2Trajectory+0x1f4>
    ec98:	7a cf       	rjmp	.-268    	; 0xeb8e <Vector2Trajectory+0xe8>
    ec9a:	20 e0       	ldi	r18, 0x00	; 0
    ec9c:	30 e0       	ldi	r19, 0x00	; 0
				break;
			}
		}
	}*/
	return 0;
}
    ec9e:	c9 01       	movw	r24, r18
    eca0:	67 96       	adiw	r28, 0x17	; 23
    eca2:	0f b6       	in	r0, 0x3f	; 63
    eca4:	f8 94       	cli
    eca6:	de bf       	out	0x3e, r29	; 62
    eca8:	0f be       	out	0x3f, r0	; 63
    ecaa:	cd bf       	out	0x3d, r28	; 61
    ecac:	cf 91       	pop	r28
    ecae:	df 91       	pop	r29
    ecb0:	1f 91       	pop	r17
    ecb2:	0f 91       	pop	r16
    ecb4:	ff 90       	pop	r15
    ecb6:	ef 90       	pop	r14
    ecb8:	df 90       	pop	r13
    ecba:	cf 90       	pop	r12
    ecbc:	bf 90       	pop	r11
    ecbe:	af 90       	pop	r10
    ecc0:	9f 90       	pop	r9
    ecc2:	8f 90       	pop	r8
    ecc4:	7f 90       	pop	r7
    ecc6:	6f 90       	pop	r6
    ecc8:	5f 90       	pop	r5
    ecca:	4f 90       	pop	r4
    eccc:	3f 90       	pop	r3
    ecce:	2f 90       	pop	r2
    ecd0:	08 95       	ret

0000ecd2 <openGripper>:
 
 
	// Los switch son normalmente Abierto. (Se necesitan de alguna resistencia de pullup para estos)
    
    //abriendo el gripper
	GRIPPERCTL |= _BV(DER);  		//1
    ecd2:	88 9a       	sbi	0x11, 0	; 17
    GRIPPERCTL &= ~(_BV(IZQ)); 	//0
    ecd4:	89 98       	cbi	0x11, 1	; 17
	pin=PINF;
    ecd6:	8f b1       	in	r24, 0x0f	; 15
    ecd8:	2a e0       	ldi	r18, 0x0A	; 10
    ecda:	30 e0       	ldi	r19, 0x00	; 0
    ecdc:	48 ec       	ldi	r20, 0xC8	; 200
    ecde:	50 e0       	ldi	r21, 0x00	; 0
	printf("openGripper=> Abriendo Gripper= %#X\n",pin);
	#endif	
	for(;;) 
	{
		
		if (!bit_is_set(PINF,FINDER))
    ece0:	7e 9b       	sbis	0x0f, 6	; 15
    ece2:	0c c0       	rjmp	.+24     	; 0xecfc <openGripper+0x2a>
			return;
		}
		
		else// not ready 
		{ 
			timer--;
    ece4:	21 50       	subi	r18, 0x01	; 1
    ece6:	30 40       	sbci	r19, 0x00	; 0
    ece8:	88 ee       	ldi	r24, 0xE8	; 232
    ecea:	93 e0       	ldi	r25, 0x03	; 3
    ecec:	fa 01       	movw	r30, r20
    ecee:	31 97       	sbiw	r30, 0x01	; 1
    ecf0:	f1 f7       	brne	.-4      	; 0xecee <openGripper+0x1c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    ecf2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    ecf4:	d9 f7       	brne	.-10     	; 0xecec <openGripper+0x1a>
			_delay_ms(100);
	
			if(timer == 0) 
    ecf6:	21 15       	cp	r18, r1
    ecf8:	31 05       	cpc	r19, r1
    ecfa:	91 f7       	brne	.-28     	; 0xece0 <openGripper+0xe>
			{
				//Parar Motor
				//Mantener el motor apadado
				PORTF     |=	_BV(DER) | _BV(IZQ);
    ecfc:	81 b3       	in	r24, 0x11	; 17
    ecfe:	83 60       	ori	r24, 0x03	; 3
    ed00:	81 bb       	out	0x11, r24	; 17
    ed02:	08 95       	ret

0000ed04 <openGripper_time>:
		}
  	} // for EVER      
} // openGripper

void openGripper_time(int tiempo) 
{
    ed04:	ac 01       	movw	r20, r24
	uint8 i;
	
	//se abre el gripper por un periodo de tiempo
	
	GRIPPERCTL |= _BV(DER);  		//1
    ed06:	88 9a       	sbi	0x11, 0	; 17
    GRIPPERCTL &= ~(_BV(IZQ)); 	//0
    ed08:	89 98       	cbi	0x11, 1	; 17
    ed0a:	20 e0       	ldi	r18, 0x00	; 0
    ed0c:	68 ec       	ldi	r22, 0xC8	; 200
    ed0e:	70 e0       	ldi	r23, 0x00	; 0
    ed10:	08 c0       	rjmp	.+16     	; 0xed22 <openGripper_time+0x1e>
	
	

	for (i = 0; i < tiempo; i++)   
    ed12:	88 ee       	ldi	r24, 0xE8	; 232
    ed14:	93 e0       	ldi	r25, 0x03	; 3
    ed16:	fb 01       	movw	r30, r22
    ed18:	31 97       	sbiw	r30, 0x01	; 1
    ed1a:	f1 f7       	brne	.-4      	; 0xed18 <openGripper_time+0x14>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    ed1c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    ed1e:	d9 f7       	brne	.-10     	; 0xed16 <openGripper_time+0x12>
    ed20:	2f 5f       	subi	r18, 0xFF	; 255
    ed22:	82 2f       	mov	r24, r18
    ed24:	90 e0       	ldi	r25, 0x00	; 0
    ed26:	84 17       	cp	r24, r20
    ed28:	95 07       	cpc	r25, r21
    ed2a:	9c f3       	brlt	.-26     	; 0xed12 <openGripper_time+0xe>
			_delay_ms(100);
	
	//Parar Motor
	//Mantener el motor apadado
	PORTF     |=	_BV(DER) | _BV(IZQ);
    ed2c:	81 b3       	in	r24, 0x11	; 17
    ed2e:	83 60       	ori	r24, 0x03	; 3
    ed30:	81 bb       	out	0x11, r24	; 17

	
	
	
    
} // openGripper_time
    ed32:	08 95       	ret

0000ed34 <closeGripper>:
	
	
	
	
	//cerrando el gripper
	GRIPPERCTL &= ~(_BV(DER));  	//0
    ed34:	88 98       	cbi	0x11, 0	; 17
    GRIPPERCTL |= _BV(IZQ); 	//1
    ed36:	89 9a       	sbi	0x11, 1	; 17
	pin=PINF;
    ed38:	8f b1       	in	r24, 0x0f	; 15
    ed3a:	2a e0       	ldi	r18, 0x0A	; 10
    ed3c:	30 e0       	ldi	r19, 0x00	; 0
    ed3e:	48 ec       	ldi	r20, 0xC8	; 200
    ed40:	50 e0       	ldi	r21, 0x00	; 0
	
		
	for(;;) 
	{
		
		if (!bit_is_set(PINF,FINIZQ))
    ed42:	7f 9b       	sbis	0x0f, 7	; 15
    ed44:	0c c0       	rjmp	.+24     	; 0xed5e <closeGripper+0x2a>
			return;
		}
		
		else// not ready 
		{ 
			timer--;
    ed46:	21 50       	subi	r18, 0x01	; 1
    ed48:	30 40       	sbci	r19, 0x00	; 0
    ed4a:	88 ee       	ldi	r24, 0xE8	; 232
    ed4c:	93 e0       	ldi	r25, 0x03	; 3
    ed4e:	fa 01       	movw	r30, r20
    ed50:	31 97       	sbiw	r30, 0x01	; 1
    ed52:	f1 f7       	brne	.-4      	; 0xed50 <closeGripper+0x1c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    ed54:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    ed56:	d9 f7       	brne	.-10     	; 0xed4e <closeGripper+0x1a>
			_delay_ms(100);
			
			if(timer == 0) 
    ed58:	21 15       	cp	r18, r1
    ed5a:	31 05       	cpc	r19, r1
    ed5c:	91 f7       	brne	.-28     	; 0xed42 <closeGripper+0xe>
			{
				//Parar Motor
				//Mantener el motor apadado
				PORTF     |=	_BV(DER) | _BV(IZQ);
    ed5e:	81 b3       	in	r24, 0x11	; 17
    ed60:	83 60       	ori	r24, 0x03	; 3
    ed62:	81 bb       	out	0x11, r24	; 17
    ed64:	08 95       	ret

0000ed66 <closeGripper_time>:

} // closeGripper


void closeGripper_time(int tiempo) 
{
    ed66:	ac 01       	movw	r20, r24
	uint8 i;
	
	//se cierra el gripper por un periodo de tiempo
	
	GRIPPERCTL &= ~(_BV(DER));  	//0
    ed68:	88 98       	cbi	0x11, 0	; 17
    GRIPPERCTL |= _BV(IZQ); 		//1
    ed6a:	89 9a       	sbi	0x11, 1	; 17
    ed6c:	20 e0       	ldi	r18, 0x00	; 0
    ed6e:	68 ec       	ldi	r22, 0xC8	; 200
    ed70:	70 e0       	ldi	r23, 0x00	; 0
    ed72:	08 c0       	rjmp	.+16     	; 0xed84 <closeGripper_time+0x1e>
	
	

	for (i = 0; i < tiempo; i++)   
    ed74:	88 ee       	ldi	r24, 0xE8	; 232
    ed76:	93 e0       	ldi	r25, 0x03	; 3
    ed78:	fb 01       	movw	r30, r22
    ed7a:	31 97       	sbiw	r30, 0x01	; 1
    ed7c:	f1 f7       	brne	.-4      	; 0xed7a <closeGripper_time+0x14>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    ed7e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    ed80:	d9 f7       	brne	.-10     	; 0xed78 <closeGripper_time+0x12>
    ed82:	2f 5f       	subi	r18, 0xFF	; 255
    ed84:	82 2f       	mov	r24, r18
    ed86:	90 e0       	ldi	r25, 0x00	; 0
    ed88:	84 17       	cp	r24, r20
    ed8a:	95 07       	cpc	r25, r21
    ed8c:	9c f3       	brlt	.-26     	; 0xed74 <closeGripper_time+0xe>
			_delay_ms(100);
	
	//Parar Motor
	//Mantener el motor apadado
	PORTF     |=	_BV(DER) | _BV(IZQ);
    ed8e:	81 b3       	in	r24, 0x11	; 17
    ed90:	83 60       	ori	r24, 0x03	; 3
    ed92:	81 bb       	out	0x11, r24	; 17
	
	
	
	
    
} // closeGripper_time
    ed94:	08 95       	ret

0000ed96 <Estado_gripper>:

//Si el gripper tiene CARGA una pieza, la funcion retorn abierto asi el gripper este cerrado.......
int8 Estado_gripper(void)
{

	if (!bit_is_set(PINF,FINIZQ))
    ed96:	7f 99       	sbic	0x0f, 7	; 15
    ed98:	06 c0       	rjmp	.+12     	; 0xeda6 <Estado_gripper+0x10>
	{
		//#ifdef DEBUGGRIPPER
		printf("Estado_gripper=> El Gripper esta cerrado. \n");
    ed9a:	8e e7       	ldi	r24, 0x7E	; 126
    ed9c:	97 e7       	ldi	r25, 0x77	; 119
    ed9e:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    eda2:	81 e0       	ldi	r24, 0x01	; 1
    eda4:	08 95       	ret
		//#endif
		return 1;
	}
	if (!bit_is_set(PINF,FINDER))
    eda6:	7e 99       	sbic	0x0f, 6	; 15
    eda8:	06 c0       	rjmp	.+12     	; 0xedb6 <Estado_gripper+0x20>
	{
		//#ifdef DEBUGGRIPPER
		printf("Estado_gripper=> El Gripper esta abierto. \n");
    edaa:	89 ea       	ldi	r24, 0xA9	; 169
    edac:	97 e7       	ldi	r25, 0x77	; 119
    edae:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    edb2:	80 e0       	ldi	r24, 0x00	; 0
    edb4:	08 95       	ret
		//#endif		
		return 0;
	}
	//#ifdef DEBUGGRIPPER
	printf("Estado_gripper=> El Gripper no esta definido. \n");
    edb6:	84 ed       	ldi	r24, 0xD4	; 212
    edb8:	97 e7       	ldi	r25, 0x77	; 119
    edba:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
    edbe:	8f ef       	ldi	r24, 0xFF	; 255
	//#endif
	return -1;


    edc0:	08 95       	ret

0000edc2 <delay_1s>:

PMDint32 EEMEM ATmegaEEPROM_var=0;

/****************************************************************************************/  
void delay_1s(void)
{
    edc2:	20 e0       	ldi	r18, 0x00	; 0
    edc4:	40 e2       	ldi	r20, 0x20	; 32
    edc6:	5e e4       	ldi	r21, 0x4E	; 78
    edc8:	ca 01       	movw	r24, r20
    edca:	01 97       	sbiw	r24, 0x01	; 1
    edcc:	f1 f7       	brne	.-4      	; 0xedca <delay_1s+0x8>
  uint8 i;

  for (i = 0; i < 100; i++)   
    edce:	2f 5f       	subi	r18, 0xFF	; 255
    edd0:	24 36       	cpi	r18, 0x64	; 100
    edd2:	d1 f7       	brne	.-12     	; 0xedc8 <delay_1s+0x6>
    _delay_ms(10);
}
    edd4:	08 95       	ret

0000edd6 <buzzer>:

/****************************************************************************************/ 
void buzzer(uint16 valor_s)
{
    edd6:	ac 01       	movw	r20, r24
	uint8 i;	
	
	PORTD 	|= 	_BV(Alarma);
    edd8:	5f 9a       	sbi	0x0b, 7	; 11
    edda:	30 e0       	ldi	r19, 0x00	; 0
    eddc:	60 e2       	ldi	r22, 0x20	; 32
    edde:	7e e4       	ldi	r23, 0x4E	; 78
    ede0:	08 c0       	rjmp	.+16     	; 0xedf2 <buzzer+0x1c>
	
	for(i = 0; i < valor_s; i++)
    ede2:	20 e0       	ldi	r18, 0x00	; 0
    ede4:	cb 01       	movw	r24, r22
    ede6:	01 97       	sbiw	r24, 0x01	; 1
    ede8:	f1 f7       	brne	.-4      	; 0xede6 <buzzer+0x10>
/****************************************************************************************/  
void delay_1s(void)
{
  uint8 i;

  for (i = 0; i < 100; i++)   
    edea:	2f 5f       	subi	r18, 0xFF	; 255
    edec:	24 36       	cpi	r18, 0x64	; 100
    edee:	d1 f7       	brne	.-12     	; 0xede4 <buzzer+0xe>
{
	uint8 i;	
	
	PORTD 	|= 	_BV(Alarma);
	
	for(i = 0; i < valor_s; i++)
    edf0:	3f 5f       	subi	r19, 0xFF	; 255
    edf2:	83 2f       	mov	r24, r19
    edf4:	90 e0       	ldi	r25, 0x00	; 0
    edf6:	84 17       	cp	r24, r20
    edf8:	95 07       	cpc	r25, r21
    edfa:	98 f3       	brcs	.-26     	; 0xede2 <buzzer+0xc>
	{
		delay_1s();
	}
	
	PORTD 	&= 	~(_BV(Alarma));
    edfc:	5f 98       	cbi	0x0b, 7	; 11
}
    edfe:	08 95       	ret

0000ee00 <buzzer_ms>:
/****************************************************************************************/ 
void buzzer_ms(uint32 valor_ms)
{
    ee00:	af 92       	push	r10
    ee02:	bf 92       	push	r11
    ee04:	cf 92       	push	r12
    ee06:	df 92       	push	r13
    ee08:	ef 92       	push	r14
    ee0a:	ff 92       	push	r15
    ee0c:	0f 93       	push	r16
    ee0e:	1f 93       	push	r17
	
	
	PORTD 	|= 	_BV(Alarma);
    ee10:	5f 9a       	sbi	0x0b, 7	; 11
	
	_delay_ms((double)valor_ms);
    ee12:	0e 94 02 84 	call	0x10804	; 0x10804 <__floatunsisf>
    ee16:	5b 01       	movw	r10, r22
    ee18:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    ee1a:	20 e0       	ldi	r18, 0x00	; 0
    ee1c:	30 e0       	ldi	r19, 0x00	; 0
    ee1e:	4a ef       	ldi	r20, 0xFA	; 250
    ee20:	54 e4       	ldi	r21, 0x44	; 68
    ee22:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    ee26:	7b 01       	movw	r14, r22
    ee28:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    ee2a:	20 e0       	ldi	r18, 0x00	; 0
    ee2c:	30 e0       	ldi	r19, 0x00	; 0
    ee2e:	40 e8       	ldi	r20, 0x80	; 128
    ee30:	5f e3       	ldi	r21, 0x3F	; 63
    ee32:	0e 94 65 83 	call	0x106ca	; 0x106ca <__cmpsf2>
    ee36:	88 23       	and	r24, r24
    ee38:	1c f4       	brge	.+6      	; 0xee40 <buzzer_ms+0x40>
    ee3a:	61 e0       	ldi	r22, 0x01	; 1
    ee3c:	70 e0       	ldi	r23, 0x00	; 0
    ee3e:	24 c0       	rjmp	.+72     	; 0xee88 <buzzer_ms+0x88>
		__ticks = 1;
	else if (__tmp > 65535)
    ee40:	c8 01       	movw	r24, r16
    ee42:	b7 01       	movw	r22, r14
    ee44:	20 e0       	ldi	r18, 0x00	; 0
    ee46:	3f ef       	ldi	r19, 0xFF	; 255
    ee48:	4f e7       	ldi	r20, 0x7F	; 127
    ee4a:	57 e4       	ldi	r21, 0x47	; 71
    ee4c:	0e 94 07 85 	call	0x10a0e	; 0x10a0e <__gesf2>
    ee50:	18 16       	cp	r1, r24
    ee52:	b4 f4       	brge	.+44     	; 0xee80 <buzzer_ms+0x80>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    ee54:	c6 01       	movw	r24, r12
    ee56:	b5 01       	movw	r22, r10
    ee58:	20 e0       	ldi	r18, 0x00	; 0
    ee5a:	30 e0       	ldi	r19, 0x00	; 0
    ee5c:	40 e2       	ldi	r20, 0x20	; 32
    ee5e:	51 e4       	ldi	r21, 0x41	; 65
    ee60:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
    ee64:	0e 94 d6 83 	call	0x107ac	; 0x107ac <__fixunssfsi>
    ee68:	88 ec       	ldi	r24, 0xC8	; 200
    ee6a:	90 e0       	ldi	r25, 0x00	; 0
    ee6c:	05 c0       	rjmp	.+10     	; 0xee78 <buzzer_ms+0x78>
    ee6e:	fc 01       	movw	r30, r24
    ee70:	31 97       	sbiw	r30, 0x01	; 1
    ee72:	f1 f7       	brne	.-4      	; 0xee70 <buzzer_ms+0x70>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    ee74:	61 50       	subi	r22, 0x01	; 1
    ee76:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    ee78:	61 15       	cp	r22, r1
    ee7a:	71 05       	cpc	r23, r1
    ee7c:	c1 f7       	brne	.-16     	; 0xee6e <buzzer_ms+0x6e>
    ee7e:	07 c0       	rjmp	.+14     	; 0xee8e <buzzer_ms+0x8e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    ee80:	c8 01       	movw	r24, r16
    ee82:	b7 01       	movw	r22, r14
    ee84:	0e 94 d6 83 	call	0x107ac	; 0x107ac <__fixunssfsi>
    ee88:	cb 01       	movw	r24, r22
    ee8a:	01 97       	sbiw	r24, 0x01	; 1
    ee8c:	f1 f7       	brne	.-4      	; 0xee8a <buzzer_ms+0x8a>
	
	PORTD 	&= 	~(_BV(Alarma));
    ee8e:	5f 98       	cbi	0x0b, 7	; 11
}
    ee90:	1f 91       	pop	r17
    ee92:	0f 91       	pop	r16
    ee94:	ff 90       	pop	r15
    ee96:	ef 90       	pop	r14
    ee98:	df 90       	pop	r13
    ee9a:	cf 90       	pop	r12
    ee9c:	bf 90       	pop	r11
    ee9e:	af 90       	pop	r10
    eea0:	08 95       	ret

0000eea2 <Led_on>:
/****************************************************************************************/  
void Led_on (tLeds color)
{
	
	/* Se Coloca el Bit LED0 del Puerto B en Modo de Salida y se le da un valor de 1*/	
	DDRB		|=	_BV(LED0);
    eea2:	27 9a       	sbi	0x04, 7	; 4
	PORTB		|=	_BV(LED0);							
    eea4:	2f 9a       	sbi	0x05, 7	; 5

	switch (color)
    eea6:	81 30       	cpi	r24, 0x01	; 1
    eea8:	41 f0       	breq	.+16     	; 0xeeba <Led_on+0x18>
    eeaa:	81 30       	cpi	r24, 0x01	; 1
    eeac:	20 f0       	brcs	.+8      	; 0xeeb6 <Led_on+0x14>
    eeae:	82 30       	cpi	r24, 0x02	; 2
    eeb0:	31 f4       	brne	.+12     	; 0xeebe <Led_on+0x1c>
	{
		case (Amarillo):
			PORTE		&= 	~(_BV(AMARILLOe)); 
    eeb2:	77 98       	cbi	0x0e, 7	; 14
    eeb4:	08 95       	ret
		break;
			
		case (Verde):
			PORTE		&= 	~(_BV(VERDEe)); 
    eeb6:	72 98       	cbi	0x0e, 2	; 14
    eeb8:	08 95       	ret
		break;
			
		case (Rojo):
			PORTB		&= 	~(_BV(ROJOb));
    eeba:	2f 98       	cbi	0x05, 7	; 5
    eebc:	08 95       	ret
		break;
			
		default:
			PORTE		|=  _BV(AMARILLOe);
    eebe:	77 9a       	sbi	0x0e, 7	; 14
			PORTE		|=  _BV(VERDEe);
    eec0:	72 9a       	sbi	0x0e, 2	; 14
			PORTB		|=  _BV(ROJOb);
    eec2:	2f 9a       	sbi	0x05, 7	; 5
    eec4:	08 95       	ret

0000eec6 <Led_off>:

/****************************************************************************************/  
void Led_off (int16 color)
{
	/* Se Coloca el Bit LED0 del Puerto B en Modo de Salida y se le da un valor de 1*/	
	DDRB		|=	_BV(LED0);
    eec6:	27 9a       	sbi	0x04, 7	; 4
	PORTB		|=	_BV(LED0);							
    eec8:	2f 9a       	sbi	0x05, 7	; 5
 
	switch (color)
    eeca:	81 30       	cpi	r24, 0x01	; 1
    eecc:	91 05       	cpc	r25, r1
    eece:	61 f0       	breq	.+24     	; 0xeee8 <Led_off+0x22>
    eed0:	82 30       	cpi	r24, 0x02	; 2
    eed2:	91 05       	cpc	r25, r1
    eed4:	19 f0       	breq	.+6      	; 0xeedc <Led_off+0x16>
    eed6:	89 2b       	or	r24, r25
    eed8:	19 f0       	breq	.+6      	; 0xeee0 <Led_off+0x1a>
    eeda:	04 c0       	rjmp	.+8      	; 0xeee4 <Led_off+0x1e>
	{
		case (Amarillo):
			PORTE		|= 	_BV(AMARILLOe); 
    eedc:	77 9a       	sbi	0x0e, 7	; 14
    eede:	08 95       	ret
		break;
			
		case (Verde):
			PORTE		|= 	_BV(VERDEe); 
    eee0:	72 9a       	sbi	0x0e, 2	; 14
    eee2:	08 95       	ret
		case (Rojo):
			PORTB		|= 	_BV(ROJOb);
		break;
			
		default:
			PORTE		|=  _BV(AMARILLOe);
    eee4:	77 9a       	sbi	0x0e, 7	; 14
			PORTE		|=  _BV(VERDEe);
    eee6:	72 9a       	sbi	0x0e, 2	; 14
			PORTB		|=  _BV(ROJOb);
    eee8:	2f 9a       	sbi	0x05, 7	; 5
    eeea:	08 95       	ret

0000eeec <Test_perifericos>:
	}
}


void Test_perifericos(void)
{
    eeec:	8f 92       	push	r8
    eeee:	9f 92       	push	r9
    eef0:	af 92       	push	r10
    eef2:	bf 92       	push	r11
    eef4:	cf 92       	push	r12
    eef6:	df 92       	push	r13
    eef8:	ef 92       	push	r14
    eefa:	ff 92       	push	r15
    eefc:	0f 93       	push	r16
    eefe:	1f 93       	push	r17
    ef00:	df 93       	push	r29
    ef02:	cf 93       	push	r28
    ef04:	cd b7       	in	r28, 0x3d	; 61
    ef06:	de b7       	in	r29, 0x3e	; 62
    ef08:	a4 97       	sbiw	r28, 0x24	; 36
    ef0a:	0f b6       	in	r0, 0x3f	; 63
    ef0c:	f8 94       	cli
    ef0e:	de bf       	out	0x3e, r29	; 62
    ef10:	0f be       	out	0x3f, r0	; 63
    ef12:	cd bf       	out	0x3d, r28	; 61
	int rv;
	char pause;
	tFecha Test_Fecha;
	
	
	printf("Iniciando secuencia de pruebas perifericos...\n");
    ef14:	83 e0       	ldi	r24, 0x03	; 3
    ef16:	98 e7       	ldi	r25, 0x78	; 120
    ef18:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	//Prueba LCD y LED...
	printf("Mensaje prueba LCD y LED ...\n");
    ef1c:	81 e3       	ldi	r24, 0x31	; 49
    ef1e:	98 e7       	ldi	r25, 0x78	; 120
    ef20:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	fprintf(stderr, "T E S T   L C D.\n");
    ef24:	60 91 33 82 	lds	r22, 0x8233
    ef28:	70 91 34 82 	lds	r23, 0x8234
    ef2c:	8e e4       	ldi	r24, 0x4E	; 78
    ef2e:	98 e7       	ldi	r25, 0x78	; 120
    ef30:	0e 94 d0 88 	call	0x111a0	; 0x111a0 <fputs>
	Led_on(Amarillo);
    ef34:	82 e0       	ldi	r24, 0x02	; 2
    ef36:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
    ef3a:	20 e0       	ldi	r18, 0x00	; 0
    ef3c:	40 e2       	ldi	r20, 0x20	; 32
    ef3e:	5e e4       	ldi	r21, 0x4E	; 78
    ef40:	ca 01       	movw	r24, r20
    ef42:	01 97       	sbiw	r24, 0x01	; 1
    ef44:	f1 f7       	brne	.-4      	; 0xef42 <Test_perifericos+0x56>
/****************************************************************************************/  
void delay_1s(void)
{
  uint8 i;

  for (i = 0; i < 100; i++)   
    ef46:	2f 5f       	subi	r18, 0xFF	; 255
    ef48:	24 36       	cpi	r18, 0x64	; 100
    ef4a:	d1 f7       	brne	.-12     	; 0xef40 <Test_perifericos+0x54>
	//Prueba LCD y LED...
	printf("Mensaje prueba LCD y LED ...\n");
	fprintf(stderr, "T E S T   L C D.\n");
	Led_on(Amarillo);
	delay_1s();	
	Led_on(Verde);	
    ef4c:	80 e0       	ldi	r24, 0x00	; 0
    ef4e:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
    ef52:	20 e0       	ldi	r18, 0x00	; 0
    ef54:	40 e2       	ldi	r20, 0x20	; 32
    ef56:	5e e4       	ldi	r21, 0x4E	; 78
    ef58:	ca 01       	movw	r24, r20
    ef5a:	01 97       	sbiw	r24, 0x01	; 1
    ef5c:	f1 f7       	brne	.-4      	; 0xef5a <Test_perifericos+0x6e>
/****************************************************************************************/  
void delay_1s(void)
{
  uint8 i;

  for (i = 0; i < 100; i++)   
    ef5e:	2f 5f       	subi	r18, 0xFF	; 255
    ef60:	24 36       	cpi	r18, 0x64	; 100
    ef62:	d1 f7       	brne	.-12     	; 0xef58 <Test_perifericos+0x6c>
	fprintf(stderr, "T E S T   L C D.\n");
	Led_on(Amarillo);
	delay_1s();	
	Led_on(Verde);	
	delay_1s();	
	Led_on(Rojo);	
    ef64:	81 e0       	ldi	r24, 0x01	; 1
    ef66:	0e 94 51 77 	call	0xeea2	; 0xeea2 <Led_on>
    ef6a:	20 e0       	ldi	r18, 0x00	; 0
    ef6c:	40 e2       	ldi	r20, 0x20	; 32
    ef6e:	5e e4       	ldi	r21, 0x4E	; 78
    ef70:	ca 01       	movw	r24, r20
    ef72:	01 97       	sbiw	r24, 0x01	; 1
    ef74:	f1 f7       	brne	.-4      	; 0xef72 <Test_perifericos+0x86>
/****************************************************************************************/  
void delay_1s(void)
{
  uint8 i;

  for (i = 0; i < 100; i++)   
    ef76:	2f 5f       	subi	r18, 0xFF	; 255
    ef78:	24 36       	cpi	r18, 0x64	; 100
    ef7a:	d1 f7       	brne	.-12     	; 0xef70 <Test_perifericos+0x84>
	delay_1s();	
	Led_on(Verde);	
	delay_1s();	
	Led_on(Rojo);	
	delay_1s();	
	Led_off(Rojo);
    ef7c:	81 e0       	ldi	r24, 0x01	; 1
    ef7e:	90 e0       	ldi	r25, 0x00	; 0
    ef80:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
	Led_off(Verde);
    ef84:	80 e0       	ldi	r24, 0x00	; 0
    ef86:	90 e0       	ldi	r25, 0x00	; 0
    ef88:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
	Led_off(Amarillo);
    ef8c:	82 e0       	ldi	r24, 0x02	; 2
    ef8e:	90 e0       	ldi	r25, 0x00	; 0
    ef90:	0e 94 63 77 	call	0xeec6	; 0xeec6 <Led_off>
	printf("Resultado corecto Y/N\n");
    ef94:	80 e6       	ldi	r24, 0x60	; 96
    ef96:	98 e7       	ldi	r25, 0x78	; 120
    ef98:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	scanf("%s",&pause);
    ef9c:	00 d0       	rcall	.+0      	; 0xef9e <Test_perifericos+0xb2>
    ef9e:	00 d0       	rcall	.+0      	; 0xefa0 <Test_perifericos+0xb4>
    efa0:	36 e7       	ldi	r19, 0x76	; 118
    efa2:	c3 2e       	mov	r12, r19
    efa4:	38 e7       	ldi	r19, 0x78	; 120
    efa6:	d3 2e       	mov	r13, r19
    efa8:	ad b7       	in	r26, 0x3d	; 61
    efaa:	be b7       	in	r27, 0x3e	; 62
    efac:	12 96       	adiw	r26, 0x02	; 2
    efae:	dc 92       	st	X, r13
    efb0:	ce 92       	st	-X, r12
    efb2:	11 97       	sbiw	r26, 0x01	; 1
    efb4:	7e 01       	movw	r14, r28
    efb6:	08 94       	sec
    efb8:	e1 1c       	adc	r14, r1
    efba:	f1 1c       	adc	r15, r1
    efbc:	14 96       	adiw	r26, 0x04	; 4
    efbe:	fc 92       	st	X, r15
    efc0:	ee 92       	st	-X, r14
    efc2:	13 97       	sbiw	r26, 0x03	; 3
    efc4:	0e 94 49 89 	call	0x11292	; 0x11292 <scanf>

	
	//Prueba EEPROM Y RAM ATME1280	
	printf("Prueba de EEPROM interna del Atmega1280...\n");
    efc8:	0f 90       	pop	r0
    efca:	0f 90       	pop	r0
    efcc:	0f 90       	pop	r0
    efce:	0f 90       	pop	r0
    efd0:	89 e7       	ldi	r24, 0x79	; 121
    efd2:	98 e7       	ldi	r25, 0x78	; 120
    efd4:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	eeprom_read_block((void*)&RAM_var,(const void*)&ATmegaEEPROM_var,sizeof(PMDint32));
    efd8:	8e 01       	movw	r16, r28
    efda:	0e 5f       	subi	r16, 0xFE	; 254
    efdc:	1f 4f       	sbci	r17, 0xFF	; 255
    efde:	c8 01       	movw	r24, r16
    efe0:	6e e5       	ldi	r22, 0x5E	; 94
    efe2:	71 e0       	ldi	r23, 0x01	; 1
    efe4:	44 e0       	ldi	r20, 0x04	; 4
    efe6:	50 e0       	ldi	r21, 0x00	; 0
    efe8:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
	printf("Leyando ATmegaEEPROM_var = %ld\n",RAM_var);
    efec:	00 d0       	rcall	.+0      	; 0xefee <Test_perifericos+0x102>
    efee:	00 d0       	rcall	.+0      	; 0xeff0 <Test_perifericos+0x104>
    eff0:	00 d0       	rcall	.+0      	; 0xeff2 <Test_perifericos+0x106>
    eff2:	84 ea       	ldi	r24, 0xA4	; 164
    eff4:	98 e7       	ldi	r25, 0x78	; 120
    eff6:	ed b7       	in	r30, 0x3d	; 61
    eff8:	fe b7       	in	r31, 0x3e	; 62
    effa:	92 83       	std	Z+2, r25	; 0x02
    effc:	81 83       	std	Z+1, r24	; 0x01
    effe:	8a 81       	ldd	r24, Y+2	; 0x02
    f000:	9b 81       	ldd	r25, Y+3	; 0x03
    f002:	ac 81       	ldd	r26, Y+4	; 0x04
    f004:	bd 81       	ldd	r27, Y+5	; 0x05
    f006:	83 83       	std	Z+3, r24	; 0x03
    f008:	94 83       	std	Z+4, r25	; 0x04
    f00a:	a5 83       	std	Z+5, r26	; 0x05
    f00c:	b6 83       	std	Z+6, r27	; 0x06
    f00e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Actualizando a 3032 ...\n");
    f012:	2d b7       	in	r18, 0x3d	; 61
    f014:	3e b7       	in	r19, 0x3e	; 62
    f016:	2a 5f       	subi	r18, 0xFA	; 250
    f018:	3f 4f       	sbci	r19, 0xFF	; 255
    f01a:	0f b6       	in	r0, 0x3f	; 63
    f01c:	f8 94       	cli
    f01e:	3e bf       	out	0x3e, r19	; 62
    f020:	0f be       	out	0x3f, r0	; 63
    f022:	2d bf       	out	0x3d, r18	; 61
    f024:	84 ec       	ldi	r24, 0xC4	; 196
    f026:	98 e7       	ldi	r25, 0x78	; 120
    f028:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	RAM_var=3032;
    f02c:	88 ed       	ldi	r24, 0xD8	; 216
    f02e:	9b e0       	ldi	r25, 0x0B	; 11
    f030:	a0 e0       	ldi	r26, 0x00	; 0
    f032:	b0 e0       	ldi	r27, 0x00	; 0
    f034:	8a 83       	std	Y+2, r24	; 0x02
    f036:	9b 83       	std	Y+3, r25	; 0x03
    f038:	ac 83       	std	Y+4, r26	; 0x04
    f03a:	bd 83       	std	Y+5, r27	; 0x05
	eeprom_write_block((const void*)&RAM_var,(void*)&ATmegaEEPROM_var,sizeof(PMDint32));
    f03c:	c8 01       	movw	r24, r16
    f03e:	6e e5       	ldi	r22, 0x5E	; 94
    f040:	71 e0       	ldi	r23, 0x01	; 1
    f042:	44 e0       	ldi	r20, 0x04	; 4
    f044:	50 e0       	ldi	r21, 0x00	; 0
    f046:	0e 94 e3 89 	call	0x113c6	; 0x113c6 <__eewr_block_m1280>
	eeprom_read_block((void*)&RAM_var,(const void*)&ATmegaEEPROM_var,sizeof(PMDint32));
    f04a:	c8 01       	movw	r24, r16
    f04c:	6e e5       	ldi	r22, 0x5E	; 94
    f04e:	71 e0       	ldi	r23, 0x01	; 1
    f050:	44 e0       	ldi	r20, 0x04	; 4
    f052:	50 e0       	ldi	r21, 0x00	; 0
    f054:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__eerd_block_m1280>
	printf("Comprobando, ATmegaEEPROM_var = %ld\n",RAM_var);
    f058:	00 d0       	rcall	.+0      	; 0xf05a <Test_perifericos+0x16e>
    f05a:	00 d0       	rcall	.+0      	; 0xf05c <Test_perifericos+0x170>
    f05c:	00 d0       	rcall	.+0      	; 0xf05e <Test_perifericos+0x172>
    f05e:	8c ed       	ldi	r24, 0xDC	; 220
    f060:	98 e7       	ldi	r25, 0x78	; 120
    f062:	ad b7       	in	r26, 0x3d	; 61
    f064:	be b7       	in	r27, 0x3e	; 62
    f066:	12 96       	adiw	r26, 0x02	; 2
    f068:	9c 93       	st	X, r25
    f06a:	8e 93       	st	-X, r24
    f06c:	11 97       	sbiw	r26, 0x01	; 1
    f06e:	8a 81       	ldd	r24, Y+2	; 0x02
    f070:	9b 81       	ldd	r25, Y+3	; 0x03
    f072:	ac 81       	ldd	r26, Y+4	; 0x04
    f074:	bd 81       	ldd	r27, Y+5	; 0x05
    f076:	ed b7       	in	r30, 0x3d	; 61
    f078:	fe b7       	in	r31, 0x3e	; 62
    f07a:	83 83       	std	Z+3, r24	; 0x03
    f07c:	94 83       	std	Z+4, r25	; 0x04
    f07e:	a5 83       	std	Z+5, r26	; 0x05
    f080:	b6 83       	std	Z+6, r27	; 0x06
    f082:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	//Reiniciando..
	RAM_var=0;
    f086:	1a 82       	std	Y+2, r1	; 0x02
    f088:	1b 82       	std	Y+3, r1	; 0x03
    f08a:	1c 82       	std	Y+4, r1	; 0x04
    f08c:	1d 82       	std	Y+5, r1	; 0x05
	eeprom_write_block((const void*)&RAM_var,(void*)&ATmegaEEPROM_var,sizeof(PMDint32));
    f08e:	2d b7       	in	r18, 0x3d	; 61
    f090:	3e b7       	in	r19, 0x3e	; 62
    f092:	2a 5f       	subi	r18, 0xFA	; 250
    f094:	3f 4f       	sbci	r19, 0xFF	; 255
    f096:	0f b6       	in	r0, 0x3f	; 63
    f098:	f8 94       	cli
    f09a:	3e bf       	out	0x3e, r19	; 62
    f09c:	0f be       	out	0x3f, r0	; 63
    f09e:	2d bf       	out	0x3d, r18	; 61
    f0a0:	c8 01       	movw	r24, r16
    f0a2:	6e e5       	ldi	r22, 0x5E	; 94
    f0a4:	71 e0       	ldi	r23, 0x01	; 1
    f0a6:	44 e0       	ldi	r20, 0x04	; 4
    f0a8:	50 e0       	ldi	r21, 0x00	; 0
    f0aa:	0e 94 e3 89 	call	0x113c6	; 0x113c6 <__eewr_block_m1280>
	printf("Resultado corecto Y/N\n");
    f0ae:	80 e6       	ldi	r24, 0x60	; 96
    f0b0:	98 e7       	ldi	r25, 0x78	; 120
    f0b2:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	scanf("%s",&pause);
    f0b6:	00 d0       	rcall	.+0      	; 0xf0b8 <Test_perifericos+0x1cc>
    f0b8:	00 d0       	rcall	.+0      	; 0xf0ba <Test_perifericos+0x1ce>
    f0ba:	ad b7       	in	r26, 0x3d	; 61
    f0bc:	be b7       	in	r27, 0x3e	; 62
    f0be:	12 96       	adiw	r26, 0x02	; 2
    f0c0:	dc 92       	st	X, r13
    f0c2:	ce 92       	st	-X, r12
    f0c4:	11 97       	sbiw	r26, 0x01	; 1
    f0c6:	14 96       	adiw	r26, 0x04	; 4
    f0c8:	fc 92       	st	X, r15
    f0ca:	ee 92       	st	-X, r14
    f0cc:	13 97       	sbiw	r26, 0x03	; 3
    f0ce:	0e 94 49 89 	call	0x11292	; 0x11292 <scanf>

	//Prueba EEPROM Externa y Pose
	/*Obtengo las Poses de la eeprom, no se desea sobreescribir alguna poses existente*/
	Num_Poses=Get_Num_Poses();
    f0d2:	0f 90       	pop	r0
    f0d4:	0f 90       	pop	r0
    f0d6:	0f 90       	pop	r0
    f0d8:	0f 90       	pop	r0
    f0da:	0e 94 bc 73 	call	0xe778	; 0xe778 <Get_Num_Poses>
    f0de:	8c 01       	movw	r16, r24
	addr=(int32)(Num_Poses)*sizeof(PoseRobot)+sizeof(int16); 
    f0e0:	b8 01       	movw	r22, r16
    f0e2:	88 27       	eor	r24, r24
    f0e4:	77 fd       	sbrc	r23, 7
    f0e6:	80 95       	com	r24
    f0e8:	98 2f       	mov	r25, r24
    f0ea:	27 e1       	ldi	r18, 0x17	; 23
    f0ec:	30 e0       	ldi	r19, 0x00	; 0
    f0ee:	40 e0       	ldi	r20, 0x00	; 0
    f0f0:	50 e0       	ldi	r21, 0x00	; 0
    f0f2:	0e 94 6e 85 	call	0x10adc	; 0x10adc <__mulsi3>
    f0f6:	22 e0       	ldi	r18, 0x02	; 2
    f0f8:	c2 2e       	mov	r12, r18
    f0fa:	d1 2c       	mov	r13, r1
    f0fc:	e1 2c       	mov	r14, r1
    f0fe:	f1 2c       	mov	r15, r1
    f100:	c6 0e       	add	r12, r22
    f102:	d7 1e       	adc	r13, r23
    f104:	e8 1e       	adc	r14, r24
    f106:	f9 1e       	adc	r15, r25
	/*Pasar al Segundo Banco de Memoria */
	if(Num_Poses > (5696/2))
    f108:	01 52       	subi	r16, 0x21	; 33
    f10a:	1b 40       	sbci	r17, 0x0B	; 11
    f10c:	54 f0       	brlt	.+20     	; 0xf122 <Test_perifericos+0x236>
		addr=addr+7;
    f10e:	6b 01       	movw	r12, r22
    f110:	7c 01       	movw	r14, r24
    f112:	89 e0       	ldi	r24, 0x09	; 9
    f114:	90 e0       	ldi	r25, 0x00	; 0
    f116:	a0 e0       	ldi	r26, 0x00	; 0
    f118:	b0 e0       	ldi	r27, 0x00	; 0
    f11a:	c8 0e       	add	r12, r24
    f11c:	d9 1e       	adc	r13, r25
    f11e:	ea 1e       	adc	r14, r26
    f120:	fb 1e       	adc	r15, r27
	
	printf("Prueba de EEPROM externa, Leyendo Pose en la direccion %ld...\n",addr);
    f122:	00 d0       	rcall	.+0      	; 0xf124 <Test_perifericos+0x238>
    f124:	00 d0       	rcall	.+0      	; 0xf126 <Test_perifericos+0x23a>
    f126:	00 d0       	rcall	.+0      	; 0xf128 <Test_perifericos+0x23c>
    f128:	81 e0       	ldi	r24, 0x01	; 1
    f12a:	99 e7       	ldi	r25, 0x79	; 121
    f12c:	ad b7       	in	r26, 0x3d	; 61
    f12e:	be b7       	in	r27, 0x3e	; 62
    f130:	12 96       	adiw	r26, 0x02	; 2
    f132:	9c 93       	st	X, r25
    f134:	8e 93       	st	-X, r24
    f136:	11 97       	sbiw	r26, 0x01	; 1
    f138:	ed b7       	in	r30, 0x3d	; 61
    f13a:	fe b7       	in	r31, 0x3e	; 62
    f13c:	c3 82       	std	Z+3, r12	; 0x03
    f13e:	d4 82       	std	Z+4, r13	; 0x04
    f140:	e5 82       	std	Z+5, r14	; 0x05
    f142:	f6 82       	std	Z+6, r15	; 0x06
    f144:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	rv=ee24xx_read_bytes(addr,sizeof(PoseRobot),(uint8*)&Pose_test);
    f148:	bc 2c       	mov	r11, r12
    f14a:	ad 2c       	mov	r10, r13
    f14c:	9e 2c       	mov	r9, r14
    f14e:	8f 2c       	mov	r8, r15
    f150:	8e 01       	movw	r16, r28
    f152:	02 5f       	subi	r16, 0xF2	; 242
    f154:	1f 4f       	sbci	r17, 0xFF	; 255
    f156:	2d b7       	in	r18, 0x3d	; 61
    f158:	3e b7       	in	r19, 0x3e	; 62
    f15a:	2a 5f       	subi	r18, 0xFA	; 250
    f15c:	3f 4f       	sbci	r19, 0xFF	; 255
    f15e:	0f b6       	in	r0, 0x3f	; 63
    f160:	f8 94       	cli
    f162:	3e bf       	out	0x3e, r19	; 62
    f164:	0f be       	out	0x3f, r0	; 63
    f166:	2d bf       	out	0x3d, r18	; 61
    f168:	b6 01       	movw	r22, r12
    f16a:	c7 01       	movw	r24, r14
    f16c:	47 e1       	ldi	r20, 0x17	; 23
    f16e:	50 e0       	ldi	r21, 0x00	; 0
    f170:	98 01       	movw	r18, r16
    f172:	0e 94 6a 71 	call	0xe2d4	; 0xe2d4 <ee24xx_read_bytes>
    printf("Pose_test->Pos_num = %d   \n",Pose_test.id);	
    f176:	00 d0       	rcall	.+0      	; 0xf178 <Test_perifericos+0x28c>
    f178:	00 d0       	rcall	.+0      	; 0xf17a <Test_perifericos+0x28e>
    f17a:	80 e4       	ldi	r24, 0x40	; 64
    f17c:	99 e7       	ldi	r25, 0x79	; 121
    f17e:	ad b7       	in	r26, 0x3d	; 61
    f180:	be b7       	in	r27, 0x3e	; 62
    f182:	12 96       	adiw	r26, 0x02	; 2
    f184:	9c 93       	st	X, r25
    f186:	8e 93       	st	-X, r24
    f188:	11 97       	sbiw	r26, 0x01	; 1
    f18a:	8e 85       	ldd	r24, Y+14	; 0x0e
    f18c:	9f 85       	ldd	r25, Y+15	; 0x0f
    f18e:	14 96       	adiw	r26, 0x04	; 4
    f190:	9c 93       	st	X, r25
    f192:	8e 93       	st	-X, r24
    f194:	13 97       	sbiw	r26, 0x03	; 3
    f196:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Waist = %ld  \n ",Pose_test.Pos_Waist);	
    f19a:	00 d0       	rcall	.+0      	; 0xf19c <Test_perifericos+0x2b0>
    f19c:	8c e5       	ldi	r24, 0x5C	; 92
    f19e:	99 e7       	ldi	r25, 0x79	; 121
    f1a0:	ed b7       	in	r30, 0x3d	; 61
    f1a2:	fe b7       	in	r31, 0x3e	; 62
    f1a4:	92 83       	std	Z+2, r25	; 0x02
    f1a6:	81 83       	std	Z+1, r24	; 0x01
    f1a8:	88 89       	ldd	r24, Y+16	; 0x10
    f1aa:	99 89       	ldd	r25, Y+17	; 0x11
    f1ac:	aa 89       	ldd	r26, Y+18	; 0x12
    f1ae:	bb 89       	ldd	r27, Y+19	; 0x13
    f1b0:	83 83       	std	Z+3, r24	; 0x03
    f1b2:	94 83       	std	Z+4, r25	; 0x04
    f1b4:	a5 83       	std	Z+5, r26	; 0x05
    f1b6:	b6 83       	std	Z+6, r27	; 0x06
    f1b8:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Shoulder = %ld  \n ",Pose_test.Pos_Shoulder);	
    f1bc:	8b e7       	ldi	r24, 0x7B	; 123
    f1be:	99 e7       	ldi	r25, 0x79	; 121
    f1c0:	ad b7       	in	r26, 0x3d	; 61
    f1c2:	be b7       	in	r27, 0x3e	; 62
    f1c4:	12 96       	adiw	r26, 0x02	; 2
    f1c6:	9c 93       	st	X, r25
    f1c8:	8e 93       	st	-X, r24
    f1ca:	11 97       	sbiw	r26, 0x01	; 1
    f1cc:	8c 89       	ldd	r24, Y+20	; 0x14
    f1ce:	9d 89       	ldd	r25, Y+21	; 0x15
    f1d0:	ae 89       	ldd	r26, Y+22	; 0x16
    f1d2:	bf 89       	ldd	r27, Y+23	; 0x17
    f1d4:	ed b7       	in	r30, 0x3d	; 61
    f1d6:	fe b7       	in	r31, 0x3e	; 62
    f1d8:	83 83       	std	Z+3, r24	; 0x03
    f1da:	94 83       	std	Z+4, r25	; 0x04
    f1dc:	a5 83       	std	Z+5, r26	; 0x05
    f1de:	b6 83       	std	Z+6, r27	; 0x06
    f1e0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Elbow = %ld  \n ",Pose_test.Pos_Elbow);	
    f1e4:	8d e9       	ldi	r24, 0x9D	; 157
    f1e6:	99 e7       	ldi	r25, 0x79	; 121
    f1e8:	ad b7       	in	r26, 0x3d	; 61
    f1ea:	be b7       	in	r27, 0x3e	; 62
    f1ec:	12 96       	adiw	r26, 0x02	; 2
    f1ee:	9c 93       	st	X, r25
    f1f0:	8e 93       	st	-X, r24
    f1f2:	11 97       	sbiw	r26, 0x01	; 1
    f1f4:	88 8d       	ldd	r24, Y+24	; 0x18
    f1f6:	99 8d       	ldd	r25, Y+25	; 0x19
    f1f8:	aa 8d       	ldd	r26, Y+26	; 0x1a
    f1fa:	bb 8d       	ldd	r27, Y+27	; 0x1b
    f1fc:	ed b7       	in	r30, 0x3d	; 61
    f1fe:	fe b7       	in	r31, 0x3e	; 62
    f200:	83 83       	std	Z+3, r24	; 0x03
    f202:	94 83       	std	Z+4, r25	; 0x04
    f204:	a5 83       	std	Z+5, r26	; 0x05
    f206:	b6 83       	std	Z+6, r27	; 0x06
    f208:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Pitch = %ld  \n ",Pose_test.Pos_Pitch);	
    f20c:	8c eb       	ldi	r24, 0xBC	; 188
    f20e:	99 e7       	ldi	r25, 0x79	; 121
    f210:	ad b7       	in	r26, 0x3d	; 61
    f212:	be b7       	in	r27, 0x3e	; 62
    f214:	12 96       	adiw	r26, 0x02	; 2
    f216:	9c 93       	st	X, r25
    f218:	8e 93       	st	-X, r24
    f21a:	11 97       	sbiw	r26, 0x01	; 1
    f21c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    f21e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    f220:	ae 8d       	ldd	r26, Y+30	; 0x1e
    f222:	bf 8d       	ldd	r27, Y+31	; 0x1f
    f224:	ed b7       	in	r30, 0x3d	; 61
    f226:	fe b7       	in	r31, 0x3e	; 62
    f228:	83 83       	std	Z+3, r24	; 0x03
    f22a:	94 83       	std	Z+4, r25	; 0x04
    f22c:	a5 83       	std	Z+5, r26	; 0x05
    f22e:	b6 83       	std	Z+6, r27	; 0x06
    f230:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Roll= %ld  \n ",Pose_test.Pos_Roll);	
    f234:	8b ed       	ldi	r24, 0xDB	; 219
    f236:	99 e7       	ldi	r25, 0x79	; 121
    f238:	ad b7       	in	r26, 0x3d	; 61
    f23a:	be b7       	in	r27, 0x3e	; 62
    f23c:	12 96       	adiw	r26, 0x02	; 2
    f23e:	9c 93       	st	X, r25
    f240:	8e 93       	st	-X, r24
    f242:	11 97       	sbiw	r26, 0x01	; 1
    f244:	88 a1       	ldd	r24, Y+32	; 0x20
    f246:	99 a1       	ldd	r25, Y+33	; 0x21
    f248:	aa a1       	ldd	r26, Y+34	; 0x22
    f24a:	bb a1       	ldd	r27, Y+35	; 0x23
    f24c:	ed b7       	in	r30, 0x3d	; 61
    f24e:	fe b7       	in	r31, 0x3e	; 62
    f250:	83 83       	std	Z+3, r24	; 0x03
    f252:	94 83       	std	Z+4, r25	; 0x04
    f254:	a5 83       	std	Z+5, r26	; 0x05
    f256:	b6 83       	std	Z+6, r27	; 0x06
    f258:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	
	printf("Actualizando Pose_test a \n");
    f25c:	2d b7       	in	r18, 0x3d	; 61
    f25e:	3e b7       	in	r19, 0x3e	; 62
    f260:	2a 5f       	subi	r18, 0xFA	; 250
    f262:	3f 4f       	sbci	r19, 0xFF	; 255
    f264:	0f b6       	in	r0, 0x3f	; 63
    f266:	f8 94       	cli
    f268:	3e bf       	out	0x3e, r19	; 62
    f26a:	0f be       	out	0x3f, r0	; 63
    f26c:	2d bf       	out	0x3d, r18	; 61
    f26e:	88 ef       	ldi	r24, 0xF8	; 248
    f270:	99 e7       	ldi	r25, 0x79	; 121
    f272:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	printf("Pose_test->Pos_num = 3   \n");	
    f276:	82 e1       	ldi	r24, 0x12	; 18
    f278:	9a e7       	ldi	r25, 0x7A	; 122
    f27a:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	printf("Pose_test->Pos_Waist = 5670 \n ");	
    f27e:	00 d0       	rcall	.+0      	; 0xf280 <Test_perifericos+0x394>
    f280:	8c e2       	ldi	r24, 0x2C	; 44
    f282:	9a e7       	ldi	r25, 0x7A	; 122
    f284:	ad b7       	in	r26, 0x3d	; 61
    f286:	be b7       	in	r27, 0x3e	; 62
    f288:	12 96       	adiw	r26, 0x02	; 2
    f28a:	9c 93       	st	X, r25
    f28c:	8e 93       	st	-X, r24
    f28e:	11 97       	sbiw	r26, 0x01	; 1
    f290:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Shoulder = 6000 \n ");	
    f294:	8b e4       	ldi	r24, 0x4B	; 75
    f296:	9a e7       	ldi	r25, 0x7A	; 122
    f298:	ed b7       	in	r30, 0x3d	; 61
    f29a:	fe b7       	in	r31, 0x3e	; 62
    f29c:	92 83       	std	Z+2, r25	; 0x02
    f29e:	81 83       	std	Z+1, r24	; 0x01
    f2a0:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Elbow = 2400 \n ");	
    f2a4:	8d e6       	ldi	r24, 0x6D	; 109
    f2a6:	9a e7       	ldi	r25, 0x7A	; 122
    f2a8:	ad b7       	in	r26, 0x3d	; 61
    f2aa:	be b7       	in	r27, 0x3e	; 62
    f2ac:	12 96       	adiw	r26, 0x02	; 2
    f2ae:	9c 93       	st	X, r25
    f2b0:	8e 93       	st	-X, r24
    f2b2:	11 97       	sbiw	r26, 0x01	; 1
    f2b4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Pitch = 1000 \n ");	
    f2b8:	8c e8       	ldi	r24, 0x8C	; 140
    f2ba:	9a e7       	ldi	r25, 0x7A	; 122
    f2bc:	ed b7       	in	r30, 0x3d	; 61
    f2be:	fe b7       	in	r31, 0x3e	; 62
    f2c0:	92 83       	std	Z+2, r25	; 0x02
    f2c2:	81 83       	std	Z+1, r24	; 0x01
    f2c4:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Roll= 10 \n ");	
    f2c8:	8b ea       	ldi	r24, 0xAB	; 171
    f2ca:	9a e7       	ldi	r25, 0x7A	; 122
    f2cc:	ad b7       	in	r26, 0x3d	; 61
    f2ce:	be b7       	in	r27, 0x3e	; 62
    f2d0:	12 96       	adiw	r26, 0x02	; 2
    f2d2:	9c 93       	st	X, r25
    f2d4:	8e 93       	st	-X, r24
    f2d6:	11 97       	sbiw	r26, 0x01	; 1
    f2d8:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	Pose_test.id= 3;	
    f2dc:	83 e0       	ldi	r24, 0x03	; 3
    f2de:	90 e0       	ldi	r25, 0x00	; 0
    f2e0:	9f 87       	std	Y+15, r25	; 0x0f
    f2e2:	8e 87       	std	Y+14, r24	; 0x0e
	Pose_test.Pos_Waist=5670;	
    f2e4:	86 e2       	ldi	r24, 0x26	; 38
    f2e6:	96 e1       	ldi	r25, 0x16	; 22
    f2e8:	a0 e0       	ldi	r26, 0x00	; 0
    f2ea:	b0 e0       	ldi	r27, 0x00	; 0
    f2ec:	88 8b       	std	Y+16, r24	; 0x10
    f2ee:	99 8b       	std	Y+17, r25	; 0x11
    f2f0:	aa 8b       	std	Y+18, r26	; 0x12
    f2f2:	bb 8b       	std	Y+19, r27	; 0x13
	Pose_test.Pos_Shoulder=6000;	
    f2f4:	80 e7       	ldi	r24, 0x70	; 112
    f2f6:	97 e1       	ldi	r25, 0x17	; 23
    f2f8:	a0 e0       	ldi	r26, 0x00	; 0
    f2fa:	b0 e0       	ldi	r27, 0x00	; 0
    f2fc:	8c 8b       	std	Y+20, r24	; 0x14
    f2fe:	9d 8b       	std	Y+21, r25	; 0x15
    f300:	ae 8b       	std	Y+22, r26	; 0x16
    f302:	bf 8b       	std	Y+23, r27	; 0x17
	Pose_test.Pos_Elbow=2400;	
    f304:	80 e6       	ldi	r24, 0x60	; 96
    f306:	99 e0       	ldi	r25, 0x09	; 9
    f308:	a0 e0       	ldi	r26, 0x00	; 0
    f30a:	b0 e0       	ldi	r27, 0x00	; 0
    f30c:	88 8f       	std	Y+24, r24	; 0x18
    f30e:	99 8f       	std	Y+25, r25	; 0x19
    f310:	aa 8f       	std	Y+26, r26	; 0x1a
    f312:	bb 8f       	std	Y+27, r27	; 0x1b
	Pose_test.Pos_Pitch=1000;	
    f314:	88 ee       	ldi	r24, 0xE8	; 232
    f316:	93 e0       	ldi	r25, 0x03	; 3
    f318:	a0 e0       	ldi	r26, 0x00	; 0
    f31a:	b0 e0       	ldi	r27, 0x00	; 0
    f31c:	8c 8f       	std	Y+28, r24	; 0x1c
    f31e:	9d 8f       	std	Y+29, r25	; 0x1d
    f320:	ae 8f       	std	Y+30, r26	; 0x1e
    f322:	bf 8f       	std	Y+31, r27	; 0x1f
	Pose_test.Pos_Roll=10;
    f324:	8a e0       	ldi	r24, 0x0A	; 10
    f326:	90 e0       	ldi	r25, 0x00	; 0
    f328:	a0 e0       	ldi	r26, 0x00	; 0
    f32a:	b0 e0       	ldi	r27, 0x00	; 0
    f32c:	88 a3       	std	Y+32, r24	; 0x20
    f32e:	99 a3       	std	Y+33, r25	; 0x21
    f330:	aa a3       	std	Y+34, r26	; 0x22
    f332:	bb a3       	std	Y+35, r27	; 0x23
	/* grabando pose*/
	rv=ee24xx_write_bytes(addr,sizeof(PoseRobot),(uint8 *)&Pose_test);			
    f334:	0f 90       	pop	r0
    f336:	0f 90       	pop	r0
    f338:	b6 01       	movw	r22, r12
    f33a:	c7 01       	movw	r24, r14
    f33c:	47 e1       	ldi	r20, 0x17	; 23
    f33e:	50 e0       	ldi	r21, 0x00	; 0
    f340:	98 01       	movw	r18, r16
    f342:	0e 94 3f 71 	call	0xe27e	; 0xe27e <ee24xx_write_bytes>
    f346:	9c 01       	movw	r18, r24
	if(rv)
    f348:	00 97       	sbiw	r24, 0x00	; 0
    f34a:	81 f0       	breq	.+32     	; 0xf36c <Test_perifericos+0x480>
	{
		printf("Numero de datos grabados corectamente al grabar Num_Poses => %d\n",rv);
    f34c:	00 d0       	rcall	.+0      	; 0xf34e <Test_perifericos+0x462>
    f34e:	00 d0       	rcall	.+0      	; 0xf350 <Test_perifericos+0x464>
    f350:	86 ec       	ldi	r24, 0xC6	; 198
    f352:	9a e7       	ldi	r25, 0x7A	; 122
    f354:	ed b7       	in	r30, 0x3d	; 61
    f356:	fe b7       	in	r31, 0x3e	; 62
    f358:	92 83       	std	Z+2, r25	; 0x02
    f35a:	81 83       	std	Z+1, r24	; 0x01
    f35c:	34 83       	std	Z+4, r19	; 0x04
    f35e:	23 83       	std	Z+3, r18	; 0x03
    f360:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    f364:	0f 90       	pop	r0
    f366:	0f 90       	pop	r0
    f368:	0f 90       	pop	r0
    f36a:	0f 90       	pop	r0
		
	}		
	printf("Comprobando, Pose_test...\n");
    f36c:	87 e0       	ldi	r24, 0x07	; 7
    f36e:	9b e7       	ldi	r25, 0x7B	; 123
    f370:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	printf("Pose_test->Pos_num = %d   \n",Pose_test.id);	
    f374:	00 d0       	rcall	.+0      	; 0xf376 <Test_perifericos+0x48a>
    f376:	00 d0       	rcall	.+0      	; 0xf378 <Test_perifericos+0x48c>
    f378:	80 e4       	ldi	r24, 0x40	; 64
    f37a:	99 e7       	ldi	r25, 0x79	; 121
    f37c:	ad b7       	in	r26, 0x3d	; 61
    f37e:	be b7       	in	r27, 0x3e	; 62
    f380:	12 96       	adiw	r26, 0x02	; 2
    f382:	9c 93       	st	X, r25
    f384:	8e 93       	st	-X, r24
    f386:	11 97       	sbiw	r26, 0x01	; 1
    f388:	8e 85       	ldd	r24, Y+14	; 0x0e
    f38a:	9f 85       	ldd	r25, Y+15	; 0x0f
    f38c:	14 96       	adiw	r26, 0x04	; 4
    f38e:	9c 93       	st	X, r25
    f390:	8e 93       	st	-X, r24
    f392:	13 97       	sbiw	r26, 0x03	; 3
    f394:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Waist = %ld  \n ",Pose_test.Pos_Waist);	
    f398:	00 d0       	rcall	.+0      	; 0xf39a <Test_perifericos+0x4ae>
    f39a:	8c e5       	ldi	r24, 0x5C	; 92
    f39c:	99 e7       	ldi	r25, 0x79	; 121
    f39e:	ed b7       	in	r30, 0x3d	; 61
    f3a0:	fe b7       	in	r31, 0x3e	; 62
    f3a2:	92 83       	std	Z+2, r25	; 0x02
    f3a4:	81 83       	std	Z+1, r24	; 0x01
    f3a6:	88 89       	ldd	r24, Y+16	; 0x10
    f3a8:	99 89       	ldd	r25, Y+17	; 0x11
    f3aa:	aa 89       	ldd	r26, Y+18	; 0x12
    f3ac:	bb 89       	ldd	r27, Y+19	; 0x13
    f3ae:	83 83       	std	Z+3, r24	; 0x03
    f3b0:	94 83       	std	Z+4, r25	; 0x04
    f3b2:	a5 83       	std	Z+5, r26	; 0x05
    f3b4:	b6 83       	std	Z+6, r27	; 0x06
    f3b6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Shoulder = %ld  \n ",Pose_test.Pos_Shoulder);	
    f3ba:	8b e7       	ldi	r24, 0x7B	; 123
    f3bc:	99 e7       	ldi	r25, 0x79	; 121
    f3be:	ad b7       	in	r26, 0x3d	; 61
    f3c0:	be b7       	in	r27, 0x3e	; 62
    f3c2:	12 96       	adiw	r26, 0x02	; 2
    f3c4:	9c 93       	st	X, r25
    f3c6:	8e 93       	st	-X, r24
    f3c8:	11 97       	sbiw	r26, 0x01	; 1
    f3ca:	8c 89       	ldd	r24, Y+20	; 0x14
    f3cc:	9d 89       	ldd	r25, Y+21	; 0x15
    f3ce:	ae 89       	ldd	r26, Y+22	; 0x16
    f3d0:	bf 89       	ldd	r27, Y+23	; 0x17
    f3d2:	ed b7       	in	r30, 0x3d	; 61
    f3d4:	fe b7       	in	r31, 0x3e	; 62
    f3d6:	83 83       	std	Z+3, r24	; 0x03
    f3d8:	94 83       	std	Z+4, r25	; 0x04
    f3da:	a5 83       	std	Z+5, r26	; 0x05
    f3dc:	b6 83       	std	Z+6, r27	; 0x06
    f3de:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Elbow = %ld  \n ",Pose_test.Pos_Elbow);	
    f3e2:	8d e9       	ldi	r24, 0x9D	; 157
    f3e4:	99 e7       	ldi	r25, 0x79	; 121
    f3e6:	ad b7       	in	r26, 0x3d	; 61
    f3e8:	be b7       	in	r27, 0x3e	; 62
    f3ea:	12 96       	adiw	r26, 0x02	; 2
    f3ec:	9c 93       	st	X, r25
    f3ee:	8e 93       	st	-X, r24
    f3f0:	11 97       	sbiw	r26, 0x01	; 1
    f3f2:	88 8d       	ldd	r24, Y+24	; 0x18
    f3f4:	99 8d       	ldd	r25, Y+25	; 0x19
    f3f6:	aa 8d       	ldd	r26, Y+26	; 0x1a
    f3f8:	bb 8d       	ldd	r27, Y+27	; 0x1b
    f3fa:	ed b7       	in	r30, 0x3d	; 61
    f3fc:	fe b7       	in	r31, 0x3e	; 62
    f3fe:	83 83       	std	Z+3, r24	; 0x03
    f400:	94 83       	std	Z+4, r25	; 0x04
    f402:	a5 83       	std	Z+5, r26	; 0x05
    f404:	b6 83       	std	Z+6, r27	; 0x06
    f406:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Pitch = %ld  \n ",Pose_test.Pos_Pitch);	
    f40a:	8c eb       	ldi	r24, 0xBC	; 188
    f40c:	99 e7       	ldi	r25, 0x79	; 121
    f40e:	ad b7       	in	r26, 0x3d	; 61
    f410:	be b7       	in	r27, 0x3e	; 62
    f412:	12 96       	adiw	r26, 0x02	; 2
    f414:	9c 93       	st	X, r25
    f416:	8e 93       	st	-X, r24
    f418:	11 97       	sbiw	r26, 0x01	; 1
    f41a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    f41c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    f41e:	ae 8d       	ldd	r26, Y+30	; 0x1e
    f420:	bf 8d       	ldd	r27, Y+31	; 0x1f
    f422:	ed b7       	in	r30, 0x3d	; 61
    f424:	fe b7       	in	r31, 0x3e	; 62
    f426:	83 83       	std	Z+3, r24	; 0x03
    f428:	94 83       	std	Z+4, r25	; 0x04
    f42a:	a5 83       	std	Z+5, r26	; 0x05
    f42c:	b6 83       	std	Z+6, r27	; 0x06
    f42e:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	printf("Pose_test->Pos_Roll= %ld  \n ",Pose_test.Pos_Roll);	
    f432:	8b ed       	ldi	r24, 0xDB	; 219
    f434:	99 e7       	ldi	r25, 0x79	; 121
    f436:	ad b7       	in	r26, 0x3d	; 61
    f438:	be b7       	in	r27, 0x3e	; 62
    f43a:	12 96       	adiw	r26, 0x02	; 2
    f43c:	9c 93       	st	X, r25
    f43e:	8e 93       	st	-X, r24
    f440:	11 97       	sbiw	r26, 0x01	; 1
    f442:	88 a1       	ldd	r24, Y+32	; 0x20
    f444:	99 a1       	ldd	r25, Y+33	; 0x21
    f446:	aa a1       	ldd	r26, Y+34	; 0x22
    f448:	bb a1       	ldd	r27, Y+35	; 0x23
    f44a:	ed b7       	in	r30, 0x3d	; 61
    f44c:	fe b7       	in	r31, 0x3e	; 62
    f44e:	83 83       	std	Z+3, r24	; 0x03
    f450:	94 83       	std	Z+4, r25	; 0x04
    f452:	a5 83       	std	Z+5, r26	; 0x05
    f454:	b6 83       	std	Z+6, r27	; 0x06
    f456:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	//Reiniciando
	Pose_test.id= 0;	
    f45a:	1f 86       	std	Y+15, r1	; 0x0f
    f45c:	1e 86       	std	Y+14, r1	; 0x0e
	Pose_test.Pos_Waist=0;	
    f45e:	18 8a       	std	Y+16, r1	; 0x10
    f460:	19 8a       	std	Y+17, r1	; 0x11
    f462:	1a 8a       	std	Y+18, r1	; 0x12
    f464:	1b 8a       	std	Y+19, r1	; 0x13
	Pose_test.Pos_Shoulder=0;	
    f466:	1c 8a       	std	Y+20, r1	; 0x14
    f468:	1d 8a       	std	Y+21, r1	; 0x15
    f46a:	1e 8a       	std	Y+22, r1	; 0x16
    f46c:	1f 8a       	std	Y+23, r1	; 0x17
	Pose_test.Pos_Elbow=0;	
    f46e:	18 8e       	std	Y+24, r1	; 0x18
    f470:	19 8e       	std	Y+25, r1	; 0x19
    f472:	1a 8e       	std	Y+26, r1	; 0x1a
    f474:	1b 8e       	std	Y+27, r1	; 0x1b
	Pose_test.Pos_Pitch=0;	
    f476:	1c 8e       	std	Y+28, r1	; 0x1c
    f478:	1d 8e       	std	Y+29, r1	; 0x1d
    f47a:	1e 8e       	std	Y+30, r1	; 0x1e
    f47c:	1f 8e       	std	Y+31, r1	; 0x1f
	Pose_test.Pos_Roll=0;
    f47e:	18 a2       	std	Y+32, r1	; 0x20
    f480:	19 a2       	std	Y+33, r1	; 0x21
    f482:	1a a2       	std	Y+34, r1	; 0x22
    f484:	1b a2       	std	Y+35, r1	; 0x23
	/* grabando pose*/
	rv=ee24xx_write_bytes(addr,sizeof(PoseRobot),(uint8 *)&Pose_test);	
    f486:	2d b7       	in	r18, 0x3d	; 61
    f488:	3e b7       	in	r19, 0x3e	; 62
    f48a:	2a 5f       	subi	r18, 0xFA	; 250
    f48c:	3f 4f       	sbci	r19, 0xFF	; 255
    f48e:	0f b6       	in	r0, 0x3f	; 63
    f490:	f8 94       	cli
    f492:	3e bf       	out	0x3e, r19	; 62
    f494:	0f be       	out	0x3f, r0	; 63
    f496:	2d bf       	out	0x3d, r18	; 61
    f498:	6b 2d       	mov	r22, r11
    f49a:	7a 2d       	mov	r23, r10
    f49c:	89 2d       	mov	r24, r9
    f49e:	98 2d       	mov	r25, r8
    f4a0:	47 e1       	ldi	r20, 0x17	; 23
    f4a2:	50 e0       	ldi	r21, 0x00	; 0
    f4a4:	98 01       	movw	r18, r16
    f4a6:	0e 94 3f 71 	call	0xe27e	; 0xe27e <ee24xx_write_bytes>
	printf("Resultado corecto Y/N\n");
    f4aa:	80 e6       	ldi	r24, 0x60	; 96
    f4ac:	98 e7       	ldi	r25, 0x78	; 120
    f4ae:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	scanf("%s",&pause);
    f4b2:	00 d0       	rcall	.+0      	; 0xf4b4 <Test_perifericos+0x5c8>
    f4b4:	00 d0       	rcall	.+0      	; 0xf4b6 <Test_perifericos+0x5ca>
    f4b6:	86 e7       	ldi	r24, 0x76	; 118
    f4b8:	98 e7       	ldi	r25, 0x78	; 120
    f4ba:	ad b7       	in	r26, 0x3d	; 61
    f4bc:	be b7       	in	r27, 0x3e	; 62
    f4be:	12 96       	adiw	r26, 0x02	; 2
    f4c0:	9c 93       	st	X, r25
    f4c2:	8e 93       	st	-X, r24
    f4c4:	11 97       	sbiw	r26, 0x01	; 1
    f4c6:	ce 01       	movw	r24, r28
    f4c8:	01 96       	adiw	r24, 0x01	; 1
    f4ca:	14 96       	adiw	r26, 0x04	; 4
    f4cc:	9c 93       	st	X, r25
    f4ce:	8e 93       	st	-X, r24
    f4d0:	13 97       	sbiw	r26, 0x03	; 3
    f4d2:	0e 94 49 89 	call	0x11292	; 0x11292 <scanf>

	//Prueba RTC
	printf("Prueba RTC...\n");
    f4d6:	0f 90       	pop	r0
    f4d8:	0f 90       	pop	r0
    f4da:	0f 90       	pop	r0
    f4dc:	0f 90       	pop	r0
    f4de:	81 e2       	ldi	r24, 0x21	; 33
    f4e0:	9b e7       	ldi	r25, 0x7B	; 123
    f4e2:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	Read_Fecha(&Test_Fecha);
    f4e6:	ce 01       	movw	r24, r28
    f4e8:	06 96       	adiw	r24, 0x06	; 6
    f4ea:	0e 94 e6 71 	call	0xe3cc	; 0xe3cc <Read_Fecha>
	printf("Fecha = Hoy es el dia %s %x de %s de 200%x. \n",Dayname(Test_Fecha.dw),Test_Fecha.dt,Monthname(Test_Fecha.mo),Test_Fecha.yr);						
    f4ee:	8c 85       	ldd	r24, Y+12	; 0x0c
    f4f0:	0e 94 ba 24 	call	0x4974	; 0x4974 <Dayname>
    f4f4:	8c 01       	movw	r16, r24
    f4f6:	f9 84       	ldd	r15, Y+9	; 0x09
    f4f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    f4fa:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <Monthname>
    f4fe:	ed b7       	in	r30, 0x3d	; 61
    f500:	fe b7       	in	r31, 0x3e	; 62
    f502:	3a 97       	sbiw	r30, 0x0a	; 10
    f504:	0f b6       	in	r0, 0x3f	; 63
    f506:	f8 94       	cli
    f508:	fe bf       	out	0x3e, r31	; 62
    f50a:	0f be       	out	0x3f, r0	; 63
    f50c:	ed bf       	out	0x3d, r30	; 61
    f50e:	31 96       	adiw	r30, 0x01	; 1
    f510:	2f e2       	ldi	r18, 0x2F	; 47
    f512:	3b e7       	ldi	r19, 0x7B	; 123
    f514:	ad b7       	in	r26, 0x3d	; 61
    f516:	be b7       	in	r27, 0x3e	; 62
    f518:	12 96       	adiw	r26, 0x02	; 2
    f51a:	3c 93       	st	X, r19
    f51c:	2e 93       	st	-X, r18
    f51e:	11 97       	sbiw	r26, 0x01	; 1
    f520:	13 83       	std	Z+3, r17	; 0x03
    f522:	02 83       	std	Z+2, r16	; 0x02
    f524:	f4 82       	std	Z+4, r15	; 0x04
    f526:	15 82       	std	Z+5, r1	; 0x05
    f528:	97 83       	std	Z+7, r25	; 0x07
    f52a:	86 83       	std	Z+6, r24	; 0x06
    f52c:	8b 85       	ldd	r24, Y+11	; 0x0b
    f52e:	80 87       	std	Z+8, r24	; 0x08
    f530:	11 86       	std	Z+9, r1	; 0x09
    f532:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
	if((Test_Fecha.hr & 0x20) != 0)			
    f536:	88 85       	ldd	r24, Y+8	; 0x08
    f538:	90 e0       	ldi	r25, 0x00	; 0
    f53a:	ed b7       	in	r30, 0x3d	; 61
    f53c:	fe b7       	in	r31, 0x3e	; 62
    f53e:	3a 96       	adiw	r30, 0x0a	; 10
    f540:	0f b6       	in	r0, 0x3f	; 63
    f542:	f8 94       	cli
    f544:	fe bf       	out	0x3e, r31	; 62
    f546:	0f be       	out	0x3f, r0	; 63
    f548:	ed bf       	out	0x3d, r30	; 61
    f54a:	9c 01       	movw	r18, r24
    f54c:	2f 71       	andi	r18, 0x1F	; 31
    f54e:	30 70       	andi	r19, 0x00	; 0
    f550:	85 ff       	sbrs	r24, 5
    f552:	0e c0       	rjmp	.+28     	; 0xf570 <Test_perifericos+0x684>
		printf("Son las %x:%x:%x PM \n",(Test_Fecha.hr & 0x1F),Test_Fecha.mn,Test_Fecha.sc);
    f554:	8d b7       	in	r24, 0x3d	; 61
    f556:	9e b7       	in	r25, 0x3e	; 62
    f558:	08 97       	sbiw	r24, 0x08	; 8
    f55a:	0f b6       	in	r0, 0x3f	; 63
    f55c:	f8 94       	cli
    f55e:	9e bf       	out	0x3e, r25	; 62
    f560:	0f be       	out	0x3f, r0	; 63
    f562:	8d bf       	out	0x3d, r24	; 61
    f564:	ed b7       	in	r30, 0x3d	; 61
    f566:	fe b7       	in	r31, 0x3e	; 62
    f568:	31 96       	adiw	r30, 0x01	; 1
    f56a:	8d e5       	ldi	r24, 0x5D	; 93
    f56c:	9b e7       	ldi	r25, 0x7B	; 123
    f56e:	0d c0       	rjmp	.+26     	; 0xf58a <Test_perifericos+0x69e>
	else 
		printf("Son las %x:%x:%x AM \n",(Test_Fecha.hr & 0x1F),Test_Fecha.mn,Test_Fecha.sc);
    f570:	8d b7       	in	r24, 0x3d	; 61
    f572:	9e b7       	in	r25, 0x3e	; 62
    f574:	08 97       	sbiw	r24, 0x08	; 8
    f576:	0f b6       	in	r0, 0x3f	; 63
    f578:	f8 94       	cli
    f57a:	9e bf       	out	0x3e, r25	; 62
    f57c:	0f be       	out	0x3f, r0	; 63
    f57e:	8d bf       	out	0x3d, r24	; 61
    f580:	ed b7       	in	r30, 0x3d	; 61
    f582:	fe b7       	in	r31, 0x3e	; 62
    f584:	31 96       	adiw	r30, 0x01	; 1
    f586:	83 e7       	ldi	r24, 0x73	; 115
    f588:	9b e7       	ldi	r25, 0x7B	; 123
    f58a:	ad b7       	in	r26, 0x3d	; 61
    f58c:	be b7       	in	r27, 0x3e	; 62
    f58e:	12 96       	adiw	r26, 0x02	; 2
    f590:	9c 93       	st	X, r25
    f592:	8e 93       	st	-X, r24
    f594:	11 97       	sbiw	r26, 0x01	; 1
    f596:	33 83       	std	Z+3, r19	; 0x03
    f598:	22 83       	std	Z+2, r18	; 0x02
    f59a:	8f 81       	ldd	r24, Y+7	; 0x07
    f59c:	84 83       	std	Z+4, r24	; 0x04
    f59e:	15 82       	std	Z+5, r1	; 0x05
    f5a0:	8e 81       	ldd	r24, Y+6	; 0x06
    f5a2:	86 83       	std	Z+6, r24	; 0x06
    f5a4:	17 82       	std	Z+7, r1	; 0x07
    f5a6:	0e 94 fb 88 	call	0x111f6	; 0x111f6 <printf>
    f5aa:	ed b7       	in	r30, 0x3d	; 61
    f5ac:	fe b7       	in	r31, 0x3e	; 62
    f5ae:	38 96       	adiw	r30, 0x08	; 8
    f5b0:	0f b6       	in	r0, 0x3f	; 63
    f5b2:	f8 94       	cli
    f5b4:	fe bf       	out	0x3e, r31	; 62
    f5b6:	0f be       	out	0x3f, r0	; 63
    f5b8:	ed bf       	out	0x3d, r30	; 61
	printf("Resultado corecto Y/N\n");
    f5ba:	80 e6       	ldi	r24, 0x60	; 96
    f5bc:	98 e7       	ldi	r25, 0x78	; 120
    f5be:	0e 94 14 89 	call	0x11228	; 0x11228 <puts>
	scanf("%s",&pause);
    f5c2:	00 d0       	rcall	.+0      	; 0xf5c4 <Test_perifericos+0x6d8>
    f5c4:	00 d0       	rcall	.+0      	; 0xf5c6 <Test_perifericos+0x6da>
    f5c6:	86 e7       	ldi	r24, 0x76	; 118
    f5c8:	98 e7       	ldi	r25, 0x78	; 120
    f5ca:	ad b7       	in	r26, 0x3d	; 61
    f5cc:	be b7       	in	r27, 0x3e	; 62
    f5ce:	12 96       	adiw	r26, 0x02	; 2
    f5d0:	9c 93       	st	X, r25
    f5d2:	8e 93       	st	-X, r24
    f5d4:	11 97       	sbiw	r26, 0x01	; 1
    f5d6:	ce 01       	movw	r24, r28
    f5d8:	01 96       	adiw	r24, 0x01	; 1
    f5da:	14 96       	adiw	r26, 0x04	; 4
    f5dc:	9c 93       	st	X, r25
    f5de:	8e 93       	st	-X, r24
    f5e0:	13 97       	sbiw	r26, 0x03	; 3
    f5e2:	0e 94 49 89 	call	0x11292	; 0x11292 <scanf>
    f5e6:	0f 90       	pop	r0
    f5e8:	0f 90       	pop	r0
    f5ea:	0f 90       	pop	r0
    f5ec:	0f 90       	pop	r0





}
    f5ee:	a4 96       	adiw	r28, 0x24	; 36
    f5f0:	0f b6       	in	r0, 0x3f	; 63
    f5f2:	f8 94       	cli
    f5f4:	de bf       	out	0x3e, r29	; 62
    f5f6:	0f be       	out	0x3f, r0	; 63
    f5f8:	cd bf       	out	0x3d, r28	; 61
    f5fa:	cf 91       	pop	r28
    f5fc:	df 91       	pop	r29
    f5fe:	1f 91       	pop	r17
    f600:	0f 91       	pop	r16
    f602:	ff 90       	pop	r15
    f604:	ef 90       	pop	r14
    f606:	df 90       	pop	r13
    f608:	cf 90       	pop	r12
    f60a:	bf 90       	pop	r11
    f60c:	af 90       	pop	r10
    f60e:	9f 90       	pop	r9
    f610:	8f 90       	pop	r8
    f612:	08 95       	ret

0000f614 <vfprintf>:
    f614:	2f 92       	push	r2
    f616:	3f 92       	push	r3
    f618:	4f 92       	push	r4
    f61a:	5f 92       	push	r5
    f61c:	6f 92       	push	r6
    f61e:	7f 92       	push	r7
    f620:	8f 92       	push	r8
    f622:	9f 92       	push	r9
    f624:	af 92       	push	r10
    f626:	bf 92       	push	r11
    f628:	cf 92       	push	r12
    f62a:	df 92       	push	r13
    f62c:	ef 92       	push	r14
    f62e:	ff 92       	push	r15
    f630:	0f 93       	push	r16
    f632:	1f 93       	push	r17
    f634:	df 93       	push	r29
    f636:	cf 93       	push	r28
    f638:	cd b7       	in	r28, 0x3d	; 61
    f63a:	de b7       	in	r29, 0x3e	; 62
    f63c:	61 97       	sbiw	r28, 0x11	; 17
    f63e:	0f b6       	in	r0, 0x3f	; 63
    f640:	f8 94       	cli
    f642:	de bf       	out	0x3e, r29	; 62
    f644:	0f be       	out	0x3f, r0	; 63
    f646:	cd bf       	out	0x3d, r28	; 61
    f648:	3c 01       	movw	r6, r24
    f64a:	7f 87       	std	Y+15, r23	; 0x0f
    f64c:	6e 87       	std	Y+14, r22	; 0x0e
    f64e:	6a 01       	movw	r12, r20
    f650:	fc 01       	movw	r30, r24
    f652:	17 82       	std	Z+7, r1	; 0x07
    f654:	16 82       	std	Z+6, r1	; 0x06
    f656:	83 81       	ldd	r24, Z+3	; 0x03
    f658:	81 fd       	sbrc	r24, 1
    f65a:	03 c0       	rjmp	.+6      	; 0xf662 <vfprintf+0x4e>
    f65c:	6f ef       	ldi	r22, 0xFF	; 255
    f65e:	7f ef       	ldi	r23, 0xFF	; 255
    f660:	6f c3       	rjmp	.+1758   	; 0xfd40 <vfprintf+0x72c>
    f662:	9e 01       	movw	r18, r28
    f664:	2f 5f       	subi	r18, 0xFF	; 255
    f666:	3f 4f       	sbci	r19, 0xFF	; 255
    f668:	39 8b       	std	Y+17, r19	; 0x11
    f66a:	28 8b       	std	Y+16, r18	; 0x10
    f66c:	f3 01       	movw	r30, r6
    f66e:	23 81       	ldd	r18, Z+3	; 0x03
    f670:	ee 85       	ldd	r30, Y+14	; 0x0e
    f672:	ff 85       	ldd	r31, Y+15	; 0x0f
    f674:	23 fd       	sbrc	r18, 3
    f676:	85 91       	lpm	r24, Z+
    f678:	23 ff       	sbrs	r18, 3
    f67a:	81 91       	ld	r24, Z+
    f67c:	ff 87       	std	Y+15, r31	; 0x0f
    f67e:	ee 87       	std	Y+14, r30	; 0x0e
    f680:	88 23       	and	r24, r24
    f682:	09 f4       	brne	.+2      	; 0xf686 <vfprintf+0x72>
    f684:	5a c3       	rjmp	.+1716   	; 0xfd3a <vfprintf+0x726>
    f686:	85 32       	cpi	r24, 0x25	; 37
    f688:	51 f4       	brne	.+20     	; 0xf69e <vfprintf+0x8a>
    f68a:	ee 85       	ldd	r30, Y+14	; 0x0e
    f68c:	ff 85       	ldd	r31, Y+15	; 0x0f
    f68e:	23 fd       	sbrc	r18, 3
    f690:	85 91       	lpm	r24, Z+
    f692:	23 ff       	sbrs	r18, 3
    f694:	81 91       	ld	r24, Z+
    f696:	ff 87       	std	Y+15, r31	; 0x0f
    f698:	ee 87       	std	Y+14, r30	; 0x0e
    f69a:	85 32       	cpi	r24, 0x25	; 37
    f69c:	29 f4       	brne	.+10     	; 0xf6a8 <vfprintf+0x94>
    f69e:	90 e0       	ldi	r25, 0x00	; 0
    f6a0:	b3 01       	movw	r22, r6
    f6a2:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    f6a6:	e2 cf       	rjmp	.-60     	; 0xf66c <vfprintf+0x58>
    f6a8:	98 2f       	mov	r25, r24
    f6aa:	10 e0       	ldi	r17, 0x00	; 0
    f6ac:	88 24       	eor	r8, r8
    f6ae:	99 24       	eor	r9, r9
    f6b0:	10 32       	cpi	r17, 0x20	; 32
    f6b2:	b0 f4       	brcc	.+44     	; 0xf6e0 <vfprintf+0xcc>
    f6b4:	9b 32       	cpi	r25, 0x2B	; 43
    f6b6:	69 f0       	breq	.+26     	; 0xf6d2 <vfprintf+0xbe>
    f6b8:	9c 32       	cpi	r25, 0x2C	; 44
    f6ba:	28 f4       	brcc	.+10     	; 0xf6c6 <vfprintf+0xb2>
    f6bc:	90 32       	cpi	r25, 0x20	; 32
    f6be:	51 f0       	breq	.+20     	; 0xf6d4 <vfprintf+0xc0>
    f6c0:	93 32       	cpi	r25, 0x23	; 35
    f6c2:	71 f4       	brne	.+28     	; 0xf6e0 <vfprintf+0xcc>
    f6c4:	0b c0       	rjmp	.+22     	; 0xf6dc <vfprintf+0xc8>
    f6c6:	9d 32       	cpi	r25, 0x2D	; 45
    f6c8:	39 f0       	breq	.+14     	; 0xf6d8 <vfprintf+0xc4>
    f6ca:	90 33       	cpi	r25, 0x30	; 48
    f6cc:	49 f4       	brne	.+18     	; 0xf6e0 <vfprintf+0xcc>
    f6ce:	11 60       	ori	r17, 0x01	; 1
    f6d0:	28 c0       	rjmp	.+80     	; 0xf722 <vfprintf+0x10e>
    f6d2:	12 60       	ori	r17, 0x02	; 2
    f6d4:	14 60       	ori	r17, 0x04	; 4
    f6d6:	25 c0       	rjmp	.+74     	; 0xf722 <vfprintf+0x10e>
    f6d8:	18 60       	ori	r17, 0x08	; 8
    f6da:	23 c0       	rjmp	.+70     	; 0xf722 <vfprintf+0x10e>
    f6dc:	10 61       	ori	r17, 0x10	; 16
    f6de:	21 c0       	rjmp	.+66     	; 0xf722 <vfprintf+0x10e>
    f6e0:	17 fd       	sbrc	r17, 7
    f6e2:	2a c0       	rjmp	.+84     	; 0xf738 <vfprintf+0x124>
    f6e4:	89 2f       	mov	r24, r25
    f6e6:	80 53       	subi	r24, 0x30	; 48
    f6e8:	8a 30       	cpi	r24, 0x0A	; 10
    f6ea:	78 f4       	brcc	.+30     	; 0xf70a <vfprintf+0xf6>
    f6ec:	16 ff       	sbrs	r17, 6
    f6ee:	06 c0       	rjmp	.+12     	; 0xf6fc <vfprintf+0xe8>
    f6f0:	fa e0       	ldi	r31, 0x0A	; 10
    f6f2:	9f 9e       	mul	r9, r31
    f6f4:	90 2c       	mov	r9, r0
    f6f6:	11 24       	eor	r1, r1
    f6f8:	98 0e       	add	r9, r24
    f6fa:	13 c0       	rjmp	.+38     	; 0xf722 <vfprintf+0x10e>
    f6fc:	3a e0       	ldi	r19, 0x0A	; 10
    f6fe:	83 9e       	mul	r8, r19
    f700:	80 2c       	mov	r8, r0
    f702:	11 24       	eor	r1, r1
    f704:	88 0e       	add	r8, r24
    f706:	10 62       	ori	r17, 0x20	; 32
    f708:	0c c0       	rjmp	.+24     	; 0xf722 <vfprintf+0x10e>
    f70a:	9e 32       	cpi	r25, 0x2E	; 46
    f70c:	21 f4       	brne	.+8      	; 0xf716 <vfprintf+0x102>
    f70e:	16 fd       	sbrc	r17, 6
    f710:	14 c3       	rjmp	.+1576   	; 0xfd3a <vfprintf+0x726>
    f712:	10 64       	ori	r17, 0x40	; 64
    f714:	06 c0       	rjmp	.+12     	; 0xf722 <vfprintf+0x10e>
    f716:	9c 36       	cpi	r25, 0x6C	; 108
    f718:	11 f4       	brne	.+4      	; 0xf71e <vfprintf+0x10a>
    f71a:	10 68       	ori	r17, 0x80	; 128
    f71c:	02 c0       	rjmp	.+4      	; 0xf722 <vfprintf+0x10e>
    f71e:	98 36       	cpi	r25, 0x68	; 104
    f720:	59 f4       	brne	.+22     	; 0xf738 <vfprintf+0x124>
    f722:	ee 85       	ldd	r30, Y+14	; 0x0e
    f724:	ff 85       	ldd	r31, Y+15	; 0x0f
    f726:	23 fd       	sbrc	r18, 3
    f728:	95 91       	lpm	r25, Z+
    f72a:	23 ff       	sbrs	r18, 3
    f72c:	91 91       	ld	r25, Z+
    f72e:	ff 87       	std	Y+15, r31	; 0x0f
    f730:	ee 87       	std	Y+14, r30	; 0x0e
    f732:	99 23       	and	r25, r25
    f734:	09 f0       	breq	.+2      	; 0xf738 <vfprintf+0x124>
    f736:	bc cf       	rjmp	.-136    	; 0xf6b0 <vfprintf+0x9c>
    f738:	89 2f       	mov	r24, r25
    f73a:	85 54       	subi	r24, 0x45	; 69
    f73c:	83 30       	cpi	r24, 0x03	; 3
    f73e:	20 f4       	brcc	.+8      	; 0xf748 <vfprintf+0x134>
    f740:	81 2f       	mov	r24, r17
    f742:	80 61       	ori	r24, 0x10	; 16
    f744:	90 5e       	subi	r25, 0xE0	; 224
    f746:	07 c0       	rjmp	.+14     	; 0xf756 <vfprintf+0x142>
    f748:	89 2f       	mov	r24, r25
    f74a:	85 56       	subi	r24, 0x65	; 101
    f74c:	83 30       	cpi	r24, 0x03	; 3
    f74e:	08 f0       	brcs	.+2      	; 0xf752 <vfprintf+0x13e>
    f750:	9f c1       	rjmp	.+830    	; 0xfa90 <vfprintf+0x47c>
    f752:	81 2f       	mov	r24, r17
    f754:	8f 7e       	andi	r24, 0xEF	; 239
    f756:	86 fd       	sbrc	r24, 6
    f758:	02 c0       	rjmp	.+4      	; 0xf75e <vfprintf+0x14a>
    f75a:	76 e0       	ldi	r23, 0x06	; 6
    f75c:	97 2e       	mov	r9, r23
    f75e:	6f e3       	ldi	r22, 0x3F	; 63
    f760:	f6 2e       	mov	r15, r22
    f762:	f8 22       	and	r15, r24
    f764:	95 36       	cpi	r25, 0x65	; 101
    f766:	19 f4       	brne	.+6      	; 0xf76e <vfprintf+0x15a>
    f768:	f0 e4       	ldi	r31, 0x40	; 64
    f76a:	ff 2a       	or	r15, r31
    f76c:	07 c0       	rjmp	.+14     	; 0xf77c <vfprintf+0x168>
    f76e:	96 36       	cpi	r25, 0x66	; 102
    f770:	19 f4       	brne	.+6      	; 0xf778 <vfprintf+0x164>
    f772:	20 e8       	ldi	r18, 0x80	; 128
    f774:	f2 2a       	or	r15, r18
    f776:	02 c0       	rjmp	.+4      	; 0xf77c <vfprintf+0x168>
    f778:	91 10       	cpse	r9, r1
    f77a:	9a 94       	dec	r9
    f77c:	f7 fe       	sbrs	r15, 7
    f77e:	0a c0       	rjmp	.+20     	; 0xf794 <vfprintf+0x180>
    f780:	3b e3       	ldi	r19, 0x3B	; 59
    f782:	39 15       	cp	r19, r9
    f784:	18 f4       	brcc	.+6      	; 0xf78c <vfprintf+0x178>
    f786:	5c e3       	ldi	r21, 0x3C	; 60
    f788:	b5 2e       	mov	r11, r21
    f78a:	02 c0       	rjmp	.+4      	; 0xf790 <vfprintf+0x17c>
    f78c:	b9 2c       	mov	r11, r9
    f78e:	b3 94       	inc	r11
    f790:	27 e0       	ldi	r18, 0x07	; 7
    f792:	09 c0       	rjmp	.+18     	; 0xf7a6 <vfprintf+0x192>
    f794:	47 e0       	ldi	r20, 0x07	; 7
    f796:	49 15       	cp	r20, r9
    f798:	20 f4       	brcc	.+8      	; 0xf7a2 <vfprintf+0x18e>
    f79a:	bb 24       	eor	r11, r11
    f79c:	47 e0       	ldi	r20, 0x07	; 7
    f79e:	94 2e       	mov	r9, r20
    f7a0:	f7 cf       	rjmp	.-18     	; 0xf790 <vfprintf+0x17c>
    f7a2:	29 2d       	mov	r18, r9
    f7a4:	bb 24       	eor	r11, r11
    f7a6:	c6 01       	movw	r24, r12
    f7a8:	04 96       	adiw	r24, 0x04	; 4
    f7aa:	9d 87       	std	Y+13, r25	; 0x0d
    f7ac:	8c 87       	std	Y+12, r24	; 0x0c
    f7ae:	f6 01       	movw	r30, r12
    f7b0:	60 81       	ld	r22, Z
    f7b2:	71 81       	ldd	r23, Z+1	; 0x01
    f7b4:	82 81       	ldd	r24, Z+2	; 0x02
    f7b6:	93 81       	ldd	r25, Z+3	; 0x03
    f7b8:	ae 01       	movw	r20, r28
    f7ba:	4f 5f       	subi	r20, 0xFF	; 255
    f7bc:	5f 4f       	sbci	r21, 0xFF	; 255
    f7be:	0b 2d       	mov	r16, r11
    f7c0:	0e 94 02 87 	call	0x10e04	; 0x10e04 <__ftoa_engine>
    f7c4:	6c 01       	movw	r12, r24
    f7c6:	09 81       	ldd	r16, Y+1	; 0x01
    f7c8:	20 2e       	mov	r2, r16
    f7ca:	33 24       	eor	r3, r3
    f7cc:	00 ff       	sbrs	r16, 0
    f7ce:	04 c0       	rjmp	.+8      	; 0xf7d8 <vfprintf+0x1c4>
    f7d0:	03 fd       	sbrc	r16, 3
    f7d2:	02 c0       	rjmp	.+4      	; 0xf7d8 <vfprintf+0x1c4>
    f7d4:	1d e2       	ldi	r17, 0x2D	; 45
    f7d6:	09 c0       	rjmp	.+18     	; 0xf7ea <vfprintf+0x1d6>
    f7d8:	f1 fe       	sbrs	r15, 1
    f7da:	02 c0       	rjmp	.+4      	; 0xf7e0 <vfprintf+0x1cc>
    f7dc:	1b e2       	ldi	r17, 0x2B	; 43
    f7de:	05 c0       	rjmp	.+10     	; 0xf7ea <vfprintf+0x1d6>
    f7e0:	f2 fc       	sbrc	r15, 2
    f7e2:	02 c0       	rjmp	.+4      	; 0xf7e8 <vfprintf+0x1d4>
    f7e4:	10 e0       	ldi	r17, 0x00	; 0
    f7e6:	01 c0       	rjmp	.+2      	; 0xf7ea <vfprintf+0x1d6>
    f7e8:	10 e2       	ldi	r17, 0x20	; 32
    f7ea:	c1 01       	movw	r24, r2
    f7ec:	8c 70       	andi	r24, 0x0C	; 12
    f7ee:	90 70       	andi	r25, 0x00	; 0
    f7f0:	89 2b       	or	r24, r25
    f7f2:	b9 f1       	breq	.+110    	; 0xf862 <vfprintf+0x24e>
    f7f4:	11 23       	and	r17, r17
    f7f6:	11 f4       	brne	.+4      	; 0xf7fc <vfprintf+0x1e8>
    f7f8:	83 e0       	ldi	r24, 0x03	; 3
    f7fa:	01 c0       	rjmp	.+2      	; 0xf7fe <vfprintf+0x1ea>
    f7fc:	84 e0       	ldi	r24, 0x04	; 4
    f7fe:	88 15       	cp	r24, r8
    f800:	10 f0       	brcs	.+4      	; 0xf806 <vfprintf+0x1f2>
    f802:	88 24       	eor	r8, r8
    f804:	0a c0       	rjmp	.+20     	; 0xf81a <vfprintf+0x206>
    f806:	88 1a       	sub	r8, r24
    f808:	f3 fc       	sbrc	r15, 3
    f80a:	07 c0       	rjmp	.+14     	; 0xf81a <vfprintf+0x206>
    f80c:	80 e2       	ldi	r24, 0x20	; 32
    f80e:	90 e0       	ldi	r25, 0x00	; 0
    f810:	b3 01       	movw	r22, r6
    f812:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    f816:	8a 94       	dec	r8
    f818:	c9 f7       	brne	.-14     	; 0xf80c <vfprintf+0x1f8>
    f81a:	11 23       	and	r17, r17
    f81c:	29 f0       	breq	.+10     	; 0xf828 <vfprintf+0x214>
    f81e:	81 2f       	mov	r24, r17
    f820:	90 e0       	ldi	r25, 0x00	; 0
    f822:	b3 01       	movw	r22, r6
    f824:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    f828:	23 fe       	sbrs	r2, 3
    f82a:	03 c0       	rjmp	.+6      	; 0xf832 <vfprintf+0x21e>
    f82c:	09 ef       	ldi	r16, 0xF9	; 249
    f82e:	14 e0       	ldi	r17, 0x04	; 4
    f830:	0e c0       	rjmp	.+28     	; 0xf84e <vfprintf+0x23a>
    f832:	0d ef       	ldi	r16, 0xFD	; 253
    f834:	14 e0       	ldi	r17, 0x04	; 4
    f836:	0b c0       	rjmp	.+22     	; 0xf84e <vfprintf+0x23a>
    f838:	e1 14       	cp	r14, r1
    f83a:	f1 04       	cpc	r15, r1
    f83c:	09 f0       	breq	.+2      	; 0xf840 <vfprintf+0x22c>
    f83e:	80 52       	subi	r24, 0x20	; 32
    f840:	90 e0       	ldi	r25, 0x00	; 0
    f842:	b3 01       	movw	r22, r6
    f844:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    f848:	0f 5f       	subi	r16, 0xFF	; 255
    f84a:	1f 4f       	sbci	r17, 0xFF	; 255
    f84c:	05 c0       	rjmp	.+10     	; 0xf858 <vfprintf+0x244>
    f84e:	ef 2c       	mov	r14, r15
    f850:	ff 24       	eor	r15, r15
    f852:	f0 e1       	ldi	r31, 0x10	; 16
    f854:	ef 22       	and	r14, r31
    f856:	ff 24       	eor	r15, r15
    f858:	f8 01       	movw	r30, r16
    f85a:	84 91       	lpm	r24, Z+
    f85c:	88 23       	and	r24, r24
    f85e:	61 f7       	brne	.-40     	; 0xf838 <vfprintf+0x224>
    f860:	14 c1       	rjmp	.+552    	; 0xfa8a <vfprintf+0x476>
    f862:	f7 fe       	sbrs	r15, 7
    f864:	12 c0       	rjmp	.+36     	; 0xf88a <vfprintf+0x276>
    f866:	bc 0c       	add	r11, r12
    f868:	24 fe       	sbrs	r2, 4
    f86a:	04 c0       	rjmp	.+8      	; 0xf874 <vfprintf+0x260>
    f86c:	8a 81       	ldd	r24, Y+2	; 0x02
    f86e:	81 33       	cpi	r24, 0x31	; 49
    f870:	09 f4       	brne	.+2      	; 0xf874 <vfprintf+0x260>
    f872:	ba 94       	dec	r11
    f874:	1b 14       	cp	r1, r11
    f876:	1c f0       	brlt	.+6      	; 0xf87e <vfprintf+0x26a>
    f878:	bb 24       	eor	r11, r11
    f87a:	b3 94       	inc	r11
    f87c:	2d c0       	rjmp	.+90     	; 0xf8d8 <vfprintf+0x2c4>
    f87e:	f8 e0       	ldi	r31, 0x08	; 8
    f880:	fb 15       	cp	r31, r11
    f882:	50 f5       	brcc	.+84     	; 0xf8d8 <vfprintf+0x2c4>
    f884:	38 e0       	ldi	r19, 0x08	; 8
    f886:	b3 2e       	mov	r11, r19
    f888:	27 c0       	rjmp	.+78     	; 0xf8d8 <vfprintf+0x2c4>
    f88a:	f6 fc       	sbrc	r15, 6
    f88c:	25 c0       	rjmp	.+74     	; 0xf8d8 <vfprintf+0x2c4>
    f88e:	89 2d       	mov	r24, r9
    f890:	90 e0       	ldi	r25, 0x00	; 0
    f892:	8c 15       	cp	r24, r12
    f894:	9d 05       	cpc	r25, r13
    f896:	4c f0       	brlt	.+18     	; 0xf8aa <vfprintf+0x296>
    f898:	2c ef       	ldi	r18, 0xFC	; 252
    f89a:	c2 16       	cp	r12, r18
    f89c:	2f ef       	ldi	r18, 0xFF	; 255
    f89e:	d2 06       	cpc	r13, r18
    f8a0:	24 f0       	brlt	.+8      	; 0xf8aa <vfprintf+0x296>
    f8a2:	30 e8       	ldi	r19, 0x80	; 128
    f8a4:	f3 2a       	or	r15, r19
    f8a6:	01 c0       	rjmp	.+2      	; 0xf8aa <vfprintf+0x296>
    f8a8:	9a 94       	dec	r9
    f8aa:	99 20       	and	r9, r9
    f8ac:	49 f0       	breq	.+18     	; 0xf8c0 <vfprintf+0x2ac>
    f8ae:	e2 e0       	ldi	r30, 0x02	; 2
    f8b0:	f0 e0       	ldi	r31, 0x00	; 0
    f8b2:	ec 0f       	add	r30, r28
    f8b4:	fd 1f       	adc	r31, r29
    f8b6:	e9 0d       	add	r30, r9
    f8b8:	f1 1d       	adc	r31, r1
    f8ba:	80 81       	ld	r24, Z
    f8bc:	80 33       	cpi	r24, 0x30	; 48
    f8be:	a1 f3       	breq	.-24     	; 0xf8a8 <vfprintf+0x294>
    f8c0:	f7 fe       	sbrs	r15, 7
    f8c2:	0a c0       	rjmp	.+20     	; 0xf8d8 <vfprintf+0x2c4>
    f8c4:	b9 2c       	mov	r11, r9
    f8c6:	b3 94       	inc	r11
    f8c8:	89 2d       	mov	r24, r9
    f8ca:	90 e0       	ldi	r25, 0x00	; 0
    f8cc:	c8 16       	cp	r12, r24
    f8ce:	d9 06       	cpc	r13, r25
    f8d0:	14 f0       	brlt	.+4      	; 0xf8d6 <vfprintf+0x2c2>
    f8d2:	99 24       	eor	r9, r9
    f8d4:	01 c0       	rjmp	.+2      	; 0xf8d8 <vfprintf+0x2c4>
    f8d6:	9c 18       	sub	r9, r12
    f8d8:	f7 fc       	sbrc	r15, 7
    f8da:	03 c0       	rjmp	.+6      	; 0xf8e2 <vfprintf+0x2ce>
    f8dc:	25 e0       	ldi	r18, 0x05	; 5
    f8de:	30 e0       	ldi	r19, 0x00	; 0
    f8e0:	09 c0       	rjmp	.+18     	; 0xf8f4 <vfprintf+0x2e0>
    f8e2:	1c 14       	cp	r1, r12
    f8e4:	1d 04       	cpc	r1, r13
    f8e6:	1c f0       	brlt	.+6      	; 0xf8ee <vfprintf+0x2da>
    f8e8:	21 e0       	ldi	r18, 0x01	; 1
    f8ea:	30 e0       	ldi	r19, 0x00	; 0
    f8ec:	03 c0       	rjmp	.+6      	; 0xf8f4 <vfprintf+0x2e0>
    f8ee:	96 01       	movw	r18, r12
    f8f0:	2f 5f       	subi	r18, 0xFF	; 255
    f8f2:	3f 4f       	sbci	r19, 0xFF	; 255
    f8f4:	11 23       	and	r17, r17
    f8f6:	11 f0       	breq	.+4      	; 0xf8fc <vfprintf+0x2e8>
    f8f8:	2f 5f       	subi	r18, 0xFF	; 255
    f8fa:	3f 4f       	sbci	r19, 0xFF	; 255
    f8fc:	99 20       	and	r9, r9
    f8fe:	29 f0       	breq	.+10     	; 0xf90a <vfprintf+0x2f6>
    f900:	89 2d       	mov	r24, r9
    f902:	90 e0       	ldi	r25, 0x00	; 0
    f904:	01 96       	adiw	r24, 0x01	; 1
    f906:	28 0f       	add	r18, r24
    f908:	39 1f       	adc	r19, r25
    f90a:	88 2d       	mov	r24, r8
    f90c:	90 e0       	ldi	r25, 0x00	; 0
    f90e:	28 17       	cp	r18, r24
    f910:	39 07       	cpc	r19, r25
    f912:	14 f0       	brlt	.+4      	; 0xf918 <vfprintf+0x304>
    f914:	88 24       	eor	r8, r8
    f916:	01 c0       	rjmp	.+2      	; 0xf91a <vfprintf+0x306>
    f918:	82 1a       	sub	r8, r18
    f91a:	4f 2c       	mov	r4, r15
    f91c:	55 24       	eor	r5, r5
    f91e:	c2 01       	movw	r24, r4
    f920:	89 70       	andi	r24, 0x09	; 9
    f922:	90 70       	andi	r25, 0x00	; 0
    f924:	89 2b       	or	r24, r25
    f926:	39 f0       	breq	.+14     	; 0xf936 <vfprintf+0x322>
    f928:	08 c0       	rjmp	.+16     	; 0xf93a <vfprintf+0x326>
    f92a:	80 e2       	ldi	r24, 0x20	; 32
    f92c:	90 e0       	ldi	r25, 0x00	; 0
    f92e:	b3 01       	movw	r22, r6
    f930:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    f934:	8a 94       	dec	r8
    f936:	88 20       	and	r8, r8
    f938:	c1 f7       	brne	.-16     	; 0xf92a <vfprintf+0x316>
    f93a:	11 23       	and	r17, r17
    f93c:	29 f0       	breq	.+10     	; 0xf948 <vfprintf+0x334>
    f93e:	81 2f       	mov	r24, r17
    f940:	90 e0       	ldi	r25, 0x00	; 0
    f942:	b3 01       	movw	r22, r6
    f944:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    f948:	43 fe       	sbrs	r4, 3
    f94a:	07 c0       	rjmp	.+14     	; 0xf95a <vfprintf+0x346>
    f94c:	08 c0       	rjmp	.+16     	; 0xf95e <vfprintf+0x34a>
    f94e:	80 e3       	ldi	r24, 0x30	; 48
    f950:	90 e0       	ldi	r25, 0x00	; 0
    f952:	b3 01       	movw	r22, r6
    f954:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    f958:	8a 94       	dec	r8
    f95a:	88 20       	and	r8, r8
    f95c:	c1 f7       	brne	.-16     	; 0xf94e <vfprintf+0x33a>
    f95e:	f7 fe       	sbrs	r15, 7
    f960:	46 c0       	rjmp	.+140    	; 0xf9ee <vfprintf+0x3da>
    f962:	86 01       	movw	r16, r12
    f964:	d7 fe       	sbrs	r13, 7
    f966:	02 c0       	rjmp	.+4      	; 0xf96c <vfprintf+0x358>
    f968:	00 e0       	ldi	r16, 0x00	; 0
    f96a:	10 e0       	ldi	r17, 0x00	; 0
    f96c:	76 01       	movw	r14, r12
    f96e:	08 94       	sec
    f970:	e1 1c       	adc	r14, r1
    f972:	f1 1c       	adc	r15, r1
    f974:	e0 1a       	sub	r14, r16
    f976:	f1 0a       	sbc	r15, r17
    f978:	41 e0       	ldi	r20, 0x01	; 1
    f97a:	50 e0       	ldi	r21, 0x00	; 0
    f97c:	4c 0f       	add	r20, r28
    f97e:	5d 1f       	adc	r21, r29
    f980:	e4 0e       	add	r14, r20
    f982:	f5 1e       	adc	r15, r21
    f984:	26 01       	movw	r4, r12
    f986:	4b 18       	sub	r4, r11
    f988:	51 08       	sbc	r5, r1
    f98a:	89 2d       	mov	r24, r9
    f98c:	90 e0       	ldi	r25, 0x00	; 0
    f98e:	aa 24       	eor	r10, r10
    f990:	bb 24       	eor	r11, r11
    f992:	a8 1a       	sub	r10, r24
    f994:	b9 0a       	sbc	r11, r25
    f996:	5f ef       	ldi	r21, 0xFF	; 255
    f998:	0f 3f       	cpi	r16, 0xFF	; 255
    f99a:	15 07       	cpc	r17, r21
    f99c:	29 f4       	brne	.+10     	; 0xf9a8 <vfprintf+0x394>
    f99e:	8e e2       	ldi	r24, 0x2E	; 46
    f9a0:	90 e0       	ldi	r25, 0x00	; 0
    f9a2:	b3 01       	movw	r22, r6
    f9a4:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    f9a8:	c0 16       	cp	r12, r16
    f9aa:	d1 06       	cpc	r13, r17
    f9ac:	34 f0       	brlt	.+12     	; 0xf9ba <vfprintf+0x3a6>
    f9ae:	40 16       	cp	r4, r16
    f9b0:	51 06       	cpc	r5, r17
    f9b2:	1c f4       	brge	.+6      	; 0xf9ba <vfprintf+0x3a6>
    f9b4:	f7 01       	movw	r30, r14
    f9b6:	80 81       	ld	r24, Z
    f9b8:	01 c0       	rjmp	.+2      	; 0xf9bc <vfprintf+0x3a8>
    f9ba:	80 e3       	ldi	r24, 0x30	; 48
    f9bc:	01 50       	subi	r16, 0x01	; 1
    f9be:	10 40       	sbci	r17, 0x00	; 0
    f9c0:	08 94       	sec
    f9c2:	e1 1c       	adc	r14, r1
    f9c4:	f1 1c       	adc	r15, r1
    f9c6:	0a 15       	cp	r16, r10
    f9c8:	1b 05       	cpc	r17, r11
    f9ca:	2c f0       	brlt	.+10     	; 0xf9d6 <vfprintf+0x3c2>
    f9cc:	90 e0       	ldi	r25, 0x00	; 0
    f9ce:	b3 01       	movw	r22, r6
    f9d0:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    f9d4:	e0 cf       	rjmp	.-64     	; 0xf996 <vfprintf+0x382>
    f9d6:	0c 15       	cp	r16, r12
    f9d8:	1d 05       	cpc	r17, r13
    f9da:	39 f4       	brne	.+14     	; 0xf9ea <vfprintf+0x3d6>
    f9dc:	9a 81       	ldd	r25, Y+2	; 0x02
    f9de:	96 33       	cpi	r25, 0x36	; 54
    f9e0:	18 f4       	brcc	.+6      	; 0xf9e8 <vfprintf+0x3d4>
    f9e2:	95 33       	cpi	r25, 0x35	; 53
    f9e4:	11 f4       	brne	.+4      	; 0xf9ea <vfprintf+0x3d6>
    f9e6:	24 fe       	sbrs	r2, 4
    f9e8:	81 e3       	ldi	r24, 0x31	; 49
    f9ea:	90 e0       	ldi	r25, 0x00	; 0
    f9ec:	4b c0       	rjmp	.+150    	; 0xfa84 <vfprintf+0x470>
    f9ee:	8a 81       	ldd	r24, Y+2	; 0x02
    f9f0:	81 33       	cpi	r24, 0x31	; 49
    f9f2:	09 f0       	breq	.+2      	; 0xf9f6 <vfprintf+0x3e2>
    f9f4:	0f 7e       	andi	r16, 0xEF	; 239
    f9f6:	90 e0       	ldi	r25, 0x00	; 0
    f9f8:	b3 01       	movw	r22, r6
    f9fa:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    f9fe:	99 20       	and	r9, r9
    fa00:	a1 f0       	breq	.+40     	; 0xfa2a <vfprintf+0x416>
    fa02:	8e e2       	ldi	r24, 0x2E	; 46
    fa04:	90 e0       	ldi	r25, 0x00	; 0
    fa06:	b3 01       	movw	r22, r6
    fa08:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fa0c:	12 e0       	ldi	r17, 0x02	; 2
    fa0e:	e1 e0       	ldi	r30, 0x01	; 1
    fa10:	f0 e0       	ldi	r31, 0x00	; 0
    fa12:	ec 0f       	add	r30, r28
    fa14:	fd 1f       	adc	r31, r29
    fa16:	e1 0f       	add	r30, r17
    fa18:	f1 1d       	adc	r31, r1
    fa1a:	1f 5f       	subi	r17, 0xFF	; 255
    fa1c:	80 81       	ld	r24, Z
    fa1e:	90 e0       	ldi	r25, 0x00	; 0
    fa20:	b3 01       	movw	r22, r6
    fa22:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fa26:	9a 94       	dec	r9
    fa28:	91 f7       	brne	.-28     	; 0xfa0e <vfprintf+0x3fa>
    fa2a:	44 fc       	sbrc	r4, 4
    fa2c:	03 c0       	rjmp	.+6      	; 0xfa34 <vfprintf+0x420>
    fa2e:	85 e6       	ldi	r24, 0x65	; 101
    fa30:	90 e0       	ldi	r25, 0x00	; 0
    fa32:	02 c0       	rjmp	.+4      	; 0xfa38 <vfprintf+0x424>
    fa34:	85 e4       	ldi	r24, 0x45	; 69
    fa36:	90 e0       	ldi	r25, 0x00	; 0
    fa38:	b3 01       	movw	r22, r6
    fa3a:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fa3e:	d7 fc       	sbrc	r13, 7
    fa40:	05 c0       	rjmp	.+10     	; 0xfa4c <vfprintf+0x438>
    fa42:	c1 14       	cp	r12, r1
    fa44:	d1 04       	cpc	r13, r1
    fa46:	41 f4       	brne	.+16     	; 0xfa58 <vfprintf+0x444>
    fa48:	04 ff       	sbrs	r16, 4
    fa4a:	06 c0       	rjmp	.+12     	; 0xfa58 <vfprintf+0x444>
    fa4c:	d0 94       	com	r13
    fa4e:	c1 94       	neg	r12
    fa50:	d1 08       	sbc	r13, r1
    fa52:	d3 94       	inc	r13
    fa54:	8d e2       	ldi	r24, 0x2D	; 45
    fa56:	01 c0       	rjmp	.+2      	; 0xfa5a <vfprintf+0x446>
    fa58:	8b e2       	ldi	r24, 0x2B	; 43
    fa5a:	90 e0       	ldi	r25, 0x00	; 0
    fa5c:	b3 01       	movw	r22, r6
    fa5e:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fa62:	80 e3       	ldi	r24, 0x30	; 48
    fa64:	05 c0       	rjmp	.+10     	; 0xfa70 <vfprintf+0x45c>
    fa66:	8f 5f       	subi	r24, 0xFF	; 255
    fa68:	26 ef       	ldi	r18, 0xF6	; 246
    fa6a:	3f ef       	ldi	r19, 0xFF	; 255
    fa6c:	c2 0e       	add	r12, r18
    fa6e:	d3 1e       	adc	r13, r19
    fa70:	3a e0       	ldi	r19, 0x0A	; 10
    fa72:	c3 16       	cp	r12, r19
    fa74:	d1 04       	cpc	r13, r1
    fa76:	bc f7       	brge	.-18     	; 0xfa66 <vfprintf+0x452>
    fa78:	90 e0       	ldi	r25, 0x00	; 0
    fa7a:	b3 01       	movw	r22, r6
    fa7c:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fa80:	c6 01       	movw	r24, r12
    fa82:	c0 96       	adiw	r24, 0x30	; 48
    fa84:	b3 01       	movw	r22, r6
    fa86:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fa8a:	cc 84       	ldd	r12, Y+12	; 0x0c
    fa8c:	dd 84       	ldd	r13, Y+13	; 0x0d
    fa8e:	52 c1       	rjmp	.+676    	; 0xfd34 <vfprintf+0x720>
    fa90:	93 36       	cpi	r25, 0x63	; 99
    fa92:	31 f0       	breq	.+12     	; 0xfaa0 <vfprintf+0x48c>
    fa94:	93 37       	cpi	r25, 0x73	; 115
    fa96:	99 f0       	breq	.+38     	; 0xfabe <vfprintf+0x4aa>
    fa98:	93 35       	cpi	r25, 0x53	; 83
    fa9a:	09 f0       	breq	.+2      	; 0xfa9e <vfprintf+0x48a>
    fa9c:	59 c0       	rjmp	.+178    	; 0xfb50 <vfprintf+0x53c>
    fa9e:	23 c0       	rjmp	.+70     	; 0xfae6 <vfprintf+0x4d2>
    faa0:	f6 01       	movw	r30, r12
    faa2:	80 81       	ld	r24, Z
    faa4:	89 83       	std	Y+1, r24	; 0x01
    faa6:	5e 01       	movw	r10, r28
    faa8:	08 94       	sec
    faaa:	a1 1c       	adc	r10, r1
    faac:	b1 1c       	adc	r11, r1
    faae:	22 e0       	ldi	r18, 0x02	; 2
    fab0:	30 e0       	ldi	r19, 0x00	; 0
    fab2:	c2 0e       	add	r12, r18
    fab4:	d3 1e       	adc	r13, r19
    fab6:	21 e0       	ldi	r18, 0x01	; 1
    fab8:	e2 2e       	mov	r14, r18
    faba:	f1 2c       	mov	r15, r1
    fabc:	12 c0       	rjmp	.+36     	; 0xfae2 <vfprintf+0x4ce>
    fabe:	f6 01       	movw	r30, r12
    fac0:	a0 80       	ld	r10, Z
    fac2:	b1 80       	ldd	r11, Z+1	; 0x01
    fac4:	16 fd       	sbrc	r17, 6
    fac6:	03 c0       	rjmp	.+6      	; 0xface <vfprintf+0x4ba>
    fac8:	6f ef       	ldi	r22, 0xFF	; 255
    faca:	7f ef       	ldi	r23, 0xFF	; 255
    facc:	02 c0       	rjmp	.+4      	; 0xfad2 <vfprintf+0x4be>
    face:	69 2d       	mov	r22, r9
    fad0:	70 e0       	ldi	r23, 0x00	; 0
    fad2:	22 e0       	ldi	r18, 0x02	; 2
    fad4:	30 e0       	ldi	r19, 0x00	; 0
    fad6:	c2 0e       	add	r12, r18
    fad8:	d3 1e       	adc	r13, r19
    fada:	c5 01       	movw	r24, r10
    fadc:	0e 94 07 88 	call	0x1100e	; 0x1100e <strnlen>
    fae0:	7c 01       	movw	r14, r24
    fae2:	1f 77       	andi	r17, 0x7F	; 127
    fae4:	13 c0       	rjmp	.+38     	; 0xfb0c <vfprintf+0x4f8>
    fae6:	f6 01       	movw	r30, r12
    fae8:	a0 80       	ld	r10, Z
    faea:	b1 80       	ldd	r11, Z+1	; 0x01
    faec:	16 fd       	sbrc	r17, 6
    faee:	03 c0       	rjmp	.+6      	; 0xfaf6 <vfprintf+0x4e2>
    faf0:	6f ef       	ldi	r22, 0xFF	; 255
    faf2:	7f ef       	ldi	r23, 0xFF	; 255
    faf4:	02 c0       	rjmp	.+4      	; 0xfafa <vfprintf+0x4e6>
    faf6:	69 2d       	mov	r22, r9
    faf8:	70 e0       	ldi	r23, 0x00	; 0
    fafa:	22 e0       	ldi	r18, 0x02	; 2
    fafc:	30 e0       	ldi	r19, 0x00	; 0
    fafe:	c2 0e       	add	r12, r18
    fb00:	d3 1e       	adc	r13, r19
    fb02:	c5 01       	movw	r24, r10
    fb04:	0e 94 f5 87 	call	0x10fea	; 0x10fea <strnlen_P>
    fb08:	7c 01       	movw	r14, r24
    fb0a:	10 68       	ori	r17, 0x80	; 128
    fb0c:	13 ff       	sbrs	r17, 3
    fb0e:	07 c0       	rjmp	.+14     	; 0xfb1e <vfprintf+0x50a>
    fb10:	1b c0       	rjmp	.+54     	; 0xfb48 <vfprintf+0x534>
    fb12:	80 e2       	ldi	r24, 0x20	; 32
    fb14:	90 e0       	ldi	r25, 0x00	; 0
    fb16:	b3 01       	movw	r22, r6
    fb18:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fb1c:	8a 94       	dec	r8
    fb1e:	88 2d       	mov	r24, r8
    fb20:	90 e0       	ldi	r25, 0x00	; 0
    fb22:	e8 16       	cp	r14, r24
    fb24:	f9 06       	cpc	r15, r25
    fb26:	a8 f3       	brcs	.-22     	; 0xfb12 <vfprintf+0x4fe>
    fb28:	0f c0       	rjmp	.+30     	; 0xfb48 <vfprintf+0x534>
    fb2a:	f5 01       	movw	r30, r10
    fb2c:	17 fd       	sbrc	r17, 7
    fb2e:	85 91       	lpm	r24, Z+
    fb30:	17 ff       	sbrs	r17, 7
    fb32:	81 91       	ld	r24, Z+
    fb34:	5f 01       	movw	r10, r30
    fb36:	90 e0       	ldi	r25, 0x00	; 0
    fb38:	b3 01       	movw	r22, r6
    fb3a:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fb3e:	81 10       	cpse	r8, r1
    fb40:	8a 94       	dec	r8
    fb42:	08 94       	sec
    fb44:	e1 08       	sbc	r14, r1
    fb46:	f1 08       	sbc	r15, r1
    fb48:	e1 14       	cp	r14, r1
    fb4a:	f1 04       	cpc	r15, r1
    fb4c:	71 f7       	brne	.-36     	; 0xfb2a <vfprintf+0x516>
    fb4e:	f2 c0       	rjmp	.+484    	; 0xfd34 <vfprintf+0x720>
    fb50:	94 36       	cpi	r25, 0x64	; 100
    fb52:	11 f0       	breq	.+4      	; 0xfb58 <vfprintf+0x544>
    fb54:	99 36       	cpi	r25, 0x69	; 105
    fb56:	89 f5       	brne	.+98     	; 0xfbba <vfprintf+0x5a6>
    fb58:	17 ff       	sbrs	r17, 7
    fb5a:	08 c0       	rjmp	.+16     	; 0xfb6c <vfprintf+0x558>
    fb5c:	f6 01       	movw	r30, r12
    fb5e:	20 81       	ld	r18, Z
    fb60:	31 81       	ldd	r19, Z+1	; 0x01
    fb62:	42 81       	ldd	r20, Z+2	; 0x02
    fb64:	53 81       	ldd	r21, Z+3	; 0x03
    fb66:	84 e0       	ldi	r24, 0x04	; 4
    fb68:	90 e0       	ldi	r25, 0x00	; 0
    fb6a:	0a c0       	rjmp	.+20     	; 0xfb80 <vfprintf+0x56c>
    fb6c:	f6 01       	movw	r30, r12
    fb6e:	80 81       	ld	r24, Z
    fb70:	91 81       	ldd	r25, Z+1	; 0x01
    fb72:	9c 01       	movw	r18, r24
    fb74:	44 27       	eor	r20, r20
    fb76:	37 fd       	sbrc	r19, 7
    fb78:	40 95       	com	r20
    fb7a:	54 2f       	mov	r21, r20
    fb7c:	82 e0       	ldi	r24, 0x02	; 2
    fb7e:	90 e0       	ldi	r25, 0x00	; 0
    fb80:	c8 0e       	add	r12, r24
    fb82:	d9 1e       	adc	r13, r25
    fb84:	9f e6       	ldi	r25, 0x6F	; 111
    fb86:	f9 2e       	mov	r15, r25
    fb88:	f1 22       	and	r15, r17
    fb8a:	57 ff       	sbrs	r21, 7
    fb8c:	09 c0       	rjmp	.+18     	; 0xfba0 <vfprintf+0x58c>
    fb8e:	50 95       	com	r21
    fb90:	40 95       	com	r20
    fb92:	30 95       	com	r19
    fb94:	21 95       	neg	r18
    fb96:	3f 4f       	sbci	r19, 0xFF	; 255
    fb98:	4f 4f       	sbci	r20, 0xFF	; 255
    fb9a:	5f 4f       	sbci	r21, 0xFF	; 255
    fb9c:	90 e8       	ldi	r25, 0x80	; 128
    fb9e:	f9 2a       	or	r15, r25
    fba0:	ca 01       	movw	r24, r20
    fba2:	b9 01       	movw	r22, r18
    fba4:	ae 01       	movw	r20, r28
    fba6:	4f 5f       	subi	r20, 0xFF	; 255
    fba8:	5f 4f       	sbci	r21, 0xFF	; 255
    fbaa:	2a e0       	ldi	r18, 0x0A	; 10
    fbac:	30 e0       	ldi	r19, 0x00	; 0
    fbae:	0e 94 75 89 	call	0x112ea	; 0x112ea <__ultoa_invert>
    fbb2:	e8 2e       	mov	r14, r24
    fbb4:	e8 89       	ldd	r30, Y+16	; 0x10
    fbb6:	ee 1a       	sub	r14, r30
    fbb8:	41 c0       	rjmp	.+130    	; 0xfc3c <vfprintf+0x628>
    fbba:	95 37       	cpi	r25, 0x75	; 117
    fbbc:	21 f4       	brne	.+8      	; 0xfbc6 <vfprintf+0x5b2>
    fbbe:	1f 7e       	andi	r17, 0xEF	; 239
    fbc0:	2a e0       	ldi	r18, 0x0A	; 10
    fbc2:	30 e0       	ldi	r19, 0x00	; 0
    fbc4:	1c c0       	rjmp	.+56     	; 0xfbfe <vfprintf+0x5ea>
    fbc6:	19 7f       	andi	r17, 0xF9	; 249
    fbc8:	9f 36       	cpi	r25, 0x6F	; 111
    fbca:	61 f0       	breq	.+24     	; 0xfbe4 <vfprintf+0x5d0>
    fbcc:	90 37       	cpi	r25, 0x70	; 112
    fbce:	20 f4       	brcc	.+8      	; 0xfbd8 <vfprintf+0x5c4>
    fbd0:	98 35       	cpi	r25, 0x58	; 88
    fbd2:	09 f0       	breq	.+2      	; 0xfbd6 <vfprintf+0x5c2>
    fbd4:	b2 c0       	rjmp	.+356    	; 0xfd3a <vfprintf+0x726>
    fbd6:	0f c0       	rjmp	.+30     	; 0xfbf6 <vfprintf+0x5e2>
    fbd8:	90 37       	cpi	r25, 0x70	; 112
    fbda:	39 f0       	breq	.+14     	; 0xfbea <vfprintf+0x5d6>
    fbdc:	98 37       	cpi	r25, 0x78	; 120
    fbde:	09 f0       	breq	.+2      	; 0xfbe2 <vfprintf+0x5ce>
    fbe0:	ac c0       	rjmp	.+344    	; 0xfd3a <vfprintf+0x726>
    fbe2:	04 c0       	rjmp	.+8      	; 0xfbec <vfprintf+0x5d8>
    fbe4:	28 e0       	ldi	r18, 0x08	; 8
    fbe6:	30 e0       	ldi	r19, 0x00	; 0
    fbe8:	0a c0       	rjmp	.+20     	; 0xfbfe <vfprintf+0x5ea>
    fbea:	10 61       	ori	r17, 0x10	; 16
    fbec:	14 fd       	sbrc	r17, 4
    fbee:	14 60       	ori	r17, 0x04	; 4
    fbf0:	20 e1       	ldi	r18, 0x10	; 16
    fbf2:	30 e0       	ldi	r19, 0x00	; 0
    fbf4:	04 c0       	rjmp	.+8      	; 0xfbfe <vfprintf+0x5ea>
    fbf6:	14 fd       	sbrc	r17, 4
    fbf8:	16 60       	ori	r17, 0x06	; 6
    fbfa:	20 e1       	ldi	r18, 0x10	; 16
    fbfc:	32 e0       	ldi	r19, 0x02	; 2
    fbfe:	17 ff       	sbrs	r17, 7
    fc00:	08 c0       	rjmp	.+16     	; 0xfc12 <vfprintf+0x5fe>
    fc02:	f6 01       	movw	r30, r12
    fc04:	60 81       	ld	r22, Z
    fc06:	71 81       	ldd	r23, Z+1	; 0x01
    fc08:	82 81       	ldd	r24, Z+2	; 0x02
    fc0a:	93 81       	ldd	r25, Z+3	; 0x03
    fc0c:	44 e0       	ldi	r20, 0x04	; 4
    fc0e:	50 e0       	ldi	r21, 0x00	; 0
    fc10:	08 c0       	rjmp	.+16     	; 0xfc22 <vfprintf+0x60e>
    fc12:	f6 01       	movw	r30, r12
    fc14:	80 81       	ld	r24, Z
    fc16:	91 81       	ldd	r25, Z+1	; 0x01
    fc18:	bc 01       	movw	r22, r24
    fc1a:	80 e0       	ldi	r24, 0x00	; 0
    fc1c:	90 e0       	ldi	r25, 0x00	; 0
    fc1e:	42 e0       	ldi	r20, 0x02	; 2
    fc20:	50 e0       	ldi	r21, 0x00	; 0
    fc22:	c4 0e       	add	r12, r20
    fc24:	d5 1e       	adc	r13, r21
    fc26:	ae 01       	movw	r20, r28
    fc28:	4f 5f       	subi	r20, 0xFF	; 255
    fc2a:	5f 4f       	sbci	r21, 0xFF	; 255
    fc2c:	0e 94 75 89 	call	0x112ea	; 0x112ea <__ultoa_invert>
    fc30:	e8 2e       	mov	r14, r24
    fc32:	58 89       	ldd	r21, Y+16	; 0x10
    fc34:	e5 1a       	sub	r14, r21
    fc36:	8f e7       	ldi	r24, 0x7F	; 127
    fc38:	f8 2e       	mov	r15, r24
    fc3a:	f1 22       	and	r15, r17
    fc3c:	f6 fe       	sbrs	r15, 6
    fc3e:	0b c0       	rjmp	.+22     	; 0xfc56 <vfprintf+0x642>
    fc40:	8e ef       	ldi	r24, 0xFE	; 254
    fc42:	f8 22       	and	r15, r24
    fc44:	e9 14       	cp	r14, r9
    fc46:	38 f4       	brcc	.+14     	; 0xfc56 <vfprintf+0x642>
    fc48:	f4 fe       	sbrs	r15, 4
    fc4a:	07 c0       	rjmp	.+14     	; 0xfc5a <vfprintf+0x646>
    fc4c:	f2 fc       	sbrc	r15, 2
    fc4e:	05 c0       	rjmp	.+10     	; 0xfc5a <vfprintf+0x646>
    fc50:	9f ee       	ldi	r25, 0xEF	; 239
    fc52:	f9 22       	and	r15, r25
    fc54:	02 c0       	rjmp	.+4      	; 0xfc5a <vfprintf+0x646>
    fc56:	1e 2d       	mov	r17, r14
    fc58:	01 c0       	rjmp	.+2      	; 0xfc5c <vfprintf+0x648>
    fc5a:	19 2d       	mov	r17, r9
    fc5c:	f4 fe       	sbrs	r15, 4
    fc5e:	0d c0       	rjmp	.+26     	; 0xfc7a <vfprintf+0x666>
    fc60:	fe 01       	movw	r30, r28
    fc62:	ee 0d       	add	r30, r14
    fc64:	f1 1d       	adc	r31, r1
    fc66:	80 81       	ld	r24, Z
    fc68:	80 33       	cpi	r24, 0x30	; 48
    fc6a:	19 f4       	brne	.+6      	; 0xfc72 <vfprintf+0x65e>
    fc6c:	e9 ee       	ldi	r30, 0xE9	; 233
    fc6e:	fe 22       	and	r15, r30
    fc70:	08 c0       	rjmp	.+16     	; 0xfc82 <vfprintf+0x66e>
    fc72:	1f 5f       	subi	r17, 0xFF	; 255
    fc74:	f2 fe       	sbrs	r15, 2
    fc76:	05 c0       	rjmp	.+10     	; 0xfc82 <vfprintf+0x66e>
    fc78:	03 c0       	rjmp	.+6      	; 0xfc80 <vfprintf+0x66c>
    fc7a:	8f 2d       	mov	r24, r15
    fc7c:	86 78       	andi	r24, 0x86	; 134
    fc7e:	09 f0       	breq	.+2      	; 0xfc82 <vfprintf+0x66e>
    fc80:	1f 5f       	subi	r17, 0xFF	; 255
    fc82:	0f 2d       	mov	r16, r15
    fc84:	f3 fc       	sbrc	r15, 3
    fc86:	14 c0       	rjmp	.+40     	; 0xfcb0 <vfprintf+0x69c>
    fc88:	f0 fe       	sbrs	r15, 0
    fc8a:	0f c0       	rjmp	.+30     	; 0xfcaa <vfprintf+0x696>
    fc8c:	18 15       	cp	r17, r8
    fc8e:	10 f0       	brcs	.+4      	; 0xfc94 <vfprintf+0x680>
    fc90:	9e 2c       	mov	r9, r14
    fc92:	0b c0       	rjmp	.+22     	; 0xfcaa <vfprintf+0x696>
    fc94:	9e 2c       	mov	r9, r14
    fc96:	98 0c       	add	r9, r8
    fc98:	91 1a       	sub	r9, r17
    fc9a:	18 2d       	mov	r17, r8
    fc9c:	06 c0       	rjmp	.+12     	; 0xfcaa <vfprintf+0x696>
    fc9e:	80 e2       	ldi	r24, 0x20	; 32
    fca0:	90 e0       	ldi	r25, 0x00	; 0
    fca2:	b3 01       	movw	r22, r6
    fca4:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fca8:	1f 5f       	subi	r17, 0xFF	; 255
    fcaa:	18 15       	cp	r17, r8
    fcac:	c0 f3       	brcs	.-16     	; 0xfc9e <vfprintf+0x68a>
    fcae:	04 c0       	rjmp	.+8      	; 0xfcb8 <vfprintf+0x6a4>
    fcb0:	18 15       	cp	r17, r8
    fcb2:	10 f4       	brcc	.+4      	; 0xfcb8 <vfprintf+0x6a4>
    fcb4:	81 1a       	sub	r8, r17
    fcb6:	01 c0       	rjmp	.+2      	; 0xfcba <vfprintf+0x6a6>
    fcb8:	88 24       	eor	r8, r8
    fcba:	04 ff       	sbrs	r16, 4
    fcbc:	0f c0       	rjmp	.+30     	; 0xfcdc <vfprintf+0x6c8>
    fcbe:	80 e3       	ldi	r24, 0x30	; 48
    fcc0:	90 e0       	ldi	r25, 0x00	; 0
    fcc2:	b3 01       	movw	r22, r6
    fcc4:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fcc8:	02 ff       	sbrs	r16, 2
    fcca:	1d c0       	rjmp	.+58     	; 0xfd06 <vfprintf+0x6f2>
    fccc:	01 fd       	sbrc	r16, 1
    fcce:	03 c0       	rjmp	.+6      	; 0xfcd6 <vfprintf+0x6c2>
    fcd0:	88 e7       	ldi	r24, 0x78	; 120
    fcd2:	90 e0       	ldi	r25, 0x00	; 0
    fcd4:	0e c0       	rjmp	.+28     	; 0xfcf2 <vfprintf+0x6de>
    fcd6:	88 e5       	ldi	r24, 0x58	; 88
    fcd8:	90 e0       	ldi	r25, 0x00	; 0
    fcda:	0b c0       	rjmp	.+22     	; 0xfcf2 <vfprintf+0x6de>
    fcdc:	80 2f       	mov	r24, r16
    fcde:	86 78       	andi	r24, 0x86	; 134
    fce0:	91 f0       	breq	.+36     	; 0xfd06 <vfprintf+0x6f2>
    fce2:	01 ff       	sbrs	r16, 1
    fce4:	02 c0       	rjmp	.+4      	; 0xfcea <vfprintf+0x6d6>
    fce6:	8b e2       	ldi	r24, 0x2B	; 43
    fce8:	01 c0       	rjmp	.+2      	; 0xfcec <vfprintf+0x6d8>
    fcea:	80 e2       	ldi	r24, 0x20	; 32
    fcec:	f7 fc       	sbrc	r15, 7
    fcee:	8d e2       	ldi	r24, 0x2D	; 45
    fcf0:	90 e0       	ldi	r25, 0x00	; 0
    fcf2:	b3 01       	movw	r22, r6
    fcf4:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fcf8:	06 c0       	rjmp	.+12     	; 0xfd06 <vfprintf+0x6f2>
    fcfa:	80 e3       	ldi	r24, 0x30	; 48
    fcfc:	90 e0       	ldi	r25, 0x00	; 0
    fcfe:	b3 01       	movw	r22, r6
    fd00:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fd04:	9a 94       	dec	r9
    fd06:	e9 14       	cp	r14, r9
    fd08:	c0 f3       	brcs	.-16     	; 0xfcfa <vfprintf+0x6e6>
    fd0a:	ea 94       	dec	r14
    fd0c:	e1 e0       	ldi	r30, 0x01	; 1
    fd0e:	f0 e0       	ldi	r31, 0x00	; 0
    fd10:	ec 0f       	add	r30, r28
    fd12:	fd 1f       	adc	r31, r29
    fd14:	ee 0d       	add	r30, r14
    fd16:	f1 1d       	adc	r31, r1
    fd18:	80 81       	ld	r24, Z
    fd1a:	90 e0       	ldi	r25, 0x00	; 0
    fd1c:	b3 01       	movw	r22, r6
    fd1e:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fd22:	ee 20       	and	r14, r14
    fd24:	91 f7       	brne	.-28     	; 0xfd0a <vfprintf+0x6f6>
    fd26:	06 c0       	rjmp	.+12     	; 0xfd34 <vfprintf+0x720>
    fd28:	80 e2       	ldi	r24, 0x20	; 32
    fd2a:	90 e0       	ldi	r25, 0x00	; 0
    fd2c:	b3 01       	movw	r22, r6
    fd2e:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
    fd32:	8a 94       	dec	r8
    fd34:	88 20       	and	r8, r8
    fd36:	c1 f7       	brne	.-16     	; 0xfd28 <vfprintf+0x714>
    fd38:	99 cc       	rjmp	.-1742   	; 0xf66c <vfprintf+0x58>
    fd3a:	f3 01       	movw	r30, r6
    fd3c:	66 81       	ldd	r22, Z+6	; 0x06
    fd3e:	77 81       	ldd	r23, Z+7	; 0x07
    fd40:	cb 01       	movw	r24, r22
    fd42:	61 96       	adiw	r28, 0x11	; 17
    fd44:	0f b6       	in	r0, 0x3f	; 63
    fd46:	f8 94       	cli
    fd48:	de bf       	out	0x3e, r29	; 62
    fd4a:	0f be       	out	0x3f, r0	; 63
    fd4c:	cd bf       	out	0x3d, r28	; 61
    fd4e:	cf 91       	pop	r28
    fd50:	df 91       	pop	r29
    fd52:	1f 91       	pop	r17
    fd54:	0f 91       	pop	r16
    fd56:	ff 90       	pop	r15
    fd58:	ef 90       	pop	r14
    fd5a:	df 90       	pop	r13
    fd5c:	cf 90       	pop	r12
    fd5e:	bf 90       	pop	r11
    fd60:	af 90       	pop	r10
    fd62:	9f 90       	pop	r9
    fd64:	8f 90       	pop	r8
    fd66:	7f 90       	pop	r7
    fd68:	6f 90       	pop	r6
    fd6a:	5f 90       	pop	r5
    fd6c:	4f 90       	pop	r4
    fd6e:	3f 90       	pop	r3
    fd70:	2f 90       	pop	r2
    fd72:	08 95       	ret

0000fd74 <putval>:
    fd74:	fc 01       	movw	r30, r24
    fd76:	20 fd       	sbrc	r18, 0
    fd78:	08 c0       	rjmp	.+16     	; 0xfd8a <putval+0x16>
    fd7a:	23 fd       	sbrc	r18, 3
    fd7c:	05 c0       	rjmp	.+10     	; 0xfd88 <putval+0x14>
    fd7e:	22 ff       	sbrs	r18, 2
    fd80:	02 c0       	rjmp	.+4      	; 0xfd86 <putval+0x12>
    fd82:	73 83       	std	Z+3, r23	; 0x03
    fd84:	62 83       	std	Z+2, r22	; 0x02
    fd86:	51 83       	std	Z+1, r21	; 0x01
    fd88:	40 83       	st	Z, r20
    fd8a:	08 95       	ret

0000fd8c <mulacc>:
    fd8c:	ef 92       	push	r14
    fd8e:	ff 92       	push	r15
    fd90:	0f 93       	push	r16
    fd92:	1f 93       	push	r17
    fd94:	44 ff       	sbrs	r20, 4
    fd96:	02 c0       	rjmp	.+4      	; 0xfd9c <mulacc+0x10>
    fd98:	33 e0       	ldi	r19, 0x03	; 3
    fd9a:	11 c0       	rjmp	.+34     	; 0xfdbe <mulacc+0x32>
    fd9c:	46 ff       	sbrs	r20, 6
    fd9e:	02 c0       	rjmp	.+4      	; 0xfda4 <mulacc+0x18>
    fda0:	34 e0       	ldi	r19, 0x04	; 4
    fda2:	0d c0       	rjmp	.+26     	; 0xfdbe <mulacc+0x32>
    fda4:	db 01       	movw	r26, r22
    fda6:	fc 01       	movw	r30, r24
    fda8:	aa 0f       	add	r26, r26
    fdaa:	bb 1f       	adc	r27, r27
    fdac:	ee 1f       	adc	r30, r30
    fdae:	ff 1f       	adc	r31, r31
    fdb0:	10 94       	com	r1
    fdb2:	d1 f7       	brne	.-12     	; 0xfda8 <mulacc+0x1c>
    fdb4:	6a 0f       	add	r22, r26
    fdb6:	7b 1f       	adc	r23, r27
    fdb8:	8e 1f       	adc	r24, r30
    fdba:	9f 1f       	adc	r25, r31
    fdbc:	31 e0       	ldi	r19, 0x01	; 1
    fdbe:	66 0f       	add	r22, r22
    fdc0:	77 1f       	adc	r23, r23
    fdc2:	88 1f       	adc	r24, r24
    fdc4:	99 1f       	adc	r25, r25
    fdc6:	31 50       	subi	r19, 0x01	; 1
    fdc8:	d1 f7       	brne	.-12     	; 0xfdbe <mulacc+0x32>
    fdca:	7b 01       	movw	r14, r22
    fdcc:	8c 01       	movw	r16, r24
    fdce:	e2 0e       	add	r14, r18
    fdd0:	f1 1c       	adc	r15, r1
    fdd2:	01 1d       	adc	r16, r1
    fdd4:	11 1d       	adc	r17, r1
    fdd6:	a8 01       	movw	r20, r16
    fdd8:	97 01       	movw	r18, r14
    fdda:	b7 01       	movw	r22, r14
    fddc:	ca 01       	movw	r24, r20
    fdde:	1f 91       	pop	r17
    fde0:	0f 91       	pop	r16
    fde2:	ff 90       	pop	r15
    fde4:	ef 90       	pop	r14
    fde6:	08 95       	ret

0000fde8 <skip_spaces>:
    fde8:	0f 93       	push	r16
    fdea:	1f 93       	push	r17
    fdec:	cf 93       	push	r28
    fdee:	df 93       	push	r29
    fdf0:	8c 01       	movw	r16, r24
    fdf2:	c8 01       	movw	r24, r16
    fdf4:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
    fdf8:	ec 01       	movw	r28, r24
    fdfa:	97 fd       	sbrc	r25, 7
    fdfc:	08 c0       	rjmp	.+16     	; 0xfe0e <skip_spaces+0x26>
    fdfe:	0e 94 da 87 	call	0x10fb4	; 0x10fb4 <isspace>
    fe02:	89 2b       	or	r24, r25
    fe04:	b1 f7       	brne	.-20     	; 0xfdf2 <skip_spaces+0xa>
    fe06:	ce 01       	movw	r24, r28
    fe08:	b8 01       	movw	r22, r16
    fe0a:	0e 94 5b 89 	call	0x112b6	; 0x112b6 <ungetc>
    fe0e:	ce 01       	movw	r24, r28
    fe10:	df 91       	pop	r29
    fe12:	cf 91       	pop	r28
    fe14:	1f 91       	pop	r17
    fe16:	0f 91       	pop	r16
    fe18:	08 95       	ret

0000fe1a <conv_int>:
    fe1a:	8f 92       	push	r8
    fe1c:	9f 92       	push	r9
    fe1e:	af 92       	push	r10
    fe20:	bf 92       	push	r11
    fe22:	df 92       	push	r13
    fe24:	ef 92       	push	r14
    fe26:	ff 92       	push	r15
    fe28:	0f 93       	push	r16
    fe2a:	1f 93       	push	r17
    fe2c:	cf 93       	push	r28
    fe2e:	df 93       	push	r29
    fe30:	5c 01       	movw	r10, r24
    fe32:	eb 01       	movw	r28, r22
    fe34:	4a 01       	movw	r8, r20
    fe36:	12 2f       	mov	r17, r18
    fe38:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
    fe3c:	ac 01       	movw	r20, r24
    fe3e:	8b 32       	cpi	r24, 0x2B	; 43
    fe40:	19 f0       	breq	.+6      	; 0xfe48 <conv_int+0x2e>
    fe42:	8d 32       	cpi	r24, 0x2D	; 45
    fe44:	51 f4       	brne	.+20     	; 0xfe5a <conv_int+0x40>
    fe46:	10 68       	ori	r17, 0x80	; 128
    fe48:	21 97       	sbiw	r28, 0x01	; 1
    fe4a:	09 f4       	brne	.+2      	; 0xfe4e <conv_int+0x34>
    fe4c:	6d c0       	rjmp	.+218    	; 0xff28 <conv_int+0x10e>
    fe4e:	c5 01       	movw	r24, r10
    fe50:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
    fe54:	ac 01       	movw	r20, r24
    fe56:	97 fd       	sbrc	r25, 7
    fe58:	67 c0       	rjmp	.+206    	; 0xff28 <conv_int+0x10e>
    fe5a:	6d ef       	ldi	r22, 0xFD	; 253
    fe5c:	d6 2e       	mov	r13, r22
    fe5e:	d1 22       	and	r13, r17
    fe60:	8d 2d       	mov	r24, r13
    fe62:	80 73       	andi	r24, 0x30	; 48
    fe64:	01 f5       	brne	.+64     	; 0xfea6 <conv_int+0x8c>
    fe66:	40 33       	cpi	r20, 0x30	; 48
    fe68:	f1 f4       	brne	.+60     	; 0xfea6 <conv_int+0x8c>
    fe6a:	21 97       	sbiw	r28, 0x01	; 1
    fe6c:	09 f4       	brne	.+2      	; 0xfe70 <conv_int+0x56>
    fe6e:	47 c0       	rjmp	.+142    	; 0xfefe <conv_int+0xe4>
    fe70:	c5 01       	movw	r24, r10
    fe72:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
    fe76:	ac 01       	movw	r20, r24
    fe78:	97 fd       	sbrc	r25, 7
    fe7a:	41 c0       	rjmp	.+130    	; 0xfefe <conv_int+0xe4>
    fe7c:	82 e0       	ldi	r24, 0x02	; 2
    fe7e:	d8 2a       	or	r13, r24
    fe80:	48 37       	cpi	r20, 0x78	; 120
    fe82:	11 f0       	breq	.+4      	; 0xfe88 <conv_int+0x6e>
    fe84:	48 35       	cpi	r20, 0x58	; 88
    fe86:	59 f4       	brne	.+22     	; 0xfe9e <conv_int+0x84>
    fe88:	80 e4       	ldi	r24, 0x40	; 64
    fe8a:	d8 2a       	or	r13, r24
    fe8c:	21 97       	sbiw	r28, 0x01	; 1
    fe8e:	b9 f1       	breq	.+110    	; 0xfefe <conv_int+0xe4>
    fe90:	c5 01       	movw	r24, r10
    fe92:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
    fe96:	ac 01       	movw	r20, r24
    fe98:	99 23       	and	r25, r25
    fe9a:	2c f4       	brge	.+10     	; 0xfea6 <conv_int+0x8c>
    fe9c:	30 c0       	rjmp	.+96     	; 0xfefe <conv_int+0xe4>
    fe9e:	d6 fc       	sbrc	r13, 6
    fea0:	02 c0       	rjmp	.+4      	; 0xfea6 <conv_int+0x8c>
    fea2:	80 e1       	ldi	r24, 0x10	; 16
    fea4:	d8 2a       	or	r13, r24
    fea6:	ee 24       	eor	r14, r14
    fea8:	ff 24       	eor	r15, r15
    feaa:	87 01       	movw	r16, r14
    feac:	24 2f       	mov	r18, r20
    feae:	20 53       	subi	r18, 0x30	; 48
    feb0:	28 30       	cpi	r18, 0x08	; 8
    feb2:	88 f0       	brcs	.+34     	; 0xfed6 <conv_int+0xbc>
    feb4:	d4 fc       	sbrc	r13, 4
    feb6:	09 c0       	rjmp	.+18     	; 0xfeca <conv_int+0xb0>
    feb8:	2a 30       	cpi	r18, 0x0A	; 10
    feba:	68 f0       	brcs	.+26     	; 0xfed6 <conv_int+0xbc>
    febc:	d6 fe       	sbrs	r13, 6
    febe:	05 c0       	rjmp	.+10     	; 0xfeca <conv_int+0xb0>
    fec0:	2f 7d       	andi	r18, 0xDF	; 223
    fec2:	82 2f       	mov	r24, r18
    fec4:	81 51       	subi	r24, 0x11	; 17
    fec6:	86 30       	cpi	r24, 0x06	; 6
    fec8:	28 f0       	brcs	.+10     	; 0xfed4 <conv_int+0xba>
    feca:	ca 01       	movw	r24, r20
    fecc:	b5 01       	movw	r22, r10
    fece:	0e 94 5b 89 	call	0x112b6	; 0x112b6 <ungetc>
    fed2:	12 c0       	rjmp	.+36     	; 0xfef8 <conv_int+0xde>
    fed4:	27 50       	subi	r18, 0x07	; 7
    fed6:	c8 01       	movw	r24, r16
    fed8:	b7 01       	movw	r22, r14
    feda:	4d 2d       	mov	r20, r13
    fedc:	0e 94 c6 7e 	call	0xfd8c	; 0xfd8c <mulacc>
    fee0:	7b 01       	movw	r14, r22
    fee2:	8c 01       	movw	r16, r24
    fee4:	82 e0       	ldi	r24, 0x02	; 2
    fee6:	d8 2a       	or	r13, r24
    fee8:	21 97       	sbiw	r28, 0x01	; 1
    feea:	61 f0       	breq	.+24     	; 0xff04 <conv_int+0xea>
    feec:	c5 01       	movw	r24, r10
    feee:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
    fef2:	ac 01       	movw	r20, r24
    fef4:	97 ff       	sbrs	r25, 7
    fef6:	da cf       	rjmp	.-76     	; 0xfeac <conv_int+0x92>
    fef8:	d1 fc       	sbrc	r13, 1
    fefa:	04 c0       	rjmp	.+8      	; 0xff04 <conv_int+0xea>
    fefc:	15 c0       	rjmp	.+42     	; 0xff28 <conv_int+0x10e>
    fefe:	ee 24       	eor	r14, r14
    ff00:	ff 24       	eor	r15, r15
    ff02:	87 01       	movw	r16, r14
    ff04:	d7 fe       	sbrs	r13, 7
    ff06:	08 c0       	rjmp	.+16     	; 0xff18 <conv_int+0xfe>
    ff08:	10 95       	com	r17
    ff0a:	00 95       	com	r16
    ff0c:	f0 94       	com	r15
    ff0e:	e0 94       	com	r14
    ff10:	e1 1c       	adc	r14, r1
    ff12:	f1 1c       	adc	r15, r1
    ff14:	01 1d       	adc	r16, r1
    ff16:	11 1d       	adc	r17, r1
    ff18:	c4 01       	movw	r24, r8
    ff1a:	b8 01       	movw	r22, r16
    ff1c:	a7 01       	movw	r20, r14
    ff1e:	2d 2d       	mov	r18, r13
    ff20:	0e 94 ba 7e 	call	0xfd74	; 0xfd74 <putval>
    ff24:	81 e0       	ldi	r24, 0x01	; 1
    ff26:	01 c0       	rjmp	.+2      	; 0xff2a <conv_int+0x110>
    ff28:	80 e0       	ldi	r24, 0x00	; 0
    ff2a:	df 91       	pop	r29
    ff2c:	cf 91       	pop	r28
    ff2e:	1f 91       	pop	r17
    ff30:	0f 91       	pop	r16
    ff32:	ff 90       	pop	r15
    ff34:	ef 90       	pop	r14
    ff36:	df 90       	pop	r13
    ff38:	bf 90       	pop	r11
    ff3a:	af 90       	pop	r10
    ff3c:	9f 90       	pop	r9
    ff3e:	8f 90       	pop	r8
    ff40:	08 95       	ret

0000ff42 <conv_brk>:
    ff42:	6f 92       	push	r6
    ff44:	7f 92       	push	r7
    ff46:	8f 92       	push	r8
    ff48:	9f 92       	push	r9
    ff4a:	af 92       	push	r10
    ff4c:	bf 92       	push	r11
    ff4e:	cf 92       	push	r12
    ff50:	df 92       	push	r13
    ff52:	ef 92       	push	r14
    ff54:	ff 92       	push	r15
    ff56:	0f 93       	push	r16
    ff58:	1f 93       	push	r17
    ff5a:	df 93       	push	r29
    ff5c:	cf 93       	push	r28
    ff5e:	cd b7       	in	r28, 0x3d	; 61
    ff60:	de b7       	in	r29, 0x3e	; 62
    ff62:	a0 97       	sbiw	r28, 0x20	; 32
    ff64:	0f b6       	in	r0, 0x3f	; 63
    ff66:	f8 94       	cli
    ff68:	de bf       	out	0x3e, r29	; 62
    ff6a:	0f be       	out	0x3f, r0	; 63
    ff6c:	cd bf       	out	0x3d, r28	; 61
    ff6e:	5c 01       	movw	r10, r24
    ff70:	6b 01       	movw	r12, r22
    ff72:	8a 01       	movw	r16, r20
    ff74:	79 01       	movw	r14, r18
    ff76:	fe 01       	movw	r30, r28
    ff78:	31 96       	adiw	r30, 0x01	; 1
    ff7a:	80 e2       	ldi	r24, 0x20	; 32
    ff7c:	df 01       	movw	r26, r30
    ff7e:	1d 92       	st	X+, r1
    ff80:	8a 95       	dec	r24
    ff82:	e9 f7       	brne	.-6      	; 0xff7e <conv_brk+0x3c>
    ff84:	70 e0       	ldi	r23, 0x00	; 0
    ff86:	30 e0       	ldi	r19, 0x00	; 0
    ff88:	60 e0       	ldi	r22, 0x00	; 0
    ff8a:	40 e0       	ldi	r20, 0x00	; 0
    ff8c:	50 e0       	ldi	r21, 0x00	; 0
    ff8e:	3f 01       	movw	r6, r30
    ff90:	a1 e0       	ldi	r26, 0x01	; 1
    ff92:	b0 e0       	ldi	r27, 0x00	; 0
    ff94:	f5 01       	movw	r30, r10
    ff96:	83 81       	ldd	r24, Z+3	; 0x03
    ff98:	f7 01       	movw	r30, r14
    ff9a:	83 fd       	sbrc	r24, 3
    ff9c:	25 91       	lpm	r18, Z+
    ff9e:	83 ff       	sbrs	r24, 3
    ffa0:	21 91       	ld	r18, Z+
    ffa2:	7f 01       	movw	r14, r30
    ffa4:	22 23       	and	r18, r18
    ffa6:	09 f4       	brne	.+2      	; 0xffaa <conv_brk+0x68>
    ffa8:	81 c0       	rjmp	.+258    	; 0x100ac <conv_brk+0x16a>
    ffaa:	2e 35       	cpi	r18, 0x5E	; 94
    ffac:	19 f4       	brne	.+6      	; 0xffb4 <conv_brk+0x72>
    ffae:	41 15       	cp	r20, r1
    ffb0:	51 05       	cpc	r21, r1
    ffb2:	69 f1       	breq	.+90     	; 0x1000e <conv_brk+0xcc>
    ffb4:	87 2f       	mov	r24, r23
    ffb6:	90 e0       	ldi	r25, 0x00	; 0
    ffb8:	84 17       	cp	r24, r20
    ffba:	95 07       	cpc	r25, r21
    ffbc:	44 f4       	brge	.+16     	; 0xffce <conv_brk+0x8c>
    ffbe:	2d 35       	cpi	r18, 0x5D	; 93
    ffc0:	51 f1       	breq	.+84     	; 0x10016 <conv_brk+0xd4>
    ffc2:	2d 32       	cpi	r18, 0x2D	; 45
    ffc4:	21 f4       	brne	.+8      	; 0xffce <conv_brk+0x8c>
    ffc6:	33 23       	and	r19, r19
    ffc8:	29 f4       	brne	.+10     	; 0xffd4 <conv_brk+0x92>
    ffca:	31 e0       	ldi	r19, 0x01	; 1
    ffcc:	21 c0       	rjmp	.+66     	; 0x10010 <conv_brk+0xce>
    ffce:	33 23       	and	r19, r19
    ffd0:	09 f4       	brne	.+2      	; 0xffd4 <conv_brk+0x92>
    ffd2:	62 2f       	mov	r22, r18
    ffd4:	32 2f       	mov	r19, r18
    ffd6:	83 2f       	mov	r24, r19
    ffd8:	86 95       	lsr	r24
    ffda:	86 95       	lsr	r24
    ffdc:	86 95       	lsr	r24
    ffde:	f3 01       	movw	r30, r6
    ffe0:	e8 0f       	add	r30, r24
    ffe2:	f1 1d       	adc	r31, r1
    ffe4:	83 2f       	mov	r24, r19
    ffe6:	87 70       	andi	r24, 0x07	; 7
    ffe8:	4d 01       	movw	r8, r26
    ffea:	02 c0       	rjmp	.+4      	; 0xfff0 <conv_brk+0xae>
    ffec:	88 0c       	add	r8, r8
    ffee:	99 1c       	adc	r9, r9
    fff0:	8a 95       	dec	r24
    fff2:	e2 f7       	brpl	.-8      	; 0xffec <conv_brk+0xaa>
    fff4:	20 81       	ld	r18, Z
    fff6:	28 29       	or	r18, r8
    fff8:	20 83       	st	Z, r18
    fffa:	36 17       	cp	r19, r22
    fffc:	11 f4       	brne	.+4      	; 0x10002 <conv_brk+0xc0>
    fffe:	30 e0       	ldi	r19, 0x00	; 0
   10000:	07 c0       	rjmp	.+14     	; 0x10010 <conv_brk+0xce>
   10002:	36 17       	cp	r19, r22
   10004:	10 f4       	brcc	.+4      	; 0x1000a <conv_brk+0xc8>
   10006:	3f 5f       	subi	r19, 0xFF	; 255
   10008:	e6 cf       	rjmp	.-52     	; 0xffd6 <conv_brk+0x94>
   1000a:	31 50       	subi	r19, 0x01	; 1
   1000c:	e4 cf       	rjmp	.-56     	; 0xffd6 <conv_brk+0x94>
   1000e:	71 e0       	ldi	r23, 0x01	; 1
   10010:	4f 5f       	subi	r20, 0xFF	; 255
   10012:	5f 4f       	sbci	r21, 0xFF	; 255
   10014:	bf cf       	rjmp	.-130    	; 0xff94 <conv_brk+0x52>
   10016:	33 23       	and	r19, r19
   10018:	19 f0       	breq	.+6      	; 0x10020 <conv_brk+0xde>
   1001a:	8e 81       	ldd	r24, Y+6	; 0x06
   1001c:	80 62       	ori	r24, 0x20	; 32
   1001e:	8e 83       	std	Y+6, r24	; 0x06
   10020:	77 23       	and	r23, r23
   10022:	59 f0       	breq	.+22     	; 0x1003a <conv_brk+0xf8>
   10024:	fe 01       	movw	r30, r28
   10026:	31 96       	adiw	r30, 0x01	; 1
   10028:	9e 01       	movw	r18, r28
   1002a:	2f 5d       	subi	r18, 0xDF	; 223
   1002c:	3f 4f       	sbci	r19, 0xFF	; 255
   1002e:	80 81       	ld	r24, Z
   10030:	80 95       	com	r24
   10032:	81 93       	st	Z+, r24
   10034:	e2 17       	cp	r30, r18
   10036:	f3 07       	cpc	r31, r19
   10038:	d1 f7       	brne	.-12     	; 0x1002e <conv_brk+0xec>
   1003a:	99 24       	eor	r9, r9
   1003c:	93 94       	inc	r9
   1003e:	3e 01       	movw	r6, r28
   10040:	08 94       	sec
   10042:	61 1c       	adc	r6, r1
   10044:	71 1c       	adc	r7, r1
   10046:	c5 01       	movw	r24, r10
   10048:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
   1004c:	ac 01       	movw	r20, r24
   1004e:	97 fd       	sbrc	r25, 7
   10050:	25 c0       	rjmp	.+74     	; 0x1009c <conv_brk+0x15a>
   10052:	86 95       	lsr	r24
   10054:	86 95       	lsr	r24
   10056:	86 95       	lsr	r24
   10058:	f3 01       	movw	r30, r6
   1005a:	e8 0f       	add	r30, r24
   1005c:	f1 1d       	adc	r31, r1
   1005e:	80 81       	ld	r24, Z
   10060:	90 e0       	ldi	r25, 0x00	; 0
   10062:	9a 01       	movw	r18, r20
   10064:	27 70       	andi	r18, 0x07	; 7
   10066:	30 70       	andi	r19, 0x00	; 0
   10068:	02 c0       	rjmp	.+4      	; 0x1006e <conv_brk+0x12c>
   1006a:	95 95       	asr	r25
   1006c:	87 95       	ror	r24
   1006e:	2a 95       	dec	r18
   10070:	e2 f7       	brpl	.-8      	; 0x1006a <conv_brk+0x128>
   10072:	80 fd       	sbrc	r24, 0
   10074:	05 c0       	rjmp	.+10     	; 0x10080 <conv_brk+0x13e>
   10076:	ca 01       	movw	r24, r20
   10078:	b5 01       	movw	r22, r10
   1007a:	0e 94 5b 89 	call	0x112b6	; 0x112b6 <ungetc>
   1007e:	0e c0       	rjmp	.+28     	; 0x1009c <conv_brk+0x15a>
   10080:	01 15       	cp	r16, r1
   10082:	11 05       	cpc	r17, r1
   10084:	19 f0       	breq	.+6      	; 0x1008c <conv_brk+0x14a>
   10086:	d8 01       	movw	r26, r16
   10088:	4d 93       	st	X+, r20
   1008a:	8d 01       	movw	r16, r26
   1008c:	08 94       	sec
   1008e:	c1 08       	sbc	r12, r1
   10090:	d1 08       	sbc	r13, r1
   10092:	99 24       	eor	r9, r9
   10094:	c1 14       	cp	r12, r1
   10096:	d1 04       	cpc	r13, r1
   10098:	b1 f6       	brne	.-84     	; 0x10046 <conv_brk+0x104>
   1009a:	02 c0       	rjmp	.+4      	; 0x100a0 <conv_brk+0x15e>
   1009c:	99 20       	and	r9, r9
   1009e:	31 f4       	brne	.+12     	; 0x100ac <conv_brk+0x16a>
   100a0:	01 15       	cp	r16, r1
   100a2:	11 05       	cpc	r17, r1
   100a4:	29 f0       	breq	.+10     	; 0x100b0 <conv_brk+0x16e>
   100a6:	f8 01       	movw	r30, r16
   100a8:	10 82       	st	Z, r1
   100aa:	02 c0       	rjmp	.+4      	; 0x100b0 <conv_brk+0x16e>
   100ac:	ee 24       	eor	r14, r14
   100ae:	ff 24       	eor	r15, r15
   100b0:	c7 01       	movw	r24, r14
   100b2:	a0 96       	adiw	r28, 0x20	; 32
   100b4:	0f b6       	in	r0, 0x3f	; 63
   100b6:	f8 94       	cli
   100b8:	de bf       	out	0x3e, r29	; 62
   100ba:	0f be       	out	0x3f, r0	; 63
   100bc:	cd bf       	out	0x3d, r28	; 61
   100be:	cf 91       	pop	r28
   100c0:	df 91       	pop	r29
   100c2:	1f 91       	pop	r17
   100c4:	0f 91       	pop	r16
   100c6:	ff 90       	pop	r15
   100c8:	ef 90       	pop	r14
   100ca:	df 90       	pop	r13
   100cc:	cf 90       	pop	r12
   100ce:	bf 90       	pop	r11
   100d0:	af 90       	pop	r10
   100d2:	9f 90       	pop	r9
   100d4:	8f 90       	pop	r8
   100d6:	7f 90       	pop	r7
   100d8:	6f 90       	pop	r6
   100da:	08 95       	ret

000100dc <conv_flt>:
   100dc:	2f 92       	push	r2
   100de:	3f 92       	push	r3
   100e0:	5f 92       	push	r5
   100e2:	6f 92       	push	r6
   100e4:	7f 92       	push	r7
   100e6:	8f 92       	push	r8
   100e8:	9f 92       	push	r9
   100ea:	af 92       	push	r10
   100ec:	bf 92       	push	r11
   100ee:	cf 92       	push	r12
   100f0:	df 92       	push	r13
   100f2:	ef 92       	push	r14
   100f4:	ff 92       	push	r15
   100f6:	0f 93       	push	r16
   100f8:	1f 93       	push	r17
   100fa:	cf 93       	push	r28
   100fc:	df 93       	push	r29
   100fe:	3c 01       	movw	r6, r24
   10100:	7b 01       	movw	r14, r22
   10102:	1a 01       	movw	r2, r20
   10104:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
   10108:	ec 01       	movw	r28, r24
   1010a:	8b 32       	cpi	r24, 0x2B	; 43
   1010c:	39 f0       	breq	.+14     	; 0x1011c <conv_flt+0x40>
   1010e:	8d 32       	cpi	r24, 0x2D	; 45
   10110:	11 f0       	breq	.+4      	; 0x10116 <conv_flt+0x3a>
   10112:	55 24       	eor	r5, r5
   10114:	11 c0       	rjmp	.+34     	; 0x10138 <conv_flt+0x5c>
   10116:	b0 e8       	ldi	r27, 0x80	; 128
   10118:	5b 2e       	mov	r5, r27
   1011a:	01 c0       	rjmp	.+2      	; 0x1011e <conv_flt+0x42>
   1011c:	55 24       	eor	r5, r5
   1011e:	08 94       	sec
   10120:	e1 08       	sbc	r14, r1
   10122:	f1 08       	sbc	r15, r1
   10124:	e1 14       	cp	r14, r1
   10126:	f1 04       	cpc	r15, r1
   10128:	09 f4       	brne	.+2      	; 0x1012c <conv_flt+0x50>
   1012a:	18 c1       	rjmp	.+560    	; 0x1035c <conv_flt+0x280>
   1012c:	c3 01       	movw	r24, r6
   1012e:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
   10132:	ec 01       	movw	r28, r24
   10134:	97 fd       	sbrc	r25, 7
   10136:	12 c1       	rjmp	.+548    	; 0x1035c <conv_flt+0x280>
   10138:	ce 01       	movw	r24, r28
   1013a:	0e 94 e2 87 	call	0x10fc4	; 0x10fc4 <tolower>
   1013e:	89 36       	cpi	r24, 0x69	; 105
   10140:	91 05       	cpc	r25, r1
   10142:	21 f0       	breq	.+8      	; 0x1014c <conv_flt+0x70>
   10144:	8e 36       	cpi	r24, 0x6E	; 110
   10146:	91 05       	cpc	r25, r1
   10148:	99 f5       	brne	.+102    	; 0x101b0 <conv_flt+0xd4>
   1014a:	1d c0       	rjmp	.+58     	; 0x10186 <conv_flt+0xaa>
   1014c:	06 e1       	ldi	r16, 0x16	; 22
   1014e:	15 e0       	ldi	r17, 0x05	; 5
   10150:	1c c0       	rjmp	.+56     	; 0x1018a <conv_flt+0xae>
   10152:	08 94       	sec
   10154:	e1 08       	sbc	r14, r1
   10156:	f1 08       	sbc	r15, r1
   10158:	e1 14       	cp	r14, r1
   1015a:	f1 04       	cpc	r15, r1
   1015c:	71 f0       	breq	.+28     	; 0x1017a <conv_flt+0x9e>
   1015e:	c3 01       	movw	r24, r6
   10160:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
   10164:	ec 01       	movw	r28, r24
   10166:	97 fd       	sbrc	r25, 7
   10168:	08 c0       	rjmp	.+16     	; 0x1017a <conv_flt+0x9e>
   1016a:	0e 94 e2 87 	call	0x10fc4	; 0x10fc4 <tolower>
   1016e:	d8 16       	cp	r13, r24
   10170:	61 f0       	breq	.+24     	; 0x1018a <conv_flt+0xae>
   10172:	ce 01       	movw	r24, r28
   10174:	b3 01       	movw	r22, r6
   10176:	0e 94 5b 89 	call	0x112b6	; 0x112b6 <ungetc>
   1017a:	25 e0       	ldi	r18, 0x05	; 5
   1017c:	09 31       	cpi	r16, 0x19	; 25
   1017e:	12 07       	cpc	r17, r18
   10180:	09 f0       	breq	.+2      	; 0x10184 <conv_flt+0xa8>
   10182:	ec c0       	rjmp	.+472    	; 0x1035c <conv_flt+0x280>
   10184:	08 c0       	rjmp	.+16     	; 0x10196 <conv_flt+0xba>
   10186:	03 e1       	ldi	r16, 0x13	; 19
   10188:	15 e0       	ldi	r17, 0x05	; 5
   1018a:	f8 01       	movw	r30, r16
   1018c:	0f 5f       	subi	r16, 0xFF	; 255
   1018e:	1f 4f       	sbci	r17, 0xFF	; 255
   10190:	d4 90       	lpm	r13, Z+
   10192:	dd 20       	and	r13, r13
   10194:	f1 f6       	brne	.-68     	; 0x10152 <conv_flt+0x76>
   10196:	06 51       	subi	r16, 0x16	; 22
   10198:	15 40       	sbci	r17, 0x05	; 5
   1019a:	29 f0       	breq	.+10     	; 0x101a6 <conv_flt+0xca>
   1019c:	80 e0       	ldi	r24, 0x00	; 0
   1019e:	90 e0       	ldi	r25, 0x00	; 0
   101a0:	a0 e8       	ldi	r26, 0x80	; 128
   101a2:	bf e7       	ldi	r27, 0x7F	; 127
   101a4:	cf c0       	rjmp	.+414    	; 0x10344 <conv_flt+0x268>
   101a6:	80 e0       	ldi	r24, 0x00	; 0
   101a8:	90 e0       	ldi	r25, 0x00	; 0
   101aa:	a0 ec       	ldi	r26, 0xC0	; 192
   101ac:	bf e7       	ldi	r27, 0x7F	; 127
   101ae:	ca c0       	rjmp	.+404    	; 0x10344 <conv_flt+0x268>
   101b0:	cc 24       	eor	r12, r12
   101b2:	dd 24       	eor	r13, r13
   101b4:	88 24       	eor	r8, r8
   101b6:	99 24       	eor	r9, r9
   101b8:	54 01       	movw	r10, r8
   101ba:	ae 01       	movw	r20, r28
   101bc:	40 53       	subi	r20, 0x30	; 48
   101be:	24 2f       	mov	r18, r20
   101c0:	4a 30       	cpi	r20, 0x0A	; 10
   101c2:	38 f5       	brcc	.+78     	; 0x10212 <conv_flt+0x136>
   101c4:	52 e0       	ldi	r21, 0x02	; 2
   101c6:	55 2a       	or	r5, r21
   101c8:	85 2d       	mov	r24, r5
   101ca:	90 e0       	ldi	r25, 0x00	; 0
   101cc:	ac 01       	movw	r20, r24
   101ce:	48 70       	andi	r20, 0x08	; 8
   101d0:	50 70       	andi	r21, 0x00	; 0
   101d2:	52 fe       	sbrs	r5, 2
   101d4:	06 c0       	rjmp	.+12     	; 0x101e2 <conv_flt+0x106>
   101d6:	45 2b       	or	r20, r21
   101d8:	11 f5       	brne	.+68     	; 0x1021e <conv_flt+0x142>
   101da:	08 94       	sec
   101dc:	c1 1c       	adc	r12, r1
   101de:	d1 1c       	adc	r13, r1
   101e0:	1e c0       	rjmp	.+60     	; 0x1021e <conv_flt+0x142>
   101e2:	45 2b       	or	r20, r21
   101e4:	19 f0       	breq	.+6      	; 0x101ec <conv_flt+0x110>
   101e6:	08 94       	sec
   101e8:	c1 08       	sbc	r12, r1
   101ea:	d1 08       	sbc	r13, r1
   101ec:	c5 01       	movw	r24, r10
   101ee:	b4 01       	movw	r22, r8
   101f0:	40 e2       	ldi	r20, 0x20	; 32
   101f2:	0e 94 c6 7e 	call	0xfd8c	; 0xfd8c <mulacc>
   101f6:	4b 01       	movw	r8, r22
   101f8:	5c 01       	movw	r10, r24
   101fa:	88 e9       	ldi	r24, 0x98	; 152
   101fc:	88 16       	cp	r8, r24
   101fe:	89 e9       	ldi	r24, 0x99	; 153
   10200:	98 06       	cpc	r9, r24
   10202:	89 e9       	ldi	r24, 0x99	; 153
   10204:	a8 06       	cpc	r10, r24
   10206:	89 e1       	ldi	r24, 0x19	; 25
   10208:	b8 06       	cpc	r11, r24
   1020a:	48 f0       	brcs	.+18     	; 0x1021e <conv_flt+0x142>
   1020c:	94 e0       	ldi	r25, 0x04	; 4
   1020e:	59 2a       	or	r5, r25
   10210:	06 c0       	rjmp	.+12     	; 0x1021e <conv_flt+0x142>
   10212:	4e 3f       	cpi	r20, 0xFE	; 254
   10214:	81 f4       	brne	.+32     	; 0x10236 <conv_flt+0x15a>
   10216:	53 fc       	sbrc	r5, 3
   10218:	0e c0       	rjmp	.+28     	; 0x10236 <conv_flt+0x15a>
   1021a:	e8 e0       	ldi	r30, 0x08	; 8
   1021c:	5e 2a       	or	r5, r30
   1021e:	08 94       	sec
   10220:	e1 08       	sbc	r14, r1
   10222:	f1 08       	sbc	r15, r1
   10224:	e1 14       	cp	r14, r1
   10226:	f1 04       	cpc	r15, r1
   10228:	31 f0       	breq	.+12     	; 0x10236 <conv_flt+0x15a>
   1022a:	c3 01       	movw	r24, r6
   1022c:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
   10230:	ec 01       	movw	r28, r24
   10232:	97 ff       	sbrs	r25, 7
   10234:	c2 cf       	rjmp	.-124    	; 0x101ba <conv_flt+0xde>
   10236:	51 fe       	sbrs	r5, 1
   10238:	91 c0       	rjmp	.+290    	; 0x1035c <conv_flt+0x280>
   1023a:	c5 36       	cpi	r28, 0x65	; 101
   1023c:	19 f0       	breq	.+6      	; 0x10244 <conv_flt+0x168>
   1023e:	c5 34       	cpi	r28, 0x45	; 69
   10240:	09 f0       	breq	.+2      	; 0x10244 <conv_flt+0x168>
   10242:	46 c0       	rjmp	.+140    	; 0x102d0 <conv_flt+0x1f4>
   10244:	08 94       	sec
   10246:	e1 08       	sbc	r14, r1
   10248:	f1 08       	sbc	r15, r1
   1024a:	e1 14       	cp	r14, r1
   1024c:	f1 04       	cpc	r15, r1
   1024e:	09 f4       	brne	.+2      	; 0x10252 <conv_flt+0x176>
   10250:	85 c0       	rjmp	.+266    	; 0x1035c <conv_flt+0x280>
   10252:	c3 01       	movw	r24, r6
   10254:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
   10258:	ec 01       	movw	r28, r24
   1025a:	97 fd       	sbrc	r25, 7
   1025c:	7f c0       	rjmp	.+254    	; 0x1035c <conv_flt+0x280>
   1025e:	8b 32       	cpi	r24, 0x2B	; 43
   10260:	21 f0       	breq	.+8      	; 0x1026a <conv_flt+0x18e>
   10262:	8d 32       	cpi	r24, 0x2D	; 45
   10264:	69 f4       	brne	.+26     	; 0x10280 <conv_flt+0x1a4>
   10266:	f0 e1       	ldi	r31, 0x10	; 16
   10268:	5f 2a       	or	r5, r31
   1026a:	08 94       	sec
   1026c:	e1 08       	sbc	r14, r1
   1026e:	f1 08       	sbc	r15, r1
   10270:	e1 14       	cp	r14, r1
   10272:	f1 04       	cpc	r15, r1
   10274:	09 f4       	brne	.+2      	; 0x10278 <conv_flt+0x19c>
   10276:	72 c0       	rjmp	.+228    	; 0x1035c <conv_flt+0x280>
   10278:	c3 01       	movw	r24, r6
   1027a:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
   1027e:	ec 01       	movw	r28, r24
   10280:	ce 01       	movw	r24, r28
   10282:	c0 97       	sbiw	r24, 0x30	; 48
   10284:	0a 97       	sbiw	r24, 0x0a	; 10
   10286:	08 f0       	brcs	.+2      	; 0x1028a <conv_flt+0x1ae>
   10288:	69 c0       	rjmp	.+210    	; 0x1035c <conv_flt+0x280>
   1028a:	00 e0       	ldi	r16, 0x00	; 0
   1028c:	10 e0       	ldi	r17, 0x00	; 0
   1028e:	b8 01       	movw	r22, r16
   10290:	88 27       	eor	r24, r24
   10292:	77 fd       	sbrc	r23, 7
   10294:	80 95       	com	r24
   10296:	98 2f       	mov	r25, r24
   10298:	ae 01       	movw	r20, r28
   1029a:	40 53       	subi	r20, 0x30	; 48
   1029c:	24 2f       	mov	r18, r20
   1029e:	40 e2       	ldi	r20, 0x20	; 32
   102a0:	0e 94 c6 7e 	call	0xfd8c	; 0xfd8c <mulacc>
   102a4:	8b 01       	movw	r16, r22
   102a6:	08 94       	sec
   102a8:	e1 08       	sbc	r14, r1
   102aa:	f1 08       	sbc	r15, r1
   102ac:	e1 14       	cp	r14, r1
   102ae:	f1 04       	cpc	r15, r1
   102b0:	39 f0       	breq	.+14     	; 0x102c0 <conv_flt+0x1e4>
   102b2:	c3 01       	movw	r24, r6
   102b4:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
   102b8:	ec 01       	movw	r28, r24
   102ba:	c0 97       	sbiw	r24, 0x30	; 48
   102bc:	0a 97       	sbiw	r24, 0x0a	; 10
   102be:	38 f3       	brcs	.-50     	; 0x1028e <conv_flt+0x1b2>
   102c0:	b8 01       	movw	r22, r16
   102c2:	54 fe       	sbrs	r5, 4
   102c4:	03 c0       	rjmp	.+6      	; 0x102cc <conv_flt+0x1f0>
   102c6:	70 95       	com	r23
   102c8:	61 95       	neg	r22
   102ca:	7f 4f       	sbci	r23, 0xFF	; 255
   102cc:	c6 0e       	add	r12, r22
   102ce:	d7 1e       	adc	r13, r23
   102d0:	ef 28       	or	r14, r15
   102d2:	31 f0       	breq	.+12     	; 0x102e0 <conv_flt+0x204>
   102d4:	d7 fd       	sbrc	r29, 7
   102d6:	04 c0       	rjmp	.+8      	; 0x102e0 <conv_flt+0x204>
   102d8:	ce 01       	movw	r24, r28
   102da:	b3 01       	movw	r22, r6
   102dc:	0e 94 5b 89 	call	0x112b6	; 0x112b6 <ungetc>
   102e0:	c5 01       	movw	r24, r10
   102e2:	b4 01       	movw	r22, r8
   102e4:	0e 94 02 84 	call	0x10804	; 0x10804 <__floatunsisf>
   102e8:	d7 fe       	sbrs	r13, 7
   102ea:	0d c0       	rjmp	.+26     	; 0x10306 <conv_flt+0x22a>
   102ec:	a2 e3       	ldi	r26, 0x32	; 50
   102ee:	ea 2e       	mov	r14, r26
   102f0:	a5 e0       	ldi	r26, 0x05	; 5
   102f2:	fa 2e       	mov	r15, r26
   102f4:	d0 94       	com	r13
   102f6:	c1 94       	neg	r12
   102f8:	d1 08       	sbc	r13, r1
   102fa:	d3 94       	inc	r13
   102fc:	c0 e2       	ldi	r28, 0x20	; 32
   102fe:	d0 e0       	ldi	r29, 0x00	; 0
   10300:	00 e0       	ldi	r16, 0x00	; 0
   10302:	10 e0       	ldi	r17, 0x00	; 0
   10304:	0e c0       	rjmp	.+28     	; 0x10322 <conv_flt+0x246>
   10306:	fa e4       	ldi	r31, 0x4A	; 74
   10308:	ef 2e       	mov	r14, r31
   1030a:	f5 e0       	ldi	r31, 0x05	; 5
   1030c:	ff 2e       	mov	r15, r31
   1030e:	f6 cf       	rjmp	.-20     	; 0x102fc <conv_flt+0x220>
   10310:	f7 01       	movw	r30, r14
   10312:	25 91       	lpm	r18, Z+
   10314:	35 91       	lpm	r19, Z+
   10316:	45 91       	lpm	r20, Z+
   10318:	54 91       	lpm	r21, Z+
   1031a:	0e 94 0b 85 	call	0x10a16	; 0x10a16 <__mulsf3>
   1031e:	cc 1a       	sub	r12, r28
   10320:	dd 0a       	sbc	r13, r29
   10322:	cc 16       	cp	r12, r28
   10324:	dd 06       	cpc	r13, r29
   10326:	a0 f7       	brcc	.-24     	; 0x10310 <conv_flt+0x234>
   10328:	d6 95       	lsr	r29
   1032a:	c7 95       	ror	r28
   1032c:	0f 5f       	subi	r16, 0xFF	; 255
   1032e:	1f 4f       	sbci	r17, 0xFF	; 255
   10330:	06 30       	cpi	r16, 0x06	; 6
   10332:	11 05       	cpc	r17, r1
   10334:	29 f0       	breq	.+10     	; 0x10340 <conv_flt+0x264>
   10336:	ec ef       	ldi	r30, 0xFC	; 252
   10338:	ff ef       	ldi	r31, 0xFF	; 255
   1033a:	ee 0e       	add	r14, r30
   1033c:	ff 1e       	adc	r15, r31
   1033e:	f1 cf       	rjmp	.-30     	; 0x10322 <conv_flt+0x246>
   10340:	dc 01       	movw	r26, r24
   10342:	cb 01       	movw	r24, r22
   10344:	57 fc       	sbrc	r5, 7
   10346:	b0 58       	subi	r27, 0x80	; 128
   10348:	21 14       	cp	r2, r1
   1034a:	31 04       	cpc	r3, r1
   1034c:	29 f0       	breq	.+10     	; 0x10358 <conv_flt+0x27c>
   1034e:	f1 01       	movw	r30, r2
   10350:	80 83       	st	Z, r24
   10352:	91 83       	std	Z+1, r25	; 0x01
   10354:	a2 83       	std	Z+2, r26	; 0x02
   10356:	b3 83       	std	Z+3, r27	; 0x03
   10358:	81 e0       	ldi	r24, 0x01	; 1
   1035a:	01 c0       	rjmp	.+2      	; 0x1035e <conv_flt+0x282>
   1035c:	80 e0       	ldi	r24, 0x00	; 0
   1035e:	df 91       	pop	r29
   10360:	cf 91       	pop	r28
   10362:	1f 91       	pop	r17
   10364:	0f 91       	pop	r16
   10366:	ff 90       	pop	r15
   10368:	ef 90       	pop	r14
   1036a:	df 90       	pop	r13
   1036c:	cf 90       	pop	r12
   1036e:	bf 90       	pop	r11
   10370:	af 90       	pop	r10
   10372:	9f 90       	pop	r9
   10374:	8f 90       	pop	r8
   10376:	7f 90       	pop	r7
   10378:	6f 90       	pop	r6
   1037a:	5f 90       	pop	r5
   1037c:	3f 90       	pop	r3
   1037e:	2f 90       	pop	r2
   10380:	08 95       	ret

00010382 <vfscanf>:
   10382:	5f 92       	push	r5
   10384:	6f 92       	push	r6
   10386:	7f 92       	push	r7
   10388:	8f 92       	push	r8
   1038a:	9f 92       	push	r9
   1038c:	af 92       	push	r10
   1038e:	bf 92       	push	r11
   10390:	cf 92       	push	r12
   10392:	df 92       	push	r13
   10394:	ef 92       	push	r14
   10396:	ff 92       	push	r15
   10398:	0f 93       	push	r16
   1039a:	1f 93       	push	r17
   1039c:	cf 93       	push	r28
   1039e:	df 93       	push	r29
   103a0:	4c 01       	movw	r8, r24
   103a2:	5b 01       	movw	r10, r22
   103a4:	3a 01       	movw	r6, r20
   103a6:	fc 01       	movw	r30, r24
   103a8:	17 82       	std	Z+7, r1	; 0x07
   103aa:	16 82       	std	Z+6, r1	; 0x06
   103ac:	55 24       	eor	r5, r5
   103ae:	04 c1       	rjmp	.+520    	; 0x105b8 <vfscanf+0x236>
   103b0:	81 2f       	mov	r24, r17
   103b2:	90 e0       	ldi	r25, 0x00	; 0
   103b4:	0e 94 da 87 	call	0x10fb4	; 0x10fb4 <isspace>
   103b8:	89 2b       	or	r24, r25
   103ba:	21 f0       	breq	.+8      	; 0x103c4 <vfscanf+0x42>
   103bc:	c4 01       	movw	r24, r8
   103be:	0e 94 f4 7e 	call	0xfde8	; 0xfde8 <skip_spaces>
   103c2:	fa c0       	rjmp	.+500    	; 0x105b8 <vfscanf+0x236>
   103c4:	15 32       	cpi	r17, 0x25	; 37
   103c6:	49 f4       	brne	.+18     	; 0x103da <vfscanf+0x58>
   103c8:	f5 01       	movw	r30, r10
   103ca:	f3 fc       	sbrc	r15, 3
   103cc:	65 91       	lpm	r22, Z+
   103ce:	f3 fe       	sbrs	r15, 3
   103d0:	61 91       	ld	r22, Z+
   103d2:	5f 01       	movw	r10, r30
   103d4:	65 32       	cpi	r22, 0x25	; 37
   103d6:	69 f4       	brne	.+26     	; 0x103f2 <vfscanf+0x70>
   103d8:	15 e2       	ldi	r17, 0x25	; 37
   103da:	c4 01       	movw	r24, r8
   103dc:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
   103e0:	97 fd       	sbrc	r25, 7
   103e2:	f6 c0       	rjmp	.+492    	; 0x105d0 <vfscanf+0x24e>
   103e4:	18 17       	cp	r17, r24
   103e6:	09 f4       	brne	.+2      	; 0x103ea <vfscanf+0x68>
   103e8:	e7 c0       	rjmp	.+462    	; 0x105b8 <vfscanf+0x236>
   103ea:	b4 01       	movw	r22, r8
   103ec:	0e 94 5b 89 	call	0x112b6	; 0x112b6 <ungetc>
   103f0:	f4 c0       	rjmp	.+488    	; 0x105da <vfscanf+0x258>
   103f2:	6a 32       	cpi	r22, 0x2A	; 42
   103f4:	19 f0       	breq	.+6      	; 0x103fc <vfscanf+0x7a>
   103f6:	16 2f       	mov	r17, r22
   103f8:	00 e0       	ldi	r16, 0x00	; 0
   103fa:	06 c0       	rjmp	.+12     	; 0x10408 <vfscanf+0x86>
   103fc:	f3 fc       	sbrc	r15, 3
   103fe:	15 91       	lpm	r17, Z+
   10400:	f3 fe       	sbrs	r15, 3
   10402:	11 91       	ld	r17, Z+
   10404:	5f 01       	movw	r10, r30
   10406:	01 e0       	ldi	r16, 0x01	; 1
   10408:	cc 24       	eor	r12, r12
   1040a:	dd 24       	eor	r13, r13
   1040c:	0e c0       	rjmp	.+28     	; 0x1042a <vfscanf+0xa8>
   1040e:	02 60       	ori	r16, 0x02	; 2
   10410:	b6 01       	movw	r22, r12
   10412:	80 e0       	ldi	r24, 0x00	; 0
   10414:	90 e0       	ldi	r25, 0x00	; 0
   10416:	40 e2       	ldi	r20, 0x20	; 32
   10418:	0e 94 c6 7e 	call	0xfd8c	; 0xfd8c <mulacc>
   1041c:	6b 01       	movw	r12, r22
   1041e:	f5 01       	movw	r30, r10
   10420:	f3 fc       	sbrc	r15, 3
   10422:	15 91       	lpm	r17, Z+
   10424:	f3 fe       	sbrs	r15, 3
   10426:	11 91       	ld	r17, Z+
   10428:	5f 01       	movw	r10, r30
   1042a:	21 2f       	mov	r18, r17
   1042c:	20 53       	subi	r18, 0x30	; 48
   1042e:	2a 30       	cpi	r18, 0x0A	; 10
   10430:	70 f3       	brcs	.-36     	; 0x1040e <vfscanf+0x8c>
   10432:	01 fd       	sbrc	r16, 1
   10434:	04 c0       	rjmp	.+8      	; 0x1043e <vfscanf+0xbc>
   10436:	cc 24       	eor	r12, r12
   10438:	ca 94       	dec	r12
   1043a:	dc 2c       	mov	r13, r12
   1043c:	04 c0       	rjmp	.+8      	; 0x10446 <vfscanf+0xc4>
   1043e:	c1 14       	cp	r12, r1
   10440:	d1 04       	cpc	r13, r1
   10442:	09 f4       	brne	.+2      	; 0x10446 <vfscanf+0xc4>
   10444:	ca c0       	rjmp	.+404    	; 0x105da <vfscanf+0x258>
   10446:	18 36       	cpi	r17, 0x68	; 104
   10448:	21 f0       	breq	.+8      	; 0x10452 <vfscanf+0xd0>
   1044a:	1c 36       	cpi	r17, 0x6C	; 108
   1044c:	99 f4       	brne	.+38     	; 0x10474 <vfscanf+0xf2>
   1044e:	f5 01       	movw	r30, r10
   10450:	0b c0       	rjmp	.+22     	; 0x10468 <vfscanf+0xe6>
   10452:	f5 01       	movw	r30, r10
   10454:	f3 fc       	sbrc	r15, 3
   10456:	65 91       	lpm	r22, Z+
   10458:	f3 fe       	sbrs	r15, 3
   1045a:	61 91       	ld	r22, Z+
   1045c:	68 36       	cpi	r22, 0x68	; 104
   1045e:	19 f0       	breq	.+6      	; 0x10466 <vfscanf+0xe4>
   10460:	5f 01       	movw	r10, r30
   10462:	16 2f       	mov	r17, r22
   10464:	07 c0       	rjmp	.+14     	; 0x10474 <vfscanf+0xf2>
   10466:	08 60       	ori	r16, 0x08	; 8
   10468:	04 60       	ori	r16, 0x04	; 4
   1046a:	f3 fc       	sbrc	r15, 3
   1046c:	15 91       	lpm	r17, Z+
   1046e:	f3 fe       	sbrs	r15, 3
   10470:	11 91       	ld	r17, Z+
   10472:	5f 01       	movw	r10, r30
   10474:	11 23       	and	r17, r17
   10476:	09 f4       	brne	.+2      	; 0x1047a <vfscanf+0xf8>
   10478:	b0 c0       	rjmp	.+352    	; 0x105da <vfscanf+0x258>
   1047a:	81 e0       	ldi	r24, 0x01	; 1
   1047c:	95 e0       	ldi	r25, 0x05	; 5
   1047e:	61 2f       	mov	r22, r17
   10480:	70 e0       	ldi	r23, 0x00	; 0
   10482:	0e 94 ea 87 	call	0x10fd4	; 0x10fd4 <strchr_P>
   10486:	89 2b       	or	r24, r25
   10488:	09 f4       	brne	.+2      	; 0x1048c <vfscanf+0x10a>
   1048a:	a7 c0       	rjmp	.+334    	; 0x105da <vfscanf+0x258>
   1048c:	80 2f       	mov	r24, r16
   1048e:	00 ff       	sbrs	r16, 0
   10490:	03 c0       	rjmp	.+6      	; 0x10498 <vfscanf+0x116>
   10492:	ee 24       	eor	r14, r14
   10494:	ff 24       	eor	r15, r15
   10496:	07 c0       	rjmp	.+14     	; 0x104a6 <vfscanf+0x124>
   10498:	f3 01       	movw	r30, r6
   1049a:	e0 80       	ld	r14, Z
   1049c:	f1 80       	ldd	r15, Z+1	; 0x01
   1049e:	22 e0       	ldi	r18, 0x02	; 2
   104a0:	30 e0       	ldi	r19, 0x00	; 0
   104a2:	62 0e       	add	r6, r18
   104a4:	73 1e       	adc	r7, r19
   104a6:	1e 36       	cpi	r17, 0x6E	; 110
   104a8:	51 f4       	brne	.+20     	; 0x104be <vfscanf+0x13c>
   104aa:	f4 01       	movw	r30, r8
   104ac:	46 81       	ldd	r20, Z+6	; 0x06
   104ae:	57 81       	ldd	r21, Z+7	; 0x07
   104b0:	60 e0       	ldi	r22, 0x00	; 0
   104b2:	70 e0       	ldi	r23, 0x00	; 0
   104b4:	c7 01       	movw	r24, r14
   104b6:	20 2f       	mov	r18, r16
   104b8:	0e 94 ba 7e 	call	0xfd74	; 0xfd74 <putval>
   104bc:	7d c0       	rjmp	.+250    	; 0x105b8 <vfscanf+0x236>
   104be:	13 36       	cpi	r17, 0x63	; 99
   104c0:	b9 f4       	brne	.+46     	; 0x104f0 <vfscanf+0x16e>
   104c2:	81 fd       	sbrc	r24, 1
   104c4:	03 c0       	rjmp	.+6      	; 0x104cc <vfscanf+0x14a>
   104c6:	11 e0       	ldi	r17, 0x01	; 1
   104c8:	c1 2e       	mov	r12, r17
   104ca:	d1 2c       	mov	r13, r1
   104cc:	c4 01       	movw	r24, r8
   104ce:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
   104d2:	97 fd       	sbrc	r25, 7
   104d4:	7d c0       	rjmp	.+250    	; 0x105d0 <vfscanf+0x24e>
   104d6:	e1 14       	cp	r14, r1
   104d8:	f1 04       	cpc	r15, r1
   104da:	19 f0       	breq	.+6      	; 0x104e2 <vfscanf+0x160>
   104dc:	f7 01       	movw	r30, r14
   104de:	81 93       	st	Z+, r24
   104e0:	7f 01       	movw	r14, r30
   104e2:	08 94       	sec
   104e4:	c1 08       	sbc	r12, r1
   104e6:	d1 08       	sbc	r13, r1
   104e8:	c1 14       	cp	r12, r1
   104ea:	d1 04       	cpc	r13, r1
   104ec:	79 f7       	brne	.-34     	; 0x104cc <vfscanf+0x14a>
   104ee:	62 c0       	rjmp	.+196    	; 0x105b4 <vfscanf+0x232>
   104f0:	1b 35       	cpi	r17, 0x5B	; 91
   104f2:	59 f4       	brne	.+22     	; 0x1050a <vfscanf+0x188>
   104f4:	c4 01       	movw	r24, r8
   104f6:	b6 01       	movw	r22, r12
   104f8:	a7 01       	movw	r20, r14
   104fa:	95 01       	movw	r18, r10
   104fc:	0e 94 a1 7f 	call	0xff42	; 0xff42 <conv_brk>
   10500:	5c 01       	movw	r10, r24
   10502:	00 97       	sbiw	r24, 0x00	; 0
   10504:	09 f0       	breq	.+2      	; 0x10508 <vfscanf+0x186>
   10506:	56 c0       	rjmp	.+172    	; 0x105b4 <vfscanf+0x232>
   10508:	50 c0       	rjmp	.+160    	; 0x105aa <vfscanf+0x228>
   1050a:	c4 01       	movw	r24, r8
   1050c:	0e 94 f4 7e 	call	0xfde8	; 0xfde8 <skip_spaces>
   10510:	97 fd       	sbrc	r25, 7
   10512:	5e c0       	rjmp	.+188    	; 0x105d0 <vfscanf+0x24e>
   10514:	1f 36       	cpi	r17, 0x6F	; 111
   10516:	d1 f1       	breq	.+116    	; 0x1058c <vfscanf+0x20a>
   10518:	10 37       	cpi	r17, 0x70	; 112
   1051a:	38 f4       	brcc	.+14     	; 0x1052a <vfscanf+0x1a8>
   1051c:	14 36       	cpi	r17, 0x64	; 100
   1051e:	a1 f1       	breq	.+104    	; 0x10588 <vfscanf+0x206>
   10520:	19 36       	cpi	r17, 0x69	; 105
   10522:	a9 f1       	breq	.+106    	; 0x1058e <vfscanf+0x20c>
   10524:	18 35       	cpi	r17, 0x58	; 88
   10526:	d1 f5       	brne	.+116    	; 0x1059c <vfscanf+0x21a>
   10528:	2d c0       	rjmp	.+90     	; 0x10584 <vfscanf+0x202>
   1052a:	13 37       	cpi	r17, 0x73	; 115
   1052c:	51 f0       	breq	.+20     	; 0x10542 <vfscanf+0x1c0>
   1052e:	14 37       	cpi	r17, 0x74	; 116
   10530:	18 f4       	brcc	.+6      	; 0x10538 <vfscanf+0x1b6>
   10532:	10 37       	cpi	r17, 0x70	; 112
   10534:	99 f5       	brne	.+102    	; 0x1059c <vfscanf+0x21a>
   10536:	26 c0       	rjmp	.+76     	; 0x10584 <vfscanf+0x202>
   10538:	15 37       	cpi	r17, 0x75	; 117
   1053a:	31 f1       	breq	.+76     	; 0x10588 <vfscanf+0x206>
   1053c:	18 37       	cpi	r17, 0x78	; 120
   1053e:	71 f5       	brne	.+92     	; 0x1059c <vfscanf+0x21a>
   10540:	21 c0       	rjmp	.+66     	; 0x10584 <vfscanf+0x202>
   10542:	c4 01       	movw	r24, r8
   10544:	0e 94 33 88 	call	0x11066	; 0x11066 <fgetc>
   10548:	ec 01       	movw	r28, r24
   1054a:	97 fd       	sbrc	r25, 7
   1054c:	15 c0       	rjmp	.+42     	; 0x10578 <vfscanf+0x1f6>
   1054e:	0e 94 da 87 	call	0x10fb4	; 0x10fb4 <isspace>
   10552:	89 2b       	or	r24, r25
   10554:	29 f0       	breq	.+10     	; 0x10560 <vfscanf+0x1de>
   10556:	ce 01       	movw	r24, r28
   10558:	b4 01       	movw	r22, r8
   1055a:	0e 94 5b 89 	call	0x112b6	; 0x112b6 <ungetc>
   1055e:	0c c0       	rjmp	.+24     	; 0x10578 <vfscanf+0x1f6>
   10560:	e1 14       	cp	r14, r1
   10562:	f1 04       	cpc	r15, r1
   10564:	19 f0       	breq	.+6      	; 0x1056c <vfscanf+0x1ea>
   10566:	f7 01       	movw	r30, r14
   10568:	c1 93       	st	Z+, r28
   1056a:	7f 01       	movw	r14, r30
   1056c:	08 94       	sec
   1056e:	c1 08       	sbc	r12, r1
   10570:	d1 08       	sbc	r13, r1
   10572:	c1 14       	cp	r12, r1
   10574:	d1 04       	cpc	r13, r1
   10576:	29 f7       	brne	.-54     	; 0x10542 <vfscanf+0x1c0>
   10578:	e1 14       	cp	r14, r1
   1057a:	f1 04       	cpc	r15, r1
   1057c:	d9 f0       	breq	.+54     	; 0x105b4 <vfscanf+0x232>
   1057e:	f7 01       	movw	r30, r14
   10580:	10 82       	st	Z, r1
   10582:	18 c0       	rjmp	.+48     	; 0x105b4 <vfscanf+0x232>
   10584:	00 64       	ori	r16, 0x40	; 64
   10586:	03 c0       	rjmp	.+6      	; 0x1058e <vfscanf+0x20c>
   10588:	00 62       	ori	r16, 0x20	; 32
   1058a:	01 c0       	rjmp	.+2      	; 0x1058e <vfscanf+0x20c>
   1058c:	00 61       	ori	r16, 0x10	; 16
   1058e:	c4 01       	movw	r24, r8
   10590:	b6 01       	movw	r22, r12
   10592:	a7 01       	movw	r20, r14
   10594:	20 2f       	mov	r18, r16
   10596:	0e 94 0d 7f 	call	0xfe1a	; 0xfe1a <conv_int>
   1059a:	05 c0       	rjmp	.+10     	; 0x105a6 <vfscanf+0x224>
   1059c:	c4 01       	movw	r24, r8
   1059e:	b6 01       	movw	r22, r12
   105a0:	a7 01       	movw	r20, r14
   105a2:	0e 94 6e 80 	call	0x100dc	; 0x100dc <conv_flt>
   105a6:	88 23       	and	r24, r24
   105a8:	29 f4       	brne	.+10     	; 0x105b4 <vfscanf+0x232>
   105aa:	f4 01       	movw	r30, r8
   105ac:	83 81       	ldd	r24, Z+3	; 0x03
   105ae:	80 73       	andi	r24, 0x30	; 48
   105b0:	79 f4       	brne	.+30     	; 0x105d0 <vfscanf+0x24e>
   105b2:	13 c0       	rjmp	.+38     	; 0x105da <vfscanf+0x258>
   105b4:	00 ff       	sbrs	r16, 0
   105b6:	53 94       	inc	r5
   105b8:	f4 01       	movw	r30, r8
   105ba:	f3 80       	ldd	r15, Z+3	; 0x03
   105bc:	f5 01       	movw	r30, r10
   105be:	f3 fc       	sbrc	r15, 3
   105c0:	15 91       	lpm	r17, Z+
   105c2:	f3 fe       	sbrs	r15, 3
   105c4:	11 91       	ld	r17, Z+
   105c6:	5f 01       	movw	r10, r30
   105c8:	11 23       	and	r17, r17
   105ca:	09 f0       	breq	.+2      	; 0x105ce <vfscanf+0x24c>
   105cc:	f1 ce       	rjmp	.-542    	; 0x103b0 <vfscanf+0x2e>
   105ce:	05 c0       	rjmp	.+10     	; 0x105da <vfscanf+0x258>
   105d0:	55 20       	and	r5, r5
   105d2:	19 f4       	brne	.+6      	; 0x105da <vfscanf+0x258>
   105d4:	2f ef       	ldi	r18, 0xFF	; 255
   105d6:	3f ef       	ldi	r19, 0xFF	; 255
   105d8:	02 c0       	rjmp	.+4      	; 0x105de <vfscanf+0x25c>
   105da:	25 2d       	mov	r18, r5
   105dc:	30 e0       	ldi	r19, 0x00	; 0
   105de:	c9 01       	movw	r24, r18
   105e0:	df 91       	pop	r29
   105e2:	cf 91       	pop	r28
   105e4:	1f 91       	pop	r17
   105e6:	0f 91       	pop	r16
   105e8:	ff 90       	pop	r15
   105ea:	ef 90       	pop	r14
   105ec:	df 90       	pop	r13
   105ee:	cf 90       	pop	r12
   105f0:	bf 90       	pop	r11
   105f2:	af 90       	pop	r10
   105f4:	9f 90       	pop	r9
   105f6:	8f 90       	pop	r8
   105f8:	7f 90       	pop	r7
   105fa:	6f 90       	pop	r6
   105fc:	5f 90       	pop	r5
   105fe:	08 95       	ret

00010600 <__subsf3>:
   10600:	50 58       	subi	r21, 0x80	; 128

00010602 <__addsf3>:
   10602:	bb 27       	eor	r27, r27
   10604:	aa 27       	eor	r26, r26
   10606:	0e d0       	rcall	.+28     	; 0x10624 <__addsf3x>
   10608:	b1 c1       	rjmp	.+866    	; 0x1096c <__fp_round>
   1060a:	a2 d1       	rcall	.+836    	; 0x10950 <__fp_pscA>
   1060c:	30 f0       	brcs	.+12     	; 0x1061a <__addsf3+0x18>
   1060e:	a7 d1       	rcall	.+846    	; 0x1095e <__fp_pscB>
   10610:	20 f0       	brcs	.+8      	; 0x1061a <__addsf3+0x18>
   10612:	31 f4       	brne	.+12     	; 0x10620 <__addsf3+0x1e>
   10614:	9f 3f       	cpi	r25, 0xFF	; 255
   10616:	11 f4       	brne	.+4      	; 0x1061c <__addsf3+0x1a>
   10618:	1e f4       	brtc	.+6      	; 0x10620 <__addsf3+0x1e>
   1061a:	97 c1       	rjmp	.+814    	; 0x1094a <__fp_nan>
   1061c:	0e f4       	brtc	.+2      	; 0x10620 <__addsf3+0x1e>
   1061e:	e0 95       	com	r30
   10620:	e7 fb       	bst	r30, 7
   10622:	64 c1       	rjmp	.+712    	; 0x108ec <__fp_inf>

00010624 <__addsf3x>:
   10624:	e9 2f       	mov	r30, r25
   10626:	b3 d1       	rcall	.+870    	; 0x1098e <__fp_split3>
   10628:	80 f3       	brcs	.-32     	; 0x1060a <__addsf3+0x8>
   1062a:	ba 17       	cp	r27, r26
   1062c:	62 07       	cpc	r22, r18
   1062e:	73 07       	cpc	r23, r19
   10630:	84 07       	cpc	r24, r20
   10632:	95 07       	cpc	r25, r21
   10634:	18 f0       	brcs	.+6      	; 0x1063c <__addsf3x+0x18>
   10636:	71 f4       	brne	.+28     	; 0x10654 <__addsf3x+0x30>
   10638:	9e f5       	brtc	.+102    	; 0x106a0 <__addsf3x+0x7c>
   1063a:	e2 c1       	rjmp	.+964    	; 0x10a00 <__fp_zero>
   1063c:	0e f4       	brtc	.+2      	; 0x10640 <__addsf3x+0x1c>
   1063e:	e0 95       	com	r30
   10640:	0b 2e       	mov	r0, r27
   10642:	ba 2f       	mov	r27, r26
   10644:	a0 2d       	mov	r26, r0
   10646:	0b 01       	movw	r0, r22
   10648:	b9 01       	movw	r22, r18
   1064a:	90 01       	movw	r18, r0
   1064c:	0c 01       	movw	r0, r24
   1064e:	ca 01       	movw	r24, r20
   10650:	a0 01       	movw	r20, r0
   10652:	11 24       	eor	r1, r1
   10654:	ff 27       	eor	r31, r31
   10656:	59 1b       	sub	r21, r25
   10658:	99 f0       	breq	.+38     	; 0x10680 <__addsf3x+0x5c>
   1065a:	59 3f       	cpi	r21, 0xF9	; 249
   1065c:	50 f4       	brcc	.+20     	; 0x10672 <__addsf3x+0x4e>
   1065e:	50 3e       	cpi	r21, 0xE0	; 224
   10660:	68 f1       	brcs	.+90     	; 0x106bc <__addsf3x+0x98>
   10662:	1a 16       	cp	r1, r26
   10664:	f0 40       	sbci	r31, 0x00	; 0
   10666:	a2 2f       	mov	r26, r18
   10668:	23 2f       	mov	r18, r19
   1066a:	34 2f       	mov	r19, r20
   1066c:	44 27       	eor	r20, r20
   1066e:	58 5f       	subi	r21, 0xF8	; 248
   10670:	f3 cf       	rjmp	.-26     	; 0x10658 <__addsf3x+0x34>
   10672:	46 95       	lsr	r20
   10674:	37 95       	ror	r19
   10676:	27 95       	ror	r18
   10678:	a7 95       	ror	r26
   1067a:	f0 40       	sbci	r31, 0x00	; 0
   1067c:	53 95       	inc	r21
   1067e:	c9 f7       	brne	.-14     	; 0x10672 <__addsf3x+0x4e>
   10680:	7e f4       	brtc	.+30     	; 0x106a0 <__addsf3x+0x7c>
   10682:	1f 16       	cp	r1, r31
   10684:	ba 0b       	sbc	r27, r26
   10686:	62 0b       	sbc	r22, r18
   10688:	73 0b       	sbc	r23, r19
   1068a:	84 0b       	sbc	r24, r20
   1068c:	ba f0       	brmi	.+46     	; 0x106bc <__addsf3x+0x98>
   1068e:	91 50       	subi	r25, 0x01	; 1
   10690:	a1 f0       	breq	.+40     	; 0x106ba <__addsf3x+0x96>
   10692:	ff 0f       	add	r31, r31
   10694:	bb 1f       	adc	r27, r27
   10696:	66 1f       	adc	r22, r22
   10698:	77 1f       	adc	r23, r23
   1069a:	88 1f       	adc	r24, r24
   1069c:	c2 f7       	brpl	.-16     	; 0x1068e <__addsf3x+0x6a>
   1069e:	0e c0       	rjmp	.+28     	; 0x106bc <__addsf3x+0x98>
   106a0:	ba 0f       	add	r27, r26
   106a2:	62 1f       	adc	r22, r18
   106a4:	73 1f       	adc	r23, r19
   106a6:	84 1f       	adc	r24, r20
   106a8:	48 f4       	brcc	.+18     	; 0x106bc <__addsf3x+0x98>
   106aa:	87 95       	ror	r24
   106ac:	77 95       	ror	r23
   106ae:	67 95       	ror	r22
   106b0:	b7 95       	ror	r27
   106b2:	f7 95       	ror	r31
   106b4:	9e 3f       	cpi	r25, 0xFE	; 254
   106b6:	08 f0       	brcs	.+2      	; 0x106ba <__addsf3x+0x96>
   106b8:	b3 cf       	rjmp	.-154    	; 0x10620 <__addsf3+0x1e>
   106ba:	93 95       	inc	r25
   106bc:	88 0f       	add	r24, r24
   106be:	08 f0       	brcs	.+2      	; 0x106c2 <__addsf3x+0x9e>
   106c0:	99 27       	eor	r25, r25
   106c2:	ee 0f       	add	r30, r30
   106c4:	97 95       	ror	r25
   106c6:	87 95       	ror	r24
   106c8:	08 95       	ret

000106ca <__cmpsf2>:
   106ca:	ec d0       	rcall	.+472    	; 0x108a4 <__fp_cmp>
   106cc:	08 f4       	brcc	.+2      	; 0x106d0 <__cmpsf2+0x6>
   106ce:	81 e0       	ldi	r24, 0x01	; 1
   106d0:	08 95       	ret

000106d2 <__divsf3>:
   106d2:	0c d0       	rcall	.+24     	; 0x106ec <__divsf3x>
   106d4:	4b c1       	rjmp	.+662    	; 0x1096c <__fp_round>
   106d6:	43 d1       	rcall	.+646    	; 0x1095e <__fp_pscB>
   106d8:	40 f0       	brcs	.+16     	; 0x106ea <__divsf3+0x18>
   106da:	3a d1       	rcall	.+628    	; 0x10950 <__fp_pscA>
   106dc:	30 f0       	brcs	.+12     	; 0x106ea <__divsf3+0x18>
   106de:	21 f4       	brne	.+8      	; 0x106e8 <__divsf3+0x16>
   106e0:	5f 3f       	cpi	r21, 0xFF	; 255
   106e2:	19 f0       	breq	.+6      	; 0x106ea <__divsf3+0x18>
   106e4:	03 c1       	rjmp	.+518    	; 0x108ec <__fp_inf>
   106e6:	51 11       	cpse	r21, r1
   106e8:	8c c1       	rjmp	.+792    	; 0x10a02 <__fp_szero>
   106ea:	2f c1       	rjmp	.+606    	; 0x1094a <__fp_nan>

000106ec <__divsf3x>:
   106ec:	50 d1       	rcall	.+672    	; 0x1098e <__fp_split3>
   106ee:	98 f3       	brcs	.-26     	; 0x106d6 <__divsf3+0x4>

000106f0 <__divsf3_pse>:
   106f0:	99 23       	and	r25, r25
   106f2:	c9 f3       	breq	.-14     	; 0x106e6 <__divsf3+0x14>
   106f4:	55 23       	and	r21, r21
   106f6:	b1 f3       	breq	.-20     	; 0x106e4 <__divsf3+0x12>
   106f8:	95 1b       	sub	r25, r21
   106fa:	55 0b       	sbc	r21, r21
   106fc:	bb 27       	eor	r27, r27
   106fe:	aa 27       	eor	r26, r26
   10700:	62 17       	cp	r22, r18
   10702:	73 07       	cpc	r23, r19
   10704:	84 07       	cpc	r24, r20
   10706:	38 f0       	brcs	.+14     	; 0x10716 <__divsf3_pse+0x26>
   10708:	9f 5f       	subi	r25, 0xFF	; 255
   1070a:	5f 4f       	sbci	r21, 0xFF	; 255
   1070c:	22 0f       	add	r18, r18
   1070e:	33 1f       	adc	r19, r19
   10710:	44 1f       	adc	r20, r20
   10712:	aa 1f       	adc	r26, r26
   10714:	a9 f3       	breq	.-22     	; 0x10700 <__divsf3_pse+0x10>
   10716:	33 d0       	rcall	.+102    	; 0x1077e <__divsf3_pse+0x8e>
   10718:	0e 2e       	mov	r0, r30
   1071a:	3a f0       	brmi	.+14     	; 0x1072a <__divsf3_pse+0x3a>
   1071c:	e0 e8       	ldi	r30, 0x80	; 128
   1071e:	30 d0       	rcall	.+96     	; 0x10780 <__divsf3_pse+0x90>
   10720:	91 50       	subi	r25, 0x01	; 1
   10722:	50 40       	sbci	r21, 0x00	; 0
   10724:	e6 95       	lsr	r30
   10726:	00 1c       	adc	r0, r0
   10728:	ca f7       	brpl	.-14     	; 0x1071c <__divsf3_pse+0x2c>
   1072a:	29 d0       	rcall	.+82     	; 0x1077e <__divsf3_pse+0x8e>
   1072c:	fe 2f       	mov	r31, r30
   1072e:	27 d0       	rcall	.+78     	; 0x1077e <__divsf3_pse+0x8e>
   10730:	66 0f       	add	r22, r22
   10732:	77 1f       	adc	r23, r23
   10734:	88 1f       	adc	r24, r24
   10736:	bb 1f       	adc	r27, r27
   10738:	26 17       	cp	r18, r22
   1073a:	37 07       	cpc	r19, r23
   1073c:	48 07       	cpc	r20, r24
   1073e:	ab 07       	cpc	r26, r27
   10740:	b0 e8       	ldi	r27, 0x80	; 128
   10742:	09 f0       	breq	.+2      	; 0x10746 <__divsf3_pse+0x56>
   10744:	bb 0b       	sbc	r27, r27
   10746:	80 2d       	mov	r24, r0
   10748:	bf 01       	movw	r22, r30
   1074a:	ff 27       	eor	r31, r31
   1074c:	93 58       	subi	r25, 0x83	; 131
   1074e:	5f 4f       	sbci	r21, 0xFF	; 255
   10750:	2a f0       	brmi	.+10     	; 0x1075c <__divsf3_pse+0x6c>
   10752:	9e 3f       	cpi	r25, 0xFE	; 254
   10754:	51 05       	cpc	r21, r1
   10756:	68 f0       	brcs	.+26     	; 0x10772 <__divsf3_pse+0x82>
   10758:	c9 c0       	rjmp	.+402    	; 0x108ec <__fp_inf>
   1075a:	53 c1       	rjmp	.+678    	; 0x10a02 <__fp_szero>
   1075c:	5f 3f       	cpi	r21, 0xFF	; 255
   1075e:	ec f3       	brlt	.-6      	; 0x1075a <__divsf3_pse+0x6a>
   10760:	98 3e       	cpi	r25, 0xE8	; 232
   10762:	dc f3       	brlt	.-10     	; 0x1075a <__divsf3_pse+0x6a>
   10764:	86 95       	lsr	r24
   10766:	77 95       	ror	r23
   10768:	67 95       	ror	r22
   1076a:	b7 95       	ror	r27
   1076c:	f7 95       	ror	r31
   1076e:	9f 5f       	subi	r25, 0xFF	; 255
   10770:	c9 f7       	brne	.-14     	; 0x10764 <__divsf3_pse+0x74>
   10772:	88 0f       	add	r24, r24
   10774:	91 1d       	adc	r25, r1
   10776:	96 95       	lsr	r25
   10778:	87 95       	ror	r24
   1077a:	97 f9       	bld	r25, 7
   1077c:	08 95       	ret
   1077e:	e1 e0       	ldi	r30, 0x01	; 1
   10780:	66 0f       	add	r22, r22
   10782:	77 1f       	adc	r23, r23
   10784:	88 1f       	adc	r24, r24
   10786:	bb 1f       	adc	r27, r27
   10788:	62 17       	cp	r22, r18
   1078a:	73 07       	cpc	r23, r19
   1078c:	84 07       	cpc	r24, r20
   1078e:	ba 07       	cpc	r27, r26
   10790:	20 f0       	brcs	.+8      	; 0x1079a <__divsf3_pse+0xaa>
   10792:	62 1b       	sub	r22, r18
   10794:	73 0b       	sbc	r23, r19
   10796:	84 0b       	sbc	r24, r20
   10798:	ba 0b       	sbc	r27, r26
   1079a:	ee 1f       	adc	r30, r30
   1079c:	88 f7       	brcc	.-30     	; 0x10780 <__divsf3_pse+0x90>
   1079e:	e0 95       	com	r30
   107a0:	08 95       	ret

000107a2 <__fixsfsi>:
   107a2:	04 d0       	rcall	.+8      	; 0x107ac <__fixunssfsi>
   107a4:	68 94       	set
   107a6:	b1 11       	cpse	r27, r1
   107a8:	2c c1       	rjmp	.+600    	; 0x10a02 <__fp_szero>
   107aa:	08 95       	ret

000107ac <__fixunssfsi>:
   107ac:	f8 d0       	rcall	.+496    	; 0x1099e <__fp_splitA>
   107ae:	88 f0       	brcs	.+34     	; 0x107d2 <__fixunssfsi+0x26>
   107b0:	9f 57       	subi	r25, 0x7F	; 127
   107b2:	90 f0       	brcs	.+36     	; 0x107d8 <__fixunssfsi+0x2c>
   107b4:	b9 2f       	mov	r27, r25
   107b6:	99 27       	eor	r25, r25
   107b8:	b7 51       	subi	r27, 0x17	; 23
   107ba:	a0 f0       	brcs	.+40     	; 0x107e4 <__fixunssfsi+0x38>
   107bc:	d1 f0       	breq	.+52     	; 0x107f2 <__fixunssfsi+0x46>
   107be:	66 0f       	add	r22, r22
   107c0:	77 1f       	adc	r23, r23
   107c2:	88 1f       	adc	r24, r24
   107c4:	99 1f       	adc	r25, r25
   107c6:	1a f0       	brmi	.+6      	; 0x107ce <__fixunssfsi+0x22>
   107c8:	ba 95       	dec	r27
   107ca:	c9 f7       	brne	.-14     	; 0x107be <__fixunssfsi+0x12>
   107cc:	12 c0       	rjmp	.+36     	; 0x107f2 <__fixunssfsi+0x46>
   107ce:	b1 30       	cpi	r27, 0x01	; 1
   107d0:	81 f0       	breq	.+32     	; 0x107f2 <__fixunssfsi+0x46>
   107d2:	16 d1       	rcall	.+556    	; 0x10a00 <__fp_zero>
   107d4:	b1 e0       	ldi	r27, 0x01	; 1
   107d6:	08 95       	ret
   107d8:	13 c1       	rjmp	.+550    	; 0x10a00 <__fp_zero>
   107da:	67 2f       	mov	r22, r23
   107dc:	78 2f       	mov	r23, r24
   107de:	88 27       	eor	r24, r24
   107e0:	b8 5f       	subi	r27, 0xF8	; 248
   107e2:	39 f0       	breq	.+14     	; 0x107f2 <__fixunssfsi+0x46>
   107e4:	b9 3f       	cpi	r27, 0xF9	; 249
   107e6:	cc f3       	brlt	.-14     	; 0x107da <__fixunssfsi+0x2e>
   107e8:	86 95       	lsr	r24
   107ea:	77 95       	ror	r23
   107ec:	67 95       	ror	r22
   107ee:	b3 95       	inc	r27
   107f0:	d9 f7       	brne	.-10     	; 0x107e8 <__fixunssfsi+0x3c>
   107f2:	3e f4       	brtc	.+14     	; 0x10802 <__fixunssfsi+0x56>
   107f4:	90 95       	com	r25
   107f6:	80 95       	com	r24
   107f8:	70 95       	com	r23
   107fa:	61 95       	neg	r22
   107fc:	7f 4f       	sbci	r23, 0xFF	; 255
   107fe:	8f 4f       	sbci	r24, 0xFF	; 255
   10800:	9f 4f       	sbci	r25, 0xFF	; 255
   10802:	08 95       	ret

00010804 <__floatunsisf>:
   10804:	e8 94       	clt
   10806:	09 c0       	rjmp	.+18     	; 0x1081a <__floatsisf+0x12>

00010808 <__floatsisf>:
   10808:	97 fb       	bst	r25, 7
   1080a:	3e f4       	brtc	.+14     	; 0x1081a <__floatsisf+0x12>
   1080c:	90 95       	com	r25
   1080e:	80 95       	com	r24
   10810:	70 95       	com	r23
   10812:	61 95       	neg	r22
   10814:	7f 4f       	sbci	r23, 0xFF	; 255
   10816:	8f 4f       	sbci	r24, 0xFF	; 255
   10818:	9f 4f       	sbci	r25, 0xFF	; 255
   1081a:	99 23       	and	r25, r25
   1081c:	a9 f0       	breq	.+42     	; 0x10848 <__floatsisf+0x40>
   1081e:	f9 2f       	mov	r31, r25
   10820:	96 e9       	ldi	r25, 0x96	; 150
   10822:	bb 27       	eor	r27, r27
   10824:	93 95       	inc	r25
   10826:	f6 95       	lsr	r31
   10828:	87 95       	ror	r24
   1082a:	77 95       	ror	r23
   1082c:	67 95       	ror	r22
   1082e:	b7 95       	ror	r27
   10830:	f1 11       	cpse	r31, r1
   10832:	f8 cf       	rjmp	.-16     	; 0x10824 <__floatsisf+0x1c>
   10834:	fa f4       	brpl	.+62     	; 0x10874 <__floatsisf+0x6c>
   10836:	bb 0f       	add	r27, r27
   10838:	11 f4       	brne	.+4      	; 0x1083e <__floatsisf+0x36>
   1083a:	60 ff       	sbrs	r22, 0
   1083c:	1b c0       	rjmp	.+54     	; 0x10874 <__floatsisf+0x6c>
   1083e:	6f 5f       	subi	r22, 0xFF	; 255
   10840:	7f 4f       	sbci	r23, 0xFF	; 255
   10842:	8f 4f       	sbci	r24, 0xFF	; 255
   10844:	9f 4f       	sbci	r25, 0xFF	; 255
   10846:	16 c0       	rjmp	.+44     	; 0x10874 <__floatsisf+0x6c>
   10848:	88 23       	and	r24, r24
   1084a:	11 f0       	breq	.+4      	; 0x10850 <__floatsisf+0x48>
   1084c:	96 e9       	ldi	r25, 0x96	; 150
   1084e:	11 c0       	rjmp	.+34     	; 0x10872 <__floatsisf+0x6a>
   10850:	77 23       	and	r23, r23
   10852:	21 f0       	breq	.+8      	; 0x1085c <__floatsisf+0x54>
   10854:	9e e8       	ldi	r25, 0x8E	; 142
   10856:	87 2f       	mov	r24, r23
   10858:	76 2f       	mov	r23, r22
   1085a:	05 c0       	rjmp	.+10     	; 0x10866 <__floatsisf+0x5e>
   1085c:	66 23       	and	r22, r22
   1085e:	71 f0       	breq	.+28     	; 0x1087c <__floatsisf+0x74>
   10860:	96 e8       	ldi	r25, 0x86	; 134
   10862:	86 2f       	mov	r24, r22
   10864:	70 e0       	ldi	r23, 0x00	; 0
   10866:	60 e0       	ldi	r22, 0x00	; 0
   10868:	2a f0       	brmi	.+10     	; 0x10874 <__floatsisf+0x6c>
   1086a:	9a 95       	dec	r25
   1086c:	66 0f       	add	r22, r22
   1086e:	77 1f       	adc	r23, r23
   10870:	88 1f       	adc	r24, r24
   10872:	da f7       	brpl	.-10     	; 0x1086a <__floatsisf+0x62>
   10874:	88 0f       	add	r24, r24
   10876:	96 95       	lsr	r25
   10878:	87 95       	ror	r24
   1087a:	97 f9       	bld	r25, 7
   1087c:	08 95       	ret

0001087e <floor>:
   1087e:	a9 d0       	rcall	.+338    	; 0x109d2 <__fp_trunc>
   10880:	80 f0       	brcs	.+32     	; 0x108a2 <floor+0x24>
   10882:	9f 37       	cpi	r25, 0x7F	; 127
   10884:	40 f4       	brcc	.+16     	; 0x10896 <floor+0x18>
   10886:	91 11       	cpse	r25, r1
   10888:	0e f0       	brts	.+2      	; 0x1088c <floor+0xe>
   1088a:	bb c0       	rjmp	.+374    	; 0x10a02 <__fp_szero>
   1088c:	60 e0       	ldi	r22, 0x00	; 0
   1088e:	70 e0       	ldi	r23, 0x00	; 0
   10890:	80 e8       	ldi	r24, 0x80	; 128
   10892:	9f eb       	ldi	r25, 0xBF	; 191
   10894:	08 95       	ret
   10896:	26 f4       	brtc	.+8      	; 0x108a0 <floor+0x22>
   10898:	1b 16       	cp	r1, r27
   1089a:	61 1d       	adc	r22, r1
   1089c:	71 1d       	adc	r23, r1
   1089e:	81 1d       	adc	r24, r1
   108a0:	2b c0       	rjmp	.+86     	; 0x108f8 <__fp_mintl>
   108a2:	45 c0       	rjmp	.+138    	; 0x1092e <__fp_mpack>

000108a4 <__fp_cmp>:
   108a4:	99 0f       	add	r25, r25
   108a6:	00 08       	sbc	r0, r0
   108a8:	55 0f       	add	r21, r21
   108aa:	aa 0b       	sbc	r26, r26
   108ac:	e0 e8       	ldi	r30, 0x80	; 128
   108ae:	fe ef       	ldi	r31, 0xFE	; 254
   108b0:	16 16       	cp	r1, r22
   108b2:	17 06       	cpc	r1, r23
   108b4:	e8 07       	cpc	r30, r24
   108b6:	f9 07       	cpc	r31, r25
   108b8:	c0 f0       	brcs	.+48     	; 0x108ea <__fp_cmp+0x46>
   108ba:	12 16       	cp	r1, r18
   108bc:	13 06       	cpc	r1, r19
   108be:	e4 07       	cpc	r30, r20
   108c0:	f5 07       	cpc	r31, r21
   108c2:	98 f0       	brcs	.+38     	; 0x108ea <__fp_cmp+0x46>
   108c4:	62 1b       	sub	r22, r18
   108c6:	73 0b       	sbc	r23, r19
   108c8:	84 0b       	sbc	r24, r20
   108ca:	95 0b       	sbc	r25, r21
   108cc:	39 f4       	brne	.+14     	; 0x108dc <__fp_cmp+0x38>
   108ce:	0a 26       	eor	r0, r26
   108d0:	61 f0       	breq	.+24     	; 0x108ea <__fp_cmp+0x46>
   108d2:	23 2b       	or	r18, r19
   108d4:	24 2b       	or	r18, r20
   108d6:	25 2b       	or	r18, r21
   108d8:	21 f4       	brne	.+8      	; 0x108e2 <__fp_cmp+0x3e>
   108da:	08 95       	ret
   108dc:	0a 26       	eor	r0, r26
   108de:	09 f4       	brne	.+2      	; 0x108e2 <__fp_cmp+0x3e>
   108e0:	a1 40       	sbci	r26, 0x01	; 1
   108e2:	a6 95       	lsr	r26
   108e4:	8f ef       	ldi	r24, 0xFF	; 255
   108e6:	81 1d       	adc	r24, r1
   108e8:	81 1d       	adc	r24, r1
   108ea:	08 95       	ret

000108ec <__fp_inf>:
   108ec:	97 f9       	bld	r25, 7
   108ee:	9f 67       	ori	r25, 0x7F	; 127
   108f0:	80 e8       	ldi	r24, 0x80	; 128
   108f2:	70 e0       	ldi	r23, 0x00	; 0
   108f4:	60 e0       	ldi	r22, 0x00	; 0
   108f6:	08 95       	ret

000108f8 <__fp_mintl>:
   108f8:	88 23       	and	r24, r24
   108fa:	71 f4       	brne	.+28     	; 0x10918 <__fp_mintl+0x20>
   108fc:	77 23       	and	r23, r23
   108fe:	21 f0       	breq	.+8      	; 0x10908 <__fp_mintl+0x10>
   10900:	98 50       	subi	r25, 0x08	; 8
   10902:	87 2b       	or	r24, r23
   10904:	76 2f       	mov	r23, r22
   10906:	07 c0       	rjmp	.+14     	; 0x10916 <__fp_mintl+0x1e>
   10908:	66 23       	and	r22, r22
   1090a:	11 f4       	brne	.+4      	; 0x10910 <__fp_mintl+0x18>
   1090c:	99 27       	eor	r25, r25
   1090e:	0d c0       	rjmp	.+26     	; 0x1092a <__fp_mintl+0x32>
   10910:	90 51       	subi	r25, 0x10	; 16
   10912:	86 2b       	or	r24, r22
   10914:	70 e0       	ldi	r23, 0x00	; 0
   10916:	60 e0       	ldi	r22, 0x00	; 0
   10918:	2a f0       	brmi	.+10     	; 0x10924 <__fp_mintl+0x2c>
   1091a:	9a 95       	dec	r25
   1091c:	66 0f       	add	r22, r22
   1091e:	77 1f       	adc	r23, r23
   10920:	88 1f       	adc	r24, r24
   10922:	da f7       	brpl	.-10     	; 0x1091a <__fp_mintl+0x22>
   10924:	88 0f       	add	r24, r24
   10926:	96 95       	lsr	r25
   10928:	87 95       	ror	r24
   1092a:	97 f9       	bld	r25, 7
   1092c:	08 95       	ret

0001092e <__fp_mpack>:
   1092e:	9f 3f       	cpi	r25, 0xFF	; 255
   10930:	31 f0       	breq	.+12     	; 0x1093e <__fp_mpack_finite+0xc>

00010932 <__fp_mpack_finite>:
   10932:	91 50       	subi	r25, 0x01	; 1
   10934:	20 f4       	brcc	.+8      	; 0x1093e <__fp_mpack_finite+0xc>
   10936:	87 95       	ror	r24
   10938:	77 95       	ror	r23
   1093a:	67 95       	ror	r22
   1093c:	b7 95       	ror	r27
   1093e:	88 0f       	add	r24, r24
   10940:	91 1d       	adc	r25, r1
   10942:	96 95       	lsr	r25
   10944:	87 95       	ror	r24
   10946:	97 f9       	bld	r25, 7
   10948:	08 95       	ret

0001094a <__fp_nan>:
   1094a:	9f ef       	ldi	r25, 0xFF	; 255
   1094c:	80 ec       	ldi	r24, 0xC0	; 192
   1094e:	08 95       	ret

00010950 <__fp_pscA>:
   10950:	00 24       	eor	r0, r0
   10952:	0a 94       	dec	r0
   10954:	16 16       	cp	r1, r22
   10956:	17 06       	cpc	r1, r23
   10958:	18 06       	cpc	r1, r24
   1095a:	09 06       	cpc	r0, r25
   1095c:	08 95       	ret

0001095e <__fp_pscB>:
   1095e:	00 24       	eor	r0, r0
   10960:	0a 94       	dec	r0
   10962:	12 16       	cp	r1, r18
   10964:	13 06       	cpc	r1, r19
   10966:	14 06       	cpc	r1, r20
   10968:	05 06       	cpc	r0, r21
   1096a:	08 95       	ret

0001096c <__fp_round>:
   1096c:	09 2e       	mov	r0, r25
   1096e:	03 94       	inc	r0
   10970:	00 0c       	add	r0, r0
   10972:	11 f4       	brne	.+4      	; 0x10978 <__fp_round+0xc>
   10974:	88 23       	and	r24, r24
   10976:	52 f0       	brmi	.+20     	; 0x1098c <__fp_round+0x20>
   10978:	bb 0f       	add	r27, r27
   1097a:	40 f4       	brcc	.+16     	; 0x1098c <__fp_round+0x20>
   1097c:	bf 2b       	or	r27, r31
   1097e:	11 f4       	brne	.+4      	; 0x10984 <__fp_round+0x18>
   10980:	60 ff       	sbrs	r22, 0
   10982:	04 c0       	rjmp	.+8      	; 0x1098c <__fp_round+0x20>
   10984:	6f 5f       	subi	r22, 0xFF	; 255
   10986:	7f 4f       	sbci	r23, 0xFF	; 255
   10988:	8f 4f       	sbci	r24, 0xFF	; 255
   1098a:	9f 4f       	sbci	r25, 0xFF	; 255
   1098c:	08 95       	ret

0001098e <__fp_split3>:
   1098e:	57 fd       	sbrc	r21, 7
   10990:	90 58       	subi	r25, 0x80	; 128
   10992:	44 0f       	add	r20, r20
   10994:	55 1f       	adc	r21, r21
   10996:	59 f0       	breq	.+22     	; 0x109ae <__fp_splitA+0x10>
   10998:	5f 3f       	cpi	r21, 0xFF	; 255
   1099a:	71 f0       	breq	.+28     	; 0x109b8 <__fp_splitA+0x1a>
   1099c:	47 95       	ror	r20

0001099e <__fp_splitA>:
   1099e:	88 0f       	add	r24, r24
   109a0:	97 fb       	bst	r25, 7
   109a2:	99 1f       	adc	r25, r25
   109a4:	61 f0       	breq	.+24     	; 0x109be <__fp_splitA+0x20>
   109a6:	9f 3f       	cpi	r25, 0xFF	; 255
   109a8:	79 f0       	breq	.+30     	; 0x109c8 <__fp_splitA+0x2a>
   109aa:	87 95       	ror	r24
   109ac:	08 95       	ret
   109ae:	12 16       	cp	r1, r18
   109b0:	13 06       	cpc	r1, r19
   109b2:	14 06       	cpc	r1, r20
   109b4:	55 1f       	adc	r21, r21
   109b6:	f2 cf       	rjmp	.-28     	; 0x1099c <__fp_split3+0xe>
   109b8:	46 95       	lsr	r20
   109ba:	f1 df       	rcall	.-30     	; 0x1099e <__fp_splitA>
   109bc:	08 c0       	rjmp	.+16     	; 0x109ce <__fp_splitA+0x30>
   109be:	16 16       	cp	r1, r22
   109c0:	17 06       	cpc	r1, r23
   109c2:	18 06       	cpc	r1, r24
   109c4:	99 1f       	adc	r25, r25
   109c6:	f1 cf       	rjmp	.-30     	; 0x109aa <__fp_splitA+0xc>
   109c8:	86 95       	lsr	r24
   109ca:	71 05       	cpc	r23, r1
   109cc:	61 05       	cpc	r22, r1
   109ce:	08 94       	sec
   109d0:	08 95       	ret

000109d2 <__fp_trunc>:
   109d2:	e5 df       	rcall	.-54     	; 0x1099e <__fp_splitA>
   109d4:	a0 f0       	brcs	.+40     	; 0x109fe <__fp_trunc+0x2c>
   109d6:	be e7       	ldi	r27, 0x7E	; 126
   109d8:	b9 17       	cp	r27, r25
   109da:	88 f4       	brcc	.+34     	; 0x109fe <__fp_trunc+0x2c>
   109dc:	bb 27       	eor	r27, r27
   109de:	9f 38       	cpi	r25, 0x8F	; 143
   109e0:	60 f4       	brcc	.+24     	; 0x109fa <__fp_trunc+0x28>
   109e2:	16 16       	cp	r1, r22
   109e4:	b1 1d       	adc	r27, r1
   109e6:	67 2f       	mov	r22, r23
   109e8:	78 2f       	mov	r23, r24
   109ea:	88 27       	eor	r24, r24
   109ec:	98 5f       	subi	r25, 0xF8	; 248
   109ee:	f7 cf       	rjmp	.-18     	; 0x109de <__fp_trunc+0xc>
   109f0:	86 95       	lsr	r24
   109f2:	77 95       	ror	r23
   109f4:	67 95       	ror	r22
   109f6:	b1 1d       	adc	r27, r1
   109f8:	93 95       	inc	r25
   109fa:	96 39       	cpi	r25, 0x96	; 150
   109fc:	c8 f3       	brcs	.-14     	; 0x109f0 <__fp_trunc+0x1e>
   109fe:	08 95       	ret

00010a00 <__fp_zero>:
   10a00:	e8 94       	clt

00010a02 <__fp_szero>:
   10a02:	bb 27       	eor	r27, r27
   10a04:	66 27       	eor	r22, r22
   10a06:	77 27       	eor	r23, r23
   10a08:	cb 01       	movw	r24, r22
   10a0a:	97 f9       	bld	r25, 7
   10a0c:	08 95       	ret

00010a0e <__gesf2>:
   10a0e:	4a df       	rcall	.-364    	; 0x108a4 <__fp_cmp>
   10a10:	08 f4       	brcc	.+2      	; 0x10a14 <__gesf2+0x6>
   10a12:	8f ef       	ldi	r24, 0xFF	; 255
   10a14:	08 95       	ret

00010a16 <__mulsf3>:
   10a16:	0b d0       	rcall	.+22     	; 0x10a2e <__mulsf3x>
   10a18:	a9 cf       	rjmp	.-174    	; 0x1096c <__fp_round>
   10a1a:	9a df       	rcall	.-204    	; 0x10950 <__fp_pscA>
   10a1c:	28 f0       	brcs	.+10     	; 0x10a28 <__mulsf3+0x12>
   10a1e:	9f df       	rcall	.-194    	; 0x1095e <__fp_pscB>
   10a20:	18 f0       	brcs	.+6      	; 0x10a28 <__mulsf3+0x12>
   10a22:	95 23       	and	r25, r21
   10a24:	09 f0       	breq	.+2      	; 0x10a28 <__mulsf3+0x12>
   10a26:	62 cf       	rjmp	.-316    	; 0x108ec <__fp_inf>
   10a28:	90 cf       	rjmp	.-224    	; 0x1094a <__fp_nan>
   10a2a:	11 24       	eor	r1, r1
   10a2c:	ea cf       	rjmp	.-44     	; 0x10a02 <__fp_szero>

00010a2e <__mulsf3x>:
   10a2e:	af df       	rcall	.-162    	; 0x1098e <__fp_split3>
   10a30:	a0 f3       	brcs	.-24     	; 0x10a1a <__mulsf3+0x4>

00010a32 <__mulsf3_pse>:
   10a32:	95 9f       	mul	r25, r21
   10a34:	d1 f3       	breq	.-12     	; 0x10a2a <__mulsf3+0x14>
   10a36:	95 0f       	add	r25, r21
   10a38:	50 e0       	ldi	r21, 0x00	; 0
   10a3a:	55 1f       	adc	r21, r21
   10a3c:	62 9f       	mul	r22, r18
   10a3e:	f0 01       	movw	r30, r0
   10a40:	72 9f       	mul	r23, r18
   10a42:	bb 27       	eor	r27, r27
   10a44:	f0 0d       	add	r31, r0
   10a46:	b1 1d       	adc	r27, r1
   10a48:	63 9f       	mul	r22, r19
   10a4a:	aa 27       	eor	r26, r26
   10a4c:	f0 0d       	add	r31, r0
   10a4e:	b1 1d       	adc	r27, r1
   10a50:	aa 1f       	adc	r26, r26
   10a52:	64 9f       	mul	r22, r20
   10a54:	66 27       	eor	r22, r22
   10a56:	b0 0d       	add	r27, r0
   10a58:	a1 1d       	adc	r26, r1
   10a5a:	66 1f       	adc	r22, r22
   10a5c:	82 9f       	mul	r24, r18
   10a5e:	22 27       	eor	r18, r18
   10a60:	b0 0d       	add	r27, r0
   10a62:	a1 1d       	adc	r26, r1
   10a64:	62 1f       	adc	r22, r18
   10a66:	73 9f       	mul	r23, r19
   10a68:	b0 0d       	add	r27, r0
   10a6a:	a1 1d       	adc	r26, r1
   10a6c:	62 1f       	adc	r22, r18
   10a6e:	83 9f       	mul	r24, r19
   10a70:	a0 0d       	add	r26, r0
   10a72:	61 1d       	adc	r22, r1
   10a74:	22 1f       	adc	r18, r18
   10a76:	74 9f       	mul	r23, r20
   10a78:	33 27       	eor	r19, r19
   10a7a:	a0 0d       	add	r26, r0
   10a7c:	61 1d       	adc	r22, r1
   10a7e:	23 1f       	adc	r18, r19
   10a80:	84 9f       	mul	r24, r20
   10a82:	60 0d       	add	r22, r0
   10a84:	21 1d       	adc	r18, r1
   10a86:	82 2f       	mov	r24, r18
   10a88:	76 2f       	mov	r23, r22
   10a8a:	6a 2f       	mov	r22, r26
   10a8c:	11 24       	eor	r1, r1
   10a8e:	9f 57       	subi	r25, 0x7F	; 127
   10a90:	50 40       	sbci	r21, 0x00	; 0
   10a92:	8a f0       	brmi	.+34     	; 0x10ab6 <__mulsf3_pse+0x84>
   10a94:	e1 f0       	breq	.+56     	; 0x10ace <__mulsf3_pse+0x9c>
   10a96:	88 23       	and	r24, r24
   10a98:	4a f0       	brmi	.+18     	; 0x10aac <__mulsf3_pse+0x7a>
   10a9a:	ee 0f       	add	r30, r30
   10a9c:	ff 1f       	adc	r31, r31
   10a9e:	bb 1f       	adc	r27, r27
   10aa0:	66 1f       	adc	r22, r22
   10aa2:	77 1f       	adc	r23, r23
   10aa4:	88 1f       	adc	r24, r24
   10aa6:	91 50       	subi	r25, 0x01	; 1
   10aa8:	50 40       	sbci	r21, 0x00	; 0
   10aaa:	a9 f7       	brne	.-22     	; 0x10a96 <__mulsf3_pse+0x64>
   10aac:	9e 3f       	cpi	r25, 0xFE	; 254
   10aae:	51 05       	cpc	r21, r1
   10ab0:	70 f0       	brcs	.+28     	; 0x10ace <__mulsf3_pse+0x9c>
   10ab2:	1c cf       	rjmp	.-456    	; 0x108ec <__fp_inf>
   10ab4:	a6 cf       	rjmp	.-180    	; 0x10a02 <__fp_szero>
   10ab6:	5f 3f       	cpi	r21, 0xFF	; 255
   10ab8:	ec f3       	brlt	.-6      	; 0x10ab4 <__mulsf3_pse+0x82>
   10aba:	98 3e       	cpi	r25, 0xE8	; 232
   10abc:	dc f3       	brlt	.-10     	; 0x10ab4 <__mulsf3_pse+0x82>
   10abe:	86 95       	lsr	r24
   10ac0:	77 95       	ror	r23
   10ac2:	67 95       	ror	r22
   10ac4:	b7 95       	ror	r27
   10ac6:	f7 95       	ror	r31
   10ac8:	e7 95       	ror	r30
   10aca:	9f 5f       	subi	r25, 0xFF	; 255
   10acc:	c1 f7       	brne	.-16     	; 0x10abe <__mulsf3_pse+0x8c>
   10ace:	fe 2b       	or	r31, r30
   10ad0:	88 0f       	add	r24, r24
   10ad2:	91 1d       	adc	r25, r1
   10ad4:	96 95       	lsr	r25
   10ad6:	87 95       	ror	r24
   10ad8:	97 f9       	bld	r25, 7
   10ada:	08 95       	ret

00010adc <__mulsi3>:
   10adc:	62 9f       	mul	r22, r18
   10ade:	d0 01       	movw	r26, r0
   10ae0:	73 9f       	mul	r23, r19
   10ae2:	f0 01       	movw	r30, r0
   10ae4:	82 9f       	mul	r24, r18
   10ae6:	e0 0d       	add	r30, r0
   10ae8:	f1 1d       	adc	r31, r1
   10aea:	64 9f       	mul	r22, r20
   10aec:	e0 0d       	add	r30, r0
   10aee:	f1 1d       	adc	r31, r1
   10af0:	92 9f       	mul	r25, r18
   10af2:	f0 0d       	add	r31, r0
   10af4:	83 9f       	mul	r24, r19
   10af6:	f0 0d       	add	r31, r0
   10af8:	74 9f       	mul	r23, r20
   10afa:	f0 0d       	add	r31, r0
   10afc:	65 9f       	mul	r22, r21
   10afe:	f0 0d       	add	r31, r0
   10b00:	99 27       	eor	r25, r25
   10b02:	72 9f       	mul	r23, r18
   10b04:	b0 0d       	add	r27, r0
   10b06:	e1 1d       	adc	r30, r1
   10b08:	f9 1f       	adc	r31, r25
   10b0a:	63 9f       	mul	r22, r19
   10b0c:	b0 0d       	add	r27, r0
   10b0e:	e1 1d       	adc	r30, r1
   10b10:	f9 1f       	adc	r31, r25
   10b12:	bd 01       	movw	r22, r26
   10b14:	cf 01       	movw	r24, r30
   10b16:	11 24       	eor	r1, r1
   10b18:	08 95       	ret

00010b1a <__udivmodqi4>:
   10b1a:	99 1b       	sub	r25, r25
   10b1c:	79 e0       	ldi	r23, 0x09	; 9
   10b1e:	04 c0       	rjmp	.+8      	; 0x10b28 <__udivmodqi4_ep>

00010b20 <__udivmodqi4_loop>:
   10b20:	99 1f       	adc	r25, r25
   10b22:	96 17       	cp	r25, r22
   10b24:	08 f0       	brcs	.+2      	; 0x10b28 <__udivmodqi4_ep>
   10b26:	96 1b       	sub	r25, r22

00010b28 <__udivmodqi4_ep>:
   10b28:	88 1f       	adc	r24, r24
   10b2a:	7a 95       	dec	r23
   10b2c:	c9 f7       	brne	.-14     	; 0x10b20 <__udivmodqi4_loop>
   10b2e:	80 95       	com	r24
   10b30:	08 95       	ret

00010b32 <__divmodhi4>:
   10b32:	97 fb       	bst	r25, 7
   10b34:	09 2e       	mov	r0, r25
   10b36:	07 26       	eor	r0, r23
   10b38:	0a d0       	rcall	.+20     	; 0x10b4e <__divmodhi4_neg1>
   10b3a:	77 fd       	sbrc	r23, 7
   10b3c:	04 d0       	rcall	.+8      	; 0x10b46 <__divmodhi4_neg2>
   10b3e:	27 d0       	rcall	.+78     	; 0x10b8e <__udivmodhi4>
   10b40:	06 d0       	rcall	.+12     	; 0x10b4e <__divmodhi4_neg1>
   10b42:	00 20       	and	r0, r0
   10b44:	1a f4       	brpl	.+6      	; 0x10b4c <__divmodhi4_exit>

00010b46 <__divmodhi4_neg2>:
   10b46:	70 95       	com	r23
   10b48:	61 95       	neg	r22
   10b4a:	7f 4f       	sbci	r23, 0xFF	; 255

00010b4c <__divmodhi4_exit>:
   10b4c:	08 95       	ret

00010b4e <__divmodhi4_neg1>:
   10b4e:	f6 f7       	brtc	.-4      	; 0x10b4c <__divmodhi4_exit>
   10b50:	90 95       	com	r25
   10b52:	81 95       	neg	r24
   10b54:	9f 4f       	sbci	r25, 0xFF	; 255
   10b56:	08 95       	ret

00010b58 <__divmodsi4>:
   10b58:	97 fb       	bst	r25, 7
   10b5a:	09 2e       	mov	r0, r25
   10b5c:	05 26       	eor	r0, r21
   10b5e:	0e d0       	rcall	.+28     	; 0x10b7c <__divmodsi4_neg1>
   10b60:	57 fd       	sbrc	r21, 7
   10b62:	04 d0       	rcall	.+8      	; 0x10b6c <__divmodsi4_neg2>
   10b64:	28 d0       	rcall	.+80     	; 0x10bb6 <__udivmodsi4>
   10b66:	0a d0       	rcall	.+20     	; 0x10b7c <__divmodsi4_neg1>
   10b68:	00 1c       	adc	r0, r0
   10b6a:	38 f4       	brcc	.+14     	; 0x10b7a <__divmodsi4_exit>

00010b6c <__divmodsi4_neg2>:
   10b6c:	50 95       	com	r21
   10b6e:	40 95       	com	r20
   10b70:	30 95       	com	r19
   10b72:	21 95       	neg	r18
   10b74:	3f 4f       	sbci	r19, 0xFF	; 255
   10b76:	4f 4f       	sbci	r20, 0xFF	; 255
   10b78:	5f 4f       	sbci	r21, 0xFF	; 255

00010b7a <__divmodsi4_exit>:
   10b7a:	08 95       	ret

00010b7c <__divmodsi4_neg1>:
   10b7c:	f6 f7       	brtc	.-4      	; 0x10b7a <__divmodsi4_exit>
   10b7e:	90 95       	com	r25
   10b80:	80 95       	com	r24
   10b82:	70 95       	com	r23
   10b84:	61 95       	neg	r22
   10b86:	7f 4f       	sbci	r23, 0xFF	; 255
   10b88:	8f 4f       	sbci	r24, 0xFF	; 255
   10b8a:	9f 4f       	sbci	r25, 0xFF	; 255
   10b8c:	08 95       	ret

00010b8e <__udivmodhi4>:
   10b8e:	aa 1b       	sub	r26, r26
   10b90:	bb 1b       	sub	r27, r27
   10b92:	51 e1       	ldi	r21, 0x11	; 17
   10b94:	07 c0       	rjmp	.+14     	; 0x10ba4 <__udivmodhi4_ep>

00010b96 <__udivmodhi4_loop>:
   10b96:	aa 1f       	adc	r26, r26
   10b98:	bb 1f       	adc	r27, r27
   10b9a:	a6 17       	cp	r26, r22
   10b9c:	b7 07       	cpc	r27, r23
   10b9e:	10 f0       	brcs	.+4      	; 0x10ba4 <__udivmodhi4_ep>
   10ba0:	a6 1b       	sub	r26, r22
   10ba2:	b7 0b       	sbc	r27, r23

00010ba4 <__udivmodhi4_ep>:
   10ba4:	88 1f       	adc	r24, r24
   10ba6:	99 1f       	adc	r25, r25
   10ba8:	5a 95       	dec	r21
   10baa:	a9 f7       	brne	.-22     	; 0x10b96 <__udivmodhi4_loop>
   10bac:	80 95       	com	r24
   10bae:	90 95       	com	r25
   10bb0:	bc 01       	movw	r22, r24
   10bb2:	cd 01       	movw	r24, r26
   10bb4:	08 95       	ret

00010bb6 <__udivmodsi4>:
   10bb6:	a1 e2       	ldi	r26, 0x21	; 33
   10bb8:	1a 2e       	mov	r1, r26
   10bba:	aa 1b       	sub	r26, r26
   10bbc:	bb 1b       	sub	r27, r27
   10bbe:	fd 01       	movw	r30, r26
   10bc0:	0d c0       	rjmp	.+26     	; 0x10bdc <__udivmodsi4_ep>

00010bc2 <__udivmodsi4_loop>:
   10bc2:	aa 1f       	adc	r26, r26
   10bc4:	bb 1f       	adc	r27, r27
   10bc6:	ee 1f       	adc	r30, r30
   10bc8:	ff 1f       	adc	r31, r31
   10bca:	a2 17       	cp	r26, r18
   10bcc:	b3 07       	cpc	r27, r19
   10bce:	e4 07       	cpc	r30, r20
   10bd0:	f5 07       	cpc	r31, r21
   10bd2:	20 f0       	brcs	.+8      	; 0x10bdc <__udivmodsi4_ep>
   10bd4:	a2 1b       	sub	r26, r18
   10bd6:	b3 0b       	sbc	r27, r19
   10bd8:	e4 0b       	sbc	r30, r20
   10bda:	f5 0b       	sbc	r31, r21

00010bdc <__udivmodsi4_ep>:
   10bdc:	66 1f       	adc	r22, r22
   10bde:	77 1f       	adc	r23, r23
   10be0:	88 1f       	adc	r24, r24
   10be2:	99 1f       	adc	r25, r25
   10be4:	1a 94       	dec	r1
   10be6:	69 f7       	brne	.-38     	; 0x10bc2 <__udivmodsi4_loop>
   10be8:	60 95       	com	r22
   10bea:	70 95       	com	r23
   10bec:	80 95       	com	r24
   10bee:	90 95       	com	r25
   10bf0:	9b 01       	movw	r18, r22
   10bf2:	ac 01       	movw	r20, r24
   10bf4:	bd 01       	movw	r22, r26
   10bf6:	cf 01       	movw	r24, r30
   10bf8:	08 95       	ret

00010bfa <malloc>:
   10bfa:	cf 93       	push	r28
   10bfc:	df 93       	push	r29
   10bfe:	bc 01       	movw	r22, r24
   10c00:	82 30       	cpi	r24, 0x02	; 2
   10c02:	91 05       	cpc	r25, r1
   10c04:	10 f4       	brcc	.+4      	; 0x10c0a <malloc+0x10>
   10c06:	62 e0       	ldi	r22, 0x02	; 2
   10c08:	70 e0       	ldi	r23, 0x00	; 0
   10c0a:	a0 91 2d 82 	lds	r26, 0x822D
   10c0e:	b0 91 2e 82 	lds	r27, 0x822E
   10c12:	ed 01       	movw	r28, r26
   10c14:	e0 e0       	ldi	r30, 0x00	; 0
   10c16:	f0 e0       	ldi	r31, 0x00	; 0
   10c18:	40 e0       	ldi	r20, 0x00	; 0
   10c1a:	50 e0       	ldi	r21, 0x00	; 0
   10c1c:	21 c0       	rjmp	.+66     	; 0x10c60 <malloc+0x66>
   10c1e:	88 81       	ld	r24, Y
   10c20:	99 81       	ldd	r25, Y+1	; 0x01
   10c22:	86 17       	cp	r24, r22
   10c24:	97 07       	cpc	r25, r23
   10c26:	69 f4       	brne	.+26     	; 0x10c42 <malloc+0x48>
   10c28:	8a 81       	ldd	r24, Y+2	; 0x02
   10c2a:	9b 81       	ldd	r25, Y+3	; 0x03
   10c2c:	30 97       	sbiw	r30, 0x00	; 0
   10c2e:	19 f0       	breq	.+6      	; 0x10c36 <malloc+0x3c>
   10c30:	93 83       	std	Z+3, r25	; 0x03
   10c32:	82 83       	std	Z+2, r24	; 0x02
   10c34:	04 c0       	rjmp	.+8      	; 0x10c3e <malloc+0x44>
   10c36:	90 93 2e 82 	sts	0x822E, r25
   10c3a:	80 93 2d 82 	sts	0x822D, r24
   10c3e:	fe 01       	movw	r30, r28
   10c40:	34 c0       	rjmp	.+104    	; 0x10caa <malloc+0xb0>
   10c42:	68 17       	cp	r22, r24
   10c44:	79 07       	cpc	r23, r25
   10c46:	38 f4       	brcc	.+14     	; 0x10c56 <malloc+0x5c>
   10c48:	41 15       	cp	r20, r1
   10c4a:	51 05       	cpc	r21, r1
   10c4c:	19 f0       	breq	.+6      	; 0x10c54 <malloc+0x5a>
   10c4e:	84 17       	cp	r24, r20
   10c50:	95 07       	cpc	r25, r21
   10c52:	08 f4       	brcc	.+2      	; 0x10c56 <malloc+0x5c>
   10c54:	ac 01       	movw	r20, r24
   10c56:	fe 01       	movw	r30, r28
   10c58:	8a 81       	ldd	r24, Y+2	; 0x02
   10c5a:	9b 81       	ldd	r25, Y+3	; 0x03
   10c5c:	9c 01       	movw	r18, r24
   10c5e:	e9 01       	movw	r28, r18
   10c60:	20 97       	sbiw	r28, 0x00	; 0
   10c62:	e9 f6       	brne	.-70     	; 0x10c1e <malloc+0x24>
   10c64:	41 15       	cp	r20, r1
   10c66:	51 05       	cpc	r21, r1
   10c68:	a9 f1       	breq	.+106    	; 0x10cd4 <malloc+0xda>
   10c6a:	ca 01       	movw	r24, r20
   10c6c:	86 1b       	sub	r24, r22
   10c6e:	97 0b       	sbc	r25, r23
   10c70:	04 97       	sbiw	r24, 0x04	; 4
   10c72:	08 f4       	brcc	.+2      	; 0x10c76 <malloc+0x7c>
   10c74:	ba 01       	movw	r22, r20
   10c76:	e0 e0       	ldi	r30, 0x00	; 0
   10c78:	f0 e0       	ldi	r31, 0x00	; 0
   10c7a:	2a c0       	rjmp	.+84     	; 0x10cd0 <malloc+0xd6>
   10c7c:	8d 91       	ld	r24, X+
   10c7e:	9c 91       	ld	r25, X
   10c80:	11 97       	sbiw	r26, 0x01	; 1
   10c82:	84 17       	cp	r24, r20
   10c84:	95 07       	cpc	r25, r21
   10c86:	f9 f4       	brne	.+62     	; 0x10cc6 <malloc+0xcc>
   10c88:	64 17       	cp	r22, r20
   10c8a:	75 07       	cpc	r23, r21
   10c8c:	81 f4       	brne	.+32     	; 0x10cae <malloc+0xb4>
   10c8e:	12 96       	adiw	r26, 0x02	; 2
   10c90:	8d 91       	ld	r24, X+
   10c92:	9c 91       	ld	r25, X
   10c94:	13 97       	sbiw	r26, 0x03	; 3
   10c96:	30 97       	sbiw	r30, 0x00	; 0
   10c98:	19 f0       	breq	.+6      	; 0x10ca0 <malloc+0xa6>
   10c9a:	93 83       	std	Z+3, r25	; 0x03
   10c9c:	82 83       	std	Z+2, r24	; 0x02
   10c9e:	04 c0       	rjmp	.+8      	; 0x10ca8 <malloc+0xae>
   10ca0:	90 93 2e 82 	sts	0x822E, r25
   10ca4:	80 93 2d 82 	sts	0x822D, r24
   10ca8:	fd 01       	movw	r30, r26
   10caa:	32 96       	adiw	r30, 0x02	; 2
   10cac:	4f c0       	rjmp	.+158    	; 0x10d4c <malloc+0x152>
   10cae:	ca 01       	movw	r24, r20
   10cb0:	86 1b       	sub	r24, r22
   10cb2:	97 0b       	sbc	r25, r23
   10cb4:	fd 01       	movw	r30, r26
   10cb6:	e8 0f       	add	r30, r24
   10cb8:	f9 1f       	adc	r31, r25
   10cba:	61 93       	st	Z+, r22
   10cbc:	71 93       	st	Z+, r23
   10cbe:	02 97       	sbiw	r24, 0x02	; 2
   10cc0:	8d 93       	st	X+, r24
   10cc2:	9c 93       	st	X, r25
   10cc4:	43 c0       	rjmp	.+134    	; 0x10d4c <malloc+0x152>
   10cc6:	fd 01       	movw	r30, r26
   10cc8:	82 81       	ldd	r24, Z+2	; 0x02
   10cca:	93 81       	ldd	r25, Z+3	; 0x03
   10ccc:	9c 01       	movw	r18, r24
   10cce:	d9 01       	movw	r26, r18
   10cd0:	10 97       	sbiw	r26, 0x00	; 0
   10cd2:	a1 f6       	brne	.-88     	; 0x10c7c <malloc+0x82>
   10cd4:	80 91 2b 82 	lds	r24, 0x822B
   10cd8:	90 91 2c 82 	lds	r25, 0x822C
   10cdc:	89 2b       	or	r24, r25
   10cde:	41 f4       	brne	.+16     	; 0x10cf0 <malloc+0xf6>
   10ce0:	80 91 8b 7b 	lds	r24, 0x7B8B
   10ce4:	90 91 8c 7b 	lds	r25, 0x7B8C
   10ce8:	90 93 2c 82 	sts	0x822C, r25
   10cec:	80 93 2b 82 	sts	0x822B, r24
   10cf0:	40 91 8d 7b 	lds	r20, 0x7B8D
   10cf4:	50 91 8e 7b 	lds	r21, 0x7B8E
   10cf8:	41 15       	cp	r20, r1
   10cfa:	51 05       	cpc	r21, r1
   10cfc:	41 f4       	brne	.+16     	; 0x10d0e <malloc+0x114>
   10cfe:	4d b7       	in	r20, 0x3d	; 61
   10d00:	5e b7       	in	r21, 0x3e	; 62
   10d02:	80 91 89 7b 	lds	r24, 0x7B89
   10d06:	90 91 8a 7b 	lds	r25, 0x7B8A
   10d0a:	48 1b       	sub	r20, r24
   10d0c:	59 0b       	sbc	r21, r25
   10d0e:	20 91 2b 82 	lds	r18, 0x822B
   10d12:	30 91 2c 82 	lds	r19, 0x822C
   10d16:	24 17       	cp	r18, r20
   10d18:	35 07       	cpc	r19, r21
   10d1a:	b0 f4       	brcc	.+44     	; 0x10d48 <malloc+0x14e>
   10d1c:	ca 01       	movw	r24, r20
   10d1e:	82 1b       	sub	r24, r18
   10d20:	93 0b       	sbc	r25, r19
   10d22:	86 17       	cp	r24, r22
   10d24:	97 07       	cpc	r25, r23
   10d26:	80 f0       	brcs	.+32     	; 0x10d48 <malloc+0x14e>
   10d28:	ab 01       	movw	r20, r22
   10d2a:	4e 5f       	subi	r20, 0xFE	; 254
   10d2c:	5f 4f       	sbci	r21, 0xFF	; 255
   10d2e:	84 17       	cp	r24, r20
   10d30:	95 07       	cpc	r25, r21
   10d32:	50 f0       	brcs	.+20     	; 0x10d48 <malloc+0x14e>
   10d34:	42 0f       	add	r20, r18
   10d36:	53 1f       	adc	r21, r19
   10d38:	50 93 2c 82 	sts	0x822C, r21
   10d3c:	40 93 2b 82 	sts	0x822B, r20
   10d40:	f9 01       	movw	r30, r18
   10d42:	61 93       	st	Z+, r22
   10d44:	71 93       	st	Z+, r23
   10d46:	02 c0       	rjmp	.+4      	; 0x10d4c <malloc+0x152>
   10d48:	e0 e0       	ldi	r30, 0x00	; 0
   10d4a:	f0 e0       	ldi	r31, 0x00	; 0
   10d4c:	cf 01       	movw	r24, r30
   10d4e:	df 91       	pop	r29
   10d50:	cf 91       	pop	r28
   10d52:	08 95       	ret

00010d54 <free>:
   10d54:	cf 93       	push	r28
   10d56:	df 93       	push	r29
   10d58:	00 97       	sbiw	r24, 0x00	; 0
   10d5a:	09 f4       	brne	.+2      	; 0x10d5e <free+0xa>
   10d5c:	50 c0       	rjmp	.+160    	; 0x10dfe <free+0xaa>
   10d5e:	ec 01       	movw	r28, r24
   10d60:	22 97       	sbiw	r28, 0x02	; 2
   10d62:	1b 82       	std	Y+3, r1	; 0x03
   10d64:	1a 82       	std	Y+2, r1	; 0x02
   10d66:	a0 91 2d 82 	lds	r26, 0x822D
   10d6a:	b0 91 2e 82 	lds	r27, 0x822E
   10d6e:	10 97       	sbiw	r26, 0x00	; 0
   10d70:	09 f1       	breq	.+66     	; 0x10db4 <free+0x60>
   10d72:	40 e0       	ldi	r20, 0x00	; 0
   10d74:	50 e0       	ldi	r21, 0x00	; 0
   10d76:	ac 17       	cp	r26, r28
   10d78:	bd 07       	cpc	r27, r29
   10d7a:	08 f1       	brcs	.+66     	; 0x10dbe <free+0x6a>
   10d7c:	bb 83       	std	Y+3, r27	; 0x03
   10d7e:	aa 83       	std	Y+2, r26	; 0x02
   10d80:	fe 01       	movw	r30, r28
   10d82:	21 91       	ld	r18, Z+
   10d84:	31 91       	ld	r19, Z+
   10d86:	e2 0f       	add	r30, r18
   10d88:	f3 1f       	adc	r31, r19
   10d8a:	ae 17       	cp	r26, r30
   10d8c:	bf 07       	cpc	r27, r31
   10d8e:	79 f4       	brne	.+30     	; 0x10dae <free+0x5a>
   10d90:	8d 91       	ld	r24, X+
   10d92:	9c 91       	ld	r25, X
   10d94:	11 97       	sbiw	r26, 0x01	; 1
   10d96:	28 0f       	add	r18, r24
   10d98:	39 1f       	adc	r19, r25
   10d9a:	2e 5f       	subi	r18, 0xFE	; 254
   10d9c:	3f 4f       	sbci	r19, 0xFF	; 255
   10d9e:	39 83       	std	Y+1, r19	; 0x01
   10da0:	28 83       	st	Y, r18
   10da2:	12 96       	adiw	r26, 0x02	; 2
   10da4:	8d 91       	ld	r24, X+
   10da6:	9c 91       	ld	r25, X
   10da8:	13 97       	sbiw	r26, 0x03	; 3
   10daa:	9b 83       	std	Y+3, r25	; 0x03
   10dac:	8a 83       	std	Y+2, r24	; 0x02
   10dae:	41 15       	cp	r20, r1
   10db0:	51 05       	cpc	r21, r1
   10db2:	71 f4       	brne	.+28     	; 0x10dd0 <free+0x7c>
   10db4:	d0 93 2e 82 	sts	0x822E, r29
   10db8:	c0 93 2d 82 	sts	0x822D, r28
   10dbc:	20 c0       	rjmp	.+64     	; 0x10dfe <free+0xaa>
   10dbe:	12 96       	adiw	r26, 0x02	; 2
   10dc0:	8d 91       	ld	r24, X+
   10dc2:	9c 91       	ld	r25, X
   10dc4:	13 97       	sbiw	r26, 0x03	; 3
   10dc6:	ad 01       	movw	r20, r26
   10dc8:	00 97       	sbiw	r24, 0x00	; 0
   10dca:	11 f0       	breq	.+4      	; 0x10dd0 <free+0x7c>
   10dcc:	dc 01       	movw	r26, r24
   10dce:	d3 cf       	rjmp	.-90     	; 0x10d76 <free+0x22>
   10dd0:	fa 01       	movw	r30, r20
   10dd2:	d3 83       	std	Z+3, r29	; 0x03
   10dd4:	c2 83       	std	Z+2, r28	; 0x02
   10dd6:	21 91       	ld	r18, Z+
   10dd8:	31 91       	ld	r19, Z+
   10dda:	e2 0f       	add	r30, r18
   10ddc:	f3 1f       	adc	r31, r19
   10dde:	ce 17       	cp	r28, r30
   10de0:	df 07       	cpc	r29, r31
   10de2:	69 f4       	brne	.+26     	; 0x10dfe <free+0xaa>
   10de4:	88 81       	ld	r24, Y
   10de6:	99 81       	ldd	r25, Y+1	; 0x01
   10de8:	28 0f       	add	r18, r24
   10dea:	39 1f       	adc	r19, r25
   10dec:	2e 5f       	subi	r18, 0xFE	; 254
   10dee:	3f 4f       	sbci	r19, 0xFF	; 255
   10df0:	fa 01       	movw	r30, r20
   10df2:	31 83       	std	Z+1, r19	; 0x01
   10df4:	20 83       	st	Z, r18
   10df6:	8a 81       	ldd	r24, Y+2	; 0x02
   10df8:	9b 81       	ldd	r25, Y+3	; 0x03
   10dfa:	93 83       	std	Z+3, r25	; 0x03
   10dfc:	82 83       	std	Z+2, r24	; 0x02
   10dfe:	df 91       	pop	r29
   10e00:	cf 91       	pop	r28
   10e02:	08 95       	ret

00010e04 <__ftoa_engine>:
   10e04:	28 30       	cpi	r18, 0x08	; 8
   10e06:	08 f0       	brcs	.+2      	; 0x10e0a <__ftoa_engine+0x6>
   10e08:	27 e0       	ldi	r18, 0x07	; 7
   10e0a:	33 27       	eor	r19, r19
   10e0c:	da 01       	movw	r26, r20
   10e0e:	99 0f       	add	r25, r25
   10e10:	31 1d       	adc	r19, r1
   10e12:	87 fd       	sbrc	r24, 7
   10e14:	91 60       	ori	r25, 0x01	; 1
   10e16:	00 96       	adiw	r24, 0x00	; 0
   10e18:	61 05       	cpc	r22, r1
   10e1a:	71 05       	cpc	r23, r1
   10e1c:	39 f4       	brne	.+14     	; 0x10e2c <__ftoa_engine+0x28>
   10e1e:	32 60       	ori	r19, 0x02	; 2
   10e20:	2e 5f       	subi	r18, 0xFE	; 254
   10e22:	3d 93       	st	X+, r19
   10e24:	30 e3       	ldi	r19, 0x30	; 48
   10e26:	2a 95       	dec	r18
   10e28:	e1 f7       	brne	.-8      	; 0x10e22 <__ftoa_engine+0x1e>
   10e2a:	08 95       	ret
   10e2c:	9f 3f       	cpi	r25, 0xFF	; 255
   10e2e:	30 f0       	brcs	.+12     	; 0x10e3c <__ftoa_engine+0x38>
   10e30:	80 38       	cpi	r24, 0x80	; 128
   10e32:	71 05       	cpc	r23, r1
   10e34:	61 05       	cpc	r22, r1
   10e36:	09 f0       	breq	.+2      	; 0x10e3a <__ftoa_engine+0x36>
   10e38:	3c 5f       	subi	r19, 0xFC	; 252
   10e3a:	3c 5f       	subi	r19, 0xFC	; 252
   10e3c:	3d 93       	st	X+, r19
   10e3e:	91 30       	cpi	r25, 0x01	; 1
   10e40:	08 f0       	brcs	.+2      	; 0x10e44 <__ftoa_engine+0x40>
   10e42:	80 68       	ori	r24, 0x80	; 128
   10e44:	91 1d       	adc	r25, r1
   10e46:	df 93       	push	r29
   10e48:	cf 93       	push	r28
   10e4a:	1f 93       	push	r17
   10e4c:	0f 93       	push	r16
   10e4e:	ff 92       	push	r15
   10e50:	ef 92       	push	r14
   10e52:	19 2f       	mov	r17, r25
   10e54:	98 7f       	andi	r25, 0xF8	; 248
   10e56:	96 95       	lsr	r25
   10e58:	e9 2f       	mov	r30, r25
   10e5a:	96 95       	lsr	r25
   10e5c:	96 95       	lsr	r25
   10e5e:	e9 0f       	add	r30, r25
   10e60:	ff 27       	eor	r31, r31
   10e62:	e8 55       	subi	r30, 0x58	; 88
   10e64:	fa 4f       	sbci	r31, 0xFA	; 250
   10e66:	99 27       	eor	r25, r25
   10e68:	33 27       	eor	r19, r19
   10e6a:	ee 24       	eor	r14, r14
   10e6c:	ff 24       	eor	r15, r15
   10e6e:	a7 01       	movw	r20, r14
   10e70:	e7 01       	movw	r28, r14
   10e72:	05 90       	lpm	r0, Z+
   10e74:	08 94       	sec
   10e76:	07 94       	ror	r0
   10e78:	28 f4       	brcc	.+10     	; 0x10e84 <__ftoa_engine+0x80>
   10e7a:	36 0f       	add	r19, r22
   10e7c:	e7 1e       	adc	r14, r23
   10e7e:	f8 1e       	adc	r15, r24
   10e80:	49 1f       	adc	r20, r25
   10e82:	51 1d       	adc	r21, r1
   10e84:	66 0f       	add	r22, r22
   10e86:	77 1f       	adc	r23, r23
   10e88:	88 1f       	adc	r24, r24
   10e8a:	99 1f       	adc	r25, r25
   10e8c:	06 94       	lsr	r0
   10e8e:	a1 f7       	brne	.-24     	; 0x10e78 <__ftoa_engine+0x74>
   10e90:	05 90       	lpm	r0, Z+
   10e92:	07 94       	ror	r0
   10e94:	28 f4       	brcc	.+10     	; 0x10ea0 <__ftoa_engine+0x9c>
   10e96:	e7 0e       	add	r14, r23
   10e98:	f8 1e       	adc	r15, r24
   10e9a:	49 1f       	adc	r20, r25
   10e9c:	56 1f       	adc	r21, r22
   10e9e:	c1 1d       	adc	r28, r1
   10ea0:	77 0f       	add	r23, r23
   10ea2:	88 1f       	adc	r24, r24
   10ea4:	99 1f       	adc	r25, r25
   10ea6:	66 1f       	adc	r22, r22
   10ea8:	06 94       	lsr	r0
   10eaa:	a1 f7       	brne	.-24     	; 0x10e94 <__ftoa_engine+0x90>
   10eac:	05 90       	lpm	r0, Z+
   10eae:	07 94       	ror	r0
   10eb0:	28 f4       	brcc	.+10     	; 0x10ebc <__ftoa_engine+0xb8>
   10eb2:	f8 0e       	add	r15, r24
   10eb4:	49 1f       	adc	r20, r25
   10eb6:	56 1f       	adc	r21, r22
   10eb8:	c7 1f       	adc	r28, r23
   10eba:	d1 1d       	adc	r29, r1
   10ebc:	88 0f       	add	r24, r24
   10ebe:	99 1f       	adc	r25, r25
   10ec0:	66 1f       	adc	r22, r22
   10ec2:	77 1f       	adc	r23, r23
   10ec4:	06 94       	lsr	r0
   10ec6:	a1 f7       	brne	.-24     	; 0x10eb0 <__ftoa_engine+0xac>
   10ec8:	05 90       	lpm	r0, Z+
   10eca:	07 94       	ror	r0
   10ecc:	20 f4       	brcc	.+8      	; 0x10ed6 <__ftoa_engine+0xd2>
   10ece:	49 0f       	add	r20, r25
   10ed0:	56 1f       	adc	r21, r22
   10ed2:	c7 1f       	adc	r28, r23
   10ed4:	d8 1f       	adc	r29, r24
   10ed6:	99 0f       	add	r25, r25
   10ed8:	66 1f       	adc	r22, r22
   10eda:	77 1f       	adc	r23, r23
   10edc:	88 1f       	adc	r24, r24
   10ede:	06 94       	lsr	r0
   10ee0:	a9 f7       	brne	.-22     	; 0x10ecc <__ftoa_engine+0xc8>
   10ee2:	84 91       	lpm	r24, Z+
   10ee4:	10 95       	com	r17
   10ee6:	17 70       	andi	r17, 0x07	; 7
   10ee8:	41 f0       	breq	.+16     	; 0x10efa <__ftoa_engine+0xf6>
   10eea:	d6 95       	lsr	r29
   10eec:	c7 95       	ror	r28
   10eee:	57 95       	ror	r21
   10ef0:	47 95       	ror	r20
   10ef2:	f7 94       	ror	r15
   10ef4:	e7 94       	ror	r14
   10ef6:	1a 95       	dec	r17
   10ef8:	c1 f7       	brne	.-16     	; 0x10eea <__ftoa_engine+0xe6>
   10efa:	ee e4       	ldi	r30, 0x4E	; 78
   10efc:	f5 e0       	ldi	r31, 0x05	; 5
   10efe:	68 94       	set
   10f00:	15 90       	lpm	r1, Z+
   10f02:	15 91       	lpm	r17, Z+
   10f04:	35 91       	lpm	r19, Z+
   10f06:	65 91       	lpm	r22, Z+
   10f08:	95 91       	lpm	r25, Z+
   10f0a:	05 90       	lpm	r0, Z+
   10f0c:	7f e2       	ldi	r23, 0x2F	; 47
   10f0e:	73 95       	inc	r23
   10f10:	e1 18       	sub	r14, r1
   10f12:	f1 0a       	sbc	r15, r17
   10f14:	43 0b       	sbc	r20, r19
   10f16:	56 0b       	sbc	r21, r22
   10f18:	c9 0b       	sbc	r28, r25
   10f1a:	d0 09       	sbc	r29, r0
   10f1c:	c0 f7       	brcc	.-16     	; 0x10f0e <__ftoa_engine+0x10a>
   10f1e:	e1 0c       	add	r14, r1
   10f20:	f1 1e       	adc	r15, r17
   10f22:	43 1f       	adc	r20, r19
   10f24:	56 1f       	adc	r21, r22
   10f26:	c9 1f       	adc	r28, r25
   10f28:	d0 1d       	adc	r29, r0
   10f2a:	7e f4       	brtc	.+30     	; 0x10f4a <__ftoa_engine+0x146>
   10f2c:	70 33       	cpi	r23, 0x30	; 48
   10f2e:	11 f4       	brne	.+4      	; 0x10f34 <__ftoa_engine+0x130>
   10f30:	8a 95       	dec	r24
   10f32:	e6 cf       	rjmp	.-52     	; 0x10f00 <__ftoa_engine+0xfc>
   10f34:	e8 94       	clt
   10f36:	01 50       	subi	r16, 0x01	; 1
   10f38:	30 f0       	brcs	.+12     	; 0x10f46 <__ftoa_engine+0x142>
   10f3a:	08 0f       	add	r16, r24
   10f3c:	0a f4       	brpl	.+2      	; 0x10f40 <__ftoa_engine+0x13c>
   10f3e:	00 27       	eor	r16, r16
   10f40:	02 17       	cp	r16, r18
   10f42:	08 f4       	brcc	.+2      	; 0x10f46 <__ftoa_engine+0x142>
   10f44:	20 2f       	mov	r18, r16
   10f46:	23 95       	inc	r18
   10f48:	02 2f       	mov	r16, r18
   10f4a:	7a 33       	cpi	r23, 0x3A	; 58
   10f4c:	28 f0       	brcs	.+10     	; 0x10f58 <__ftoa_engine+0x154>
   10f4e:	79 e3       	ldi	r23, 0x39	; 57
   10f50:	7d 93       	st	X+, r23
   10f52:	2a 95       	dec	r18
   10f54:	e9 f7       	brne	.-6      	; 0x10f50 <__ftoa_engine+0x14c>
   10f56:	10 c0       	rjmp	.+32     	; 0x10f78 <__ftoa_engine+0x174>
   10f58:	7d 93       	st	X+, r23
   10f5a:	2a 95       	dec	r18
   10f5c:	89 f6       	brne	.-94     	; 0x10f00 <__ftoa_engine+0xfc>
   10f5e:	06 94       	lsr	r0
   10f60:	97 95       	ror	r25
   10f62:	67 95       	ror	r22
   10f64:	37 95       	ror	r19
   10f66:	17 95       	ror	r17
   10f68:	17 94       	ror	r1
   10f6a:	e1 18       	sub	r14, r1
   10f6c:	f1 0a       	sbc	r15, r17
   10f6e:	43 0b       	sbc	r20, r19
   10f70:	56 0b       	sbc	r21, r22
   10f72:	c9 0b       	sbc	r28, r25
   10f74:	d0 09       	sbc	r29, r0
   10f76:	98 f0       	brcs	.+38     	; 0x10f9e <__ftoa_engine+0x19a>
   10f78:	23 95       	inc	r18
   10f7a:	7e 91       	ld	r23, -X
   10f7c:	73 95       	inc	r23
   10f7e:	7a 33       	cpi	r23, 0x3A	; 58
   10f80:	08 f0       	brcs	.+2      	; 0x10f84 <__ftoa_engine+0x180>
   10f82:	70 e3       	ldi	r23, 0x30	; 48
   10f84:	7c 93       	st	X, r23
   10f86:	20 13       	cpse	r18, r16
   10f88:	b8 f7       	brcc	.-18     	; 0x10f78 <__ftoa_engine+0x174>
   10f8a:	7e 91       	ld	r23, -X
   10f8c:	70 61       	ori	r23, 0x10	; 16
   10f8e:	7d 93       	st	X+, r23
   10f90:	30 f0       	brcs	.+12     	; 0x10f9e <__ftoa_engine+0x19a>
   10f92:	83 95       	inc	r24
   10f94:	71 e3       	ldi	r23, 0x31	; 49
   10f96:	7d 93       	st	X+, r23
   10f98:	70 e3       	ldi	r23, 0x30	; 48
   10f9a:	2a 95       	dec	r18
   10f9c:	e1 f7       	brne	.-8      	; 0x10f96 <__ftoa_engine+0x192>
   10f9e:	11 24       	eor	r1, r1
   10fa0:	ef 90       	pop	r14
   10fa2:	ff 90       	pop	r15
   10fa4:	0f 91       	pop	r16
   10fa6:	1f 91       	pop	r17
   10fa8:	cf 91       	pop	r28
   10faa:	df 91       	pop	r29
   10fac:	99 27       	eor	r25, r25
   10fae:	87 fd       	sbrc	r24, 7
   10fb0:	90 95       	com	r25
   10fb2:	08 95       	ret

00010fb4 <isspace>:
   10fb4:	91 11       	cpse	r25, r1
   10fb6:	1f c2       	rjmp	.+1086   	; 0x113f6 <__ctype_isfalse>
   10fb8:	80 32       	cpi	r24, 0x20	; 32
   10fba:	19 f0       	breq	.+6      	; 0x10fc2 <isspace+0xe>
   10fbc:	89 50       	subi	r24, 0x09	; 9
   10fbe:	85 50       	subi	r24, 0x05	; 5
   10fc0:	d0 f7       	brcc	.-12     	; 0x10fb6 <isspace+0x2>
   10fc2:	08 95       	ret

00010fc4 <tolower>:
   10fc4:	91 11       	cpse	r25, r1
   10fc6:	08 95       	ret
   10fc8:	81 54       	subi	r24, 0x41	; 65
   10fca:	8a 51       	subi	r24, 0x1A	; 26
   10fcc:	08 f4       	brcc	.+2      	; 0x10fd0 <tolower+0xc>
   10fce:	80 5e       	subi	r24, 0xE0	; 224
   10fd0:	85 5a       	subi	r24, 0xA5	; 165
   10fd2:	08 95       	ret

00010fd4 <strchr_P>:
   10fd4:	fc 01       	movw	r30, r24
   10fd6:	05 90       	lpm	r0, Z+
   10fd8:	06 16       	cp	r0, r22
   10fda:	21 f0       	breq	.+8      	; 0x10fe4 <strchr_P+0x10>
   10fdc:	00 20       	and	r0, r0
   10fde:	d9 f7       	brne	.-10     	; 0x10fd6 <strchr_P+0x2>
   10fe0:	c0 01       	movw	r24, r0
   10fe2:	08 95       	ret
   10fe4:	31 97       	sbiw	r30, 0x01	; 1
   10fe6:	cf 01       	movw	r24, r30
   10fe8:	08 95       	ret

00010fea <strnlen_P>:
   10fea:	fc 01       	movw	r30, r24
   10fec:	05 90       	lpm	r0, Z+
   10fee:	61 50       	subi	r22, 0x01	; 1
   10ff0:	70 40       	sbci	r23, 0x00	; 0
   10ff2:	01 10       	cpse	r0, r1
   10ff4:	d8 f7       	brcc	.-10     	; 0x10fec <strnlen_P+0x2>
   10ff6:	80 95       	com	r24
   10ff8:	90 95       	com	r25
   10ffa:	8e 0f       	add	r24, r30
   10ffc:	9f 1f       	adc	r25, r31
   10ffe:	08 95       	ret

00011000 <memset>:
   11000:	dc 01       	movw	r26, r24
   11002:	01 c0       	rjmp	.+2      	; 0x11006 <memset+0x6>
   11004:	6d 93       	st	X+, r22
   11006:	41 50       	subi	r20, 0x01	; 1
   11008:	50 40       	sbci	r21, 0x00	; 0
   1100a:	e0 f7       	brcc	.-8      	; 0x11004 <memset+0x4>
   1100c:	08 95       	ret

0001100e <strnlen>:
   1100e:	fc 01       	movw	r30, r24
   11010:	61 50       	subi	r22, 0x01	; 1
   11012:	70 40       	sbci	r23, 0x00	; 0
   11014:	01 90       	ld	r0, Z+
   11016:	01 10       	cpse	r0, r1
   11018:	d8 f7       	brcc	.-10     	; 0x11010 <strnlen+0x2>
   1101a:	80 95       	com	r24
   1101c:	90 95       	com	r25
   1101e:	8e 0f       	add	r24, r30
   11020:	9f 1f       	adc	r25, r31
   11022:	08 95       	ret

00011024 <itoa>:
   11024:	fb 01       	movw	r30, r22
   11026:	9f 01       	movw	r18, r30
   11028:	e8 94       	clt
   1102a:	42 30       	cpi	r20, 0x02	; 2
   1102c:	c4 f0       	brlt	.+48     	; 0x1105e <itoa+0x3a>
   1102e:	45 32       	cpi	r20, 0x25	; 37
   11030:	b4 f4       	brge	.+44     	; 0x1105e <itoa+0x3a>
   11032:	4a 30       	cpi	r20, 0x0A	; 10
   11034:	29 f4       	brne	.+10     	; 0x11040 <itoa+0x1c>
   11036:	97 fb       	bst	r25, 7
   11038:	1e f4       	brtc	.+6      	; 0x11040 <itoa+0x1c>
   1103a:	90 95       	com	r25
   1103c:	81 95       	neg	r24
   1103e:	9f 4f       	sbci	r25, 0xFF	; 255
   11040:	64 2f       	mov	r22, r20
   11042:	77 27       	eor	r23, r23
   11044:	0e 94 c7 85 	call	0x10b8e	; 0x10b8e <__udivmodhi4>
   11048:	80 5d       	subi	r24, 0xD0	; 208
   1104a:	8a 33       	cpi	r24, 0x3A	; 58
   1104c:	0c f0       	brlt	.+2      	; 0x11050 <itoa+0x2c>
   1104e:	89 5d       	subi	r24, 0xD9	; 217
   11050:	81 93       	st	Z+, r24
   11052:	cb 01       	movw	r24, r22
   11054:	00 97       	sbiw	r24, 0x00	; 0
   11056:	a1 f7       	brne	.-24     	; 0x11040 <itoa+0x1c>
   11058:	16 f4       	brtc	.+4      	; 0x1105e <itoa+0x3a>
   1105a:	5d e2       	ldi	r21, 0x2D	; 45
   1105c:	51 93       	st	Z+, r21
   1105e:	10 82       	st	Z, r1
   11060:	c9 01       	movw	r24, r18
   11062:	0c 94 fe 89 	jmp	0x113fc	; 0x113fc <strrev>

00011066 <fgetc>:
   11066:	cf 93       	push	r28
   11068:	df 93       	push	r29
   1106a:	ec 01       	movw	r28, r24
   1106c:	4b 81       	ldd	r20, Y+3	; 0x03
   1106e:	40 ff       	sbrs	r20, 0
   11070:	1a c0       	rjmp	.+52     	; 0x110a6 <fgetc+0x40>
   11072:	46 ff       	sbrs	r20, 6
   11074:	0a c0       	rjmp	.+20     	; 0x1108a <fgetc+0x24>
   11076:	4f 7b       	andi	r20, 0xBF	; 191
   11078:	4b 83       	std	Y+3, r20	; 0x03
   1107a:	8e 81       	ldd	r24, Y+6	; 0x06
   1107c:	9f 81       	ldd	r25, Y+7	; 0x07
   1107e:	01 96       	adiw	r24, 0x01	; 1
   11080:	9f 83       	std	Y+7, r25	; 0x07
   11082:	8e 83       	std	Y+6, r24	; 0x06
   11084:	8a 81       	ldd	r24, Y+2	; 0x02
   11086:	28 2f       	mov	r18, r24
   11088:	2b c0       	rjmp	.+86     	; 0x110e0 <fgetc+0x7a>
   1108a:	42 ff       	sbrs	r20, 2
   1108c:	13 c0       	rjmp	.+38     	; 0x110b4 <fgetc+0x4e>
   1108e:	e8 81       	ld	r30, Y
   11090:	f9 81       	ldd	r31, Y+1	; 0x01
   11092:	80 81       	ld	r24, Z
   11094:	28 2f       	mov	r18, r24
   11096:	33 27       	eor	r19, r19
   11098:	27 fd       	sbrc	r18, 7
   1109a:	30 95       	com	r19
   1109c:	21 15       	cp	r18, r1
   1109e:	31 05       	cpc	r19, r1
   110a0:	29 f4       	brne	.+10     	; 0x110ac <fgetc+0x46>
   110a2:	40 62       	ori	r20, 0x20	; 32
   110a4:	4b 83       	std	Y+3, r20	; 0x03
   110a6:	2f ef       	ldi	r18, 0xFF	; 255
   110a8:	3f ef       	ldi	r19, 0xFF	; 255
   110aa:	1b c0       	rjmp	.+54     	; 0x110e2 <fgetc+0x7c>
   110ac:	31 96       	adiw	r30, 0x01	; 1
   110ae:	f9 83       	std	Y+1, r31	; 0x01
   110b0:	e8 83       	st	Y, r30
   110b2:	11 c0       	rjmp	.+34     	; 0x110d6 <fgetc+0x70>
   110b4:	ea 85       	ldd	r30, Y+10	; 0x0a
   110b6:	fb 85       	ldd	r31, Y+11	; 0x0b
   110b8:	ce 01       	movw	r24, r28
   110ba:	09 95       	icall
   110bc:	9c 01       	movw	r18, r24
   110be:	97 ff       	sbrs	r25, 7
   110c0:	0a c0       	rjmp	.+20     	; 0x110d6 <fgetc+0x70>
   110c2:	9b 81       	ldd	r25, Y+3	; 0x03
   110c4:	2f 5f       	subi	r18, 0xFF	; 255
   110c6:	3f 4f       	sbci	r19, 0xFF	; 255
   110c8:	11 f0       	breq	.+4      	; 0x110ce <fgetc+0x68>
   110ca:	80 e2       	ldi	r24, 0x20	; 32
   110cc:	01 c0       	rjmp	.+2      	; 0x110d0 <fgetc+0x6a>
   110ce:	80 e1       	ldi	r24, 0x10	; 16
   110d0:	89 2b       	or	r24, r25
   110d2:	8b 83       	std	Y+3, r24	; 0x03
   110d4:	e8 cf       	rjmp	.-48     	; 0x110a6 <fgetc+0x40>
   110d6:	8e 81       	ldd	r24, Y+6	; 0x06
   110d8:	9f 81       	ldd	r25, Y+7	; 0x07
   110da:	01 96       	adiw	r24, 0x01	; 1
   110dc:	9f 83       	std	Y+7, r25	; 0x07
   110de:	8e 83       	std	Y+6, r24	; 0x06
   110e0:	30 e0       	ldi	r19, 0x00	; 0
   110e2:	c9 01       	movw	r24, r18
   110e4:	df 91       	pop	r29
   110e6:	cf 91       	pop	r28
   110e8:	08 95       	ret

000110ea <fprintf>:
   110ea:	df 93       	push	r29
   110ec:	cf 93       	push	r28
   110ee:	cd b7       	in	r28, 0x3d	; 61
   110f0:	de b7       	in	r29, 0x3e	; 62
   110f2:	9e 01       	movw	r18, r28
   110f4:	27 5f       	subi	r18, 0xF7	; 247
   110f6:	3f 4f       	sbci	r19, 0xFF	; 255
   110f8:	8d 81       	ldd	r24, Y+5	; 0x05
   110fa:	9e 81       	ldd	r25, Y+6	; 0x06
   110fc:	6f 81       	ldd	r22, Y+7	; 0x07
   110fe:	78 85       	ldd	r23, Y+8	; 0x08
   11100:	a9 01       	movw	r20, r18
   11102:	0e 94 0a 7b 	call	0xf614	; 0xf614 <vfprintf>
   11106:	cf 91       	pop	r28
   11108:	df 91       	pop	r29
   1110a:	08 95       	ret

0001110c <fprintf_P>:
   1110c:	0f 93       	push	r16
   1110e:	1f 93       	push	r17
   11110:	df 93       	push	r29
   11112:	cf 93       	push	r28
   11114:	cd b7       	in	r28, 0x3d	; 61
   11116:	de b7       	in	r29, 0x3e	; 62
   11118:	0f 81       	ldd	r16, Y+7	; 0x07
   1111a:	18 85       	ldd	r17, Y+8	; 0x08
   1111c:	9e 01       	movw	r18, r28
   1111e:	25 5f       	subi	r18, 0xF5	; 245
   11120:	3f 4f       	sbci	r19, 0xFF	; 255
   11122:	f8 01       	movw	r30, r16
   11124:	83 81       	ldd	r24, Z+3	; 0x03
   11126:	88 60       	ori	r24, 0x08	; 8
   11128:	83 83       	std	Z+3, r24	; 0x03
   1112a:	c8 01       	movw	r24, r16
   1112c:	69 85       	ldd	r22, Y+9	; 0x09
   1112e:	7a 85       	ldd	r23, Y+10	; 0x0a
   11130:	a9 01       	movw	r20, r18
   11132:	0e 94 0a 7b 	call	0xf614	; 0xf614 <vfprintf>
   11136:	f8 01       	movw	r30, r16
   11138:	23 81       	ldd	r18, Z+3	; 0x03
   1113a:	27 7f       	andi	r18, 0xF7	; 247
   1113c:	23 83       	std	Z+3, r18	; 0x03
   1113e:	cf 91       	pop	r28
   11140:	df 91       	pop	r29
   11142:	1f 91       	pop	r17
   11144:	0f 91       	pop	r16
   11146:	08 95       	ret

00011148 <fputc>:
   11148:	0f 93       	push	r16
   1114a:	1f 93       	push	r17
   1114c:	cf 93       	push	r28
   1114e:	df 93       	push	r29
   11150:	8c 01       	movw	r16, r24
   11152:	eb 01       	movw	r28, r22
   11154:	8b 81       	ldd	r24, Y+3	; 0x03
   11156:	81 ff       	sbrs	r24, 1
   11158:	1b c0       	rjmp	.+54     	; 0x11190 <fputc+0x48>
   1115a:	82 ff       	sbrs	r24, 2
   1115c:	0d c0       	rjmp	.+26     	; 0x11178 <fputc+0x30>
   1115e:	2e 81       	ldd	r18, Y+6	; 0x06
   11160:	3f 81       	ldd	r19, Y+7	; 0x07
   11162:	8c 81       	ldd	r24, Y+4	; 0x04
   11164:	9d 81       	ldd	r25, Y+5	; 0x05
   11166:	28 17       	cp	r18, r24
   11168:	39 07       	cpc	r19, r25
   1116a:	64 f4       	brge	.+24     	; 0x11184 <fputc+0x3c>
   1116c:	e8 81       	ld	r30, Y
   1116e:	f9 81       	ldd	r31, Y+1	; 0x01
   11170:	01 93       	st	Z+, r16
   11172:	f9 83       	std	Y+1, r31	; 0x01
   11174:	e8 83       	st	Y, r30
   11176:	06 c0       	rjmp	.+12     	; 0x11184 <fputc+0x3c>
   11178:	e8 85       	ldd	r30, Y+8	; 0x08
   1117a:	f9 85       	ldd	r31, Y+9	; 0x09
   1117c:	80 2f       	mov	r24, r16
   1117e:	09 95       	icall
   11180:	89 2b       	or	r24, r25
   11182:	31 f4       	brne	.+12     	; 0x11190 <fputc+0x48>
   11184:	8e 81       	ldd	r24, Y+6	; 0x06
   11186:	9f 81       	ldd	r25, Y+7	; 0x07
   11188:	01 96       	adiw	r24, 0x01	; 1
   1118a:	9f 83       	std	Y+7, r25	; 0x07
   1118c:	8e 83       	std	Y+6, r24	; 0x06
   1118e:	02 c0       	rjmp	.+4      	; 0x11194 <fputc+0x4c>
   11190:	0f ef       	ldi	r16, 0xFF	; 255
   11192:	1f ef       	ldi	r17, 0xFF	; 255
   11194:	c8 01       	movw	r24, r16
   11196:	df 91       	pop	r29
   11198:	cf 91       	pop	r28
   1119a:	1f 91       	pop	r17
   1119c:	0f 91       	pop	r16
   1119e:	08 95       	ret

000111a0 <fputs>:
   111a0:	ef 92       	push	r14
   111a2:	ff 92       	push	r15
   111a4:	0f 93       	push	r16
   111a6:	1f 93       	push	r17
   111a8:	cf 93       	push	r28
   111aa:	df 93       	push	r29
   111ac:	7c 01       	movw	r14, r24
   111ae:	8b 01       	movw	r16, r22
   111b0:	db 01       	movw	r26, r22
   111b2:	13 96       	adiw	r26, 0x03	; 3
   111b4:	8c 91       	ld	r24, X
   111b6:	81 fd       	sbrc	r24, 1
   111b8:	03 c0       	rjmp	.+6      	; 0x111c0 <fputs+0x20>
   111ba:	cf ef       	ldi	r28, 0xFF	; 255
   111bc:	df ef       	ldi	r29, 0xFF	; 255
   111be:	13 c0       	rjmp	.+38     	; 0x111e6 <fputs+0x46>
   111c0:	c0 e0       	ldi	r28, 0x00	; 0
   111c2:	d0 e0       	ldi	r29, 0x00	; 0
   111c4:	0b c0       	rjmp	.+22     	; 0x111dc <fputs+0x3c>
   111c6:	d8 01       	movw	r26, r16
   111c8:	18 96       	adiw	r26, 0x08	; 8
   111ca:	ed 91       	ld	r30, X+
   111cc:	fc 91       	ld	r31, X
   111ce:	19 97       	sbiw	r26, 0x09	; 9
   111d0:	b8 01       	movw	r22, r16
   111d2:	09 95       	icall
   111d4:	89 2b       	or	r24, r25
   111d6:	11 f0       	breq	.+4      	; 0x111dc <fputs+0x3c>
   111d8:	cf ef       	ldi	r28, 0xFF	; 255
   111da:	df ef       	ldi	r29, 0xFF	; 255
   111dc:	f7 01       	movw	r30, r14
   111de:	81 91       	ld	r24, Z+
   111e0:	7f 01       	movw	r14, r30
   111e2:	88 23       	and	r24, r24
   111e4:	81 f7       	brne	.-32     	; 0x111c6 <fputs+0x26>
   111e6:	ce 01       	movw	r24, r28
   111e8:	df 91       	pop	r29
   111ea:	cf 91       	pop	r28
   111ec:	1f 91       	pop	r17
   111ee:	0f 91       	pop	r16
   111f0:	ff 90       	pop	r15
   111f2:	ef 90       	pop	r14
   111f4:	08 95       	ret

000111f6 <printf>:
   111f6:	df 93       	push	r29
   111f8:	cf 93       	push	r28
   111fa:	cd b7       	in	r28, 0x3d	; 61
   111fc:	de b7       	in	r29, 0x3e	; 62
   111fe:	fe 01       	movw	r30, r28
   11200:	35 96       	adiw	r30, 0x05	; 5
   11202:	61 91       	ld	r22, Z+
   11204:	71 91       	ld	r23, Z+
   11206:	80 91 31 82 	lds	r24, 0x8231
   1120a:	90 91 32 82 	lds	r25, 0x8232
   1120e:	af 01       	movw	r20, r30
   11210:	0e 94 0a 7b 	call	0xf614	; 0xf614 <vfprintf>
   11214:	cf 91       	pop	r28
   11216:	df 91       	pop	r29
   11218:	08 95       	ret

0001121a <putchar>:
   1121a:	60 91 31 82 	lds	r22, 0x8231
   1121e:	70 91 32 82 	lds	r23, 0x8232
   11222:	0e 94 a4 88 	call	0x11148	; 0x11148 <fputc>
   11226:	08 95       	ret

00011228 <puts>:
   11228:	0f 93       	push	r16
   1122a:	1f 93       	push	r17
   1122c:	cf 93       	push	r28
   1122e:	df 93       	push	r29
   11230:	8c 01       	movw	r16, r24
   11232:	e0 91 31 82 	lds	r30, 0x8231
   11236:	f0 91 32 82 	lds	r31, 0x8232
   1123a:	83 81       	ldd	r24, Z+3	; 0x03
   1123c:	81 ff       	sbrs	r24, 1
   1123e:	21 c0       	rjmp	.+66     	; 0x11282 <puts+0x5a>
   11240:	c0 e0       	ldi	r28, 0x00	; 0
   11242:	d0 e0       	ldi	r29, 0x00	; 0
   11244:	0d c0       	rjmp	.+26     	; 0x11260 <puts+0x38>
   11246:	e0 91 31 82 	lds	r30, 0x8231
   1124a:	f0 91 32 82 	lds	r31, 0x8232
   1124e:	20 85       	ldd	r18, Z+8	; 0x08
   11250:	31 85       	ldd	r19, Z+9	; 0x09
   11252:	bf 01       	movw	r22, r30
   11254:	f9 01       	movw	r30, r18
   11256:	09 95       	icall
   11258:	89 2b       	or	r24, r25
   1125a:	11 f0       	breq	.+4      	; 0x11260 <puts+0x38>
   1125c:	cf ef       	ldi	r28, 0xFF	; 255
   1125e:	df ef       	ldi	r29, 0xFF	; 255
   11260:	f8 01       	movw	r30, r16
   11262:	81 91       	ld	r24, Z+
   11264:	8f 01       	movw	r16, r30
   11266:	88 23       	and	r24, r24
   11268:	71 f7       	brne	.-36     	; 0x11246 <puts+0x1e>
   1126a:	e0 91 31 82 	lds	r30, 0x8231
   1126e:	f0 91 32 82 	lds	r31, 0x8232
   11272:	20 85       	ldd	r18, Z+8	; 0x08
   11274:	31 85       	ldd	r19, Z+9	; 0x09
   11276:	8a e0       	ldi	r24, 0x0A	; 10
   11278:	bf 01       	movw	r22, r30
   1127a:	f9 01       	movw	r30, r18
   1127c:	09 95       	icall
   1127e:	89 2b       	or	r24, r25
   11280:	11 f0       	breq	.+4      	; 0x11286 <puts+0x5e>
   11282:	cf ef       	ldi	r28, 0xFF	; 255
   11284:	df ef       	ldi	r29, 0xFF	; 255
   11286:	ce 01       	movw	r24, r28
   11288:	df 91       	pop	r29
   1128a:	cf 91       	pop	r28
   1128c:	1f 91       	pop	r17
   1128e:	0f 91       	pop	r16
   11290:	08 95       	ret

00011292 <scanf>:
   11292:	df 93       	push	r29
   11294:	cf 93       	push	r28
   11296:	cd b7       	in	r28, 0x3d	; 61
   11298:	de b7       	in	r29, 0x3e	; 62
   1129a:	fe 01       	movw	r30, r28
   1129c:	35 96       	adiw	r30, 0x05	; 5
   1129e:	61 91       	ld	r22, Z+
   112a0:	71 91       	ld	r23, Z+
   112a2:	80 91 2f 82 	lds	r24, 0x822F
   112a6:	90 91 30 82 	lds	r25, 0x8230
   112aa:	af 01       	movw	r20, r30
   112ac:	0e 94 c1 81 	call	0x10382	; 0x10382 <vfscanf>
   112b0:	cf 91       	pop	r28
   112b2:	df 91       	pop	r29
   112b4:	08 95       	ret

000112b6 <ungetc>:
   112b6:	9c 01       	movw	r18, r24
   112b8:	fb 01       	movw	r30, r22
   112ba:	83 81       	ldd	r24, Z+3	; 0x03
   112bc:	80 ff       	sbrs	r24, 0
   112be:	11 c0       	rjmp	.+34     	; 0x112e2 <ungetc+0x2c>
   112c0:	86 fd       	sbrc	r24, 6
   112c2:	0f c0       	rjmp	.+30     	; 0x112e2 <ungetc+0x2c>
   112c4:	9f ef       	ldi	r25, 0xFF	; 255
   112c6:	2f 3f       	cpi	r18, 0xFF	; 255
   112c8:	39 07       	cpc	r19, r25
   112ca:	59 f0       	breq	.+22     	; 0x112e2 <ungetc+0x2c>
   112cc:	22 83       	std	Z+2, r18	; 0x02
   112ce:	80 64       	ori	r24, 0x40	; 64
   112d0:	8f 7d       	andi	r24, 0xDF	; 223
   112d2:	83 83       	std	Z+3, r24	; 0x03
   112d4:	86 81       	ldd	r24, Z+6	; 0x06
   112d6:	97 81       	ldd	r25, Z+7	; 0x07
   112d8:	01 97       	sbiw	r24, 0x01	; 1
   112da:	97 83       	std	Z+7, r25	; 0x07
   112dc:	86 83       	std	Z+6, r24	; 0x06
   112de:	30 e0       	ldi	r19, 0x00	; 0
   112e0:	02 c0       	rjmp	.+4      	; 0x112e6 <ungetc+0x30>
   112e2:	2f ef       	ldi	r18, 0xFF	; 255
   112e4:	3f ef       	ldi	r19, 0xFF	; 255
   112e6:	c9 01       	movw	r24, r18
   112e8:	08 95       	ret

000112ea <__ultoa_invert>:
   112ea:	fa 01       	movw	r30, r20
   112ec:	aa 27       	eor	r26, r26
   112ee:	28 30       	cpi	r18, 0x08	; 8
   112f0:	51 f1       	breq	.+84     	; 0x11346 <__ultoa_invert+0x5c>
   112f2:	20 31       	cpi	r18, 0x10	; 16
   112f4:	81 f1       	breq	.+96     	; 0x11356 <__ultoa_invert+0x6c>
   112f6:	e8 94       	clt
   112f8:	6f 93       	push	r22
   112fa:	6e 7f       	andi	r22, 0xFE	; 254
   112fc:	6e 5f       	subi	r22, 0xFE	; 254
   112fe:	7f 4f       	sbci	r23, 0xFF	; 255
   11300:	8f 4f       	sbci	r24, 0xFF	; 255
   11302:	9f 4f       	sbci	r25, 0xFF	; 255
   11304:	af 4f       	sbci	r26, 0xFF	; 255
   11306:	b1 e0       	ldi	r27, 0x01	; 1
   11308:	3e d0       	rcall	.+124    	; 0x11386 <__ultoa_invert+0x9c>
   1130a:	b4 e0       	ldi	r27, 0x04	; 4
   1130c:	3c d0       	rcall	.+120    	; 0x11386 <__ultoa_invert+0x9c>
   1130e:	67 0f       	add	r22, r23
   11310:	78 1f       	adc	r23, r24
   11312:	89 1f       	adc	r24, r25
   11314:	9a 1f       	adc	r25, r26
   11316:	a1 1d       	adc	r26, r1
   11318:	68 0f       	add	r22, r24
   1131a:	79 1f       	adc	r23, r25
   1131c:	8a 1f       	adc	r24, r26
   1131e:	91 1d       	adc	r25, r1
   11320:	a1 1d       	adc	r26, r1
   11322:	6a 0f       	add	r22, r26
   11324:	71 1d       	adc	r23, r1
   11326:	81 1d       	adc	r24, r1
   11328:	91 1d       	adc	r25, r1
   1132a:	a1 1d       	adc	r26, r1
   1132c:	20 d0       	rcall	.+64     	; 0x1136e <__ultoa_invert+0x84>
   1132e:	09 f4       	brne	.+2      	; 0x11332 <__ultoa_invert+0x48>
   11330:	68 94       	set
   11332:	3f 91       	pop	r19
   11334:	2a e0       	ldi	r18, 0x0A	; 10
   11336:	26 9f       	mul	r18, r22
   11338:	11 24       	eor	r1, r1
   1133a:	30 19       	sub	r19, r0
   1133c:	30 5d       	subi	r19, 0xD0	; 208
   1133e:	31 93       	st	Z+, r19
   11340:	de f6       	brtc	.-74     	; 0x112f8 <__ultoa_invert+0xe>
   11342:	cf 01       	movw	r24, r30
   11344:	08 95       	ret
   11346:	46 2f       	mov	r20, r22
   11348:	47 70       	andi	r20, 0x07	; 7
   1134a:	40 5d       	subi	r20, 0xD0	; 208
   1134c:	41 93       	st	Z+, r20
   1134e:	b3 e0       	ldi	r27, 0x03	; 3
   11350:	0f d0       	rcall	.+30     	; 0x11370 <__ultoa_invert+0x86>
   11352:	c9 f7       	brne	.-14     	; 0x11346 <__ultoa_invert+0x5c>
   11354:	f6 cf       	rjmp	.-20     	; 0x11342 <__ultoa_invert+0x58>
   11356:	46 2f       	mov	r20, r22
   11358:	4f 70       	andi	r20, 0x0F	; 15
   1135a:	40 5d       	subi	r20, 0xD0	; 208
   1135c:	4a 33       	cpi	r20, 0x3A	; 58
   1135e:	18 f0       	brcs	.+6      	; 0x11366 <__ultoa_invert+0x7c>
   11360:	49 5d       	subi	r20, 0xD9	; 217
   11362:	31 fd       	sbrc	r19, 1
   11364:	40 52       	subi	r20, 0x20	; 32
   11366:	41 93       	st	Z+, r20
   11368:	02 d0       	rcall	.+4      	; 0x1136e <__ultoa_invert+0x84>
   1136a:	a9 f7       	brne	.-22     	; 0x11356 <__ultoa_invert+0x6c>
   1136c:	ea cf       	rjmp	.-44     	; 0x11342 <__ultoa_invert+0x58>
   1136e:	b4 e0       	ldi	r27, 0x04	; 4
   11370:	a6 95       	lsr	r26
   11372:	97 95       	ror	r25
   11374:	87 95       	ror	r24
   11376:	77 95       	ror	r23
   11378:	67 95       	ror	r22
   1137a:	ba 95       	dec	r27
   1137c:	c9 f7       	brne	.-14     	; 0x11370 <__ultoa_invert+0x86>
   1137e:	00 97       	sbiw	r24, 0x00	; 0
   11380:	61 05       	cpc	r22, r1
   11382:	71 05       	cpc	r23, r1
   11384:	08 95       	ret
   11386:	9b 01       	movw	r18, r22
   11388:	ac 01       	movw	r20, r24
   1138a:	0a 2e       	mov	r0, r26
   1138c:	06 94       	lsr	r0
   1138e:	57 95       	ror	r21
   11390:	47 95       	ror	r20
   11392:	37 95       	ror	r19
   11394:	27 95       	ror	r18
   11396:	ba 95       	dec	r27
   11398:	c9 f7       	brne	.-14     	; 0x1138c <__ultoa_invert+0xa2>
   1139a:	62 0f       	add	r22, r18
   1139c:	73 1f       	adc	r23, r19
   1139e:	84 1f       	adc	r24, r20
   113a0:	95 1f       	adc	r25, r21
   113a2:	a0 1d       	adc	r26, r0
   113a4:	08 95       	ret

000113a6 <__eerd_block_m1280>:
   113a6:	dc 01       	movw	r26, r24
   113a8:	cb 01       	movw	r24, r22

000113aa <__eerd_blraw_m1280>:
   113aa:	fc 01       	movw	r30, r24
   113ac:	f9 99       	sbic	0x1f, 1	; 31
   113ae:	fe cf       	rjmp	.-4      	; 0x113ac <__eerd_blraw_m1280+0x2>
   113b0:	06 c0       	rjmp	.+12     	; 0x113be <__eerd_blraw_m1280+0x14>
   113b2:	f2 bd       	out	0x22, r31	; 34
   113b4:	e1 bd       	out	0x21, r30	; 33
   113b6:	f8 9a       	sbi	0x1f, 0	; 31
   113b8:	31 96       	adiw	r30, 0x01	; 1
   113ba:	00 b4       	in	r0, 0x20	; 32
   113bc:	0d 92       	st	X+, r0
   113be:	41 50       	subi	r20, 0x01	; 1
   113c0:	50 40       	sbci	r21, 0x00	; 0
   113c2:	b8 f7       	brcc	.-18     	; 0x113b2 <__eerd_blraw_m1280+0x8>
   113c4:	08 95       	ret

000113c6 <__eewr_block_m1280>:
   113c6:	dc 01       	movw	r26, r24
   113c8:	cb 01       	movw	r24, r22
   113ca:	03 c0       	rjmp	.+6      	; 0x113d2 <__eewr_block_m1280+0xc>
   113cc:	2d 91       	ld	r18, X+
   113ce:	0e 94 ee 89 	call	0x113dc	; 0x113dc <__eewr_r18_m1280>
   113d2:	41 50       	subi	r20, 0x01	; 1
   113d4:	50 40       	sbci	r21, 0x00	; 0
   113d6:	d0 f7       	brcc	.-12     	; 0x113cc <__eewr_block_m1280+0x6>
   113d8:	08 95       	ret

000113da <__eewr_byte_m1280>:
   113da:	26 2f       	mov	r18, r22

000113dc <__eewr_r18_m1280>:
   113dc:	f9 99       	sbic	0x1f, 1	; 31
   113de:	fe cf       	rjmp	.-4      	; 0x113dc <__eewr_r18_m1280>
   113e0:	1f ba       	out	0x1f, r1	; 31
   113e2:	92 bd       	out	0x22, r25	; 34
   113e4:	81 bd       	out	0x21, r24	; 33
   113e6:	20 bd       	out	0x20, r18	; 32
   113e8:	0f b6       	in	r0, 0x3f	; 63
   113ea:	f8 94       	cli
   113ec:	fa 9a       	sbi	0x1f, 2	; 31
   113ee:	f9 9a       	sbi	0x1f, 1	; 31
   113f0:	0f be       	out	0x3f, r0	; 63
   113f2:	01 96       	adiw	r24, 0x01	; 1
   113f4:	08 95       	ret

000113f6 <__ctype_isfalse>:
   113f6:	99 27       	eor	r25, r25
   113f8:	88 27       	eor	r24, r24

000113fa <__ctype_istrue>:
   113fa:	08 95       	ret

000113fc <strrev>:
   113fc:	dc 01       	movw	r26, r24
   113fe:	fc 01       	movw	r30, r24
   11400:	67 2f       	mov	r22, r23
   11402:	71 91       	ld	r23, Z+
   11404:	77 23       	and	r23, r23
   11406:	e1 f7       	brne	.-8      	; 0x11400 <strrev+0x4>
   11408:	32 97       	sbiw	r30, 0x02	; 2
   1140a:	04 c0       	rjmp	.+8      	; 0x11414 <strrev+0x18>
   1140c:	7c 91       	ld	r23, X
   1140e:	6d 93       	st	X+, r22
   11410:	70 83       	st	Z, r23
   11412:	62 91       	ld	r22, -Z
   11414:	ae 17       	cp	r26, r30
   11416:	bf 07       	cpc	r27, r31
   11418:	c8 f3       	brcs	.-14     	; 0x1140c <strrev+0x10>
   1141a:	08 95       	ret

0001141c <_exit>:
   1141c:	f8 94       	cli

0001141e <__stop_program>:
   1141e:	ff cf       	rjmp	.-2      	; 0x1141e <__stop_program>
