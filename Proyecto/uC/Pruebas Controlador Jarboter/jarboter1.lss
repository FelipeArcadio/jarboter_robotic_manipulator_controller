
jarboter1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000052aa  00802200  000141bc  00014270  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000141bc  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000052a  008074aa  008074aa  0001951a  2**0
                  ALLOC
  3 .eeprom       00000162  00810000  00810000  0001951a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         000162f0  00000000  00000000  0001967c  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000e94e  00000000  00000000  0002f96c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 da 0c 	jmp	0x19b4	; 0x19b4 <__ctors_end>
       4:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
       8:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
       c:	0c 94 a7 28 	jmp	0x514e	; 0x514e <__vector_3>
      10:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      14:	0c 94 7b 28 	jmp	0x50f6	; 0x50f6 <__vector_5>
      18:	0c 94 4f 28 	jmp	0x509e	; 0x509e <__vector_6>
      1c:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      20:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      24:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      28:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      2c:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      30:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      34:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      38:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      3c:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      40:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      44:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      48:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      4c:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      50:	0c 94 c2 27 	jmp	0x4f84	; 0x4f84 <__vector_20>
      54:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      58:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      5c:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      60:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      64:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      68:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      6c:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      70:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      74:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      78:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      7c:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      80:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      84:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      88:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      8c:	0c 94 22 27 	jmp	0x4e44	; 0x4e44 <__vector_35>
      90:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      94:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      98:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      9c:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      a0:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      a4:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      a8:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      ac:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      b0:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      b4:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      b8:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      bc:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      c0:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      c4:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      c8:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      cc:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      d0:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      d4:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      d8:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      dc:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      e0:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__bad_interrupt>
      e4:	81 37       	cpi	r24, 0x71	; 113
      e6:	7e 37       	cpi	r23, 0x7E	; 126
      e8:	84 37       	cpi	r24, 0x74	; 116
      ea:	87 37       	cpi	r24, 0x77	; 119
      ec:	8a 37       	cpi	r24, 0x7A	; 122
      ee:	8d 37       	cpi	r24, 0x7D	; 125
      f0:	90 37       	cpi	r25, 0x70	; 112
      f2:	93 37       	cpi	r25, 0x73	; 115
      f4:	96 37       	cpi	r25, 0x76	; 118
      f6:	99 37       	cpi	r25, 0x79	; 121
      f8:	9c 37       	cpi	r25, 0x7C	; 124
      fa:	9f 37       	cpi	r25, 0x7F	; 127
      fc:	a2 37       	cpi	r26, 0x72	; 114
      fe:	a5 37       	cpi	r26, 0x75	; 117
     100:	a8 37       	cpi	r26, 0x78	; 120
     102:	ab 37       	cpi	r26, 0x7B	; 123
     104:	ae 37       	cpi	r26, 0x7E	; 126
     106:	b1 37       	cpi	r27, 0x71	; 113
     108:	b4 37       	cpi	r27, 0x74	; 116
     10a:	0d 38       	cpi	r16, 0x8D	; 141
     10c:	0a 38       	cpi	r16, 0x8A	; 138
     10e:	10 38       	cpi	r17, 0x80	; 128
     110:	13 38       	cpi	r17, 0x83	; 131
     112:	16 38       	cpi	r17, 0x86	; 134
     114:	19 38       	cpi	r17, 0x89	; 137
     116:	1c 38       	cpi	r17, 0x8C	; 140
     118:	1f 38       	cpi	r17, 0x8F	; 143
     11a:	22 38       	cpi	r18, 0x82	; 130
     11c:	25 38       	cpi	r18, 0x85	; 133
     11e:	28 38       	cpi	r18, 0x88	; 136
     120:	2b 38       	cpi	r18, 0x8B	; 139
     122:	2e 38       	cpi	r18, 0x8E	; 142
     124:	31 38       	cpi	r19, 0x81	; 129
     126:	34 38       	cpi	r19, 0x84	; 132
     128:	37 38       	cpi	r19, 0x87	; 135
     12a:	46 38       	cpi	r20, 0x86	; 134
     12c:	46 38       	cpi	r20, 0x86	; 134
     12e:	46 38       	cpi	r20, 0x86	; 134
     130:	3a 38       	cpi	r19, 0x8A	; 138
     132:	3d 38       	cpi	r19, 0x8D	; 141
     134:	40 38       	cpi	r20, 0x80	; 128
     136:	43 38       	cpi	r20, 0x83	; 131
     138:	5f 38       	cpi	r21, 0x8F	; 143
     13a:	48 3a       	cpi	r20, 0xA8	; 168
     13c:	48 3a       	cpi	r20, 0xA8	; 168
     13e:	48 3a       	cpi	r20, 0xA8	; 168
     140:	48 3a       	cpi	r20, 0xA8	; 168
     142:	48 3a       	cpi	r20, 0xA8	; 168
     144:	5c 38       	cpi	r21, 0x8C	; 140
     146:	62 38       	cpi	r22, 0x82	; 130
     148:	48 3a       	cpi	r20, 0xA8	; 168
     14a:	48 3a       	cpi	r20, 0xA8	; 168
     14c:	48 3a       	cpi	r20, 0xA8	; 168
     14e:	48 3a       	cpi	r20, 0xA8	; 168
     150:	48 3a       	cpi	r20, 0xA8	; 168
     152:	48 3a       	cpi	r20, 0xA8	; 168
     154:	48 3a       	cpi	r20, 0xA8	; 168
     156:	65 38       	cpi	r22, 0x85	; 133
     158:	68 38       	cpi	r22, 0x88	; 136
     15a:	6b 38       	cpi	r22, 0x8B	; 139
     15c:	48 3a       	cpi	r20, 0xA8	; 168
     15e:	6e 38       	cpi	r22, 0x8E	; 142
     160:	71 38       	cpi	r23, 0x81	; 129
     162:	48 3a       	cpi	r20, 0xA8	; 168
     164:	48 3a       	cpi	r20, 0xA8	; 168
     166:	48 3a       	cpi	r20, 0xA8	; 168
     168:	48 3a       	cpi	r20, 0xA8	; 168
     16a:	48 3a       	cpi	r20, 0xA8	; 168
     16c:	74 38       	cpi	r23, 0x84	; 132
     16e:	48 3a       	cpi	r20, 0xA8	; 168
     170:	48 3a       	cpi	r20, 0xA8	; 168
     172:	77 38       	cpi	r23, 0x87	; 135
     174:	7a 38       	cpi	r23, 0x8A	; 138
     176:	48 3a       	cpi	r20, 0xA8	; 168
     178:	48 3a       	cpi	r20, 0xA8	; 168
     17a:	48 3a       	cpi	r20, 0xA8	; 168
     17c:	48 3a       	cpi	r20, 0xA8	; 168
     17e:	48 3a       	cpi	r20, 0xA8	; 168
     180:	48 3a       	cpi	r20, 0xA8	; 168
     182:	7d 38       	cpi	r23, 0x8D	; 141
     184:	80 38       	cpi	r24, 0x80	; 128
     186:	83 38       	cpi	r24, 0x83	; 131
     188:	48 3a       	cpi	r20, 0xA8	; 168
     18a:	48 3a       	cpi	r20, 0xA8	; 168
     18c:	48 3a       	cpi	r20, 0xA8	; 168
     18e:	86 38       	cpi	r24, 0x86	; 134
     190:	89 38       	cpi	r24, 0x89	; 137
     192:	8c 38       	cpi	r24, 0x8C	; 140
     194:	48 3a       	cpi	r20, 0xA8	; 168
     196:	8f 38       	cpi	r24, 0x8F	; 143
     198:	48 3a       	cpi	r20, 0xA8	; 168
     19a:	92 38       	cpi	r25, 0x82	; 130
     19c:	48 3a       	cpi	r20, 0xA8	; 168
     19e:	48 3a       	cpi	r20, 0xA8	; 168
     1a0:	95 38       	cpi	r25, 0x85	; 133
     1a2:	48 3a       	cpi	r20, 0xA8	; 168
     1a4:	98 38       	cpi	r25, 0x88	; 136
     1a6:	9b 38       	cpi	r25, 0x8B	; 139
     1a8:	9e 38       	cpi	r25, 0x8E	; 142
     1aa:	a1 38       	cpi	r26, 0x81	; 129
     1ac:	a4 38       	cpi	r26, 0x84	; 132
     1ae:	48 3a       	cpi	r20, 0xA8	; 168
     1b0:	48 3a       	cpi	r20, 0xA8	; 168
     1b2:	48 3a       	cpi	r20, 0xA8	; 168
     1b4:	a7 38       	cpi	r26, 0x87	; 135
     1b6:	48 3a       	cpi	r20, 0xA8	; 168
     1b8:	48 3a       	cpi	r20, 0xA8	; 168
     1ba:	48 3a       	cpi	r20, 0xA8	; 168
     1bc:	48 3a       	cpi	r20, 0xA8	; 168
     1be:	48 3a       	cpi	r20, 0xA8	; 168
     1c0:	48 3a       	cpi	r20, 0xA8	; 168
     1c2:	48 3a       	cpi	r20, 0xA8	; 168
     1c4:	48 3a       	cpi	r20, 0xA8	; 168
     1c6:	aa 38       	cpi	r26, 0x8A	; 138
     1c8:	48 3a       	cpi	r20, 0xA8	; 168
     1ca:	48 3a       	cpi	r20, 0xA8	; 168
     1cc:	ad 38       	cpi	r26, 0x8D	; 141
     1ce:	b0 38       	cpi	r27, 0x80	; 128
     1d0:	b3 38       	cpi	r27, 0x83	; 131
     1d2:	b6 38       	cpi	r27, 0x86	; 134
     1d4:	48 3a       	cpi	r20, 0xA8	; 168
     1d6:	48 3a       	cpi	r20, 0xA8	; 168
     1d8:	b9 38       	cpi	r27, 0x89	; 137
     1da:	bc 38       	cpi	r27, 0x8C	; 140
     1dc:	bf 38       	cpi	r27, 0x8F	; 143
     1de:	48 3a       	cpi	r20, 0xA8	; 168
     1e0:	c2 38       	cpi	r28, 0x82	; 130
     1e2:	48 3a       	cpi	r20, 0xA8	; 168
     1e4:	c5 38       	cpi	r28, 0x85	; 133
     1e6:	48 3a       	cpi	r20, 0xA8	; 168
     1e8:	c8 38       	cpi	r28, 0x88	; 136
     1ea:	cb 38       	cpi	r28, 0x8B	; 139
     1ec:	48 3a       	cpi	r20, 0xA8	; 168
     1ee:	ce 38       	cpi	r28, 0x8E	; 142
     1f0:	48 3a       	cpi	r20, 0xA8	; 168
     1f2:	48 3a       	cpi	r20, 0xA8	; 168
     1f4:	48 3a       	cpi	r20, 0xA8	; 168
     1f6:	48 3a       	cpi	r20, 0xA8	; 168
     1f8:	48 3a       	cpi	r20, 0xA8	; 168
     1fa:	d1 38       	cpi	r29, 0x81	; 129
     1fc:	48 3a       	cpi	r20, 0xA8	; 168
     1fe:	48 3a       	cpi	r20, 0xA8	; 168
     200:	48 3a       	cpi	r20, 0xA8	; 168
     202:	48 3a       	cpi	r20, 0xA8	; 168
     204:	48 3a       	cpi	r20, 0xA8	; 168
     206:	48 3a       	cpi	r20, 0xA8	; 168
     208:	48 3a       	cpi	r20, 0xA8	; 168
     20a:	d4 38       	cpi	r29, 0x84	; 132
     20c:	d7 38       	cpi	r29, 0x87	; 135
     20e:	da 38       	cpi	r29, 0x8A	; 138
     210:	48 3a       	cpi	r20, 0xA8	; 168
     212:	48 3a       	cpi	r20, 0xA8	; 168
     214:	dd 38       	cpi	r29, 0x8D	; 141
     216:	48 3a       	cpi	r20, 0xA8	; 168
     218:	48 3a       	cpi	r20, 0xA8	; 168
     21a:	48 3a       	cpi	r20, 0xA8	; 168
     21c:	e0 38       	cpi	r30, 0x80	; 128
     21e:	48 3a       	cpi	r20, 0xA8	; 168
     220:	48 3a       	cpi	r20, 0xA8	; 168
     222:	e3 38       	cpi	r30, 0x83	; 131
     224:	e6 38       	cpi	r30, 0x86	; 134
     226:	e9 38       	cpi	r30, 0x89	; 137
     228:	48 3a       	cpi	r20, 0xA8	; 168
     22a:	48 3a       	cpi	r20, 0xA8	; 168
     22c:	ec 38       	cpi	r30, 0x8C	; 140
     22e:	ef 38       	cpi	r30, 0x8F	; 143
     230:	f2 38       	cpi	r31, 0x82	; 130
     232:	f5 38       	cpi	r31, 0x85	; 133
     234:	48 3a       	cpi	r20, 0xA8	; 168
     236:	48 3a       	cpi	r20, 0xA8	; 168
     238:	f8 38       	cpi	r31, 0x88	; 136
     23a:	fb 38       	cpi	r31, 0x8B	; 139
     23c:	fe 38       	cpi	r31, 0x8E	; 142
     23e:	01 39       	cpi	r16, 0x91	; 145
     240:	04 39       	cpi	r16, 0x94	; 148
     242:	07 39       	cpi	r16, 0x97	; 151
     244:	0a 39       	cpi	r16, 0x9A	; 154
     246:	0d 39       	cpi	r16, 0x9D	; 157
     248:	10 39       	cpi	r17, 0x90	; 144
     24a:	13 39       	cpi	r17, 0x93	; 147
     24c:	16 39       	cpi	r17, 0x96	; 150
     24e:	19 39       	cpi	r17, 0x99	; 153
     250:	1c 39       	cpi	r17, 0x9C	; 156
     252:	1f 39       	cpi	r17, 0x9F	; 159
     254:	22 39       	cpi	r18, 0x92	; 146
     256:	25 39       	cpi	r18, 0x95	; 149
     258:	28 39       	cpi	r18, 0x98	; 152
     25a:	2b 39       	cpi	r18, 0x9B	; 155
     25c:	2e 39       	cpi	r18, 0x9E	; 158
     25e:	31 39       	cpi	r19, 0x91	; 145
     260:	34 39       	cpi	r19, 0x94	; 148
     262:	37 39       	cpi	r19, 0x97	; 151
     264:	3a 39       	cpi	r19, 0x9A	; 154
     266:	3d 39       	cpi	r19, 0x9D	; 157
     268:	40 39       	cpi	r20, 0x90	; 144
     26a:	43 39       	cpi	r20, 0x93	; 147
     26c:	46 39       	cpi	r20, 0x96	; 150
     26e:	49 39       	cpi	r20, 0x99	; 153
     270:	4c 39       	cpi	r20, 0x9C	; 156
     272:	4f 39       	cpi	r20, 0x9F	; 159
     274:	52 39       	cpi	r21, 0x92	; 146
     276:	55 39       	cpi	r21, 0x95	; 149
     278:	58 39       	cpi	r21, 0x98	; 152
     27a:	5b 39       	cpi	r21, 0x9B	; 155
     27c:	5e 39       	cpi	r21, 0x9E	; 158
     27e:	61 39       	cpi	r22, 0x91	; 145
     280:	64 39       	cpi	r22, 0x94	; 148
     282:	67 39       	cpi	r22, 0x97	; 151
     284:	6a 39       	cpi	r22, 0x9A	; 154
     286:	6d 39       	cpi	r22, 0x9D	; 157
     288:	70 39       	cpi	r23, 0x90	; 144
     28a:	73 39       	cpi	r23, 0x93	; 147
     28c:	76 39       	cpi	r23, 0x96	; 150
     28e:	79 39       	cpi	r23, 0x99	; 153
     290:	7c 39       	cpi	r23, 0x9C	; 156
     292:	7f 39       	cpi	r23, 0x9F	; 159
     294:	82 39       	cpi	r24, 0x92	; 146
     296:	85 39       	cpi	r24, 0x95	; 149
     298:	88 39       	cpi	r24, 0x98	; 152
     29a:	8b 39       	cpi	r24, 0x9B	; 155
     29c:	8e 39       	cpi	r24, 0x9E	; 158
     29e:	91 39       	cpi	r25, 0x91	; 145
     2a0:	94 39       	cpi	r25, 0x94	; 148
     2a2:	97 39       	cpi	r25, 0x97	; 151
     2a4:	9a 39       	cpi	r25, 0x9A	; 154
     2a6:	9d 39       	cpi	r25, 0x9D	; 157
     2a8:	a0 39       	cpi	r26, 0x90	; 144
     2aa:	a3 39       	cpi	r26, 0x93	; 147
     2ac:	a6 39       	cpi	r26, 0x96	; 150
     2ae:	a9 39       	cpi	r26, 0x99	; 153
     2b0:	ac 39       	cpi	r26, 0x9C	; 156
     2b2:	af 39       	cpi	r26, 0x9F	; 159
     2b4:	b2 39       	cpi	r27, 0x92	; 146
     2b6:	b5 39       	cpi	r27, 0x95	; 149
     2b8:	b8 39       	cpi	r27, 0x98	; 152
     2ba:	bb 39       	cpi	r27, 0x9B	; 155
     2bc:	be 39       	cpi	r27, 0x9E	; 158
     2be:	c1 39       	cpi	r28, 0x91	; 145
     2c0:	c4 39       	cpi	r28, 0x94	; 148
     2c2:	c7 39       	cpi	r28, 0x97	; 151
     2c4:	ca 39       	cpi	r28, 0x9A	; 154
     2c6:	cd 39       	cpi	r28, 0x9D	; 157
     2c8:	d0 39       	cpi	r29, 0x90	; 144
     2ca:	d3 39       	cpi	r29, 0x93	; 147
     2cc:	d6 39       	cpi	r29, 0x96	; 150
     2ce:	d9 39       	cpi	r29, 0x99	; 153
     2d0:	48 3a       	cpi	r20, 0xA8	; 168
     2d2:	48 3a       	cpi	r20, 0xA8	; 168
     2d4:	dc 39       	cpi	r29, 0x9C	; 156
     2d6:	df 39       	cpi	r29, 0x9F	; 159
     2d8:	e2 39       	cpi	r30, 0x92	; 146
     2da:	e5 39       	cpi	r30, 0x95	; 149
     2dc:	e8 39       	cpi	r30, 0x98	; 152
     2de:	eb 39       	cpi	r30, 0x9B	; 155
     2e0:	ee 39       	cpi	r30, 0x9E	; 158
     2e2:	f1 39       	cpi	r31, 0x91	; 145
     2e4:	f4 39       	cpi	r31, 0x94	; 148
     2e6:	f7 39       	cpi	r31, 0x97	; 151
     2e8:	fa 39       	cpi	r31, 0x9A	; 154
     2ea:	fd 39       	cpi	r31, 0x9D	; 157
     2ec:	00 3a       	cpi	r16, 0xA0	; 160
     2ee:	03 3a       	cpi	r16, 0xA3	; 163
     2f0:	06 3a       	cpi	r16, 0xA6	; 166
     2f2:	09 3a       	cpi	r16, 0xA9	; 169
     2f4:	0c 3a       	cpi	r16, 0xAC	; 172
     2f6:	0f 3a       	cpi	r16, 0xAF	; 175
     2f8:	12 3a       	cpi	r17, 0xA2	; 162
     2fa:	15 3a       	cpi	r17, 0xA5	; 165
     2fc:	18 3a       	cpi	r17, 0xA8	; 168
     2fe:	1b 3a       	cpi	r17, 0xAB	; 171
     300:	1e 3a       	cpi	r17, 0xAE	; 174
     302:	21 3a       	cpi	r18, 0xA1	; 161
     304:	24 3a       	cpi	r18, 0xA4	; 164
     306:	27 3a       	cpi	r18, 0xA7	; 167
     308:	2a 3a       	cpi	r18, 0xAA	; 170
     30a:	2d 3a       	cpi	r18, 0xAD	; 173
     30c:	30 3a       	cpi	r19, 0xA0	; 160
     30e:	33 3a       	cpi	r19, 0xA3	; 163
     310:	36 3a       	cpi	r19, 0xA6	; 166
     312:	39 3a       	cpi	r19, 0xA9	; 169
     314:	3c 3a       	cpi	r19, 0xAC	; 172
     316:	3f 3a       	cpi	r19, 0xAF	; 175
     318:	48 3a       	cpi	r20, 0xA8	; 168
     31a:	48 3a       	cpi	r20, 0xA8	; 168
     31c:	48 3a       	cpi	r20, 0xA8	; 168
     31e:	48 3a       	cpi	r20, 0xA8	; 168
     320:	48 3a       	cpi	r20, 0xA8	; 168
     322:	42 3a       	cpi	r20, 0xA2	; 162
     324:	48 3a       	cpi	r20, 0xA8	; 168
     326:	48 3a       	cpi	r20, 0xA8	; 168
     328:	45 3a       	cpi	r20, 0xA5	; 165

0000032a <__c.4090>:
     32a:	53 65 20 68 61 20 72 65 61 6c 69 7a 61 64 6f 20     Se ha realizado 
     33a:	75 6e 61 20 70 61 72 61 64 61 20 73 75 61 76 65     una parada suave
     34a:	20 65 6e 20 74 6f 64 6f 73 20 6c 6f 73 20 45 6a      en todos los Ej
     35a:	65 73 20 0a 00                                      es ..

0000035f <__c.4079>:
     35f:	4f 74 72 61 20 4f 70 63 69 6f 6e 3a 20 53 61 6c     Otra Opcion: Sal
     36f:	69 72 20 53 75 62 4d 65 6e 75 20 0a 00              ir SubMenu ..

0000037c <__c.4077>:
     37c:	34 2e 52 6f 6c 6c 2e 20 0a 00                       4.Roll. ..

00000386 <__c.4075>:
     386:	33 2e 20 50 69 74 63 68 2e 20 0a 00                 3. Pitch. ..

00000392 <__c.4073>:
     392:	32 2e 20 43 6f 64 6f 2e 20 0a 00                    2. Codo. ..

0000039d <__c.4071>:
     39d:	31 2e 20 48 6f 6d 62 72 6f 2e 20 0a 00              1. Hombro. ..

000003aa <__c.4069>:
     3aa:	30 2e 20 43 69 6e 74 75 72 61 2e 20 0a 00           0. Cintura. ..

000003b8 <__c.4067>:
     3b8:	44 69 67 69 74 65 20 41 72 74 69 63 75 6c 61 63     Digite Articulac
     3c8:	69 6f 6e 20 3a 20 0a 00                             ion : ..

000003d0 <__c.4065>:
     3d0:	4f 74 72 61 20 4f 70 63 69 6f 6e 3a 20 53 61 6c     Otra Opcion: Sal
     3e0:	69 72 20 53 75 62 4d 65 6e 75 20 0a 00              ir SubMenu ..

000003ed <__c.4063>:
     3ed:	33 2e 20 53 65 61 72 63 68 20 48 6f 6d 65 20 52     3. Search Home R
     3fd:	6f 6c 6c 20 50 6f 73 69 74 69 76 65 20 0a 00        oll Positive ..

0000040c <__c.4061>:
     40c:	32 2e 20 48 61 6c 6c 61 72 20 65 6e 20 4e 75 6d     2. Hallar en Num
     41c:	65 72 6f 20 64 65 20 50 61 73 6f 73 20 70 6f 72     ero de Pasos por
     42c:	20 52 65 76 6f 6c 75 63 69 6f 6e 20 64 65 6c 20      Revolucion del 
     43c:	4d 6f 74 6f 72 20 0a 00                             Motor ..

00000444 <__c.4059>:
     444:	31 2e 20 48 61 6c 6c 61 72 20 4c 69 6d 69 74 65     1. Hallar Limite
     454:	73 20 28 67 72 61 64 6f 73 29 20 64 65 6c 20 52     s (grados) del R
     464:	6f 62 6f 74 20 0a 00                                obot ..

0000046b <__c.4057>:
     46b:	30 2e 20 44 65 62 75 67 20 53 69 67 6e 61 6c 20     0. Debug Signal 
     47b:	53 74 61 74 75 73 20 0a 00                          Status ..

00000484 <__c.4050>:
     484:	4f 74 72 61 20 4f 70 63 69 6f 6e 3a 20 53 61 6c     Otra Opcion: Sal
     494:	69 72 20 53 75 62 4d 65 6e 75 20 0a 00              ir SubMenu ..

000004a1 <__c.4048>:
     4a1:	31 2e 20 43 65 72 72 61 72 20 47 72 69 70 70 65     1. Cerrar Grippe
     4b1:	72 20 0a 00                                         r ..

000004b5 <__c.4046>:
     4b5:	30 2e 20 41 62 72 69 72 20 47 72 69 70 70 65 72     0. Abrir Gripper
     4c5:	20 0a 00                                             ..

000004c8 <__c.4038>:
     4c8:	34 2e 52 6f 6c 6c 2e 20 0a 00                       4.Roll. ..

000004d2 <__c.4036>:
     4d2:	33 2e 20 50 69 74 63 68 2e 20 0a 00                 3. Pitch. ..

000004de <__c.4034>:
     4de:	32 2e 20 43 6f 64 6f 2e 20 0a 00                    2. Codo. ..

000004e9 <__c.4032>:
     4e9:	31 2e 20 48 6f 6d 62 72 6f 2e 20 0a 00              1. Hombro. ..

000004f6 <__c.4030>:
     4f6:	30 2e 20 43 69 6e 74 75 72 61 2e 20 0a 00           0. Cintura. ..

00000504 <__c.4028>:
     504:	44 69 67 69 74 65 20 6c 61 20 61 72 74 69 63 75     Digite la articu
     514:	6c 61 63 69 6f 6e 20 0a 00                          lacion ..

0000051d <__c.4026>:
     51d:	4f 74 72 61 20 4f 70 63 69 6f 6e 3a 20 53 61 6c     Otra Opcion: Sal
     52d:	69 72 20 53 75 62 4d 65 6e 75 20 0a 00              ir SubMenu ..

0000053a <__c.4024>:
     53a:	31 2e 20 49 6d 70 72 69 6d 69 72 20 54 72 61 7a     1. Imprimir Traz
     54a:	6f 20 0a 00                                         o ..

0000054e <__c.4022>:
     54e:	30 2e 20 43 6f 6e 66 69 67 75 72 61 72 20 54 72     0. Configurar Tr
     55e:	61 7a 6f 20 0a 00                                   azo ..

00000564 <__c.4016>:
     564:	45 72 72 6f 72 20 65 6e 20 6c 61 20 54 72 61 6e     Error en la Tran
     574:	73 6d 69 73 69 6f 6e 20 49 32 43 20 65 6e 20 4a     smision I2C en J
     584:	61 72 62 6f 74 65 72 2e 63 20 0a 00                 arboter.c ..

00000590 <__c.4010>:
     590:	4c 61 20 50 6f 73 65 20 6e 6f 20 45 78 69 73 74     La Pose no Exist
     5a0:	65 20 0a 00                                         e ..

000005a4 <__c.4008>:
     5a4:	44 69 67 69 74 65 20 65 6c 20 49 44 20 64 65 20     Digite el ID de 
     5b4:	6c 61 20 50 6f 73 65 20 71 75 65 20 64 65 73 65     la Pose que dese
     5c4:	61 20 4c 65 65 72 20 2e 20 0a 00                    a Leer . ..

000005cf <__c.4002>:
     5cf:	44 69 67 69 74 65 20 65 6c 20 49 44 20 64 65 20     Digite el ID de 
     5df:	6c 61 20 50 6f 73 65 20 71 75 65 20 44 65 73 65     la Pose que Dese
     5ef:	61 20 45 6e 63 6f 6e 74 72 61 72 2e 20 0a 00        a Encontrar. ..

000005fe <__c.3990>:
     5fe:	44 69 67 69 74 65 20 6c 61 20 70 6f 73 69 63 69     Digite la posici
     60e:	6f 6e 20 64 65 20 52 6f 6c 6c 20 2e 20 0a 00        on de Roll . ..

0000061d <__c.3988>:
     61d:	44 69 67 69 74 65 20 6c 61 20 70 6f 73 69 63 69     Digite la posici
     62d:	6f 6e 20 64 65 20 50 69 74 63 68 20 2e 20 0a 00     on de Pitch . ..

0000063d <__c.3986>:
     63d:	44 69 67 69 74 65 20 6c 61 20 70 6f 73 69 63 69     Digite la posici
     64d:	6f 6e 20 64 65 20 43 6f 64 6f 20 2e 20 0a 00        on de Codo . ..

0000065c <__c.3984>:
     65c:	44 69 67 69 74 65 20 6c 61 20 70 6f 73 69 63 69     Digite la posici
     66c:	6f 6e 20 64 65 20 48 6f 6d 62 72 6f 20 2e 20 0a     on de Hombro . .
	...

0000067d <__c.3982>:
     67d:	44 69 67 69 74 65 20 6c 61 20 70 6f 73 69 63 69     Digite la posici
     68d:	6f 6e 20 64 65 20 63 69 6e 74 75 72 61 20 2e 20     on de cintura . 
     69d:	0a 00                                               ..

0000069f <__c.3980>:
     69f:	44 69 67 69 74 65 20 65 6c 20 49 44 20 64 65 20     Digite el ID de 
     6af:	6c 61 20 50 6f 73 65 20 71 75 65 20 64 65 73 65     la Pose que dese
     6bf:	61 20 67 72 61 62 61 72 20 2e 20 0a 00              a grabar . ..

000006cc <__c.3978>:
     6cc:	44 69 67 69 74 65 20 65 6c 20 49 44 20 64 65 20     Digite el ID de 
     6dc:	6c 61 20 50 6f 73 65 20 71 75 65 20 64 65 73 65     la Pose que dese
     6ec:	61 20 67 72 61 62 61 72 20 2e 20 0a 00              a grabar . ..

000006f9 <__c.3976>:
     6f9:	4f 74 72 61 20 4f 70 63 69 6f 6e 3a 20 53 61 6c     Otra Opcion: Sal
     709:	69 72 20 53 75 62 4d 65 6e 75 20 0a 00              ir SubMenu ..

00000716 <__c.3974>:
     716:	39 2e 20 49 6d 70 72 69 6d 69 72 20 44 61 74 6f     9. Imprimir Dato
     726:	73 20 64 65 20 54 72 61 79 65 63 74 6f 72 69 61     s de Trayectoria
     736:	20 0a 00                                             ..

00000739 <__c.3972>:
     739:	38 2e 20 4f 62 74 65 6e 65 72 20 54 72 61 79 65     8. Obtener Traye
     749:	63 74 6f 72 69 61 20 64 65 20 75 6e 20 56 65 63     ctoria de un Vec
     759:	74 6f 72 20 64 65 20 49 44 73 20 0a 00              tor de IDs ..

00000766 <__c.3970>:
     766:	37 2e 20 52 65 74 6f 72 6e 61 72 20 56 65 63 74     7. Retornar Vect
     776:	6f 72 20 64 65 20 49 64 73 20 0a 00                 or de Ids ..

00000782 <__c.3968>:
     782:	36 2e 20 4c 65 65 72 20 50 6f 73 65 20 61 6c 6d     6. Leer Pose alm
     792:	61 63 65 6e 61 64 61 20 65 6e 20 45 45 50 52 4f     acenada en EEPRO
     7a2:	4d 20 0a 00                                         M ..

000007a6 <__c.3966>:
     7a6:	35 2e 20 53 6f 62 72 65 65 73 63 72 69 62 69 72     5. Sobreescribir
     7b6:	20 50 6f 73 65 20 0a 00                              Pose ..

000007be <__c.3964>:
     7be:	34 2e 20 41 64 69 63 69 6f 6e 61 72 20 50 6f 73     4. Adicionar Pos
     7ce:	65 20 65 6e 20 45 45 50 52 4f 4d 20 0a 00           e en EEPROM ..

000007dc <__c.3962>:
     7dc:	33 2e 20 42 6f 72 72 61 72 20 45 45 50 52 4f 4d     3. Borrar EEPROM
     7ec:	20 0a 00                                             ..

000007ef <__c.3960>:
     7ef:	32 2e 20 45 6e 63 6f 6e 74 72 61 72 20 44 69 72     2. Encontrar Dir
     7ff:	65 63 63 69 6f 6e 20 64 65 20 49 44 20 0a 00        eccion de ID ..

0000080e <__c.3958>:
     80e:	31 2e 20 4c 65 65 72 20 6c 61 20 45 45 50 52 4f     1. Leer la EEPRO
     81e:	4d 20 0a 00                                         M ..

00000822 <__c.3956>:
     822:	30 2e 20 45 73 63 72 69 62 69 72 20 65 6e 20 6c     0. Escribir en l
     832:	61 20 45 45 50 52 4f 4d 20 0a 00                    a EEPROM ..

0000083d <__c.3951>:
     83d:	52 54 43 46 20 3d 20 30 20 0a 00                    RTCF = 0 ..

00000848 <__c.3949>:
     848:	52 54 43 46 20 3d 20 31 20 0a 00                    RTCF = 1 ..

00000853 <__c.3947>:
     853:	57 45 4c 20 3d 20 30 20 0a 00                       WEL = 0 ..

0000085d <__c.3945>:
     85d:	57 45 4c 20 3d 20 31 20 0a 00                       WEL = 1 ..

00000867 <__c.3943>:
     867:	52 57 45 4c 20 3d 20 30 20 0a 00                    RWEL = 0 ..

00000872 <__c.3941>:
     872:	52 57 45 4c 20 3d 20 31 20 0a 00                    RWEL = 1 ..

0000087d <__c.3939>:
     87d:	4f 53 43 46 20 3d 20 30 20 0a 00                    OSCF = 0 ..

00000888 <__c.3937>:
     888:	4f 53 43 46 20 3d 20 31 20 0a 00                    OSCF = 1 ..

00000893 <__c.3935>:
     893:	41 6c 30 20 3d 20 30 20 0a 00                       Al0 = 0 ..

0000089d <__c.3933>:
     89d:	41 6c 30 20 3d 20 31 20 0a 00                       Al0 = 1 ..

000008a7 <__c.3931>:
     8a7:	41 4c 31 20 3d 20 30 20 0a 00                       AL1 = 0 ..

000008b1 <__c.3929>:
     8b1:	41 4c 31 20 3d 20 31 20 0a 00                       AL1 = 1 ..

000008bb <__c.3927>:
     8bb:	42 41 54 20 3d 20 30 20 0a 00                       BAT = 0 ..

000008c5 <__c.3925>:
     8c5:	42 41 54 20 3d 20 31 20 0a 00                       BAT = 1 ..

000008cf <__c.3921>:
     8cf:	31 2e 20 50 65 72 69 6f 64 69 63 61 2e 20 0a 00     1. Periodica. ..

000008df <__c.3919>:
     8df:	30 2e 20 4e 6f 20 50 65 72 69 6f 64 69 63 61 2e     0. No Periodica.
     8ef:	20 0a 00                                             ..

000008f2 <__c.3917>:
     8f2:	41 6c 61 72 6d 61 20 50 65 72 69 6f 64 69 63 61     Alarma Periodica
     902:	2e 20 0a 00                                         . ..

00000906 <__c.3915>:
     906:	44 69 67 69 74 65 20 65 6c 20 56 61 6c 6f 72 20     Digite el Valor 
     916:	65 6e 20 73 65 67 75 6e 64 6f 73 2e 20 30 2d 35     en segundos. 0-5
     926:	39 20 0a 00                                         9 ..

0000092a <__c.3913>:
     92a:	31 2e 20 53 49 20 0a 00                             1. SI ..

00000932 <__c.3911>:
     932:	30 2e 20 4e 4f 20 0a 00                             0. NO ..

0000093a <__c.3909>:
     93a:	44 65 73 65 61 20 48 61 62 69 6c 69 61 72 20 65     Desea Habiliar e
     94a:	6c 20 76 61 6c 6f 72 20 64 65 20 6c 6f 73 20 73     l valor de los s
     95a:	65 67 75 6e 64 6f 73 20 70 61 72 61 20 6c 61 20     egundos para la 
     96a:	41 6c 61 72 6d 61 3f 2e 20 0a 00                    Alarma?. ..

00000975 <__c.3907>:
     975:	44 69 67 69 74 65 20 65 6c 20 56 61 6c 6f 72 20     Digite el Valor 
     985:	64 65 20 6c 6f 73 20 4d 69 6e 75 74 6f 73 2e 20     de los Minutos. 
     995:	30 2d 35 39 20 0a 00                                0-59 ..

0000099c <__c.3905>:
     99c:	31 2e 20 53 49 20 0a 00                             1. SI ..

000009a4 <__c.3903>:
     9a4:	30 2e 20 4e 4f 20 0a 00                             0. NO ..

000009ac <__c.3901>:
     9ac:	44 65 73 65 61 20 48 61 62 69 6c 69 61 72 20 65     Desea Habiliar e
     9bc:	6c 20 76 61 6c 6f 72 20 64 65 20 6c 6f 73 20 6d     l valor de los m
     9cc:	69 6e 75 74 6f 73 20 70 61 72 61 20 6c 61 20 41     inutos para la A
     9dc:	6c 61 72 6d 61 3f 2e 20 0a 00                       larma?. ..

000009e6 <__c.3899>:
     9e6:	31 2e 50 4d 20 20 0a 00                             1.PM  ..

000009ee <__c.3897>:
     9ee:	30 2e 41 4d 20 20 0a 00                             0.AM  ..

000009f6 <__c.3895>:
     9f6:	44 69 67 69 74 65 20 65 6c 20 56 61 6c 6f 72 20     Digite el Valor 
     a06:	64 65 20 6c 61 20 48 6f 72 61 20 0a 00              de la Hora ..

00000a13 <__c.3893>:
     a13:	31 2e 20 53 49 20 0a 00                             1. SI ..

00000a1b <__c.3891>:
     a1b:	30 2e 20 4e 4f 20 0a 00                             0. NO ..

00000a23 <__c.3889>:
     a23:	44 65 73 65 61 20 48 61 62 69 6c 69 61 72 20 65     Desea Habiliar e
     a33:	6c 20 76 61 6c 6f 72 20 64 65 20 6c 61 20 48 6f     l valor de la Ho
     a43:	72 61 20 70 61 72 61 20 6c 61 20 41 6c 61 72 6d     ra para la Alarm
     a53:	61 3f 2e 20 0a 00                                   a?. ..

00000a59 <__c.3887>:
     a59:	44 69 67 69 74 65 20 65 6c 20 44 69 61 2e 20 31     Digite el Dia. 1
     a69:	2d 33 31 20 0a 00                                   -31 ..

00000a6f <__c.3885>:
     a6f:	31 2e 20 53 49 20 0a 00                             1. SI ..

00000a77 <__c.3883>:
     a77:	30 2e 20 4e 4f 20 0a 00                             0. NO ..

00000a7f <__c.3881>:
     a7f:	44 65 73 65 61 20 48 61 62 69 6c 69 61 72 20 75     Desea Habiliar u
     a8f:	6e 20 56 61 6c 6f 72 20 64 65 6c 20 44 49 41 20     n Valor del DIA 
     a9f:	70 61 72 61 20 6c 61 20 41 6c 61 72 6d 61 3f 2e     para la Alarma?.
     aaf:	20 0a 00                                             ..

00000ab2 <__c.3879>:
     ab2:	44 69 67 69 74 65 20 65 6c 20 4d 65 73 2e 20 31     Digite el Mes. 1
     ac2:	2d 31 32 20 0a 00                                   -12 ..

00000ac8 <__c.3877>:
     ac8:	31 2e 20 53 49 20 0a 00                             1. SI ..

00000ad0 <__c.3875>:
     ad0:	30 2e 20 4e 4f 20 0a 00                             0. NO ..

00000ad8 <__c.3873>:
     ad8:	44 65 73 65 61 20 48 61 62 69 6c 69 61 72 20 75     Desea Habiliar u
     ae8:	6e 20 56 61 6c 6f 72 20 64 65 6c 20 4d 65 73 20     n Valor del Mes 
     af8:	70 61 72 61 20 6c 61 20 41 6c 61 72 6d 61 3f 2e     para la Alarma?.
     b08:	20 0a 00                                             ..

00000b0b <__c.3870>:
     b0b:	31 2e 20 50 65 72 69 6f 64 69 63 61 2e 20 0a 00     1. Periodica. ..

00000b1b <__c.3868>:
     b1b:	30 2e 20 4e 6f 20 50 65 72 69 6f 64 69 63 61 2e     0. No Periodica.
     b2b:	20 0a 00                                             ..

00000b2e <__c.3866>:
     b2e:	41 6c 61 72 6d 61 20 50 65 72 69 6f 64 69 63 61     Alarma Periodica
     b3e:	2e 20 0a 00                                         . ..

00000b42 <__c.3864>:
     b42:	30 2e 20 44 65 73 68 61 62 69 6c 69 74 61 72 2e     0. Deshabilitar.
     b52:	20 0a 00                                             ..

00000b55 <__c.3862>:
     b55:	31 2e 20 48 61 62 69 6c 69 74 61 72 2e 20 0a 00     1. Habilitar. ..

00000b65 <__c.3860>:
     b65:	48 61 62 69 6c 69 74 61 72 20 41 6c 61 72 6d 61     Habilitar Alarma
     b75:	2e 20 0a 00                                         . ..

00000b79 <__c.3858>:
     b79:	44 69 67 69 74 65 20 75 6e 20 56 61 6c 6f 72 20     Digite un Valor 
     b89:	70 61 72 61 20 6c 61 20 63 6f 6d 70 65 6e 73 61     para la compensa
     b99:	63 69 6f 6e 20 64 65 20 6c 61 20 63 61 70 61 63     cion de la capac
     ba9:	69 74 61 6e 63 69 61 2e 20 0a 00                    itancia. ..

00000bb4 <__c.3856>:
     bb4:	37 2e 20 46 72 65 63 75 65 6e 63 69 61 20 45 73     7. Frecuencia Es
     bc4:	74 69 6d 61 64 61 20 28 50 50 4d 29 20 3d 20 2d     timada (PPM) = -
     bd4:	33 30 20 0a 00                                      30 ..

00000bd9 <__c.3854>:
     bd9:	36 2e 20 46 72 65 63 75 65 6e 63 69 61 20 45 73     6. Frecuencia Es
     be9:	74 69 6d 61 64 61 20 28 50 50 4d 29 20 3d 20 2d     timada (PPM) = -
     bf9:	31 30 20 0a 00                                      10 ..

00000bfe <__c.3852>:
     bfe:	35 2e 20 46 72 65 63 75 65 6e 63 69 61 20 45 73     5. Frecuencia Es
     c0e:	74 69 6d 61 64 61 20 28 50 50 4d 29 20 3d 20 2d     timada (PPM) = -
     c1e:	32 30 20 0a 00                                      20 ..

00000c23 <__c.3850>:
     c23:	33 2e 20 46 72 65 63 75 65 6e 63 69 61 20 45 73     3. Frecuencia Es
     c33:	74 69 6d 61 64 61 20 28 50 50 4d 29 20 3d 20 2b     timada (PPM) = +
     c43:	33 30 20 0a 00                                      30 ..

00000c48 <__c.3848>:
     c48:	32 2e 20 46 72 65 63 75 65 6e 63 69 61 20 45 73     2. Frecuencia Es
     c58:	74 69 6d 61 64 61 20 28 50 50 4d 29 20 3d 20 2b     timada (PPM) = +
     c68:	31 30 20 0a 00                                      10 ..

00000c6d <__c.3846>:
     c6d:	31 2e 20 46 72 65 63 75 65 6e 63 69 61 20 45 73     1. Frecuencia Es
     c7d:	74 69 6d 61 64 61 20 28 50 50 4d 29 20 3d 20 2b     timada (PPM) = +
     c8d:	32 30 20 0a 00                                      20 ..

00000c92 <__c.3844>:
     c92:	30 2e 20 46 72 65 63 75 65 6e 63 69 61 20 45 73     0. Frecuencia Es
     ca2:	74 69 6d 61 64 61 20 28 50 50 4d 29 20 3d 20 30     timada (PPM) = 0
     cb2:	20 0a 00                                             ..

00000cb5 <__c.3842>:
     cb5:	44 69 67 69 74 65 20 75 6e 20 56 61 6c 6f 72 20     Digite un Valor 
     cc5:	64 65 6c 20 44 69 67 69 74 61 6c 20 54 52 69 6d     del Digital TRim
     cd5:	6d 69 6e 67 20 52 65 67 69 73 74 65 72 2e 20 0a     ming Register. .
	...

00000ce6 <__c.3840>:
     ce6:	31 2e 20 4c 65 67 61 63 79 2f 44 65 66 65 63 74     1. Legacy/Defect
     cf6:	6f 2e 20 0a 00                                      o. ..

00000cfb <__c.3838>:
     cfb:	30 2e 20 53 74 61 6e 64 61 72 64 2e 20 0a 00        0. Standard. ..

00000d0a <__c.3836>:
     d0a:	44 69 67 69 74 65 20 6c 61 20 63 6f 6e 64 69 63     Digite la condic
     d1a:	69 6f 6e 20 64 65 20 63 61 6d 62 69 6f 20 65 6e     ion de cambio en
     d2a:	74 72 65 20 56 44 44 20 79 20 42 61 74 74 65 72     tre VDD y Batter
     d3a:	79 20 42 61 63 6b 75 70 2e 20 0a 00                 y Backup. ..

00000d46 <__c.3834>:
     d46:	31 2e 20 44 65 73 68 61 62 69 6c 69 74 61 72 2e     1. Deshabilitar.
     d56:	20 0a 00                                             ..

00000d59 <__c.3832>:
     d59:	30 2e 20 48 61 62 69 6c 69 74 61 72 2e 20 0a 00     0. Habilitar. ..

00000d69 <__c.3830>:
     d69:	44 69 67 69 74 65 20 73 69 20 48 61 62 69 6c 69     Digite si Habili
     d79:	74 61 72 61 20 6c 61 20 49 6e 74 65 72 66 61 63     tara la Interfac
     d89:	65 20 53 65 72 69 61 6c 20 65 6e 20 4d 6f 64 6f     e Serial en Modo
     d99:	20 64 65 20 42 61 74 74 65 72 79 20 42 61 63 6b      de Battery Back
     da9:	75 70 2e 20 0a 00                                   up. ..

00000daf <__c.3826>:
     daf:	36 2e 20 53 61 62 61 64 6f 20 0a 00                 6. Sabado ..

00000dbb <__c.3824>:
     dbb:	35 2e 20 56 69 65 72 6e 65 73 20 0a 00              5. Viernes ..

00000dc8 <__c.3822>:
     dc8:	34 2e 20 4a 75 65 76 65 73 20 0a 00                 4. Jueves ..

00000dd4 <__c.3820>:
     dd4:	33 2e 20 4d 69 65 72 63 6f 6c 65 73 20 0a 00        3. Miercoles ..

00000de3 <__c.3818>:
     de3:	32 2e 20 4d 61 72 74 65 73 20 0a 00                 2. Martes ..

00000def <__c.3816>:
     def:	31 2e 20 4c 75 6e 65 73 20 0a 00                    1. Lunes ..

00000dfa <__c.3814>:
     dfa:	30 2e 20 44 6f 6d 69 6e 67 6f 20 0a 00              0. Domingo ..

00000e07 <__c.3812>:
     e07:	44 69 67 69 74 65 20 65 6c 20 64 69 61 20 64 65     Digite el dia de
     e17:	20 6c 61 20 53 65 6d 61 6e 61 2e 20 0a 00            la Semana. ..

00000e25 <__c.3810>:
     e25:	44 69 67 69 74 65 20 65 6c 20 41 6e 6f 2e 20 30     Digite el Ano. 0
     e35:	2d 39 39 20 0a 00                                   -99 ..

00000e3b <__c.3808>:
     e3b:	44 69 67 69 74 65 20 65 6c 20 4d 65 73 2e 20 31     Digite el Mes. 1
     e4b:	2d 31 32 20 0a 00                                   -12 ..

00000e51 <__c.3806>:
     e51:	44 69 67 69 74 65 20 65 6c 20 44 69 61 2e 20 31     Digite el Dia. 1
     e61:	2d 33 31 20 0a 00                                   -31 ..

00000e67 <__c.3804>:
     e67:	31 2e 50 4d 20 20 0a 00                             1.PM  ..

00000e6f <__c.3802>:
     e6f:	30 2e 41 4d 20 20 0a 00                             0.AM  ..

00000e77 <__c.3800>:
     e77:	44 69 67 69 74 65 20 65 6c 20 56 61 6c 6f 72 20     Digite el Valor 
     e87:	64 65 20 6c 61 20 48 6f 72 61 20 20 0a 00           de la Hora  ..

00000e95 <__c.3798>:
     e95:	44 69 67 69 74 65 20 65 6c 20 56 61 6c 6f 72 20     Digite el Valor 
     ea5:	65 6e 20 4d 69 6e 75 74 6f 73 2e 20 30 2d 35 39     en Minutos. 0-59
     eb5:	20 0a 00                                             ..

00000eb8 <__c.3796>:
     eb8:	44 69 67 69 74 65 20 65 6c 20 56 61 6c 6f 72 20     Digite el Valor 
     ec8:	65 6e 20 53 65 67 75 6e 64 6f 73 2e 20 30 2d 35     en Segundos. 0-5
     ed8:	39 20 0a 00                                         9 ..

00000edc <__c.3793>:
     edc:	4f 74 72 61 20 4f 70 63 69 6f 6e 3a 20 53 61 6c     Otra Opcion: Sal
     eec:	69 72 20 53 75 62 4d 65 6e 75 20 0a 00              ir SubMenu ..

00000ef9 <__c.3791>:
     ef9:	35 2e 20 4c 65 65 72 20 65 6c 20 43 6f 6e 74 72     5. Leer el Contr
     f09:	6f 6c 20 64 65 20 52 65 67 69 73 74 72 6f 73 20     ol de Registros 
     f19:	64 65 6c 20 52 54 43 20 0a 00                       del RTC ..

00000f23 <__c.3789>:
     f23:	34 2e 20 4c 65 65 72 20 45 6c 20 53 74 61 74 75     4. Leer El Statu
     f33:	73 20 52 65 67 69 73 74 65 72 20 64 65 6c 20 52     s Register del R
     f43:	54 43 20 0a 00                                      TC ..

00000f48 <__c.3787>:
     f48:	33 2e 20 4c 65 65 72 20 46 65 63 68 61 20 0a 00     3. Leer Fecha ..

00000f58 <__c.3785>:
     f58:	32 2e 20 43 6f 6e 66 69 67 75 72 61 72 20 41 6c     2. Configurar Al
     f68:	61 72 6d 61 20 0a 00                                arma ..

00000f6f <__c.3783>:
     f6f:	31 2e 20 45 73 63 72 69 62 69 72 20 65 6e 20 65     1. Escribir en e
     f7f:	6c 20 43 6f 6e 74 72 6f 6c 20 64 65 20 52 65 67     l Control de Reg
     f8f:	69 73 74 72 6f 73 20 64 65 6c 20 52 54 43 20 0a     istros del RTC .
	...

00000fa0 <__c.3781>:
     fa0:	30 2e 20 45 73 63 72 69 62 69 72 20 46 65 63 68     0. Escribir Fech
     fb0:	61 20 0a 00                                         a ..

00000fb4 <__c.3777>:
     fb4:	44 69 67 69 74 65 20 65 6c 20 76 61 6c 6f 72 20     Digite el valor 
     fc4:	64 65 6c 20 54 72 69 67 67 65 72 20 0a 00           del Trigger ..

00000fd2 <__c.3775>:
     fd2:	31 30 2e 53 69 67 6e 61 6c 53 74 61 74 75 73 2e     10.SignalStatus.
     fe2:	20 0a 00                                             ..

00000fe5 <__c.3773>:
     fe5:	39 2e 20 41 63 74 69 76 69 74 79 53 74 61 74 75     9. ActivityStatu
     ff5:	73 2e 20 0a 00                                      s. ..

00000ffa <__c.3771>:
     ffa:	38 2e 20 45 76 65 6e 74 53 74 61 74 75 73 2e 20     8. EventStatus. 
    100a:	0a 00                                               ..

0000100c <__c.3769>:
    100c:	37 2e 20 54 69 6d 65 2e 20 0a 00                    7. Time. ..

00001017 <__c.3767>:
    1017:	36 2e 20 41 63 74 75 61 6c 50 6f 73 69 74 69 6f     6. ActualPositio
    1027:	6e 43 72 6f 73 73 65 64 2e 20 0a 00                 nCrossed. ..

00001033 <__c.3765>:
    1033:	35 2e 20 43 6f 6d 6d 61 6e 64 65 64 50 6f 73 69     5. CommandedPosi
    1043:	74 69 6f 6e 43 72 6f 73 73 65 64 2e 20 0a 00        tionCrossed. ..

00001052 <__c.3763>:
    1052:	34 2e 20 4c 65 73 73 65 72 4f 72 45 71 75 61 6c     4. LesserOrEqual
    1062:	41 63 74 75 61 6c 50 6f 73 69 74 69 6f 6e 2e 20     ActualPosition. 
    1072:	0a 00                                               ..

00001074 <__c.3761>:
    1074:	33 2e 20 47 72 65 61 74 65 72 4f 72 45 71 75 61     3. GreaterOrEqua
    1084:	6c 41 63 74 75 61 6c 50 6f 73 69 74 69 6f 6e 2e     lActualPosition.
    1094:	20 0a 00                                             ..

00001097 <__c.3759>:
    1097:	32 2e 20 4c 65 73 73 65 72 4f 72 45 71 75 61 6c     2. LesserOrEqual
    10a7:	43 6f 6d 6d 61 6e 64 65 64 50 6f 73 69 74 69 6f     CommandedPositio
    10b7:	6e 2e 20 0a 00                                      n. ..

000010bc <__c.3757>:
    10bc:	31 2e 20 47 72 65 61 74 65 72 4f 72 45 71 75 61     1. GreaterOrEqua
    10cc:	6c 43 6f 6d 6d 61 6e 64 65 64 50 6f 73 69 74 69     lCommandedPositi
    10dc:	6f 6e 2e 20 0a 00                                   on. ..

000010e2 <__c.3755>:
    10e2:	30 2e 20 4e 69 6e 67 75 6e 6f 2e 20 0a 00           0. Ninguno. ..

000010f0 <__c.3753>:
    10f0:	44 69 67 69 74 65 20 65 6c 20 54 52 49 47 47 45     Digite el TRIGGE
    1100:	52 20 64 65 6c 20 42 72 65 61 6b 50 6f 69 6e 74     R del BreakPoint
    1110:	20 0a 00                                             ..

00001113 <__c.3751>:
    1113:	34 2e 4d 6f 74 6f 72 5f 4f 46 46 2e 20 0a 00        4.Motor_OFF. ..

00001122 <__c.3749>:
    1122:	33 2e 20 53 6d 6f 6f 74 68 53 74 6f 70 2e 20 0a     3. SmoothStop. .
	...

00001133 <__c.3747>:
    1133:	32 2e 20 41 62 72 75 70 74 53 74 6f 70 2e 20 0a     2. AbruptStop. .
	...

00001144 <__c.3745>:
    1144:	31 2e 20 55 70 64 61 74 65 2e 20 0a 00              1. Update. ..

00001151 <__c.3743>:
    1151:	30 2e 4e 69 6e 67 75 6e 61 20 41 63 63 69 6f 6e     0.Ninguna Accion
    1161:	2e 20 0a 00                                         . ..

00001165 <__c.3741>:
    1165:	44 69 67 69 74 65 20 6c 61 20 61 63 63 69 6f 6e     Digite la accion
    1175:	20 64 65 6c 20 42 72 65 61 6b 50 6f 69 6e 74 20      del BreakPoint 
    1185:	0a 00                                               ..

00001187 <__c.3739>:
    1187:	34 2e 52 6f 6c 6c 2e 20 0a 00                       4.Roll. ..

00001191 <__c.3737>:
    1191:	33 2e 20 50 69 74 63 68 2e 20 0a 00                 3. Pitch. ..

0000119d <__c.3735>:
    119d:	32 2e 20 43 6f 64 6f 2e 20 0a 00                    2. Codo. ..

000011a8 <__c.3733>:
    11a8:	31 2e 20 48 6f 6d 62 72 6f 2e 20 0a 00              1. Hombro. ..

000011b5 <__c.3731>:
    11b5:	30 2e 20 43 69 6e 74 75 72 61 2e 20 0a 00           0. Cintura. ..

000011c3 <__c.3729>:
    11c3:	44 69 67 69 74 65 20 65 6c 20 45 6a 65 20 46 75     Digite el Eje Fu
    11d3:	65 6e 74 65 20 28 73 6f 75 72 63 65 29 20 64 65     ente (source) de
    11e3:	6c 20 42 72 65 61 6b 50 6f 69 6e 74 20 0a 00        l BreakPoint ..

000011f2 <__c.3727>:
    11f2:	31 2e 20 42 72 65 61 6b 50 6f 69 6e 74 32 2e 20     1. BreakPoint2. 
    1202:	0a 00                                               ..

00001204 <__c.3725>:
    1204:	30 2e 20 42 72 65 61 6b 50 6f 69 6e 74 31 2e 20     0. BreakPoint1. 
    1214:	0a 00                                               ..

00001216 <__c.3723>:
    1216:	44 69 67 69 74 65 20 65 6c 20 20 42 72 65 61 6b     Digite el  Break
    1226:	50 6f 69 6e 74 5f 49 44 20 0a 00                    Point_ID ..

00001231 <__c.3721>:
    1231:	34 2e 52 6f 6c 6c 2e 20 0a 00                       4.Roll. ..

0000123b <__c.3719>:
    123b:	33 2e 20 50 69 74 63 68 2e 20 0a 00                 3. Pitch. ..

00001247 <__c.3717>:
    1247:	32 2e 20 43 6f 64 6f 2e 20 0a 00                    2. Codo. ..

00001252 <__c.3715>:
    1252:	31 2e 20 48 6f 6d 62 72 6f 2e 20 0a 00              1. Hombro. ..

0000125f <__c.3713>:
    125f:	30 2e 20 43 69 6e 74 75 72 61 2e 20 0a 00           0. Cintura. ..

0000126d <__c.3711>:
    126d:	44 69 67 69 74 65 20 65 6c 20 65 6a 65 20 65 6c     Digite el eje el
    127d:	20 63 75 61 6c 20 63 6f 6e 66 69 67 75 72 61 72      cual configurar
    128d:	61 20 65 6c 20 42 72 65 61 6b 50 6f 69 6e 74 20     a el BreakPoint 
    129d:	0a 00                                               ..

0000129f <__c.3705>:
    129f:	34 2e 52 6f 6c 6c 2e 20 0a 00                       4.Roll. ..

000012a9 <__c.3703>:
    12a9:	33 2e 20 50 69 74 63 68 2e 20 0a 00                 3. Pitch. ..

000012b5 <__c.3701>:
    12b5:	32 2e 20 43 6f 64 6f 2e 20 0a 00                    2. Codo. ..

000012c0 <__c.3699>:
    12c0:	31 2e 20 48 6f 6d 62 72 6f 2e 20 0a 00              1. Hombro. ..

000012cd <__c.3697>:
    12cd:	30 2e 20 43 69 6e 74 75 72 61 2e 20 0a 00           0. Cintura. ..

000012db <__c.3695>:
    12db:	44 69 67 69 74 65 20 6c 61 20 61 72 74 69 63 75     Digite la articu
    12eb:	6c 61 63 69 6f 6e 20 61 20 63 6f 6e 66 69 67 75     lacion a configu
    12fb:	72 61 72 20 0a 00                                   rar ..

00001301 <__c.3693>:
    1301:	4f 74 72 61 20 4f 70 63 69 6f 6e 3a 20 53 61 6c     Otra Opcion: Sal
    1311:	69 72 20 53 75 62 4d 65 6e 75 20 0a 00              ir SubMenu ..

0000131e <__c.3691>:
    131e:	32 2e 20 43 6f 6e 66 69 67 75 72 61 72 20 42 72     2. Configurar Br
    132e:	65 61 6b 50 6f 69 6e 74 20 0a 00                    eakPoint ..

00001339 <__c.3689>:
    1339:	31 2e 20 48 61 6c 6c 61 72 20 4e 65 73 74 20 79     1. Hallar Nest y
    1349:	20 6d 61 78 20 79 20 6d 69 6e 20 70 6f 73 69 63      max y min posic
    1359:	69 6f 6e 20 0a 00                                   ion ..

0000135f <__c.3687>:
    135f:	30 2e 20 52 65 61 6c 69 7a 61 72 20 50 72 6f 63     0. Realizar Proc
    136f:	65 73 6f 20 64 65 20 43 61 6c 69 62 72 61 63 69     eso de Calibraci
    137f:	6f 6e 20 0a 00                                      on ..

00001384 <__c.3683>:
    1384:	44 69 67 69 74 65 20 65 6c 20 76 61 6c 6f 72 20     Digite el valor 
    1394:	64 65 20 6c 61 20 70 6f 73 69 63 69 6f 6e 20 61     de la posicion a
    13a4:	20 61 6a 75 73 74 61 72 20 0a 00                     ajustar ..

000013af <__c.3675>:
    13af:	34 2e 52 6f 6c 6c 2e 20 0a 00                       4.Roll. ..

000013b9 <__c.3673>:
    13b9:	33 2e 20 50 69 74 63 68 2e 20 0a 00                 3. Pitch. ..

000013c5 <__c.3671>:
    13c5:	32 2e 20 43 6f 64 6f 2e 20 0a 00                    2. Codo. ..

000013d0 <__c.3669>:
    13d0:	31 2e 20 48 6f 6d 62 72 6f 2e 20 0a 00              1. Hombro. ..

000013dd <__c.3667>:
    13dd:	30 2e 20 43 69 6e 74 75 72 61 2e 20 0a 00           0. Cintura. ..

000013eb <__c.3665>:
    13eb:	44 69 67 69 74 65 20 6c 61 20 61 72 74 69 63 75     Digite la articu
    13fb:	6c 61 63 69 6f 6e 20 71 75 65 20 71 75 69 65 72     lacion que quier
    140b:	65 20 4c 65 65 72 20 6f 20 41 6a 75 73 74 61 72     e Leer o Ajustar
    141b:	0a 00                                               ..

0000141d <__c.3663>:
    141d:	4f 74 72 61 20 4f 70 63 69 6f 6e 3a 20 53 61 6c     Otra Opcion: Sal
    142d:	69 72 20 53 75 62 4d 65 6e 75 20 0a 00              ir SubMenu ..

0000143a <__c.3661>:
    143a:	34 2e 20 41 6a 75 73 74 61 72 20 50 6f 73 69 63     4. Ajustar Posic
    144a:	69 6f 6e 20 0a 00                                   ion ..

00001450 <__c.3659>:
    1450:	33 2e 20 53 69 67 6e 61 6c 20 53 74 61 74 75 73     3. Signal Status
    1460:	20 0a 00                                             ..

00001463 <__c.3657>:
    1463:	32 2e 20 4c 65 63 74 75 72 61 20 64 65 6c 20 41     2. Lectura del A
    1473:	63 74 69 76 69 74 79 20 53 74 61 74 75 73 20 52     ctivity Status R
    1483:	65 67 69 73 74 65 72 20 0a 00                       egister ..

0000148d <__c.3655>:
    148d:	31 2e 20 4c 65 63 74 75 72 61 20 64 65 6c 20 45     1. Lectura del E
    149d:	76 65 6e 74 20 53 74 61 74 75 73 20 52 65 67 69     vent Status Regi
    14ad:	73 74 65 72 20 0a 00                                ster ..

000014b4 <__c.3653>:
    14b4:	30 2e 20 49 6e 66 6f 72 6d 61 63 69 6f 6e 20 4d     0. Informacion M
    14c4:	6f 76 69 6d 69 65 6e 74 6f 0a 00                    ovimiento..

000014cf <__c.3642>:
    14cf:	44 69 67 69 74 65 20 61 63 65 6c 65 72 61 63 69     Digite aceleraci
    14df:	6f 6e 3f 20 0a 00                                   on? ..

000014e5 <__c.3640>:
    14e5:	44 69 67 69 74 65 20 56 65 6c 6f 63 69 64 61 64     Digite Velocidad
    14f5:	3f 20 0a 00                                         ? ..

000014f9 <__c.3638>:
    14f9:	44 69 67 69 74 65 20 50 6f 73 69 63 69 6f 6e 3f     Digite Posicion?
    1509:	20 0a 00                                             ..

0000150c <__c.3636>:
    150c:	4f 74 72 61 20 4f 70 63 69 6f 6e 3a 20 53 61 6c     Otra Opcion: Sal
    151c:	69 72 20 53 75 62 4d 65 6e 75 20 0a 00              ir SubMenu ..

00001529 <__c.3634>:
    1529:	34 2e 52 6f 6c 6c 2e 20 0a 00                       4.Roll. ..

00001533 <__c.3632>:
    1533:	33 2e 20 50 69 74 63 68 2e 20 0a 00                 3. Pitch. ..

0000153f <__c.3630>:
    153f:	32 2e 20 43 6f 64 6f 2e 20 0a 00                    2. Codo. ..

0000154a <__c.3628>:
    154a:	31 2e 20 48 6f 6d 62 72 6f 2e 20 0a 00              1. Hombro. ..

00001557 <__c.3626>:
    1557:	30 2e 20 43 69 6e 74 75 72 61 2e 20 0a 00           0. Cintura. ..

00001565 <__c.3624>:
    1565:	44 69 67 69 74 65 20 41 72 74 69 63 75 6c 61 63     Digite Articulac
    1575:	69 6f 6e 20 61 20 6d 6f 76 65 72 20 0a 00           ion a mover ..

00001583 <__c.3621>:
    1583:	4f 74 72 61 20 4f 70 63 69 6f 6e 3a 20 50 61 72     Otra Opcion: Par
    1593:	61 64 61 20 53 75 61 76 65 20 0a 00                 ada Suave ..

0000159f <__c.3619>:
    159f:	38 2e 46 75 6e 63 69 6f 6e 65 73 20 70 61 72 61     8.Funciones para
    15af:	20 44 45 42 55 47 20 0a 00                           DEBUG ..

000015b8 <__c.3617>:
    15b8:	37 2e 46 75 6e 63 69 6f 6e 65 73 20 64 65 20 47     7.Funciones de G
    15c8:	72 69 70 70 65 72 20 0a 00                          ripper ..

000015d1 <__c.3615>:
    15d1:	36 2e 52 65 73 65 74 20 45 76 65 6e 74 20 53 74     6.Reset Event St
    15e1:	61 74 75 73 20 52 65 67 69 73 74 65 72 20 0a 00     atus Register ..

000015f1 <__c.3613>:
    15f1:	35 2e 46 75 6e 63 69 6f 6e 65 73 20 64 65 20 54     5.Funciones de T
    1601:	72 61 7a 6f 20 65 20 49 6d 70 72 65 73 69 6f 6e     razo e Impresion
    1611:	20 64 65 20 56 61 72 69 61 62 6c 65 73 20 0a 00      de Variables ..

00001621 <__c.3611>:
    1621:	34 2e 46 75 6e 63 69 6f 6e 65 73 20 64 65 20 4d     4.Funciones de M
    1631:	61 6e 65 6a 6f 20 44 65 20 45 45 50 52 4f 4d 0a     anejo De EEPROM.
	...

00001642 <__c.3609>:
    1642:	33 2e 46 75 6e 63 69 6f 6e 65 73 20 64 65 6c 20     3.Funciones del 
    1652:	52 65 6c 6f 6a 20 64 65 20 54 69 65 6d 70 6f 20     Reloj de Tiempo 
    1662:	52 65 61 6c 20 0a 00                                Real ..

00001669 <__c.3607>:
    1669:	32 2e 46 75 6e 63 69 6f 6e 65 73 20 64 65 20 43     2.Funciones de C
    1679:	61 6c 69 62 72 61 63 69 6f 6e 2d 41 6a 75 73 74     alibracion-Ajust
    1689:	65 2d 42 72 65 61 6b 70 6f 69 6e 74 0a 00           e-Breakpoint..

00001697 <__c.3605>:
    1697:	31 2e 46 75 6e 63 69 6f 6e 65 73 20 64 65 20 69     1.Funciones de i
    16a7:	6e 66 6f 72 6d 61 63 69 6f 6e 20 64 65 20 4d 6f     nformacion de Mo
    16b7:	76 69 6d 69 65 6e 74 6f 0a 00                       vimiento..

000016c1 <__c.3603>:
    16c1:	30 2e 46 75 6e 63 69 6f 6e 65 73 20 64 65 20 4d     0.Funciones de M
    16d1:	6f 76 69 6d 69 65 6e 74 6f 0a 00                    ovimiento..

000016dc <__c.3601>:
    16dc:	54 65 73 69 73 20 64 65 20 47 72 61 64 6f 20 4a     Tesis de Grado J
    16ec:	41 52 42 4f 54 45 52 20 56 32 2e 31 2e 20 0a 20     ARBOTER V2.1. . 
    16fc:	0a 00                                               ..

000016fe <__c.3599>:
    16fe:	2f 6e 20 2f 6e 20 50 52 4f 47 52 41 4d 41 20 44     /n /n PROGRAMA D
    170e:	45 20 50 52 55 45 42 41 53 20 59 20 44 45 50 55     E PRUEBAS Y DEPU
    171e:	52 41 43 49 4f 4e 20 2e 0a 00                       RACION ...

00001728 <__c.3597>:
    1728:	41 70 61 67 75 65 20 65 6c 20 63 6f 6e 74 72 6f     Apague el contro
    1738:	6c 61 64 6f 72 20 0a 00                             lador ..

00001740 <__c.3657>:
    1740:	45 72 72 6f 72 20 65 6e 20 65 6c 20 43 6f 6e 74     Error en el Cont
    1750:	72 6f 6c 61 64 6f 72 20 64 65 20 6d 6f 74 6f 72     rolador de motor
    1760:	65 73 20 4e 6f 2e 20 32 20 0a 00                    es No. 2 ..

0000176b <__c.3655>:
    176b:	45 72 72 6f 72 20 65 6e 20 43 6f 6e 74 72 6f 6c     Error en Control
    177b:	61 64 6f 72 20 32 20 0a 00                          ador 2 ..

00001784 <__c.3653>:
    1784:	45 72 72 6f 72 20 65 6e 20 65 6c 20 43 6f 6e 74     Error en el Cont
    1794:	72 6f 6c 61 64 6f 72 20 64 65 20 6d 6f 74 6f 72     rolador de motor
    17a4:	65 73 20 4e 6f 2e 20 31 20 0a 00                    es No. 1 ..

000017af <__c.3651>:
    17af:	45 72 72 6f 72 20 65 6e 20 43 6f 6e 74 72 6f 6c     Error en Control
    17bf:	61 64 6f 72 20 31 20 0a 00                          ador 1 ..

000017c8 <__c.3412>:
    17c8:	43 61 62 6c 65 20 23 32 20 64 65 20 73 65 6e 73     Cable #2 de sens
    17d8:	6f 72 65 73 20 64 65 73 63 6f 6e 65 63 74 61 64     ores desconectad
    17e8:	6f 20 0a 00                                         o ..

000017ec <__c.3410>:
    17ec:	43 61 62 6c 65 20 23 31 20 64 65 20 73 65 6e 73     Cable #1 de sens
    17fc:	6f 72 65 73 20 64 65 73 63 6f 6e 65 63 74 61 64     ores desconectad
    180c:	6f 20 0a 00                                         o ..

00001810 <__c.3408>:
    1810:	42 6f 74 6f 6e 20 64 65 20 50 61 72 61 64 61 20     Boton de Parada 
    1820:	64 65 20 45 6d 65 72 67 65 6e 63 69 61 20 41 63     de Emergencia Ac
    1830:	74 69 76 6f 20 0a 00                                tivo ..

00001837 <__c.3319>:
    1837:	45 72 72 6f 72 20 64 65 20 49 6e 73 74 72 75 63     Error de Instruc
    1847:	63 69 6f 6e 20 0a 00                                cion ..

0000184e <__c.3257>:
    184e:	20 45 72 72 6f 72 20 64 65 20 4d 6f 76 69 6d 69      Error de Movimi
    185e:	65 6e 74 6f 20 0a 00                                ento ..

00001865 <__c.1790>:
    1865:	6e 61 6e 00                                         nan.

00001869 <__c.1788>:
    1869:	69 6e 66 00                                         inf.

0000186d <__c.2085>:
    186d:	63 64 69 6e 6f 70 73 75 78 58 5b 65 66 67 45 46     cdinopsuxX[efgEF
    187d:	47 00                                               G.

0000187f <pstr_an>:
    187f:	61 6e 00                                            an.

00001882 <pstr_nfinity>:
    1882:	6e 66 69 6e 69 74 79 00                             nfinity.

0000188a <pwr_m10>:
    188a:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
    189a:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

000018a2 <pwr_p10>:
    18a2:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
    18b2:	ca 1b 0e 5a ae c5 9d 74 00 40 7a 10 f3 5a 00 a0     ...Z...t.@z..Z..
    18c2:	72 4e 18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00     rN..........vH..
    18d2:	00 e4 0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05     ...T.....;......
    18e2:	00 00 80 96 98 00 00 00 40 42 0f 00 00 00 a0 86     ........@B......
    18f2:	01 00 00 00 10 27 00 00 00 00 e8 03 00 00 00 00     .....'..........
    1902:	64 00 00 00 00 00 0a 00 00 00 00 00 01 00 00 00     d...............
    1912:	00 00 2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59     ..,v...gO.#....Y
    1922:	e1 b1 b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8     .......S.:.Q.v..
    1932:	e6 c2 84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc     ...&....b.@|o...
    1942:	9c 9f 40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93     ..@...o....Z*.\.
    1952:	6b 6c f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6     kl.gm......G.. .
    1962:	b5 00 d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e     .........5w.....
    1972:	08 00 00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f     ... N......3333.
    1982:	98 6e 12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf     .n...A..!..;.U..
    1992:	fe e6 db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb     ......K8..|.....
    19a2:	e4 24 20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5     .$ 2.r^"....$...
    19b2:	3d 27                                               ='

000019b4 <__ctors_end>:
    19b4:	11 24       	eor	r1, r1
    19b6:	1f be       	out	0x3f, r1	; 63
    19b8:	cf ef       	ldi	r28, 0xFF	; 255
    19ba:	d1 e2       	ldi	r29, 0x21	; 33
    19bc:	de bf       	out	0x3e, r29	; 62
    19be:	cd bf       	out	0x3d, r28	; 61

000019c0 <Init_EXRAM>:



void Init_EXRAM (void) 
{ 
	XMCRA		=	_BV(SRE) | _BV(SRW11) | _BV(SRW10);	
    19c0:	8c e8       	ldi	r24, 0x8C	; 140
    19c2:	80 93 74 00 	sts	0x0074, r24
	XMCRB 		= 	0x00; 
    19c6:	10 92 75 00 	sts	0x0075, r1

000019ca <__do_copy_data>:
}
    19ca:	14 e7       	ldi	r17, 0x74	; 116
    19cc:	a0 e0       	ldi	r26, 0x00	; 0
    19ce:	b2 e2       	ldi	r27, 0x22	; 34
    19d0:	ec eb       	ldi	r30, 0xBC	; 188
    19d2:	f1 e4       	ldi	r31, 0x41	; 65
    19d4:	01 e0       	ldi	r16, 0x01	; 1
    19d6:	0b bf       	out	0x3b, r16	; 59
    19d8:	02 c0       	rjmp	.+4      	; 0x19de <__do_copy_data+0x14>
    19da:	07 90       	elpm	r0, Z+
    19dc:	0d 92       	st	X+, r0
    19de:	aa 3a       	cpi	r26, 0xAA	; 170
    19e0:	b1 07       	cpc	r27, r17
    19e2:	d9 f7       	brne	.-10     	; 0x19da <__do_copy_data+0x10>

000019e4 <__do_clear_bss>:
    19e4:	19 e7       	ldi	r17, 0x79	; 121
    19e6:	aa ea       	ldi	r26, 0xAA	; 170
    19e8:	b4 e7       	ldi	r27, 0x74	; 116
    19ea:	01 c0       	rjmp	.+2      	; 0x19ee <.do_clear_bss_start>

000019ec <.do_clear_bss_loop>:
    19ec:	1d 92       	st	X+, r1

000019ee <.do_clear_bss_start>:
    19ee:	a4 3d       	cpi	r26, 0xD4	; 212
    19f0:	b1 07       	cpc	r27, r17
    19f2:	e1 f7       	brne	.-8      	; 0x19ec <.do_clear_bss_loop>
    19f4:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <main>
    19f8:	0c 94 dc a0 	jmp	0x141b8	; 0x141b8 <_exit>

000019fc <__bad_interrupt>:
    19fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001a00 <main>:
	


int
main(void)
{
    1a00:	2f 92       	push	r2
    1a02:	3f 92       	push	r3
    1a04:	4f 92       	push	r4
    1a06:	5f 92       	push	r5
    1a08:	6f 92       	push	r6
    1a0a:	7f 92       	push	r7
    1a0c:	8f 92       	push	r8
    1a0e:	9f 92       	push	r9
    1a10:	af 92       	push	r10
    1a12:	bf 92       	push	r11
    1a14:	cf 92       	push	r12
    1a16:	df 92       	push	r13
    1a18:	ef 92       	push	r14
    1a1a:	ff 92       	push	r15
    1a1c:	0f 93       	push	r16
    1a1e:	1f 93       	push	r17
    1a20:	df 93       	push	r29
    1a22:	cf 93       	push	r28
    1a24:	cd b7       	in	r28, 0x3d	; 61
    1a26:	de b7       	in	r29, 0x3e	; 62
    1a28:	c5 59       	subi	r28, 0x95	; 149
    1a2a:	d0 40       	sbci	r29, 0x00	; 0
    1a2c:	0f b6       	in	r0, 0x3f	; 63
    1a2e:	f8 94       	cli
    1a30:	de bf       	out	0x3e, r29	; 62
    1a32:	0f be       	out	0x3f, r0	; 63
    1a34:	cd bf       	out	0x3d, r28	; 61

	
	
	
	//Variables EEPROM
	int16 memory[10]={2,4,6,8,10,12,14,16,18,20};
    1a36:	de 01       	movw	r26, r28
    1a38:	ab 5a       	subi	r26, 0xAB	; 171
    1a3a:	bf 4f       	sbci	r27, 0xFF	; 255
    1a3c:	e9 eb       	ldi	r30, 0xB9	; 185
    1a3e:	f6 e2       	ldi	r31, 0x26	; 38
    1a40:	84 e1       	ldi	r24, 0x14	; 20
    1a42:	01 90       	ld	r0, Z+
    1a44:	0d 92       	st	X+, r0
    1a46:	81 50       	subi	r24, 0x01	; 1
    1a48:	e1 f7       	brne	.-8      	; 0x1a42 <main+0x42>
	
	//Variables Prueba Get_Trajectory
	
	//uint16 id_vector_PC[5] ={5,2,3,7,8};
	
	initCard();							//inicializa el Atmega 1280.
    1a4a:	0e 94 ba 3b 	call	0x7774	; 0x7774 <initCard>
	uart_init();						//Inicializa la UART a 9600 Bd, tx/rx, 8N1.
    1a4e:	0e 94 75 84 	call	0x108ea	; 0x108ea <uart_init>
	lcd_init();
    1a52:	0e 94 19 86 	call	0x10c32	; 0x10c32 <lcd_init>
	rtc_init();							//Inicializacion RTC	
    1a56:	0e 94 53 89 	call	0x112a6	; 0x112a6 <rtc_init>
	stdout = stdin = &uart_str;
    1a5a:	8d e9       	ldi	r24, 0x9D	; 157
    1a5c:	96 e2       	ldi	r25, 0x26	; 38
    1a5e:	90 93 cf 79 	sts	0x79CF, r25
    1a62:	80 93 ce 79 	sts	0x79CE, r24
    1a66:	90 93 d1 79 	sts	0x79D1, r25
    1a6a:	80 93 d0 79 	sts	0x79D0, r24
	stderr = &lcd_str;
    1a6e:	8b ea       	ldi	r24, 0xAB	; 171
    1a70:	96 e2       	ldi	r25, 0x26	; 38
    1a72:	90 93 d3 79 	sts	0x79D3, r25
    1a76:	80 93 d2 79 	sts	0x79D2, r24
	
	Led_on(Amarillo);	
    1a7a:	82 e0       	ldi	r24, 0x02	; 2
    1a7c:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
	delay_1s();	
    1a80:	0e 94 37 8d 	call	0x11a6e	; 0x11a6e <delay_1s>
	Led_on(Verde);	
    1a84:	80 e0       	ldi	r24, 0x00	; 0
    1a86:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
	delay_1s();	
    1a8a:	0e 94 37 8d 	call	0x11a6e	; 0x11a6e <delay_1s>
	Led_on(Rojo);	
    1a8e:	81 e0       	ldi	r24, 0x01	; 1
    1a90:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
	delay_1s();	
    1a94:	0e 94 37 8d 	call	0x11a6e	; 0x11a6e <delay_1s>
	Led_off(Rojo);
    1a98:	81 e0       	ldi	r24, 0x01	; 1
    1a9a:	90 e0       	ldi	r25, 0x00	; 0
    1a9c:	0e 94 b9 8d 	call	0x11b72	; 0x11b72 <Led_off>
	Led_off(Verde);
    1aa0:	80 e0       	ldi	r24, 0x00	; 0
    1aa2:	90 e0       	ldi	r25, 0x00	; 0
    1aa4:	0e 94 b9 8d 	call	0x11b72	; 0x11b72 <Led_off>
	Led_off(Amarillo);
    1aa8:	82 e0       	ldi	r24, 0x02	; 2
    1aaa:	90 e0       	ldi	r25, 0x00	; 0
    1aac:	0e 94 b9 8d 	call	0x11b72	; 0x11b72 <Led_off>
	
	
	
	if(selftestPMD()!=rcOK)
    1ab0:	0e 94 ee 44 	call	0x89dc	; 0x89dc <selftestPMD>
    1ab4:	89 2b       	or	r24, r25
    1ab6:	e1 f0       	breq	.+56     	; 0x1af0 <main+0xf0>
	{
		fprintf_P(stderr,PSTR("Apague el controlador \n"));
    1ab8:	00 d0       	rcall	.+0      	; 0x1aba <main+0xba>
    1aba:	00 d0       	rcall	.+0      	; 0x1abc <main+0xbc>
    1abc:	80 91 d2 79 	lds	r24, 0x79D2
    1ac0:	90 91 d3 79 	lds	r25, 0x79D3
    1ac4:	ad b7       	in	r26, 0x3d	; 61
    1ac6:	be b7       	in	r27, 0x3e	; 62
    1ac8:	12 96       	adiw	r26, 0x02	; 2
    1aca:	9c 93       	st	X, r25
    1acc:	8e 93       	st	-X, r24
    1ace:	11 97       	sbiw	r26, 0x01	; 1
    1ad0:	88 e2       	ldi	r24, 0x28	; 40
    1ad2:	97 e1       	ldi	r25, 0x17	; 23
    1ad4:	14 96       	adiw	r26, 0x04	; 4
    1ad6:	9c 93       	st	X, r25
    1ad8:	8e 93       	st	-X, r24
    1ada:	13 97       	sbiw	r26, 0x03	; 3
    1adc:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		exit(0);
    1ae0:	0f 90       	pop	r0
    1ae2:	0f 90       	pop	r0
    1ae4:	0f 90       	pop	r0
    1ae6:	0f 90       	pop	r0
    1ae8:	80 e0       	ldi	r24, 0x00	; 0
    1aea:	90 e0       	ldi	r25, 0x00	; 0
    1aec:	0e 94 dc a0 	call	0x141b8	; 0x141b8 <_exit>
	}
	
	
	
	#ifdef TRAPEZOIDAL
		PMDsetupChipSets(PMDTrapezoidalProfile);
    1af0:	80 e0       	ldi	r24, 0x00	; 0
    1af2:	0e 94 6d 42 	call	0x84da	; 0x84da <PMDsetupChipSets>
	#else
		PMDsetupChipSets(PMDVelocityContouringProfile);
	#endif
	
#ifdef TRAPEZOIDAL
	Memoryconfig();
    1af6:	0e 94 d2 48 	call	0x91a4	; 0x91a4 <Memoryconfig>
	checkconnect();	
    1afa:	0e 94 92 6b 	call	0xd724	; 0xd724 <checkconnect>
	go_home();
    1afe:	0e 94 e5 5e 	call	0xbdca	; 0xbdca <go_home>
	
   EIFR=0xFF;   //Borro flasas interrupnes al inizializar PMDs, ver pag 79 del manual atemega1280
    1b02:	8f ef       	ldi	r24, 0xFF	; 255
    1b04:	8c bb       	out	0x1c, r24	; 28
	             //Para evitar el problema de la interrupcion al inicializar el controlador
					 
/**	 enable interrupts 	*/

	HostInterruptEnable();
    1b06:	0e 94 ef 75 	call	0xebde	; 0xebde <HostInterruptEnable>
	sei();
    1b0a:	78 94       	sei
	
	fprintf(stderr, "Robot Jarboter Controller.\n");
    1b0c:	60 91 d2 79 	lds	r22, 0x79D2
    1b10:	70 91 d3 79 	lds	r23, 0x79D3
    1b14:	80 e0       	ldi	r24, 0x00	; 0
    1b16:	92 e2       	ldi	r25, 0x22	; 34
    1b18:	0e 94 9e 9f 	call	0x13f3c	; 0x13f3c <fputs>


	//Se resetea el Event Status Register en todos los ejes y se borra el Error
	
	
	Clear_Position_Error();	
    1b1c:	0e 94 3e 41 	call	0x827c	; 0x827c <Clear_Position_Error>
	Reset_Even_Status_Register();
    1b20:	0e 94 65 41 	call	0x82ca	; 0x82ca <Reset_Even_Status_Register>
    1b24:	88 ee       	ldi	r24, 0xE8	; 232
    1b26:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1b28:	28 ec       	ldi	r18, 0xC8	; 200
    1b2a:	30 e0       	ldi	r19, 0x00	; 0
    1b2c:	f9 01       	movw	r30, r18
    1b2e:	31 97       	sbiw	r30, 0x01	; 1
    1b30:	f1 f7       	brne	.-4      	; 0x1b2e <main+0x12e>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b32:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b34:	d9 f7       	brne	.-10     	; 0x1b2c <main+0x12c>
	_delay_ms(100);
	Reset_Even_Status_Register();
    1b36:	0e 94 65 41 	call	0x82ca	; 0x82ca <Reset_Even_Status_Register>
						
						scanf("%d",&stop);	
				    break;
					
					case (3):
						Read_Fecha(&Fecha);
    1b3a:	e7 e6       	ldi	r30, 0x67	; 103
    1b3c:	f8 e7       	ldi	r31, 0x78	; 120
    1b3e:	cc 56       	subi	r28, 0x6C	; 108
    1b40:	df 4f       	sbci	r29, 0xFF	; 255
    1b42:	f9 83       	std	Y+1, r31	; 0x01
    1b44:	e8 83       	st	Y, r30
    1b46:	c4 59       	subi	r28, 0x94	; 148
    1b48:	d0 40       	sbci	r29, 0x00	; 0
	Reset_Even_Status_Register();
	
	
	for (;;)
	{  
		fprintf_P(stdout,PSTR("/n /n PROGRAMA DE PRUEBAS Y DEPURACION .\n"));
    1b4a:	00 d0       	rcall	.+0      	; 0x1b4c <main+0x14c>
    1b4c:	00 d0       	rcall	.+0      	; 0x1b4e <main+0x14e>
    1b4e:	80 91 d0 79 	lds	r24, 0x79D0
    1b52:	90 91 d1 79 	lds	r25, 0x79D1
    1b56:	ad b7       	in	r26, 0x3d	; 61
    1b58:	be b7       	in	r27, 0x3e	; 62
    1b5a:	12 96       	adiw	r26, 0x02	; 2
    1b5c:	9c 93       	st	X, r25
    1b5e:	8e 93       	st	-X, r24
    1b60:	11 97       	sbiw	r26, 0x01	; 1
    1b62:	ee ef       	ldi	r30, 0xFE	; 254
    1b64:	f6 e1       	ldi	r31, 0x16	; 22
    1b66:	14 96       	adiw	r26, 0x04	; 4
    1b68:	fc 93       	st	X, r31
    1b6a:	ee 93       	st	-X, r30
    1b6c:	13 97       	sbiw	r26, 0x03	; 3
    1b6e:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		fprintf_P(stdout,PSTR("Tesis de Grado JARBOTER V2.1. \n \n"));
    1b72:	80 91 d0 79 	lds	r24, 0x79D0
    1b76:	90 91 d1 79 	lds	r25, 0x79D1
    1b7a:	ad b7       	in	r26, 0x3d	; 61
    1b7c:	be b7       	in	r27, 0x3e	; 62
    1b7e:	12 96       	adiw	r26, 0x02	; 2
    1b80:	9c 93       	st	X, r25
    1b82:	8e 93       	st	-X, r24
    1b84:	11 97       	sbiw	r26, 0x01	; 1
    1b86:	ec ed       	ldi	r30, 0xDC	; 220
    1b88:	f6 e1       	ldi	r31, 0x16	; 22
    1b8a:	14 96       	adiw	r26, 0x04	; 4
    1b8c:	fc 93       	st	X, r31
    1b8e:	ee 93       	st	-X, r30
    1b90:	13 97       	sbiw	r26, 0x03	; 3
    1b92:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		
		fprintf_P(stdout,PSTR("0.Funciones de Movimiento\n"));
    1b96:	80 91 d0 79 	lds	r24, 0x79D0
    1b9a:	90 91 d1 79 	lds	r25, 0x79D1
    1b9e:	ad b7       	in	r26, 0x3d	; 61
    1ba0:	be b7       	in	r27, 0x3e	; 62
    1ba2:	12 96       	adiw	r26, 0x02	; 2
    1ba4:	9c 93       	st	X, r25
    1ba6:	8e 93       	st	-X, r24
    1ba8:	11 97       	sbiw	r26, 0x01	; 1
    1baa:	e1 ec       	ldi	r30, 0xC1	; 193
    1bac:	f6 e1       	ldi	r31, 0x16	; 22
    1bae:	14 96       	adiw	r26, 0x04	; 4
    1bb0:	fc 93       	st	X, r31
    1bb2:	ee 93       	st	-X, r30
    1bb4:	13 97       	sbiw	r26, 0x03	; 3
    1bb6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		fprintf_P(stdout,PSTR("1.Funciones de informacion de Movimiento\n"));
    1bba:	80 91 d0 79 	lds	r24, 0x79D0
    1bbe:	90 91 d1 79 	lds	r25, 0x79D1
    1bc2:	ad b7       	in	r26, 0x3d	; 61
    1bc4:	be b7       	in	r27, 0x3e	; 62
    1bc6:	12 96       	adiw	r26, 0x02	; 2
    1bc8:	9c 93       	st	X, r25
    1bca:	8e 93       	st	-X, r24
    1bcc:	11 97       	sbiw	r26, 0x01	; 1
    1bce:	e7 e9       	ldi	r30, 0x97	; 151
    1bd0:	f6 e1       	ldi	r31, 0x16	; 22
    1bd2:	14 96       	adiw	r26, 0x04	; 4
    1bd4:	fc 93       	st	X, r31
    1bd6:	ee 93       	st	-X, r30
    1bd8:	13 97       	sbiw	r26, 0x03	; 3
    1bda:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		fprintf_P(stdout,PSTR("2.Funciones de Calibracion-Ajuste-Breakpoint\n"));
    1bde:	80 91 d0 79 	lds	r24, 0x79D0
    1be2:	90 91 d1 79 	lds	r25, 0x79D1
    1be6:	ad b7       	in	r26, 0x3d	; 61
    1be8:	be b7       	in	r27, 0x3e	; 62
    1bea:	12 96       	adiw	r26, 0x02	; 2
    1bec:	9c 93       	st	X, r25
    1bee:	8e 93       	st	-X, r24
    1bf0:	11 97       	sbiw	r26, 0x01	; 1
    1bf2:	e9 e6       	ldi	r30, 0x69	; 105
    1bf4:	f6 e1       	ldi	r31, 0x16	; 22
    1bf6:	14 96       	adiw	r26, 0x04	; 4
    1bf8:	fc 93       	st	X, r31
    1bfa:	ee 93       	st	-X, r30
    1bfc:	13 97       	sbiw	r26, 0x03	; 3
    1bfe:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		fprintf_P(stdout,PSTR("3.Funciones del Reloj de Tiempo Real \n"));
    1c02:	80 91 d0 79 	lds	r24, 0x79D0
    1c06:	90 91 d1 79 	lds	r25, 0x79D1
    1c0a:	ad b7       	in	r26, 0x3d	; 61
    1c0c:	be b7       	in	r27, 0x3e	; 62
    1c0e:	12 96       	adiw	r26, 0x02	; 2
    1c10:	9c 93       	st	X, r25
    1c12:	8e 93       	st	-X, r24
    1c14:	11 97       	sbiw	r26, 0x01	; 1
    1c16:	e2 e4       	ldi	r30, 0x42	; 66
    1c18:	f6 e1       	ldi	r31, 0x16	; 22
    1c1a:	14 96       	adiw	r26, 0x04	; 4
    1c1c:	fc 93       	st	X, r31
    1c1e:	ee 93       	st	-X, r30
    1c20:	13 97       	sbiw	r26, 0x03	; 3
    1c22:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		fprintf_P(stdout,PSTR("4.Funciones de Manejo De EEPROM\n"));
    1c26:	80 91 d0 79 	lds	r24, 0x79D0
    1c2a:	90 91 d1 79 	lds	r25, 0x79D1
    1c2e:	ad b7       	in	r26, 0x3d	; 61
    1c30:	be b7       	in	r27, 0x3e	; 62
    1c32:	12 96       	adiw	r26, 0x02	; 2
    1c34:	9c 93       	st	X, r25
    1c36:	8e 93       	st	-X, r24
    1c38:	11 97       	sbiw	r26, 0x01	; 1
    1c3a:	e1 e2       	ldi	r30, 0x21	; 33
    1c3c:	f6 e1       	ldi	r31, 0x16	; 22
    1c3e:	14 96       	adiw	r26, 0x04	; 4
    1c40:	fc 93       	st	X, r31
    1c42:	ee 93       	st	-X, r30
    1c44:	13 97       	sbiw	r26, 0x03	; 3
    1c46:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		fprintf_P(stdout,PSTR("5.Funciones de Trazo e Impresion de Variables \n"));
    1c4a:	80 91 d0 79 	lds	r24, 0x79D0
    1c4e:	90 91 d1 79 	lds	r25, 0x79D1
    1c52:	ad b7       	in	r26, 0x3d	; 61
    1c54:	be b7       	in	r27, 0x3e	; 62
    1c56:	12 96       	adiw	r26, 0x02	; 2
    1c58:	9c 93       	st	X, r25
    1c5a:	8e 93       	st	-X, r24
    1c5c:	11 97       	sbiw	r26, 0x01	; 1
    1c5e:	e1 ef       	ldi	r30, 0xF1	; 241
    1c60:	f5 e1       	ldi	r31, 0x15	; 21
    1c62:	14 96       	adiw	r26, 0x04	; 4
    1c64:	fc 93       	st	X, r31
    1c66:	ee 93       	st	-X, r30
    1c68:	13 97       	sbiw	r26, 0x03	; 3
    1c6a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		fprintf_P(stdout,PSTR("6.Reset Event Status Register \n"));
    1c6e:	80 91 d0 79 	lds	r24, 0x79D0
    1c72:	90 91 d1 79 	lds	r25, 0x79D1
    1c76:	ad b7       	in	r26, 0x3d	; 61
    1c78:	be b7       	in	r27, 0x3e	; 62
    1c7a:	12 96       	adiw	r26, 0x02	; 2
    1c7c:	9c 93       	st	X, r25
    1c7e:	8e 93       	st	-X, r24
    1c80:	11 97       	sbiw	r26, 0x01	; 1
    1c82:	e1 ed       	ldi	r30, 0xD1	; 209
    1c84:	f5 e1       	ldi	r31, 0x15	; 21
    1c86:	14 96       	adiw	r26, 0x04	; 4
    1c88:	fc 93       	st	X, r31
    1c8a:	ee 93       	st	-X, r30
    1c8c:	13 97       	sbiw	r26, 0x03	; 3
    1c8e:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		fprintf_P(stdout,PSTR("7.Funciones de Gripper \n"));
    1c92:	80 91 d0 79 	lds	r24, 0x79D0
    1c96:	90 91 d1 79 	lds	r25, 0x79D1
    1c9a:	ad b7       	in	r26, 0x3d	; 61
    1c9c:	be b7       	in	r27, 0x3e	; 62
    1c9e:	12 96       	adiw	r26, 0x02	; 2
    1ca0:	9c 93       	st	X, r25
    1ca2:	8e 93       	st	-X, r24
    1ca4:	11 97       	sbiw	r26, 0x01	; 1
    1ca6:	e8 eb       	ldi	r30, 0xB8	; 184
    1ca8:	f5 e1       	ldi	r31, 0x15	; 21
    1caa:	14 96       	adiw	r26, 0x04	; 4
    1cac:	fc 93       	st	X, r31
    1cae:	ee 93       	st	-X, r30
    1cb0:	13 97       	sbiw	r26, 0x03	; 3
    1cb2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		fprintf_P(stdout,PSTR("8.Funciones para DEBUG \n"));
    1cb6:	80 91 d0 79 	lds	r24, 0x79D0
    1cba:	90 91 d1 79 	lds	r25, 0x79D1
    1cbe:	ad b7       	in	r26, 0x3d	; 61
    1cc0:	be b7       	in	r27, 0x3e	; 62
    1cc2:	12 96       	adiw	r26, 0x02	; 2
    1cc4:	9c 93       	st	X, r25
    1cc6:	8e 93       	st	-X, r24
    1cc8:	11 97       	sbiw	r26, 0x01	; 1
    1cca:	ef e9       	ldi	r30, 0x9F	; 159
    1ccc:	f5 e1       	ldi	r31, 0x15	; 21
    1cce:	14 96       	adiw	r26, 0x04	; 4
    1cd0:	fc 93       	st	X, r31
    1cd2:	ee 93       	st	-X, r30
    1cd4:	13 97       	sbiw	r26, 0x03	; 3
    1cd6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		fprintf_P(stdout,PSTR("Otra Opcion: Parada Suave \n"));	
    1cda:	80 91 d0 79 	lds	r24, 0x79D0
    1cde:	90 91 d1 79 	lds	r25, 0x79D1
    1ce2:	ad b7       	in	r26, 0x3d	; 61
    1ce4:	be b7       	in	r27, 0x3e	; 62
    1ce6:	12 96       	adiw	r26, 0x02	; 2
    1ce8:	9c 93       	st	X, r25
    1cea:	8e 93       	st	-X, r24
    1cec:	11 97       	sbiw	r26, 0x01	; 1
    1cee:	e3 e8       	ldi	r30, 0x83	; 131
    1cf0:	f5 e1       	ldi	r31, 0x15	; 21
    1cf2:	14 96       	adiw	r26, 0x04	; 4
    1cf4:	fc 93       	st	X, r31
    1cf6:	ee 93       	st	-X, r30
    1cf8:	13 97       	sbiw	r26, 0x03	; 3
    1cfa:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
		scanf("%d",&menu);		
    1cfe:	ec e1       	ldi	r30, 0x1C	; 28
    1d00:	f2 e2       	ldi	r31, 0x22	; 34
    1d02:	ad b7       	in	r26, 0x3d	; 61
    1d04:	be b7       	in	r27, 0x3e	; 62
    1d06:	12 96       	adiw	r26, 0x02	; 2
    1d08:	fc 93       	st	X, r31
    1d0a:	ee 93       	st	-X, r30
    1d0c:	11 97       	sbiw	r26, 0x01	; 1
    1d0e:	ce 01       	movw	r24, r28
    1d10:	01 96       	adiw	r24, 0x01	; 1
    1d12:	14 96       	adiw	r26, 0x04	; 4
    1d14:	9c 93       	st	X, r25
    1d16:	8e 93       	st	-X, r24
    1d18:	13 97       	sbiw	r26, 0x03	; 3
    1d1a:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
		
		switch (menu)
    1d1e:	0f 90       	pop	r0
    1d20:	0f 90       	pop	r0
    1d22:	0f 90       	pop	r0
    1d24:	0f 90       	pop	r0
    1d26:	89 81       	ldd	r24, Y+1	; 0x01
    1d28:	9a 81       	ldd	r25, Y+2	; 0x02
    1d2a:	84 30       	cpi	r24, 0x04	; 4
    1d2c:	91 05       	cpc	r25, r1
    1d2e:	11 f4       	brne	.+4      	; 0x1d34 <main+0x334>
    1d30:	0c 94 89 20 	jmp	0x4112	; 0x4112 <__stack+0x1f13>
    1d34:	85 30       	cpi	r24, 0x05	; 5
    1d36:	91 05       	cpc	r25, r1
    1d38:	a4 f4       	brge	.+40     	; 0x1d62 <main+0x362>
    1d3a:	81 30       	cpi	r24, 0x01	; 1
    1d3c:	91 05       	cpc	r25, r1
    1d3e:	09 f4       	brne	.+2      	; 0x1d42 <main+0x342>
    1d40:	82 c1       	rjmp	.+772    	; 0x2046 <main+0x646>
    1d42:	82 30       	cpi	r24, 0x02	; 2
    1d44:	91 05       	cpc	r25, r1
    1d46:	24 f4       	brge	.+8      	; 0x1d50 <main+0x350>
    1d48:	89 2b       	or	r24, r25
    1d4a:	01 f1       	breq	.+64     	; 0x1d8c <main+0x38c>
    1d4c:	0c 94 0a 27 	jmp	0x4e14	; 0x4e14 <__stack+0x2c15>
    1d50:	82 30       	cpi	r24, 0x02	; 2
    1d52:	91 05       	cpc	r25, r1
    1d54:	09 f4       	brne	.+2      	; 0x1d58 <main+0x358>
    1d56:	0f c4       	rjmp	.+2078   	; 0x2576 <__stack+0x377>
    1d58:	03 97       	sbiw	r24, 0x03	; 3
    1d5a:	11 f0       	breq	.+4      	; 0x1d60 <main+0x360>
    1d5c:	0c 94 0a 27 	jmp	0x4e14	; 0x4e14 <__stack+0x2c15>
    1d60:	b2 c7       	rjmp	.+3940   	; 0x2cc6 <__stack+0xac7>
    1d62:	86 30       	cpi	r24, 0x06	; 6
    1d64:	91 05       	cpc	r25, r1
    1d66:	11 f4       	brne	.+4      	; 0x1d6c <main+0x36c>
    1d68:	0c 94 97 25 	jmp	0x4b2e	; 0x4b2e <__stack+0x292f>
    1d6c:	86 30       	cpi	r24, 0x06	; 6
    1d6e:	91 05       	cpc	r25, r1
    1d70:	14 f4       	brge	.+4      	; 0x1d76 <main+0x376>
    1d72:	0c 94 c2 24 	jmp	0x4984	; 0x4984 <__stack+0x2785>
    1d76:	87 30       	cpi	r24, 0x07	; 7
    1d78:	91 05       	cpc	r25, r1
    1d7a:	11 f4       	brne	.+4      	; 0x1d80 <main+0x380>
    1d7c:	0c 94 9b 25 	jmp	0x4b36	; 0x4b36 <__stack+0x2937>
    1d80:	08 97       	sbiw	r24, 0x08	; 8
    1d82:	11 f0       	breq	.+4      	; 0x1d88 <main+0x388>
    1d84:	0c 94 0a 27 	jmp	0x4e14	; 0x4e14 <__stack+0x2c15>
    1d88:	0c 94 f0 25 	jmp	0x4be0	; 0x4be0 <__stack+0x29e1>
		{
			case (0)://FUNCIONES DE MOVIMIENTO
				fprintf_P(stdout,PSTR("Digite Articulacion a mover \n"));
    1d8c:	00 d0       	rcall	.+0      	; 0x1d8e <main+0x38e>
    1d8e:	00 d0       	rcall	.+0      	; 0x1d90 <main+0x390>
    1d90:	80 91 d0 79 	lds	r24, 0x79D0
    1d94:	90 91 d1 79 	lds	r25, 0x79D1
    1d98:	ad b7       	in	r26, 0x3d	; 61
    1d9a:	be b7       	in	r27, 0x3e	; 62
    1d9c:	12 96       	adiw	r26, 0x02	; 2
    1d9e:	9c 93       	st	X, r25
    1da0:	8e 93       	st	-X, r24
    1da2:	11 97       	sbiw	r26, 0x01	; 1
    1da4:	85 e6       	ldi	r24, 0x65	; 101
    1da6:	95 e1       	ldi	r25, 0x15	; 21
    1da8:	14 96       	adiw	r26, 0x04	; 4
    1daa:	9c 93       	st	X, r25
    1dac:	8e 93       	st	-X, r24
    1dae:	13 97       	sbiw	r26, 0x03	; 3
    1db0:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("0. Cintura. \n"));
    1db4:	80 91 d0 79 	lds	r24, 0x79D0
    1db8:	90 91 d1 79 	lds	r25, 0x79D1
    1dbc:	ed b7       	in	r30, 0x3d	; 61
    1dbe:	fe b7       	in	r31, 0x3e	; 62
    1dc0:	92 83       	std	Z+2, r25	; 0x02
    1dc2:	81 83       	std	Z+1, r24	; 0x01
    1dc4:	87 e5       	ldi	r24, 0x57	; 87
    1dc6:	95 e1       	ldi	r25, 0x15	; 21
    1dc8:	94 83       	std	Z+4, r25	; 0x04
    1dca:	83 83       	std	Z+3, r24	; 0x03
    1dcc:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("1. Hombro. \n"));
    1dd0:	80 91 d0 79 	lds	r24, 0x79D0
    1dd4:	90 91 d1 79 	lds	r25, 0x79D1
    1dd8:	ad b7       	in	r26, 0x3d	; 61
    1dda:	be b7       	in	r27, 0x3e	; 62
    1ddc:	12 96       	adiw	r26, 0x02	; 2
    1dde:	9c 93       	st	X, r25
    1de0:	8e 93       	st	-X, r24
    1de2:	11 97       	sbiw	r26, 0x01	; 1
    1de4:	8a e4       	ldi	r24, 0x4A	; 74
    1de6:	95 e1       	ldi	r25, 0x15	; 21
    1de8:	14 96       	adiw	r26, 0x04	; 4
    1dea:	9c 93       	st	X, r25
    1dec:	8e 93       	st	-X, r24
    1dee:	13 97       	sbiw	r26, 0x03	; 3
    1df0:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("2. Codo. \n"));
    1df4:	80 91 d0 79 	lds	r24, 0x79D0
    1df8:	90 91 d1 79 	lds	r25, 0x79D1
    1dfc:	ed b7       	in	r30, 0x3d	; 61
    1dfe:	fe b7       	in	r31, 0x3e	; 62
    1e00:	92 83       	std	Z+2, r25	; 0x02
    1e02:	81 83       	std	Z+1, r24	; 0x01
    1e04:	8f e3       	ldi	r24, 0x3F	; 63
    1e06:	95 e1       	ldi	r25, 0x15	; 21
    1e08:	94 83       	std	Z+4, r25	; 0x04
    1e0a:	83 83       	std	Z+3, r24	; 0x03
    1e0c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("3. Pitch. \n"));
    1e10:	80 91 d0 79 	lds	r24, 0x79D0
    1e14:	90 91 d1 79 	lds	r25, 0x79D1
    1e18:	ad b7       	in	r26, 0x3d	; 61
    1e1a:	be b7       	in	r27, 0x3e	; 62
    1e1c:	12 96       	adiw	r26, 0x02	; 2
    1e1e:	9c 93       	st	X, r25
    1e20:	8e 93       	st	-X, r24
    1e22:	11 97       	sbiw	r26, 0x01	; 1
    1e24:	83 e3       	ldi	r24, 0x33	; 51
    1e26:	95 e1       	ldi	r25, 0x15	; 21
    1e28:	14 96       	adiw	r26, 0x04	; 4
    1e2a:	9c 93       	st	X, r25
    1e2c:	8e 93       	st	-X, r24
    1e2e:	13 97       	sbiw	r26, 0x03	; 3
    1e30:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("4.Roll. \n"));
    1e34:	80 91 d0 79 	lds	r24, 0x79D0
    1e38:	90 91 d1 79 	lds	r25, 0x79D1
    1e3c:	ed b7       	in	r30, 0x3d	; 61
    1e3e:	fe b7       	in	r31, 0x3e	; 62
    1e40:	92 83       	std	Z+2, r25	; 0x02
    1e42:	81 83       	std	Z+1, r24	; 0x01
    1e44:	89 e2       	ldi	r24, 0x29	; 41
    1e46:	95 e1       	ldi	r25, 0x15	; 21
    1e48:	94 83       	std	Z+4, r25	; 0x04
    1e4a:	83 83       	std	Z+3, r24	; 0x03
    1e4c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("Otra Opcion: Salir SubMenu \n"));
    1e50:	80 91 d0 79 	lds	r24, 0x79D0
    1e54:	90 91 d1 79 	lds	r25, 0x79D1
    1e58:	ad b7       	in	r26, 0x3d	; 61
    1e5a:	be b7       	in	r27, 0x3e	; 62
    1e5c:	12 96       	adiw	r26, 0x02	; 2
    1e5e:	9c 93       	st	X, r25
    1e60:	8e 93       	st	-X, r24
    1e62:	11 97       	sbiw	r26, 0x01	; 1
    1e64:	8c e0       	ldi	r24, 0x0C	; 12
    1e66:	95 e1       	ldi	r25, 0x15	; 21
    1e68:	14 96       	adiw	r26, 0x04	; 4
    1e6a:	9c 93       	st	X, r25
    1e6c:	8e 93       	st	-X, r24
    1e6e:	13 97       	sbiw	r26, 0x03	; 3
    1e70:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				scanf("%d",&articulacion);
    1e74:	2c e1       	ldi	r18, 0x1C	; 28
    1e76:	32 e2       	ldi	r19, 0x22	; 34
    1e78:	ed b7       	in	r30, 0x3d	; 61
    1e7a:	fe b7       	in	r31, 0x3e	; 62
    1e7c:	32 83       	std	Z+2, r19	; 0x02
    1e7e:	21 83       	std	Z+1, r18	; 0x01
    1e80:	ce 01       	movw	r24, r28
    1e82:	03 96       	adiw	r24, 0x03	; 3
    1e84:	94 83       	std	Z+4, r25	; 0x04
    1e86:	83 83       	std	Z+3, r24	; 0x03
    1e88:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
				
				if(articulacion >=0 && articulacion <=4)
    1e8c:	0f 90       	pop	r0
    1e8e:	0f 90       	pop	r0
    1e90:	0f 90       	pop	r0
    1e92:	0f 90       	pop	r0
    1e94:	8b 81       	ldd	r24, Y+3	; 0x03
    1e96:	9c 81       	ldd	r25, Y+4	; 0x04
    1e98:	05 97       	sbiw	r24, 0x05	; 5
    1e9a:	08 f0       	brcs	.+2      	; 0x1e9e <main+0x49e>
    1e9c:	5c c0       	rjmp	.+184    	; 0x1f56 <main+0x556>
				{				
					fprintf_P(stdout,PSTR("Digite Posicion? \n"));
    1e9e:	00 d0       	rcall	.+0      	; 0x1ea0 <main+0x4a0>
    1ea0:	00 d0       	rcall	.+0      	; 0x1ea2 <main+0x4a2>
    1ea2:	80 91 d0 79 	lds	r24, 0x79D0
    1ea6:	90 91 d1 79 	lds	r25, 0x79D1
    1eaa:	ad b7       	in	r26, 0x3d	; 61
    1eac:	be b7       	in	r27, 0x3e	; 62
    1eae:	12 96       	adiw	r26, 0x02	; 2
    1eb0:	9c 93       	st	X, r25
    1eb2:	8e 93       	st	-X, r24
    1eb4:	11 97       	sbiw	r26, 0x01	; 1
    1eb6:	89 ef       	ldi	r24, 0xF9	; 249
    1eb8:	94 e1       	ldi	r25, 0x14	; 20
    1eba:	14 96       	adiw	r26, 0x04	; 4
    1ebc:	9c 93       	st	X, r25
    1ebe:	8e 93       	st	-X, r24
    1ec0:	13 97       	sbiw	r26, 0x03	; 3
    1ec2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%ld", &position);				
    1ec6:	0f e1       	ldi	r16, 0x1F	; 31
    1ec8:	12 e2       	ldi	r17, 0x22	; 34
    1eca:	ed b7       	in	r30, 0x3d	; 61
    1ecc:	fe b7       	in	r31, 0x3e	; 62
    1ece:	12 83       	std	Z+2, r17	; 0x02
    1ed0:	01 83       	std	Z+1, r16	; 0x01
    1ed2:	ce 01       	movw	r24, r28
    1ed4:	4d 96       	adiw	r24, 0x1d	; 29
    1ed6:	94 83       	std	Z+4, r25	; 0x04
    1ed8:	83 83       	std	Z+3, r24	; 0x03
    1eda:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
					fprintf_P(stdout,PSTR("Digite Velocidad? \n"));
    1ede:	80 91 d0 79 	lds	r24, 0x79D0
    1ee2:	90 91 d1 79 	lds	r25, 0x79D1
    1ee6:	ad b7       	in	r26, 0x3d	; 61
    1ee8:	be b7       	in	r27, 0x3e	; 62
    1eea:	12 96       	adiw	r26, 0x02	; 2
    1eec:	9c 93       	st	X, r25
    1eee:	8e 93       	st	-X, r24
    1ef0:	11 97       	sbiw	r26, 0x01	; 1
    1ef2:	85 ee       	ldi	r24, 0xE5	; 229
    1ef4:	94 e1       	ldi	r25, 0x14	; 20
    1ef6:	14 96       	adiw	r26, 0x04	; 4
    1ef8:	9c 93       	st	X, r25
    1efa:	8e 93       	st	-X, r24
    1efc:	13 97       	sbiw	r26, 0x03	; 3
    1efe:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%ld", &velocity);			
    1f02:	ed b7       	in	r30, 0x3d	; 61
    1f04:	fe b7       	in	r31, 0x3e	; 62
    1f06:	12 83       	std	Z+2, r17	; 0x02
    1f08:	01 83       	std	Z+1, r16	; 0x01
    1f0a:	ce 01       	movw	r24, r28
    1f0c:	81 96       	adiw	r24, 0x21	; 33
    1f0e:	94 83       	std	Z+4, r25	; 0x04
    1f10:	83 83       	std	Z+3, r24	; 0x03
    1f12:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
					fprintf_P(stdout,PSTR("Digite aceleracion? \n"));
    1f16:	80 91 d0 79 	lds	r24, 0x79D0
    1f1a:	90 91 d1 79 	lds	r25, 0x79D1
    1f1e:	ad b7       	in	r26, 0x3d	; 61
    1f20:	be b7       	in	r27, 0x3e	; 62
    1f22:	12 96       	adiw	r26, 0x02	; 2
    1f24:	9c 93       	st	X, r25
    1f26:	8e 93       	st	-X, r24
    1f28:	11 97       	sbiw	r26, 0x01	; 1
    1f2a:	8f ec       	ldi	r24, 0xCF	; 207
    1f2c:	94 e1       	ldi	r25, 0x14	; 20
    1f2e:	14 96       	adiw	r26, 0x04	; 4
    1f30:	9c 93       	st	X, r25
    1f32:	8e 93       	st	-X, r24
    1f34:	13 97       	sbiw	r26, 0x03	; 3
    1f36:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%ld", &aceleration);
    1f3a:	ed b7       	in	r30, 0x3d	; 61
    1f3c:	fe b7       	in	r31, 0x3e	; 62
    1f3e:	12 83       	std	Z+2, r17	; 0x02
    1f40:	01 83       	std	Z+1, r16	; 0x01
    1f42:	ce 01       	movw	r24, r28
    1f44:	85 96       	adiw	r24, 0x25	; 37
    1f46:	94 83       	std	Z+4, r25	; 0x04
    1f48:	83 83       	std	Z+3, r24	; 0x03
    1f4a:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
    1f4e:	0f 90       	pop	r0
    1f50:	0f 90       	pop	r0
    1f52:	0f 90       	pop	r0
    1f54:	0f 90       	pop	r0
				}
				
				switch (articulacion)
    1f56:	8b 81       	ldd	r24, Y+3	; 0x03
    1f58:	9c 81       	ldd	r25, Y+4	; 0x04
    1f5a:	82 30       	cpi	r24, 0x02	; 2
    1f5c:	91 05       	cpc	r25, r1
    1f5e:	a1 f1       	breq	.+104    	; 0x1fc8 <main+0x5c8>
    1f60:	83 30       	cpi	r24, 0x03	; 3
    1f62:	91 05       	cpc	r25, r1
    1f64:	34 f4       	brge	.+12     	; 0x1f72 <main+0x572>
    1f66:	00 97       	sbiw	r24, 0x00	; 0
    1f68:	59 f0       	breq	.+22     	; 0x1f80 <main+0x580>
    1f6a:	01 97       	sbiw	r24, 0x01	; 1
    1f6c:	09 f0       	breq	.+2      	; 0x1f70 <main+0x570>
    1f6e:	66 c0       	rjmp	.+204    	; 0x203c <main+0x63c>
    1f70:	16 c0       	rjmp	.+44     	; 0x1f9e <main+0x59e>
    1f72:	83 30       	cpi	r24, 0x03	; 3
    1f74:	91 05       	cpc	r25, r1
    1f76:	b9 f1       	breq	.+110    	; 0x1fe6 <main+0x5e6>
    1f78:	04 97       	sbiw	r24, 0x04	; 4
    1f7a:	09 f0       	breq	.+2      	; 0x1f7e <main+0x57e>
    1f7c:	5f c0       	rjmp	.+190    	; 0x203c <main+0x63c>
    1f7e:	49 c0       	rjmp	.+146    	; 0x2012 <main+0x612>
				{
					case (0):
				    mov_axis(articulacion,position,velocity,aceleration,update);
    1f80:	4d 8d       	ldd	r20, Y+29	; 0x1d
    1f82:	5e 8d       	ldd	r21, Y+30	; 0x1e
    1f84:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1f86:	78 a1       	ldd	r23, Y+32	; 0x20
    1f88:	09 a1       	ldd	r16, Y+33	; 0x21
    1f8a:	1a a1       	ldd	r17, Y+34	; 0x22
    1f8c:	2b a1       	ldd	r18, Y+35	; 0x23
    1f8e:	3c a1       	ldd	r19, Y+36	; 0x24
    1f90:	cd a0       	ldd	r12, Y+37	; 0x25
    1f92:	de a0       	ldd	r13, Y+38	; 0x26
    1f94:	ef a0       	ldd	r14, Y+39	; 0x27
    1f96:	f8 a4       	ldd	r15, Y+40	; 0x28
    1f98:	80 e0       	ldi	r24, 0x00	; 0
    1f9a:	90 e0       	ldi	r25, 0x00	; 0
    1f9c:	0e c0       	rjmp	.+28     	; 0x1fba <main+0x5ba>
				    break;
					
					case (1):
				    mov_axis(articulacion,position,velocity,aceleration,update);
    1f9e:	4d 8d       	ldd	r20, Y+29	; 0x1d
    1fa0:	5e 8d       	ldd	r21, Y+30	; 0x1e
    1fa2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1fa4:	78 a1       	ldd	r23, Y+32	; 0x20
    1fa6:	09 a1       	ldd	r16, Y+33	; 0x21
    1fa8:	1a a1       	ldd	r17, Y+34	; 0x22
    1faa:	2b a1       	ldd	r18, Y+35	; 0x23
    1fac:	3c a1       	ldd	r19, Y+36	; 0x24
    1fae:	cd a0       	ldd	r12, Y+37	; 0x25
    1fb0:	de a0       	ldd	r13, Y+38	; 0x26
    1fb2:	ef a0       	ldd	r14, Y+39	; 0x27
    1fb4:	f8 a4       	ldd	r15, Y+40	; 0x28
    1fb6:	81 e0       	ldi	r24, 0x01	; 1
    1fb8:	90 e0       	ldi	r25, 0x00	; 0
    1fba:	e0 ef       	ldi	r30, 0xF0	; 240
    1fbc:	ae 2e       	mov	r10, r30
    1fbe:	ef ef       	ldi	r30, 0xFF	; 255
    1fc0:	be 2e       	mov	r11, r30
    1fc2:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
    1fc6:	3a c0       	rjmp	.+116    	; 0x203c <main+0x63c>
				    break;
					
					case (2):
				    mov_axis(articulacion,position,velocity,aceleration,update);
    1fc8:	4d 8d       	ldd	r20, Y+29	; 0x1d
    1fca:	5e 8d       	ldd	r21, Y+30	; 0x1e
    1fcc:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1fce:	78 a1       	ldd	r23, Y+32	; 0x20
    1fd0:	09 a1       	ldd	r16, Y+33	; 0x21
    1fd2:	1a a1       	ldd	r17, Y+34	; 0x22
    1fd4:	2b a1       	ldd	r18, Y+35	; 0x23
    1fd6:	3c a1       	ldd	r19, Y+36	; 0x24
    1fd8:	cd a0       	ldd	r12, Y+37	; 0x25
    1fda:	de a0       	ldd	r13, Y+38	; 0x26
    1fdc:	ef a0       	ldd	r14, Y+39	; 0x27
    1fde:	f8 a4       	ldd	r15, Y+40	; 0x28
    1fe0:	82 e0       	ldi	r24, 0x02	; 2
    1fe2:	90 e0       	ldi	r25, 0x00	; 0
    1fe4:	ea cf       	rjmp	.-44     	; 0x1fba <main+0x5ba>
				    break;
					
					case (3):
				    pitch(position,velocity,aceleration,update,MOVIMIENTO_NORMAL);
    1fe6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1fe8:	7e 8d       	ldd	r23, Y+30	; 0x1e
    1fea:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1fec:	98 a1       	ldd	r25, Y+32	; 0x20
    1fee:	29 a1       	ldd	r18, Y+33	; 0x21
    1ff0:	3a a1       	ldd	r19, Y+34	; 0x22
    1ff2:	4b a1       	ldd	r20, Y+35	; 0x23
    1ff4:	5c a1       	ldd	r21, Y+36	; 0x24
    1ff6:	ed a0       	ldd	r14, Y+37	; 0x25
    1ff8:	fe a0       	ldd	r15, Y+38	; 0x26
    1ffa:	0f a1       	ldd	r16, Y+39	; 0x27
    1ffc:	18 a5       	ldd	r17, Y+40	; 0x28
    1ffe:	b0 ef       	ldi	r27, 0xF0	; 240
    2000:	cb 2e       	mov	r12, r27
    2002:	bf ef       	ldi	r27, 0xFF	; 255
    2004:	db 2e       	mov	r13, r27
    2006:	a1 e0       	ldi	r26, 0x01	; 1
    2008:	aa 2e       	mov	r10, r26
    200a:	b1 2c       	mov	r11, r1
    200c:	0e 94 78 52 	call	0xa4f0	; 0xa4f0 <pitch>
    2010:	15 c0       	rjmp	.+42     	; 0x203c <main+0x63c>
				    break;
					
				    case (4):
				    roll(position,velocity,aceleration,update,MOVIMIENTO_NORMAL);
    2012:	6d 8d       	ldd	r22, Y+29	; 0x1d
    2014:	7e 8d       	ldd	r23, Y+30	; 0x1e
    2016:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2018:	98 a1       	ldd	r25, Y+32	; 0x20
    201a:	29 a1       	ldd	r18, Y+33	; 0x21
    201c:	3a a1       	ldd	r19, Y+34	; 0x22
    201e:	4b a1       	ldd	r20, Y+35	; 0x23
    2020:	5c a1       	ldd	r21, Y+36	; 0x24
    2022:	ed a0       	ldd	r14, Y+37	; 0x25
    2024:	fe a0       	ldd	r15, Y+38	; 0x26
    2026:	0f a1       	ldd	r16, Y+39	; 0x27
    2028:	18 a5       	ldd	r17, Y+40	; 0x28
    202a:	f0 ef       	ldi	r31, 0xF0	; 240
    202c:	cf 2e       	mov	r12, r31
    202e:	ff ef       	ldi	r31, 0xFF	; 255
    2030:	df 2e       	mov	r13, r31
    2032:	e1 e0       	ldi	r30, 0x01	; 1
    2034:	ae 2e       	mov	r10, r30
    2036:	b1 2c       	mov	r11, r1
    2038:	0e 94 1b 50 	call	0xa036	; 0xa036 <roll>
					printf("Error Posicion=	%08ld\n",error_posicion);			
				}
				while ((status & PMDEventMotionCompleteMask)==0);
				printf("El movimiento se completo \n");*/
				
				motioncomplete(articulacion);					
    203c:	8b 81       	ldd	r24, Y+3	; 0x03
    203e:	9c 81       	ldd	r25, Y+4	; 0x04
    2040:	0e 94 30 4d 	call	0x9a60	; 0x9a60 <motioncomplete>
    2044:	82 cd       	rjmp	.-1276   	; 0x1b4a <main+0x14a>
			break;
			
		    case (1)://FUNCIONES DE INFORMACION DE MOVIMIENTO
				fprintf_P(stdout,PSTR("0. Informacion Movimiento\n"));
    2046:	00 d0       	rcall	.+0      	; 0x2048 <main+0x648>
    2048:	00 d0       	rcall	.+0      	; 0x204a <main+0x64a>
    204a:	80 91 d0 79 	lds	r24, 0x79D0
    204e:	90 91 d1 79 	lds	r25, 0x79D1
    2052:	ad b7       	in	r26, 0x3d	; 61
    2054:	be b7       	in	r27, 0x3e	; 62
    2056:	12 96       	adiw	r26, 0x02	; 2
    2058:	9c 93       	st	X, r25
    205a:	8e 93       	st	-X, r24
    205c:	11 97       	sbiw	r26, 0x01	; 1
    205e:	84 eb       	ldi	r24, 0xB4	; 180
    2060:	94 e1       	ldi	r25, 0x14	; 20
    2062:	14 96       	adiw	r26, 0x04	; 4
    2064:	9c 93       	st	X, r25
    2066:	8e 93       	st	-X, r24
    2068:	13 97       	sbiw	r26, 0x03	; 3
    206a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("1. Lectura del Event Status Register \n"));
    206e:	80 91 d0 79 	lds	r24, 0x79D0
    2072:	90 91 d1 79 	lds	r25, 0x79D1
    2076:	ed b7       	in	r30, 0x3d	; 61
    2078:	fe b7       	in	r31, 0x3e	; 62
    207a:	92 83       	std	Z+2, r25	; 0x02
    207c:	81 83       	std	Z+1, r24	; 0x01
    207e:	8d e8       	ldi	r24, 0x8D	; 141
    2080:	94 e1       	ldi	r25, 0x14	; 20
    2082:	94 83       	std	Z+4, r25	; 0x04
    2084:	83 83       	std	Z+3, r24	; 0x03
    2086:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("2. Lectura del Activity Status Register \n"));
    208a:	80 91 d0 79 	lds	r24, 0x79D0
    208e:	90 91 d1 79 	lds	r25, 0x79D1
    2092:	ad b7       	in	r26, 0x3d	; 61
    2094:	be b7       	in	r27, 0x3e	; 62
    2096:	12 96       	adiw	r26, 0x02	; 2
    2098:	9c 93       	st	X, r25
    209a:	8e 93       	st	-X, r24
    209c:	11 97       	sbiw	r26, 0x01	; 1
    209e:	83 e6       	ldi	r24, 0x63	; 99
    20a0:	94 e1       	ldi	r25, 0x14	; 20
    20a2:	14 96       	adiw	r26, 0x04	; 4
    20a4:	9c 93       	st	X, r25
    20a6:	8e 93       	st	-X, r24
    20a8:	13 97       	sbiw	r26, 0x03	; 3
    20aa:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("3. Signal Status \n"));
    20ae:	80 91 d0 79 	lds	r24, 0x79D0
    20b2:	90 91 d1 79 	lds	r25, 0x79D1
    20b6:	ed b7       	in	r30, 0x3d	; 61
    20b8:	fe b7       	in	r31, 0x3e	; 62
    20ba:	92 83       	std	Z+2, r25	; 0x02
    20bc:	81 83       	std	Z+1, r24	; 0x01
    20be:	80 e5       	ldi	r24, 0x50	; 80
    20c0:	94 e1       	ldi	r25, 0x14	; 20
    20c2:	94 83       	std	Z+4, r25	; 0x04
    20c4:	83 83       	std	Z+3, r24	; 0x03
    20c6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("4. Ajustar Posicion \n"));
    20ca:	80 91 d0 79 	lds	r24, 0x79D0
    20ce:	90 91 d1 79 	lds	r25, 0x79D1
    20d2:	ad b7       	in	r26, 0x3d	; 61
    20d4:	be b7       	in	r27, 0x3e	; 62
    20d6:	12 96       	adiw	r26, 0x02	; 2
    20d8:	9c 93       	st	X, r25
    20da:	8e 93       	st	-X, r24
    20dc:	11 97       	sbiw	r26, 0x01	; 1
    20de:	8a e3       	ldi	r24, 0x3A	; 58
    20e0:	94 e1       	ldi	r25, 0x14	; 20
    20e2:	14 96       	adiw	r26, 0x04	; 4
    20e4:	9c 93       	st	X, r25
    20e6:	8e 93       	st	-X, r24
    20e8:	13 97       	sbiw	r26, 0x03	; 3
    20ea:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("Otra Opcion: Salir SubMenu \n"));
    20ee:	80 91 d0 79 	lds	r24, 0x79D0
    20f2:	90 91 d1 79 	lds	r25, 0x79D1
    20f6:	ed b7       	in	r30, 0x3d	; 61
    20f8:	fe b7       	in	r31, 0x3e	; 62
    20fa:	92 83       	std	Z+2, r25	; 0x02
    20fc:	81 83       	std	Z+1, r24	; 0x01
    20fe:	8d e1       	ldi	r24, 0x1D	; 29
    2100:	94 e1       	ldi	r25, 0x14	; 20
    2102:	94 83       	std	Z+4, r25	; 0x04
    2104:	83 83       	std	Z+3, r24	; 0x03
    2106:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				scanf("%d",&submenu);
    210a:	ec e1       	ldi	r30, 0x1C	; 28
    210c:	f2 e2       	ldi	r31, 0x22	; 34
    210e:	ad b7       	in	r26, 0x3d	; 61
    2110:	be b7       	in	r27, 0x3e	; 62
    2112:	12 96       	adiw	r26, 0x02	; 2
    2114:	fc 93       	st	X, r31
    2116:	ee 93       	st	-X, r30
    2118:	11 97       	sbiw	r26, 0x01	; 1
    211a:	ce 01       	movw	r24, r28
    211c:	05 96       	adiw	r24, 0x05	; 5
    211e:	14 96       	adiw	r26, 0x04	; 4
    2120:	9c 93       	st	X, r25
    2122:	8e 93       	st	-X, r24
    2124:	13 97       	sbiw	r26, 0x03	; 3
    2126:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
				
				if(submenu >=0 && submenu<=4)
    212a:	0f 90       	pop	r0
    212c:	0f 90       	pop	r0
    212e:	0f 90       	pop	r0
    2130:	0f 90       	pop	r0
    2132:	8d 81       	ldd	r24, Y+5	; 0x05
    2134:	9e 81       	ldd	r25, Y+6	; 0x06
    2136:	05 97       	sbiw	r24, 0x05	; 5
    2138:	08 f0       	brcs	.+2      	; 0x213c <main+0x73c>
    213a:	76 c0       	rjmp	.+236    	; 0x2228 <__stack+0x29>
				{
					fprintf_P(stdout,PSTR("Digite la articulacion que quiere Leer o Ajustar\n"));
    213c:	00 d0       	rcall	.+0      	; 0x213e <main+0x73e>
    213e:	00 d0       	rcall	.+0      	; 0x2140 <main+0x740>
    2140:	80 91 d0 79 	lds	r24, 0x79D0
    2144:	90 91 d1 79 	lds	r25, 0x79D1
    2148:	ad b7       	in	r26, 0x3d	; 61
    214a:	be b7       	in	r27, 0x3e	; 62
    214c:	12 96       	adiw	r26, 0x02	; 2
    214e:	9c 93       	st	X, r25
    2150:	8e 93       	st	-X, r24
    2152:	11 97       	sbiw	r26, 0x01	; 1
    2154:	8b ee       	ldi	r24, 0xEB	; 235
    2156:	93 e1       	ldi	r25, 0x13	; 19
    2158:	14 96       	adiw	r26, 0x04	; 4
    215a:	9c 93       	st	X, r25
    215c:	8e 93       	st	-X, r24
    215e:	13 97       	sbiw	r26, 0x03	; 3
    2160:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("0. Cintura. \n"));
    2164:	80 91 d0 79 	lds	r24, 0x79D0
    2168:	90 91 d1 79 	lds	r25, 0x79D1
    216c:	ed b7       	in	r30, 0x3d	; 61
    216e:	fe b7       	in	r31, 0x3e	; 62
    2170:	92 83       	std	Z+2, r25	; 0x02
    2172:	81 83       	std	Z+1, r24	; 0x01
    2174:	8d ed       	ldi	r24, 0xDD	; 221
    2176:	93 e1       	ldi	r25, 0x13	; 19
    2178:	94 83       	std	Z+4, r25	; 0x04
    217a:	83 83       	std	Z+3, r24	; 0x03
    217c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("1. Hombro. \n"));
    2180:	80 91 d0 79 	lds	r24, 0x79D0
    2184:	90 91 d1 79 	lds	r25, 0x79D1
    2188:	ad b7       	in	r26, 0x3d	; 61
    218a:	be b7       	in	r27, 0x3e	; 62
    218c:	12 96       	adiw	r26, 0x02	; 2
    218e:	9c 93       	st	X, r25
    2190:	8e 93       	st	-X, r24
    2192:	11 97       	sbiw	r26, 0x01	; 1
    2194:	80 ed       	ldi	r24, 0xD0	; 208
    2196:	93 e1       	ldi	r25, 0x13	; 19
    2198:	14 96       	adiw	r26, 0x04	; 4
    219a:	9c 93       	st	X, r25
    219c:	8e 93       	st	-X, r24
    219e:	13 97       	sbiw	r26, 0x03	; 3
    21a0:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("2. Codo. \n"));
    21a4:	80 91 d0 79 	lds	r24, 0x79D0
    21a8:	90 91 d1 79 	lds	r25, 0x79D1
    21ac:	ed b7       	in	r30, 0x3d	; 61
    21ae:	fe b7       	in	r31, 0x3e	; 62
    21b0:	92 83       	std	Z+2, r25	; 0x02
    21b2:	81 83       	std	Z+1, r24	; 0x01
    21b4:	85 ec       	ldi	r24, 0xC5	; 197
    21b6:	93 e1       	ldi	r25, 0x13	; 19
    21b8:	94 83       	std	Z+4, r25	; 0x04
    21ba:	83 83       	std	Z+3, r24	; 0x03
    21bc:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("3. Pitch. \n"));		
    21c0:	80 91 d0 79 	lds	r24, 0x79D0
    21c4:	90 91 d1 79 	lds	r25, 0x79D1
    21c8:	ad b7       	in	r26, 0x3d	; 61
    21ca:	be b7       	in	r27, 0x3e	; 62
    21cc:	12 96       	adiw	r26, 0x02	; 2
    21ce:	9c 93       	st	X, r25
    21d0:	8e 93       	st	-X, r24
    21d2:	11 97       	sbiw	r26, 0x01	; 1
    21d4:	89 eb       	ldi	r24, 0xB9	; 185
    21d6:	93 e1       	ldi	r25, 0x13	; 19
    21d8:	14 96       	adiw	r26, 0x04	; 4
    21da:	9c 93       	st	X, r25
    21dc:	8e 93       	st	-X, r24
    21de:	13 97       	sbiw	r26, 0x03	; 3
    21e0:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("4.Roll. \n"));
    21e4:	80 91 d0 79 	lds	r24, 0x79D0
    21e8:	90 91 d1 79 	lds	r25, 0x79D1
    21ec:	ed b7       	in	r30, 0x3d	; 61
    21ee:	fe b7       	in	r31, 0x3e	; 62
    21f0:	92 83       	std	Z+2, r25	; 0x02
    21f2:	81 83       	std	Z+1, r24	; 0x01
    21f4:	8f ea       	ldi	r24, 0xAF	; 175
    21f6:	93 e1       	ldi	r25, 0x13	; 19
    21f8:	94 83       	std	Z+4, r25	; 0x04
    21fa:	83 83       	std	Z+3, r24	; 0x03
    21fc:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%d",&articulacion);
    2200:	ec e1       	ldi	r30, 0x1C	; 28
    2202:	f2 e2       	ldi	r31, 0x22	; 34
    2204:	ad b7       	in	r26, 0x3d	; 61
    2206:	be b7       	in	r27, 0x3e	; 62
    2208:	12 96       	adiw	r26, 0x02	; 2
    220a:	fc 93       	st	X, r31
    220c:	ee 93       	st	-X, r30
    220e:	11 97       	sbiw	r26, 0x01	; 1
    2210:	ce 01       	movw	r24, r28
    2212:	03 96       	adiw	r24, 0x03	; 3
    2214:	14 96       	adiw	r26, 0x04	; 4
    2216:	9c 93       	st	X, r25
    2218:	8e 93       	st	-X, r24
    221a:	13 97       	sbiw	r26, 0x03	; 3
    221c:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
    2220:	0f 90       	pop	r0
    2222:	0f 90       	pop	r0
    2224:	0f 90       	pop	r0
    2226:	0f 90       	pop	r0
				}
				
				switch (submenu)
    2228:	8d 81       	ldd	r24, Y+5	; 0x05
    222a:	9e 81       	ldd	r25, Y+6	; 0x06
    222c:	82 30       	cpi	r24, 0x02	; 2
    222e:	91 05       	cpc	r25, r1
    2230:	09 f4       	brne	.+2      	; 0x2234 <__stack+0x35>
    2232:	64 c1       	rjmp	.+712    	; 0x24fc <__stack+0x2fd>
    2234:	83 30       	cpi	r24, 0x03	; 3
    2236:	91 05       	cpc	r25, r1
    2238:	34 f4       	brge	.+12     	; 0x2246 <__stack+0x47>
    223a:	00 97       	sbiw	r24, 0x00	; 0
    223c:	61 f0       	breq	.+24     	; 0x2256 <__stack+0x57>
    223e:	01 97       	sbiw	r24, 0x01	; 1
    2240:	09 f0       	breq	.+2      	; 0x2244 <__stack+0x45>
    2242:	83 cc       	rjmp	.-1786   	; 0x1b4a <main+0x14a>
    2244:	3e c1       	rjmp	.+636    	; 0x24c2 <__stack+0x2c3>
    2246:	83 30       	cpi	r24, 0x03	; 3
    2248:	91 05       	cpc	r25, r1
    224a:	09 f4       	brne	.+2      	; 0x224e <__stack+0x4f>
    224c:	5e c1       	rjmp	.+700    	; 0x250a <__stack+0x30b>
    224e:	04 97       	sbiw	r24, 0x04	; 4
    2250:	09 f0       	breq	.+2      	; 0x2254 <__stack+0x55>
    2252:	7b cc       	rjmp	.-1802   	; 0x1b4a <main+0x14a>
    2254:	61 c1       	rjmp	.+706    	; 0x2518 <__stack+0x319>
				{
					case (0):
						infomov(articulacion,&position1, &velocity1, &acceleration1, &deceleration, 
    2256:	00 d0       	rcall	.+0      	; 0x2258 <__stack+0x59>
    2258:	00 d0       	rcall	.+0      	; 0x225a <__stack+0x5b>
    225a:	00 d0       	rcall	.+0      	; 0x225c <__stack+0x5d>
    225c:	ed b7       	in	r30, 0x3d	; 61
    225e:	fe b7       	in	r31, 0x3e	; 62
    2260:	31 96       	adiw	r30, 0x01	; 1
    2262:	8b 81       	ldd	r24, Y+3	; 0x03
    2264:	9c 81       	ldd	r25, Y+4	; 0x04
    2266:	05 e4       	ldi	r16, 0x45	; 69
    2268:	60 2e       	mov	r6, r16
    226a:	71 2c       	mov	r7, r1
    226c:	6c 0e       	add	r6, r28
    226e:	7d 1e       	adc	r7, r29
    2270:	19 e4       	ldi	r17, 0x49	; 73
    2272:	41 2e       	mov	r4, r17
    2274:	51 2c       	mov	r5, r1
    2276:	4c 0e       	add	r4, r28
    2278:	5d 1e       	adc	r5, r29
    227a:	bd e3       	ldi	r27, 0x3D	; 61
    227c:	2b 2e       	mov	r2, r27
    227e:	31 2c       	mov	r3, r1
    2280:	2c 0e       	add	r2, r28
    2282:	3d 1e       	adc	r3, r29
    2284:	21 e4       	ldi	r18, 0x41	; 65
    2286:	30 e0       	ldi	r19, 0x00	; 0
    2288:	2c 0f       	add	r18, r28
    228a:	3d 1f       	adc	r19, r29
    228c:	ad b7       	in	r26, 0x3d	; 61
    228e:	be b7       	in	r27, 0x3e	; 62
    2290:	12 96       	adiw	r26, 0x02	; 2
    2292:	3c 93       	st	X, r19
    2294:	2e 93       	st	-X, r18
    2296:	11 97       	sbiw	r26, 0x01	; 1
    2298:	9e 01       	movw	r18, r28
    229a:	27 5f       	subi	r18, 0xF7	; 247
    229c:	3f 4f       	sbci	r19, 0xFF	; 255
    229e:	33 83       	std	Z+3, r19	; 0x03
    22a0:	22 83       	std	Z+2, r18	; 0x02
    22a2:	9e 01       	movw	r18, r28
    22a4:	25 5f       	subi	r18, 0xF5	; 245
    22a6:	3f 4f       	sbci	r19, 0xFF	; 255
    22a8:	35 83       	std	Z+5, r19	; 0x05
    22aa:	24 83       	std	Z+4, r18	; 0x04
    22ac:	be 01       	movw	r22, r28
    22ae:	67 5d       	subi	r22, 0xD7	; 215
    22b0:	7f 4f       	sbci	r23, 0xFF	; 255
    22b2:	ae 01       	movw	r20, r28
    22b4:	43 5d       	subi	r20, 0xD3	; 211
    22b6:	5f 4f       	sbci	r21, 0xFF	; 255
    22b8:	93 01       	movw	r18, r6
    22ba:	82 01       	movw	r16, r4
    22bc:	a1 e3       	ldi	r26, 0x31	; 49
    22be:	ea 2e       	mov	r14, r26
    22c0:	f1 2c       	mov	r15, r1
    22c2:	ec 0e       	add	r14, r28
    22c4:	fd 1e       	adc	r15, r29
    22c6:	f5 e3       	ldi	r31, 0x35	; 53
    22c8:	cf 2e       	mov	r12, r31
    22ca:	d1 2c       	mov	r13, r1
    22cc:	cc 0e       	add	r12, r28
    22ce:	dd 1e       	adc	r13, r29
    22d0:	e9 e3       	ldi	r30, 0x39	; 57
    22d2:	ae 2e       	mov	r10, r30
    22d4:	b1 2c       	mov	r11, r1
    22d6:	ac 0e       	add	r10, r28
    22d8:	bd 1e       	adc	r11, r29
    22da:	41 01       	movw	r8, r2
    22dc:	0e 94 05 6d 	call	0xda0a	; 0xda0a <infomov>
								&commandedposition,	&commandedvelocity, &commandedacceleration, 
								&readencoder1, &readerror,&cuentas_encoder,&micropasos);
						printf("la informacion correspondiente del movimiento del eje %s es :\n",AxisName(articulacion));
    22e0:	8d b7       	in	r24, 0x3d	; 61
    22e2:	9e b7       	in	r25, 0x3e	; 62
    22e4:	06 96       	adiw	r24, 0x06	; 6
    22e6:	0f b6       	in	r0, 0x3f	; 63
    22e8:	f8 94       	cli
    22ea:	9e bf       	out	0x3e, r25	; 62
    22ec:	0f be       	out	0x3f, r0	; 63
    22ee:	8d bf       	out	0x3d, r24	; 61
    22f0:	8b 81       	ldd	r24, Y+3	; 0x03
    22f2:	9c 81       	ldd	r25, Y+4	; 0x04
    22f4:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    22f8:	00 d0       	rcall	.+0      	; 0x22fa <__stack+0xfb>
    22fa:	00 d0       	rcall	.+0      	; 0x22fc <__stack+0xfd>
    22fc:	23 e2       	ldi	r18, 0x23	; 35
    22fe:	32 e2       	ldi	r19, 0x22	; 34
    2300:	ad b7       	in	r26, 0x3d	; 61
    2302:	be b7       	in	r27, 0x3e	; 62
    2304:	12 96       	adiw	r26, 0x02	; 2
    2306:	3c 93       	st	X, r19
    2308:	2e 93       	st	-X, r18
    230a:	11 97       	sbiw	r26, 0x01	; 1
    230c:	14 96       	adiw	r26, 0x04	; 4
    230e:	9c 93       	st	X, r25
    2310:	8e 93       	st	-X, r24
    2312:	13 97       	sbiw	r26, 0x03	; 3
    2314:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("posicion=	%08ld\n",position1);
    2318:	00 d0       	rcall	.+0      	; 0x231a <__stack+0x11b>
    231a:	82 e6       	ldi	r24, 0x62	; 98
    231c:	92 e2       	ldi	r25, 0x22	; 34
    231e:	ed b7       	in	r30, 0x3d	; 61
    2320:	fe b7       	in	r31, 0x3e	; 62
    2322:	92 83       	std	Z+2, r25	; 0x02
    2324:	81 83       	std	Z+1, r24	; 0x01
    2326:	89 a5       	ldd	r24, Y+41	; 0x29
    2328:	9a a5       	ldd	r25, Y+42	; 0x2a
    232a:	ab a5       	ldd	r26, Y+43	; 0x2b
    232c:	bc a5       	ldd	r27, Y+44	; 0x2c
    232e:	83 83       	std	Z+3, r24	; 0x03
    2330:	94 83       	std	Z+4, r25	; 0x04
    2332:	a5 83       	std	Z+5, r26	; 0x05
    2334:	b6 83       	std	Z+6, r27	; 0x06
    2336:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("velodidad	= 	%08ld\n",velocity1);
    233a:	83 e7       	ldi	r24, 0x73	; 115
    233c:	92 e2       	ldi	r25, 0x22	; 34
    233e:	ad b7       	in	r26, 0x3d	; 61
    2340:	be b7       	in	r27, 0x3e	; 62
    2342:	12 96       	adiw	r26, 0x02	; 2
    2344:	9c 93       	st	X, r25
    2346:	8e 93       	st	-X, r24
    2348:	11 97       	sbiw	r26, 0x01	; 1
    234a:	8d a5       	ldd	r24, Y+45	; 0x2d
    234c:	9e a5       	ldd	r25, Y+46	; 0x2e
    234e:	af a5       	ldd	r26, Y+47	; 0x2f
    2350:	b8 a9       	ldd	r27, Y+48	; 0x30
    2352:	ed b7       	in	r30, 0x3d	; 61
    2354:	fe b7       	in	r31, 0x3e	; 62
    2356:	83 83       	std	Z+3, r24	; 0x03
    2358:	94 83       	std	Z+4, r25	; 0x04
    235a:	a5 83       	std	Z+5, r26	; 0x05
    235c:	b6 83       	std	Z+6, r27	; 0x06
    235e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("aceleracion=	%08ld\n",acceleration1);
    2362:	87 e8       	ldi	r24, 0x87	; 135
    2364:	92 e2       	ldi	r25, 0x22	; 34
    2366:	ad b7       	in	r26, 0x3d	; 61
    2368:	be b7       	in	r27, 0x3e	; 62
    236a:	12 96       	adiw	r26, 0x02	; 2
    236c:	9c 93       	st	X, r25
    236e:	8e 93       	st	-X, r24
    2370:	11 97       	sbiw	r26, 0x01	; 1
    2372:	f3 01       	movw	r30, r6
    2374:	80 81       	ld	r24, Z
    2376:	91 81       	ldd	r25, Z+1	; 0x01
    2378:	a2 81       	ldd	r26, Z+2	; 0x02
    237a:	b3 81       	ldd	r27, Z+3	; 0x03
    237c:	ed b7       	in	r30, 0x3d	; 61
    237e:	fe b7       	in	r31, 0x3e	; 62
    2380:	83 83       	std	Z+3, r24	; 0x03
    2382:	94 83       	std	Z+4, r25	; 0x04
    2384:	a5 83       	std	Z+5, r26	; 0x05
    2386:	b6 83       	std	Z+6, r27	; 0x06
    2388:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("desaceleracion=	%08ld\n",deceleration);
    238c:	8b e9       	ldi	r24, 0x9B	; 155
    238e:	92 e2       	ldi	r25, 0x22	; 34
    2390:	ad b7       	in	r26, 0x3d	; 61
    2392:	be b7       	in	r27, 0x3e	; 62
    2394:	12 96       	adiw	r26, 0x02	; 2
    2396:	9c 93       	st	X, r25
    2398:	8e 93       	st	-X, r24
    239a:	11 97       	sbiw	r26, 0x01	; 1
    239c:	f2 01       	movw	r30, r4
    239e:	80 81       	ld	r24, Z
    23a0:	91 81       	ldd	r25, Z+1	; 0x01
    23a2:	a2 81       	ldd	r26, Z+2	; 0x02
    23a4:	b3 81       	ldd	r27, Z+3	; 0x03
    23a6:	ed b7       	in	r30, 0x3d	; 61
    23a8:	fe b7       	in	r31, 0x3e	; 62
    23aa:	83 83       	std	Z+3, r24	; 0x03
    23ac:	94 83       	std	Z+4, r25	; 0x04
    23ae:	a5 83       	std	Z+5, r26	; 0x05
    23b0:	b6 83       	std	Z+6, r27	; 0x06
    23b2:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("posicion instantanea=	%08ld\n",commandedposition);
    23b6:	82 eb       	ldi	r24, 0xB2	; 178
    23b8:	92 e2       	ldi	r25, 0x22	; 34
    23ba:	ad b7       	in	r26, 0x3d	; 61
    23bc:	be b7       	in	r27, 0x3e	; 62
    23be:	12 96       	adiw	r26, 0x02	; 2
    23c0:	9c 93       	st	X, r25
    23c2:	8e 93       	st	-X, r24
    23c4:	11 97       	sbiw	r26, 0x01	; 1
    23c6:	89 a9       	ldd	r24, Y+49	; 0x31
    23c8:	9a a9       	ldd	r25, Y+50	; 0x32
    23ca:	ab a9       	ldd	r26, Y+51	; 0x33
    23cc:	bc a9       	ldd	r27, Y+52	; 0x34
    23ce:	ed b7       	in	r30, 0x3d	; 61
    23d0:	fe b7       	in	r31, 0x3e	; 62
    23d2:	83 83       	std	Z+3, r24	; 0x03
    23d4:	94 83       	std	Z+4, r25	; 0x04
    23d6:	a5 83       	std	Z+5, r26	; 0x05
    23d8:	b6 83       	std	Z+6, r27	; 0x06
    23da:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("velodidad instantanea=	%08ld\n",commandedvelocity);
    23de:	8f ec       	ldi	r24, 0xCF	; 207
    23e0:	92 e2       	ldi	r25, 0x22	; 34
    23e2:	ad b7       	in	r26, 0x3d	; 61
    23e4:	be b7       	in	r27, 0x3e	; 62
    23e6:	12 96       	adiw	r26, 0x02	; 2
    23e8:	9c 93       	st	X, r25
    23ea:	8e 93       	st	-X, r24
    23ec:	11 97       	sbiw	r26, 0x01	; 1
    23ee:	8d a9       	ldd	r24, Y+53	; 0x35
    23f0:	9e a9       	ldd	r25, Y+54	; 0x36
    23f2:	af a9       	ldd	r26, Y+55	; 0x37
    23f4:	b8 ad       	ldd	r27, Y+56	; 0x38
    23f6:	ed b7       	in	r30, 0x3d	; 61
    23f8:	fe b7       	in	r31, 0x3e	; 62
    23fa:	83 83       	std	Z+3, r24	; 0x03
    23fc:	94 83       	std	Z+4, r25	; 0x04
    23fe:	a5 83       	std	Z+5, r26	; 0x05
    2400:	b6 83       	std	Z+6, r27	; 0x06
    2402:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("aceleracion instantanea=	%08ld\n",commandedacceleration);
    2406:	8d ee       	ldi	r24, 0xED	; 237
    2408:	92 e2       	ldi	r25, 0x22	; 34
    240a:	ad b7       	in	r26, 0x3d	; 61
    240c:	be b7       	in	r27, 0x3e	; 62
    240e:	12 96       	adiw	r26, 0x02	; 2
    2410:	9c 93       	st	X, r25
    2412:	8e 93       	st	-X, r24
    2414:	11 97       	sbiw	r26, 0x01	; 1
    2416:	89 ad       	ldd	r24, Y+57	; 0x39
    2418:	9a ad       	ldd	r25, Y+58	; 0x3a
    241a:	ab ad       	ldd	r26, Y+59	; 0x3b
    241c:	bc ad       	ldd	r27, Y+60	; 0x3c
    241e:	ed b7       	in	r30, 0x3d	; 61
    2420:	fe b7       	in	r31, 0x3e	; 62
    2422:	83 83       	std	Z+3, r24	; 0x03
    2424:	94 83       	std	Z+4, r25	; 0x04
    2426:	a5 83       	std	Z+5, r26	; 0x05
    2428:	b6 83       	std	Z+6, r27	; 0x06
    242a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("Lectura Encoder=	%08ld\n",readencoder1);
    242e:	8d e0       	ldi	r24, 0x0D	; 13
    2430:	93 e2       	ldi	r25, 0x23	; 35
    2432:	ad b7       	in	r26, 0x3d	; 61
    2434:	be b7       	in	r27, 0x3e	; 62
    2436:	12 96       	adiw	r26, 0x02	; 2
    2438:	9c 93       	st	X, r25
    243a:	8e 93       	st	-X, r24
    243c:	11 97       	sbiw	r26, 0x01	; 1
    243e:	f1 01       	movw	r30, r2
    2440:	80 81       	ld	r24, Z
    2442:	91 81       	ldd	r25, Z+1	; 0x01
    2444:	a2 81       	ldd	r26, Z+2	; 0x02
    2446:	b3 81       	ldd	r27, Z+3	; 0x03
    2448:	ed b7       	in	r30, 0x3d	; 61
    244a:	fe b7       	in	r31, 0x3e	; 62
    244c:	83 83       	std	Z+3, r24	; 0x03
    244e:	94 83       	std	Z+4, r25	; 0x04
    2450:	a5 83       	std	Z+5, r26	; 0x05
    2452:	b6 83       	std	Z+6, r27	; 0x06
    2454:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("Error Posicion=	%08ld\n",readerror);	
    2458:	85 e2       	ldi	r24, 0x25	; 37
    245a:	93 e2       	ldi	r25, 0x23	; 35
    245c:	ad b7       	in	r26, 0x3d	; 61
    245e:	be b7       	in	r27, 0x3e	; 62
    2460:	12 96       	adiw	r26, 0x02	; 2
    2462:	9c 93       	st	X, r25
    2464:	8e 93       	st	-X, r24
    2466:	11 97       	sbiw	r26, 0x01	; 1
    2468:	25 96       	adiw	r28, 0x05	; 5
    246a:	8c ad       	ldd	r24, Y+60	; 0x3c
    246c:	9d ad       	ldd	r25, Y+61	; 0x3d
    246e:	ae ad       	ldd	r26, Y+62	; 0x3e
    2470:	bf ad       	ldd	r27, Y+63	; 0x3f
    2472:	25 97       	sbiw	r28, 0x05	; 5
    2474:	ed b7       	in	r30, 0x3d	; 61
    2476:	fe b7       	in	r31, 0x3e	; 62
    2478:	83 83       	std	Z+3, r24	; 0x03
    247a:	94 83       	std	Z+4, r25	; 0x04
    247c:	a5 83       	std	Z+5, r26	; 0x05
    247e:	b6 83       	std	Z+6, r27	; 0x06
    2480:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("Cuentas de Encoder= %08d \n",cuentas_encoder);
    2484:	0f 90       	pop	r0
    2486:	0f 90       	pop	r0
    2488:	8c e3       	ldi	r24, 0x3C	; 60
    248a:	93 e2       	ldi	r25, 0x23	; 35
    248c:	ad b7       	in	r26, 0x3d	; 61
    248e:	be b7       	in	r27, 0x3e	; 62
    2490:	12 96       	adiw	r26, 0x02	; 2
    2492:	9c 93       	st	X, r25
    2494:	8e 93       	st	-X, r24
    2496:	11 97       	sbiw	r26, 0x01	; 1
    2498:	89 85       	ldd	r24, Y+9	; 0x09
    249a:	9a 85       	ldd	r25, Y+10	; 0x0a
    249c:	14 96       	adiw	r26, 0x04	; 4
    249e:	9c 93       	st	X, r25
    24a0:	8e 93       	st	-X, r24
    24a2:	13 97       	sbiw	r26, 0x03	; 3
    24a4:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("No. uPasos por vuelta= %08d \n",micropasos);	
    24a8:	87 e5       	ldi	r24, 0x57	; 87
    24aa:	93 e2       	ldi	r25, 0x23	; 35
    24ac:	ed b7       	in	r30, 0x3d	; 61
    24ae:	fe b7       	in	r31, 0x3e	; 62
    24b0:	92 83       	std	Z+2, r25	; 0x02
    24b2:	81 83       	std	Z+1, r24	; 0x01
    24b4:	8b 85       	ldd	r24, Y+11	; 0x0b
    24b6:	9c 85       	ldd	r25, Y+12	; 0x0c
    24b8:	94 83       	std	Z+4, r25	; 0x04
    24ba:	83 83       	std	Z+3, r24	; 0x03
    24bc:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    24c0:	08 c0       	rjmp	.+16     	; 0x24d2 <__stack+0x2d3>
								
								
				    break;
					
				    case (1):
						PMDCheckEventStatus(articulacion,imprimir);
    24c2:	8b 81       	ldd	r24, Y+3	; 0x03
    24c4:	9c 81       	ldd	r25, Y+4	; 0x04
    24c6:	6e ee       	ldi	r22, 0xEE	; 238
    24c8:	7f ef       	ldi	r23, 0xFF	; 255
    24ca:	0e 94 bf 70 	call	0xe17e	; 0xe17e <PMDCheckEventStatus>
						scanf("%d",&stop);	
    24ce:	00 d0       	rcall	.+0      	; 0x24d0 <__stack+0x2d1>
    24d0:	00 d0       	rcall	.+0      	; 0x24d2 <__stack+0x2d3>
    24d2:	ec e1       	ldi	r30, 0x1C	; 28
    24d4:	f2 e2       	ldi	r31, 0x22	; 34
    24d6:	ad b7       	in	r26, 0x3d	; 61
    24d8:	be b7       	in	r27, 0x3e	; 62
    24da:	12 96       	adiw	r26, 0x02	; 2
    24dc:	fc 93       	st	X, r31
    24de:	ee 93       	st	-X, r30
    24e0:	11 97       	sbiw	r26, 0x01	; 1
    24e2:	ce 01       	movw	r24, r28
    24e4:	07 96       	adiw	r24, 0x07	; 7
    24e6:	14 96       	adiw	r26, 0x04	; 4
    24e8:	9c 93       	st	X, r25
    24ea:	8e 93       	st	-X, r24
    24ec:	13 97       	sbiw	r26, 0x03	; 3
    24ee:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
    24f2:	0f 90       	pop	r0
    24f4:	0f 90       	pop	r0
    24f6:	0f 90       	pop	r0
    24f8:	0f 90       	pop	r0
    24fa:	27 cb       	rjmp	.-2482   	; 0x1b4a <main+0x14a>
				    break;
					
					case (2):
						PMDCheckActivityStatus(articulacion,imprimir);
    24fc:	8b 81       	ldd	r24, Y+3	; 0x03
    24fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2500:	6e ee       	ldi	r22, 0xEE	; 238
    2502:	7f ef       	ldi	r23, 0xFF	; 255
    2504:	0e 94 64 6f 	call	0xdec8	; 0xdec8 <PMDCheckActivityStatus>
    2508:	e2 cf       	rjmp	.-60     	; 0x24ce <__stack+0x2cf>
						scanf("%d",&stop);	
				    break;
					
					case (3):
						PMDCheckSignalStatus(articulacion,imprimir);
    250a:	8b 81       	ldd	r24, Y+3	; 0x03
    250c:	9c 81       	ldd	r25, Y+4	; 0x04
    250e:	6e ee       	ldi	r22, 0xEE	; 238
    2510:	7f ef       	ldi	r23, 0xFF	; 255
    2512:	0e 94 37 6e 	call	0xdc6e	; 0xdc6e <PMDCheckSignalStatus>
    2516:	db cf       	rjmp	.-74     	; 0x24ce <__stack+0x2cf>
						scanf("%d",&stop);	
				    break;
					
					case (4):
						fprintf_P(stdout,PSTR("Digite el valor de la posicion a ajustar \n"));
    2518:	00 d0       	rcall	.+0      	; 0x251a <__stack+0x31b>
    251a:	00 d0       	rcall	.+0      	; 0x251c <__stack+0x31d>
    251c:	80 91 d0 79 	lds	r24, 0x79D0
    2520:	90 91 d1 79 	lds	r25, 0x79D1
    2524:	ad b7       	in	r26, 0x3d	; 61
    2526:	be b7       	in	r27, 0x3e	; 62
    2528:	12 96       	adiw	r26, 0x02	; 2
    252a:	9c 93       	st	X, r25
    252c:	8e 93       	st	-X, r24
    252e:	11 97       	sbiw	r26, 0x01	; 1
    2530:	84 e8       	ldi	r24, 0x84	; 132
    2532:	93 e1       	ldi	r25, 0x13	; 19
    2534:	14 96       	adiw	r26, 0x04	; 4
    2536:	9c 93       	st	X, r25
    2538:	8e 93       	st	-X, r24
    253a:	13 97       	sbiw	r26, 0x03	; 3
    253c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&P_ajuste);
    2540:	2c e1       	ldi	r18, 0x1C	; 28
    2542:	32 e2       	ldi	r19, 0x22	; 34
    2544:	ed b7       	in	r30, 0x3d	; 61
    2546:	fe b7       	in	r31, 0x3e	; 62
    2548:	32 83       	std	Z+2, r19	; 0x02
    254a:	21 83       	std	Z+1, r18	; 0x01
    254c:	ce 01       	movw	r24, r28
    254e:	0d 96       	adiw	r24, 0x0d	; 13
    2550:	94 83       	std	Z+4, r25	; 0x04
    2552:	83 83       	std	Z+3, r24	; 0x03
    2554:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						ajustar_posicion(articulacion,P_ajuste);
    2558:	0f 90       	pop	r0
    255a:	0f 90       	pop	r0
    255c:	0f 90       	pop	r0
    255e:	0f 90       	pop	r0
    2560:	4d 85       	ldd	r20, Y+13	; 0x0d
    2562:	5e 85       	ldd	r21, Y+14	; 0x0e
    2564:	66 27       	eor	r22, r22
    2566:	57 fd       	sbrc	r21, 7
    2568:	60 95       	com	r22
    256a:	76 2f       	mov	r23, r22
    256c:	8b 81       	ldd	r24, Y+3	; 0x03
    256e:	9c 81       	ldd	r25, Y+4	; 0x04
    2570:	0e 94 2f 41 	call	0x825e	; 0x825e <ajustar_posicion>
    2574:	ea ca       	rjmp	.-2604   	; 0x1b4a <main+0x14a>
				
			
			break;
			
			case (2)://FUNCIONES DE CALIBRACION - AJUSTE - BREAKPOINT
				fprintf_P(stdout,PSTR("0. Realizar Proceso de Calibracion \n"));
    2576:	00 d0       	rcall	.+0      	; 0x2578 <__stack+0x379>
    2578:	00 d0       	rcall	.+0      	; 0x257a <__stack+0x37b>
    257a:	80 91 d0 79 	lds	r24, 0x79D0
    257e:	90 91 d1 79 	lds	r25, 0x79D1
    2582:	ad b7       	in	r26, 0x3d	; 61
    2584:	be b7       	in	r27, 0x3e	; 62
    2586:	12 96       	adiw	r26, 0x02	; 2
    2588:	9c 93       	st	X, r25
    258a:	8e 93       	st	-X, r24
    258c:	11 97       	sbiw	r26, 0x01	; 1
    258e:	8f e5       	ldi	r24, 0x5F	; 95
    2590:	93 e1       	ldi	r25, 0x13	; 19
    2592:	14 96       	adiw	r26, 0x04	; 4
    2594:	9c 93       	st	X, r25
    2596:	8e 93       	st	-X, r24
    2598:	13 97       	sbiw	r26, 0x03	; 3
    259a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("1. Hallar Nest y max y min posicion \n"));
    259e:	80 91 d0 79 	lds	r24, 0x79D0
    25a2:	90 91 d1 79 	lds	r25, 0x79D1
    25a6:	ed b7       	in	r30, 0x3d	; 61
    25a8:	fe b7       	in	r31, 0x3e	; 62
    25aa:	92 83       	std	Z+2, r25	; 0x02
    25ac:	81 83       	std	Z+1, r24	; 0x01
    25ae:	89 e3       	ldi	r24, 0x39	; 57
    25b0:	93 e1       	ldi	r25, 0x13	; 19
    25b2:	94 83       	std	Z+4, r25	; 0x04
    25b4:	83 83       	std	Z+3, r24	; 0x03
    25b6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("2. Configurar BreakPoint \n"));
    25ba:	80 91 d0 79 	lds	r24, 0x79D0
    25be:	90 91 d1 79 	lds	r25, 0x79D1
    25c2:	ad b7       	in	r26, 0x3d	; 61
    25c4:	be b7       	in	r27, 0x3e	; 62
    25c6:	12 96       	adiw	r26, 0x02	; 2
    25c8:	9c 93       	st	X, r25
    25ca:	8e 93       	st	-X, r24
    25cc:	11 97       	sbiw	r26, 0x01	; 1
    25ce:	8e e1       	ldi	r24, 0x1E	; 30
    25d0:	93 e1       	ldi	r25, 0x13	; 19
    25d2:	14 96       	adiw	r26, 0x04	; 4
    25d4:	9c 93       	st	X, r25
    25d6:	8e 93       	st	-X, r24
    25d8:	13 97       	sbiw	r26, 0x03	; 3
    25da:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("Otra Opcion: Salir SubMenu \n"));
    25de:	80 91 d0 79 	lds	r24, 0x79D0
    25e2:	90 91 d1 79 	lds	r25, 0x79D1
    25e6:	ed b7       	in	r30, 0x3d	; 61
    25e8:	fe b7       	in	r31, 0x3e	; 62
    25ea:	92 83       	std	Z+2, r25	; 0x02
    25ec:	81 83       	std	Z+1, r24	; 0x01
    25ee:	81 e0       	ldi	r24, 0x01	; 1
    25f0:	93 e1       	ldi	r25, 0x13	; 19
    25f2:	94 83       	std	Z+4, r25	; 0x04
    25f4:	83 83       	std	Z+3, r24	; 0x03
    25f6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				scanf("%d",&submenu);
    25fa:	ec e1       	ldi	r30, 0x1C	; 28
    25fc:	f2 e2       	ldi	r31, 0x22	; 34
    25fe:	ad b7       	in	r26, 0x3d	; 61
    2600:	be b7       	in	r27, 0x3e	; 62
    2602:	12 96       	adiw	r26, 0x02	; 2
    2604:	fc 93       	st	X, r31
    2606:	ee 93       	st	-X, r30
    2608:	11 97       	sbiw	r26, 0x01	; 1
    260a:	ce 01       	movw	r24, r28
    260c:	05 96       	adiw	r24, 0x05	; 5
    260e:	14 96       	adiw	r26, 0x04	; 4
    2610:	9c 93       	st	X, r25
    2612:	8e 93       	st	-X, r24
    2614:	13 97       	sbiw	r26, 0x03	; 3
    2616:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
				
				if(submenu >=0 && submenu<=1)
    261a:	0f 90       	pop	r0
    261c:	0f 90       	pop	r0
    261e:	0f 90       	pop	r0
    2620:	0f 90       	pop	r0
    2622:	8d 81       	ldd	r24, Y+5	; 0x05
    2624:	9e 81       	ldd	r25, Y+6	; 0x06
    2626:	02 97       	sbiw	r24, 0x02	; 2
    2628:	08 f0       	brcs	.+2      	; 0x262c <__stack+0x42d>
    262a:	76 c0       	rjmp	.+236    	; 0x2718 <__stack+0x519>
				{				
					fprintf_P(stdout,PSTR("Digite la articulacion a configurar \n"));
    262c:	00 d0       	rcall	.+0      	; 0x262e <__stack+0x42f>
    262e:	00 d0       	rcall	.+0      	; 0x2630 <__stack+0x431>
    2630:	80 91 d0 79 	lds	r24, 0x79D0
    2634:	90 91 d1 79 	lds	r25, 0x79D1
    2638:	ad b7       	in	r26, 0x3d	; 61
    263a:	be b7       	in	r27, 0x3e	; 62
    263c:	12 96       	adiw	r26, 0x02	; 2
    263e:	9c 93       	st	X, r25
    2640:	8e 93       	st	-X, r24
    2642:	11 97       	sbiw	r26, 0x01	; 1
    2644:	8b ed       	ldi	r24, 0xDB	; 219
    2646:	92 e1       	ldi	r25, 0x12	; 18
    2648:	14 96       	adiw	r26, 0x04	; 4
    264a:	9c 93       	st	X, r25
    264c:	8e 93       	st	-X, r24
    264e:	13 97       	sbiw	r26, 0x03	; 3
    2650:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("0. Cintura. \n"));
    2654:	80 91 d0 79 	lds	r24, 0x79D0
    2658:	90 91 d1 79 	lds	r25, 0x79D1
    265c:	ed b7       	in	r30, 0x3d	; 61
    265e:	fe b7       	in	r31, 0x3e	; 62
    2660:	92 83       	std	Z+2, r25	; 0x02
    2662:	81 83       	std	Z+1, r24	; 0x01
    2664:	8d ec       	ldi	r24, 0xCD	; 205
    2666:	92 e1       	ldi	r25, 0x12	; 18
    2668:	94 83       	std	Z+4, r25	; 0x04
    266a:	83 83       	std	Z+3, r24	; 0x03
    266c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("1. Hombro. \n"));
    2670:	80 91 d0 79 	lds	r24, 0x79D0
    2674:	90 91 d1 79 	lds	r25, 0x79D1
    2678:	ad b7       	in	r26, 0x3d	; 61
    267a:	be b7       	in	r27, 0x3e	; 62
    267c:	12 96       	adiw	r26, 0x02	; 2
    267e:	9c 93       	st	X, r25
    2680:	8e 93       	st	-X, r24
    2682:	11 97       	sbiw	r26, 0x01	; 1
    2684:	80 ec       	ldi	r24, 0xC0	; 192
    2686:	92 e1       	ldi	r25, 0x12	; 18
    2688:	14 96       	adiw	r26, 0x04	; 4
    268a:	9c 93       	st	X, r25
    268c:	8e 93       	st	-X, r24
    268e:	13 97       	sbiw	r26, 0x03	; 3
    2690:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("2. Codo. \n"));
    2694:	80 91 d0 79 	lds	r24, 0x79D0
    2698:	90 91 d1 79 	lds	r25, 0x79D1
    269c:	ed b7       	in	r30, 0x3d	; 61
    269e:	fe b7       	in	r31, 0x3e	; 62
    26a0:	92 83       	std	Z+2, r25	; 0x02
    26a2:	81 83       	std	Z+1, r24	; 0x01
    26a4:	85 eb       	ldi	r24, 0xB5	; 181
    26a6:	92 e1       	ldi	r25, 0x12	; 18
    26a8:	94 83       	std	Z+4, r25	; 0x04
    26aa:	83 83       	std	Z+3, r24	; 0x03
    26ac:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("3. Pitch. \n"));		
    26b0:	80 91 d0 79 	lds	r24, 0x79D0
    26b4:	90 91 d1 79 	lds	r25, 0x79D1
    26b8:	ad b7       	in	r26, 0x3d	; 61
    26ba:	be b7       	in	r27, 0x3e	; 62
    26bc:	12 96       	adiw	r26, 0x02	; 2
    26be:	9c 93       	st	X, r25
    26c0:	8e 93       	st	-X, r24
    26c2:	11 97       	sbiw	r26, 0x01	; 1
    26c4:	89 ea       	ldi	r24, 0xA9	; 169
    26c6:	92 e1       	ldi	r25, 0x12	; 18
    26c8:	14 96       	adiw	r26, 0x04	; 4
    26ca:	9c 93       	st	X, r25
    26cc:	8e 93       	st	-X, r24
    26ce:	13 97       	sbiw	r26, 0x03	; 3
    26d0:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("4.Roll. \n"));
    26d4:	80 91 d0 79 	lds	r24, 0x79D0
    26d8:	90 91 d1 79 	lds	r25, 0x79D1
    26dc:	ed b7       	in	r30, 0x3d	; 61
    26de:	fe b7       	in	r31, 0x3e	; 62
    26e0:	92 83       	std	Z+2, r25	; 0x02
    26e2:	81 83       	std	Z+1, r24	; 0x01
    26e4:	8f e9       	ldi	r24, 0x9F	; 159
    26e6:	92 e1       	ldi	r25, 0x12	; 18
    26e8:	94 83       	std	Z+4, r25	; 0x04
    26ea:	83 83       	std	Z+3, r24	; 0x03
    26ec:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%d",&articulacion);
    26f0:	ec e1       	ldi	r30, 0x1C	; 28
    26f2:	f2 e2       	ldi	r31, 0x22	; 34
    26f4:	ad b7       	in	r26, 0x3d	; 61
    26f6:	be b7       	in	r27, 0x3e	; 62
    26f8:	12 96       	adiw	r26, 0x02	; 2
    26fa:	fc 93       	st	X, r31
    26fc:	ee 93       	st	-X, r30
    26fe:	11 97       	sbiw	r26, 0x01	; 1
    2700:	ce 01       	movw	r24, r28
    2702:	03 96       	adiw	r24, 0x03	; 3
    2704:	14 96       	adiw	r26, 0x04	; 4
    2706:	9c 93       	st	X, r25
    2708:	8e 93       	st	-X, r24
    270a:	13 97       	sbiw	r26, 0x03	; 3
    270c:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
    2710:	0f 90       	pop	r0
    2712:	0f 90       	pop	r0
    2714:	0f 90       	pop	r0
    2716:	0f 90       	pop	r0
				}
				
				switch (submenu)
    2718:	8d 81       	ldd	r24, Y+5	; 0x05
    271a:	9e 81       	ldd	r25, Y+6	; 0x06
    271c:	81 30       	cpi	r24, 0x01	; 1
    271e:	91 05       	cpc	r25, r1
    2720:	a9 f1       	breq	.+106    	; 0x278c <__stack+0x58d>
    2722:	82 30       	cpi	r24, 0x02	; 2
    2724:	91 05       	cpc	r25, r1
    2726:	b9 f1       	breq	.+110    	; 0x2796 <__stack+0x597>
    2728:	89 2b       	or	r24, r25
    272a:	09 f0       	breq	.+2      	; 0x272e <__stack+0x52f>
    272c:	0e ca       	rjmp	.-3044   	; 0x1b4a <main+0x14a>
				{
					case (0):
						relacion=calibration(articulacion);
    272e:	8b 81       	ldd	r24, Y+3	; 0x03
    2730:	9c 81       	ldd	r25, Y+4	; 0x04
    2732:	0e 94 80 53 	call	0xa700	; 0xa700 <calibration>
    2736:	7b 01       	movw	r14, r22
    2738:	8c 01       	movw	r16, r24
						printf("la relacion de pasos a motor en el eje %s es= %08ld \n",AxisName(articulacion),relacion);		
    273a:	8b 81       	ldd	r24, Y+3	; 0x03
    273c:	9c 81       	ldd	r25, Y+4	; 0x04
    273e:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    2742:	2d b7       	in	r18, 0x3d	; 61
    2744:	3e b7       	in	r19, 0x3e	; 62
    2746:	28 50       	subi	r18, 0x08	; 8
    2748:	30 40       	sbci	r19, 0x00	; 0
    274a:	0f b6       	in	r0, 0x3f	; 63
    274c:	f8 94       	cli
    274e:	3e bf       	out	0x3e, r19	; 62
    2750:	0f be       	out	0x3f, r0	; 63
    2752:	2d bf       	out	0x3d, r18	; 61
    2754:	ed b7       	in	r30, 0x3d	; 61
    2756:	fe b7       	in	r31, 0x3e	; 62
    2758:	31 96       	adiw	r30, 0x01	; 1
    275a:	25 e7       	ldi	r18, 0x75	; 117
    275c:	33 e2       	ldi	r19, 0x23	; 35
    275e:	ad b7       	in	r26, 0x3d	; 61
    2760:	be b7       	in	r27, 0x3e	; 62
    2762:	12 96       	adiw	r26, 0x02	; 2
    2764:	3c 93       	st	X, r19
    2766:	2e 93       	st	-X, r18
    2768:	11 97       	sbiw	r26, 0x01	; 1
    276a:	93 83       	std	Z+3, r25	; 0x03
    276c:	82 83       	std	Z+2, r24	; 0x02
    276e:	e4 82       	std	Z+4, r14	; 0x04
    2770:	f5 82       	std	Z+5, r15	; 0x05
    2772:	06 83       	std	Z+6, r16	; 0x06
    2774:	17 83       	std	Z+7, r17	; 0x07
    2776:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    277a:	ed b7       	in	r30, 0x3d	; 61
    277c:	fe b7       	in	r31, 0x3e	; 62
    277e:	38 96       	adiw	r30, 0x08	; 8
    2780:	0f b6       	in	r0, 0x3f	; 63
    2782:	f8 94       	cli
    2784:	fe bf       	out	0x3e, r31	; 62
    2786:	0f be       	out	0x3f, r0	; 63
    2788:	ed bf       	out	0x3d, r30	; 61
    278a:	df c9       	rjmp	.-3138   	; 0x1b4a <main+0x14a>
				    break;
					
				    case (1):
						initializeAxis(articulacion);
    278c:	8b 81       	ldd	r24, Y+3	; 0x03
    278e:	9c 81       	ldd	r25, Y+4	; 0x04
    2790:	0e 94 7d 65 	call	0xcafa	; 0xcafa <initializeAxis>
    2794:	da c9       	rjmp	.-3148   	; 0x1b4a <main+0x14a>
				    break;
					
					case (2):						
						fprintf_P(stdout,PSTR("Digite el eje el cual configurara el BreakPoint \n"));
    2796:	00 d0       	rcall	.+0      	; 0x2798 <__stack+0x599>
    2798:	00 d0       	rcall	.+0      	; 0x279a <__stack+0x59b>
    279a:	80 91 d0 79 	lds	r24, 0x79D0
    279e:	90 91 d1 79 	lds	r25, 0x79D1
    27a2:	ad b7       	in	r26, 0x3d	; 61
    27a4:	be b7       	in	r27, 0x3e	; 62
    27a6:	12 96       	adiw	r26, 0x02	; 2
    27a8:	9c 93       	st	X, r25
    27aa:	8e 93       	st	-X, r24
    27ac:	11 97       	sbiw	r26, 0x01	; 1
    27ae:	8d e6       	ldi	r24, 0x6D	; 109
    27b0:	92 e1       	ldi	r25, 0x12	; 18
    27b2:	14 96       	adiw	r26, 0x04	; 4
    27b4:	9c 93       	st	X, r25
    27b6:	8e 93       	st	-X, r24
    27b8:	13 97       	sbiw	r26, 0x03	; 3
    27ba:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. Cintura. \n"));
    27be:	80 91 d0 79 	lds	r24, 0x79D0
    27c2:	90 91 d1 79 	lds	r25, 0x79D1
    27c6:	ed b7       	in	r30, 0x3d	; 61
    27c8:	fe b7       	in	r31, 0x3e	; 62
    27ca:	92 83       	std	Z+2, r25	; 0x02
    27cc:	81 83       	std	Z+1, r24	; 0x01
    27ce:	8f e5       	ldi	r24, 0x5F	; 95
    27d0:	92 e1       	ldi	r25, 0x12	; 18
    27d2:	94 83       	std	Z+4, r25	; 0x04
    27d4:	83 83       	std	Z+3, r24	; 0x03
    27d6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. Hombro. \n"));
    27da:	80 91 d0 79 	lds	r24, 0x79D0
    27de:	90 91 d1 79 	lds	r25, 0x79D1
    27e2:	ad b7       	in	r26, 0x3d	; 61
    27e4:	be b7       	in	r27, 0x3e	; 62
    27e6:	12 96       	adiw	r26, 0x02	; 2
    27e8:	9c 93       	st	X, r25
    27ea:	8e 93       	st	-X, r24
    27ec:	11 97       	sbiw	r26, 0x01	; 1
    27ee:	82 e5       	ldi	r24, 0x52	; 82
    27f0:	92 e1       	ldi	r25, 0x12	; 18
    27f2:	14 96       	adiw	r26, 0x04	; 4
    27f4:	9c 93       	st	X, r25
    27f6:	8e 93       	st	-X, r24
    27f8:	13 97       	sbiw	r26, 0x03	; 3
    27fa:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("2. Codo. \n"));
    27fe:	80 91 d0 79 	lds	r24, 0x79D0
    2802:	90 91 d1 79 	lds	r25, 0x79D1
    2806:	ed b7       	in	r30, 0x3d	; 61
    2808:	fe b7       	in	r31, 0x3e	; 62
    280a:	92 83       	std	Z+2, r25	; 0x02
    280c:	81 83       	std	Z+1, r24	; 0x01
    280e:	87 e4       	ldi	r24, 0x47	; 71
    2810:	92 e1       	ldi	r25, 0x12	; 18
    2812:	94 83       	std	Z+4, r25	; 0x04
    2814:	83 83       	std	Z+3, r24	; 0x03
    2816:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("3. Pitch. \n"));		
    281a:	80 91 d0 79 	lds	r24, 0x79D0
    281e:	90 91 d1 79 	lds	r25, 0x79D1
    2822:	ad b7       	in	r26, 0x3d	; 61
    2824:	be b7       	in	r27, 0x3e	; 62
    2826:	12 96       	adiw	r26, 0x02	; 2
    2828:	9c 93       	st	X, r25
    282a:	8e 93       	st	-X, r24
    282c:	11 97       	sbiw	r26, 0x01	; 1
    282e:	8b e3       	ldi	r24, 0x3B	; 59
    2830:	92 e1       	ldi	r25, 0x12	; 18
    2832:	14 96       	adiw	r26, 0x04	; 4
    2834:	9c 93       	st	X, r25
    2836:	8e 93       	st	-X, r24
    2838:	13 97       	sbiw	r26, 0x03	; 3
    283a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("4.Roll. \n"));
    283e:	80 91 d0 79 	lds	r24, 0x79D0
    2842:	90 91 d1 79 	lds	r25, 0x79D1
    2846:	ed b7       	in	r30, 0x3d	; 61
    2848:	fe b7       	in	r31, 0x3e	; 62
    284a:	92 83       	std	Z+2, r25	; 0x02
    284c:	81 83       	std	Z+1, r24	; 0x01
    284e:	81 e3       	ldi	r24, 0x31	; 49
    2850:	92 e1       	ldi	r25, 0x12	; 18
    2852:	94 83       	std	Z+4, r25	; 0x04
    2854:	83 83       	std	Z+3, r24	; 0x03
    2856:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&eje_break);			
    285a:	ec e1       	ldi	r30, 0x1C	; 28
    285c:	f2 e2       	ldi	r31, 0x22	; 34
    285e:	ad b7       	in	r26, 0x3d	; 61
    2860:	be b7       	in	r27, 0x3e	; 62
    2862:	12 96       	adiw	r26, 0x02	; 2
    2864:	fc 93       	st	X, r31
    2866:	ee 93       	st	-X, r30
    2868:	11 97       	sbiw	r26, 0x01	; 1
    286a:	ce 01       	movw	r24, r28
    286c:	0f 96       	adiw	r24, 0x0f	; 15
    286e:	14 96       	adiw	r26, 0x04	; 4
    2870:	9c 93       	st	X, r25
    2872:	8e 93       	st	-X, r24
    2874:	13 97       	sbiw	r26, 0x03	; 3
    2876:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						
						fprintf_P(stdout,PSTR("Digite el  BreakPoint_ID \n"));
    287a:	80 91 d0 79 	lds	r24, 0x79D0
    287e:	90 91 d1 79 	lds	r25, 0x79D1
    2882:	ad b7       	in	r26, 0x3d	; 61
    2884:	be b7       	in	r27, 0x3e	; 62
    2886:	12 96       	adiw	r26, 0x02	; 2
    2888:	9c 93       	st	X, r25
    288a:	8e 93       	st	-X, r24
    288c:	11 97       	sbiw	r26, 0x01	; 1
    288e:	86 e1       	ldi	r24, 0x16	; 22
    2890:	92 e1       	ldi	r25, 0x12	; 18
    2892:	14 96       	adiw	r26, 0x04	; 4
    2894:	9c 93       	st	X, r25
    2896:	8e 93       	st	-X, r24
    2898:	13 97       	sbiw	r26, 0x03	; 3
    289a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. BreakPoint1. \n"));
    289e:	80 91 d0 79 	lds	r24, 0x79D0
    28a2:	90 91 d1 79 	lds	r25, 0x79D1
    28a6:	ed b7       	in	r30, 0x3d	; 61
    28a8:	fe b7       	in	r31, 0x3e	; 62
    28aa:	92 83       	std	Z+2, r25	; 0x02
    28ac:	81 83       	std	Z+1, r24	; 0x01
    28ae:	84 e0       	ldi	r24, 0x04	; 4
    28b0:	92 e1       	ldi	r25, 0x12	; 18
    28b2:	94 83       	std	Z+4, r25	; 0x04
    28b4:	83 83       	std	Z+3, r24	; 0x03
    28b6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. BreakPoint2. \n"));
    28ba:	80 91 d0 79 	lds	r24, 0x79D0
    28be:	90 91 d1 79 	lds	r25, 0x79D1
    28c2:	ad b7       	in	r26, 0x3d	; 61
    28c4:	be b7       	in	r27, 0x3e	; 62
    28c6:	12 96       	adiw	r26, 0x02	; 2
    28c8:	9c 93       	st	X, r25
    28ca:	8e 93       	st	-X, r24
    28cc:	11 97       	sbiw	r26, 0x01	; 1
    28ce:	82 ef       	ldi	r24, 0xF2	; 242
    28d0:	91 e1       	ldi	r25, 0x11	; 17
    28d2:	14 96       	adiw	r26, 0x04	; 4
    28d4:	9c 93       	st	X, r25
    28d6:	8e 93       	st	-X, r24
    28d8:	13 97       	sbiw	r26, 0x03	; 3
    28da:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&Breakpoint_id);			
    28de:	2c e1       	ldi	r18, 0x1C	; 28
    28e0:	32 e2       	ldi	r19, 0x22	; 34
    28e2:	ed b7       	in	r30, 0x3d	; 61
    28e4:	fe b7       	in	r31, 0x3e	; 62
    28e6:	32 83       	std	Z+2, r19	; 0x02
    28e8:	21 83       	std	Z+1, r18	; 0x01
    28ea:	ce 01       	movw	r24, r28
    28ec:	41 96       	adiw	r24, 0x11	; 17
    28ee:	94 83       	std	Z+4, r25	; 0x04
    28f0:	83 83       	std	Z+3, r24	; 0x03
    28f2:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						
						fprintf_P(stdout,PSTR("Digite el Eje Fuente (source) del BreakPoint \n"));
    28f6:	80 91 d0 79 	lds	r24, 0x79D0
    28fa:	90 91 d1 79 	lds	r25, 0x79D1
    28fe:	ad b7       	in	r26, 0x3d	; 61
    2900:	be b7       	in	r27, 0x3e	; 62
    2902:	12 96       	adiw	r26, 0x02	; 2
    2904:	9c 93       	st	X, r25
    2906:	8e 93       	st	-X, r24
    2908:	11 97       	sbiw	r26, 0x01	; 1
    290a:	83 ec       	ldi	r24, 0xC3	; 195
    290c:	91 e1       	ldi	r25, 0x11	; 17
    290e:	14 96       	adiw	r26, 0x04	; 4
    2910:	9c 93       	st	X, r25
    2912:	8e 93       	st	-X, r24
    2914:	13 97       	sbiw	r26, 0x03	; 3
    2916:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. Cintura. \n"));
    291a:	80 91 d0 79 	lds	r24, 0x79D0
    291e:	90 91 d1 79 	lds	r25, 0x79D1
    2922:	ed b7       	in	r30, 0x3d	; 61
    2924:	fe b7       	in	r31, 0x3e	; 62
    2926:	92 83       	std	Z+2, r25	; 0x02
    2928:	81 83       	std	Z+1, r24	; 0x01
    292a:	85 eb       	ldi	r24, 0xB5	; 181
    292c:	91 e1       	ldi	r25, 0x11	; 17
    292e:	94 83       	std	Z+4, r25	; 0x04
    2930:	83 83       	std	Z+3, r24	; 0x03
    2932:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. Hombro. \n"));
    2936:	80 91 d0 79 	lds	r24, 0x79D0
    293a:	90 91 d1 79 	lds	r25, 0x79D1
    293e:	ad b7       	in	r26, 0x3d	; 61
    2940:	be b7       	in	r27, 0x3e	; 62
    2942:	12 96       	adiw	r26, 0x02	; 2
    2944:	9c 93       	st	X, r25
    2946:	8e 93       	st	-X, r24
    2948:	11 97       	sbiw	r26, 0x01	; 1
    294a:	88 ea       	ldi	r24, 0xA8	; 168
    294c:	91 e1       	ldi	r25, 0x11	; 17
    294e:	14 96       	adiw	r26, 0x04	; 4
    2950:	9c 93       	st	X, r25
    2952:	8e 93       	st	-X, r24
    2954:	13 97       	sbiw	r26, 0x03	; 3
    2956:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("2. Codo. \n"));
    295a:	80 91 d0 79 	lds	r24, 0x79D0
    295e:	90 91 d1 79 	lds	r25, 0x79D1
    2962:	ed b7       	in	r30, 0x3d	; 61
    2964:	fe b7       	in	r31, 0x3e	; 62
    2966:	92 83       	std	Z+2, r25	; 0x02
    2968:	81 83       	std	Z+1, r24	; 0x01
    296a:	8d e9       	ldi	r24, 0x9D	; 157
    296c:	91 e1       	ldi	r25, 0x11	; 17
    296e:	94 83       	std	Z+4, r25	; 0x04
    2970:	83 83       	std	Z+3, r24	; 0x03
    2972:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("3. Pitch. \n"));		
    2976:	80 91 d0 79 	lds	r24, 0x79D0
    297a:	90 91 d1 79 	lds	r25, 0x79D1
    297e:	ad b7       	in	r26, 0x3d	; 61
    2980:	be b7       	in	r27, 0x3e	; 62
    2982:	12 96       	adiw	r26, 0x02	; 2
    2984:	9c 93       	st	X, r25
    2986:	8e 93       	st	-X, r24
    2988:	11 97       	sbiw	r26, 0x01	; 1
    298a:	81 e9       	ldi	r24, 0x91	; 145
    298c:	91 e1       	ldi	r25, 0x11	; 17
    298e:	14 96       	adiw	r26, 0x04	; 4
    2990:	9c 93       	st	X, r25
    2992:	8e 93       	st	-X, r24
    2994:	13 97       	sbiw	r26, 0x03	; 3
    2996:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("4.Roll. \n"));
    299a:	80 91 d0 79 	lds	r24, 0x79D0
    299e:	90 91 d1 79 	lds	r25, 0x79D1
    29a2:	ed b7       	in	r30, 0x3d	; 61
    29a4:	fe b7       	in	r31, 0x3e	; 62
    29a6:	92 83       	std	Z+2, r25	; 0x02
    29a8:	81 83       	std	Z+1, r24	; 0x01
    29aa:	87 e8       	ldi	r24, 0x87	; 135
    29ac:	91 e1       	ldi	r25, 0x11	; 17
    29ae:	94 83       	std	Z+4, r25	; 0x04
    29b0:	83 83       	std	Z+3, r24	; 0x03
    29b2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&source_Axis);			
    29b6:	ec e1       	ldi	r30, 0x1C	; 28
    29b8:	f2 e2       	ldi	r31, 0x22	; 34
    29ba:	ad b7       	in	r26, 0x3d	; 61
    29bc:	be b7       	in	r27, 0x3e	; 62
    29be:	12 96       	adiw	r26, 0x02	; 2
    29c0:	fc 93       	st	X, r31
    29c2:	ee 93       	st	-X, r30
    29c4:	11 97       	sbiw	r26, 0x01	; 1
    29c6:	ce 01       	movw	r24, r28
    29c8:	43 96       	adiw	r24, 0x13	; 19
    29ca:	14 96       	adiw	r26, 0x04	; 4
    29cc:	9c 93       	st	X, r25
    29ce:	8e 93       	st	-X, r24
    29d0:	13 97       	sbiw	r26, 0x03	; 3
    29d2:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						
						fprintf_P(stdout,PSTR("Digite la accion del BreakPoint \n"));
    29d6:	80 91 d0 79 	lds	r24, 0x79D0
    29da:	90 91 d1 79 	lds	r25, 0x79D1
    29de:	ad b7       	in	r26, 0x3d	; 61
    29e0:	be b7       	in	r27, 0x3e	; 62
    29e2:	12 96       	adiw	r26, 0x02	; 2
    29e4:	9c 93       	st	X, r25
    29e6:	8e 93       	st	-X, r24
    29e8:	11 97       	sbiw	r26, 0x01	; 1
    29ea:	85 e6       	ldi	r24, 0x65	; 101
    29ec:	91 e1       	ldi	r25, 0x11	; 17
    29ee:	14 96       	adiw	r26, 0x04	; 4
    29f0:	9c 93       	st	X, r25
    29f2:	8e 93       	st	-X, r24
    29f4:	13 97       	sbiw	r26, 0x03	; 3
    29f6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0.Ninguna Accion. \n"));
    29fa:	80 91 d0 79 	lds	r24, 0x79D0
    29fe:	90 91 d1 79 	lds	r25, 0x79D1
    2a02:	ed b7       	in	r30, 0x3d	; 61
    2a04:	fe b7       	in	r31, 0x3e	; 62
    2a06:	92 83       	std	Z+2, r25	; 0x02
    2a08:	81 83       	std	Z+1, r24	; 0x01
    2a0a:	81 e5       	ldi	r24, 0x51	; 81
    2a0c:	91 e1       	ldi	r25, 0x11	; 17
    2a0e:	94 83       	std	Z+4, r25	; 0x04
    2a10:	83 83       	std	Z+3, r24	; 0x03
    2a12:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. Update. \n"));
    2a16:	80 91 d0 79 	lds	r24, 0x79D0
    2a1a:	90 91 d1 79 	lds	r25, 0x79D1
    2a1e:	ad b7       	in	r26, 0x3d	; 61
    2a20:	be b7       	in	r27, 0x3e	; 62
    2a22:	12 96       	adiw	r26, 0x02	; 2
    2a24:	9c 93       	st	X, r25
    2a26:	8e 93       	st	-X, r24
    2a28:	11 97       	sbiw	r26, 0x01	; 1
    2a2a:	84 e4       	ldi	r24, 0x44	; 68
    2a2c:	91 e1       	ldi	r25, 0x11	; 17
    2a2e:	14 96       	adiw	r26, 0x04	; 4
    2a30:	9c 93       	st	X, r25
    2a32:	8e 93       	st	-X, r24
    2a34:	13 97       	sbiw	r26, 0x03	; 3
    2a36:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("2. AbruptStop. \n"));
    2a3a:	80 91 d0 79 	lds	r24, 0x79D0
    2a3e:	90 91 d1 79 	lds	r25, 0x79D1
    2a42:	ed b7       	in	r30, 0x3d	; 61
    2a44:	fe b7       	in	r31, 0x3e	; 62
    2a46:	92 83       	std	Z+2, r25	; 0x02
    2a48:	81 83       	std	Z+1, r24	; 0x01
    2a4a:	83 e3       	ldi	r24, 0x33	; 51
    2a4c:	91 e1       	ldi	r25, 0x11	; 17
    2a4e:	94 83       	std	Z+4, r25	; 0x04
    2a50:	83 83       	std	Z+3, r24	; 0x03
    2a52:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("3. SmoothStop. \n"));
    2a56:	80 91 d0 79 	lds	r24, 0x79D0
    2a5a:	90 91 d1 79 	lds	r25, 0x79D1
    2a5e:	ad b7       	in	r26, 0x3d	; 61
    2a60:	be b7       	in	r27, 0x3e	; 62
    2a62:	12 96       	adiw	r26, 0x02	; 2
    2a64:	9c 93       	st	X, r25
    2a66:	8e 93       	st	-X, r24
    2a68:	11 97       	sbiw	r26, 0x01	; 1
    2a6a:	82 e2       	ldi	r24, 0x22	; 34
    2a6c:	91 e1       	ldi	r25, 0x11	; 17
    2a6e:	14 96       	adiw	r26, 0x04	; 4
    2a70:	9c 93       	st	X, r25
    2a72:	8e 93       	st	-X, r24
    2a74:	13 97       	sbiw	r26, 0x03	; 3
    2a76:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("4.Motor_OFF. \n"));
    2a7a:	80 91 d0 79 	lds	r24, 0x79D0
    2a7e:	90 91 d1 79 	lds	r25, 0x79D1
    2a82:	ed b7       	in	r30, 0x3d	; 61
    2a84:	fe b7       	in	r31, 0x3e	; 62
    2a86:	92 83       	std	Z+2, r25	; 0x02
    2a88:	81 83       	std	Z+1, r24	; 0x01
    2a8a:	83 e1       	ldi	r24, 0x13	; 19
    2a8c:	91 e1       	ldi	r25, 0x11	; 17
    2a8e:	94 83       	std	Z+4, r25	; 0x04
    2a90:	83 83       	std	Z+3, r24	; 0x03
    2a92:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&accion);			
    2a96:	ec e1       	ldi	r30, 0x1C	; 28
    2a98:	f2 e2       	ldi	r31, 0x22	; 34
    2a9a:	ad b7       	in	r26, 0x3d	; 61
    2a9c:	be b7       	in	r27, 0x3e	; 62
    2a9e:	12 96       	adiw	r26, 0x02	; 2
    2aa0:	fc 93       	st	X, r31
    2aa2:	ee 93       	st	-X, r30
    2aa4:	11 97       	sbiw	r26, 0x01	; 1
    2aa6:	ce 01       	movw	r24, r28
    2aa8:	45 96       	adiw	r24, 0x15	; 21
    2aaa:	14 96       	adiw	r26, 0x04	; 4
    2aac:	9c 93       	st	X, r25
    2aae:	8e 93       	st	-X, r24
    2ab0:	13 97       	sbiw	r26, 0x03	; 3
    2ab2:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						
						fprintf_P(stdout,PSTR("Digite el TRIGGER del BreakPoint \n"));
    2ab6:	80 91 d0 79 	lds	r24, 0x79D0
    2aba:	90 91 d1 79 	lds	r25, 0x79D1
    2abe:	ad b7       	in	r26, 0x3d	; 61
    2ac0:	be b7       	in	r27, 0x3e	; 62
    2ac2:	12 96       	adiw	r26, 0x02	; 2
    2ac4:	9c 93       	st	X, r25
    2ac6:	8e 93       	st	-X, r24
    2ac8:	11 97       	sbiw	r26, 0x01	; 1
    2aca:	80 ef       	ldi	r24, 0xF0	; 240
    2acc:	90 e1       	ldi	r25, 0x10	; 16
    2ace:	14 96       	adiw	r26, 0x04	; 4
    2ad0:	9c 93       	st	X, r25
    2ad2:	8e 93       	st	-X, r24
    2ad4:	13 97       	sbiw	r26, 0x03	; 3
    2ad6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. Ninguno. \n"));
    2ada:	80 91 d0 79 	lds	r24, 0x79D0
    2ade:	90 91 d1 79 	lds	r25, 0x79D1
    2ae2:	ed b7       	in	r30, 0x3d	; 61
    2ae4:	fe b7       	in	r31, 0x3e	; 62
    2ae6:	92 83       	std	Z+2, r25	; 0x02
    2ae8:	81 83       	std	Z+1, r24	; 0x01
    2aea:	82 ee       	ldi	r24, 0xE2	; 226
    2aec:	90 e1       	ldi	r25, 0x10	; 16
    2aee:	94 83       	std	Z+4, r25	; 0x04
    2af0:	83 83       	std	Z+3, r24	; 0x03
    2af2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. GreaterOrEqualCommandedPosition. \n"));
    2af6:	80 91 d0 79 	lds	r24, 0x79D0
    2afa:	90 91 d1 79 	lds	r25, 0x79D1
    2afe:	ad b7       	in	r26, 0x3d	; 61
    2b00:	be b7       	in	r27, 0x3e	; 62
    2b02:	12 96       	adiw	r26, 0x02	; 2
    2b04:	9c 93       	st	X, r25
    2b06:	8e 93       	st	-X, r24
    2b08:	11 97       	sbiw	r26, 0x01	; 1
    2b0a:	8c eb       	ldi	r24, 0xBC	; 188
    2b0c:	90 e1       	ldi	r25, 0x10	; 16
    2b0e:	14 96       	adiw	r26, 0x04	; 4
    2b10:	9c 93       	st	X, r25
    2b12:	8e 93       	st	-X, r24
    2b14:	13 97       	sbiw	r26, 0x03	; 3
    2b16:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("2. LesserOrEqualCommandedPosition. \n"));
    2b1a:	80 91 d0 79 	lds	r24, 0x79D0
    2b1e:	90 91 d1 79 	lds	r25, 0x79D1
    2b22:	ed b7       	in	r30, 0x3d	; 61
    2b24:	fe b7       	in	r31, 0x3e	; 62
    2b26:	92 83       	std	Z+2, r25	; 0x02
    2b28:	81 83       	std	Z+1, r24	; 0x01
    2b2a:	87 e9       	ldi	r24, 0x97	; 151
    2b2c:	90 e1       	ldi	r25, 0x10	; 16
    2b2e:	94 83       	std	Z+4, r25	; 0x04
    2b30:	83 83       	std	Z+3, r24	; 0x03
    2b32:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("3. GreaterOrEqualActualPosition. \n"));
    2b36:	80 91 d0 79 	lds	r24, 0x79D0
    2b3a:	90 91 d1 79 	lds	r25, 0x79D1
    2b3e:	ad b7       	in	r26, 0x3d	; 61
    2b40:	be b7       	in	r27, 0x3e	; 62
    2b42:	12 96       	adiw	r26, 0x02	; 2
    2b44:	9c 93       	st	X, r25
    2b46:	8e 93       	st	-X, r24
    2b48:	11 97       	sbiw	r26, 0x01	; 1
    2b4a:	84 e7       	ldi	r24, 0x74	; 116
    2b4c:	90 e1       	ldi	r25, 0x10	; 16
    2b4e:	14 96       	adiw	r26, 0x04	; 4
    2b50:	9c 93       	st	X, r25
    2b52:	8e 93       	st	-X, r24
    2b54:	13 97       	sbiw	r26, 0x03	; 3
    2b56:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("4. LesserOrEqualActualPosition. \n"));
    2b5a:	80 91 d0 79 	lds	r24, 0x79D0
    2b5e:	90 91 d1 79 	lds	r25, 0x79D1
    2b62:	ed b7       	in	r30, 0x3d	; 61
    2b64:	fe b7       	in	r31, 0x3e	; 62
    2b66:	92 83       	std	Z+2, r25	; 0x02
    2b68:	81 83       	std	Z+1, r24	; 0x01
    2b6a:	82 e5       	ldi	r24, 0x52	; 82
    2b6c:	90 e1       	ldi	r25, 0x10	; 16
    2b6e:	94 83       	std	Z+4, r25	; 0x04
    2b70:	83 83       	std	Z+3, r24	; 0x03
    2b72:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("5. CommandedPositionCrossed. \n"));
    2b76:	80 91 d0 79 	lds	r24, 0x79D0
    2b7a:	90 91 d1 79 	lds	r25, 0x79D1
    2b7e:	ad b7       	in	r26, 0x3d	; 61
    2b80:	be b7       	in	r27, 0x3e	; 62
    2b82:	12 96       	adiw	r26, 0x02	; 2
    2b84:	9c 93       	st	X, r25
    2b86:	8e 93       	st	-X, r24
    2b88:	11 97       	sbiw	r26, 0x01	; 1
    2b8a:	83 e3       	ldi	r24, 0x33	; 51
    2b8c:	90 e1       	ldi	r25, 0x10	; 16
    2b8e:	14 96       	adiw	r26, 0x04	; 4
    2b90:	9c 93       	st	X, r25
    2b92:	8e 93       	st	-X, r24
    2b94:	13 97       	sbiw	r26, 0x03	; 3
    2b96:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("6. ActualPositionCrossed. \n"));
    2b9a:	80 91 d0 79 	lds	r24, 0x79D0
    2b9e:	90 91 d1 79 	lds	r25, 0x79D1
    2ba2:	ed b7       	in	r30, 0x3d	; 61
    2ba4:	fe b7       	in	r31, 0x3e	; 62
    2ba6:	92 83       	std	Z+2, r25	; 0x02
    2ba8:	81 83       	std	Z+1, r24	; 0x01
    2baa:	87 e1       	ldi	r24, 0x17	; 23
    2bac:	90 e1       	ldi	r25, 0x10	; 16
    2bae:	94 83       	std	Z+4, r25	; 0x04
    2bb0:	83 83       	std	Z+3, r24	; 0x03
    2bb2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("7. Time. \n"));
    2bb6:	80 91 d0 79 	lds	r24, 0x79D0
    2bba:	90 91 d1 79 	lds	r25, 0x79D1
    2bbe:	ad b7       	in	r26, 0x3d	; 61
    2bc0:	be b7       	in	r27, 0x3e	; 62
    2bc2:	12 96       	adiw	r26, 0x02	; 2
    2bc4:	9c 93       	st	X, r25
    2bc6:	8e 93       	st	-X, r24
    2bc8:	11 97       	sbiw	r26, 0x01	; 1
    2bca:	8c e0       	ldi	r24, 0x0C	; 12
    2bcc:	90 e1       	ldi	r25, 0x10	; 16
    2bce:	14 96       	adiw	r26, 0x04	; 4
    2bd0:	9c 93       	st	X, r25
    2bd2:	8e 93       	st	-X, r24
    2bd4:	13 97       	sbiw	r26, 0x03	; 3
    2bd6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("8. EventStatus. \n"));
    2bda:	80 91 d0 79 	lds	r24, 0x79D0
    2bde:	90 91 d1 79 	lds	r25, 0x79D1
    2be2:	ed b7       	in	r30, 0x3d	; 61
    2be4:	fe b7       	in	r31, 0x3e	; 62
    2be6:	92 83       	std	Z+2, r25	; 0x02
    2be8:	81 83       	std	Z+1, r24	; 0x01
    2bea:	8a ef       	ldi	r24, 0xFA	; 250
    2bec:	9f e0       	ldi	r25, 0x0F	; 15
    2bee:	94 83       	std	Z+4, r25	; 0x04
    2bf0:	83 83       	std	Z+3, r24	; 0x03
    2bf2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("9. ActivityStatus. \n"));
    2bf6:	80 91 d0 79 	lds	r24, 0x79D0
    2bfa:	90 91 d1 79 	lds	r25, 0x79D1
    2bfe:	ad b7       	in	r26, 0x3d	; 61
    2c00:	be b7       	in	r27, 0x3e	; 62
    2c02:	12 96       	adiw	r26, 0x02	; 2
    2c04:	9c 93       	st	X, r25
    2c06:	8e 93       	st	-X, r24
    2c08:	11 97       	sbiw	r26, 0x01	; 1
    2c0a:	85 ee       	ldi	r24, 0xE5	; 229
    2c0c:	9f e0       	ldi	r25, 0x0F	; 15
    2c0e:	14 96       	adiw	r26, 0x04	; 4
    2c10:	9c 93       	st	X, r25
    2c12:	8e 93       	st	-X, r24
    2c14:	13 97       	sbiw	r26, 0x03	; 3
    2c16:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("10.SignalStatus. \n"));
    2c1a:	80 91 d0 79 	lds	r24, 0x79D0
    2c1e:	90 91 d1 79 	lds	r25, 0x79D1
    2c22:	ed b7       	in	r30, 0x3d	; 61
    2c24:	fe b7       	in	r31, 0x3e	; 62
    2c26:	92 83       	std	Z+2, r25	; 0x02
    2c28:	81 83       	std	Z+1, r24	; 0x01
    2c2a:	82 ed       	ldi	r24, 0xD2	; 210
    2c2c:	9f e0       	ldi	r25, 0x0F	; 15
    2c2e:	94 83       	std	Z+4, r25	; 0x04
    2c30:	83 83       	std	Z+3, r24	; 0x03
    2c32:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&trigger);			
    2c36:	ec e1       	ldi	r30, 0x1C	; 28
    2c38:	f2 e2       	ldi	r31, 0x22	; 34
    2c3a:	ad b7       	in	r26, 0x3d	; 61
    2c3c:	be b7       	in	r27, 0x3e	; 62
    2c3e:	12 96       	adiw	r26, 0x02	; 2
    2c40:	fc 93       	st	X, r31
    2c42:	ee 93       	st	-X, r30
    2c44:	11 97       	sbiw	r26, 0x01	; 1
    2c46:	ce 01       	movw	r24, r28
    2c48:	47 96       	adiw	r24, 0x17	; 23
    2c4a:	14 96       	adiw	r26, 0x04	; 4
    2c4c:	9c 93       	st	X, r25
    2c4e:	8e 93       	st	-X, r24
    2c50:	13 97       	sbiw	r26, 0x03	; 3
    2c52:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						
						fprintf_P(stdout,PSTR("Digite el valor del Trigger \n"));
    2c56:	80 91 d0 79 	lds	r24, 0x79D0
    2c5a:	90 91 d1 79 	lds	r25, 0x79D1
    2c5e:	ad b7       	in	r26, 0x3d	; 61
    2c60:	be b7       	in	r27, 0x3e	; 62
    2c62:	12 96       	adiw	r26, 0x02	; 2
    2c64:	9c 93       	st	X, r25
    2c66:	8e 93       	st	-X, r24
    2c68:	11 97       	sbiw	r26, 0x01	; 1
    2c6a:	84 eb       	ldi	r24, 0xB4	; 180
    2c6c:	9f e0       	ldi	r25, 0x0F	; 15
    2c6e:	14 96       	adiw	r26, 0x04	; 4
    2c70:	9c 93       	st	X, r25
    2c72:	8e 93       	st	-X, r24
    2c74:	13 97       	sbiw	r26, 0x03	; 3
    2c76:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%ld",&value);			
    2c7a:	8f e1       	ldi	r24, 0x1F	; 31
    2c7c:	92 e2       	ldi	r25, 0x22	; 34
    2c7e:	ed b7       	in	r30, 0x3d	; 61
    2c80:	fe b7       	in	r31, 0x3e	; 62
    2c82:	92 83       	std	Z+2, r25	; 0x02
    2c84:	81 83       	std	Z+1, r24	; 0x01
    2c86:	4d e4       	ldi	r20, 0x4D	; 77
    2c88:	e4 2e       	mov	r14, r20
    2c8a:	f1 2c       	mov	r15, r1
    2c8c:	ec 0e       	add	r14, r28
    2c8e:	fd 1e       	adc	r15, r29
    2c90:	f4 82       	std	Z+4, r15	; 0x04
    2c92:	e3 82       	std	Z+3, r14	; 0x03
    2c94:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						
						Config_BreakPoint(eje_break, Breakpoint_id, source_Axis, accion, trigger,value);
    2c98:	0f 90       	pop	r0
    2c9a:	0f 90       	pop	r0
    2c9c:	0f 90       	pop	r0
    2c9e:	0f 90       	pop	r0
    2ca0:	69 89       	ldd	r22, Y+17	; 0x11
    2ca2:	7a 89       	ldd	r23, Y+18	; 0x12
    2ca4:	4b 89       	ldd	r20, Y+19	; 0x13
    2ca6:	5c 89       	ldd	r21, Y+20	; 0x14
    2ca8:	2d 89       	ldd	r18, Y+21	; 0x15
    2caa:	3e 89       	ldd	r19, Y+22	; 0x16
    2cac:	0f 89       	ldd	r16, Y+23	; 0x17
    2cae:	18 8d       	ldd	r17, Y+24	; 0x18
    2cb0:	d7 01       	movw	r26, r14
    2cb2:	cd 90       	ld	r12, X+
    2cb4:	dd 90       	ld	r13, X+
    2cb6:	ed 90       	ld	r14, X+
    2cb8:	fc 90       	ld	r15, X
    2cba:	8f 85       	ldd	r24, Y+15	; 0x0f
    2cbc:	98 89       	ldd	r25, Y+16	; 0x10
    2cbe:	0e 94 ec 40 	call	0x81d8	; 0x81d8 <Config_BreakPoint>
    2cc2:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
					break;
				}	
			break;
			
			case (3)://FUNCIONES DEL RELOJ DE TIEMPO REAL
				fprintf_P(stdout,PSTR("0. Escribir Fecha \n"));
    2cc6:	00 d0       	rcall	.+0      	; 0x2cc8 <__stack+0xac9>
    2cc8:	00 d0       	rcall	.+0      	; 0x2cca <__stack+0xacb>
    2cca:	80 91 d0 79 	lds	r24, 0x79D0
    2cce:	90 91 d1 79 	lds	r25, 0x79D1
    2cd2:	ed b7       	in	r30, 0x3d	; 61
    2cd4:	fe b7       	in	r31, 0x3e	; 62
    2cd6:	92 83       	std	Z+2, r25	; 0x02
    2cd8:	81 83       	std	Z+1, r24	; 0x01
    2cda:	80 ea       	ldi	r24, 0xA0	; 160
    2cdc:	9f e0       	ldi	r25, 0x0F	; 15
    2cde:	94 83       	std	Z+4, r25	; 0x04
    2ce0:	83 83       	std	Z+3, r24	; 0x03
    2ce2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("1. Escribir en el Control de Registros del RTC \n"));
    2ce6:	80 91 d0 79 	lds	r24, 0x79D0
    2cea:	90 91 d1 79 	lds	r25, 0x79D1
    2cee:	ad b7       	in	r26, 0x3d	; 61
    2cf0:	be b7       	in	r27, 0x3e	; 62
    2cf2:	12 96       	adiw	r26, 0x02	; 2
    2cf4:	9c 93       	st	X, r25
    2cf6:	8e 93       	st	-X, r24
    2cf8:	11 97       	sbiw	r26, 0x01	; 1
    2cfa:	8f e6       	ldi	r24, 0x6F	; 111
    2cfc:	9f e0       	ldi	r25, 0x0F	; 15
    2cfe:	14 96       	adiw	r26, 0x04	; 4
    2d00:	9c 93       	st	X, r25
    2d02:	8e 93       	st	-X, r24
    2d04:	13 97       	sbiw	r26, 0x03	; 3
    2d06:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("2. Configurar Alarma \n"));
    2d0a:	80 91 d0 79 	lds	r24, 0x79D0
    2d0e:	90 91 d1 79 	lds	r25, 0x79D1
    2d12:	ed b7       	in	r30, 0x3d	; 61
    2d14:	fe b7       	in	r31, 0x3e	; 62
    2d16:	92 83       	std	Z+2, r25	; 0x02
    2d18:	81 83       	std	Z+1, r24	; 0x01
    2d1a:	88 e5       	ldi	r24, 0x58	; 88
    2d1c:	9f e0       	ldi	r25, 0x0F	; 15
    2d1e:	94 83       	std	Z+4, r25	; 0x04
    2d20:	83 83       	std	Z+3, r24	; 0x03
    2d22:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("3. Leer Fecha \n"));
    2d26:	80 91 d0 79 	lds	r24, 0x79D0
    2d2a:	90 91 d1 79 	lds	r25, 0x79D1
    2d2e:	ad b7       	in	r26, 0x3d	; 61
    2d30:	be b7       	in	r27, 0x3e	; 62
    2d32:	12 96       	adiw	r26, 0x02	; 2
    2d34:	9c 93       	st	X, r25
    2d36:	8e 93       	st	-X, r24
    2d38:	11 97       	sbiw	r26, 0x01	; 1
    2d3a:	88 e4       	ldi	r24, 0x48	; 72
    2d3c:	9f e0       	ldi	r25, 0x0F	; 15
    2d3e:	14 96       	adiw	r26, 0x04	; 4
    2d40:	9c 93       	st	X, r25
    2d42:	8e 93       	st	-X, r24
    2d44:	13 97       	sbiw	r26, 0x03	; 3
    2d46:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("4. Leer El Status Register del RTC \n"));
    2d4a:	80 91 d0 79 	lds	r24, 0x79D0
    2d4e:	90 91 d1 79 	lds	r25, 0x79D1
    2d52:	ed b7       	in	r30, 0x3d	; 61
    2d54:	fe b7       	in	r31, 0x3e	; 62
    2d56:	92 83       	std	Z+2, r25	; 0x02
    2d58:	81 83       	std	Z+1, r24	; 0x01
    2d5a:	83 e2       	ldi	r24, 0x23	; 35
    2d5c:	9f e0       	ldi	r25, 0x0F	; 15
    2d5e:	94 83       	std	Z+4, r25	; 0x04
    2d60:	83 83       	std	Z+3, r24	; 0x03
    2d62:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("5. Leer el Control de Registros del RTC \n"));
    2d66:	80 91 d0 79 	lds	r24, 0x79D0
    2d6a:	90 91 d1 79 	lds	r25, 0x79D1
    2d6e:	ad b7       	in	r26, 0x3d	; 61
    2d70:	be b7       	in	r27, 0x3e	; 62
    2d72:	12 96       	adiw	r26, 0x02	; 2
    2d74:	9c 93       	st	X, r25
    2d76:	8e 93       	st	-X, r24
    2d78:	11 97       	sbiw	r26, 0x01	; 1
    2d7a:	89 ef       	ldi	r24, 0xF9	; 249
    2d7c:	9e e0       	ldi	r25, 0x0E	; 14
    2d7e:	14 96       	adiw	r26, 0x04	; 4
    2d80:	9c 93       	st	X, r25
    2d82:	8e 93       	st	-X, r24
    2d84:	13 97       	sbiw	r26, 0x03	; 3
    2d86:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("Otra Opcion: Salir SubMenu \n"));
    2d8a:	80 91 d0 79 	lds	r24, 0x79D0
    2d8e:	90 91 d1 79 	lds	r25, 0x79D1
    2d92:	ed b7       	in	r30, 0x3d	; 61
    2d94:	fe b7       	in	r31, 0x3e	; 62
    2d96:	92 83       	std	Z+2, r25	; 0x02
    2d98:	81 83       	std	Z+1, r24	; 0x01
    2d9a:	8c ed       	ldi	r24, 0xDC	; 220
    2d9c:	9e e0       	ldi	r25, 0x0E	; 14
    2d9e:	94 83       	std	Z+4, r25	; 0x04
    2da0:	83 83       	std	Z+3, r24	; 0x03
    2da2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				scanf("%d",&submenu);
    2da6:	ec e1       	ldi	r30, 0x1C	; 28
    2da8:	f2 e2       	ldi	r31, 0x22	; 34
    2daa:	ad b7       	in	r26, 0x3d	; 61
    2dac:	be b7       	in	r27, 0x3e	; 62
    2dae:	12 96       	adiw	r26, 0x02	; 2
    2db0:	fc 93       	st	X, r31
    2db2:	ee 93       	st	-X, r30
    2db4:	11 97       	sbiw	r26, 0x01	; 1
    2db6:	ce 01       	movw	r24, r28
    2db8:	05 96       	adiw	r24, 0x05	; 5
    2dba:	14 96       	adiw	r26, 0x04	; 4
    2dbc:	9c 93       	st	X, r25
    2dbe:	8e 93       	st	-X, r24
    2dc0:	13 97       	sbiw	r26, 0x03	; 3
    2dc2:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
				
				switch (submenu)
    2dc6:	0f 90       	pop	r0
    2dc8:	0f 90       	pop	r0
    2dca:	0f 90       	pop	r0
    2dcc:	0f 90       	pop	r0
    2dce:	8d 81       	ldd	r24, Y+5	; 0x05
    2dd0:	9e 81       	ldd	r25, Y+6	; 0x06
    2dd2:	82 30       	cpi	r24, 0x02	; 2
    2dd4:	91 05       	cpc	r25, r1
    2dd6:	09 f4       	brne	.+2      	; 0x2dda <__stack+0xbdb>
    2dd8:	b1 c3       	rjmp	.+1890   	; 0x353c <__stack+0x133d>
    2dda:	83 30       	cpi	r24, 0x03	; 3
    2ddc:	91 05       	cpc	r25, r1
    2dde:	3c f4       	brge	.+14     	; 0x2dee <__stack+0xbef>
    2de0:	00 97       	sbiw	r24, 0x00	; 0
    2de2:	a1 f0       	breq	.+40     	; 0x2e0c <__stack+0xc0d>
    2de4:	01 97       	sbiw	r24, 0x01	; 1
    2de6:	11 f0       	breq	.+4      	; 0x2dec <__stack+0xbed>
    2de8:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
    2dec:	bb c1       	rjmp	.+886    	; 0x3164 <__stack+0xf65>
    2dee:	84 30       	cpi	r24, 0x04	; 4
    2df0:	91 05       	cpc	r25, r1
    2df2:	11 f4       	brne	.+4      	; 0x2df8 <__stack+0xbf9>
    2df4:	0c 94 f2 1e 	jmp	0x3de4	; 0x3de4 <__stack+0x1be5>
    2df8:	84 30       	cpi	r24, 0x04	; 4
    2dfa:	91 05       	cpc	r25, r1
    2dfc:	0c f4       	brge	.+2      	; 0x2e00 <__stack+0xc01>
    2dfe:	7f c7       	rjmp	.+3838   	; 0x3cfe <__stack+0x1aff>
    2e00:	05 97       	sbiw	r24, 0x05	; 5
    2e02:	11 f0       	breq	.+4      	; 0x2e08 <__stack+0xc09>
    2e04:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
    2e08:	0c 94 31 20 	jmp	0x4062	; 0x4062 <__stack+0x1e63>
				{
					case (0):
						//Configuro el ano 20 (para 2000)
						Fecha.y2k=0x20;			
    2e0c:	80 e2       	ldi	r24, 0x20	; 32
    2e0e:	80 93 6e 78 	sts	0x786E, r24
						fprintf_P(stdout,PSTR("Digite el Valor en Segundos. 0-59 \n"));
    2e12:	00 d0       	rcall	.+0      	; 0x2e14 <__stack+0xc15>
    2e14:	00 d0       	rcall	.+0      	; 0x2e16 <__stack+0xc17>
    2e16:	80 91 d0 79 	lds	r24, 0x79D0
    2e1a:	90 91 d1 79 	lds	r25, 0x79D1
    2e1e:	ad b7       	in	r26, 0x3d	; 61
    2e20:	be b7       	in	r27, 0x3e	; 62
    2e22:	12 96       	adiw	r26, 0x02	; 2
    2e24:	9c 93       	st	X, r25
    2e26:	8e 93       	st	-X, r24
    2e28:	11 97       	sbiw	r26, 0x01	; 1
    2e2a:	88 eb       	ldi	r24, 0xB8	; 184
    2e2c:	9e e0       	ldi	r25, 0x0E	; 14
    2e2e:	14 96       	adiw	r26, 0x04	; 4
    2e30:	9c 93       	st	X, r25
    2e32:	8e 93       	st	-X, r24
    2e34:	13 97       	sbiw	r26, 0x03	; 3
    2e36:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%x",(int16 *)&Fecha.sc);			
    2e3a:	0b ea       	ldi	r16, 0xAB	; 171
    2e3c:	13 e2       	ldi	r17, 0x23	; 35
    2e3e:	ed b7       	in	r30, 0x3d	; 61
    2e40:	fe b7       	in	r31, 0x3e	; 62
    2e42:	12 83       	std	Z+2, r17	; 0x02
    2e44:	01 83       	std	Z+1, r16	; 0x01
    2e46:	cc 56       	subi	r28, 0x6C	; 108
    2e48:	df 4f       	sbci	r29, 0xFF	; 255
    2e4a:	28 81       	ld	r18, Y
    2e4c:	39 81       	ldd	r19, Y+1	; 0x01
    2e4e:	c4 59       	subi	r28, 0x94	; 148
    2e50:	d0 40       	sbci	r29, 0x00	; 0
    2e52:	34 83       	std	Z+4, r19	; 0x04
    2e54:	23 83       	std	Z+3, r18	; 0x03
    2e56:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						fprintf_P(stdout,PSTR("Digite el Valor en Minutos. 0-59 \n"));
    2e5a:	80 91 d0 79 	lds	r24, 0x79D0
    2e5e:	90 91 d1 79 	lds	r25, 0x79D1
    2e62:	ad b7       	in	r26, 0x3d	; 61
    2e64:	be b7       	in	r27, 0x3e	; 62
    2e66:	12 96       	adiw	r26, 0x02	; 2
    2e68:	9c 93       	st	X, r25
    2e6a:	8e 93       	st	-X, r24
    2e6c:	11 97       	sbiw	r26, 0x01	; 1
    2e6e:	85 e9       	ldi	r24, 0x95	; 149
    2e70:	9e e0       	ldi	r25, 0x0E	; 14
    2e72:	14 96       	adiw	r26, 0x04	; 4
    2e74:	9c 93       	st	X, r25
    2e76:	8e 93       	st	-X, r24
    2e78:	13 97       	sbiw	r26, 0x03	; 3
    2e7a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%x",(int16 *)&Fecha.mn);			
    2e7e:	ed b7       	in	r30, 0x3d	; 61
    2e80:	fe b7       	in	r31, 0x3e	; 62
    2e82:	12 83       	std	Z+2, r17	; 0x02
    2e84:	01 83       	std	Z+1, r16	; 0x01
    2e86:	28 e6       	ldi	r18, 0x68	; 104
    2e88:	38 e7       	ldi	r19, 0x78	; 120
    2e8a:	34 83       	std	Z+4, r19	; 0x04
    2e8c:	23 83       	std	Z+3, r18	; 0x03
    2e8e:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						fprintf_P(stdout,PSTR("Digite el Valor de la Hora  \n"));
    2e92:	80 91 d0 79 	lds	r24, 0x79D0
    2e96:	90 91 d1 79 	lds	r25, 0x79D1
    2e9a:	ad b7       	in	r26, 0x3d	; 61
    2e9c:	be b7       	in	r27, 0x3e	; 62
    2e9e:	12 96       	adiw	r26, 0x02	; 2
    2ea0:	9c 93       	st	X, r25
    2ea2:	8e 93       	st	-X, r24
    2ea4:	11 97       	sbiw	r26, 0x01	; 1
    2ea6:	87 e7       	ldi	r24, 0x77	; 119
    2ea8:	9e e0       	ldi	r25, 0x0E	; 14
    2eaa:	14 96       	adiw	r26, 0x04	; 4
    2eac:	9c 93       	st	X, r25
    2eae:	8e 93       	st	-X, r24
    2eb0:	13 97       	sbiw	r26, 0x03	; 3
    2eb2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%x",(int16 *)&Fecha.hr);			
    2eb6:	ed b7       	in	r30, 0x3d	; 61
    2eb8:	fe b7       	in	r31, 0x3e	; 62
    2eba:	12 83       	std	Z+2, r17	; 0x02
    2ebc:	01 83       	std	Z+1, r16	; 0x01
    2ebe:	cc 56       	subi	r28, 0x6C	; 108
    2ec0:	df 4f       	sbci	r29, 0xFF	; 255
    2ec2:	28 81       	ld	r18, Y
    2ec4:	39 81       	ldd	r19, Y+1	; 0x01
    2ec6:	c4 59       	subi	r28, 0x94	; 148
    2ec8:	d0 40       	sbci	r29, 0x00	; 0
    2eca:	2e 5f       	subi	r18, 0xFE	; 254
    2ecc:	3f 4f       	sbci	r19, 0xFF	; 255
    2ece:	34 83       	std	Z+4, r19	; 0x04
    2ed0:	23 83       	std	Z+3, r18	; 0x03
    2ed2:	22 50       	subi	r18, 0x02	; 2
    2ed4:	30 40       	sbci	r19, 0x00	; 0
    2ed6:	cc 56       	subi	r28, 0x6C	; 108
    2ed8:	df 4f       	sbci	r29, 0xFF	; 255
    2eda:	39 83       	std	Y+1, r19	; 0x01
    2edc:	28 83       	st	Y, r18
    2ede:	c4 59       	subi	r28, 0x94	; 148
    2ee0:	d0 40       	sbci	r29, 0x00	; 0
    2ee2:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						fprintf_P(stdout,PSTR("0.AM  \n"));
    2ee6:	80 91 d0 79 	lds	r24, 0x79D0
    2eea:	90 91 d1 79 	lds	r25, 0x79D1
    2eee:	ad b7       	in	r26, 0x3d	; 61
    2ef0:	be b7       	in	r27, 0x3e	; 62
    2ef2:	12 96       	adiw	r26, 0x02	; 2
    2ef4:	9c 93       	st	X, r25
    2ef6:	8e 93       	st	-X, r24
    2ef8:	11 97       	sbiw	r26, 0x01	; 1
    2efa:	8f e6       	ldi	r24, 0x6F	; 111
    2efc:	9e e0       	ldi	r25, 0x0E	; 14
    2efe:	14 96       	adiw	r26, 0x04	; 4
    2f00:	9c 93       	st	X, r25
    2f02:	8e 93       	st	-X, r24
    2f04:	13 97       	sbiw	r26, 0x03	; 3
    2f06:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1.PM  \n"));
    2f0a:	80 91 d0 79 	lds	r24, 0x79D0
    2f0e:	90 91 d1 79 	lds	r25, 0x79D1
    2f12:	ed b7       	in	r30, 0x3d	; 61
    2f14:	fe b7       	in	r31, 0x3e	; 62
    2f16:	92 83       	std	Z+2, r25	; 0x02
    2f18:	81 83       	std	Z+1, r24	; 0x01
    2f1a:	87 e6       	ldi	r24, 0x67	; 103
    2f1c:	9e e0       	ldi	r25, 0x0E	; 14
    2f1e:	94 83       	std	Z+4, r25	; 0x04
    2f20:	83 83       	std	Z+3, r24	; 0x03
    2f22:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&ask);			
    2f26:	ec e1       	ldi	r30, 0x1C	; 28
    2f28:	f2 e2       	ldi	r31, 0x22	; 34
    2f2a:	ad b7       	in	r26, 0x3d	; 61
    2f2c:	be b7       	in	r27, 0x3e	; 62
    2f2e:	12 96       	adiw	r26, 0x02	; 2
    2f30:	fc 93       	st	X, r31
    2f32:	ee 93       	st	-X, r30
    2f34:	11 97       	sbiw	r26, 0x01	; 1
    2f36:	87 e1       	ldi	r24, 0x17	; 23
    2f38:	95 e7       	ldi	r25, 0x75	; 117
    2f3a:	14 96       	adiw	r26, 0x04	; 4
    2f3c:	9c 93       	st	X, r25
    2f3e:	8e 93       	st	-X, r24
    2f40:	13 97       	sbiw	r26, 0x03	; 3
    2f42:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						if(ask==1)
    2f46:	0f 90       	pop	r0
    2f48:	0f 90       	pop	r0
    2f4a:	0f 90       	pop	r0
    2f4c:	0f 90       	pop	r0
    2f4e:	80 91 17 75 	lds	r24, 0x7517
    2f52:	90 91 18 75 	lds	r25, 0x7518
    2f56:	01 97       	sbiw	r24, 0x01	; 1
    2f58:	29 f4       	brne	.+10     	; 0x2f64 <__stack+0xd65>
							Fecha.hr= Fecha.hr | 0x20;			
    2f5a:	80 91 69 78 	lds	r24, 0x7869
    2f5e:	80 62       	ori	r24, 0x20	; 32
    2f60:	80 93 69 78 	sts	0x7869, r24
						fprintf_P(stdout,PSTR("Digite el Dia. 1-31 \n"));
    2f64:	00 d0       	rcall	.+0      	; 0x2f66 <__stack+0xd67>
    2f66:	00 d0       	rcall	.+0      	; 0x2f68 <__stack+0xd69>
    2f68:	80 91 d0 79 	lds	r24, 0x79D0
    2f6c:	90 91 d1 79 	lds	r25, 0x79D1
    2f70:	ad b7       	in	r26, 0x3d	; 61
    2f72:	be b7       	in	r27, 0x3e	; 62
    2f74:	12 96       	adiw	r26, 0x02	; 2
    2f76:	9c 93       	st	X, r25
    2f78:	8e 93       	st	-X, r24
    2f7a:	11 97       	sbiw	r26, 0x01	; 1
    2f7c:	81 e5       	ldi	r24, 0x51	; 81
    2f7e:	9e e0       	ldi	r25, 0x0E	; 14
    2f80:	14 96       	adiw	r26, 0x04	; 4
    2f82:	9c 93       	st	X, r25
    2f84:	8e 93       	st	-X, r24
    2f86:	13 97       	sbiw	r26, 0x03	; 3
    2f88:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%x",(int16 *)&Fecha.dt);			
    2f8c:	0b ea       	ldi	r16, 0xAB	; 171
    2f8e:	13 e2       	ldi	r17, 0x23	; 35
    2f90:	ed b7       	in	r30, 0x3d	; 61
    2f92:	fe b7       	in	r31, 0x3e	; 62
    2f94:	12 83       	std	Z+2, r17	; 0x02
    2f96:	01 83       	std	Z+1, r16	; 0x01
    2f98:	2a e6       	ldi	r18, 0x6A	; 106
    2f9a:	38 e7       	ldi	r19, 0x78	; 120
    2f9c:	34 83       	std	Z+4, r19	; 0x04
    2f9e:	23 83       	std	Z+3, r18	; 0x03
    2fa0:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						fprintf_P(stdout,PSTR("Digite el Mes. 1-12 \n"));
    2fa4:	80 91 d0 79 	lds	r24, 0x79D0
    2fa8:	90 91 d1 79 	lds	r25, 0x79D1
    2fac:	ad b7       	in	r26, 0x3d	; 61
    2fae:	be b7       	in	r27, 0x3e	; 62
    2fb0:	12 96       	adiw	r26, 0x02	; 2
    2fb2:	9c 93       	st	X, r25
    2fb4:	8e 93       	st	-X, r24
    2fb6:	11 97       	sbiw	r26, 0x01	; 1
    2fb8:	8b e3       	ldi	r24, 0x3B	; 59
    2fba:	9e e0       	ldi	r25, 0x0E	; 14
    2fbc:	14 96       	adiw	r26, 0x04	; 4
    2fbe:	9c 93       	st	X, r25
    2fc0:	8e 93       	st	-X, r24
    2fc2:	13 97       	sbiw	r26, 0x03	; 3
    2fc4:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%x",(int16 *)&Fecha.mo);			
    2fc8:	ed b7       	in	r30, 0x3d	; 61
    2fca:	fe b7       	in	r31, 0x3e	; 62
    2fcc:	12 83       	std	Z+2, r17	; 0x02
    2fce:	01 83       	std	Z+1, r16	; 0x01
    2fd0:	2b e6       	ldi	r18, 0x6B	; 107
    2fd2:	38 e7       	ldi	r19, 0x78	; 120
    2fd4:	34 83       	std	Z+4, r19	; 0x04
    2fd6:	23 83       	std	Z+3, r18	; 0x03
    2fd8:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						fprintf_P(stdout,PSTR("Digite el Ano. 0-99 \n"));
    2fdc:	80 91 d0 79 	lds	r24, 0x79D0
    2fe0:	90 91 d1 79 	lds	r25, 0x79D1
    2fe4:	ad b7       	in	r26, 0x3d	; 61
    2fe6:	be b7       	in	r27, 0x3e	; 62
    2fe8:	12 96       	adiw	r26, 0x02	; 2
    2fea:	9c 93       	st	X, r25
    2fec:	8e 93       	st	-X, r24
    2fee:	11 97       	sbiw	r26, 0x01	; 1
    2ff0:	85 e2       	ldi	r24, 0x25	; 37
    2ff2:	9e e0       	ldi	r25, 0x0E	; 14
    2ff4:	14 96       	adiw	r26, 0x04	; 4
    2ff6:	9c 93       	st	X, r25
    2ff8:	8e 93       	st	-X, r24
    2ffa:	13 97       	sbiw	r26, 0x03	; 3
    2ffc:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%x",(int16 *)&Fecha.yr);			
    3000:	ed b7       	in	r30, 0x3d	; 61
    3002:	fe b7       	in	r31, 0x3e	; 62
    3004:	12 83       	std	Z+2, r17	; 0x02
    3006:	01 83       	std	Z+1, r16	; 0x01
    3008:	8a e6       	ldi	r24, 0x6A	; 106
    300a:	98 e7       	ldi	r25, 0x78	; 120
    300c:	02 96       	adiw	r24, 0x02	; 2
    300e:	94 83       	std	Z+4, r25	; 0x04
    3010:	83 83       	std	Z+3, r24	; 0x03
    3012:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						fprintf_P(stdout,PSTR("Digite el dia de la Semana. \n"));
    3016:	80 91 d0 79 	lds	r24, 0x79D0
    301a:	90 91 d1 79 	lds	r25, 0x79D1
    301e:	ad b7       	in	r26, 0x3d	; 61
    3020:	be b7       	in	r27, 0x3e	; 62
    3022:	12 96       	adiw	r26, 0x02	; 2
    3024:	9c 93       	st	X, r25
    3026:	8e 93       	st	-X, r24
    3028:	11 97       	sbiw	r26, 0x01	; 1
    302a:	87 e0       	ldi	r24, 0x07	; 7
    302c:	9e e0       	ldi	r25, 0x0E	; 14
    302e:	14 96       	adiw	r26, 0x04	; 4
    3030:	9c 93       	st	X, r25
    3032:	8e 93       	st	-X, r24
    3034:	13 97       	sbiw	r26, 0x03	; 3
    3036:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. Domingo \n"));
    303a:	80 91 d0 79 	lds	r24, 0x79D0
    303e:	90 91 d1 79 	lds	r25, 0x79D1
    3042:	ed b7       	in	r30, 0x3d	; 61
    3044:	fe b7       	in	r31, 0x3e	; 62
    3046:	92 83       	std	Z+2, r25	; 0x02
    3048:	81 83       	std	Z+1, r24	; 0x01
    304a:	8a ef       	ldi	r24, 0xFA	; 250
    304c:	9d e0       	ldi	r25, 0x0D	; 13
    304e:	94 83       	std	Z+4, r25	; 0x04
    3050:	83 83       	std	Z+3, r24	; 0x03
    3052:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. Lunes \n"));
    3056:	80 91 d0 79 	lds	r24, 0x79D0
    305a:	90 91 d1 79 	lds	r25, 0x79D1
    305e:	ad b7       	in	r26, 0x3d	; 61
    3060:	be b7       	in	r27, 0x3e	; 62
    3062:	12 96       	adiw	r26, 0x02	; 2
    3064:	9c 93       	st	X, r25
    3066:	8e 93       	st	-X, r24
    3068:	11 97       	sbiw	r26, 0x01	; 1
    306a:	8f ee       	ldi	r24, 0xEF	; 239
    306c:	9d e0       	ldi	r25, 0x0D	; 13
    306e:	14 96       	adiw	r26, 0x04	; 4
    3070:	9c 93       	st	X, r25
    3072:	8e 93       	st	-X, r24
    3074:	13 97       	sbiw	r26, 0x03	; 3
    3076:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("2. Martes \n"));
    307a:	80 91 d0 79 	lds	r24, 0x79D0
    307e:	90 91 d1 79 	lds	r25, 0x79D1
    3082:	ed b7       	in	r30, 0x3d	; 61
    3084:	fe b7       	in	r31, 0x3e	; 62
    3086:	92 83       	std	Z+2, r25	; 0x02
    3088:	81 83       	std	Z+1, r24	; 0x01
    308a:	83 ee       	ldi	r24, 0xE3	; 227
    308c:	9d e0       	ldi	r25, 0x0D	; 13
    308e:	94 83       	std	Z+4, r25	; 0x04
    3090:	83 83       	std	Z+3, r24	; 0x03
    3092:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("3. Miercoles \n"));
    3096:	80 91 d0 79 	lds	r24, 0x79D0
    309a:	90 91 d1 79 	lds	r25, 0x79D1
    309e:	ad b7       	in	r26, 0x3d	; 61
    30a0:	be b7       	in	r27, 0x3e	; 62
    30a2:	12 96       	adiw	r26, 0x02	; 2
    30a4:	9c 93       	st	X, r25
    30a6:	8e 93       	st	-X, r24
    30a8:	11 97       	sbiw	r26, 0x01	; 1
    30aa:	84 ed       	ldi	r24, 0xD4	; 212
    30ac:	9d e0       	ldi	r25, 0x0D	; 13
    30ae:	14 96       	adiw	r26, 0x04	; 4
    30b0:	9c 93       	st	X, r25
    30b2:	8e 93       	st	-X, r24
    30b4:	13 97       	sbiw	r26, 0x03	; 3
    30b6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("4. Jueves \n"));
    30ba:	80 91 d0 79 	lds	r24, 0x79D0
    30be:	90 91 d1 79 	lds	r25, 0x79D1
    30c2:	ed b7       	in	r30, 0x3d	; 61
    30c4:	fe b7       	in	r31, 0x3e	; 62
    30c6:	92 83       	std	Z+2, r25	; 0x02
    30c8:	81 83       	std	Z+1, r24	; 0x01
    30ca:	88 ec       	ldi	r24, 0xC8	; 200
    30cc:	9d e0       	ldi	r25, 0x0D	; 13
    30ce:	94 83       	std	Z+4, r25	; 0x04
    30d0:	83 83       	std	Z+3, r24	; 0x03
    30d2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("5. Viernes \n"));
    30d6:	80 91 d0 79 	lds	r24, 0x79D0
    30da:	90 91 d1 79 	lds	r25, 0x79D1
    30de:	ad b7       	in	r26, 0x3d	; 61
    30e0:	be b7       	in	r27, 0x3e	; 62
    30e2:	12 96       	adiw	r26, 0x02	; 2
    30e4:	9c 93       	st	X, r25
    30e6:	8e 93       	st	-X, r24
    30e8:	11 97       	sbiw	r26, 0x01	; 1
    30ea:	8b eb       	ldi	r24, 0xBB	; 187
    30ec:	9d e0       	ldi	r25, 0x0D	; 13
    30ee:	14 96       	adiw	r26, 0x04	; 4
    30f0:	9c 93       	st	X, r25
    30f2:	8e 93       	st	-X, r24
    30f4:	13 97       	sbiw	r26, 0x03	; 3
    30f6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("6. Sabado \n"));
    30fa:	80 91 d0 79 	lds	r24, 0x79D0
    30fe:	90 91 d1 79 	lds	r25, 0x79D1
    3102:	ed b7       	in	r30, 0x3d	; 61
    3104:	fe b7       	in	r31, 0x3e	; 62
    3106:	92 83       	std	Z+2, r25	; 0x02
    3108:	81 83       	std	Z+1, r24	; 0x01
    310a:	8f ea       	ldi	r24, 0xAF	; 175
    310c:	9d e0       	ldi	r25, 0x0D	; 13
    310e:	94 83       	std	Z+4, r25	; 0x04
    3110:	83 83       	std	Z+3, r24	; 0x03
    3112:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%x",(int16 *)&Fecha.dw);			
    3116:	ad b7       	in	r26, 0x3d	; 61
    3118:	be b7       	in	r27, 0x3e	; 62
    311a:	12 96       	adiw	r26, 0x02	; 2
    311c:	1c 93       	st	X, r17
    311e:	0e 93       	st	-X, r16
    3120:	11 97       	sbiw	r26, 0x01	; 1
    3122:	8a e6       	ldi	r24, 0x6A	; 106
    3124:	98 e7       	ldi	r25, 0x78	; 120
    3126:	03 96       	adiw	r24, 0x03	; 3
    3128:	14 96       	adiw	r26, 0x04	; 4
    312a:	9c 93       	st	X, r25
    312c:	8e 93       	st	-X, r24
    312e:	13 97       	sbiw	r26, 0x03	; 3
    3130:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						write_Fecha(Fecha);
    3134:	0f 90       	pop	r0
    3136:	0f 90       	pop	r0
    3138:	0f 90       	pop	r0
    313a:	0f 90       	pop	r0
    313c:	20 91 67 78 	lds	r18, 0x7867
    3140:	30 91 68 78 	lds	r19, 0x7868
    3144:	40 91 69 78 	lds	r20, 0x7869
    3148:	50 91 6a 78 	lds	r21, 0x786A
    314c:	60 91 6b 78 	lds	r22, 0x786B
    3150:	70 91 6c 78 	lds	r23, 0x786C
    3154:	80 91 6d 78 	lds	r24, 0x786D
    3158:	90 91 6e 78 	lds	r25, 0x786E
    315c:	0e 94 70 89 	call	0x112e0	; 0x112e0 <write_Fecha>
    3160:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
				    break;
					
					case (1):
						fprintf_P(stdout,PSTR("Digite si Habilitara la Interface Serial en Modo de Battery Backup. \n"));
    3164:	00 d0       	rcall	.+0      	; 0x3166 <__stack+0xf67>
    3166:	00 d0       	rcall	.+0      	; 0x3168 <__stack+0xf69>
    3168:	80 91 d0 79 	lds	r24, 0x79D0
    316c:	90 91 d1 79 	lds	r25, 0x79D1
    3170:	ed b7       	in	r30, 0x3d	; 61
    3172:	fe b7       	in	r31, 0x3e	; 62
    3174:	92 83       	std	Z+2, r25	; 0x02
    3176:	81 83       	std	Z+1, r24	; 0x01
    3178:	89 e6       	ldi	r24, 0x69	; 105
    317a:	9d e0       	ldi	r25, 0x0D	; 13
    317c:	94 83       	std	Z+4, r25	; 0x04
    317e:	83 83       	std	Z+3, r24	; 0x03
    3180:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. Habilitar. \n"));
    3184:	80 91 d0 79 	lds	r24, 0x79D0
    3188:	90 91 d1 79 	lds	r25, 0x79D1
    318c:	ad b7       	in	r26, 0x3d	; 61
    318e:	be b7       	in	r27, 0x3e	; 62
    3190:	12 96       	adiw	r26, 0x02	; 2
    3192:	9c 93       	st	X, r25
    3194:	8e 93       	st	-X, r24
    3196:	11 97       	sbiw	r26, 0x01	; 1
    3198:	89 e5       	ldi	r24, 0x59	; 89
    319a:	9d e0       	ldi	r25, 0x0D	; 13
    319c:	14 96       	adiw	r26, 0x04	; 4
    319e:	9c 93       	st	X, r25
    31a0:	8e 93       	st	-X, r24
    31a2:	13 97       	sbiw	r26, 0x03	; 3
    31a4:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. Deshabilitar. \n"));
    31a8:	80 91 d0 79 	lds	r24, 0x79D0
    31ac:	90 91 d1 79 	lds	r25, 0x79D1
    31b0:	ed b7       	in	r30, 0x3d	; 61
    31b2:	fe b7       	in	r31, 0x3e	; 62
    31b4:	92 83       	std	Z+2, r25	; 0x02
    31b6:	81 83       	std	Z+1, r24	; 0x01
    31b8:	86 e4       	ldi	r24, 0x46	; 70
    31ba:	9d e0       	ldi	r25, 0x0D	; 13
    31bc:	94 83       	std	Z+4, r25	; 0x04
    31be:	83 83       	std	Z+3, r24	; 0x03
    31c0:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d", &sbib);			
    31c4:	ec e1       	ldi	r30, 0x1C	; 28
    31c6:	f2 e2       	ldi	r31, 0x22	; 34
    31c8:	ad b7       	in	r26, 0x3d	; 61
    31ca:	be b7       	in	r27, 0x3e	; 62
    31cc:	12 96       	adiw	r26, 0x02	; 2
    31ce:	fc 93       	st	X, r31
    31d0:	ee 93       	st	-X, r30
    31d2:	11 97       	sbiw	r26, 0x01	; 1
    31d4:	8e e5       	ldi	r24, 0x5E	; 94
    31d6:	98 e7       	ldi	r25, 0x78	; 120
    31d8:	14 96       	adiw	r26, 0x04	; 4
    31da:	9c 93       	st	X, r25
    31dc:	8e 93       	st	-X, r24
    31de:	13 97       	sbiw	r26, 0x03	; 3
    31e0:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						fprintf_P(stdout,PSTR("Digite la condicion de cambio entre VDD y Battery Backup. \n"));
    31e4:	80 91 d0 79 	lds	r24, 0x79D0
    31e8:	90 91 d1 79 	lds	r25, 0x79D1
    31ec:	ad b7       	in	r26, 0x3d	; 61
    31ee:	be b7       	in	r27, 0x3e	; 62
    31f0:	12 96       	adiw	r26, 0x02	; 2
    31f2:	9c 93       	st	X, r25
    31f4:	8e 93       	st	-X, r24
    31f6:	11 97       	sbiw	r26, 0x01	; 1
    31f8:	8a e0       	ldi	r24, 0x0A	; 10
    31fa:	9d e0       	ldi	r25, 0x0D	; 13
    31fc:	14 96       	adiw	r26, 0x04	; 4
    31fe:	9c 93       	st	X, r25
    3200:	8e 93       	st	-X, r24
    3202:	13 97       	sbiw	r26, 0x03	; 3
    3204:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. Standard. \n"));
    3208:	80 91 d0 79 	lds	r24, 0x79D0
    320c:	90 91 d1 79 	lds	r25, 0x79D1
    3210:	ed b7       	in	r30, 0x3d	; 61
    3212:	fe b7       	in	r31, 0x3e	; 62
    3214:	92 83       	std	Z+2, r25	; 0x02
    3216:	81 83       	std	Z+1, r24	; 0x01
    3218:	8b ef       	ldi	r24, 0xFB	; 251
    321a:	9c e0       	ldi	r25, 0x0C	; 12
    321c:	94 83       	std	Z+4, r25	; 0x04
    321e:	83 83       	std	Z+3, r24	; 0x03
    3220:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. Legacy/Defecto. \n"));
    3224:	80 91 d0 79 	lds	r24, 0x79D0
    3228:	90 91 d1 79 	lds	r25, 0x79D1
    322c:	ad b7       	in	r26, 0x3d	; 61
    322e:	be b7       	in	r27, 0x3e	; 62
    3230:	12 96       	adiw	r26, 0x02	; 2
    3232:	9c 93       	st	X, r25
    3234:	8e 93       	st	-X, r24
    3236:	11 97       	sbiw	r26, 0x01	; 1
    3238:	86 ee       	ldi	r24, 0xE6	; 230
    323a:	9c e0       	ldi	r25, 0x0C	; 12
    323c:	14 96       	adiw	r26, 0x04	; 4
    323e:	9c 93       	st	X, r25
    3240:	8e 93       	st	-X, r24
    3242:	13 97       	sbiw	r26, 0x03	; 3
    3244:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d", &bsw);			
    3248:	2c e1       	ldi	r18, 0x1C	; 28
    324a:	32 e2       	ldi	r19, 0x22	; 34
    324c:	ed b7       	in	r30, 0x3d	; 61
    324e:	fe b7       	in	r31, 0x3e	; 62
    3250:	32 83       	std	Z+2, r19	; 0x02
    3252:	21 83       	std	Z+1, r18	; 0x01
    3254:	8f e4       	ldi	r24, 0x4F	; 79
    3256:	98 e7       	ldi	r25, 0x78	; 120
    3258:	94 83       	std	Z+4, r25	; 0x04
    325a:	83 83       	std	Z+3, r24	; 0x03
    325c:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						fprintf_P(stdout,PSTR("Digite un Valor del Digital TRimming Register. \n"));
    3260:	80 91 d0 79 	lds	r24, 0x79D0
    3264:	90 91 d1 79 	lds	r25, 0x79D1
    3268:	ad b7       	in	r26, 0x3d	; 61
    326a:	be b7       	in	r27, 0x3e	; 62
    326c:	12 96       	adiw	r26, 0x02	; 2
    326e:	9c 93       	st	X, r25
    3270:	8e 93       	st	-X, r24
    3272:	11 97       	sbiw	r26, 0x01	; 1
    3274:	85 eb       	ldi	r24, 0xB5	; 181
    3276:	9c e0       	ldi	r25, 0x0C	; 12
    3278:	14 96       	adiw	r26, 0x04	; 4
    327a:	9c 93       	st	X, r25
    327c:	8e 93       	st	-X, r24
    327e:	13 97       	sbiw	r26, 0x03	; 3
    3280:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. Frecuencia Estimada (PPM) = 0 \n"));
    3284:	80 91 d0 79 	lds	r24, 0x79D0
    3288:	90 91 d1 79 	lds	r25, 0x79D1
    328c:	ed b7       	in	r30, 0x3d	; 61
    328e:	fe b7       	in	r31, 0x3e	; 62
    3290:	92 83       	std	Z+2, r25	; 0x02
    3292:	81 83       	std	Z+1, r24	; 0x01
    3294:	82 e9       	ldi	r24, 0x92	; 146
    3296:	9c e0       	ldi	r25, 0x0C	; 12
    3298:	94 83       	std	Z+4, r25	; 0x04
    329a:	83 83       	std	Z+3, r24	; 0x03
    329c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. Frecuencia Estimada (PPM) = +20 \n"));
    32a0:	80 91 d0 79 	lds	r24, 0x79D0
    32a4:	90 91 d1 79 	lds	r25, 0x79D1
    32a8:	ad b7       	in	r26, 0x3d	; 61
    32aa:	be b7       	in	r27, 0x3e	; 62
    32ac:	12 96       	adiw	r26, 0x02	; 2
    32ae:	9c 93       	st	X, r25
    32b0:	8e 93       	st	-X, r24
    32b2:	11 97       	sbiw	r26, 0x01	; 1
    32b4:	8d e6       	ldi	r24, 0x6D	; 109
    32b6:	9c e0       	ldi	r25, 0x0C	; 12
    32b8:	14 96       	adiw	r26, 0x04	; 4
    32ba:	9c 93       	st	X, r25
    32bc:	8e 93       	st	-X, r24
    32be:	13 97       	sbiw	r26, 0x03	; 3
    32c0:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("2. Frecuencia Estimada (PPM) = +10 \n"));
    32c4:	80 91 d0 79 	lds	r24, 0x79D0
    32c8:	90 91 d1 79 	lds	r25, 0x79D1
    32cc:	ed b7       	in	r30, 0x3d	; 61
    32ce:	fe b7       	in	r31, 0x3e	; 62
    32d0:	92 83       	std	Z+2, r25	; 0x02
    32d2:	81 83       	std	Z+1, r24	; 0x01
    32d4:	88 e4       	ldi	r24, 0x48	; 72
    32d6:	9c e0       	ldi	r25, 0x0C	; 12
    32d8:	94 83       	std	Z+4, r25	; 0x04
    32da:	83 83       	std	Z+3, r24	; 0x03
    32dc:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("3. Frecuencia Estimada (PPM) = +30 \n"));
    32e0:	80 91 d0 79 	lds	r24, 0x79D0
    32e4:	90 91 d1 79 	lds	r25, 0x79D1
    32e8:	ad b7       	in	r26, 0x3d	; 61
    32ea:	be b7       	in	r27, 0x3e	; 62
    32ec:	12 96       	adiw	r26, 0x02	; 2
    32ee:	9c 93       	st	X, r25
    32f0:	8e 93       	st	-X, r24
    32f2:	11 97       	sbiw	r26, 0x01	; 1
    32f4:	83 e2       	ldi	r24, 0x23	; 35
    32f6:	9c e0       	ldi	r25, 0x0C	; 12
    32f8:	14 96       	adiw	r26, 0x04	; 4
    32fa:	9c 93       	st	X, r25
    32fc:	8e 93       	st	-X, r24
    32fe:	13 97       	sbiw	r26, 0x03	; 3
    3300:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("5. Frecuencia Estimada (PPM) = -20 \n"));
    3304:	80 91 d0 79 	lds	r24, 0x79D0
    3308:	90 91 d1 79 	lds	r25, 0x79D1
    330c:	ed b7       	in	r30, 0x3d	; 61
    330e:	fe b7       	in	r31, 0x3e	; 62
    3310:	92 83       	std	Z+2, r25	; 0x02
    3312:	81 83       	std	Z+1, r24	; 0x01
    3314:	8e ef       	ldi	r24, 0xFE	; 254
    3316:	9b e0       	ldi	r25, 0x0B	; 11
    3318:	94 83       	std	Z+4, r25	; 0x04
    331a:	83 83       	std	Z+3, r24	; 0x03
    331c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("6. Frecuencia Estimada (PPM) = -10 \n"));
    3320:	80 91 d0 79 	lds	r24, 0x79D0
    3324:	90 91 d1 79 	lds	r25, 0x79D1
    3328:	ad b7       	in	r26, 0x3d	; 61
    332a:	be b7       	in	r27, 0x3e	; 62
    332c:	12 96       	adiw	r26, 0x02	; 2
    332e:	9c 93       	st	X, r25
    3330:	8e 93       	st	-X, r24
    3332:	11 97       	sbiw	r26, 0x01	; 1
    3334:	89 ed       	ldi	r24, 0xD9	; 217
    3336:	9b e0       	ldi	r25, 0x0B	; 11
    3338:	14 96       	adiw	r26, 0x04	; 4
    333a:	9c 93       	st	X, r25
    333c:	8e 93       	st	-X, r24
    333e:	13 97       	sbiw	r26, 0x03	; 3
    3340:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("7. Frecuencia Estimada (PPM) = -30 \n"));			
    3344:	80 91 d0 79 	lds	r24, 0x79D0
    3348:	90 91 d1 79 	lds	r25, 0x79D1
    334c:	ed b7       	in	r30, 0x3d	; 61
    334e:	fe b7       	in	r31, 0x3e	; 62
    3350:	92 83       	std	Z+2, r25	; 0x02
    3352:	81 83       	std	Z+1, r24	; 0x01
    3354:	84 eb       	ldi	r24, 0xB4	; 180
    3356:	9b e0       	ldi	r25, 0x0B	; 11
    3358:	94 83       	std	Z+4, r25	; 0x04
    335a:	83 83       	std	Z+3, r24	; 0x03
    335c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%x", &dtr);			
    3360:	8b ea       	ldi	r24, 0xAB	; 171
    3362:	93 e2       	ldi	r25, 0x23	; 35
    3364:	ad b7       	in	r26, 0x3d	; 61
    3366:	be b7       	in	r27, 0x3e	; 62
    3368:	12 96       	adiw	r26, 0x02	; 2
    336a:	9c 93       	st	X, r25
    336c:	8e 93       	st	-X, r24
    336e:	11 97       	sbiw	r26, 0x01	; 1
    3370:	8d e4       	ldi	r24, 0x4D	; 77
    3372:	98 e7       	ldi	r25, 0x78	; 120
    3374:	14 96       	adiw	r26, 0x04	; 4
    3376:	9c 93       	st	X, r25
    3378:	8e 93       	st	-X, r24
    337a:	13 97       	sbiw	r26, 0x03	; 3
    337c:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						fprintf_P(stdout,PSTR("Digite un Valor para la compensacion de la capacitancia. \n"));
    3380:	80 91 d0 79 	lds	r24, 0x79D0
    3384:	90 91 d1 79 	lds	r25, 0x79D1
    3388:	ed b7       	in	r30, 0x3d	; 61
    338a:	fe b7       	in	r31, 0x3e	; 62
    338c:	92 83       	std	Z+2, r25	; 0x02
    338e:	81 83       	std	Z+1, r24	; 0x01
    3390:	89 e7       	ldi	r24, 0x79	; 121
    3392:	9b e0       	ldi	r25, 0x0B	; 11
    3394:	94 83       	std	Z+4, r25	; 0x04
    3396:	83 83       	std	Z+3, r24	; 0x03
    3398:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d", &atr);			
    339c:	ec e1       	ldi	r30, 0x1C	; 28
    339e:	f2 e2       	ldi	r31, 0x22	; 34
    33a0:	ad b7       	in	r26, 0x3d	; 61
    33a2:	be b7       	in	r27, 0x3e	; 62
    33a4:	12 96       	adiw	r26, 0x02	; 2
    33a6:	fc 93       	st	X, r31
    33a8:	ee 93       	st	-X, r30
    33aa:	11 97       	sbiw	r26, 0x01	; 1
    33ac:	85 e1       	ldi	r24, 0x15	; 21
    33ae:	95 e7       	ldi	r25, 0x75	; 117
    33b0:	14 96       	adiw	r26, 0x04	; 4
    33b2:	9c 93       	st	X, r25
    33b4:	8e 93       	st	-X, r24
    33b6:	13 97       	sbiw	r26, 0x03	; 3
    33b8:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						fprintf_P(stdout,PSTR("Habilitar Alarma. \n"));
    33bc:	80 91 d0 79 	lds	r24, 0x79D0
    33c0:	90 91 d1 79 	lds	r25, 0x79D1
    33c4:	ad b7       	in	r26, 0x3d	; 61
    33c6:	be b7       	in	r27, 0x3e	; 62
    33c8:	12 96       	adiw	r26, 0x02	; 2
    33ca:	9c 93       	st	X, r25
    33cc:	8e 93       	st	-X, r24
    33ce:	11 97       	sbiw	r26, 0x01	; 1
    33d0:	85 e6       	ldi	r24, 0x65	; 101
    33d2:	9b e0       	ldi	r25, 0x0B	; 11
    33d4:	14 96       	adiw	r26, 0x04	; 4
    33d6:	9c 93       	st	X, r25
    33d8:	8e 93       	st	-X, r24
    33da:	13 97       	sbiw	r26, 0x03	; 3
    33dc:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. Habilitar. \n"));
    33e0:	80 91 d0 79 	lds	r24, 0x79D0
    33e4:	90 91 d1 79 	lds	r25, 0x79D1
    33e8:	ed b7       	in	r30, 0x3d	; 61
    33ea:	fe b7       	in	r31, 0x3e	; 62
    33ec:	92 83       	std	Z+2, r25	; 0x02
    33ee:	81 83       	std	Z+1, r24	; 0x01
    33f0:	85 e5       	ldi	r24, 0x55	; 85
    33f2:	9b e0       	ldi	r25, 0x0B	; 11
    33f4:	94 83       	std	Z+4, r25	; 0x04
    33f6:	83 83       	std	Z+3, r24	; 0x03
    33f8:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. Deshabilitar. \n"));
    33fc:	80 91 d0 79 	lds	r24, 0x79D0
    3400:	90 91 d1 79 	lds	r25, 0x79D1
    3404:	ad b7       	in	r26, 0x3d	; 61
    3406:	be b7       	in	r27, 0x3e	; 62
    3408:	12 96       	adiw	r26, 0x02	; 2
    340a:	9c 93       	st	X, r25
    340c:	8e 93       	st	-X, r24
    340e:	11 97       	sbiw	r26, 0x01	; 1
    3410:	82 e4       	ldi	r24, 0x42	; 66
    3412:	9b e0       	ldi	r25, 0x0B	; 11
    3414:	14 96       	adiw	r26, 0x04	; 4
    3416:	9c 93       	st	X, r25
    3418:	8e 93       	st	-X, r24
    341a:	13 97       	sbiw	r26, 0x03	; 3
    341c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d", &al);			
    3420:	2c e1       	ldi	r18, 0x1C	; 28
    3422:	32 e2       	ldi	r19, 0x22	; 34
    3424:	ed b7       	in	r30, 0x3d	; 61
    3426:	fe b7       	in	r31, 0x3e	; 62
    3428:	32 83       	std	Z+2, r19	; 0x02
    342a:	21 83       	std	Z+1, r18	; 0x01
    342c:	81 e5       	ldi	r24, 0x51	; 81
    342e:	98 e7       	ldi	r25, 0x78	; 120
    3430:	94 83       	std	Z+4, r25	; 0x04
    3432:	83 83       	std	Z+3, r24	; 0x03
    3434:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						fprintf_P(stdout,PSTR("Alarma Periodica. \n"));
    3438:	80 91 d0 79 	lds	r24, 0x79D0
    343c:	90 91 d1 79 	lds	r25, 0x79D1
    3440:	ad b7       	in	r26, 0x3d	; 61
    3442:	be b7       	in	r27, 0x3e	; 62
    3444:	12 96       	adiw	r26, 0x02	; 2
    3446:	9c 93       	st	X, r25
    3448:	8e 93       	st	-X, r24
    344a:	11 97       	sbiw	r26, 0x01	; 1
    344c:	8e e2       	ldi	r24, 0x2E	; 46
    344e:	9b e0       	ldi	r25, 0x0B	; 11
    3450:	14 96       	adiw	r26, 0x04	; 4
    3452:	9c 93       	st	X, r25
    3454:	8e 93       	st	-X, r24
    3456:	13 97       	sbiw	r26, 0x03	; 3
    3458:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. No Periodica. \n"));
    345c:	80 91 d0 79 	lds	r24, 0x79D0
    3460:	90 91 d1 79 	lds	r25, 0x79D1
    3464:	ed b7       	in	r30, 0x3d	; 61
    3466:	fe b7       	in	r31, 0x3e	; 62
    3468:	92 83       	std	Z+2, r25	; 0x02
    346a:	81 83       	std	Z+1, r24	; 0x01
    346c:	8b e1       	ldi	r24, 0x1B	; 27
    346e:	9b e0       	ldi	r25, 0x0B	; 11
    3470:	94 83       	std	Z+4, r25	; 0x04
    3472:	83 83       	std	Z+3, r24	; 0x03
    3474:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. Periodica. \n"));
    3478:	80 91 d0 79 	lds	r24, 0x79D0
    347c:	90 91 d1 79 	lds	r25, 0x79D1
    3480:	ad b7       	in	r26, 0x3d	; 61
    3482:	be b7       	in	r27, 0x3e	; 62
    3484:	12 96       	adiw	r26, 0x02	; 2
    3486:	9c 93       	st	X, r25
    3488:	8e 93       	st	-X, r24
    348a:	11 97       	sbiw	r26, 0x01	; 1
    348c:	8b e0       	ldi	r24, 0x0B	; 11
    348e:	9b e0       	ldi	r25, 0x0B	; 11
    3490:	14 96       	adiw	r26, 0x04	; 4
    3492:	9c 93       	st	X, r25
    3494:	8e 93       	st	-X, r24
    3496:	13 97       	sbiw	r26, 0x03	; 3
    3498:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d", &im);			
    349c:	2c e1       	ldi	r18, 0x1C	; 28
    349e:	32 e2       	ldi	r19, 0x22	; 34
    34a0:	ed b7       	in	r30, 0x3d	; 61
    34a2:	fe b7       	in	r31, 0x3e	; 62
    34a4:	32 83       	std	Z+2, r19	; 0x02
    34a6:	21 83       	std	Z+1, r18	; 0x01
    34a8:	88 e5       	ldi	r24, 0x58	; 88
    34aa:	98 e7       	ldi	r25, 0x78	; 120
    34ac:	94 83       	std	Z+4, r25	; 0x04
    34ae:	83 83       	std	Z+3, r24	; 0x03
    34b0:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						ctr.PWR=RTC_PWR(sbib,bsw);
    34b4:	0f 90       	pop	r0
    34b6:	0f 90       	pop	r0
    34b8:	0f 90       	pop	r0
    34ba:	0f 90       	pop	r0
    34bc:	80 91 5e 78 	lds	r24, 0x785E
    34c0:	90 91 5f 78 	lds	r25, 0x785F
    34c4:	89 2b       	or	r24, r25
    34c6:	11 f4       	brne	.+4      	; 0x34cc <__stack+0x12cd>
    34c8:	20 e0       	ldi	r18, 0x00	; 0
    34ca:	01 c0       	rjmp	.+2      	; 0x34ce <__stack+0x12cf>
    34cc:	20 e8       	ldi	r18, 0x80	; 128
    34ce:	80 91 4f 78 	lds	r24, 0x784F
    34d2:	90 91 50 78 	lds	r25, 0x7850
    34d6:	89 2b       	or	r24, r25
    34d8:	11 f4       	brne	.+4      	; 0x34de <__stack+0x12df>
    34da:	80 e0       	ldi	r24, 0x00	; 0
    34dc:	01 c0       	rjmp	.+2      	; 0x34e0 <__stack+0x12e1>
    34de:	80 e4       	ldi	r24, 0x40	; 64
    34e0:	82 2b       	or	r24, r18
    34e2:	80 93 12 75 	sts	0x7512, r24
						ctr.DTR=dtr;
    34e6:	80 91 4d 78 	lds	r24, 0x784D
    34ea:	80 93 11 75 	sts	0x7511, r24
						ctr.ATR=atr;
    34ee:	80 91 15 75 	lds	r24, 0x7515
    34f2:	80 93 10 75 	sts	0x7510, r24
						ctr.INT=RTC_INT(al,im);
    34f6:	80 91 51 78 	lds	r24, 0x7851
    34fa:	90 91 52 78 	lds	r25, 0x7852
    34fe:	89 2b       	or	r24, r25
    3500:	11 f4       	brne	.+4      	; 0x3506 <__stack+0x1307>
    3502:	20 e0       	ldi	r18, 0x00	; 0
    3504:	01 c0       	rjmp	.+2      	; 0x3508 <__stack+0x1309>
    3506:	20 e2       	ldi	r18, 0x20	; 32
    3508:	80 91 58 78 	lds	r24, 0x7858
    350c:	90 91 59 78 	lds	r25, 0x7859
    3510:	89 2b       	or	r24, r25
    3512:	11 f4       	brne	.+4      	; 0x3518 <__stack+0x1319>
    3514:	50 e0       	ldi	r21, 0x00	; 0
    3516:	01 c0       	rjmp	.+2      	; 0x351a <__stack+0x131b>
    3518:	50 e8       	ldi	r21, 0x80	; 128
    351a:	52 2b       	or	r21, r18
    351c:	50 93 0f 75 	sts	0x750F, r21
						ctr.BL =0x18;
    3520:	88 e1       	ldi	r24, 0x18	; 24
    3522:	80 93 0e 75 	sts	0x750E, r24
						write_control(ctr);
    3526:	48 e1       	ldi	r20, 0x18	; 24
    3528:	60 91 10 75 	lds	r22, 0x7510
    352c:	70 91 11 75 	lds	r23, 0x7511
    3530:	80 91 12 75 	lds	r24, 0x7512
    3534:	0e 94 22 89 	call	0x11244	; 0x11244 <write_control>
    3538:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
				    break;
					
					case (2):
						fprintf_P(stdout,PSTR("Desea Habiliar un Valor del Mes para la Alarma?. \n"));			
    353c:	00 d0       	rcall	.+0      	; 0x353e <__stack+0x133f>
    353e:	00 d0       	rcall	.+0      	; 0x3540 <__stack+0x1341>
    3540:	80 91 d0 79 	lds	r24, 0x79D0
    3544:	90 91 d1 79 	lds	r25, 0x79D1
    3548:	ad b7       	in	r26, 0x3d	; 61
    354a:	be b7       	in	r27, 0x3e	; 62
    354c:	12 96       	adiw	r26, 0x02	; 2
    354e:	9c 93       	st	X, r25
    3550:	8e 93       	st	-X, r24
    3552:	11 97       	sbiw	r26, 0x01	; 1
    3554:	88 ed       	ldi	r24, 0xD8	; 216
    3556:	9a e0       	ldi	r25, 0x0A	; 10
    3558:	14 96       	adiw	r26, 0x04	; 4
    355a:	9c 93       	st	X, r25
    355c:	8e 93       	st	-X, r24
    355e:	13 97       	sbiw	r26, 0x03	; 3
    3560:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. NO \n"));
    3564:	80 91 d0 79 	lds	r24, 0x79D0
    3568:	90 91 d1 79 	lds	r25, 0x79D1
    356c:	ed b7       	in	r30, 0x3d	; 61
    356e:	fe b7       	in	r31, 0x3e	; 62
    3570:	92 83       	std	Z+2, r25	; 0x02
    3572:	81 83       	std	Z+1, r24	; 0x01
    3574:	80 ed       	ldi	r24, 0xD0	; 208
    3576:	9a e0       	ldi	r25, 0x0A	; 10
    3578:	94 83       	std	Z+4, r25	; 0x04
    357a:	83 83       	std	Z+3, r24	; 0x03
    357c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. SI \n"));
    3580:	80 91 d0 79 	lds	r24, 0x79D0
    3584:	90 91 d1 79 	lds	r25, 0x79D1
    3588:	ad b7       	in	r26, 0x3d	; 61
    358a:	be b7       	in	r27, 0x3e	; 62
    358c:	12 96       	adiw	r26, 0x02	; 2
    358e:	9c 93       	st	X, r25
    3590:	8e 93       	st	-X, r24
    3592:	11 97       	sbiw	r26, 0x01	; 1
    3594:	88 ec       	ldi	r24, 0xC8	; 200
    3596:	9a e0       	ldi	r25, 0x0A	; 10
    3598:	14 96       	adiw	r26, 0x04	; 4
    359a:	9c 93       	st	X, r25
    359c:	8e 93       	st	-X, r24
    359e:	13 97       	sbiw	r26, 0x03	; 3
    35a0:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&ask);						
    35a4:	2c e1       	ldi	r18, 0x1C	; 28
    35a6:	32 e2       	ldi	r19, 0x22	; 34
    35a8:	ed b7       	in	r30, 0x3d	; 61
    35aa:	fe b7       	in	r31, 0x3e	; 62
    35ac:	32 83       	std	Z+2, r19	; 0x02
    35ae:	21 83       	std	Z+1, r18	; 0x01
    35b0:	87 e1       	ldi	r24, 0x17	; 23
    35b2:	95 e7       	ldi	r25, 0x75	; 117
    35b4:	94 83       	std	Z+4, r25	; 0x04
    35b6:	83 83       	std	Z+3, r24	; 0x03
    35b8:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						if(ask==1)
    35bc:	0f 90       	pop	r0
    35be:	0f 90       	pop	r0
    35c0:	0f 90       	pop	r0
    35c2:	0f 90       	pop	r0
    35c4:	80 91 17 75 	lds	r24, 0x7517
    35c8:	90 91 18 75 	lds	r25, 0x7518
    35cc:	01 97       	sbiw	r24, 0x01	; 1
    35ce:	51 f5       	brne	.+84     	; 0x3624 <__stack+0x1425>
						{
							fprintf_P(stdout,PSTR("Digite el Mes. 1-12 \n"));
    35d0:	00 d0       	rcall	.+0      	; 0x35d2 <__stack+0x13d3>
    35d2:	00 d0       	rcall	.+0      	; 0x35d4 <__stack+0x13d5>
    35d4:	80 91 d0 79 	lds	r24, 0x79D0
    35d8:	90 91 d1 79 	lds	r25, 0x79D1
    35dc:	ad b7       	in	r26, 0x3d	; 61
    35de:	be b7       	in	r27, 0x3e	; 62
    35e0:	12 96       	adiw	r26, 0x02	; 2
    35e2:	9c 93       	st	X, r25
    35e4:	8e 93       	st	-X, r24
    35e6:	11 97       	sbiw	r26, 0x01	; 1
    35e8:	82 eb       	ldi	r24, 0xB2	; 178
    35ea:	9a e0       	ldi	r25, 0x0A	; 10
    35ec:	14 96       	adiw	r26, 0x04	; 4
    35ee:	9c 93       	st	X, r25
    35f0:	8e 93       	st	-X, r24
    35f2:	13 97       	sbiw	r26, 0x03	; 3
    35f4:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
							scanf("%x",&scn);
    35f8:	8b ea       	ldi	r24, 0xAB	; 171
    35fa:	93 e2       	ldi	r25, 0x23	; 35
    35fc:	ed b7       	in	r30, 0x3d	; 61
    35fe:	fe b7       	in	r31, 0x3e	; 62
    3600:	92 83       	std	Z+2, r25	; 0x02
    3602:	81 83       	std	Z+1, r24	; 0x01
    3604:	83 e5       	ldi	r24, 0x53	; 83
    3606:	98 e7       	ldi	r25, 0x78	; 120
    3608:	94 83       	std	Z+4, r25	; 0x04
    360a:	83 83       	std	Z+3, r24	; 0x03
    360c:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
							alarma.MOA0= (uint8)scn;
    3610:	80 91 53 78 	lds	r24, 0x7853
							alarma.MOA0=alarma.MOA0 | 0x80;						//0x80 habilita el mes
    3614:	80 68       	ori	r24, 0x80	; 128
    3616:	80 93 64 78 	sts	0x7864, r24
    361a:	0f 90       	pop	r0
    361c:	0f 90       	pop	r0
    361e:	0f 90       	pop	r0
    3620:	0f 90       	pop	r0
    3622:	02 c0       	rjmp	.+4      	; 0x3628 <__stack+0x1429>
						}
						else
							alarma.MOA0=0x00;				
    3624:	10 92 64 78 	sts	0x7864, r1
						fprintf_P(stdout,PSTR("Desea Habiliar un Valor del DIA para la Alarma?. \n"));			
    3628:	00 d0       	rcall	.+0      	; 0x362a <__stack+0x142b>
    362a:	00 d0       	rcall	.+0      	; 0x362c <__stack+0x142d>
    362c:	80 91 d0 79 	lds	r24, 0x79D0
    3630:	90 91 d1 79 	lds	r25, 0x79D1
    3634:	ad b7       	in	r26, 0x3d	; 61
    3636:	be b7       	in	r27, 0x3e	; 62
    3638:	12 96       	adiw	r26, 0x02	; 2
    363a:	9c 93       	st	X, r25
    363c:	8e 93       	st	-X, r24
    363e:	11 97       	sbiw	r26, 0x01	; 1
    3640:	8f e7       	ldi	r24, 0x7F	; 127
    3642:	9a e0       	ldi	r25, 0x0A	; 10
    3644:	14 96       	adiw	r26, 0x04	; 4
    3646:	9c 93       	st	X, r25
    3648:	8e 93       	st	-X, r24
    364a:	13 97       	sbiw	r26, 0x03	; 3
    364c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. NO \n"));
    3650:	80 91 d0 79 	lds	r24, 0x79D0
    3654:	90 91 d1 79 	lds	r25, 0x79D1
    3658:	ed b7       	in	r30, 0x3d	; 61
    365a:	fe b7       	in	r31, 0x3e	; 62
    365c:	92 83       	std	Z+2, r25	; 0x02
    365e:	81 83       	std	Z+1, r24	; 0x01
    3660:	87 e7       	ldi	r24, 0x77	; 119
    3662:	9a e0       	ldi	r25, 0x0A	; 10
    3664:	94 83       	std	Z+4, r25	; 0x04
    3666:	83 83       	std	Z+3, r24	; 0x03
    3668:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. SI \n"));
    366c:	80 91 d0 79 	lds	r24, 0x79D0
    3670:	90 91 d1 79 	lds	r25, 0x79D1
    3674:	ad b7       	in	r26, 0x3d	; 61
    3676:	be b7       	in	r27, 0x3e	; 62
    3678:	12 96       	adiw	r26, 0x02	; 2
    367a:	9c 93       	st	X, r25
    367c:	8e 93       	st	-X, r24
    367e:	11 97       	sbiw	r26, 0x01	; 1
    3680:	8f e6       	ldi	r24, 0x6F	; 111
    3682:	9a e0       	ldi	r25, 0x0A	; 10
    3684:	14 96       	adiw	r26, 0x04	; 4
    3686:	9c 93       	st	X, r25
    3688:	8e 93       	st	-X, r24
    368a:	13 97       	sbiw	r26, 0x03	; 3
    368c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&ask);
    3690:	2c e1       	ldi	r18, 0x1C	; 28
    3692:	32 e2       	ldi	r19, 0x22	; 34
    3694:	ed b7       	in	r30, 0x3d	; 61
    3696:	fe b7       	in	r31, 0x3e	; 62
    3698:	32 83       	std	Z+2, r19	; 0x02
    369a:	21 83       	std	Z+1, r18	; 0x01
    369c:	87 e1       	ldi	r24, 0x17	; 23
    369e:	95 e7       	ldi	r25, 0x75	; 117
    36a0:	94 83       	std	Z+4, r25	; 0x04
    36a2:	83 83       	std	Z+3, r24	; 0x03
    36a4:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						if(ask==1)
    36a8:	0f 90       	pop	r0
    36aa:	0f 90       	pop	r0
    36ac:	0f 90       	pop	r0
    36ae:	0f 90       	pop	r0
    36b0:	80 91 17 75 	lds	r24, 0x7517
    36b4:	90 91 18 75 	lds	r25, 0x7518
    36b8:	01 97       	sbiw	r24, 0x01	; 1
    36ba:	51 f5       	brne	.+84     	; 0x3710 <__stack+0x1511>
						{
							fprintf_P(stdout,PSTR("Digite el Dia. 1-31 \n"));
    36bc:	00 d0       	rcall	.+0      	; 0x36be <__stack+0x14bf>
    36be:	00 d0       	rcall	.+0      	; 0x36c0 <__stack+0x14c1>
    36c0:	80 91 d0 79 	lds	r24, 0x79D0
    36c4:	90 91 d1 79 	lds	r25, 0x79D1
    36c8:	ad b7       	in	r26, 0x3d	; 61
    36ca:	be b7       	in	r27, 0x3e	; 62
    36cc:	12 96       	adiw	r26, 0x02	; 2
    36ce:	9c 93       	st	X, r25
    36d0:	8e 93       	st	-X, r24
    36d2:	11 97       	sbiw	r26, 0x01	; 1
    36d4:	89 e5       	ldi	r24, 0x59	; 89
    36d6:	9a e0       	ldi	r25, 0x0A	; 10
    36d8:	14 96       	adiw	r26, 0x04	; 4
    36da:	9c 93       	st	X, r25
    36dc:	8e 93       	st	-X, r24
    36de:	13 97       	sbiw	r26, 0x03	; 3
    36e0:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
							scanf("%x",&scn);
    36e4:	8b ea       	ldi	r24, 0xAB	; 171
    36e6:	93 e2       	ldi	r25, 0x23	; 35
    36e8:	ed b7       	in	r30, 0x3d	; 61
    36ea:	fe b7       	in	r31, 0x3e	; 62
    36ec:	92 83       	std	Z+2, r25	; 0x02
    36ee:	81 83       	std	Z+1, r24	; 0x01
    36f0:	83 e5       	ldi	r24, 0x53	; 83
    36f2:	98 e7       	ldi	r25, 0x78	; 120
    36f4:	94 83       	std	Z+4, r25	; 0x04
    36f6:	83 83       	std	Z+3, r24	; 0x03
    36f8:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
							alarma.DTA0=(uint8)scn;
    36fc:	80 91 53 78 	lds	r24, 0x7853
							alarma.DTA0=alarma.DTA0 | 0x80;						//0x80 habilita el dia
    3700:	80 68       	ori	r24, 0x80	; 128
    3702:	80 93 63 78 	sts	0x7863, r24
    3706:	0f 90       	pop	r0
    3708:	0f 90       	pop	r0
    370a:	0f 90       	pop	r0
    370c:	0f 90       	pop	r0
    370e:	02 c0       	rjmp	.+4      	; 0x3714 <__stack+0x1515>
						}
						else
							alarma.DTA0=0x00;							
    3710:	10 92 63 78 	sts	0x7863, r1
						fprintf_P(stdout,PSTR("Desea Habiliar el valor de la Hora para la Alarma?. \n"));			
    3714:	00 d0       	rcall	.+0      	; 0x3716 <__stack+0x1517>
    3716:	00 d0       	rcall	.+0      	; 0x3718 <__stack+0x1519>
    3718:	80 91 d0 79 	lds	r24, 0x79D0
    371c:	90 91 d1 79 	lds	r25, 0x79D1
    3720:	ad b7       	in	r26, 0x3d	; 61
    3722:	be b7       	in	r27, 0x3e	; 62
    3724:	12 96       	adiw	r26, 0x02	; 2
    3726:	9c 93       	st	X, r25
    3728:	8e 93       	st	-X, r24
    372a:	11 97       	sbiw	r26, 0x01	; 1
    372c:	83 e2       	ldi	r24, 0x23	; 35
    372e:	9a e0       	ldi	r25, 0x0A	; 10
    3730:	14 96       	adiw	r26, 0x04	; 4
    3732:	9c 93       	st	X, r25
    3734:	8e 93       	st	-X, r24
    3736:	13 97       	sbiw	r26, 0x03	; 3
    3738:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. NO \n"));
    373c:	80 91 d0 79 	lds	r24, 0x79D0
    3740:	90 91 d1 79 	lds	r25, 0x79D1
    3744:	ed b7       	in	r30, 0x3d	; 61
    3746:	fe b7       	in	r31, 0x3e	; 62
    3748:	92 83       	std	Z+2, r25	; 0x02
    374a:	81 83       	std	Z+1, r24	; 0x01
    374c:	8b e1       	ldi	r24, 0x1B	; 27
    374e:	9a e0       	ldi	r25, 0x0A	; 10
    3750:	94 83       	std	Z+4, r25	; 0x04
    3752:	83 83       	std	Z+3, r24	; 0x03
    3754:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. SI \n"));
    3758:	80 91 d0 79 	lds	r24, 0x79D0
    375c:	90 91 d1 79 	lds	r25, 0x79D1
    3760:	ad b7       	in	r26, 0x3d	; 61
    3762:	be b7       	in	r27, 0x3e	; 62
    3764:	12 96       	adiw	r26, 0x02	; 2
    3766:	9c 93       	st	X, r25
    3768:	8e 93       	st	-X, r24
    376a:	11 97       	sbiw	r26, 0x01	; 1
    376c:	83 e1       	ldi	r24, 0x13	; 19
    376e:	9a e0       	ldi	r25, 0x0A	; 10
    3770:	14 96       	adiw	r26, 0x04	; 4
    3772:	9c 93       	st	X, r25
    3774:	8e 93       	st	-X, r24
    3776:	13 97       	sbiw	r26, 0x03	; 3
    3778:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&ask);
    377c:	2c e1       	ldi	r18, 0x1C	; 28
    377e:	32 e2       	ldi	r19, 0x22	; 34
    3780:	ed b7       	in	r30, 0x3d	; 61
    3782:	fe b7       	in	r31, 0x3e	; 62
    3784:	32 83       	std	Z+2, r19	; 0x02
    3786:	21 83       	std	Z+1, r18	; 0x01
    3788:	07 e1       	ldi	r16, 0x17	; 23
    378a:	15 e7       	ldi	r17, 0x75	; 117
    378c:	14 83       	std	Z+4, r17	; 0x04
    378e:	03 83       	std	Z+3, r16	; 0x03
    3790:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						if(ask==1)
    3794:	0f 90       	pop	r0
    3796:	0f 90       	pop	r0
    3798:	0f 90       	pop	r0
    379a:	0f 90       	pop	r0
    379c:	80 91 17 75 	lds	r24, 0x7517
    37a0:	90 91 18 75 	lds	r25, 0x7518
    37a4:	01 97       	sbiw	r24, 0x01	; 1
    37a6:	09 f0       	breq	.+2      	; 0x37aa <__stack+0x15ab>
    37a8:	63 c0       	rjmp	.+198    	; 0x3870 <__stack+0x1671>
						{
							fprintf_P(stdout,PSTR("Digite el Valor de la Hora \n"));
    37aa:	00 d0       	rcall	.+0      	; 0x37ac <__stack+0x15ad>
    37ac:	00 d0       	rcall	.+0      	; 0x37ae <__stack+0x15af>
    37ae:	80 91 d0 79 	lds	r24, 0x79D0
    37b2:	90 91 d1 79 	lds	r25, 0x79D1
    37b6:	ad b7       	in	r26, 0x3d	; 61
    37b8:	be b7       	in	r27, 0x3e	; 62
    37ba:	12 96       	adiw	r26, 0x02	; 2
    37bc:	9c 93       	st	X, r25
    37be:	8e 93       	st	-X, r24
    37c0:	11 97       	sbiw	r26, 0x01	; 1
    37c2:	86 ef       	ldi	r24, 0xF6	; 246
    37c4:	99 e0       	ldi	r25, 0x09	; 9
    37c6:	14 96       	adiw	r26, 0x04	; 4
    37c8:	9c 93       	st	X, r25
    37ca:	8e 93       	st	-X, r24
    37cc:	13 97       	sbiw	r26, 0x03	; 3
    37ce:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
							scanf("%x",&scn);
    37d2:	8b ea       	ldi	r24, 0xAB	; 171
    37d4:	93 e2       	ldi	r25, 0x23	; 35
    37d6:	ed b7       	in	r30, 0x3d	; 61
    37d8:	fe b7       	in	r31, 0x3e	; 62
    37da:	92 83       	std	Z+2, r25	; 0x02
    37dc:	81 83       	std	Z+1, r24	; 0x01
    37de:	83 e5       	ldi	r24, 0x53	; 83
    37e0:	98 e7       	ldi	r25, 0x78	; 120
    37e2:	94 83       	std	Z+4, r25	; 0x04
    37e4:	83 83       	std	Z+3, r24	; 0x03
    37e6:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
							alarma.HRA0=(uint8)scn;
							alarma.HRA0=alarma.HRA0 | 0x80;						//0x80 habilita la Hora
    37ea:	80 91 53 78 	lds	r24, 0x7853
    37ee:	80 68       	ori	r24, 0x80	; 128
    37f0:	80 93 62 78 	sts	0x7862, r24
							
							fprintf_P(stdout,PSTR("0.AM  \n"));
    37f4:	80 91 d0 79 	lds	r24, 0x79D0
    37f8:	90 91 d1 79 	lds	r25, 0x79D1
    37fc:	ad b7       	in	r26, 0x3d	; 61
    37fe:	be b7       	in	r27, 0x3e	; 62
    3800:	12 96       	adiw	r26, 0x02	; 2
    3802:	9c 93       	st	X, r25
    3804:	8e 93       	st	-X, r24
    3806:	11 97       	sbiw	r26, 0x01	; 1
    3808:	8e ee       	ldi	r24, 0xEE	; 238
    380a:	99 e0       	ldi	r25, 0x09	; 9
    380c:	14 96       	adiw	r26, 0x04	; 4
    380e:	9c 93       	st	X, r25
    3810:	8e 93       	st	-X, r24
    3812:	13 97       	sbiw	r26, 0x03	; 3
    3814:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
							fprintf_P(stdout,PSTR("1.PM  \n"));
    3818:	80 91 d0 79 	lds	r24, 0x79D0
    381c:	90 91 d1 79 	lds	r25, 0x79D1
    3820:	ed b7       	in	r30, 0x3d	; 61
    3822:	fe b7       	in	r31, 0x3e	; 62
    3824:	92 83       	std	Z+2, r25	; 0x02
    3826:	81 83       	std	Z+1, r24	; 0x01
    3828:	86 ee       	ldi	r24, 0xE6	; 230
    382a:	99 e0       	ldi	r25, 0x09	; 9
    382c:	94 83       	std	Z+4, r25	; 0x04
    382e:	83 83       	std	Z+3, r24	; 0x03
    3830:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
							scanf("%d",&ask);
    3834:	ec e1       	ldi	r30, 0x1C	; 28
    3836:	f2 e2       	ldi	r31, 0x22	; 34
    3838:	ad b7       	in	r26, 0x3d	; 61
    383a:	be b7       	in	r27, 0x3e	; 62
    383c:	12 96       	adiw	r26, 0x02	; 2
    383e:	fc 93       	st	X, r31
    3840:	ee 93       	st	-X, r30
    3842:	11 97       	sbiw	r26, 0x01	; 1
    3844:	14 96       	adiw	r26, 0x04	; 4
    3846:	1c 93       	st	X, r17
    3848:	0e 93       	st	-X, r16
    384a:	13 97       	sbiw	r26, 0x03	; 3
    384c:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
							
							if(ask==1)
    3850:	0f 90       	pop	r0
    3852:	0f 90       	pop	r0
    3854:	0f 90       	pop	r0
    3856:	0f 90       	pop	r0
    3858:	80 91 17 75 	lds	r24, 0x7517
    385c:	90 91 18 75 	lds	r25, 0x7518
    3860:	01 97       	sbiw	r24, 0x01	; 1
    3862:	41 f4       	brne	.+16     	; 0x3874 <__stack+0x1675>
								alarma.HRA0= alarma.HRA0 | 0x20;
    3864:	80 91 62 78 	lds	r24, 0x7862
    3868:	80 62       	ori	r24, 0x20	; 32
    386a:	80 93 62 78 	sts	0x7862, r24
    386e:	02 c0       	rjmp	.+4      	; 0x3874 <__stack+0x1675>
						}
						else
							alarma.HRA0=0x00;						
    3870:	10 92 62 78 	sts	0x7862, r1
						fprintf_P(stdout,PSTR("Desea Habiliar el valor de los minutos para la Alarma?. \n"));			
    3874:	00 d0       	rcall	.+0      	; 0x3876 <__stack+0x1677>
    3876:	00 d0       	rcall	.+0      	; 0x3878 <__stack+0x1679>
    3878:	80 91 d0 79 	lds	r24, 0x79D0
    387c:	90 91 d1 79 	lds	r25, 0x79D1
    3880:	ad b7       	in	r26, 0x3d	; 61
    3882:	be b7       	in	r27, 0x3e	; 62
    3884:	12 96       	adiw	r26, 0x02	; 2
    3886:	9c 93       	st	X, r25
    3888:	8e 93       	st	-X, r24
    388a:	11 97       	sbiw	r26, 0x01	; 1
    388c:	8c ea       	ldi	r24, 0xAC	; 172
    388e:	99 e0       	ldi	r25, 0x09	; 9
    3890:	14 96       	adiw	r26, 0x04	; 4
    3892:	9c 93       	st	X, r25
    3894:	8e 93       	st	-X, r24
    3896:	13 97       	sbiw	r26, 0x03	; 3
    3898:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. NO \n"));
    389c:	80 91 d0 79 	lds	r24, 0x79D0
    38a0:	90 91 d1 79 	lds	r25, 0x79D1
    38a4:	ed b7       	in	r30, 0x3d	; 61
    38a6:	fe b7       	in	r31, 0x3e	; 62
    38a8:	92 83       	std	Z+2, r25	; 0x02
    38aa:	81 83       	std	Z+1, r24	; 0x01
    38ac:	84 ea       	ldi	r24, 0xA4	; 164
    38ae:	99 e0       	ldi	r25, 0x09	; 9
    38b0:	94 83       	std	Z+4, r25	; 0x04
    38b2:	83 83       	std	Z+3, r24	; 0x03
    38b4:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. SI \n"));
    38b8:	80 91 d0 79 	lds	r24, 0x79D0
    38bc:	90 91 d1 79 	lds	r25, 0x79D1
    38c0:	ad b7       	in	r26, 0x3d	; 61
    38c2:	be b7       	in	r27, 0x3e	; 62
    38c4:	12 96       	adiw	r26, 0x02	; 2
    38c6:	9c 93       	st	X, r25
    38c8:	8e 93       	st	-X, r24
    38ca:	11 97       	sbiw	r26, 0x01	; 1
    38cc:	8c e9       	ldi	r24, 0x9C	; 156
    38ce:	99 e0       	ldi	r25, 0x09	; 9
    38d0:	14 96       	adiw	r26, 0x04	; 4
    38d2:	9c 93       	st	X, r25
    38d4:	8e 93       	st	-X, r24
    38d6:	13 97       	sbiw	r26, 0x03	; 3
    38d8:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&ask);
    38dc:	2c e1       	ldi	r18, 0x1C	; 28
    38de:	32 e2       	ldi	r19, 0x22	; 34
    38e0:	ed b7       	in	r30, 0x3d	; 61
    38e2:	fe b7       	in	r31, 0x3e	; 62
    38e4:	32 83       	std	Z+2, r19	; 0x02
    38e6:	21 83       	std	Z+1, r18	; 0x01
    38e8:	87 e1       	ldi	r24, 0x17	; 23
    38ea:	95 e7       	ldi	r25, 0x75	; 117
    38ec:	94 83       	std	Z+4, r25	; 0x04
    38ee:	83 83       	std	Z+3, r24	; 0x03
    38f0:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						if(ask==1)
    38f4:	0f 90       	pop	r0
    38f6:	0f 90       	pop	r0
    38f8:	0f 90       	pop	r0
    38fa:	0f 90       	pop	r0
    38fc:	80 91 17 75 	lds	r24, 0x7517
    3900:	90 91 18 75 	lds	r25, 0x7518
    3904:	01 97       	sbiw	r24, 0x01	; 1
    3906:	51 f5       	brne	.+84     	; 0x395c <__stack+0x175d>
						{
							fprintf_P(stdout,PSTR("Digite el Valor de los Minutos. 0-59 \n"));
    3908:	00 d0       	rcall	.+0      	; 0x390a <__stack+0x170b>
    390a:	00 d0       	rcall	.+0      	; 0x390c <__stack+0x170d>
    390c:	80 91 d0 79 	lds	r24, 0x79D0
    3910:	90 91 d1 79 	lds	r25, 0x79D1
    3914:	ad b7       	in	r26, 0x3d	; 61
    3916:	be b7       	in	r27, 0x3e	; 62
    3918:	12 96       	adiw	r26, 0x02	; 2
    391a:	9c 93       	st	X, r25
    391c:	8e 93       	st	-X, r24
    391e:	11 97       	sbiw	r26, 0x01	; 1
    3920:	85 e7       	ldi	r24, 0x75	; 117
    3922:	99 e0       	ldi	r25, 0x09	; 9
    3924:	14 96       	adiw	r26, 0x04	; 4
    3926:	9c 93       	st	X, r25
    3928:	8e 93       	st	-X, r24
    392a:	13 97       	sbiw	r26, 0x03	; 3
    392c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
							scanf("%x",&scn);
    3930:	8b ea       	ldi	r24, 0xAB	; 171
    3932:	93 e2       	ldi	r25, 0x23	; 35
    3934:	ed b7       	in	r30, 0x3d	; 61
    3936:	fe b7       	in	r31, 0x3e	; 62
    3938:	92 83       	std	Z+2, r25	; 0x02
    393a:	81 83       	std	Z+1, r24	; 0x01
    393c:	83 e5       	ldi	r24, 0x53	; 83
    393e:	98 e7       	ldi	r25, 0x78	; 120
    3940:	94 83       	std	Z+4, r25	; 0x04
    3942:	83 83       	std	Z+3, r24	; 0x03
    3944:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
							alarma.MNA0=(uint8)scn;
    3948:	80 91 53 78 	lds	r24, 0x7853
							alarma.MNA0=alarma.MNA0 | 0x80;						//0x80 habilita Los minutos
    394c:	80 68       	ori	r24, 0x80	; 128
    394e:	80 93 61 78 	sts	0x7861, r24
    3952:	0f 90       	pop	r0
    3954:	0f 90       	pop	r0
    3956:	0f 90       	pop	r0
    3958:	0f 90       	pop	r0
    395a:	02 c0       	rjmp	.+4      	; 0x3960 <__stack+0x1761>
						}
						else
							alarma.MNA0=0x00;							
    395c:	10 92 61 78 	sts	0x7861, r1
						fprintf_P(stdout,PSTR("Desea Habiliar el valor de los segundos para la Alarma?. \n"));			
    3960:	00 d0       	rcall	.+0      	; 0x3962 <__stack+0x1763>
    3962:	00 d0       	rcall	.+0      	; 0x3964 <__stack+0x1765>
    3964:	80 91 d0 79 	lds	r24, 0x79D0
    3968:	90 91 d1 79 	lds	r25, 0x79D1
    396c:	ad b7       	in	r26, 0x3d	; 61
    396e:	be b7       	in	r27, 0x3e	; 62
    3970:	12 96       	adiw	r26, 0x02	; 2
    3972:	9c 93       	st	X, r25
    3974:	8e 93       	st	-X, r24
    3976:	11 97       	sbiw	r26, 0x01	; 1
    3978:	8a e3       	ldi	r24, 0x3A	; 58
    397a:	99 e0       	ldi	r25, 0x09	; 9
    397c:	14 96       	adiw	r26, 0x04	; 4
    397e:	9c 93       	st	X, r25
    3980:	8e 93       	st	-X, r24
    3982:	13 97       	sbiw	r26, 0x03	; 3
    3984:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. NO \n"));
    3988:	80 91 d0 79 	lds	r24, 0x79D0
    398c:	90 91 d1 79 	lds	r25, 0x79D1
    3990:	ed b7       	in	r30, 0x3d	; 61
    3992:	fe b7       	in	r31, 0x3e	; 62
    3994:	92 83       	std	Z+2, r25	; 0x02
    3996:	81 83       	std	Z+1, r24	; 0x01
    3998:	82 e3       	ldi	r24, 0x32	; 50
    399a:	99 e0       	ldi	r25, 0x09	; 9
    399c:	94 83       	std	Z+4, r25	; 0x04
    399e:	83 83       	std	Z+3, r24	; 0x03
    39a0:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. SI \n"));
    39a4:	80 91 d0 79 	lds	r24, 0x79D0
    39a8:	90 91 d1 79 	lds	r25, 0x79D1
    39ac:	ad b7       	in	r26, 0x3d	; 61
    39ae:	be b7       	in	r27, 0x3e	; 62
    39b0:	12 96       	adiw	r26, 0x02	; 2
    39b2:	9c 93       	st	X, r25
    39b4:	8e 93       	st	-X, r24
    39b6:	11 97       	sbiw	r26, 0x01	; 1
    39b8:	8a e2       	ldi	r24, 0x2A	; 42
    39ba:	99 e0       	ldi	r25, 0x09	; 9
    39bc:	14 96       	adiw	r26, 0x04	; 4
    39be:	9c 93       	st	X, r25
    39c0:	8e 93       	st	-X, r24
    39c2:	13 97       	sbiw	r26, 0x03	; 3
    39c4:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d",&ask);
    39c8:	2c e1       	ldi	r18, 0x1C	; 28
    39ca:	32 e2       	ldi	r19, 0x22	; 34
    39cc:	ed b7       	in	r30, 0x3d	; 61
    39ce:	fe b7       	in	r31, 0x3e	; 62
    39d0:	32 83       	std	Z+2, r19	; 0x02
    39d2:	21 83       	std	Z+1, r18	; 0x01
    39d4:	87 e1       	ldi	r24, 0x17	; 23
    39d6:	95 e7       	ldi	r25, 0x75	; 117
    39d8:	94 83       	std	Z+4, r25	; 0x04
    39da:	83 83       	std	Z+3, r24	; 0x03
    39dc:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						if(ask==1)
    39e0:	0f 90       	pop	r0
    39e2:	0f 90       	pop	r0
    39e4:	0f 90       	pop	r0
    39e6:	0f 90       	pop	r0
    39e8:	80 91 17 75 	lds	r24, 0x7517
    39ec:	90 91 18 75 	lds	r25, 0x7518
    39f0:	01 97       	sbiw	r24, 0x01	; 1
    39f2:	51 f5       	brne	.+84     	; 0x3a48 <__stack+0x1849>
						{
							fprintf_P(stdout,PSTR("Digite el Valor en segundos. 0-59 \n"));
    39f4:	00 d0       	rcall	.+0      	; 0x39f6 <__stack+0x17f7>
    39f6:	00 d0       	rcall	.+0      	; 0x39f8 <__stack+0x17f9>
    39f8:	80 91 d0 79 	lds	r24, 0x79D0
    39fc:	90 91 d1 79 	lds	r25, 0x79D1
    3a00:	ad b7       	in	r26, 0x3d	; 61
    3a02:	be b7       	in	r27, 0x3e	; 62
    3a04:	12 96       	adiw	r26, 0x02	; 2
    3a06:	9c 93       	st	X, r25
    3a08:	8e 93       	st	-X, r24
    3a0a:	11 97       	sbiw	r26, 0x01	; 1
    3a0c:	86 e0       	ldi	r24, 0x06	; 6
    3a0e:	99 e0       	ldi	r25, 0x09	; 9
    3a10:	14 96       	adiw	r26, 0x04	; 4
    3a12:	9c 93       	st	X, r25
    3a14:	8e 93       	st	-X, r24
    3a16:	13 97       	sbiw	r26, 0x03	; 3
    3a18:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
							scanf("%x",&scn);
    3a1c:	8b ea       	ldi	r24, 0xAB	; 171
    3a1e:	93 e2       	ldi	r25, 0x23	; 35
    3a20:	ed b7       	in	r30, 0x3d	; 61
    3a22:	fe b7       	in	r31, 0x3e	; 62
    3a24:	92 83       	std	Z+2, r25	; 0x02
    3a26:	81 83       	std	Z+1, r24	; 0x01
    3a28:	83 e5       	ldi	r24, 0x53	; 83
    3a2a:	98 e7       	ldi	r25, 0x78	; 120
    3a2c:	94 83       	std	Z+4, r25	; 0x04
    3a2e:	83 83       	std	Z+3, r24	; 0x03
    3a30:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
							alarma.SCA0=(uint8)scn;
    3a34:	80 91 53 78 	lds	r24, 0x7853
							alarma.SCA0=alarma.SCA0 | 0x80;						//0x80 habilita Los segundos
    3a38:	80 68       	ori	r24, 0x80	; 128
    3a3a:	80 93 60 78 	sts	0x7860, r24
    3a3e:	0f 90       	pop	r0
    3a40:	0f 90       	pop	r0
    3a42:	0f 90       	pop	r0
    3a44:	0f 90       	pop	r0
    3a46:	02 c0       	rjmp	.+4      	; 0x3a4c <__stack+0x184d>
						}
						else
							alarma.SCA0= 0x00;							
    3a48:	10 92 60 78 	sts	0x7860, r1
						write_alarm(alarma);
    3a4c:	20 91 60 78 	lds	r18, 0x7860
    3a50:	30 91 61 78 	lds	r19, 0x7861
    3a54:	40 91 62 78 	lds	r20, 0x7862
    3a58:	50 91 63 78 	lds	r21, 0x7863
    3a5c:	60 91 64 78 	lds	r22, 0x7864
    3a60:	70 91 65 78 	lds	r23, 0x7865
    3a64:	80 91 66 78 	lds	r24, 0x7866
    3a68:	0e 94 eb 88 	call	0x111d6	; 0x111d6 <write_alarm>
    3a6c:	00 e4       	ldi	r16, 0x40	; 64
    3a6e:	1c e9       	ldi	r17, 0x9C	; 156
    3a70:	c8 01       	movw	r24, r16
    3a72:	01 97       	sbiw	r24, 0x01	; 1
    3a74:	f1 f7       	brne	.-4      	; 0x3a72 <__stack+0x1873>
						_delay_ms(20);
						
						read_control(&ctr);
    3a76:	8e e0       	ldi	r24, 0x0E	; 14
    3a78:	95 e7       	ldi	r25, 0x75	; 117
    3a7a:	0e 94 96 88 	call	0x1112c	; 0x1112c <read_control>
    3a7e:	c8 01       	movw	r24, r16
    3a80:	01 97       	sbiw	r24, 0x01	; 1
    3a82:	f1 f7       	brne	.-4      	; 0x3a80 <__stack+0x1881>
						_delay_ms(20);
						
						fprintf_P(stdout,PSTR("Alarma Periodica. \n"));
    3a84:	00 d0       	rcall	.+0      	; 0x3a86 <__stack+0x1887>
    3a86:	00 d0       	rcall	.+0      	; 0x3a88 <__stack+0x1889>
    3a88:	80 91 d0 79 	lds	r24, 0x79D0
    3a8c:	90 91 d1 79 	lds	r25, 0x79D1
    3a90:	ad b7       	in	r26, 0x3d	; 61
    3a92:	be b7       	in	r27, 0x3e	; 62
    3a94:	12 96       	adiw	r26, 0x02	; 2
    3a96:	9c 93       	st	X, r25
    3a98:	8e 93       	st	-X, r24
    3a9a:	11 97       	sbiw	r26, 0x01	; 1
    3a9c:	82 ef       	ldi	r24, 0xF2	; 242
    3a9e:	98 e0       	ldi	r25, 0x08	; 8
    3aa0:	14 96       	adiw	r26, 0x04	; 4
    3aa2:	9c 93       	st	X, r25
    3aa4:	8e 93       	st	-X, r24
    3aa6:	13 97       	sbiw	r26, 0x03	; 3
    3aa8:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("0. No Periodica. \n"));
    3aac:	80 91 d0 79 	lds	r24, 0x79D0
    3ab0:	90 91 d1 79 	lds	r25, 0x79D1
    3ab4:	ed b7       	in	r30, 0x3d	; 61
    3ab6:	fe b7       	in	r31, 0x3e	; 62
    3ab8:	92 83       	std	Z+2, r25	; 0x02
    3aba:	81 83       	std	Z+1, r24	; 0x01
    3abc:	8f ed       	ldi	r24, 0xDF	; 223
    3abe:	98 e0       	ldi	r25, 0x08	; 8
    3ac0:	94 83       	std	Z+4, r25	; 0x04
    3ac2:	83 83       	std	Z+3, r24	; 0x03
    3ac4:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						fprintf_P(stdout,PSTR("1. Periodica. \n"));
    3ac8:	80 91 d0 79 	lds	r24, 0x79D0
    3acc:	90 91 d1 79 	lds	r25, 0x79D1
    3ad0:	ad b7       	in	r26, 0x3d	; 61
    3ad2:	be b7       	in	r27, 0x3e	; 62
    3ad4:	12 96       	adiw	r26, 0x02	; 2
    3ad6:	9c 93       	st	X, r25
    3ad8:	8e 93       	st	-X, r24
    3ada:	11 97       	sbiw	r26, 0x01	; 1
    3adc:	8f ec       	ldi	r24, 0xCF	; 207
    3ade:	98 e0       	ldi	r25, 0x08	; 8
    3ae0:	14 96       	adiw	r26, 0x04	; 4
    3ae2:	9c 93       	st	X, r25
    3ae4:	8e 93       	st	-X, r24
    3ae6:	13 97       	sbiw	r26, 0x03	; 3
    3ae8:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d", &ask);
    3aec:	2c e1       	ldi	r18, 0x1C	; 28
    3aee:	32 e2       	ldi	r19, 0x22	; 34
    3af0:	ed b7       	in	r30, 0x3d	; 61
    3af2:	fe b7       	in	r31, 0x3e	; 62
    3af4:	32 83       	std	Z+2, r19	; 0x02
    3af6:	21 83       	std	Z+1, r18	; 0x01
    3af8:	87 e1       	ldi	r24, 0x17	; 23
    3afa:	95 e7       	ldi	r25, 0x75	; 117
    3afc:	94 83       	std	Z+4, r25	; 0x04
    3afe:	83 83       	std	Z+3, r24	; 0x03
    3b00:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						
						if(ask==1)
    3b04:	0f 90       	pop	r0
    3b06:	0f 90       	pop	r0
    3b08:	0f 90       	pop	r0
    3b0a:	0f 90       	pop	r0
    3b0c:	20 91 17 75 	lds	r18, 0x7517
    3b10:	30 91 18 75 	lds	r19, 0x7518
    3b14:	21 30       	cpi	r18, 0x01	; 1
    3b16:	31 05       	cpc	r19, r1
    3b18:	41 f4       	brne	.+16     	; 0x3b2a <__stack+0x192b>
						{
							ctr.INT=RTC_INT(1,1);
    3b1a:	80 ea       	ldi	r24, 0xA0	; 160
    3b1c:	80 93 0f 75 	sts	0x750F, r24
							activo_alarma=1;
    3b20:	30 93 5d 78 	sts	0x785D, r19
    3b24:	20 93 5c 78 	sts	0x785C, r18
    3b28:	09 c0       	rjmp	.+18     	; 0x3b3c <__stack+0x193d>
						}
						else
						{	
							ctr.INT=RTC_INT(1,0);
    3b2a:	80 e2       	ldi	r24, 0x20	; 32
    3b2c:	80 93 0f 75 	sts	0x750F, r24
							activo_alarma=1;
    3b30:	81 e0       	ldi	r24, 0x01	; 1
    3b32:	90 e0       	ldi	r25, 0x00	; 0
    3b34:	90 93 5d 78 	sts	0x785D, r25
    3b38:	80 93 5c 78 	sts	0x785C, r24
						}							
						write_control(ctr);
    3b3c:	40 91 0e 75 	lds	r20, 0x750E
    3b40:	50 91 0f 75 	lds	r21, 0x750F
    3b44:	60 91 10 75 	lds	r22, 0x7510
    3b48:	70 91 11 75 	lds	r23, 0x7511
    3b4c:	80 91 12 75 	lds	r24, 0x7512
    3b50:	0e 94 22 89 	call	0x11244	; 0x11244 <write_control>
    3b54:	80 e4       	ldi	r24, 0x40	; 64
    3b56:	9c e9       	ldi	r25, 0x9C	; 156
    3b58:	01 97       	sbiw	r24, 0x01	; 1
    3b5a:	f1 f7       	brne	.-4      	; 0x3b58 <__stack+0x1959>
						_delay_ms(20);
						
						read_control(&ctr);
    3b5c:	8e e0       	ldi	r24, 0x0E	; 14
    3b5e:	95 e7       	ldi	r25, 0x75	; 117
    3b60:	0e 94 96 88 	call	0x1112c	; 0x1112c <read_control>
						printf("PWR = %x \n",ctr.PWR);
    3b64:	00 d0       	rcall	.+0      	; 0x3b66 <__stack+0x1967>
    3b66:	00 d0       	rcall	.+0      	; 0x3b68 <__stack+0x1969>
    3b68:	ed b7       	in	r30, 0x3d	; 61
    3b6a:	fe b7       	in	r31, 0x3e	; 62
    3b6c:	31 96       	adiw	r30, 0x01	; 1
    3b6e:	8e ea       	ldi	r24, 0xAE	; 174
    3b70:	93 e2       	ldi	r25, 0x23	; 35
    3b72:	ad b7       	in	r26, 0x3d	; 61
    3b74:	be b7       	in	r27, 0x3e	; 62
    3b76:	12 96       	adiw	r26, 0x02	; 2
    3b78:	9c 93       	st	X, r25
    3b7a:	8e 93       	st	-X, r24
    3b7c:	11 97       	sbiw	r26, 0x01	; 1
    3b7e:	80 91 12 75 	lds	r24, 0x7512
    3b82:	82 83       	std	Z+2, r24	; 0x02
    3b84:	13 82       	std	Z+3, r1	; 0x03
    3b86:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("DTR = %x \n",ctr.DTR);
    3b8a:	ed b7       	in	r30, 0x3d	; 61
    3b8c:	fe b7       	in	r31, 0x3e	; 62
    3b8e:	31 96       	adiw	r30, 0x01	; 1
    3b90:	89 eb       	ldi	r24, 0xB9	; 185
    3b92:	93 e2       	ldi	r25, 0x23	; 35
    3b94:	ad b7       	in	r26, 0x3d	; 61
    3b96:	be b7       	in	r27, 0x3e	; 62
    3b98:	12 96       	adiw	r26, 0x02	; 2
    3b9a:	9c 93       	st	X, r25
    3b9c:	8e 93       	st	-X, r24
    3b9e:	11 97       	sbiw	r26, 0x01	; 1
    3ba0:	80 91 11 75 	lds	r24, 0x7511
    3ba4:	82 83       	std	Z+2, r24	; 0x02
    3ba6:	13 82       	std	Z+3, r1	; 0x03
    3ba8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("ATR = %x \n",ctr.ATR);
    3bac:	ed b7       	in	r30, 0x3d	; 61
    3bae:	fe b7       	in	r31, 0x3e	; 62
    3bb0:	31 96       	adiw	r30, 0x01	; 1
    3bb2:	84 ec       	ldi	r24, 0xC4	; 196
    3bb4:	93 e2       	ldi	r25, 0x23	; 35
    3bb6:	ad b7       	in	r26, 0x3d	; 61
    3bb8:	be b7       	in	r27, 0x3e	; 62
    3bba:	12 96       	adiw	r26, 0x02	; 2
    3bbc:	9c 93       	st	X, r25
    3bbe:	8e 93       	st	-X, r24
    3bc0:	11 97       	sbiw	r26, 0x01	; 1
    3bc2:	80 91 10 75 	lds	r24, 0x7510
    3bc6:	82 83       	std	Z+2, r24	; 0x02
    3bc8:	13 82       	std	Z+3, r1	; 0x03
    3bca:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("INT = %x \n",ctr.INT);
    3bce:	ed b7       	in	r30, 0x3d	; 61
    3bd0:	fe b7       	in	r31, 0x3e	; 62
    3bd2:	31 96       	adiw	r30, 0x01	; 1
    3bd4:	8f ec       	ldi	r24, 0xCF	; 207
    3bd6:	93 e2       	ldi	r25, 0x23	; 35
    3bd8:	ad b7       	in	r26, 0x3d	; 61
    3bda:	be b7       	in	r27, 0x3e	; 62
    3bdc:	12 96       	adiw	r26, 0x02	; 2
    3bde:	9c 93       	st	X, r25
    3be0:	8e 93       	st	-X, r24
    3be2:	11 97       	sbiw	r26, 0x01	; 1
    3be4:	80 91 0f 75 	lds	r24, 0x750F
    3be8:	82 83       	std	Z+2, r24	; 0x02
    3bea:	13 82       	std	Z+3, r1	; 0x03
    3bec:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("BL  = %x \n",ctr.BL);
    3bf0:	ed b7       	in	r30, 0x3d	; 61
    3bf2:	fe b7       	in	r31, 0x3e	; 62
    3bf4:	31 96       	adiw	r30, 0x01	; 1
    3bf6:	8a ed       	ldi	r24, 0xDA	; 218
    3bf8:	93 e2       	ldi	r25, 0x23	; 35
    3bfa:	ad b7       	in	r26, 0x3d	; 61
    3bfc:	be b7       	in	r27, 0x3e	; 62
    3bfe:	12 96       	adiw	r26, 0x02	; 2
    3c00:	9c 93       	st	X, r25
    3c02:	8e 93       	st	-X, r24
    3c04:	11 97       	sbiw	r26, 0x01	; 1
    3c06:	80 91 0e 75 	lds	r24, 0x750E
    3c0a:	82 83       	std	Z+2, r24	; 0x02
    3c0c:	13 82       	std	Z+3, r1	; 0x03
    3c0e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						scanf("%d",&stop);		
    3c12:	2c e1       	ldi	r18, 0x1C	; 28
    3c14:	32 e2       	ldi	r19, 0x22	; 34
    3c16:	ed b7       	in	r30, 0x3d	; 61
    3c18:	fe b7       	in	r31, 0x3e	; 62
    3c1a:	32 83       	std	Z+2, r19	; 0x02
    3c1c:	21 83       	std	Z+1, r18	; 0x01
    3c1e:	8e 01       	movw	r16, r28
    3c20:	09 5f       	subi	r16, 0xF9	; 249
    3c22:	1f 4f       	sbci	r17, 0xFF	; 255
    3c24:	14 83       	std	Z+4, r17	; 0x04
    3c26:	03 83       	std	Z+3, r16	; 0x03
    3c28:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						
						read_alarm(&alarma);
    3c2c:	0f 90       	pop	r0
    3c2e:	0f 90       	pop	r0
    3c30:	0f 90       	pop	r0
    3c32:	0f 90       	pop	r0
    3c34:	80 e6       	ldi	r24, 0x60	; 96
    3c36:	98 e7       	ldi	r25, 0x78	; 120
    3c38:	0e 94 87 88 	call	0x1110e	; 0x1110e <read_alarm>
						printf("MES = %x \n",alarma.MOA0);
    3c3c:	00 d0       	rcall	.+0      	; 0x3c3e <__stack+0x1a3f>
    3c3e:	00 d0       	rcall	.+0      	; 0x3c40 <__stack+0x1a41>
    3c40:	ed b7       	in	r30, 0x3d	; 61
    3c42:	fe b7       	in	r31, 0x3e	; 62
    3c44:	31 96       	adiw	r30, 0x01	; 1
    3c46:	85 ee       	ldi	r24, 0xE5	; 229
    3c48:	93 e2       	ldi	r25, 0x23	; 35
    3c4a:	ad b7       	in	r26, 0x3d	; 61
    3c4c:	be b7       	in	r27, 0x3e	; 62
    3c4e:	12 96       	adiw	r26, 0x02	; 2
    3c50:	9c 93       	st	X, r25
    3c52:	8e 93       	st	-X, r24
    3c54:	11 97       	sbiw	r26, 0x01	; 1
    3c56:	80 91 64 78 	lds	r24, 0x7864
    3c5a:	82 83       	std	Z+2, r24	; 0x02
    3c5c:	13 82       	std	Z+3, r1	; 0x03
    3c5e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("DIA = %x \n",alarma.DTA0);
    3c62:	ed b7       	in	r30, 0x3d	; 61
    3c64:	fe b7       	in	r31, 0x3e	; 62
    3c66:	31 96       	adiw	r30, 0x01	; 1
    3c68:	80 ef       	ldi	r24, 0xF0	; 240
    3c6a:	93 e2       	ldi	r25, 0x23	; 35
    3c6c:	ad b7       	in	r26, 0x3d	; 61
    3c6e:	be b7       	in	r27, 0x3e	; 62
    3c70:	12 96       	adiw	r26, 0x02	; 2
    3c72:	9c 93       	st	X, r25
    3c74:	8e 93       	st	-X, r24
    3c76:	11 97       	sbiw	r26, 0x01	; 1
    3c78:	80 91 63 78 	lds	r24, 0x7863
    3c7c:	82 83       	std	Z+2, r24	; 0x02
    3c7e:	13 82       	std	Z+3, r1	; 0x03
    3c80:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("HORA = %x \n",alarma.HRA0);
    3c84:	ed b7       	in	r30, 0x3d	; 61
    3c86:	fe b7       	in	r31, 0x3e	; 62
    3c88:	31 96       	adiw	r30, 0x01	; 1
    3c8a:	8b ef       	ldi	r24, 0xFB	; 251
    3c8c:	93 e2       	ldi	r25, 0x23	; 35
    3c8e:	ad b7       	in	r26, 0x3d	; 61
    3c90:	be b7       	in	r27, 0x3e	; 62
    3c92:	12 96       	adiw	r26, 0x02	; 2
    3c94:	9c 93       	st	X, r25
    3c96:	8e 93       	st	-X, r24
    3c98:	11 97       	sbiw	r26, 0x01	; 1
    3c9a:	80 91 62 78 	lds	r24, 0x7862
    3c9e:	82 83       	std	Z+2, r24	; 0x02
    3ca0:	13 82       	std	Z+3, r1	; 0x03
    3ca2:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("MIN = %x \n",alarma.MNA0);
    3ca6:	ed b7       	in	r30, 0x3d	; 61
    3ca8:	fe b7       	in	r31, 0x3e	; 62
    3caa:	31 96       	adiw	r30, 0x01	; 1
    3cac:	87 e0       	ldi	r24, 0x07	; 7
    3cae:	94 e2       	ldi	r25, 0x24	; 36
    3cb0:	ad b7       	in	r26, 0x3d	; 61
    3cb2:	be b7       	in	r27, 0x3e	; 62
    3cb4:	12 96       	adiw	r26, 0x02	; 2
    3cb6:	9c 93       	st	X, r25
    3cb8:	8e 93       	st	-X, r24
    3cba:	11 97       	sbiw	r26, 0x01	; 1
    3cbc:	80 91 61 78 	lds	r24, 0x7861
    3cc0:	82 83       	std	Z+2, r24	; 0x02
    3cc2:	13 82       	std	Z+3, r1	; 0x03
    3cc4:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("SEC = %x \n",alarma.SCA0);
    3cc8:	ed b7       	in	r30, 0x3d	; 61
    3cca:	fe b7       	in	r31, 0x3e	; 62
    3ccc:	31 96       	adiw	r30, 0x01	; 1
    3cce:	82 e1       	ldi	r24, 0x12	; 18
    3cd0:	94 e2       	ldi	r25, 0x24	; 36
    3cd2:	ad b7       	in	r26, 0x3d	; 61
    3cd4:	be b7       	in	r27, 0x3e	; 62
    3cd6:	12 96       	adiw	r26, 0x02	; 2
    3cd8:	9c 93       	st	X, r25
    3cda:	8e 93       	st	-X, r24
    3cdc:	11 97       	sbiw	r26, 0x01	; 1
    3cde:	80 91 60 78 	lds	r24, 0x7860
    3ce2:	82 83       	std	Z+2, r24	; 0x02
    3ce4:	13 82       	std	Z+3, r1	; 0x03
    3ce6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						
						scanf("%d",&stop);	
    3cea:	2c e1       	ldi	r18, 0x1C	; 28
    3cec:	32 e2       	ldi	r19, 0x22	; 34
    3cee:	ed b7       	in	r30, 0x3d	; 61
    3cf0:	fe b7       	in	r31, 0x3e	; 62
    3cf2:	32 83       	std	Z+2, r19	; 0x02
    3cf4:	21 83       	std	Z+1, r18	; 0x01
    3cf6:	14 83       	std	Z+4, r17	; 0x04
    3cf8:	03 83       	std	Z+3, r16	; 0x03
    3cfa:	0c 94 77 12 	jmp	0x24ee	; 0x24ee <__stack+0x2ef>
				    break;
					
					case (3):
						Read_Fecha(&Fecha);
    3cfe:	87 e6       	ldi	r24, 0x67	; 103
    3d00:	98 e7       	ldi	r25, 0x78	; 120
    3d02:	0e 94 b4 88 	call	0x11168	; 0x11168 <Read_Fecha>
						printf("Fecha = Hoy es el dia %s %x de %s de 200%x. \n",Dayname(Fecha.dw),Fecha.dt,Monthname(Fecha.mo),Fecha.yr);						
    3d06:	80 91 6d 78 	lds	r24, 0x786D
    3d0a:	0e 94 47 3b 	call	0x768e	; 0x768e <Dayname>
    3d0e:	8c 01       	movw	r16, r24
    3d10:	f0 90 6a 78 	lds	r15, 0x786A
    3d14:	80 91 6b 78 	lds	r24, 0x786B
    3d18:	0e 94 70 3b 	call	0x76e0	; 0x76e0 <Monthname>
    3d1c:	ad b7       	in	r26, 0x3d	; 61
    3d1e:	be b7       	in	r27, 0x3e	; 62
    3d20:	1a 97       	sbiw	r26, 0x0a	; 10
    3d22:	0f b6       	in	r0, 0x3f	; 63
    3d24:	f8 94       	cli
    3d26:	be bf       	out	0x3e, r27	; 62
    3d28:	0f be       	out	0x3f, r0	; 63
    3d2a:	ad bf       	out	0x3d, r26	; 61
    3d2c:	ed b7       	in	r30, 0x3d	; 61
    3d2e:	fe b7       	in	r31, 0x3e	; 62
    3d30:	31 96       	adiw	r30, 0x01	; 1
    3d32:	2d e1       	ldi	r18, 0x1D	; 29
    3d34:	34 e2       	ldi	r19, 0x24	; 36
    3d36:	12 96       	adiw	r26, 0x02	; 2
    3d38:	3c 93       	st	X, r19
    3d3a:	2e 93       	st	-X, r18
    3d3c:	11 97       	sbiw	r26, 0x01	; 1
    3d3e:	13 83       	std	Z+3, r17	; 0x03
    3d40:	02 83       	std	Z+2, r16	; 0x02
    3d42:	f4 82       	std	Z+4, r15	; 0x04
    3d44:	15 82       	std	Z+5, r1	; 0x05
    3d46:	97 83       	std	Z+7, r25	; 0x07
    3d48:	86 83       	std	Z+6, r24	; 0x06
    3d4a:	80 91 6c 78 	lds	r24, 0x786C
    3d4e:	80 87       	std	Z+8, r24	; 0x08
    3d50:	11 86       	std	Z+9, r1	; 0x09
    3d52:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						if((Fecha.hr & 0x20) != 0)			
    3d56:	80 91 69 78 	lds	r24, 0x7869
    3d5a:	90 e0       	ldi	r25, 0x00	; 0
    3d5c:	ed b7       	in	r30, 0x3d	; 61
    3d5e:	fe b7       	in	r31, 0x3e	; 62
    3d60:	3a 96       	adiw	r30, 0x0a	; 10
    3d62:	0f b6       	in	r0, 0x3f	; 63
    3d64:	f8 94       	cli
    3d66:	fe bf       	out	0x3e, r31	; 62
    3d68:	0f be       	out	0x3f, r0	; 63
    3d6a:	ed bf       	out	0x3d, r30	; 61
    3d6c:	9c 01       	movw	r18, r24
    3d6e:	2f 71       	andi	r18, 0x1F	; 31
    3d70:	30 70       	andi	r19, 0x00	; 0
    3d72:	85 ff       	sbrs	r24, 5
    3d74:	0e c0       	rjmp	.+28     	; 0x3d92 <__stack+0x1b93>
							printf("Son las %x:%x:%x PM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    3d76:	8d b7       	in	r24, 0x3d	; 61
    3d78:	9e b7       	in	r25, 0x3e	; 62
    3d7a:	08 97       	sbiw	r24, 0x08	; 8
    3d7c:	0f b6       	in	r0, 0x3f	; 63
    3d7e:	f8 94       	cli
    3d80:	9e bf       	out	0x3e, r25	; 62
    3d82:	0f be       	out	0x3f, r0	; 63
    3d84:	8d bf       	out	0x3d, r24	; 61
    3d86:	ed b7       	in	r30, 0x3d	; 61
    3d88:	fe b7       	in	r31, 0x3e	; 62
    3d8a:	31 96       	adiw	r30, 0x01	; 1
    3d8c:	8b e4       	ldi	r24, 0x4B	; 75
    3d8e:	94 e2       	ldi	r25, 0x24	; 36
    3d90:	0d c0       	rjmp	.+26     	; 0x3dac <__stack+0x1bad>
						else 
							printf("Son las %x:%x:%x AM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    3d92:	8d b7       	in	r24, 0x3d	; 61
    3d94:	9e b7       	in	r25, 0x3e	; 62
    3d96:	08 97       	sbiw	r24, 0x08	; 8
    3d98:	0f b6       	in	r0, 0x3f	; 63
    3d9a:	f8 94       	cli
    3d9c:	9e bf       	out	0x3e, r25	; 62
    3d9e:	0f be       	out	0x3f, r0	; 63
    3da0:	8d bf       	out	0x3d, r24	; 61
    3da2:	ed b7       	in	r30, 0x3d	; 61
    3da4:	fe b7       	in	r31, 0x3e	; 62
    3da6:	31 96       	adiw	r30, 0x01	; 1
    3da8:	81 e6       	ldi	r24, 0x61	; 97
    3daa:	94 e2       	ldi	r25, 0x24	; 36
    3dac:	ad b7       	in	r26, 0x3d	; 61
    3dae:	be b7       	in	r27, 0x3e	; 62
    3db0:	12 96       	adiw	r26, 0x02	; 2
    3db2:	9c 93       	st	X, r25
    3db4:	8e 93       	st	-X, r24
    3db6:	11 97       	sbiw	r26, 0x01	; 1
    3db8:	33 83       	std	Z+3, r19	; 0x03
    3dba:	22 83       	std	Z+2, r18	; 0x02
    3dbc:	80 91 68 78 	lds	r24, 0x7868
    3dc0:	84 83       	std	Z+4, r24	; 0x04
    3dc2:	15 82       	std	Z+5, r1	; 0x05
    3dc4:	80 91 67 78 	lds	r24, 0x7867
    3dc8:	86 83       	std	Z+6, r24	; 0x06
    3dca:	17 82       	std	Z+7, r1	; 0x07
    3dcc:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    3dd0:	ed b7       	in	r30, 0x3d	; 61
    3dd2:	fe b7       	in	r31, 0x3e	; 62
    3dd4:	38 96       	adiw	r30, 0x08	; 8
    3dd6:	0f b6       	in	r0, 0x3f	; 63
    3dd8:	f8 94       	cli
    3dda:	fe bf       	out	0x3e, r31	; 62
    3ddc:	0f be       	out	0x3f, r0	; 63
    3dde:	ed bf       	out	0x3d, r30	; 61
    3de0:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__stack+0x2cf>
						scanf("%d",&stop);  
				    break;
					
					case (4):
						Read_SR(&SR_RTC);
    3de4:	85 e5       	ldi	r24, 0x55	; 85
    3de6:	98 e7       	ldi	r25, 0x78	; 120
    3de8:	0e 94 a5 88 	call	0x1114a	; 0x1114a <Read_SR>
							if((SR_RTC & BATMask) != 0)
    3dec:	80 91 55 78 	lds	r24, 0x7855
    3df0:	87 ff       	sbrs	r24, 7
    3df2:	13 c0       	rjmp	.+38     	; 0x3e1a <__stack+0x1c1b>
								fprintf_P(stdout,PSTR("BAT = 1 \n"));
    3df4:	00 d0       	rcall	.+0      	; 0x3df6 <__stack+0x1bf7>
    3df6:	00 d0       	rcall	.+0      	; 0x3df8 <__stack+0x1bf9>
    3df8:	80 91 d0 79 	lds	r24, 0x79D0
    3dfc:	90 91 d1 79 	lds	r25, 0x79D1
    3e00:	ad b7       	in	r26, 0x3d	; 61
    3e02:	be b7       	in	r27, 0x3e	; 62
    3e04:	12 96       	adiw	r26, 0x02	; 2
    3e06:	9c 93       	st	X, r25
    3e08:	8e 93       	st	-X, r24
    3e0a:	11 97       	sbiw	r26, 0x01	; 1
    3e0c:	85 ec       	ldi	r24, 0xC5	; 197
    3e0e:	98 e0       	ldi	r25, 0x08	; 8
    3e10:	14 96       	adiw	r26, 0x04	; 4
    3e12:	9c 93       	st	X, r25
    3e14:	8e 93       	st	-X, r24
    3e16:	13 97       	sbiw	r26, 0x03	; 3
    3e18:	0e c0       	rjmp	.+28     	; 0x3e36 <__stack+0x1c37>
							else
								fprintf_P(stdout,PSTR("BAT = 0 \n"));								
    3e1a:	00 d0       	rcall	.+0      	; 0x3e1c <__stack+0x1c1d>
    3e1c:	00 d0       	rcall	.+0      	; 0x3e1e <__stack+0x1c1f>
    3e1e:	80 91 d0 79 	lds	r24, 0x79D0
    3e22:	90 91 d1 79 	lds	r25, 0x79D1
    3e26:	ed b7       	in	r30, 0x3d	; 61
    3e28:	fe b7       	in	r31, 0x3e	; 62
    3e2a:	92 83       	std	Z+2, r25	; 0x02
    3e2c:	81 83       	std	Z+1, r24	; 0x01
    3e2e:	8b eb       	ldi	r24, 0xBB	; 187
    3e30:	98 e0       	ldi	r25, 0x08	; 8
    3e32:	94 83       	std	Z+4, r25	; 0x04
    3e34:	83 83       	std	Z+3, r24	; 0x03
    3e36:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    3e3a:	0f 90       	pop	r0
    3e3c:	0f 90       	pop	r0
    3e3e:	0f 90       	pop	r0
    3e40:	0f 90       	pop	r0
							
							if((SR_RTC & AL1Mask) != 0)
    3e42:	80 91 55 78 	lds	r24, 0x7855
    3e46:	86 ff       	sbrs	r24, 6
    3e48:	13 c0       	rjmp	.+38     	; 0x3e70 <__stack+0x1c71>
								fprintf_P(stdout,PSTR("AL1 = 1 \n"));
    3e4a:	00 d0       	rcall	.+0      	; 0x3e4c <__stack+0x1c4d>
    3e4c:	00 d0       	rcall	.+0      	; 0x3e4e <__stack+0x1c4f>
    3e4e:	80 91 d0 79 	lds	r24, 0x79D0
    3e52:	90 91 d1 79 	lds	r25, 0x79D1
    3e56:	ad b7       	in	r26, 0x3d	; 61
    3e58:	be b7       	in	r27, 0x3e	; 62
    3e5a:	12 96       	adiw	r26, 0x02	; 2
    3e5c:	9c 93       	st	X, r25
    3e5e:	8e 93       	st	-X, r24
    3e60:	11 97       	sbiw	r26, 0x01	; 1
    3e62:	81 eb       	ldi	r24, 0xB1	; 177
    3e64:	98 e0       	ldi	r25, 0x08	; 8
    3e66:	14 96       	adiw	r26, 0x04	; 4
    3e68:	9c 93       	st	X, r25
    3e6a:	8e 93       	st	-X, r24
    3e6c:	13 97       	sbiw	r26, 0x03	; 3
    3e6e:	0e c0       	rjmp	.+28     	; 0x3e8c <__stack+0x1c8d>
							else
								fprintf_P(stdout,PSTR("AL1 = 0 \n"));								
    3e70:	00 d0       	rcall	.+0      	; 0x3e72 <__stack+0x1c73>
    3e72:	00 d0       	rcall	.+0      	; 0x3e74 <__stack+0x1c75>
    3e74:	80 91 d0 79 	lds	r24, 0x79D0
    3e78:	90 91 d1 79 	lds	r25, 0x79D1
    3e7c:	ed b7       	in	r30, 0x3d	; 61
    3e7e:	fe b7       	in	r31, 0x3e	; 62
    3e80:	92 83       	std	Z+2, r25	; 0x02
    3e82:	81 83       	std	Z+1, r24	; 0x01
    3e84:	87 ea       	ldi	r24, 0xA7	; 167
    3e86:	98 e0       	ldi	r25, 0x08	; 8
    3e88:	94 83       	std	Z+4, r25	; 0x04
    3e8a:	83 83       	std	Z+3, r24	; 0x03
    3e8c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    3e90:	0f 90       	pop	r0
    3e92:	0f 90       	pop	r0
    3e94:	0f 90       	pop	r0
    3e96:	0f 90       	pop	r0
							
							if((SR_RTC & AL0Mask) != 0)
    3e98:	80 91 55 78 	lds	r24, 0x7855
    3e9c:	85 ff       	sbrs	r24, 5
    3e9e:	13 c0       	rjmp	.+38     	; 0x3ec6 <__stack+0x1cc7>
								fprintf_P(stdout,PSTR("Al0 = 1 \n"));
    3ea0:	00 d0       	rcall	.+0      	; 0x3ea2 <__stack+0x1ca3>
    3ea2:	00 d0       	rcall	.+0      	; 0x3ea4 <__stack+0x1ca5>
    3ea4:	80 91 d0 79 	lds	r24, 0x79D0
    3ea8:	90 91 d1 79 	lds	r25, 0x79D1
    3eac:	ad b7       	in	r26, 0x3d	; 61
    3eae:	be b7       	in	r27, 0x3e	; 62
    3eb0:	12 96       	adiw	r26, 0x02	; 2
    3eb2:	9c 93       	st	X, r25
    3eb4:	8e 93       	st	-X, r24
    3eb6:	11 97       	sbiw	r26, 0x01	; 1
    3eb8:	8d e9       	ldi	r24, 0x9D	; 157
    3eba:	98 e0       	ldi	r25, 0x08	; 8
    3ebc:	14 96       	adiw	r26, 0x04	; 4
    3ebe:	9c 93       	st	X, r25
    3ec0:	8e 93       	st	-X, r24
    3ec2:	13 97       	sbiw	r26, 0x03	; 3
    3ec4:	0e c0       	rjmp	.+28     	; 0x3ee2 <__stack+0x1ce3>
							else
								fprintf_P(stdout,PSTR("Al0 = 0 \n"));								
    3ec6:	00 d0       	rcall	.+0      	; 0x3ec8 <__stack+0x1cc9>
    3ec8:	00 d0       	rcall	.+0      	; 0x3eca <__stack+0x1ccb>
    3eca:	80 91 d0 79 	lds	r24, 0x79D0
    3ece:	90 91 d1 79 	lds	r25, 0x79D1
    3ed2:	ed b7       	in	r30, 0x3d	; 61
    3ed4:	fe b7       	in	r31, 0x3e	; 62
    3ed6:	92 83       	std	Z+2, r25	; 0x02
    3ed8:	81 83       	std	Z+1, r24	; 0x01
    3eda:	83 e9       	ldi	r24, 0x93	; 147
    3edc:	98 e0       	ldi	r25, 0x08	; 8
    3ede:	94 83       	std	Z+4, r25	; 0x04
    3ee0:	83 83       	std	Z+3, r24	; 0x03
    3ee2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    3ee6:	0f 90       	pop	r0
    3ee8:	0f 90       	pop	r0
    3eea:	0f 90       	pop	r0
    3eec:	0f 90       	pop	r0
							
							if((SR_RTC & OSCFMask) != 0)
    3eee:	80 91 55 78 	lds	r24, 0x7855
    3ef2:	84 ff       	sbrs	r24, 4
    3ef4:	13 c0       	rjmp	.+38     	; 0x3f1c <__stack+0x1d1d>
								fprintf_P(stdout,PSTR("OSCF = 1 \n"));
    3ef6:	00 d0       	rcall	.+0      	; 0x3ef8 <__stack+0x1cf9>
    3ef8:	00 d0       	rcall	.+0      	; 0x3efa <__stack+0x1cfb>
    3efa:	80 91 d0 79 	lds	r24, 0x79D0
    3efe:	90 91 d1 79 	lds	r25, 0x79D1
    3f02:	ad b7       	in	r26, 0x3d	; 61
    3f04:	be b7       	in	r27, 0x3e	; 62
    3f06:	12 96       	adiw	r26, 0x02	; 2
    3f08:	9c 93       	st	X, r25
    3f0a:	8e 93       	st	-X, r24
    3f0c:	11 97       	sbiw	r26, 0x01	; 1
    3f0e:	88 e8       	ldi	r24, 0x88	; 136
    3f10:	98 e0       	ldi	r25, 0x08	; 8
    3f12:	14 96       	adiw	r26, 0x04	; 4
    3f14:	9c 93       	st	X, r25
    3f16:	8e 93       	st	-X, r24
    3f18:	13 97       	sbiw	r26, 0x03	; 3
    3f1a:	0e c0       	rjmp	.+28     	; 0x3f38 <__stack+0x1d39>
							else
								fprintf_P(stdout,PSTR("OSCF = 0 \n"));
    3f1c:	00 d0       	rcall	.+0      	; 0x3f1e <__stack+0x1d1f>
    3f1e:	00 d0       	rcall	.+0      	; 0x3f20 <__stack+0x1d21>
    3f20:	80 91 d0 79 	lds	r24, 0x79D0
    3f24:	90 91 d1 79 	lds	r25, 0x79D1
    3f28:	ed b7       	in	r30, 0x3d	; 61
    3f2a:	fe b7       	in	r31, 0x3e	; 62
    3f2c:	92 83       	std	Z+2, r25	; 0x02
    3f2e:	81 83       	std	Z+1, r24	; 0x01
    3f30:	8d e7       	ldi	r24, 0x7D	; 125
    3f32:	98 e0       	ldi	r25, 0x08	; 8
    3f34:	94 83       	std	Z+4, r25	; 0x04
    3f36:	83 83       	std	Z+3, r24	; 0x03
    3f38:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    3f3c:	0f 90       	pop	r0
    3f3e:	0f 90       	pop	r0
    3f40:	0f 90       	pop	r0
    3f42:	0f 90       	pop	r0
								
							if((SR_RTC & RWELMask) != 0)
    3f44:	80 91 55 78 	lds	r24, 0x7855
    3f48:	82 ff       	sbrs	r24, 2
    3f4a:	13 c0       	rjmp	.+38     	; 0x3f72 <__stack+0x1d73>
								fprintf_P(stdout,PSTR("RWEL = 1 \n"));
    3f4c:	00 d0       	rcall	.+0      	; 0x3f4e <__stack+0x1d4f>
    3f4e:	00 d0       	rcall	.+0      	; 0x3f50 <__stack+0x1d51>
    3f50:	80 91 d0 79 	lds	r24, 0x79D0
    3f54:	90 91 d1 79 	lds	r25, 0x79D1
    3f58:	ad b7       	in	r26, 0x3d	; 61
    3f5a:	be b7       	in	r27, 0x3e	; 62
    3f5c:	12 96       	adiw	r26, 0x02	; 2
    3f5e:	9c 93       	st	X, r25
    3f60:	8e 93       	st	-X, r24
    3f62:	11 97       	sbiw	r26, 0x01	; 1
    3f64:	82 e7       	ldi	r24, 0x72	; 114
    3f66:	98 e0       	ldi	r25, 0x08	; 8
    3f68:	14 96       	adiw	r26, 0x04	; 4
    3f6a:	9c 93       	st	X, r25
    3f6c:	8e 93       	st	-X, r24
    3f6e:	13 97       	sbiw	r26, 0x03	; 3
    3f70:	0e c0       	rjmp	.+28     	; 0x3f8e <__stack+0x1d8f>
							else
								fprintf_P(stdout,PSTR("RWEL = 0 \n"));								
    3f72:	00 d0       	rcall	.+0      	; 0x3f74 <__stack+0x1d75>
    3f74:	00 d0       	rcall	.+0      	; 0x3f76 <__stack+0x1d77>
    3f76:	80 91 d0 79 	lds	r24, 0x79D0
    3f7a:	90 91 d1 79 	lds	r25, 0x79D1
    3f7e:	ed b7       	in	r30, 0x3d	; 61
    3f80:	fe b7       	in	r31, 0x3e	; 62
    3f82:	92 83       	std	Z+2, r25	; 0x02
    3f84:	81 83       	std	Z+1, r24	; 0x01
    3f86:	87 e6       	ldi	r24, 0x67	; 103
    3f88:	98 e0       	ldi	r25, 0x08	; 8
    3f8a:	94 83       	std	Z+4, r25	; 0x04
    3f8c:	83 83       	std	Z+3, r24	; 0x03
    3f8e:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    3f92:	0f 90       	pop	r0
    3f94:	0f 90       	pop	r0
    3f96:	0f 90       	pop	r0
    3f98:	0f 90       	pop	r0
								
							if((SR_RTC & WELMask) != 0)
    3f9a:	80 91 55 78 	lds	r24, 0x7855
    3f9e:	81 ff       	sbrs	r24, 1
    3fa0:	13 c0       	rjmp	.+38     	; 0x3fc8 <__stack+0x1dc9>
								fprintf_P(stdout,PSTR("WEL = 1 \n"));
    3fa2:	00 d0       	rcall	.+0      	; 0x3fa4 <__stack+0x1da5>
    3fa4:	00 d0       	rcall	.+0      	; 0x3fa6 <__stack+0x1da7>
    3fa6:	80 91 d0 79 	lds	r24, 0x79D0
    3faa:	90 91 d1 79 	lds	r25, 0x79D1
    3fae:	ad b7       	in	r26, 0x3d	; 61
    3fb0:	be b7       	in	r27, 0x3e	; 62
    3fb2:	12 96       	adiw	r26, 0x02	; 2
    3fb4:	9c 93       	st	X, r25
    3fb6:	8e 93       	st	-X, r24
    3fb8:	11 97       	sbiw	r26, 0x01	; 1
    3fba:	8d e5       	ldi	r24, 0x5D	; 93
    3fbc:	98 e0       	ldi	r25, 0x08	; 8
    3fbe:	14 96       	adiw	r26, 0x04	; 4
    3fc0:	9c 93       	st	X, r25
    3fc2:	8e 93       	st	-X, r24
    3fc4:	13 97       	sbiw	r26, 0x03	; 3
    3fc6:	0e c0       	rjmp	.+28     	; 0x3fe4 <__stack+0x1de5>
							else
								fprintf_P(stdout,PSTR("WEL = 0 \n"));								
    3fc8:	00 d0       	rcall	.+0      	; 0x3fca <__stack+0x1dcb>
    3fca:	00 d0       	rcall	.+0      	; 0x3fcc <__stack+0x1dcd>
    3fcc:	80 91 d0 79 	lds	r24, 0x79D0
    3fd0:	90 91 d1 79 	lds	r25, 0x79D1
    3fd4:	ed b7       	in	r30, 0x3d	; 61
    3fd6:	fe b7       	in	r31, 0x3e	; 62
    3fd8:	92 83       	std	Z+2, r25	; 0x02
    3fda:	81 83       	std	Z+1, r24	; 0x01
    3fdc:	83 e5       	ldi	r24, 0x53	; 83
    3fde:	98 e0       	ldi	r25, 0x08	; 8
    3fe0:	94 83       	std	Z+4, r25	; 0x04
    3fe2:	83 83       	std	Z+3, r24	; 0x03
    3fe4:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    3fe8:	0f 90       	pop	r0
    3fea:	0f 90       	pop	r0
    3fec:	0f 90       	pop	r0
    3fee:	0f 90       	pop	r0
								
							if((SR_RTC & RTCFMask) != 0)
    3ff0:	80 91 55 78 	lds	r24, 0x7855
    3ff4:	80 ff       	sbrs	r24, 0
    3ff6:	13 c0       	rjmp	.+38     	; 0x401e <__stack+0x1e1f>
								fprintf_P(stdout,PSTR("RTCF = 1 \n"));
    3ff8:	00 d0       	rcall	.+0      	; 0x3ffa <__stack+0x1dfb>
    3ffa:	00 d0       	rcall	.+0      	; 0x3ffc <__stack+0x1dfd>
    3ffc:	80 91 d0 79 	lds	r24, 0x79D0
    4000:	90 91 d1 79 	lds	r25, 0x79D1
    4004:	ad b7       	in	r26, 0x3d	; 61
    4006:	be b7       	in	r27, 0x3e	; 62
    4008:	12 96       	adiw	r26, 0x02	; 2
    400a:	9c 93       	st	X, r25
    400c:	8e 93       	st	-X, r24
    400e:	11 97       	sbiw	r26, 0x01	; 1
    4010:	88 e4       	ldi	r24, 0x48	; 72
    4012:	98 e0       	ldi	r25, 0x08	; 8
    4014:	14 96       	adiw	r26, 0x04	; 4
    4016:	9c 93       	st	X, r25
    4018:	8e 93       	st	-X, r24
    401a:	13 97       	sbiw	r26, 0x03	; 3
    401c:	0e c0       	rjmp	.+28     	; 0x403a <__stack+0x1e3b>
							else
								fprintf_P(stdout,PSTR("RTCF = 0 \n"));							
    401e:	00 d0       	rcall	.+0      	; 0x4020 <__stack+0x1e21>
    4020:	00 d0       	rcall	.+0      	; 0x4022 <__stack+0x1e23>
    4022:	80 91 d0 79 	lds	r24, 0x79D0
    4026:	90 91 d1 79 	lds	r25, 0x79D1
    402a:	ed b7       	in	r30, 0x3d	; 61
    402c:	fe b7       	in	r31, 0x3e	; 62
    402e:	92 83       	std	Z+2, r25	; 0x02
    4030:	81 83       	std	Z+1, r24	; 0x01
    4032:	8d e3       	ldi	r24, 0x3D	; 61
    4034:	98 e0       	ldi	r25, 0x08	; 8
    4036:	94 83       	std	Z+4, r25	; 0x04
    4038:	83 83       	std	Z+3, r24	; 0x03
    403a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						
						printf("Status Register = %#X \n",SR_RTC);
    403e:	ed b7       	in	r30, 0x3d	; 61
    4040:	fe b7       	in	r31, 0x3e	; 62
    4042:	31 96       	adiw	r30, 0x01	; 1
    4044:	87 e7       	ldi	r24, 0x77	; 119
    4046:	94 e2       	ldi	r25, 0x24	; 36
    4048:	ad b7       	in	r26, 0x3d	; 61
    404a:	be b7       	in	r27, 0x3e	; 62
    404c:	12 96       	adiw	r26, 0x02	; 2
    404e:	9c 93       	st	X, r25
    4050:	8e 93       	st	-X, r24
    4052:	11 97       	sbiw	r26, 0x01	; 1
    4054:	80 91 55 78 	lds	r24, 0x7855
    4058:	82 83       	std	Z+2, r24	; 0x02
    405a:	13 82       	std	Z+3, r1	; 0x03
    405c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    4060:	24 c4       	rjmp	.+2120   	; 0x48aa <__stack+0x26ab>
						scanf("%d",&stop);		
				    break;
					
					case (5):
						read_control(&ctr);
    4062:	8e e0       	ldi	r24, 0x0E	; 14
    4064:	95 e7       	ldi	r25, 0x75	; 117
    4066:	0e 94 96 88 	call	0x1112c	; 0x1112c <read_control>
						printf("PWR = %x \n",ctr.PWR);
    406a:	00 d0       	rcall	.+0      	; 0x406c <__stack+0x1e6d>
    406c:	00 d0       	rcall	.+0      	; 0x406e <__stack+0x1e6f>
    406e:	ed b7       	in	r30, 0x3d	; 61
    4070:	fe b7       	in	r31, 0x3e	; 62
    4072:	31 96       	adiw	r30, 0x01	; 1
    4074:	8e ea       	ldi	r24, 0xAE	; 174
    4076:	93 e2       	ldi	r25, 0x23	; 35
    4078:	ad b7       	in	r26, 0x3d	; 61
    407a:	be b7       	in	r27, 0x3e	; 62
    407c:	12 96       	adiw	r26, 0x02	; 2
    407e:	9c 93       	st	X, r25
    4080:	8e 93       	st	-X, r24
    4082:	11 97       	sbiw	r26, 0x01	; 1
    4084:	80 91 12 75 	lds	r24, 0x7512
    4088:	82 83       	std	Z+2, r24	; 0x02
    408a:	13 82       	std	Z+3, r1	; 0x03
    408c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("DTR = %x \n",ctr.DTR);
    4090:	ed b7       	in	r30, 0x3d	; 61
    4092:	fe b7       	in	r31, 0x3e	; 62
    4094:	31 96       	adiw	r30, 0x01	; 1
    4096:	89 eb       	ldi	r24, 0xB9	; 185
    4098:	93 e2       	ldi	r25, 0x23	; 35
    409a:	ad b7       	in	r26, 0x3d	; 61
    409c:	be b7       	in	r27, 0x3e	; 62
    409e:	12 96       	adiw	r26, 0x02	; 2
    40a0:	9c 93       	st	X, r25
    40a2:	8e 93       	st	-X, r24
    40a4:	11 97       	sbiw	r26, 0x01	; 1
    40a6:	80 91 11 75 	lds	r24, 0x7511
    40aa:	82 83       	std	Z+2, r24	; 0x02
    40ac:	13 82       	std	Z+3, r1	; 0x03
    40ae:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("ATR = %x \n",ctr.ATR);
    40b2:	ed b7       	in	r30, 0x3d	; 61
    40b4:	fe b7       	in	r31, 0x3e	; 62
    40b6:	31 96       	adiw	r30, 0x01	; 1
    40b8:	84 ec       	ldi	r24, 0xC4	; 196
    40ba:	93 e2       	ldi	r25, 0x23	; 35
    40bc:	ad b7       	in	r26, 0x3d	; 61
    40be:	be b7       	in	r27, 0x3e	; 62
    40c0:	12 96       	adiw	r26, 0x02	; 2
    40c2:	9c 93       	st	X, r25
    40c4:	8e 93       	st	-X, r24
    40c6:	11 97       	sbiw	r26, 0x01	; 1
    40c8:	80 91 10 75 	lds	r24, 0x7510
    40cc:	82 83       	std	Z+2, r24	; 0x02
    40ce:	13 82       	std	Z+3, r1	; 0x03
    40d0:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("INT = %x \n",ctr.INT);
    40d4:	ed b7       	in	r30, 0x3d	; 61
    40d6:	fe b7       	in	r31, 0x3e	; 62
    40d8:	31 96       	adiw	r30, 0x01	; 1
    40da:	8f ec       	ldi	r24, 0xCF	; 207
    40dc:	93 e2       	ldi	r25, 0x23	; 35
    40de:	ad b7       	in	r26, 0x3d	; 61
    40e0:	be b7       	in	r27, 0x3e	; 62
    40e2:	12 96       	adiw	r26, 0x02	; 2
    40e4:	9c 93       	st	X, r25
    40e6:	8e 93       	st	-X, r24
    40e8:	11 97       	sbiw	r26, 0x01	; 1
    40ea:	80 91 0f 75 	lds	r24, 0x750F
    40ee:	82 83       	std	Z+2, r24	; 0x02
    40f0:	13 82       	std	Z+3, r1	; 0x03
    40f2:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						printf("BL  = %x \n",ctr.BL);
    40f6:	ed b7       	in	r30, 0x3d	; 61
    40f8:	fe b7       	in	r31, 0x3e	; 62
    40fa:	31 96       	adiw	r30, 0x01	; 1
    40fc:	8a ed       	ldi	r24, 0xDA	; 218
    40fe:	93 e2       	ldi	r25, 0x23	; 35
    4100:	ad b7       	in	r26, 0x3d	; 61
    4102:	be b7       	in	r27, 0x3e	; 62
    4104:	12 96       	adiw	r26, 0x02	; 2
    4106:	9c 93       	st	X, r25
    4108:	8e 93       	st	-X, r24
    410a:	11 97       	sbiw	r26, 0x01	; 1
    410c:	80 91 0e 75 	lds	r24, 0x750E
    4110:	a3 cf       	rjmp	.-186    	; 0x4058 <__stack+0x1e59>
					break;				    
				}				
			break;			
			
			case (4)://FUNCIONES DE MANEJO DE EEPROM Y TEACH PENDANT
				fprintf_P(stdout,PSTR("0. Escribir en la EEPROM \n"));
    4112:	00 d0       	rcall	.+0      	; 0x4114 <__stack+0x1f15>
    4114:	00 d0       	rcall	.+0      	; 0x4116 <__stack+0x1f17>
    4116:	80 91 d0 79 	lds	r24, 0x79D0
    411a:	90 91 d1 79 	lds	r25, 0x79D1
    411e:	ad b7       	in	r26, 0x3d	; 61
    4120:	be b7       	in	r27, 0x3e	; 62
    4122:	12 96       	adiw	r26, 0x02	; 2
    4124:	9c 93       	st	X, r25
    4126:	8e 93       	st	-X, r24
    4128:	11 97       	sbiw	r26, 0x01	; 1
    412a:	82 e2       	ldi	r24, 0x22	; 34
    412c:	98 e0       	ldi	r25, 0x08	; 8
    412e:	14 96       	adiw	r26, 0x04	; 4
    4130:	9c 93       	st	X, r25
    4132:	8e 93       	st	-X, r24
    4134:	13 97       	sbiw	r26, 0x03	; 3
    4136:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("1. Leer la EEPROM \n"));
    413a:	80 91 d0 79 	lds	r24, 0x79D0
    413e:	90 91 d1 79 	lds	r25, 0x79D1
    4142:	ed b7       	in	r30, 0x3d	; 61
    4144:	fe b7       	in	r31, 0x3e	; 62
    4146:	92 83       	std	Z+2, r25	; 0x02
    4148:	81 83       	std	Z+1, r24	; 0x01
    414a:	8e e0       	ldi	r24, 0x0E	; 14
    414c:	98 e0       	ldi	r25, 0x08	; 8
    414e:	94 83       	std	Z+4, r25	; 0x04
    4150:	83 83       	std	Z+3, r24	; 0x03
    4152:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("2. Encontrar Direccion de ID \n"));
    4156:	80 91 d0 79 	lds	r24, 0x79D0
    415a:	90 91 d1 79 	lds	r25, 0x79D1
    415e:	ad b7       	in	r26, 0x3d	; 61
    4160:	be b7       	in	r27, 0x3e	; 62
    4162:	12 96       	adiw	r26, 0x02	; 2
    4164:	9c 93       	st	X, r25
    4166:	8e 93       	st	-X, r24
    4168:	11 97       	sbiw	r26, 0x01	; 1
    416a:	8f ee       	ldi	r24, 0xEF	; 239
    416c:	97 e0       	ldi	r25, 0x07	; 7
    416e:	14 96       	adiw	r26, 0x04	; 4
    4170:	9c 93       	st	X, r25
    4172:	8e 93       	st	-X, r24
    4174:	13 97       	sbiw	r26, 0x03	; 3
    4176:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("3. Borrar EEPROM \n"));
    417a:	80 91 d0 79 	lds	r24, 0x79D0
    417e:	90 91 d1 79 	lds	r25, 0x79D1
    4182:	ed b7       	in	r30, 0x3d	; 61
    4184:	fe b7       	in	r31, 0x3e	; 62
    4186:	92 83       	std	Z+2, r25	; 0x02
    4188:	81 83       	std	Z+1, r24	; 0x01
    418a:	8c ed       	ldi	r24, 0xDC	; 220
    418c:	97 e0       	ldi	r25, 0x07	; 7
    418e:	94 83       	std	Z+4, r25	; 0x04
    4190:	83 83       	std	Z+3, r24	; 0x03
    4192:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("4. Adicionar Pose en EEPROM \n"));
    4196:	80 91 d0 79 	lds	r24, 0x79D0
    419a:	90 91 d1 79 	lds	r25, 0x79D1
    419e:	ad b7       	in	r26, 0x3d	; 61
    41a0:	be b7       	in	r27, 0x3e	; 62
    41a2:	12 96       	adiw	r26, 0x02	; 2
    41a4:	9c 93       	st	X, r25
    41a6:	8e 93       	st	-X, r24
    41a8:	11 97       	sbiw	r26, 0x01	; 1
    41aa:	8e eb       	ldi	r24, 0xBE	; 190
    41ac:	97 e0       	ldi	r25, 0x07	; 7
    41ae:	14 96       	adiw	r26, 0x04	; 4
    41b0:	9c 93       	st	X, r25
    41b2:	8e 93       	st	-X, r24
    41b4:	13 97       	sbiw	r26, 0x03	; 3
    41b6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("5. Sobreescribir Pose \n"));
    41ba:	80 91 d0 79 	lds	r24, 0x79D0
    41be:	90 91 d1 79 	lds	r25, 0x79D1
    41c2:	ed b7       	in	r30, 0x3d	; 61
    41c4:	fe b7       	in	r31, 0x3e	; 62
    41c6:	92 83       	std	Z+2, r25	; 0x02
    41c8:	81 83       	std	Z+1, r24	; 0x01
    41ca:	86 ea       	ldi	r24, 0xA6	; 166
    41cc:	97 e0       	ldi	r25, 0x07	; 7
    41ce:	94 83       	std	Z+4, r25	; 0x04
    41d0:	83 83       	std	Z+3, r24	; 0x03
    41d2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("6. Leer Pose almacenada en EEPROM \n"));				
    41d6:	80 91 d0 79 	lds	r24, 0x79D0
    41da:	90 91 d1 79 	lds	r25, 0x79D1
    41de:	ad b7       	in	r26, 0x3d	; 61
    41e0:	be b7       	in	r27, 0x3e	; 62
    41e2:	12 96       	adiw	r26, 0x02	; 2
    41e4:	9c 93       	st	X, r25
    41e6:	8e 93       	st	-X, r24
    41e8:	11 97       	sbiw	r26, 0x01	; 1
    41ea:	82 e8       	ldi	r24, 0x82	; 130
    41ec:	97 e0       	ldi	r25, 0x07	; 7
    41ee:	14 96       	adiw	r26, 0x04	; 4
    41f0:	9c 93       	st	X, r25
    41f2:	8e 93       	st	-X, r24
    41f4:	13 97       	sbiw	r26, 0x03	; 3
    41f6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("7. Retornar Vector de Ids \n"));
    41fa:	80 91 d0 79 	lds	r24, 0x79D0
    41fe:	90 91 d1 79 	lds	r25, 0x79D1
    4202:	ed b7       	in	r30, 0x3d	; 61
    4204:	fe b7       	in	r31, 0x3e	; 62
    4206:	92 83       	std	Z+2, r25	; 0x02
    4208:	81 83       	std	Z+1, r24	; 0x01
    420a:	86 e6       	ldi	r24, 0x66	; 102
    420c:	97 e0       	ldi	r25, 0x07	; 7
    420e:	94 83       	std	Z+4, r25	; 0x04
    4210:	83 83       	std	Z+3, r24	; 0x03
    4212:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("8. Obtener Trayectoria de un Vector de IDs \n"));
    4216:	80 91 d0 79 	lds	r24, 0x79D0
    421a:	90 91 d1 79 	lds	r25, 0x79D1
    421e:	ad b7       	in	r26, 0x3d	; 61
    4220:	be b7       	in	r27, 0x3e	; 62
    4222:	12 96       	adiw	r26, 0x02	; 2
    4224:	9c 93       	st	X, r25
    4226:	8e 93       	st	-X, r24
    4228:	11 97       	sbiw	r26, 0x01	; 1
    422a:	89 e3       	ldi	r24, 0x39	; 57
    422c:	97 e0       	ldi	r25, 0x07	; 7
    422e:	14 96       	adiw	r26, 0x04	; 4
    4230:	9c 93       	st	X, r25
    4232:	8e 93       	st	-X, r24
    4234:	13 97       	sbiw	r26, 0x03	; 3
    4236:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("9. Imprimir Datos de Trayectoria \n"));
    423a:	80 91 d0 79 	lds	r24, 0x79D0
    423e:	90 91 d1 79 	lds	r25, 0x79D1
    4242:	ed b7       	in	r30, 0x3d	; 61
    4244:	fe b7       	in	r31, 0x3e	; 62
    4246:	92 83       	std	Z+2, r25	; 0x02
    4248:	81 83       	std	Z+1, r24	; 0x01
    424a:	86 e1       	ldi	r24, 0x16	; 22
    424c:	97 e0       	ldi	r25, 0x07	; 7
    424e:	94 83       	std	Z+4, r25	; 0x04
    4250:	83 83       	std	Z+3, r24	; 0x03
    4252:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("Otra Opcion: Salir SubMenu \n"));
    4256:	80 91 d0 79 	lds	r24, 0x79D0
    425a:	90 91 d1 79 	lds	r25, 0x79D1
    425e:	ad b7       	in	r26, 0x3d	; 61
    4260:	be b7       	in	r27, 0x3e	; 62
    4262:	12 96       	adiw	r26, 0x02	; 2
    4264:	9c 93       	st	X, r25
    4266:	8e 93       	st	-X, r24
    4268:	11 97       	sbiw	r26, 0x01	; 1
    426a:	89 ef       	ldi	r24, 0xF9	; 249
    426c:	96 e0       	ldi	r25, 0x06	; 6
    426e:	14 96       	adiw	r26, 0x04	; 4
    4270:	9c 93       	st	X, r25
    4272:	8e 93       	st	-X, r24
    4274:	13 97       	sbiw	r26, 0x03	; 3
    4276:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				scanf("%d",&submenu);
    427a:	2c e1       	ldi	r18, 0x1C	; 28
    427c:	32 e2       	ldi	r19, 0x22	; 34
    427e:	ed b7       	in	r30, 0x3d	; 61
    4280:	fe b7       	in	r31, 0x3e	; 62
    4282:	32 83       	std	Z+2, r19	; 0x02
    4284:	21 83       	std	Z+1, r18	; 0x01
    4286:	ce 01       	movw	r24, r28
    4288:	05 96       	adiw	r24, 0x05	; 5
    428a:	94 83       	std	Z+4, r25	; 0x04
    428c:	83 83       	std	Z+3, r24	; 0x03
    428e:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
				
				if(submenu==4 || submenu==5)
    4292:	8d 81       	ldd	r24, Y+5	; 0x05
    4294:	9e 81       	ldd	r25, Y+6	; 0x06
    4296:	04 97       	sbiw	r24, 0x04	; 4
    4298:	0f 90       	pop	r0
    429a:	0f 90       	pop	r0
    429c:	0f 90       	pop	r0
    429e:	0f 90       	pop	r0
    42a0:	02 97       	sbiw	r24, 0x02	; 2
    42a2:	08 f0       	brcs	.+2      	; 0x42a6 <__stack+0x20a7>
    42a4:	01 c1       	rjmp	.+514    	; 0x44a8 <__stack+0x22a9>
				{
					fprintf_P(stdout,PSTR("Digite el ID de la Pose que desea grabar . \n"));
    42a6:	00 d0       	rcall	.+0      	; 0x42a8 <__stack+0x20a9>
    42a8:	00 d0       	rcall	.+0      	; 0x42aa <__stack+0x20ab>
    42aa:	80 91 d0 79 	lds	r24, 0x79D0
    42ae:	90 91 d1 79 	lds	r25, 0x79D1
    42b2:	ad b7       	in	r26, 0x3d	; 61
    42b4:	be b7       	in	r27, 0x3e	; 62
    42b6:	12 96       	adiw	r26, 0x02	; 2
    42b8:	9c 93       	st	X, r25
    42ba:	8e 93       	st	-X, r24
    42bc:	11 97       	sbiw	r26, 0x01	; 1
    42be:	8c ec       	ldi	r24, 0xCC	; 204
    42c0:	96 e0       	ldi	r25, 0x06	; 6
    42c2:	14 96       	adiw	r26, 0x04	; 4
    42c4:	9c 93       	st	X, r25
    42c6:	8e 93       	st	-X, r24
    42c8:	13 97       	sbiw	r26, 0x03	; 3
    42ca:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("Digite el ID de la Pose que desea grabar . \n"));
    42ce:	80 91 d0 79 	lds	r24, 0x79D0
    42d2:	90 91 d1 79 	lds	r25, 0x79D1
    42d6:	ed b7       	in	r30, 0x3d	; 61
    42d8:	fe b7       	in	r31, 0x3e	; 62
    42da:	92 83       	std	Z+2, r25	; 0x02
    42dc:	81 83       	std	Z+1, r24	; 0x01
    42de:	8f e9       	ldi	r24, 0x9F	; 159
    42e0:	96 e0       	ldi	r25, 0x06	; 6
    42e2:	94 83       	std	Z+4, r25	; 0x04
    42e4:	83 83       	std	Z+3, r24	; 0x03
    42e6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%d", &id_pose);			
    42ea:	ec e1       	ldi	r30, 0x1C	; 28
    42ec:	f2 e2       	ldi	r31, 0x22	; 34
    42ee:	ad b7       	in	r26, 0x3d	; 61
    42f0:	be b7       	in	r27, 0x3e	; 62
    42f2:	12 96       	adiw	r26, 0x02	; 2
    42f4:	fc 93       	st	X, r31
    42f6:	ee 93       	st	-X, r30
    42f8:	11 97       	sbiw	r26, 0x01	; 1
    42fa:	ce 01       	movw	r24, r28
    42fc:	4b 96       	adiw	r24, 0x1b	; 27
    42fe:	14 96       	adiw	r26, 0x04	; 4
    4300:	9c 93       	st	X, r25
    4302:	8e 93       	st	-X, r24
    4304:	13 97       	sbiw	r26, 0x03	; 3
    4306:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
					Pose.id=id_pose;			
    430a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    430c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    430e:	ef 96       	adiw	r28, 0x3f	; 63
    4310:	9f af       	std	Y+63, r25	; 0x3f
    4312:	8e af       	std	Y+62, r24	; 0x3e
    4314:	ef 97       	sbiw	r28, 0x3f	; 63
					fprintf_P(stdout,PSTR("Digite la posicion de cintura . \n"));
    4316:	80 91 d0 79 	lds	r24, 0x79D0
    431a:	90 91 d1 79 	lds	r25, 0x79D1
    431e:	ad b7       	in	r26, 0x3d	; 61
    4320:	be b7       	in	r27, 0x3e	; 62
    4322:	12 96       	adiw	r26, 0x02	; 2
    4324:	9c 93       	st	X, r25
    4326:	8e 93       	st	-X, r24
    4328:	11 97       	sbiw	r26, 0x01	; 1
    432a:	8d e7       	ldi	r24, 0x7D	; 125
    432c:	96 e0       	ldi	r25, 0x06	; 6
    432e:	14 96       	adiw	r26, 0x04	; 4
    4330:	9c 93       	st	X, r25
    4332:	8e 93       	st	-X, r24
    4334:	13 97       	sbiw	r26, 0x03	; 3
    4336:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%ld", &position);
    433a:	3f e1       	ldi	r19, 0x1F	; 31
    433c:	e3 2e       	mov	r14, r19
    433e:	32 e2       	ldi	r19, 0x22	; 34
    4340:	f3 2e       	mov	r15, r19
    4342:	ed b7       	in	r30, 0x3d	; 61
    4344:	fe b7       	in	r31, 0x3e	; 62
    4346:	f2 82       	std	Z+2, r15	; 0x02
    4348:	e1 82       	std	Z+1, r14	; 0x01
    434a:	8e 01       	movw	r16, r28
    434c:	03 5e       	subi	r16, 0xE3	; 227
    434e:	1f 4f       	sbci	r17, 0xFF	; 255
    4350:	14 83       	std	Z+4, r17	; 0x04
    4352:	03 83       	std	Z+3, r16	; 0x03
    4354:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
					Pose.Pos_Waist=position;			
    4358:	8d 8d       	ldd	r24, Y+29	; 0x1d
    435a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    435c:	af 8d       	ldd	r26, Y+31	; 0x1f
    435e:	b8 a1       	ldd	r27, Y+32	; 0x20
    4360:	c1 58       	subi	r28, 0x81	; 129
    4362:	df 4f       	sbci	r29, 0xFF	; 255
    4364:	88 83       	st	Y, r24
    4366:	99 83       	std	Y+1, r25	; 0x01
    4368:	aa 83       	std	Y+2, r26	; 0x02
    436a:	bb 83       	std	Y+3, r27	; 0x03
    436c:	cf 57       	subi	r28, 0x7F	; 127
    436e:	d0 40       	sbci	r29, 0x00	; 0
					fprintf_P(stdout,PSTR("Digite la posicion de Hombro . \n"));
    4370:	80 91 d0 79 	lds	r24, 0x79D0
    4374:	90 91 d1 79 	lds	r25, 0x79D1
    4378:	ad b7       	in	r26, 0x3d	; 61
    437a:	be b7       	in	r27, 0x3e	; 62
    437c:	12 96       	adiw	r26, 0x02	; 2
    437e:	9c 93       	st	X, r25
    4380:	8e 93       	st	-X, r24
    4382:	11 97       	sbiw	r26, 0x01	; 1
    4384:	8c e5       	ldi	r24, 0x5C	; 92
    4386:	96 e0       	ldi	r25, 0x06	; 6
    4388:	14 96       	adiw	r26, 0x04	; 4
    438a:	9c 93       	st	X, r25
    438c:	8e 93       	st	-X, r24
    438e:	13 97       	sbiw	r26, 0x03	; 3
    4390:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%ld", &position);
    4394:	ed b7       	in	r30, 0x3d	; 61
    4396:	fe b7       	in	r31, 0x3e	; 62
    4398:	f2 82       	std	Z+2, r15	; 0x02
    439a:	e1 82       	std	Z+1, r14	; 0x01
    439c:	14 83       	std	Z+4, r17	; 0x04
    439e:	03 83       	std	Z+3, r16	; 0x03
    43a0:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
					Pose.Pos_Shoulder=position;			
    43a4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    43a6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    43a8:	af 8d       	ldd	r26, Y+31	; 0x1f
    43aa:	b8 a1       	ldd	r27, Y+32	; 0x20
    43ac:	cd 57       	subi	r28, 0x7D	; 125
    43ae:	df 4f       	sbci	r29, 0xFF	; 255
    43b0:	88 83       	st	Y, r24
    43b2:	99 83       	std	Y+1, r25	; 0x01
    43b4:	aa 83       	std	Y+2, r26	; 0x02
    43b6:	bb 83       	std	Y+3, r27	; 0x03
    43b8:	c3 58       	subi	r28, 0x83	; 131
    43ba:	d0 40       	sbci	r29, 0x00	; 0
					fprintf_P(stdout,PSTR("Digite la posicion de Codo . \n"));
    43bc:	80 91 d0 79 	lds	r24, 0x79D0
    43c0:	90 91 d1 79 	lds	r25, 0x79D1
    43c4:	ad b7       	in	r26, 0x3d	; 61
    43c6:	be b7       	in	r27, 0x3e	; 62
    43c8:	12 96       	adiw	r26, 0x02	; 2
    43ca:	9c 93       	st	X, r25
    43cc:	8e 93       	st	-X, r24
    43ce:	11 97       	sbiw	r26, 0x01	; 1
    43d0:	8d e3       	ldi	r24, 0x3D	; 61
    43d2:	96 e0       	ldi	r25, 0x06	; 6
    43d4:	14 96       	adiw	r26, 0x04	; 4
    43d6:	9c 93       	st	X, r25
    43d8:	8e 93       	st	-X, r24
    43da:	13 97       	sbiw	r26, 0x03	; 3
    43dc:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%ld", &position);
    43e0:	ed b7       	in	r30, 0x3d	; 61
    43e2:	fe b7       	in	r31, 0x3e	; 62
    43e4:	f2 82       	std	Z+2, r15	; 0x02
    43e6:	e1 82       	std	Z+1, r14	; 0x01
    43e8:	14 83       	std	Z+4, r17	; 0x04
    43ea:	03 83       	std	Z+3, r16	; 0x03
    43ec:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
					Pose.Pos_Elbow=position;			
    43f0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    43f2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    43f4:	af 8d       	ldd	r26, Y+31	; 0x1f
    43f6:	b8 a1       	ldd	r27, Y+32	; 0x20
    43f8:	c9 57       	subi	r28, 0x79	; 121
    43fa:	df 4f       	sbci	r29, 0xFF	; 255
    43fc:	88 83       	st	Y, r24
    43fe:	99 83       	std	Y+1, r25	; 0x01
    4400:	aa 83       	std	Y+2, r26	; 0x02
    4402:	bb 83       	std	Y+3, r27	; 0x03
    4404:	c7 58       	subi	r28, 0x87	; 135
    4406:	d0 40       	sbci	r29, 0x00	; 0
					fprintf_P(stdout,PSTR("Digite la posicion de Pitch . \n"));
    4408:	80 91 d0 79 	lds	r24, 0x79D0
    440c:	90 91 d1 79 	lds	r25, 0x79D1
    4410:	ad b7       	in	r26, 0x3d	; 61
    4412:	be b7       	in	r27, 0x3e	; 62
    4414:	12 96       	adiw	r26, 0x02	; 2
    4416:	9c 93       	st	X, r25
    4418:	8e 93       	st	-X, r24
    441a:	11 97       	sbiw	r26, 0x01	; 1
    441c:	8d e1       	ldi	r24, 0x1D	; 29
    441e:	96 e0       	ldi	r25, 0x06	; 6
    4420:	14 96       	adiw	r26, 0x04	; 4
    4422:	9c 93       	st	X, r25
    4424:	8e 93       	st	-X, r24
    4426:	13 97       	sbiw	r26, 0x03	; 3
    4428:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%ld", &position);
    442c:	ed b7       	in	r30, 0x3d	; 61
    442e:	fe b7       	in	r31, 0x3e	; 62
    4430:	f2 82       	std	Z+2, r15	; 0x02
    4432:	e1 82       	std	Z+1, r14	; 0x01
    4434:	14 83       	std	Z+4, r17	; 0x04
    4436:	03 83       	std	Z+3, r16	; 0x03
    4438:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
					Pose.Pos_Pitch=position;			
    443c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    443e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4440:	af 8d       	ldd	r26, Y+31	; 0x1f
    4442:	b8 a1       	ldd	r27, Y+32	; 0x20
    4444:	c5 57       	subi	r28, 0x75	; 117
    4446:	df 4f       	sbci	r29, 0xFF	; 255
    4448:	88 83       	st	Y, r24
    444a:	99 83       	std	Y+1, r25	; 0x01
    444c:	aa 83       	std	Y+2, r26	; 0x02
    444e:	bb 83       	std	Y+3, r27	; 0x03
    4450:	cb 58       	subi	r28, 0x8B	; 139
    4452:	d0 40       	sbci	r29, 0x00	; 0
					fprintf_P(stdout,PSTR("Digite la posicion de Roll . \n"));
    4454:	80 91 d0 79 	lds	r24, 0x79D0
    4458:	90 91 d1 79 	lds	r25, 0x79D1
    445c:	ad b7       	in	r26, 0x3d	; 61
    445e:	be b7       	in	r27, 0x3e	; 62
    4460:	12 96       	adiw	r26, 0x02	; 2
    4462:	9c 93       	st	X, r25
    4464:	8e 93       	st	-X, r24
    4466:	11 97       	sbiw	r26, 0x01	; 1
    4468:	8e ef       	ldi	r24, 0xFE	; 254
    446a:	95 e0       	ldi	r25, 0x05	; 5
    446c:	14 96       	adiw	r26, 0x04	; 4
    446e:	9c 93       	st	X, r25
    4470:	8e 93       	st	-X, r24
    4472:	13 97       	sbiw	r26, 0x03	; 3
    4474:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%ld", &position);
    4478:	ed b7       	in	r30, 0x3d	; 61
    447a:	fe b7       	in	r31, 0x3e	; 62
    447c:	f2 82       	std	Z+2, r15	; 0x02
    447e:	e1 82       	std	Z+1, r14	; 0x01
    4480:	14 83       	std	Z+4, r17	; 0x04
    4482:	03 83       	std	Z+3, r16	; 0x03
    4484:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
					Pose.Pos_Roll=position;				
    4488:	8d 8d       	ldd	r24, Y+29	; 0x1d
    448a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    448c:	af 8d       	ldd	r26, Y+31	; 0x1f
    448e:	b8 a1       	ldd	r27, Y+32	; 0x20
    4490:	c1 57       	subi	r28, 0x71	; 113
    4492:	df 4f       	sbci	r29, 0xFF	; 255
    4494:	88 83       	st	Y, r24
    4496:	99 83       	std	Y+1, r25	; 0x01
    4498:	aa 83       	std	Y+2, r26	; 0x02
    449a:	bb 83       	std	Y+3, r27	; 0x03
    449c:	cf 58       	subi	r28, 0x8F	; 143
    449e:	d0 40       	sbci	r29, 0x00	; 0
    44a0:	0f 90       	pop	r0
    44a2:	0f 90       	pop	r0
    44a4:	0f 90       	pop	r0
    44a6:	0f 90       	pop	r0
				}
				
				switch (submenu)
    44a8:	8d 81       	ldd	r24, Y+5	; 0x05
    44aa:	9e 81       	ldd	r25, Y+6	; 0x06
    44ac:	83 30       	cpi	r24, 0x03	; 3
    44ae:	91 05       	cpc	r25, r1
    44b0:	09 f4       	brne	.+2      	; 0x44b4 <__stack+0x22b5>
    44b2:	ea c0       	rjmp	.+468    	; 0x4688 <__stack+0x2489>
    44b4:	84 30       	cpi	r24, 0x04	; 4
    44b6:	91 05       	cpc	r25, r1
    44b8:	64 f4       	brge	.+24     	; 0x44d2 <__stack+0x22d3>
    44ba:	81 30       	cpi	r24, 0x01	; 1
    44bc:	91 05       	cpc	r25, r1
    44be:	09 f4       	brne	.+2      	; 0x44c2 <__stack+0x22c3>
    44c0:	4f c0       	rjmp	.+158    	; 0x4560 <__stack+0x2361>
    44c2:	82 30       	cpi	r24, 0x02	; 2
    44c4:	91 05       	cpc	r25, r1
    44c6:	0c f0       	brlt	.+2      	; 0x44ca <__stack+0x22cb>
    44c8:	81 c0       	rjmp	.+258    	; 0x45cc <__stack+0x23cd>
    44ca:	89 2b       	or	r24, r25
    44cc:	99 f0       	breq	.+38     	; 0x44f4 <__stack+0x22f5>
    44ce:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
    44d2:	85 30       	cpi	r24, 0x05	; 5
    44d4:	91 05       	cpc	r25, r1
    44d6:	09 f4       	brne	.+2      	; 0x44da <__stack+0x22db>
    44d8:	fa c0       	rjmp	.+500    	; 0x46ce <__stack+0x24cf>
    44da:	85 30       	cpi	r24, 0x05	; 5
    44dc:	91 05       	cpc	r25, r1
    44de:	0c f4       	brge	.+2      	; 0x44e2 <__stack+0x22e3>
    44e0:	d7 c0       	rjmp	.+430    	; 0x4690 <__stack+0x2491>
    44e2:	86 30       	cpi	r24, 0x06	; 6
    44e4:	91 05       	cpc	r25, r1
    44e6:	09 f4       	brne	.+2      	; 0x44ea <__stack+0x22eb>
    44e8:	12 c1       	rjmp	.+548    	; 0x470e <__stack+0x250f>
    44ea:	07 97       	sbiw	r24, 0x07	; 7
    44ec:	11 f0       	breq	.+4      	; 0x44f2 <__stack+0x22f3>
    44ee:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
    44f2:	e7 c1       	rjmp	.+974    	; 0x48c2 <__stack+0x26c3>
				{
					case (0):
						ee24xx_write_bytes(0, sizeof(int16)*10, (uint8 *)memory);
    44f4:	8e 01       	movw	r16, r28
    44f6:	0b 5a       	subi	r16, 0xAB	; 171
    44f8:	1f 4f       	sbci	r17, 0xFF	; 255
    44fa:	60 e0       	ldi	r22, 0x00	; 0
    44fc:	70 e0       	ldi	r23, 0x00	; 0
    44fe:	80 e0       	ldi	r24, 0x00	; 0
    4500:	90 e0       	ldi	r25, 0x00	; 0
    4502:	44 e1       	ldi	r20, 0x14	; 20
    4504:	50 e0       	ldi	r21, 0x00	; 0
    4506:	98 01       	movw	r18, r16
    4508:	0e 94 0d 88 	call	0x1101a	; 0x1101a <ee24xx_write_bytes>
    450c:	78 01       	movw	r14, r16
    450e:	00 e0       	ldi	r16, 0x00	; 0
    4510:	10 e0       	ldi	r17, 0x00	; 0
						for (i=0; i< 10;i++)
						{
							printf(" El valor %d de Memory es = %d\n",i,memory[i]);							
    4512:	00 d0       	rcall	.+0      	; 0x4514 <__stack+0x2315>
    4514:	00 d0       	rcall	.+0      	; 0x4516 <__stack+0x2317>
    4516:	00 d0       	rcall	.+0      	; 0x4518 <__stack+0x2319>
    4518:	ed b7       	in	r30, 0x3d	; 61
    451a:	fe b7       	in	r31, 0x3e	; 62
    451c:	31 96       	adiw	r30, 0x01	; 1
    451e:	2f e8       	ldi	r18, 0x8F	; 143
    4520:	34 e2       	ldi	r19, 0x24	; 36
    4522:	ad b7       	in	r26, 0x3d	; 61
    4524:	be b7       	in	r27, 0x3e	; 62
    4526:	12 96       	adiw	r26, 0x02	; 2
    4528:	3c 93       	st	X, r19
    452a:	2e 93       	st	-X, r18
    452c:	11 97       	sbiw	r26, 0x01	; 1
    452e:	13 83       	std	Z+3, r17	; 0x03
    4530:	02 83       	std	Z+2, r16	; 0x02
    4532:	d7 01       	movw	r26, r14
    4534:	8d 91       	ld	r24, X+
    4536:	9d 91       	ld	r25, X+
    4538:	7d 01       	movw	r14, r26
    453a:	95 83       	std	Z+5, r25	; 0x05
    453c:	84 83       	std	Z+4, r24	; 0x04
    453e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
				
				switch (submenu)
				{
					case (0):
						ee24xx_write_bytes(0, sizeof(int16)*10, (uint8 *)memory);
						for (i=0; i< 10;i++)
    4542:	0f 5f       	subi	r16, 0xFF	; 255
    4544:	1f 4f       	sbci	r17, 0xFF	; 255
    4546:	ed b7       	in	r30, 0x3d	; 61
    4548:	fe b7       	in	r31, 0x3e	; 62
    454a:	36 96       	adiw	r30, 0x06	; 6
    454c:	0f b6       	in	r0, 0x3f	; 63
    454e:	f8 94       	cli
    4550:	fe bf       	out	0x3e, r31	; 62
    4552:	0f be       	out	0x3f, r0	; 63
    4554:	ed bf       	out	0x3d, r30	; 61
    4556:	0a 30       	cpi	r16, 0x0A	; 10
    4558:	11 05       	cpc	r17, r1
    455a:	d9 f6       	brne	.-74     	; 0x4512 <__stack+0x2313>
    455c:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__stack+0x2cf>
						}
						scanf("%d",&stop);
				    break;
					
					case (1):
						ee24xx_read_bytes(0, sizeof(int16)*10, (uint8 *)memory1);
    4560:	8e 01       	movw	r16, r28
    4562:	07 59       	subi	r16, 0x97	; 151
    4564:	1f 4f       	sbci	r17, 0xFF	; 255
    4566:	60 e0       	ldi	r22, 0x00	; 0
    4568:	70 e0       	ldi	r23, 0x00	; 0
    456a:	80 e0       	ldi	r24, 0x00	; 0
    456c:	90 e0       	ldi	r25, 0x00	; 0
    456e:	44 e1       	ldi	r20, 0x14	; 20
    4570:	50 e0       	ldi	r21, 0x00	; 0
    4572:	98 01       	movw	r18, r16
    4574:	0e 94 38 88 	call	0x11070	; 0x11070 <ee24xx_read_bytes>
    4578:	78 01       	movw	r14, r16
    457a:	00 e0       	ldi	r16, 0x00	; 0
    457c:	10 e0       	ldi	r17, 0x00	; 0
						for (i=0; i< 10;i++)
						{
							printf(" El valor %d de Memory1 es = %d\n",i,memory1[i]);
    457e:	00 d0       	rcall	.+0      	; 0x4580 <__stack+0x2381>
    4580:	00 d0       	rcall	.+0      	; 0x4582 <__stack+0x2383>
    4582:	00 d0       	rcall	.+0      	; 0x4584 <__stack+0x2385>
    4584:	ed b7       	in	r30, 0x3d	; 61
    4586:	fe b7       	in	r31, 0x3e	; 62
    4588:	31 96       	adiw	r30, 0x01	; 1
    458a:	2f ea       	ldi	r18, 0xAF	; 175
    458c:	34 e2       	ldi	r19, 0x24	; 36
    458e:	ad b7       	in	r26, 0x3d	; 61
    4590:	be b7       	in	r27, 0x3e	; 62
    4592:	12 96       	adiw	r26, 0x02	; 2
    4594:	3c 93       	st	X, r19
    4596:	2e 93       	st	-X, r18
    4598:	11 97       	sbiw	r26, 0x01	; 1
    459a:	13 83       	std	Z+3, r17	; 0x03
    459c:	02 83       	std	Z+2, r16	; 0x02
    459e:	d7 01       	movw	r26, r14
    45a0:	8d 91       	ld	r24, X+
    45a2:	9d 91       	ld	r25, X+
    45a4:	7d 01       	movw	r14, r26
    45a6:	95 83       	std	Z+5, r25	; 0x05
    45a8:	84 83       	std	Z+4, r24	; 0x04
    45aa:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						scanf("%d",&stop);
				    break;
					
					case (1):
						ee24xx_read_bytes(0, sizeof(int16)*10, (uint8 *)memory1);
						for (i=0; i< 10;i++)
    45ae:	0f 5f       	subi	r16, 0xFF	; 255
    45b0:	1f 4f       	sbci	r17, 0xFF	; 255
    45b2:	ed b7       	in	r30, 0x3d	; 61
    45b4:	fe b7       	in	r31, 0x3e	; 62
    45b6:	36 96       	adiw	r30, 0x06	; 6
    45b8:	0f b6       	in	r0, 0x3f	; 63
    45ba:	f8 94       	cli
    45bc:	fe bf       	out	0x3e, r31	; 62
    45be:	0f be       	out	0x3f, r0	; 63
    45c0:	ed bf       	out	0x3d, r30	; 61
    45c2:	0a 30       	cpi	r16, 0x0A	; 10
    45c4:	11 05       	cpc	r17, r1
    45c6:	d9 f6       	brne	.-74     	; 0x457e <__stack+0x237f>
    45c8:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__stack+0x2cf>
						}
						scanf("%d",&stop);
				    break;
					
					case (2):
						fprintf_P(stdout,PSTR("Digite el ID de la Pose que Desea Encontrar. \n"));
    45cc:	00 d0       	rcall	.+0      	; 0x45ce <__stack+0x23cf>
    45ce:	00 d0       	rcall	.+0      	; 0x45d0 <__stack+0x23d1>
    45d0:	80 91 d0 79 	lds	r24, 0x79D0
    45d4:	90 91 d1 79 	lds	r25, 0x79D1
    45d8:	ad b7       	in	r26, 0x3d	; 61
    45da:	be b7       	in	r27, 0x3e	; 62
    45dc:	12 96       	adiw	r26, 0x02	; 2
    45de:	9c 93       	st	X, r25
    45e0:	8e 93       	st	-X, r24
    45e2:	11 97       	sbiw	r26, 0x01	; 1
    45e4:	8f ec       	ldi	r24, 0xCF	; 207
    45e6:	95 e0       	ldi	r25, 0x05	; 5
    45e8:	14 96       	adiw	r26, 0x04	; 4
    45ea:	9c 93       	st	X, r25
    45ec:	8e 93       	st	-X, r24
    45ee:	13 97       	sbiw	r26, 0x03	; 3
    45f0:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d", &id);
    45f4:	2c e1       	ldi	r18, 0x1C	; 28
    45f6:	32 e2       	ldi	r19, 0x22	; 34
    45f8:	ed b7       	in	r30, 0x3d	; 61
    45fa:	fe b7       	in	r31, 0x3e	; 62
    45fc:	32 83       	std	Z+2, r19	; 0x02
    45fe:	21 83       	std	Z+1, r18	; 0x01
    4600:	ce 01       	movw	r24, r28
    4602:	49 96       	adiw	r24, 0x19	; 25
    4604:	94 83       	std	Z+4, r25	; 0x04
    4606:	83 83       	std	Z+3, r24	; 0x03
    4608:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						Addr= Found_Id (id);
    460c:	0f 90       	pop	r0
    460e:	0f 90       	pop	r0
    4610:	0f 90       	pop	r0
    4612:	0f 90       	pop	r0
    4614:	89 8d       	ldd	r24, Y+25	; 0x19
    4616:	9a 8d       	ldd	r25, Y+26	; 0x1a
    4618:	0e 94 82 8b 	call	0x11704	; 0x11704 <Found_Id>
    461c:	9b 01       	movw	r18, r22
    461e:	ac 01       	movw	r20, r24
						if(Addr>=0)
    4620:	77 fd       	sbrc	r23, 7
    4622:	1f c0       	rjmp	.+62     	; 0x4662 <__stack+0x2463>
							printf("La pose %d tiene una direccion = %d \n",id,Addr);
    4624:	00 d0       	rcall	.+0      	; 0x4626 <__stack+0x2427>
    4626:	00 d0       	rcall	.+0      	; 0x4628 <__stack+0x2429>
    4628:	00 d0       	rcall	.+0      	; 0x462a <__stack+0x242b>
    462a:	ed b7       	in	r30, 0x3d	; 61
    462c:	fe b7       	in	r31, 0x3e	; 62
    462e:	31 96       	adiw	r30, 0x01	; 1
    4630:	80 ed       	ldi	r24, 0xD0	; 208
    4632:	94 e2       	ldi	r25, 0x24	; 36
    4634:	ad b7       	in	r26, 0x3d	; 61
    4636:	be b7       	in	r27, 0x3e	; 62
    4638:	12 96       	adiw	r26, 0x02	; 2
    463a:	9c 93       	st	X, r25
    463c:	8e 93       	st	-X, r24
    463e:	11 97       	sbiw	r26, 0x01	; 1
    4640:	89 8d       	ldd	r24, Y+25	; 0x19
    4642:	9a 8d       	ldd	r25, Y+26	; 0x1a
    4644:	93 83       	std	Z+3, r25	; 0x03
    4646:	82 83       	std	Z+2, r24	; 0x02
    4648:	35 83       	std	Z+5, r19	; 0x05
    464a:	24 83       	std	Z+4, r18	; 0x04
    464c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    4650:	ed b7       	in	r30, 0x3d	; 61
    4652:	fe b7       	in	r31, 0x3e	; 62
    4654:	36 96       	adiw	r30, 0x06	; 6
    4656:	0f b6       	in	r0, 0x3f	; 63
    4658:	f8 94       	cli
    465a:	fe bf       	out	0x3e, r31	; 62
    465c:	0f be       	out	0x3f, r0	; 63
    465e:	ed bf       	out	0x3d, r30	; 61
    4660:	22 c1       	rjmp	.+580    	; 0x48a6 <__stack+0x26a7>
						else
							printf("La pose %d No existe \n",id);
    4662:	00 d0       	rcall	.+0      	; 0x4664 <__stack+0x2465>
    4664:	00 d0       	rcall	.+0      	; 0x4666 <__stack+0x2467>
    4666:	86 ef       	ldi	r24, 0xF6	; 246
    4668:	94 e2       	ldi	r25, 0x24	; 36
    466a:	ad b7       	in	r26, 0x3d	; 61
    466c:	be b7       	in	r27, 0x3e	; 62
    466e:	12 96       	adiw	r26, 0x02	; 2
    4670:	9c 93       	st	X, r25
    4672:	8e 93       	st	-X, r24
    4674:	11 97       	sbiw	r26, 0x01	; 1
    4676:	89 8d       	ldd	r24, Y+25	; 0x19
    4678:	9a 8d       	ldd	r25, Y+26	; 0x1a
    467a:	14 96       	adiw	r26, 0x04	; 4
    467c:	9c 93       	st	X, r25
    467e:	8e 93       	st	-X, r24
    4680:	13 97       	sbiw	r26, 0x03	; 3
    4682:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    4686:	0b c1       	rjmp	.+534    	; 0x489e <__stack+0x269f>
						scanf("%d",&stop);
				    break;
					
					case (3):
						BorrarEEPROM();
    4688:	0e 94 73 8a 	call	0x114e6	; 0x114e6 <BorrarEEPROM>
    468c:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
				    break;
					
					case (4):						
						Adicionar_PoseTWI(Pose);				    
    4690:	8d b7       	in	r24, 0x3d	; 61
    4692:	9e b7       	in	r25, 0x3e	; 62
    4694:	47 97       	sbiw	r24, 0x17	; 23
    4696:	0f b6       	in	r0, 0x3f	; 63
    4698:	f8 94       	cli
    469a:	9e bf       	out	0x3e, r25	; 62
    469c:	0f be       	out	0x3f, r0	; 63
    469e:	8d bf       	out	0x3d, r24	; 61
    46a0:	ad b7       	in	r26, 0x3d	; 61
    46a2:	be b7       	in	r27, 0x3e	; 62
    46a4:	11 96       	adiw	r26, 0x01	; 1
    46a6:	fe 01       	movw	r30, r28
    46a8:	e3 58       	subi	r30, 0x83	; 131
    46aa:	ff 4f       	sbci	r31, 0xFF	; 255
    46ac:	87 e1       	ldi	r24, 0x17	; 23
    46ae:	01 90       	ld	r0, Z+
    46b0:	0d 92       	st	X+, r0
    46b2:	81 50       	subi	r24, 0x01	; 1
    46b4:	e1 f7       	brne	.-8      	; 0x46ae <__stack+0x24af>
    46b6:	0e 94 ae 8a 	call	0x1155c	; 0x1155c <Adicionar_PoseTWI>
    46ba:	ad b7       	in	r26, 0x3d	; 61
    46bc:	be b7       	in	r27, 0x3e	; 62
    46be:	57 96       	adiw	r26, 0x17	; 23
    46c0:	0f b6       	in	r0, 0x3f	; 63
    46c2:	f8 94       	cli
    46c4:	be bf       	out	0x3e, r27	; 62
    46c6:	0f be       	out	0x3f, r0	; 63
    46c8:	ad bf       	out	0x3d, r26	; 61
    46ca:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
				    break;
					
					case (5):
						SobreEscribir_Pose(Pose);				    
    46ce:	ed b7       	in	r30, 0x3d	; 61
    46d0:	fe b7       	in	r31, 0x3e	; 62
    46d2:	77 97       	sbiw	r30, 0x17	; 23
    46d4:	0f b6       	in	r0, 0x3f	; 63
    46d6:	f8 94       	cli
    46d8:	fe bf       	out	0x3e, r31	; 62
    46da:	0f be       	out	0x3f, r0	; 63
    46dc:	ed bf       	out	0x3d, r30	; 61
    46de:	ad b7       	in	r26, 0x3d	; 61
    46e0:	be b7       	in	r27, 0x3e	; 62
    46e2:	11 96       	adiw	r26, 0x01	; 1
    46e4:	fe 01       	movw	r30, r28
    46e6:	e3 58       	subi	r30, 0x83	; 131
    46e8:	ff 4f       	sbci	r31, 0xFF	; 255
    46ea:	87 e1       	ldi	r24, 0x17	; 23
    46ec:	01 90       	ld	r0, Z+
    46ee:	0d 92       	st	X+, r0
    46f0:	81 50       	subi	r24, 0x01	; 1
    46f2:	e1 f7       	brne	.-8      	; 0x46ec <__stack+0x24ed>
    46f4:	0e 94 ee 8b 	call	0x117dc	; 0x117dc <SobreEscribir_Pose>
    46f8:	2d b7       	in	r18, 0x3d	; 61
    46fa:	3e b7       	in	r19, 0x3e	; 62
    46fc:	29 5e       	subi	r18, 0xE9	; 233
    46fe:	3f 4f       	sbci	r19, 0xFF	; 255
    4700:	0f b6       	in	r0, 0x3f	; 63
    4702:	f8 94       	cli
    4704:	3e bf       	out	0x3e, r19	; 62
    4706:	0f be       	out	0x3f, r0	; 63
    4708:	2d bf       	out	0x3d, r18	; 61
    470a:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
				    break;
					
					case (6):
						fprintf_P(stdout,PSTR("Digite el ID de la Pose que desea Leer . \n"));
    470e:	00 d0       	rcall	.+0      	; 0x4710 <__stack+0x2511>
    4710:	00 d0       	rcall	.+0      	; 0x4712 <__stack+0x2513>
    4712:	80 91 d0 79 	lds	r24, 0x79D0
    4716:	90 91 d1 79 	lds	r25, 0x79D1
    471a:	ad b7       	in	r26, 0x3d	; 61
    471c:	be b7       	in	r27, 0x3e	; 62
    471e:	12 96       	adiw	r26, 0x02	; 2
    4720:	9c 93       	st	X, r25
    4722:	8e 93       	st	-X, r24
    4724:	11 97       	sbiw	r26, 0x01	; 1
    4726:	84 ea       	ldi	r24, 0xA4	; 164
    4728:	95 e0       	ldi	r25, 0x05	; 5
    472a:	14 96       	adiw	r26, 0x04	; 4
    472c:	9c 93       	st	X, r25
    472e:	8e 93       	st	-X, r24
    4730:	13 97       	sbiw	r26, 0x03	; 3
    4732:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
						scanf("%d", &id_pose);
    4736:	2c e1       	ldi	r18, 0x1C	; 28
    4738:	32 e2       	ldi	r19, 0x22	; 34
    473a:	ed b7       	in	r30, 0x3d	; 61
    473c:	fe b7       	in	r31, 0x3e	; 62
    473e:	32 83       	std	Z+2, r19	; 0x02
    4740:	21 83       	std	Z+1, r18	; 0x01
    4742:	ce 01       	movw	r24, r28
    4744:	4b 96       	adiw	r24, 0x1b	; 27
    4746:	94 83       	std	Z+4, r25	; 0x04
    4748:	83 83       	std	Z+3, r24	; 0x03
    474a:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
						rv=Leer_PoseTWI(id_pose, &Pose);
    474e:	0f 90       	pop	r0
    4750:	0f 90       	pop	r0
    4752:	0f 90       	pop	r0
    4754:	0f 90       	pop	r0
    4756:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4758:	9c 8d       	ldd	r25, Y+28	; 0x1c
    475a:	be 01       	movw	r22, r28
    475c:	63 58       	subi	r22, 0x83	; 131
    475e:	7f 4f       	sbci	r23, 0xFF	; 255
    4760:	0e 94 0a 8c 	call	0x11814	; 0x11814 <Leer_PoseTWI>
						if(rv > 0)
    4764:	18 16       	cp	r1, r24
    4766:	19 06       	cpc	r1, r25
    4768:	0c f0       	brlt	.+2      	; 0x476c <__stack+0x256d>
    476a:	85 c0       	rjmp	.+266    	; 0x4876 <__stack+0x2677>
						{
							printf("Cintura	= %ld \n",Pose.Pos_Waist);
    476c:	00 d0       	rcall	.+0      	; 0x476e <__stack+0x256f>
    476e:	00 d0       	rcall	.+0      	; 0x4770 <__stack+0x2571>
    4770:	00 d0       	rcall	.+0      	; 0x4772 <__stack+0x2573>
    4772:	8d e0       	ldi	r24, 0x0D	; 13
    4774:	95 e2       	ldi	r25, 0x25	; 37
    4776:	ad b7       	in	r26, 0x3d	; 61
    4778:	be b7       	in	r27, 0x3e	; 62
    477a:	12 96       	adiw	r26, 0x02	; 2
    477c:	9c 93       	st	X, r25
    477e:	8e 93       	st	-X, r24
    4780:	11 97       	sbiw	r26, 0x01	; 1
    4782:	c1 58       	subi	r28, 0x81	; 129
    4784:	df 4f       	sbci	r29, 0xFF	; 255
    4786:	88 81       	ld	r24, Y
    4788:	99 81       	ldd	r25, Y+1	; 0x01
    478a:	aa 81       	ldd	r26, Y+2	; 0x02
    478c:	bb 81       	ldd	r27, Y+3	; 0x03
    478e:	cf 57       	subi	r28, 0x7F	; 127
    4790:	d0 40       	sbci	r29, 0x00	; 0
    4792:	ed b7       	in	r30, 0x3d	; 61
    4794:	fe b7       	in	r31, 0x3e	; 62
    4796:	83 83       	std	Z+3, r24	; 0x03
    4798:	94 83       	std	Z+4, r25	; 0x04
    479a:	a5 83       	std	Z+5, r26	; 0x05
    479c:	b6 83       	std	Z+6, r27	; 0x06
    479e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
							printf("Hombro 	= %ld \n",Pose.Pos_Shoulder);
    47a2:	8d e1       	ldi	r24, 0x1D	; 29
    47a4:	95 e2       	ldi	r25, 0x25	; 37
    47a6:	ad b7       	in	r26, 0x3d	; 61
    47a8:	be b7       	in	r27, 0x3e	; 62
    47aa:	12 96       	adiw	r26, 0x02	; 2
    47ac:	9c 93       	st	X, r25
    47ae:	8e 93       	st	-X, r24
    47b0:	11 97       	sbiw	r26, 0x01	; 1
    47b2:	cd 57       	subi	r28, 0x7D	; 125
    47b4:	df 4f       	sbci	r29, 0xFF	; 255
    47b6:	88 81       	ld	r24, Y
    47b8:	99 81       	ldd	r25, Y+1	; 0x01
    47ba:	aa 81       	ldd	r26, Y+2	; 0x02
    47bc:	bb 81       	ldd	r27, Y+3	; 0x03
    47be:	c3 58       	subi	r28, 0x83	; 131
    47c0:	d0 40       	sbci	r29, 0x00	; 0
    47c2:	ed b7       	in	r30, 0x3d	; 61
    47c4:	fe b7       	in	r31, 0x3e	; 62
    47c6:	83 83       	std	Z+3, r24	; 0x03
    47c8:	94 83       	std	Z+4, r25	; 0x04
    47ca:	a5 83       	std	Z+5, r26	; 0x05
    47cc:	b6 83       	std	Z+6, r27	; 0x06
    47ce:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
							printf("Codo 	= %ld \n",Pose.Pos_Elbow);
    47d2:	8d e2       	ldi	r24, 0x2D	; 45
    47d4:	95 e2       	ldi	r25, 0x25	; 37
    47d6:	ad b7       	in	r26, 0x3d	; 61
    47d8:	be b7       	in	r27, 0x3e	; 62
    47da:	12 96       	adiw	r26, 0x02	; 2
    47dc:	9c 93       	st	X, r25
    47de:	8e 93       	st	-X, r24
    47e0:	11 97       	sbiw	r26, 0x01	; 1
    47e2:	c9 57       	subi	r28, 0x79	; 121
    47e4:	df 4f       	sbci	r29, 0xFF	; 255
    47e6:	88 81       	ld	r24, Y
    47e8:	99 81       	ldd	r25, Y+1	; 0x01
    47ea:	aa 81       	ldd	r26, Y+2	; 0x02
    47ec:	bb 81       	ldd	r27, Y+3	; 0x03
    47ee:	c7 58       	subi	r28, 0x87	; 135
    47f0:	d0 40       	sbci	r29, 0x00	; 0
    47f2:	ed b7       	in	r30, 0x3d	; 61
    47f4:	fe b7       	in	r31, 0x3e	; 62
    47f6:	83 83       	std	Z+3, r24	; 0x03
    47f8:	94 83       	std	Z+4, r25	; 0x04
    47fa:	a5 83       	std	Z+5, r26	; 0x05
    47fc:	b6 83       	std	Z+6, r27	; 0x06
    47fe:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
							printf("Pitch 	= %ld \n",Pose.Pos_Pitch);
    4802:	8b e3       	ldi	r24, 0x3B	; 59
    4804:	95 e2       	ldi	r25, 0x25	; 37
    4806:	ad b7       	in	r26, 0x3d	; 61
    4808:	be b7       	in	r27, 0x3e	; 62
    480a:	12 96       	adiw	r26, 0x02	; 2
    480c:	9c 93       	st	X, r25
    480e:	8e 93       	st	-X, r24
    4810:	11 97       	sbiw	r26, 0x01	; 1
    4812:	c5 57       	subi	r28, 0x75	; 117
    4814:	df 4f       	sbci	r29, 0xFF	; 255
    4816:	88 81       	ld	r24, Y
    4818:	99 81       	ldd	r25, Y+1	; 0x01
    481a:	aa 81       	ldd	r26, Y+2	; 0x02
    481c:	bb 81       	ldd	r27, Y+3	; 0x03
    481e:	cb 58       	subi	r28, 0x8B	; 139
    4820:	d0 40       	sbci	r29, 0x00	; 0
    4822:	ed b7       	in	r30, 0x3d	; 61
    4824:	fe b7       	in	r31, 0x3e	; 62
    4826:	83 83       	std	Z+3, r24	; 0x03
    4828:	94 83       	std	Z+4, r25	; 0x04
    482a:	a5 83       	std	Z+5, r26	; 0x05
    482c:	b6 83       	std	Z+6, r27	; 0x06
    482e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
							printf("Roll 	= %ld \n",Pose.Pos_Roll);
    4832:	8a e4       	ldi	r24, 0x4A	; 74
    4834:	95 e2       	ldi	r25, 0x25	; 37
    4836:	ad b7       	in	r26, 0x3d	; 61
    4838:	be b7       	in	r27, 0x3e	; 62
    483a:	12 96       	adiw	r26, 0x02	; 2
    483c:	9c 93       	st	X, r25
    483e:	8e 93       	st	-X, r24
    4840:	11 97       	sbiw	r26, 0x01	; 1
    4842:	c1 57       	subi	r28, 0x71	; 113
    4844:	df 4f       	sbci	r29, 0xFF	; 255
    4846:	88 81       	ld	r24, Y
    4848:	99 81       	ldd	r25, Y+1	; 0x01
    484a:	aa 81       	ldd	r26, Y+2	; 0x02
    484c:	bb 81       	ldd	r27, Y+3	; 0x03
    484e:	cf 58       	subi	r28, 0x8F	; 143
    4850:	d0 40       	sbci	r29, 0x00	; 0
    4852:	ed b7       	in	r30, 0x3d	; 61
    4854:	fe b7       	in	r31, 0x3e	; 62
    4856:	83 83       	std	Z+3, r24	; 0x03
    4858:	94 83       	std	Z+4, r25	; 0x04
    485a:	a5 83       	std	Z+5, r26	; 0x05
    485c:	b6 83       	std	Z+6, r27	; 0x06
    485e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    4862:	2d b7       	in	r18, 0x3d	; 61
    4864:	3e b7       	in	r19, 0x3e	; 62
    4866:	2a 5f       	subi	r18, 0xFA	; 250
    4868:	3f 4f       	sbci	r19, 0xFF	; 255
    486a:	0f b6       	in	r0, 0x3f	; 63
    486c:	f8 94       	cli
    486e:	3e bf       	out	0x3e, r19	; 62
    4870:	0f be       	out	0x3f, r0	; 63
    4872:	2d bf       	out	0x3d, r18	; 61
    4874:	18 c0       	rjmp	.+48     	; 0x48a6 <__stack+0x26a7>
						}
						else
							fprintf_P(stdout,PSTR("La Pose no Existe \n"));
    4876:	00 d0       	rcall	.+0      	; 0x4878 <__stack+0x2679>
    4878:	00 d0       	rcall	.+0      	; 0x487a <__stack+0x267b>
    487a:	80 91 d0 79 	lds	r24, 0x79D0
    487e:	90 91 d1 79 	lds	r25, 0x79D1
    4882:	ad b7       	in	r26, 0x3d	; 61
    4884:	be b7       	in	r27, 0x3e	; 62
    4886:	12 96       	adiw	r26, 0x02	; 2
    4888:	9c 93       	st	X, r25
    488a:	8e 93       	st	-X, r24
    488c:	11 97       	sbiw	r26, 0x01	; 1
    488e:	80 e9       	ldi	r24, 0x90	; 144
    4890:	95 e0       	ldi	r25, 0x05	; 5
    4892:	14 96       	adiw	r26, 0x04	; 4
    4894:	9c 93       	st	X, r25
    4896:	8e 93       	st	-X, r24
    4898:	13 97       	sbiw	r26, 0x03	; 3
    489a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    489e:	0f 90       	pop	r0
    48a0:	0f 90       	pop	r0
    48a2:	0f 90       	pop	r0
    48a4:	0f 90       	pop	r0
							scanf("%d",&stop);				
    48a6:	00 d0       	rcall	.+0      	; 0x48a8 <__stack+0x26a9>
    48a8:	00 d0       	rcall	.+0      	; 0x48aa <__stack+0x26ab>
    48aa:	2c e1       	ldi	r18, 0x1C	; 28
    48ac:	32 e2       	ldi	r19, 0x22	; 34
    48ae:	ed b7       	in	r30, 0x3d	; 61
    48b0:	fe b7       	in	r31, 0x3e	; 62
    48b2:	32 83       	std	Z+2, r19	; 0x02
    48b4:	21 83       	std	Z+1, r18	; 0x01
    48b6:	ce 01       	movw	r24, r28
    48b8:	07 96       	adiw	r24, 0x07	; 7
    48ba:	94 83       	std	Z+4, r25	; 0x04
    48bc:	83 83       	std	Z+3, r24	; 0x03
    48be:	0c 94 77 12 	jmp	0x24ee	; 0x24ee <__stack+0x2ef>
				    break;
					
					case (7):
						rv= return_id_vector();
    48c2:	0e 94 ff 8a 	call	0x115fe	; 0x115fe <return_id_vector>
						if(rv==1)
    48c6:	81 30       	cpi	r24, 0x01	; 1
    48c8:	91 05       	cpc	r25, r1
    48ca:	c9 f5       	brne	.+114    	; 0x493e <__stack+0x273f>
						{
							num_datos=id_vector[0];
    48cc:	e0 91 c2 79 	lds	r30, 0x79C2
    48d0:	f0 91 c3 79 	lds	r31, 0x79C3
    48d4:	e0 80       	ld	r14, Z
    48d6:	f1 80       	ldd	r15, Z+1	; 0x01
    48d8:	00 e0       	ldi	r16, 0x00	; 0
    48da:	10 e0       	ldi	r17, 0x00	; 0
    48dc:	2b c0       	rjmp	.+86     	; 0x4934 <__stack+0x2735>
							
							for(i=0;i<num_datos;i++)
							{
								printf("id_vector[%d] en Jarboter.c => %d \n",i,id_vector[i]);
    48de:	00 d0       	rcall	.+0      	; 0x48e0 <__stack+0x26e1>
    48e0:	00 d0       	rcall	.+0      	; 0x48e2 <__stack+0x26e3>
    48e2:	00 d0       	rcall	.+0      	; 0x48e4 <__stack+0x26e5>
    48e4:	ad b7       	in	r26, 0x3d	; 61
    48e6:	be b7       	in	r27, 0x3e	; 62
    48e8:	11 96       	adiw	r26, 0x01	; 1
    48ea:	28 e5       	ldi	r18, 0x58	; 88
    48ec:	35 e2       	ldi	r19, 0x25	; 37
    48ee:	ed b7       	in	r30, 0x3d	; 61
    48f0:	fe b7       	in	r31, 0x3e	; 62
    48f2:	32 83       	std	Z+2, r19	; 0x02
    48f4:	21 83       	std	Z+1, r18	; 0x01
    48f6:	13 96       	adiw	r26, 0x03	; 3
    48f8:	1c 93       	st	X, r17
    48fa:	0e 93       	st	-X, r16
    48fc:	12 97       	sbiw	r26, 0x02	; 2
    48fe:	c8 01       	movw	r24, r16
    4900:	88 0f       	add	r24, r24
    4902:	99 1f       	adc	r25, r25
    4904:	e0 91 c2 79 	lds	r30, 0x79C2
    4908:	f0 91 c3 79 	lds	r31, 0x79C3
    490c:	e8 0f       	add	r30, r24
    490e:	f9 1f       	adc	r31, r25
    4910:	80 81       	ld	r24, Z
    4912:	91 81       	ldd	r25, Z+1	; 0x01
    4914:	15 96       	adiw	r26, 0x05	; 5
    4916:	9c 93       	st	X, r25
    4918:	8e 93       	st	-X, r24
    491a:	14 97       	sbiw	r26, 0x04	; 4
    491c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						rv= return_id_vector();
						if(rv==1)
						{
							num_datos=id_vector[0];
							
							for(i=0;i<num_datos;i++)
    4920:	0f 5f       	subi	r16, 0xFF	; 255
    4922:	1f 4f       	sbci	r17, 0xFF	; 255
    4924:	8d b7       	in	r24, 0x3d	; 61
    4926:	9e b7       	in	r25, 0x3e	; 62
    4928:	06 96       	adiw	r24, 0x06	; 6
    492a:	0f b6       	in	r0, 0x3f	; 63
    492c:	f8 94       	cli
    492e:	9e bf       	out	0x3e, r25	; 62
    4930:	0f be       	out	0x3f, r0	; 63
    4932:	8d bf       	out	0x3d, r24	; 61
    4934:	0e 15       	cp	r16, r14
    4936:	1f 05       	cpc	r17, r15
    4938:	94 f2       	brlt	.-92     	; 0x48de <__stack+0x26df>
    493a:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__stack+0x2cf>
							{
								printf("id_vector[%d] en Jarboter.c => %d \n",i,id_vector[i]);
							}
						}
						if(rv==0)
    493e:	00 97       	sbiw	r24, 0x00	; 0
    4940:	31 f4       	brne	.+12     	; 0x494e <__stack+0x274f>
							printf("No Existen Poses en jarboter.c \n");
    4942:	8c e7       	ldi	r24, 0x7C	; 124
    4944:	95 e2       	ldi	r25, 0x25	; 37
    4946:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
    494a:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__stack+0x2cf>
						
						if(rv==-1)
    494e:	8f 5f       	subi	r24, 0xFF	; 255
    4950:	9f 4f       	sbci	r25, 0xFF	; 255
    4952:	11 f0       	breq	.+4      	; 0x4958 <__stack+0x2759>
    4954:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__stack+0x2cf>
							fprintf_P(stdout,PSTR("Error en la Transmision I2C en Jarboter.c \n"));
    4958:	00 d0       	rcall	.+0      	; 0x495a <__stack+0x275b>
    495a:	00 d0       	rcall	.+0      	; 0x495c <__stack+0x275d>
    495c:	80 91 d0 79 	lds	r24, 0x79D0
    4960:	90 91 d1 79 	lds	r25, 0x79D1
    4964:	ed b7       	in	r30, 0x3d	; 61
    4966:	fe b7       	in	r31, 0x3e	; 62
    4968:	92 83       	std	Z+2, r25	; 0x02
    496a:	81 83       	std	Z+1, r24	; 0x01
    496c:	84 e6       	ldi	r24, 0x64	; 100
    496e:	95 e0       	ldi	r25, 0x05	; 5
    4970:	94 83       	std	Z+4, r25	; 0x04
    4972:	83 83       	std	Z+3, r24	; 0x03
    4974:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    4978:	0f 90       	pop	r0
    497a:	0f 90       	pop	r0
    497c:	0f 90       	pop	r0
    497e:	0f 90       	pop	r0
    4980:	0c 94 67 12 	jmp	0x24ce	; 0x24ce <__stack+0x2cf>
					break;
				}			
			break;			
			
			case (5)://FUNCIONES DE TRAZO E IMPRESION DE VARIABLES
				fprintf_P(stdout,PSTR("0. Configurar Trazo \n"));
    4984:	00 d0       	rcall	.+0      	; 0x4986 <__stack+0x2787>
    4986:	00 d0       	rcall	.+0      	; 0x4988 <__stack+0x2789>
    4988:	80 91 d0 79 	lds	r24, 0x79D0
    498c:	90 91 d1 79 	lds	r25, 0x79D1
    4990:	ad b7       	in	r26, 0x3d	; 61
    4992:	be b7       	in	r27, 0x3e	; 62
    4994:	12 96       	adiw	r26, 0x02	; 2
    4996:	9c 93       	st	X, r25
    4998:	8e 93       	st	-X, r24
    499a:	11 97       	sbiw	r26, 0x01	; 1
    499c:	8e e4       	ldi	r24, 0x4E	; 78
    499e:	95 e0       	ldi	r25, 0x05	; 5
    49a0:	14 96       	adiw	r26, 0x04	; 4
    49a2:	9c 93       	st	X, r25
    49a4:	8e 93       	st	-X, r24
    49a6:	13 97       	sbiw	r26, 0x03	; 3
    49a8:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("1. Imprimir Trazo \n"));
    49ac:	80 91 d0 79 	lds	r24, 0x79D0
    49b0:	90 91 d1 79 	lds	r25, 0x79D1
    49b4:	ed b7       	in	r30, 0x3d	; 61
    49b6:	fe b7       	in	r31, 0x3e	; 62
    49b8:	92 83       	std	Z+2, r25	; 0x02
    49ba:	81 83       	std	Z+1, r24	; 0x01
    49bc:	8a e3       	ldi	r24, 0x3A	; 58
    49be:	95 e0       	ldi	r25, 0x05	; 5
    49c0:	94 83       	std	Z+4, r25	; 0x04
    49c2:	83 83       	std	Z+3, r24	; 0x03
    49c4:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("Otra Opcion: Salir SubMenu \n"));
    49c8:	80 91 d0 79 	lds	r24, 0x79D0
    49cc:	90 91 d1 79 	lds	r25, 0x79D1
    49d0:	ad b7       	in	r26, 0x3d	; 61
    49d2:	be b7       	in	r27, 0x3e	; 62
    49d4:	12 96       	adiw	r26, 0x02	; 2
    49d6:	9c 93       	st	X, r25
    49d8:	8e 93       	st	-X, r24
    49da:	11 97       	sbiw	r26, 0x01	; 1
    49dc:	8d e1       	ldi	r24, 0x1D	; 29
    49de:	95 e0       	ldi	r25, 0x05	; 5
    49e0:	14 96       	adiw	r26, 0x04	; 4
    49e2:	9c 93       	st	X, r25
    49e4:	8e 93       	st	-X, r24
    49e6:	13 97       	sbiw	r26, 0x03	; 3
    49e8:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				scanf("%d",&submenu);
    49ec:	2c e1       	ldi	r18, 0x1C	; 28
    49ee:	32 e2       	ldi	r19, 0x22	; 34
    49f0:	ed b7       	in	r30, 0x3d	; 61
    49f2:	fe b7       	in	r31, 0x3e	; 62
    49f4:	32 83       	std	Z+2, r19	; 0x02
    49f6:	21 83       	std	Z+1, r18	; 0x01
    49f8:	ce 01       	movw	r24, r28
    49fa:	05 96       	adiw	r24, 0x05	; 5
    49fc:	94 83       	std	Z+4, r25	; 0x04
    49fe:	83 83       	std	Z+3, r24	; 0x03
    4a00:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
				
				if(submenu >=0 && submenu<=1)
    4a04:	0f 90       	pop	r0
    4a06:	0f 90       	pop	r0
    4a08:	0f 90       	pop	r0
    4a0a:	0f 90       	pop	r0
    4a0c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a0e:	9e 81       	ldd	r25, Y+6	; 0x06
    4a10:	02 97       	sbiw	r24, 0x02	; 2
    4a12:	08 f0       	brcs	.+2      	; 0x4a16 <__stack+0x2817>
    4a14:	76 c0       	rjmp	.+236    	; 0x4b02 <__stack+0x2903>
				{				
					fprintf_P(stdout,PSTR("Digite la articulacion \n"));
    4a16:	00 d0       	rcall	.+0      	; 0x4a18 <__stack+0x2819>
    4a18:	00 d0       	rcall	.+0      	; 0x4a1a <__stack+0x281b>
    4a1a:	80 91 d0 79 	lds	r24, 0x79D0
    4a1e:	90 91 d1 79 	lds	r25, 0x79D1
    4a22:	ad b7       	in	r26, 0x3d	; 61
    4a24:	be b7       	in	r27, 0x3e	; 62
    4a26:	12 96       	adiw	r26, 0x02	; 2
    4a28:	9c 93       	st	X, r25
    4a2a:	8e 93       	st	-X, r24
    4a2c:	11 97       	sbiw	r26, 0x01	; 1
    4a2e:	84 e0       	ldi	r24, 0x04	; 4
    4a30:	95 e0       	ldi	r25, 0x05	; 5
    4a32:	14 96       	adiw	r26, 0x04	; 4
    4a34:	9c 93       	st	X, r25
    4a36:	8e 93       	st	-X, r24
    4a38:	13 97       	sbiw	r26, 0x03	; 3
    4a3a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("0. Cintura. \n"));
    4a3e:	80 91 d0 79 	lds	r24, 0x79D0
    4a42:	90 91 d1 79 	lds	r25, 0x79D1
    4a46:	ed b7       	in	r30, 0x3d	; 61
    4a48:	fe b7       	in	r31, 0x3e	; 62
    4a4a:	92 83       	std	Z+2, r25	; 0x02
    4a4c:	81 83       	std	Z+1, r24	; 0x01
    4a4e:	86 ef       	ldi	r24, 0xF6	; 246
    4a50:	94 e0       	ldi	r25, 0x04	; 4
    4a52:	94 83       	std	Z+4, r25	; 0x04
    4a54:	83 83       	std	Z+3, r24	; 0x03
    4a56:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("1. Hombro. \n"));
    4a5a:	80 91 d0 79 	lds	r24, 0x79D0
    4a5e:	90 91 d1 79 	lds	r25, 0x79D1
    4a62:	ad b7       	in	r26, 0x3d	; 61
    4a64:	be b7       	in	r27, 0x3e	; 62
    4a66:	12 96       	adiw	r26, 0x02	; 2
    4a68:	9c 93       	st	X, r25
    4a6a:	8e 93       	st	-X, r24
    4a6c:	11 97       	sbiw	r26, 0x01	; 1
    4a6e:	89 ee       	ldi	r24, 0xE9	; 233
    4a70:	94 e0       	ldi	r25, 0x04	; 4
    4a72:	14 96       	adiw	r26, 0x04	; 4
    4a74:	9c 93       	st	X, r25
    4a76:	8e 93       	st	-X, r24
    4a78:	13 97       	sbiw	r26, 0x03	; 3
    4a7a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("2. Codo. \n"));
    4a7e:	80 91 d0 79 	lds	r24, 0x79D0
    4a82:	90 91 d1 79 	lds	r25, 0x79D1
    4a86:	ed b7       	in	r30, 0x3d	; 61
    4a88:	fe b7       	in	r31, 0x3e	; 62
    4a8a:	92 83       	std	Z+2, r25	; 0x02
    4a8c:	81 83       	std	Z+1, r24	; 0x01
    4a8e:	8e ed       	ldi	r24, 0xDE	; 222
    4a90:	94 e0       	ldi	r25, 0x04	; 4
    4a92:	94 83       	std	Z+4, r25	; 0x04
    4a94:	83 83       	std	Z+3, r24	; 0x03
    4a96:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("3. Pitch. \n"));		
    4a9a:	80 91 d0 79 	lds	r24, 0x79D0
    4a9e:	90 91 d1 79 	lds	r25, 0x79D1
    4aa2:	ad b7       	in	r26, 0x3d	; 61
    4aa4:	be b7       	in	r27, 0x3e	; 62
    4aa6:	12 96       	adiw	r26, 0x02	; 2
    4aa8:	9c 93       	st	X, r25
    4aaa:	8e 93       	st	-X, r24
    4aac:	11 97       	sbiw	r26, 0x01	; 1
    4aae:	82 ed       	ldi	r24, 0xD2	; 210
    4ab0:	94 e0       	ldi	r25, 0x04	; 4
    4ab2:	14 96       	adiw	r26, 0x04	; 4
    4ab4:	9c 93       	st	X, r25
    4ab6:	8e 93       	st	-X, r24
    4ab8:	13 97       	sbiw	r26, 0x03	; 3
    4aba:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("4.Roll. \n"));
    4abe:	80 91 d0 79 	lds	r24, 0x79D0
    4ac2:	90 91 d1 79 	lds	r25, 0x79D1
    4ac6:	ed b7       	in	r30, 0x3d	; 61
    4ac8:	fe b7       	in	r31, 0x3e	; 62
    4aca:	92 83       	std	Z+2, r25	; 0x02
    4acc:	81 83       	std	Z+1, r24	; 0x01
    4ace:	88 ec       	ldi	r24, 0xC8	; 200
    4ad0:	94 e0       	ldi	r25, 0x04	; 4
    4ad2:	94 83       	std	Z+4, r25	; 0x04
    4ad4:	83 83       	std	Z+3, r24	; 0x03
    4ad6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%d",&articulacion);
    4ada:	ec e1       	ldi	r30, 0x1C	; 28
    4adc:	f2 e2       	ldi	r31, 0x22	; 34
    4ade:	ad b7       	in	r26, 0x3d	; 61
    4ae0:	be b7       	in	r27, 0x3e	; 62
    4ae2:	12 96       	adiw	r26, 0x02	; 2
    4ae4:	fc 93       	st	X, r31
    4ae6:	ee 93       	st	-X, r30
    4ae8:	11 97       	sbiw	r26, 0x01	; 1
    4aea:	ce 01       	movw	r24, r28
    4aec:	03 96       	adiw	r24, 0x03	; 3
    4aee:	14 96       	adiw	r26, 0x04	; 4
    4af0:	9c 93       	st	X, r25
    4af2:	8e 93       	st	-X, r24
    4af4:	13 97       	sbiw	r26, 0x03	; 3
    4af6:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
    4afa:	0f 90       	pop	r0
    4afc:	0f 90       	pop	r0
    4afe:	0f 90       	pop	r0
    4b00:	0f 90       	pop	r0
				}	
				
				
				switch (submenu)
    4b02:	8d 81       	ldd	r24, Y+5	; 0x05
    4b04:	9e 81       	ldd	r25, Y+6	; 0x06
    4b06:	00 97       	sbiw	r24, 0x00	; 0
    4b08:	29 f0       	breq	.+10     	; 0x4b14 <__stack+0x2915>
    4b0a:	01 97       	sbiw	r24, 0x01	; 1
    4b0c:	11 f0       	breq	.+4      	; 0x4b12 <__stack+0x2913>
    4b0e:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
    4b12:	06 c0       	rjmp	.+12     	; 0x4b20 <__stack+0x2921>
				{
					case (0):
						SetupSingleAxisTrace(articulacion);
    4b14:	8b 81       	ldd	r24, Y+3	; 0x03
    4b16:	9c 81       	ldd	r25, Y+4	; 0x04
    4b18:	0e 94 73 48 	call	0x90e6	; 0x90e6 <SetupSingleAxisTrace>
    4b1c:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
				    break;	
					
					case (1):
						DisplayTraceResults(articulacion,4);
    4b20:	8b 81       	ldd	r24, Y+3	; 0x03
    4b22:	9c 81       	ldd	r25, Y+4	; 0x04
    4b24:	64 e0       	ldi	r22, 0x04	; 4
    4b26:	0e 94 85 47 	call	0x8f0a	; 0x8f0a <DisplayTraceResults>
    4b2a:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
					break;
				}				
			break;
			
			case(6)://RESET EVENT STATUS REGISTER DE TODOS LOS EJES
				Reset_Even_Status_Register();
    4b2e:	0e 94 65 41 	call	0x82ca	; 0x82ca <Reset_Even_Status_Register>
    4b32:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
			break;
			
			case(7)://FUNCIONES DE GRIPPER
				fprintf_P(stdout,PSTR("0. Abrir Gripper \n"));
    4b36:	00 d0       	rcall	.+0      	; 0x4b38 <__stack+0x2939>
    4b38:	00 d0       	rcall	.+0      	; 0x4b3a <__stack+0x293b>
    4b3a:	80 91 d0 79 	lds	r24, 0x79D0
    4b3e:	90 91 d1 79 	lds	r25, 0x79D1
    4b42:	ad b7       	in	r26, 0x3d	; 61
    4b44:	be b7       	in	r27, 0x3e	; 62
    4b46:	12 96       	adiw	r26, 0x02	; 2
    4b48:	9c 93       	st	X, r25
    4b4a:	8e 93       	st	-X, r24
    4b4c:	11 97       	sbiw	r26, 0x01	; 1
    4b4e:	85 eb       	ldi	r24, 0xB5	; 181
    4b50:	94 e0       	ldi	r25, 0x04	; 4
    4b52:	14 96       	adiw	r26, 0x04	; 4
    4b54:	9c 93       	st	X, r25
    4b56:	8e 93       	st	-X, r24
    4b58:	13 97       	sbiw	r26, 0x03	; 3
    4b5a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("1. Cerrar Gripper \n"));
    4b5e:	80 91 d0 79 	lds	r24, 0x79D0
    4b62:	90 91 d1 79 	lds	r25, 0x79D1
    4b66:	ed b7       	in	r30, 0x3d	; 61
    4b68:	fe b7       	in	r31, 0x3e	; 62
    4b6a:	92 83       	std	Z+2, r25	; 0x02
    4b6c:	81 83       	std	Z+1, r24	; 0x01
    4b6e:	81 ea       	ldi	r24, 0xA1	; 161
    4b70:	94 e0       	ldi	r25, 0x04	; 4
    4b72:	94 83       	std	Z+4, r25	; 0x04
    4b74:	83 83       	std	Z+3, r24	; 0x03
    4b76:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("Otra Opcion: Salir SubMenu \n"));
    4b7a:	80 91 d0 79 	lds	r24, 0x79D0
    4b7e:	90 91 d1 79 	lds	r25, 0x79D1
    4b82:	ad b7       	in	r26, 0x3d	; 61
    4b84:	be b7       	in	r27, 0x3e	; 62
    4b86:	12 96       	adiw	r26, 0x02	; 2
    4b88:	9c 93       	st	X, r25
    4b8a:	8e 93       	st	-X, r24
    4b8c:	11 97       	sbiw	r26, 0x01	; 1
    4b8e:	84 e8       	ldi	r24, 0x84	; 132
    4b90:	94 e0       	ldi	r25, 0x04	; 4
    4b92:	14 96       	adiw	r26, 0x04	; 4
    4b94:	9c 93       	st	X, r25
    4b96:	8e 93       	st	-X, r24
    4b98:	13 97       	sbiw	r26, 0x03	; 3
    4b9a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				scanf("%d",&submenu);
    4b9e:	2c e1       	ldi	r18, 0x1C	; 28
    4ba0:	32 e2       	ldi	r19, 0x22	; 34
    4ba2:	ed b7       	in	r30, 0x3d	; 61
    4ba4:	fe b7       	in	r31, 0x3e	; 62
    4ba6:	32 83       	std	Z+2, r19	; 0x02
    4ba8:	21 83       	std	Z+1, r18	; 0x01
    4baa:	ce 01       	movw	r24, r28
    4bac:	05 96       	adiw	r24, 0x05	; 5
    4bae:	94 83       	std	Z+4, r25	; 0x04
    4bb0:	83 83       	std	Z+3, r24	; 0x03
    4bb2:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
				
				switch (submenu)
    4bb6:	0f 90       	pop	r0
    4bb8:	0f 90       	pop	r0
    4bba:	0f 90       	pop	r0
    4bbc:	0f 90       	pop	r0
    4bbe:	8d 81       	ldd	r24, Y+5	; 0x05
    4bc0:	9e 81       	ldd	r25, Y+6	; 0x06
    4bc2:	00 97       	sbiw	r24, 0x00	; 0
    4bc4:	29 f0       	breq	.+10     	; 0x4bd0 <__stack+0x29d1>
    4bc6:	01 97       	sbiw	r24, 0x01	; 1
    4bc8:	11 f0       	breq	.+4      	; 0x4bce <__stack+0x29cf>
    4bca:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
    4bce:	04 c0       	rjmp	.+8      	; 0x4bd8 <__stack+0x29d9>
				{
					case (0):
						openGripper(); 
    4bd0:	0e 94 60 91 	call	0x122c0	; 0x122c0 <openGripper>
    4bd4:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
				    break;	
					
					case (1):
						closeGripper();
    4bd8:	0e 94 91 91 	call	0x12322	; 0x12322 <closeGripper>
    4bdc:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
					break;
				}				
			break;
			
			case(8)://Funciones para DEBUG
				fprintf_P(stdout,PSTR("0. Debug Signal Status \n"));
    4be0:	00 d0       	rcall	.+0      	; 0x4be2 <__stack+0x29e3>
    4be2:	00 d0       	rcall	.+0      	; 0x4be4 <__stack+0x29e5>
    4be4:	80 91 d0 79 	lds	r24, 0x79D0
    4be8:	90 91 d1 79 	lds	r25, 0x79D1
    4bec:	ad b7       	in	r26, 0x3d	; 61
    4bee:	be b7       	in	r27, 0x3e	; 62
    4bf0:	12 96       	adiw	r26, 0x02	; 2
    4bf2:	9c 93       	st	X, r25
    4bf4:	8e 93       	st	-X, r24
    4bf6:	11 97       	sbiw	r26, 0x01	; 1
    4bf8:	8b e6       	ldi	r24, 0x6B	; 107
    4bfa:	94 e0       	ldi	r25, 0x04	; 4
    4bfc:	14 96       	adiw	r26, 0x04	; 4
    4bfe:	9c 93       	st	X, r25
    4c00:	8e 93       	st	-X, r24
    4c02:	13 97       	sbiw	r26, 0x03	; 3
    4c04:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("1. Hallar Limites (grados) del Robot \n"));
    4c08:	80 91 d0 79 	lds	r24, 0x79D0
    4c0c:	90 91 d1 79 	lds	r25, 0x79D1
    4c10:	ed b7       	in	r30, 0x3d	; 61
    4c12:	fe b7       	in	r31, 0x3e	; 62
    4c14:	92 83       	std	Z+2, r25	; 0x02
    4c16:	81 83       	std	Z+1, r24	; 0x01
    4c18:	84 e4       	ldi	r24, 0x44	; 68
    4c1a:	94 e0       	ldi	r25, 0x04	; 4
    4c1c:	94 83       	std	Z+4, r25	; 0x04
    4c1e:	83 83       	std	Z+3, r24	; 0x03
    4c20:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("2. Hallar en Numero de Pasos por Revolucion del Motor \n"));
    4c24:	80 91 d0 79 	lds	r24, 0x79D0
    4c28:	90 91 d1 79 	lds	r25, 0x79D1
    4c2c:	ad b7       	in	r26, 0x3d	; 61
    4c2e:	be b7       	in	r27, 0x3e	; 62
    4c30:	12 96       	adiw	r26, 0x02	; 2
    4c32:	9c 93       	st	X, r25
    4c34:	8e 93       	st	-X, r24
    4c36:	11 97       	sbiw	r26, 0x01	; 1
    4c38:	8c e0       	ldi	r24, 0x0C	; 12
    4c3a:	94 e0       	ldi	r25, 0x04	; 4
    4c3c:	14 96       	adiw	r26, 0x04	; 4
    4c3e:	9c 93       	st	X, r25
    4c40:	8e 93       	st	-X, r24
    4c42:	13 97       	sbiw	r26, 0x03	; 3
    4c44:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("3. Search Home Roll Positive \n"));
    4c48:	80 91 d0 79 	lds	r24, 0x79D0
    4c4c:	90 91 d1 79 	lds	r25, 0x79D1
    4c50:	ed b7       	in	r30, 0x3d	; 61
    4c52:	fe b7       	in	r31, 0x3e	; 62
    4c54:	92 83       	std	Z+2, r25	; 0x02
    4c56:	81 83       	std	Z+1, r24	; 0x01
    4c58:	8d ee       	ldi	r24, 0xED	; 237
    4c5a:	93 e0       	ldi	r25, 0x03	; 3
    4c5c:	94 83       	std	Z+4, r25	; 0x04
    4c5e:	83 83       	std	Z+3, r24	; 0x03
    4c60:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				fprintf_P(stdout,PSTR("Otra Opcion: Salir SubMenu \n"));
    4c64:	80 91 d0 79 	lds	r24, 0x79D0
    4c68:	90 91 d1 79 	lds	r25, 0x79D1
    4c6c:	ad b7       	in	r26, 0x3d	; 61
    4c6e:	be b7       	in	r27, 0x3e	; 62
    4c70:	12 96       	adiw	r26, 0x02	; 2
    4c72:	9c 93       	st	X, r25
    4c74:	8e 93       	st	-X, r24
    4c76:	11 97       	sbiw	r26, 0x01	; 1
    4c78:	80 ed       	ldi	r24, 0xD0	; 208
    4c7a:	93 e0       	ldi	r25, 0x03	; 3
    4c7c:	14 96       	adiw	r26, 0x04	; 4
    4c7e:	9c 93       	st	X, r25
    4c80:	8e 93       	st	-X, r24
    4c82:	13 97       	sbiw	r26, 0x03	; 3
    4c84:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
				scanf("%d",&submenu);		
    4c88:	2c e1       	ldi	r18, 0x1C	; 28
    4c8a:	32 e2       	ldi	r19, 0x22	; 34
    4c8c:	ed b7       	in	r30, 0x3d	; 61
    4c8e:	fe b7       	in	r31, 0x3e	; 62
    4c90:	32 83       	std	Z+2, r19	; 0x02
    4c92:	21 83       	std	Z+1, r18	; 0x01
    4c94:	ce 01       	movw	r24, r28
    4c96:	05 96       	adiw	r24, 0x05	; 5
    4c98:	94 83       	std	Z+4, r25	; 0x04
    4c9a:	83 83       	std	Z+3, r24	; 0x03
    4c9c:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
				
				if(submenu >=0 && submenu<=2)
    4ca0:	0f 90       	pop	r0
    4ca2:	0f 90       	pop	r0
    4ca4:	0f 90       	pop	r0
    4ca6:	0f 90       	pop	r0
    4ca8:	8d 81       	ldd	r24, Y+5	; 0x05
    4caa:	9e 81       	ldd	r25, Y+6	; 0x06
    4cac:	03 97       	sbiw	r24, 0x03	; 3
    4cae:	08 f0       	brcs	.+2      	; 0x4cb2 <__stack+0x2ab3>
    4cb0:	84 c0       	rjmp	.+264    	; 0x4dba <__stack+0x2bbb>
				{	
					fprintf_P(stdout,PSTR("Digite Articulacion : \n"));
    4cb2:	00 d0       	rcall	.+0      	; 0x4cb4 <__stack+0x2ab5>
    4cb4:	00 d0       	rcall	.+0      	; 0x4cb6 <__stack+0x2ab7>
    4cb6:	80 91 d0 79 	lds	r24, 0x79D0
    4cba:	90 91 d1 79 	lds	r25, 0x79D1
    4cbe:	ad b7       	in	r26, 0x3d	; 61
    4cc0:	be b7       	in	r27, 0x3e	; 62
    4cc2:	12 96       	adiw	r26, 0x02	; 2
    4cc4:	9c 93       	st	X, r25
    4cc6:	8e 93       	st	-X, r24
    4cc8:	11 97       	sbiw	r26, 0x01	; 1
    4cca:	88 eb       	ldi	r24, 0xB8	; 184
    4ccc:	93 e0       	ldi	r25, 0x03	; 3
    4cce:	14 96       	adiw	r26, 0x04	; 4
    4cd0:	9c 93       	st	X, r25
    4cd2:	8e 93       	st	-X, r24
    4cd4:	13 97       	sbiw	r26, 0x03	; 3
    4cd6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("0. Cintura. \n"));
    4cda:	80 91 d0 79 	lds	r24, 0x79D0
    4cde:	90 91 d1 79 	lds	r25, 0x79D1
    4ce2:	ed b7       	in	r30, 0x3d	; 61
    4ce4:	fe b7       	in	r31, 0x3e	; 62
    4ce6:	92 83       	std	Z+2, r25	; 0x02
    4ce8:	81 83       	std	Z+1, r24	; 0x01
    4cea:	8a ea       	ldi	r24, 0xAA	; 170
    4cec:	93 e0       	ldi	r25, 0x03	; 3
    4cee:	94 83       	std	Z+4, r25	; 0x04
    4cf0:	83 83       	std	Z+3, r24	; 0x03
    4cf2:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("1. Hombro. \n"));
    4cf6:	80 91 d0 79 	lds	r24, 0x79D0
    4cfa:	90 91 d1 79 	lds	r25, 0x79D1
    4cfe:	ad b7       	in	r26, 0x3d	; 61
    4d00:	be b7       	in	r27, 0x3e	; 62
    4d02:	12 96       	adiw	r26, 0x02	; 2
    4d04:	9c 93       	st	X, r25
    4d06:	8e 93       	st	-X, r24
    4d08:	11 97       	sbiw	r26, 0x01	; 1
    4d0a:	8d e9       	ldi	r24, 0x9D	; 157
    4d0c:	93 e0       	ldi	r25, 0x03	; 3
    4d0e:	14 96       	adiw	r26, 0x04	; 4
    4d10:	9c 93       	st	X, r25
    4d12:	8e 93       	st	-X, r24
    4d14:	13 97       	sbiw	r26, 0x03	; 3
    4d16:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("2. Codo. \n"));
    4d1a:	80 91 d0 79 	lds	r24, 0x79D0
    4d1e:	90 91 d1 79 	lds	r25, 0x79D1
    4d22:	ed b7       	in	r30, 0x3d	; 61
    4d24:	fe b7       	in	r31, 0x3e	; 62
    4d26:	92 83       	std	Z+2, r25	; 0x02
    4d28:	81 83       	std	Z+1, r24	; 0x01
    4d2a:	82 e9       	ldi	r24, 0x92	; 146
    4d2c:	93 e0       	ldi	r25, 0x03	; 3
    4d2e:	94 83       	std	Z+4, r25	; 0x04
    4d30:	83 83       	std	Z+3, r24	; 0x03
    4d32:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("3. Pitch. \n"));
    4d36:	80 91 d0 79 	lds	r24, 0x79D0
    4d3a:	90 91 d1 79 	lds	r25, 0x79D1
    4d3e:	ad b7       	in	r26, 0x3d	; 61
    4d40:	be b7       	in	r27, 0x3e	; 62
    4d42:	12 96       	adiw	r26, 0x02	; 2
    4d44:	9c 93       	st	X, r25
    4d46:	8e 93       	st	-X, r24
    4d48:	11 97       	sbiw	r26, 0x01	; 1
    4d4a:	86 e8       	ldi	r24, 0x86	; 134
    4d4c:	93 e0       	ldi	r25, 0x03	; 3
    4d4e:	14 96       	adiw	r26, 0x04	; 4
    4d50:	9c 93       	st	X, r25
    4d52:	8e 93       	st	-X, r24
    4d54:	13 97       	sbiw	r26, 0x03	; 3
    4d56:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("4.Roll. \n"));
    4d5a:	80 91 d0 79 	lds	r24, 0x79D0
    4d5e:	90 91 d1 79 	lds	r25, 0x79D1
    4d62:	ed b7       	in	r30, 0x3d	; 61
    4d64:	fe b7       	in	r31, 0x3e	; 62
    4d66:	92 83       	std	Z+2, r25	; 0x02
    4d68:	81 83       	std	Z+1, r24	; 0x01
    4d6a:	8c e7       	ldi	r24, 0x7C	; 124
    4d6c:	93 e0       	ldi	r25, 0x03	; 3
    4d6e:	94 83       	std	Z+4, r25	; 0x04
    4d70:	83 83       	std	Z+3, r24	; 0x03
    4d72:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					fprintf_P(stdout,PSTR("Otra Opcion: Salir SubMenu \n"));
    4d76:	80 91 d0 79 	lds	r24, 0x79D0
    4d7a:	90 91 d1 79 	lds	r25, 0x79D1
    4d7e:	ad b7       	in	r26, 0x3d	; 61
    4d80:	be b7       	in	r27, 0x3e	; 62
    4d82:	12 96       	adiw	r26, 0x02	; 2
    4d84:	9c 93       	st	X, r25
    4d86:	8e 93       	st	-X, r24
    4d88:	11 97       	sbiw	r26, 0x01	; 1
    4d8a:	8f e5       	ldi	r24, 0x5F	; 95
    4d8c:	93 e0       	ldi	r25, 0x03	; 3
    4d8e:	14 96       	adiw	r26, 0x04	; 4
    4d90:	9c 93       	st	X, r25
    4d92:	8e 93       	st	-X, r24
    4d94:	13 97       	sbiw	r26, 0x03	; 3
    4d96:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
					scanf("%d",&articulacion);
    4d9a:	2c e1       	ldi	r18, 0x1C	; 28
    4d9c:	32 e2       	ldi	r19, 0x22	; 34
    4d9e:	ed b7       	in	r30, 0x3d	; 61
    4da0:	fe b7       	in	r31, 0x3e	; 62
    4da2:	32 83       	std	Z+2, r19	; 0x02
    4da4:	21 83       	std	Z+1, r18	; 0x01
    4da6:	ce 01       	movw	r24, r28
    4da8:	03 96       	adiw	r24, 0x03	; 3
    4daa:	94 83       	std	Z+4, r25	; 0x04
    4dac:	83 83       	std	Z+3, r24	; 0x03
    4dae:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
    4db2:	0f 90       	pop	r0
    4db4:	0f 90       	pop	r0
    4db6:	0f 90       	pop	r0
    4db8:	0f 90       	pop	r0
				}				
				
				switch (submenu)
    4dba:	8d 81       	ldd	r24, Y+5	; 0x05
    4dbc:	9e 81       	ldd	r25, Y+6	; 0x06
    4dbe:	81 30       	cpi	r24, 0x01	; 1
    4dc0:	91 05       	cpc	r25, r1
    4dc2:	b1 f0       	breq	.+44     	; 0x4df0 <__stack+0x2bf1>
    4dc4:	82 30       	cpi	r24, 0x02	; 2
    4dc6:	91 05       	cpc	r25, r1
    4dc8:	24 f4       	brge	.+8      	; 0x4dd2 <__stack+0x2bd3>
    4dca:	89 2b       	or	r24, r25
    4dcc:	51 f0       	breq	.+20     	; 0x4de2 <__stack+0x2be3>
    4dce:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
    4dd2:	82 30       	cpi	r24, 0x02	; 2
    4dd4:	91 05       	cpc	r25, r1
    4dd6:	89 f0       	breq	.+34     	; 0x4dfa <__stack+0x2bfb>
    4dd8:	03 97       	sbiw	r24, 0x03	; 3
    4dda:	11 f0       	breq	.+4      	; 0x4de0 <__stack+0x2be1>
    4ddc:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
    4de0:	12 c0       	rjmp	.+36     	; 0x4e06 <__stack+0x2c07>
				{
					case (0):
						while(1)
						{
							PMDCheckSignalStatus(articulacion,no_imprimir);
    4de2:	8b 81       	ldd	r24, Y+3	; 0x03
    4de4:	9c 81       	ldd	r25, Y+4	; 0x04
    4de6:	6d ee       	ldi	r22, 0xED	; 237
    4de8:	7f ef       	ldi	r23, 0xFF	; 255
    4dea:	0e 94 37 6e 	call	0xdc6e	; 0xdc6e <PMDCheckSignalStatus>
    4dee:	f9 cf       	rjmp	.-14     	; 0x4de2 <__stack+0x2be3>
				    break;
					
				    case (1):
						while(1)
						{
							rangosrobot(articulacion);
    4df0:	8b 81       	ldd	r24, Y+3	; 0x03
    4df2:	9c 81       	ldd	r25, Y+4	; 0x04
    4df4:	0e 94 95 4c 	call	0x992a	; 0x992a <rangosrobot>
    4df8:	fb cf       	rjmp	.-10     	; 0x4df0 <__stack+0x2bf1>
						}
				    break;
					
					case (2):
						StepCalibration(articulacion);
    4dfa:	8b 81       	ldd	r24, Y+3	; 0x03
    4dfc:	9c 81       	ldd	r25, Y+4	; 0x04
    4dfe:	0e 94 ee 4e 	call	0x9ddc	; 0x9ddc <StepCalibration>
    4e02:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
				    break;
					
					case (3):
						search_home_roll_positive(&home);
    4e06:	ce 01       	movw	r24, r28
    4e08:	8f 5a       	subi	r24, 0xAF	; 175
    4e0a:	9f 4f       	sbci	r25, 0xFF	; 255
    4e0c:	0e 94 f7 50 	call	0xa1ee	; 0xa1ee <search_home_roll_positive>
    4e10:	0c 94 a5 0d 	jmp	0x1b4a	; 0x1b4a <main+0x14a>
					break;
				}
			break;
			
			default://PARADA SUAVE DE TODOS LOS EJES
				sofstop();
    4e14:	0e 94 76 4d 	call	0x9aec	; 0x9aec <sofstop>
				fprintf_P(stdout,PSTR("Se ha realizado una parada suave en todos los Ejes \n"));
    4e18:	00 d0       	rcall	.+0      	; 0x4e1a <__stack+0x2c1b>
    4e1a:	00 d0       	rcall	.+0      	; 0x4e1c <__stack+0x2c1d>
    4e1c:	80 91 d0 79 	lds	r24, 0x79D0
    4e20:	90 91 d1 79 	lds	r25, 0x79D1
    4e24:	ad b7       	in	r26, 0x3d	; 61
    4e26:	be b7       	in	r27, 0x3e	; 62
    4e28:	12 96       	adiw	r26, 0x02	; 2
    4e2a:	9c 93       	st	X, r25
    4e2c:	8e 93       	st	-X, r24
    4e2e:	11 97       	sbiw	r26, 0x01	; 1
    4e30:	8a e2       	ldi	r24, 0x2A	; 42
    4e32:	93 e0       	ldi	r25, 0x03	; 3
    4e34:	14 96       	adiw	r26, 0x04	; 4
    4e36:	9c 93       	st	X, r25
    4e38:	8e 93       	st	-X, r24
    4e3a:	13 97       	sbiw	r26, 0x03	; 3
    4e3c:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    4e40:	0c 94 79 12 	jmp	0x24f2	; 0x24f2 <__stack+0x2f3>

00004e44 <__vector_35>:
	}

}

ISR(TIMER3_OVF_vect)
{
    4e44:	1f 92       	push	r1
    4e46:	0f 92       	push	r0
    4e48:	0f b6       	in	r0, 0x3f	; 63
    4e4a:	0f 92       	push	r0
    4e4c:	0b b6       	in	r0, 0x3b	; 59
    4e4e:	0f 92       	push	r0
    4e50:	11 24       	eor	r1, r1
    4e52:	2f 93       	push	r18
    4e54:	3f 93       	push	r19
    4e56:	4f 93       	push	r20
    4e58:	5f 93       	push	r21
    4e5a:	6f 93       	push	r22
    4e5c:	7f 93       	push	r23
    4e5e:	8f 93       	push	r24
    4e60:	9f 93       	push	r25
    4e62:	af 93       	push	r26
    4e64:	bf 93       	push	r27
    4e66:	ef 93       	push	r30
    4e68:	ff 93       	push	r31
	
	if (activo_alarma)
    4e6a:	80 91 5c 78 	lds	r24, 0x785C
    4e6e:	90 91 5d 78 	lds	r25, 0x785D
    4e72:	89 2b       	or	r24, r25
    4e74:	09 f4       	brne	.+2      	; 0x4e78 <__vector_35+0x34>
    4e76:	73 c0       	rjmp	.+230    	; 0x4f5e <__vector_35+0x11a>
	{
		
		cont_alarma++;
    4e78:	80 91 ac 74 	lds	r24, 0x74AC
    4e7c:	90 91 ad 74 	lds	r25, 0x74AD
    4e80:	01 96       	adiw	r24, 0x01	; 1
    4e82:	90 93 ad 74 	sts	0x74AD, r25
    4e86:	80 93 ac 74 	sts	0x74AC, r24
		
		if(cont_alarma==3) //30 seg aprox
    4e8a:	03 97       	sbiw	r24, 0x03	; 3
    4e8c:	09 f0       	breq	.+2      	; 0x4e90 <__vector_35+0x4c>
    4e8e:	67 c0       	rjmp	.+206    	; 0x4f5e <__vector_35+0x11a>
		{
			cont_alarma=0;
    4e90:	10 92 ad 74 	sts	0x74AD, r1
    4e94:	10 92 ac 74 	sts	0x74AC, r1
			Read_SR(&SR_RTC);
    4e98:	85 e5       	ldi	r24, 0x55	; 85
    4e9a:	98 e7       	ldi	r25, 0x78	; 120
    4e9c:	0e 94 a5 88 	call	0x1114a	; 0x1114a <Read_SR>
			if((SR_RTC & AL0Mask)!=0)
    4ea0:	80 91 55 78 	lds	r24, 0x7855
    4ea4:	85 ff       	sbrs	r24, 5
    4ea6:	5b c0       	rjmp	.+182    	; 0x4f5e <__vector_35+0x11a>
			{
				activo_alarma=0;
    4ea8:	10 92 5d 78 	sts	0x785D, r1
    4eac:	10 92 5c 78 	sts	0x785C, r1
				buzzer(1); 
    4eb0:	81 e0       	ldi	r24, 0x01	; 1
    4eb2:	90 e0       	ldi	r25, 0x00	; 0
    4eb4:	0e 94 41 8d 	call	0x11a82	; 0x11a82 <buzzer>
				fprintf(stderr,"Se produjo Alarma \n");	
    4eb8:	60 91 d2 79 	lds	r22, 0x79D2
    4ebc:	70 91 d3 79 	lds	r23, 0x79D3
    4ec0:	8c e9       	ldi	r24, 0x9C	; 156
    4ec2:	95 e2       	ldi	r25, 0x25	; 37
    4ec4:	0e 94 9e 9f 	call	0x13f3c	; 0x13f3c <fputs>
				Read_Fecha(&Fecha);
    4ec8:	87 e6       	ldi	r24, 0x67	; 103
    4eca:	98 e7       	ldi	r25, 0x78	; 120
    4ecc:	0e 94 b4 88 	call	0x11168	; 0x11168 <Read_Fecha>
				if((Fecha.hr & 0x20) != 0)	
    4ed0:	80 91 69 78 	lds	r24, 0x7869
    4ed4:	90 e0       	ldi	r25, 0x00	; 0
    4ed6:	20 91 d2 79 	lds	r18, 0x79D2
    4eda:	30 91 d3 79 	lds	r19, 0x79D3
    4ede:	ac 01       	movw	r20, r24
    4ee0:	4f 71       	andi	r20, 0x1F	; 31
    4ee2:	50 70       	andi	r21, 0x00	; 0
    4ee4:	85 ff       	sbrs	r24, 5
    4ee6:	14 c0       	rjmp	.+40     	; 0x4f10 <__vector_35+0xcc>
					fprintf(stderr,"a las %x:%x:%x PM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    4ee8:	8d b7       	in	r24, 0x3d	; 61
    4eea:	9e b7       	in	r25, 0x3e	; 62
    4eec:	0a 97       	sbiw	r24, 0x0a	; 10
    4eee:	0f b6       	in	r0, 0x3f	; 63
    4ef0:	f8 94       	cli
    4ef2:	9e bf       	out	0x3e, r25	; 62
    4ef4:	0f be       	out	0x3f, r0	; 63
    4ef6:	8d bf       	out	0x3d, r24	; 61
    4ef8:	ed b7       	in	r30, 0x3d	; 61
    4efa:	fe b7       	in	r31, 0x3e	; 62
    4efc:	31 96       	adiw	r30, 0x01	; 1
    4efe:	ad b7       	in	r26, 0x3d	; 61
    4f00:	be b7       	in	r27, 0x3e	; 62
    4f02:	12 96       	adiw	r26, 0x02	; 2
    4f04:	3c 93       	st	X, r19
    4f06:	2e 93       	st	-X, r18
    4f08:	11 97       	sbiw	r26, 0x01	; 1
    4f0a:	80 eb       	ldi	r24, 0xB0	; 176
    4f0c:	95 e2       	ldi	r25, 0x25	; 37
    4f0e:	11 c0       	rjmp	.+34     	; 0x4f32 <__vector_35+0xee>
				else 
					fprintf(stderr,"a las %x:%x:%x AM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    4f10:	ad b7       	in	r26, 0x3d	; 61
    4f12:	be b7       	in	r27, 0x3e	; 62
    4f14:	1a 97       	sbiw	r26, 0x0a	; 10
    4f16:	0f b6       	in	r0, 0x3f	; 63
    4f18:	f8 94       	cli
    4f1a:	be bf       	out	0x3e, r27	; 62
    4f1c:	0f be       	out	0x3f, r0	; 63
    4f1e:	ad bf       	out	0x3d, r26	; 61
    4f20:	ed b7       	in	r30, 0x3d	; 61
    4f22:	fe b7       	in	r31, 0x3e	; 62
    4f24:	31 96       	adiw	r30, 0x01	; 1
    4f26:	12 96       	adiw	r26, 0x02	; 2
    4f28:	3c 93       	st	X, r19
    4f2a:	2e 93       	st	-X, r18
    4f2c:	11 97       	sbiw	r26, 0x01	; 1
    4f2e:	84 ec       	ldi	r24, 0xC4	; 196
    4f30:	95 e2       	ldi	r25, 0x25	; 37
    4f32:	93 83       	std	Z+3, r25	; 0x03
    4f34:	82 83       	std	Z+2, r24	; 0x02
    4f36:	55 83       	std	Z+5, r21	; 0x05
    4f38:	44 83       	std	Z+4, r20	; 0x04
    4f3a:	80 91 68 78 	lds	r24, 0x7868
    4f3e:	86 83       	std	Z+6, r24	; 0x06
    4f40:	17 82       	std	Z+7, r1	; 0x07
    4f42:	80 91 67 78 	lds	r24, 0x7867
    4f46:	80 87       	std	Z+8, r24	; 0x08
    4f48:	11 86       	std	Z+9, r1	; 0x09
    4f4a:	0e 94 43 9f 	call	0x13e86	; 0x13e86 <fprintf>
    4f4e:	8d b7       	in	r24, 0x3d	; 61
    4f50:	9e b7       	in	r25, 0x3e	; 62
    4f52:	0a 96       	adiw	r24, 0x0a	; 10
    4f54:	0f b6       	in	r0, 0x3f	; 63
    4f56:	f8 94       	cli
    4f58:	9e bf       	out	0x3e, r25	; 62
    4f5a:	0f be       	out	0x3f, r0	; 63
    4f5c:	8d bf       	out	0x3d, r24	; 61
			}
		}	
	}

}
    4f5e:	ff 91       	pop	r31
    4f60:	ef 91       	pop	r30
    4f62:	bf 91       	pop	r27
    4f64:	af 91       	pop	r26
    4f66:	9f 91       	pop	r25
    4f68:	8f 91       	pop	r24
    4f6a:	7f 91       	pop	r23
    4f6c:	6f 91       	pop	r22
    4f6e:	5f 91       	pop	r21
    4f70:	4f 91       	pop	r20
    4f72:	3f 91       	pop	r19
    4f74:	2f 91       	pop	r18
    4f76:	0f 90       	pop	r0
    4f78:	0b be       	out	0x3b, r0	; 59
    4f7a:	0f 90       	pop	r0
    4f7c:	0f be       	out	0x3f, r0	; 63
    4f7e:	0f 90       	pop	r0
    4f80:	1f 90       	pop	r1
    4f82:	18 95       	reti

00004f84 <__vector_20>:
	printf("PMD2 PRODUJO INTERRUPCION \n"); 
	InterruptHandling_chipset2();
}

ISR(TIMER1_OVF_vect)
{
    4f84:	1f 92       	push	r1
    4f86:	0f 92       	push	r0
    4f88:	0f b6       	in	r0, 0x3f	; 63
    4f8a:	0f 92       	push	r0
    4f8c:	0b b6       	in	r0, 0x3b	; 59
    4f8e:	0f 92       	push	r0
    4f90:	11 24       	eor	r1, r1
    4f92:	2f 93       	push	r18
    4f94:	3f 93       	push	r19
    4f96:	4f 93       	push	r20
    4f98:	5f 93       	push	r21
    4f9a:	6f 93       	push	r22
    4f9c:	7f 93       	push	r23
    4f9e:	8f 93       	push	r24
    4fa0:	9f 93       	push	r25
    4fa2:	af 93       	push	r26
    4fa4:	bf 93       	push	r27
    4fa6:	ef 93       	push	r30
    4fa8:	ff 93       	push	r31
	conta++;
    4faa:	80 91 aa 74 	lds	r24, 0x74AA
    4fae:	90 91 ab 74 	lds	r25, 0x74AB
    4fb2:	01 96       	adiw	r24, 0x01	; 1
    4fb4:	90 93 ab 74 	sts	0x74AB, r25
    4fb8:	80 93 aa 74 	sts	0x74AA, r24
	
	if (conta==35)  //5min
    4fbc:	80 91 aa 74 	lds	r24, 0x74AA
    4fc0:	90 91 ab 74 	lds	r25, 0x74AB
    4fc4:	83 97       	sbiw	r24, 0x23	; 35
    4fc6:	09 f0       	breq	.+2      	; 0x4fca <__vector_20+0x46>
    4fc8:	57 c0       	rjmp	.+174    	; 0x5078 <__vector_20+0xf4>
	{
		fprintf(stderr, "Robot Jarboter Controller.\n");
    4fca:	60 91 d2 79 	lds	r22, 0x79D2
    4fce:	70 91 d3 79 	lds	r23, 0x79D3
    4fd2:	80 e0       	ldi	r24, 0x00	; 0
    4fd4:	92 e2       	ldi	r25, 0x22	; 34
    4fd6:	0e 94 9e 9f 	call	0x13f3c	; 0x13f3c <fputs>
		Read_Fecha(&Fecha);
    4fda:	87 e6       	ldi	r24, 0x67	; 103
    4fdc:	98 e7       	ldi	r25, 0x78	; 120
    4fde:	0e 94 b4 88 	call	0x11168	; 0x11168 <Read_Fecha>
		if((Fecha.hr & 0x20) != 0)	
    4fe2:	80 91 69 78 	lds	r24, 0x7869
    4fe6:	90 e0       	ldi	r25, 0x00	; 0
    4fe8:	20 91 d2 79 	lds	r18, 0x79D2
    4fec:	30 91 d3 79 	lds	r19, 0x79D3
    4ff0:	ac 01       	movw	r20, r24
    4ff2:	4f 71       	andi	r20, 0x1F	; 31
    4ff4:	50 70       	andi	r21, 0x00	; 0
    4ff6:	85 ff       	sbrs	r24, 5
    4ff8:	14 c0       	rjmp	.+40     	; 0x5022 <__vector_20+0x9e>
			fprintf(stderr,"Son las %x:%x:%x PM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    4ffa:	8d b7       	in	r24, 0x3d	; 61
    4ffc:	9e b7       	in	r25, 0x3e	; 62
    4ffe:	0a 97       	sbiw	r24, 0x0a	; 10
    5000:	0f b6       	in	r0, 0x3f	; 63
    5002:	f8 94       	cli
    5004:	9e bf       	out	0x3e, r25	; 62
    5006:	0f be       	out	0x3f, r0	; 63
    5008:	8d bf       	out	0x3d, r24	; 61
    500a:	ed b7       	in	r30, 0x3d	; 61
    500c:	fe b7       	in	r31, 0x3e	; 62
    500e:	31 96       	adiw	r30, 0x01	; 1
    5010:	ad b7       	in	r26, 0x3d	; 61
    5012:	be b7       	in	r27, 0x3e	; 62
    5014:	12 96       	adiw	r26, 0x02	; 2
    5016:	3c 93       	st	X, r19
    5018:	2e 93       	st	-X, r18
    501a:	11 97       	sbiw	r26, 0x01	; 1
    501c:	8b e4       	ldi	r24, 0x4B	; 75
    501e:	94 e2       	ldi	r25, 0x24	; 36
    5020:	11 c0       	rjmp	.+34     	; 0x5044 <__vector_20+0xc0>
		else 
			fprintf(stderr,"Son las %x:%x:%x AM \n",(Fecha.hr & 0x1F),Fecha.mn,Fecha.sc);
    5022:	ad b7       	in	r26, 0x3d	; 61
    5024:	be b7       	in	r27, 0x3e	; 62
    5026:	1a 97       	sbiw	r26, 0x0a	; 10
    5028:	0f b6       	in	r0, 0x3f	; 63
    502a:	f8 94       	cli
    502c:	be bf       	out	0x3e, r27	; 62
    502e:	0f be       	out	0x3f, r0	; 63
    5030:	ad bf       	out	0x3d, r26	; 61
    5032:	ed b7       	in	r30, 0x3d	; 61
    5034:	fe b7       	in	r31, 0x3e	; 62
    5036:	31 96       	adiw	r30, 0x01	; 1
    5038:	12 96       	adiw	r26, 0x02	; 2
    503a:	3c 93       	st	X, r19
    503c:	2e 93       	st	-X, r18
    503e:	11 97       	sbiw	r26, 0x01	; 1
    5040:	81 e6       	ldi	r24, 0x61	; 97
    5042:	94 e2       	ldi	r25, 0x24	; 36
    5044:	93 83       	std	Z+3, r25	; 0x03
    5046:	82 83       	std	Z+2, r24	; 0x02
    5048:	55 83       	std	Z+5, r21	; 0x05
    504a:	44 83       	std	Z+4, r20	; 0x04
    504c:	80 91 68 78 	lds	r24, 0x7868
    5050:	86 83       	std	Z+6, r24	; 0x06
    5052:	17 82       	std	Z+7, r1	; 0x07
    5054:	80 91 67 78 	lds	r24, 0x7867
    5058:	80 87       	std	Z+8, r24	; 0x08
    505a:	11 86       	std	Z+9, r1	; 0x09
    505c:	0e 94 43 9f 	call	0x13e86	; 0x13e86 <fprintf>
    5060:	8d b7       	in	r24, 0x3d	; 61
    5062:	9e b7       	in	r25, 0x3e	; 62
    5064:	0a 96       	adiw	r24, 0x0a	; 10
    5066:	0f b6       	in	r0, 0x3f	; 63
    5068:	f8 94       	cli
    506a:	9e bf       	out	0x3e, r25	; 62
    506c:	0f be       	out	0x3f, r0	; 63
    506e:	8d bf       	out	0x3d, r24	; 61
		
		conta=0;
    5070:	10 92 ab 74 	sts	0x74AB, r1
    5074:	10 92 aa 74 	sts	0x74AA, r1
	}

}
    5078:	ff 91       	pop	r31
    507a:	ef 91       	pop	r30
    507c:	bf 91       	pop	r27
    507e:	af 91       	pop	r26
    5080:	9f 91       	pop	r25
    5082:	8f 91       	pop	r24
    5084:	7f 91       	pop	r23
    5086:	6f 91       	pop	r22
    5088:	5f 91       	pop	r21
    508a:	4f 91       	pop	r20
    508c:	3f 91       	pop	r19
    508e:	2f 91       	pop	r18
    5090:	0f 90       	pop	r0
    5092:	0b be       	out	0x3b, r0	; 59
    5094:	0f 90       	pop	r0
    5096:	0f be       	out	0x3f, r0	; 63
    5098:	0f 90       	pop	r0
    509a:	1f 90       	pop	r1
    509c:	18 95       	reti

0000509e <__vector_6>:
	printf("PMD1 PRODUJO INTERRUPCION \n"); 
	InterruptHandling_chipset1();
}

ISR(INT5_vect)
{
    509e:	1f 92       	push	r1
    50a0:	0f 92       	push	r0
    50a2:	0f b6       	in	r0, 0x3f	; 63
    50a4:	0f 92       	push	r0
    50a6:	0b b6       	in	r0, 0x3b	; 59
    50a8:	0f 92       	push	r0
    50aa:	11 24       	eor	r1, r1
    50ac:	2f 93       	push	r18
    50ae:	3f 93       	push	r19
    50b0:	4f 93       	push	r20
    50b2:	5f 93       	push	r21
    50b4:	6f 93       	push	r22
    50b6:	7f 93       	push	r23
    50b8:	8f 93       	push	r24
    50ba:	9f 93       	push	r25
    50bc:	af 93       	push	r26
    50be:	bf 93       	push	r27
    50c0:	ef 93       	push	r30
    50c2:	ff 93       	push	r31
	printf("PMD2 PRODUJO INTERRUPCION \n"); 
    50c4:	88 ed       	ldi	r24, 0xD8	; 216
    50c6:	95 e2       	ldi	r25, 0x25	; 37
    50c8:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	InterruptHandling_chipset2();
    50cc:	0e 94 2b 75 	call	0xea56	; 0xea56 <InterruptHandling_chipset2>
}
    50d0:	ff 91       	pop	r31
    50d2:	ef 91       	pop	r30
    50d4:	bf 91       	pop	r27
    50d6:	af 91       	pop	r26
    50d8:	9f 91       	pop	r25
    50da:	8f 91       	pop	r24
    50dc:	7f 91       	pop	r23
    50de:	6f 91       	pop	r22
    50e0:	5f 91       	pop	r21
    50e2:	4f 91       	pop	r20
    50e4:	3f 91       	pop	r19
    50e6:	2f 91       	pop	r18
    50e8:	0f 90       	pop	r0
    50ea:	0b be       	out	0x3b, r0	; 59
    50ec:	0f 90       	pop	r0
    50ee:	0f be       	out	0x3f, r0	; 63
    50f0:	0f 90       	pop	r0
    50f2:	1f 90       	pop	r1
    50f4:	18 95       	reti

000050f6 <__vector_5>:
	exit(1);
}


ISR(INT4_vect)
{
    50f6:	1f 92       	push	r1
    50f8:	0f 92       	push	r0
    50fa:	0f b6       	in	r0, 0x3f	; 63
    50fc:	0f 92       	push	r0
    50fe:	0b b6       	in	r0, 0x3b	; 59
    5100:	0f 92       	push	r0
    5102:	11 24       	eor	r1, r1
    5104:	2f 93       	push	r18
    5106:	3f 93       	push	r19
    5108:	4f 93       	push	r20
    510a:	5f 93       	push	r21
    510c:	6f 93       	push	r22
    510e:	7f 93       	push	r23
    5110:	8f 93       	push	r24
    5112:	9f 93       	push	r25
    5114:	af 93       	push	r26
    5116:	bf 93       	push	r27
    5118:	ef 93       	push	r30
    511a:	ff 93       	push	r31
	printf("PMD1 PRODUJO INTERRUPCION \n"); 
    511c:	83 ef       	ldi	r24, 0xF3	; 243
    511e:	95 e2       	ldi	r25, 0x25	; 37
    5120:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	InterruptHandling_chipset1();
    5124:	0e 94 8d 75 	call	0xeb1a	; 0xeb1a <InterruptHandling_chipset1>
}
    5128:	ff 91       	pop	r31
    512a:	ef 91       	pop	r30
    512c:	bf 91       	pop	r27
    512e:	af 91       	pop	r26
    5130:	9f 91       	pop	r25
    5132:	8f 91       	pop	r24
    5134:	7f 91       	pop	r23
    5136:	6f 91       	pop	r22
    5138:	5f 91       	pop	r21
    513a:	4f 91       	pop	r20
    513c:	3f 91       	pop	r19
    513e:	2f 91       	pop	r18
    5140:	0f 90       	pop	r0
    5142:	0b be       	out	0x3b, r0	; 59
    5144:	0f 90       	pop	r0
    5146:	0f be       	out	0x3f, r0	; 63
    5148:	0f 90       	pop	r0
    514a:	1f 90       	pop	r1
    514c:	18 95       	reti

0000514e <__vector_3>:
	tAlarm alarma;
	int16 sbib,bsw,dtr,atr,al,im,ask,scn;
	int16 activo_alarma,cont_alarma=0;

ISR(INT2_vect)
{
    514e:	1f 92       	push	r1
    5150:	0f 92       	push	r0
    5152:	0f b6       	in	r0, 0x3f	; 63
    5154:	0f 92       	push	r0
    5156:	0b b6       	in	r0, 0x3b	; 59
    5158:	0f 92       	push	r0
    515a:	11 24       	eor	r1, r1
    515c:	0f 93       	push	r16
    515e:	1f 93       	push	r17
    5160:	2f 93       	push	r18
    5162:	3f 93       	push	r19
    5164:	4f 93       	push	r20
    5166:	5f 93       	push	r21
    5168:	6f 93       	push	r22
    516a:	7f 93       	push	r23
    516c:	8f 93       	push	r24
    516e:	9f 93       	push	r25
    5170:	af 93       	push	r26
    5172:	bf 93       	push	r27
    5174:	ef 93       	push	r30
    5176:	ff 93       	push	r31
	TIM16_ReadTCNTn(); //coloco a cero el timer 1
    5178:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <TIM16_ReadTCNTn>
	abruptstop();      //Paro los motores
    517c:	0e 94 51 4d 	call	0x9aa2	; 0x9aa2 <abruptstop>
	tiempo_motor_stop=TIM16_ReadTCNTn(); //Retorno el tiempo 
    5180:	0e 94 e7 3b 	call	0x77ce	; 0x77ce <TIM16_ReadTCNTn>
    5184:	90 93 57 78 	sts	0x7857, r25
    5188:	80 93 56 78 	sts	0x7856, r24
	buzzer(1);	
    518c:	81 e0       	ldi	r24, 0x01	; 1
    518e:	90 e0       	ldi	r25, 0x00	; 0
    5190:	0e 94 41 8d 	call	0x11a82	; 0x11a82 <buzzer>
	printf("Se ha efectuadado una parada Abrupta en los motores. \n");
    5194:	8e e0       	ldi	r24, 0x0E	; 14
    5196:	96 e2       	ldi	r25, 0x26	; 38
    5198:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	printf("Registro Timer=%x Tiempo=%f seg.\n",tiempo_motor_stop,(double)tiempo_motor_stop*0.000128);
    519c:	40 91 56 78 	lds	r20, 0x7856
    51a0:	50 91 57 78 	lds	r21, 0x7857
    51a4:	60 91 56 78 	lds	r22, 0x7856
    51a8:	70 91 57 78 	lds	r23, 0x7857
    51ac:	8d b7       	in	r24, 0x3d	; 61
    51ae:	9e b7       	in	r25, 0x3e	; 62
    51b0:	08 97       	sbiw	r24, 0x08	; 8
    51b2:	0f b6       	in	r0, 0x3f	; 63
    51b4:	f8 94       	cli
    51b6:	9e bf       	out	0x3e, r25	; 62
    51b8:	0f be       	out	0x3f, r0	; 63
    51ba:	8d bf       	out	0x3d, r24	; 61
    51bc:	0d b7       	in	r16, 0x3d	; 61
    51be:	1e b7       	in	r17, 0x3e	; 62
    51c0:	0f 5f       	subi	r16, 0xFF	; 255
    51c2:	1f 4f       	sbci	r17, 0xFF	; 255
    51c4:	24 e4       	ldi	r18, 0x44	; 68
    51c6:	36 e2       	ldi	r19, 0x26	; 38
    51c8:	ed b7       	in	r30, 0x3d	; 61
    51ca:	fe b7       	in	r31, 0x3e	; 62
    51cc:	32 83       	std	Z+2, r19	; 0x02
    51ce:	21 83       	std	Z+1, r18	; 0x01
    51d0:	f8 01       	movw	r30, r16
    51d2:	53 83       	std	Z+3, r21	; 0x03
    51d4:	42 83       	std	Z+2, r20	; 0x02
    51d6:	80 e0       	ldi	r24, 0x00	; 0
    51d8:	90 e0       	ldi	r25, 0x00	; 0
    51da:	0e 94 d0 9a 	call	0x135a0	; 0x135a0 <__floatunsisf>
    51de:	2d eb       	ldi	r18, 0xBD	; 189
    51e0:	37 e3       	ldi	r19, 0x37	; 55
    51e2:	46 e0       	ldi	r20, 0x06	; 6
    51e4:	59 e3       	ldi	r21, 0x39	; 57
    51e6:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    51ea:	f8 01       	movw	r30, r16
    51ec:	64 83       	std	Z+4, r22	; 0x04
    51ee:	75 83       	std	Z+5, r23	; 0x05
    51f0:	86 83       	std	Z+6, r24	; 0x06
    51f2:	97 83       	std	Z+7, r25	; 0x07
    51f4:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	fprintf(stderr,"Se ha efectuadado una parada Abrupta en los motores. \n"); 
    51f8:	8d b7       	in	r24, 0x3d	; 61
    51fa:	9e b7       	in	r25, 0x3e	; 62
    51fc:	08 96       	adiw	r24, 0x08	; 8
    51fe:	0f b6       	in	r0, 0x3f	; 63
    5200:	f8 94       	cli
    5202:	9e bf       	out	0x3e, r25	; 62
    5204:	0f be       	out	0x3f, r0	; 63
    5206:	8d bf       	out	0x3d, r24	; 61
    5208:	60 91 d2 79 	lds	r22, 0x79D2
    520c:	70 91 d3 79 	lds	r23, 0x79D3
    5210:	86 e6       	ldi	r24, 0x66	; 102
    5212:	96 e2       	ldi	r25, 0x26	; 38
    5214:	0e 94 9e 9f 	call	0x13f3c	; 0x13f3c <fputs>
	exit(1);
    5218:	81 e0       	ldi	r24, 0x01	; 1
    521a:	90 e0       	ldi	r25, 0x00	; 0
    521c:	0e 94 dc a0 	call	0x141b8	; 0x141b8 <_exit>

00005220 <rad2usteps>:


/*****************************************************************************************/
// convert angle in rad into microsteps
double rad2usteps(tAxisSettings *paxisSettings, double rad) 
{
    5220:	8f 92       	push	r8
    5222:	9f 92       	push	r9
    5224:	af 92       	push	r10
    5226:	bf 92       	push	r11
    5228:	cf 92       	push	r12
    522a:	df 92       	push	r13
    522c:	ef 92       	push	r14
    522e:	ff 92       	push	r15
    5230:	0f 93       	push	r16
    5232:	1f 93       	push	r17
    5234:	6c 01       	movw	r12, r24
    5236:	4a 01       	movw	r8, r20
    5238:	5b 01       	movw	r10, r22
    523a:	fc 01       	movw	r30, r24
    523c:	64 8d       	ldd	r22, Z+28	; 0x1c
    523e:	75 8d       	ldd	r23, Z+29	; 0x1d
    5240:	88 27       	eor	r24, r24
    5242:	77 fd       	sbrc	r23, 7
    5244:	80 95       	com	r24
    5246:	98 2f       	mov	r25, r24
    5248:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    524c:	7b 01       	movw	r14, r22
    524e:	8c 01       	movw	r16, r24
    5250:	f6 01       	movw	r30, r12
    5252:	66 8d       	ldd	r22, Z+30	; 0x1e
    5254:	77 8d       	ldd	r23, Z+31	; 0x1f
    5256:	88 27       	eor	r24, r24
    5258:	77 fd       	sbrc	r23, 7
    525a:	80 95       	com	r24
    525c:	98 2f       	mov	r25, r24
    525e:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    5262:	9b 01       	movw	r18, r22
    5264:	ac 01       	movw	r20, r24
    5266:	c8 01       	movw	r24, r16
    5268:	b7 01       	movw	r22, r14
    526a:	0e 94 37 9a 	call	0x1346e	; 0x1346e <__divsf3>
    526e:	7b 01       	movw	r14, r22
    5270:	8c 01       	movw	r16, r24
    5272:	c5 01       	movw	r24, r10
    5274:	b4 01       	movw	r22, r8
    5276:	2b ed       	ldi	r18, 0xDB	; 219
    5278:	3f e0       	ldi	r19, 0x0F	; 15
    527a:	49 ec       	ldi	r20, 0xC9	; 201
    527c:	50 e4       	ldi	r21, 0x40	; 64
    527e:	0e 94 37 9a 	call	0x1346e	; 0x1346e <__divsf3>
    5282:	9b 01       	movw	r18, r22
    5284:	ac 01       	movw	r20, r24
    5286:	c8 01       	movw	r24, r16
    5288:	b7 01       	movw	r22, r14
    528a:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    528e:	4b 01       	movw	r8, r22
    5290:	5c 01       	movw	r10, r24
    5292:	f6 01       	movw	r30, r12
    5294:	64 85       	ldd	r22, Z+12	; 0x0c
    5296:	75 85       	ldd	r23, Z+13	; 0x0d
    5298:	88 27       	eor	r24, r24
    529a:	77 fd       	sbrc	r23, 7
    529c:	80 95       	com	r24
    529e:	98 2f       	mov	r25, r24
    52a0:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    52a4:	7b 01       	movw	r14, r22
    52a6:	8c 01       	movw	r16, r24
    52a8:	f6 01       	movw	r30, r12
    52aa:	62 85       	ldd	r22, Z+10	; 0x0a
    52ac:	73 85       	ldd	r23, Z+11	; 0x0b
    52ae:	88 27       	eor	r24, r24
    52b0:	77 fd       	sbrc	r23, 7
    52b2:	80 95       	com	r24
    52b4:	98 2f       	mov	r25, r24
    52b6:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    52ba:	9b 01       	movw	r18, r22
    52bc:	ac 01       	movw	r20, r24
    52be:	c8 01       	movw	r24, r16
    52c0:	b7 01       	movw	r22, r14
    52c2:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    52c6:	9b 01       	movw	r18, r22
    52c8:	ac 01       	movw	r20, r24
    52ca:	c5 01       	movw	r24, r10
    52cc:	b4 01       	movw	r22, r8
    52ce:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
	x=(double) paxisSettings->gearNominator/(double)paxisSettings->gearDenominator;
	y=(rad/(2*M_PI));
	z=(double)paxisSettings->motorStepsPerRevolution* (double)paxisSettings->ustepsPerStep;
	resul= x*y*z;
	return resul; 
} // rad2usteps
    52d2:	1f 91       	pop	r17
    52d4:	0f 91       	pop	r16
    52d6:	ff 90       	pop	r15
    52d8:	ef 90       	pop	r14
    52da:	df 90       	pop	r13
    52dc:	cf 90       	pop	r12
    52de:	bf 90       	pop	r11
    52e0:	af 90       	pop	r10
    52e2:	9f 90       	pop	r9
    52e4:	8f 90       	pop	r8
    52e6:	08 95       	ret

000052e8 <ustep2rad>:

/*****************************************************************************************/
// convert microsteps into angle in rad
double ustep2rad(tAxisSettings *paxisSettings, double usteps) 
{
    52e8:	8f 92       	push	r8
    52ea:	9f 92       	push	r9
    52ec:	af 92       	push	r10
    52ee:	bf 92       	push	r11
    52f0:	cf 92       	push	r12
    52f2:	df 92       	push	r13
    52f4:	ef 92       	push	r14
    52f6:	ff 92       	push	r15
    52f8:	0f 93       	push	r16
    52fa:	1f 93       	push	r17
    52fc:	6c 01       	movw	r12, r24
    52fe:	9a 01       	movw	r18, r20
    5300:	ab 01       	movw	r20, r22
    5302:	ca 01       	movw	r24, r20
    5304:	b9 01       	movw	r22, r18
    5306:	0e 94 cf 99 	call	0x1339e	; 0x1339e <__addsf3>
    530a:	2b ed       	ldi	r18, 0xDB	; 219
    530c:	3f e0       	ldi	r19, 0x0F	; 15
    530e:	49 e4       	ldi	r20, 0x49	; 73
    5310:	50 e4       	ldi	r21, 0x40	; 64
    5312:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    5316:	4b 01       	movw	r8, r22
    5318:	5c 01       	movw	r10, r24
    531a:	f6 01       	movw	r30, r12
    531c:	66 8d       	ldd	r22, Z+30	; 0x1e
    531e:	77 8d       	ldd	r23, Z+31	; 0x1f
    5320:	88 27       	eor	r24, r24
    5322:	77 fd       	sbrc	r23, 7
    5324:	80 95       	com	r24
    5326:	98 2f       	mov	r25, r24
    5328:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    532c:	7b 01       	movw	r14, r22
    532e:	8c 01       	movw	r16, r24
    5330:	f6 01       	movw	r30, r12
    5332:	64 8d       	ldd	r22, Z+28	; 0x1c
    5334:	75 8d       	ldd	r23, Z+29	; 0x1d
    5336:	88 27       	eor	r24, r24
    5338:	77 fd       	sbrc	r23, 7
    533a:	80 95       	com	r24
    533c:	98 2f       	mov	r25, r24
    533e:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    5342:	9b 01       	movw	r18, r22
    5344:	ac 01       	movw	r20, r24
    5346:	c8 01       	movw	r24, r16
    5348:	b7 01       	movw	r22, r14
    534a:	0e 94 37 9a 	call	0x1346e	; 0x1346e <__divsf3>
    534e:	9b 01       	movw	r18, r22
    5350:	ac 01       	movw	r20, r24
    5352:	c5 01       	movw	r24, r10
    5354:	b4 01       	movw	r22, r8
    5356:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    535a:	4b 01       	movw	r8, r22
    535c:	5c 01       	movw	r10, r24
    535e:	f6 01       	movw	r30, r12
    5360:	62 85       	ldd	r22, Z+10	; 0x0a
    5362:	73 85       	ldd	r23, Z+11	; 0x0b
    5364:	88 27       	eor	r24, r24
    5366:	77 fd       	sbrc	r23, 7
    5368:	80 95       	com	r24
    536a:	98 2f       	mov	r25, r24
    536c:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    5370:	7b 01       	movw	r14, r22
    5372:	8c 01       	movw	r16, r24
    5374:	f6 01       	movw	r30, r12
    5376:	64 85       	ldd	r22, Z+12	; 0x0c
    5378:	75 85       	ldd	r23, Z+13	; 0x0d
    537a:	88 27       	eor	r24, r24
    537c:	77 fd       	sbrc	r23, 7
    537e:	80 95       	com	r24
    5380:	98 2f       	mov	r25, r24
    5382:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    5386:	9b 01       	movw	r18, r22
    5388:	ac 01       	movw	r20, r24
    538a:	c8 01       	movw	r24, r16
    538c:	b7 01       	movw	r22, r14
    538e:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    5392:	9b 01       	movw	r18, r22
    5394:	ac 01       	movw	r20, r24
    5396:	60 e0       	ldi	r22, 0x00	; 0
    5398:	70 e0       	ldi	r23, 0x00	; 0
    539a:	80 e8       	ldi	r24, 0x80	; 128
    539c:	9f e3       	ldi	r25, 0x3F	; 63
    539e:	0e 94 37 9a 	call	0x1346e	; 0x1346e <__divsf3>
    53a2:	9b 01       	movw	r18, r22
    53a4:	ac 01       	movw	r20, r24
    53a6:	c5 01       	movw	r24, r10
    53a8:	b4 01       	movw	r22, r8
    53aa:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>

	x=(double)paxisSettings->gearDenominator/(double)paxisSettings->gearNominator;
	y=1/( (double)paxisSettings->ustepsPerStep*(double)paxisSettings->motorStepsPerRevolution );
	resul=usteps*2*M_PI*x*y;
	return resul;
} // ustep2rad
    53ae:	1f 91       	pop	r17
    53b0:	0f 91       	pop	r16
    53b2:	ff 90       	pop	r15
    53b4:	ef 90       	pop	r14
    53b6:	df 90       	pop	r13
    53b8:	cf 90       	pop	r12
    53ba:	bf 90       	pop	r11
    53bc:	af 90       	pop	r10
    53be:	9f 90       	pop	r9
    53c0:	8f 90       	pop	r8
    53c2:	08 95       	ret

000053c4 <grados2rad>:

/*****************************************************************************************/
double grados2rad(double deg)
{
    53c4:	25 e3       	ldi	r18, 0x35	; 53
    53c6:	3a ef       	ldi	r19, 0xFA	; 250
    53c8:	4e e8       	ldi	r20, 0x8E	; 142
    53ca:	5c e3       	ldi	r21, 0x3C	; 60
    53cc:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
	double rad;

	rad=deg*(M_PI/180);
	return rad;
}
    53d0:	08 95       	ret

000053d2 <rad2grados>:

/*****************************************************************************************/
double rad2grados(double rad)
{
    53d2:	25 e3       	ldi	r18, 0x35	; 53
    53d4:	3a ef       	ldi	r19, 0xFA	; 250
    53d6:	4e e8       	ldi	r20, 0x8E	; 142
    53d8:	5c e3       	ldi	r21, 0x3C	; 60
    53da:	0e 94 37 9a 	call	0x1346e	; 0x1346e <__divsf3>
	double grad;

	grad=rad/(M_PI/180);
	return grad;
}
    53de:	08 95       	ret

000053e0 <bcd2int>:

/*****************************************************************************************/
uint8 bcd2int(uint8 bcd_format)
{
    53e0:	28 2f       	mov	r18, r24
    53e2:	22 95       	swap	r18
    53e4:	2f 70       	andi	r18, 0x0F	; 15
    53e6:	9a e0       	ldi	r25, 0x0A	; 10
    53e8:	29 9f       	mul	r18, r25
    53ea:	90 01       	movw	r18, r0
    53ec:	11 24       	eor	r1, r1
    53ee:	8f 70       	andi	r24, 0x0F	; 15
	uint8 integer;
	
	integer= (((bcd_format >>4)*10) + (bcd_format%16));
	
	return integer;
}
    53f0:	82 0f       	add	r24, r18
    53f2:	08 95       	ret

000053f4 <int2bcd>:

/*****************************************************************************************/
uint8 int2bcd(uint8 integer)
{
    53f4:	28 2f       	mov	r18, r24
    53f6:	6a e0       	ldi	r22, 0x0A	; 10
    53f8:	0e 94 5b 9c 	call	0x138b6	; 0x138b6 <__udivmodqi4>
    53fc:	38 2f       	mov	r19, r24
    53fe:	32 95       	swap	r19
    5400:	30 7f       	andi	r19, 0xF0	; 240
    5402:	82 2f       	mov	r24, r18
    5404:	0e 94 5b 9c 	call	0x138b6	; 0x138b6 <__udivmodqi4>
	uint8 bcd_format;
	
	bcd_format= ((integer/10)<<4) + (integer%10);
	
	return bcd_format;
}
    5408:	83 2f       	mov	r24, r19
    540a:	89 0f       	add	r24, r25
    540c:	08 95       	ret

0000540e <uPasosTOgradros>:

//paxisSettings apuntador a las caracteristicas de la acticulacion a convertir. 

/*****************************************************************************************/
double uPasosTOgradros(tAxisSettings *paxisSettings,int32 Valor,int tipo)
{
    540e:	cf 93       	push	r28
    5410:	df 93       	push	r29
    5412:	ec 01       	movw	r28, r24

	double result,Data;

	result=-1;
	
	switch(tipo) 
    5414:	21 30       	cpi	r18, 0x01	; 1
    5416:	31 05       	cpc	r19, r1
    5418:	a1 f0       	breq	.+40     	; 0x5442 <uPasosTOgradros+0x34>
    541a:	22 30       	cpi	r18, 0x02	; 2
    541c:	31 05       	cpc	r19, r1
    541e:	69 f1       	breq	.+90     	; 0x547a <uPasosTOgradros+0x6c>
    5420:	23 2b       	or	r18, r19
    5422:	29 f0       	breq	.+10     	; 0x542e <uPasosTOgradros+0x20>
    5424:	60 e0       	ldi	r22, 0x00	; 0
    5426:	70 e0       	ldi	r23, 0x00	; 0
    5428:	80 e8       	ldi	r24, 0x80	; 128
    542a:	9f eb       	ldi	r25, 0xBF	; 191
    542c:	43 c0       	rjmp	.+134    	; 0x54b4 <uPasosTOgradros+0xa6>
	{
		case POSICION_TYPE:
			Data=Valor;
			/*De uPasos A radianes*/
			result=ustep2rad(paxisSettings,(double)Data);
    542e:	cb 01       	movw	r24, r22
    5430:	ba 01       	movw	r22, r20
    5432:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    5436:	ab 01       	movw	r20, r22
    5438:	bc 01       	movw	r22, r24
    543a:	ce 01       	movw	r24, r28
    543c:	0e 94 74 29 	call	0x52e8	; 0x52e8 <ustep2rad>
    5440:	37 c0       	rjmp	.+110    	; 0x54b0 <uPasosTOgradros+0xa2>
			/*De Radianes A grados*/
			result=rad2grados((double)result);
		break;
		case VELOCIDAD_TYPE:
			Data=Valor-0.5;
    5442:	cb 01       	movw	r24, r22
    5444:	ba 01       	movw	r22, r20
    5446:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    544a:	20 e0       	ldi	r18, 0x00	; 0
    544c:	30 e0       	ldi	r19, 0x00	; 0
    544e:	40 e0       	ldi	r20, 0x00	; 0
    5450:	5f e3       	ldi	r21, 0x3F	; 63
    5452:	0e 94 ce 99 	call	0x1339c	; 0x1339c <__subsf3>
			Data=Data/65536.0;
    5456:	20 e0       	ldi	r18, 0x00	; 0
    5458:	30 e0       	ldi	r19, 0x00	; 0
    545a:	40 e8       	ldi	r20, 0x80	; 128
    545c:	57 e3       	ldi	r21, 0x37	; 55
    545e:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
			Data=Data/SAMPLETIME;
			/*De uPasos A radianes*/
			result=ustep2rad(paxisSettings,(double)Data);
    5462:	22 e5       	ldi	r18, 0x52	; 82
    5464:	39 e4       	ldi	r19, 0x49	; 73
    5466:	4d e1       	ldi	r20, 0x1D	; 29
    5468:	5a e3       	ldi	r21, 0x3A	; 58
    546a:	0e 94 37 9a 	call	0x1346e	; 0x1346e <__divsf3>
    546e:	ab 01       	movw	r20, r22
    5470:	bc 01       	movw	r22, r24
    5472:	ce 01       	movw	r24, r28
    5474:	0e 94 74 29 	call	0x52e8	; 0x52e8 <ustep2rad>
    5478:	1b c0       	rjmp	.+54     	; 0x54b0 <uPasosTOgradros+0xa2>
			/*De Radianes A grados*/
			result=rad2grados((double)result);
		break;
		case ACELERACION_TYPE:
			Data=Valor-0.5;
    547a:	cb 01       	movw	r24, r22
    547c:	ba 01       	movw	r22, r20
    547e:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    5482:	20 e0       	ldi	r18, 0x00	; 0
    5484:	30 e0       	ldi	r19, 0x00	; 0
    5486:	40 e0       	ldi	r20, 0x00	; 0
    5488:	5f e3       	ldi	r21, 0x3F	; 63
    548a:	0e 94 ce 99 	call	0x1339c	; 0x1339c <__subsf3>
			Data=Data/65536.0;
    548e:	20 e0       	ldi	r18, 0x00	; 0
    5490:	30 e0       	ldi	r19, 0x00	; 0
    5492:	40 e8       	ldi	r20, 0x80	; 128
    5494:	57 e3       	ldi	r21, 0x37	; 55
    5496:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
			Data=Data/(SAMPLETIME*SAMPLETIME);
			/*De uPasos A radianes*/
			result=ustep2rad(paxisSettings,(double)Data);
    549a:	27 e0       	ldi	r18, 0x07	; 7
    549c:	36 e4       	ldi	r19, 0x46	; 70
    549e:	41 ec       	ldi	r20, 0xC1	; 193
    54a0:	54 e3       	ldi	r21, 0x34	; 52
    54a2:	0e 94 37 9a 	call	0x1346e	; 0x1346e <__divsf3>
    54a6:	ab 01       	movw	r20, r22
    54a8:	bc 01       	movw	r22, r24
    54aa:	ce 01       	movw	r24, r28
    54ac:	0e 94 74 29 	call	0x52e8	; 0x52e8 <ustep2rad>
			/*De Radianes A grados*/
			result=rad2grados((double)result);
    54b0:	0e 94 e9 29 	call	0x53d2	; 0x53d2 <rad2grados>
		break;
	}
 
	return result;
}
    54b4:	df 91       	pop	r29
    54b6:	cf 91       	pop	r28
    54b8:	08 95       	ret

000054ba <accelerationPCtoUC>:
int32 accelerationPCtoUC(double f) 
{
	double temp=0;
	
	temp=f*SAMPLETIME*SAMPLETIME; //De segundos a sampletime 
	temp=0.50+(65536.0*temp);
    54ba:	22 e5       	ldi	r18, 0x52	; 82
    54bc:	39 e4       	ldi	r19, 0x49	; 73
    54be:	4d e1       	ldi	r20, 0x1D	; 29
    54c0:	5a e3       	ldi	r21, 0x3A	; 58
    54c2:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    54c6:	22 e5       	ldi	r18, 0x52	; 82
    54c8:	39 e4       	ldi	r19, 0x49	; 73
    54ca:	4d e1       	ldi	r20, 0x1D	; 29
    54cc:	5a e3       	ldi	r21, 0x3A	; 58
    54ce:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    54d2:	20 e0       	ldi	r18, 0x00	; 0
    54d4:	30 e0       	ldi	r19, 0x00	; 0
    54d6:	40 e8       	ldi	r20, 0x80	; 128
    54d8:	57 e4       	ldi	r21, 0x47	; 71
    54da:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    54de:	20 e0       	ldi	r18, 0x00	; 0
    54e0:	30 e0       	ldi	r19, 0x00	; 0
    54e2:	40 e0       	ldi	r20, 0x00	; 0
    54e4:	5f e3       	ldi	r21, 0x3F	; 63
    54e6:	0e 94 cf 99 	call	0x1339e	; 0x1339e <__addsf3>
    temp=floor(temp);
    54ea:	0e 94 0d 9b 	call	0x1361a	; 0x1361a <floor>
    54ee:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    54f2:	9b 01       	movw	r18, r22
    54f4:	ac 01       	movw	r20, r24
	return (int32)temp;  // 16.16 format
} // accelerationPCtoUC
    54f6:	ca 01       	movw	r24, r20
    54f8:	08 95       	ret

000054fa <velocityPCtoUC>:
int32 velocityPCtoUC(double f) 
{
	double temp=0;
	
	temp=f*SAMPLETIME; //De segundos a sampletime 
	temp=0.50+65536.0*temp;
    54fa:	22 e5       	ldi	r18, 0x52	; 82
    54fc:	39 e4       	ldi	r19, 0x49	; 73
    54fe:	4d e1       	ldi	r20, 0x1D	; 29
    5500:	5a e3       	ldi	r21, 0x3A	; 58
    5502:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    5506:	20 e0       	ldi	r18, 0x00	; 0
    5508:	30 e0       	ldi	r19, 0x00	; 0
    550a:	40 e8       	ldi	r20, 0x80	; 128
    550c:	57 e4       	ldi	r21, 0x47	; 71
    550e:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    5512:	20 e0       	ldi	r18, 0x00	; 0
    5514:	30 e0       	ldi	r19, 0x00	; 0
    5516:	40 e0       	ldi	r20, 0x00	; 0
    5518:	5f e3       	ldi	r21, 0x3F	; 63
    551a:	0e 94 cf 99 	call	0x1339e	; 0x1339e <__addsf3>
	temp=floor(temp);
    551e:	0e 94 0d 9b 	call	0x1361a	; 0x1361a <floor>
    5522:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    5526:	9b 01       	movw	r18, r22
    5528:	ac 01       	movw	r20, r24
	return (int32)temp;  // 16.16 format
} // velocityPCtoUC
    552a:	ca 01       	movw	r24, r20
    552c:	08 95       	ret

0000552e <positionPCtoUC>:


/*****************************************************************************************/
int32 positionPCtoUC(double f) 
{
	return (int32)floor(0.50+f);  // 32.0 format
    552e:	20 e0       	ldi	r18, 0x00	; 0
    5530:	30 e0       	ldi	r19, 0x00	; 0
    5532:	40 e0       	ldi	r20, 0x00	; 0
    5534:	5f e3       	ldi	r21, 0x3F	; 63
    5536:	0e 94 cf 99 	call	0x1339e	; 0x1339e <__addsf3>
    553a:	0e 94 0d 9b 	call	0x1361a	; 0x1361a <floor>
    553e:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    5542:	9b 01       	movw	r18, r22
    5544:	ac 01       	movw	r20, r24
} // positionPCtoUC
    5546:	ca 01       	movw	r24, r20
    5548:	08 95       	ret

0000554a <gradrosTOuPasos>:
	return result;
}


int32 gradrosTOuPasos(tAxisSettings *paxisSettings,double angulo,int tipo)
{
    554a:	0f 93       	push	r16
    554c:	1f 93       	push	r17
    554e:	cf 93       	push	r28
    5550:	df 93       	push	r29
    5552:	8c 01       	movw	r16, r24
    5554:	e9 01       	movw	r28, r18
	int32 result;

	result=-1;
	
	Radianes=grados2rad(angulo);
	uPasos=rad2usteps(paxisSettings,Radianes);
    5556:	cb 01       	movw	r24, r22
    5558:	ba 01       	movw	r22, r20
    555a:	25 e3       	ldi	r18, 0x35	; 53
    555c:	3a ef       	ldi	r19, 0xFA	; 250
    555e:	4e e8       	ldi	r20, 0x8E	; 142
    5560:	5c e3       	ldi	r21, 0x3C	; 60
    5562:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    5566:	ab 01       	movw	r20, r22
    5568:	bc 01       	movw	r22, r24
    556a:	c8 01       	movw	r24, r16
    556c:	0e 94 10 29 	call	0x5220	; 0x5220 <rad2usteps>
	
	switch(tipo) 
    5570:	c1 30       	cpi	r28, 0x01	; 1
    5572:	d1 05       	cpc	r29, r1
    5574:	69 f0       	breq	.+26     	; 0x5590 <gradrosTOuPasos+0x46>
    5576:	c2 30       	cpi	r28, 0x02	; 2
    5578:	d1 05       	cpc	r29, r1
    557a:	69 f0       	breq	.+26     	; 0x5596 <gradrosTOuPasos+0x4c>
    557c:	cd 2b       	or	r28, r29
    557e:	29 f0       	breq	.+10     	; 0x558a <gradrosTOuPasos+0x40>
    5580:	2f ef       	ldi	r18, 0xFF	; 255
    5582:	3f ef       	ldi	r19, 0xFF	; 255
    5584:	4f ef       	ldi	r20, 0xFF	; 255
    5586:	5f ef       	ldi	r21, 0xFF	; 255
    5588:	0a c0       	rjmp	.+20     	; 0x559e <gradrosTOuPasos+0x54>
	{
		case POSICION_TYPE:		
			result=positionPCtoUC(uPasos);  
    558a:	0e 94 97 2a 	call	0x552e	; 0x552e <positionPCtoUC>
    558e:	05 c0       	rjmp	.+10     	; 0x559a <gradrosTOuPasos+0x50>
		break;
		case VELOCIDAD_TYPE:
			result=velocityPCtoUC(uPasos);  
    5590:	0e 94 7d 2a 	call	0x54fa	; 0x54fa <velocityPCtoUC>
    5594:	02 c0       	rjmp	.+4      	; 0x559a <gradrosTOuPasos+0x50>
		break;
		case ACELERACION_TYPE:
			result=accelerationPCtoUC(uPasos);  
    5596:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <accelerationPCtoUC>
    559a:	9b 01       	movw	r18, r22
    559c:	ac 01       	movw	r20, r24
		break;
	}
 
	return result;
}
    559e:	b9 01       	movw	r22, r18
    55a0:	ca 01       	movw	r24, r20
    55a2:	df 91       	pop	r29
    55a4:	cf 91       	pop	r28
    55a6:	1f 91       	pop	r17
    55a8:	0f 91       	pop	r16
    55aa:	08 95       	ret

000055ac <usb_read>:


/*---------------------------Funciones Interface PC-uControlador---------------------------*/

int16 usb_read(uint8 *dato_h,uint8 *dato_l)
{
    55ac:	fc 01       	movw	r30, r24
    55ae:	db 01       	movw	r26, r22
	uint32 timeout=0xFFFF;
	
	CONTROL_USB_HIGH		=		0x00;					 	//Coloco el puerto L como lectura
    55b0:	10 92 07 01 	sts	0x0107, r1
	CONTROL_USB_LOW		=		0x00;					  	//Coloco el puerto K como lectura
    55b4:	10 92 0a 01 	sts	0x010A, r1
	
	PORTH		&= ~(_BV(USB_EN));						  	//Habilito el Controlador USB
    55b8:	80 91 02 01 	lds	r24, 0x0102
    55bc:	8b 7f       	andi	r24, 0xFB	; 251
    55be:	80 93 02 01 	sts	0x0102, r24
    55c2:	20 e0       	ldi	r18, 0x00	; 0
    55c4:	30 e0       	ldi	r19, 0x00	; 0
    55c6:	07 c0       	rjmp	.+14     	; 0x55d6 <usb_read+0x2a>
	/** Espero a que la seal USB_READY est en Bajo.*/	 
//	loop_until_bit_is_clear(PINH,USB_READY);									
	do
	{
		timeout--;
		if (timeout==0)
    55c8:	8f ef       	ldi	r24, 0xFF	; 255
    55ca:	2e 3f       	cpi	r18, 0xFE	; 254
    55cc:	38 07       	cpc	r19, r24
    55ce:	19 f4       	brne	.+6      	; 0x55d6 <usb_read+0x2a>
    55d0:	2a e0       	ldi	r18, 0x0A	; 10
    55d2:	30 e0       	ldi	r19, 0x00	; 0
    55d4:	22 c0       	rjmp	.+68     	; 0x561a <usb_read+0x6e>
			return rcTimeoutReadingData;
	}
	while(bit_is_set(PINH,USB_READY));	
    55d6:	80 91 00 01 	lds	r24, 0x0100
    55da:	2f 5f       	subi	r18, 0xFF	; 255
    55dc:	3f 4f       	sbci	r19, 0xFF	; 255
    55de:	87 fd       	sbrc	r24, 7
    55e0:	f3 cf       	rjmp	.-26     	; 0x55c8 <usb_read+0x1c>
	
	PORTH			&= ~(_BV(USB_READ));				  	//Realiza Lectura
    55e2:	80 91 02 01 	lds	r24, 0x0102
    55e6:	8f 7e       	andi	r24, 0xEF	; 239
    55e8:	80 93 02 01 	sts	0x0102, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    55ec:	85 e0       	ldi	r24, 0x05	; 5
    55ee:	8a 95       	dec	r24
    55f0:	f1 f7       	brne	.-4      	; 0x55ee <usb_read+0x42>
	_delay_us(2);
	
	if(dato_h!=NULL)
    55f2:	30 97       	sbiw	r30, 0x00	; 0
    55f4:	19 f0       	breq	.+6      	; 0x55fc <usb_read+0x50>
	*dato_h	=	DATA_USB_READ_HIGH;         		//leo dato ms significativo en el Puerto
    55f6:	80 91 06 01 	lds	r24, 0x0106
    55fa:	80 83       	st	Z, r24
	*dato_l	=	DATA_USB_READ_LOW;             	//leo dato menos significativo	
    55fc:	80 91 09 01 	lds	r24, 0x0109
    5600:	8c 93       	st	X, r24
	PORTH 	 		|= _BV(USB_READ);				 	 	//coloco la seal de read en alto	
    5602:	80 91 02 01 	lds	r24, 0x0102
    5606:	80 61       	ori	r24, 0x10	; 16
    5608:	80 93 02 01 	sts	0x0102, r24
	PORTH 	 		|= _BV(USB_EN);					 	//coloco la seal de chip select en alto
    560c:	80 91 02 01 	lds	r24, 0x0102
    5610:	84 60       	ori	r24, 0x04	; 4
    5612:	80 93 02 01 	sts	0x0102, r24
    5616:	20 e0       	ldi	r18, 0x00	; 0
    5618:	30 e0       	ldi	r19, 0x00	; 0
	
	return rcOK;
} 
    561a:	c9 01       	movw	r24, r18
    561c:	08 95       	ret

0000561e <usb_write>:
/*----------------------------------------------------------------------------------------------------*/
int16 usb_write(uint8 datoh,uint8 datol)
{
    561e:	98 2f       	mov	r25, r24
	DDRL	=		0xFF;											//Coloco el puerto L como Salida
    5620:	8f ef       	ldi	r24, 0xFF	; 255
    5622:	80 93 0a 01 	sts	0x010A, r24
	DDRK	=		0xFF;											//Coloco el puerto K como Salida
    5626:	80 93 07 01 	sts	0x0107, r24
	//uint32 timeout=0xFFFF;
	
	PORTH		&= ~(_BV(USB_EN));							//Habilito el Controlador USB
    562a:	80 91 02 01 	lds	r24, 0x0102
    562e:	8b 7f       	andi	r24, 0xFB	; 251
    5630:	80 93 02 01 	sts	0x0102, r24
	
	/* Espero a que la seal USB_READY est en Bajo.*/
	
  loop_until_bit_is_clear(PINH,USB_READY);
    5634:	80 91 00 01 	lds	r24, 0x0100
    5638:	87 fd       	sbrc	r24, 7
    563a:	fc cf       	rjmp	.-8      	; 0x5634 <usb_write+0x16>
	   if (timeout==0)
	       return rcTimeoutSendingData;
	}while(bit_is_set(PINH,USB_READY));
*/	
	
	DATA_USB_WRITE_HIGH	=	datoh;						//Coloco el Dato mas significativo en el Puerto
    563c:	90 93 08 01 	sts	0x0108, r25
	DATA_USB_WRITE_LOW	=	datol;						//Coloco el Dato menos significativo en el Puerto
    5640:	60 93 0b 01 	sts	0x010B, r22
	PORTH		&= ~(_BV(USB_WRITE));						//Realizo una operacion de Escritura
    5644:	80 91 02 01 	lds	r24, 0x0102
    5648:	87 7f       	andi	r24, 0xF7	; 247
    564a:	80 93 02 01 	sts	0x0102, r24
    564e:	85 e0       	ldi	r24, 0x05	; 5
    5650:	8a 95       	dec	r24
    5652:	f1 f7       	brne	.-4      	; 0x5650 <usb_write+0x32>
	_delay_us(2);
	PORTH 		|= _BV(USB_WRITE);						//coloco la seal de read en alto	
    5654:	80 91 02 01 	lds	r24, 0x0102
    5658:	88 60       	ori	r24, 0x08	; 8
    565a:	80 93 02 01 	sts	0x0102, r24
	PORTH 		|= _BV(USB_EN);							//coloco la seal de chip select en alto
    565e:	80 91 02 01 	lds	r24, 0x0102
    5662:	84 60       	ori	r24, 0x04	; 4
    5664:	80 93 02 01 	sts	0x0102, r24
	return rcOK;
	
} 
    5668:	80 e0       	ldi	r24, 0x00	; 0
    566a:	90 e0       	ldi	r25, 0x00	; 0
    566c:	08 95       	ret

0000566e <Envio_USB>:
/*----------------------------------------------------------------------------------------------------*/  
//Esta funcion envia por los puertos del uC los datos
//Maneja tanto tamaos pares como inpares
 int16 Envio_USB(uint8* Buffer,int16 size)
{
    566e:	ef 92       	push	r14
    5670:	ff 92       	push	r15
    5672:	0f 93       	push	r16
    5674:	1f 93       	push	r17
    5676:	cf 93       	push	r28
    5678:	df 93       	push	r29
    567a:	7b 01       	movw	r14, r22
    567c:	8c 01       	movw	r16, r24
    567e:	c0 e0       	ldi	r28, 0x00	; 0
    5680:	d0 e0       	ldi	r29, 0x00	; 0
	for(j=0;j<size;j++)
		printf("Envio_USB => Buffer[%d]=%X \n",j,Buffer[j]);		   
	#endif
   do
	{
		templ=Buffer[i] ;
    5682:	f8 01       	movw	r30, r16
    5684:	60 81       	ld	r22, Z
		actual=i+1;                    					//actual tiene los impares
		if (actual==size)
    5686:	ce 01       	movw	r24, r28
    5688:	01 96       	adiw	r24, 0x01	; 1
    568a:	8e 15       	cp	r24, r14
    568c:	9f 05       	cpc	r25, r15
    568e:	11 f4       	brne	.+4      	; 0x5694 <Envio_USB+0x26>
			rc=usb_write(0x00,templ);     				//he llegado a el final del 
    5690:	80 e0       	ldi	r24, 0x00	; 0
    5692:	02 c0       	rjmp	.+4      	; 0x5698 <Envio_USB+0x2a>
														//arreglo donde el tamao es impar
		else
		{  	 
			temph=Buffer[i+1];			
			rc=usb_write(temph,templ);
    5694:	f8 01       	movw	r30, r16
    5696:	81 81       	ldd	r24, Z+1	; 0x01
    5698:	0e 94 0f 2b 	call	0x561e	; 0x561e <usb_write>
		}
		i=i+2;
    569c:	22 96       	adiw	r28, 0x02	; 2
    569e:	0e 5f       	subi	r16, 0xFE	; 254
    56a0:	1f 4f       	sbci	r17, 0xFF	; 255
		#ifdef DEBUGUSBLevel1
		printf("Envio_USB => i= %d \n",i);
		#endif
	}
	while (i<size); 
    56a2:	ce 15       	cp	r28, r14
    56a4:	df 05       	cpc	r29, r15
    56a6:	6c f3       	brlt	.-38     	; 0x5682 <Envio_USB+0x14>
	#ifdef DEBUGUSBLevel0
		printf("Envio_USB => Saliendo\n");
	#endif
	return rc;
	
}
    56a8:	df 91       	pop	r29
    56aa:	cf 91       	pop	r28
    56ac:	1f 91       	pop	r17
    56ae:	0f 91       	pop	r16
    56b0:	ff 90       	pop	r15
    56b2:	ef 90       	pop	r14
    56b4:	08 95       	ret

000056b6 <Leo_USB>:
/*----------------------------------------------------------------------------------------------------*/
int16 Leo_USB(uint8* Buffer,int16 size)
{
    56b6:	ef 92       	push	r14
    56b8:	ff 92       	push	r15
    56ba:	0f 93       	push	r16
    56bc:	1f 93       	push	r17
    56be:	cf 93       	push	r28
    56c0:	df 93       	push	r29
    56c2:	7b 01       	movw	r14, r22
    56c4:	ec 01       	movw	r28, r24
    56c6:	00 e0       	ldi	r16, 0x00	; 0
    56c8:	10 e0       	ldi	r17, 0x00	; 0
	printf("Leo_USB => Cantida de datos por leer %d \n",size);
	#endif
	do
	{	
		actual=i+1;                    					//actual tiene los impares
		if(actual==size)
    56ca:	c8 01       	movw	r24, r16
    56cc:	01 96       	adiw	r24, 0x01	; 1
    56ce:	8e 15       	cp	r24, r14
    56d0:	9f 05       	cpc	r25, r15
    56d2:	19 f4       	brne	.+6      	; 0x56da <Leo_USB+0x24>
			rc=usb_read(NULL,&Buffer[i]);     			//he llegado a el final del 
    56d4:	80 e0       	ldi	r24, 0x00	; 0
    56d6:	90 e0       	ldi	r25, 0x00	; 0
    56d8:	02 c0       	rjmp	.+4      	; 0x56de <Leo_USB+0x28>
														//arreglo donde el tamao es impar
		else
		rc=usb_read(&Buffer[i+1],&Buffer[i]);				
    56da:	ce 01       	movw	r24, r28
    56dc:	01 96       	adiw	r24, 0x01	; 1
    56de:	be 01       	movw	r22, r28
    56e0:	0e 94 d6 2a 	call	0x55ac	; 0x55ac <usb_read>
		i=i+2;
    56e4:	0e 5f       	subi	r16, 0xFE	; 254
    56e6:	1f 4f       	sbci	r17, 0xFF	; 255
    56e8:	22 96       	adiw	r28, 0x02	; 2
	}
	while (i<size); 
    56ea:	0e 15       	cp	r16, r14
    56ec:	1f 05       	cpc	r17, r15
    56ee:	6c f3       	brlt	.-38     	; 0x56ca <Leo_USB+0x14>
	#ifdef DEBUGUSBLevel2
	for(i=0;i<size;i++)
	printf("Leo_USB => Buffer[%d]=%X \n",i,Buffer[i]);		   
	#endif	
	return rc;
}
    56f0:	df 91       	pop	r29
    56f2:	cf 91       	pop	r28
    56f4:	1f 91       	pop	r17
    56f6:	0f 91       	pop	r16
    56f8:	ff 90       	pop	r15
    56fa:	ef 90       	pop	r14
    56fc:	08 95       	ret

000056fe <defaultAxisSettings>:

#endif


 void defaultAxisSettings(int16 axis, tAxisSettings *paxisSettings)
{
    56fe:	cf 93       	push	r28
    5700:	df 93       	push	r29
    5702:	9c 01       	movw	r18, r24
    5704:	eb 01       	movw	r28, r22
//General Settings:
  paxisSettings->axisEnabled = TRUE;      
    5706:	81 e0       	ldi	r24, 0x01	; 1
    5708:	88 83       	st	Y, r24
  paxisSettings->interruptEnable=TRUE;
    570a:	89 83       	std	Y+1, r24	; 0x01
  paxisSettings->switchEnable=TRUE;
    570c:	41 e0       	ldi	r20, 0x01	; 1
    570e:	50 e0       	ldi	r21, 0x00	; 0
    5710:	5b 83       	std	Y+3, r21	; 0x03
    5712:	4a 83       	std	Y+2, r20	; 0x02
  paxisSettings->encoderEnable=FALSE; 
    5714:	1d 82       	std	Y+5, r1	; 0x05
    5716:	1c 82       	std	Y+4, r1	; 0x04
  paxisSettings->ustepsPerStep = 32; //Quiere decir que 32 uP hacen un paso
    5718:	60 e2       	ldi	r22, 0x20	; 32
    571a:	70 e0       	ldi	r23, 0x00	; 0
    571c:	7b 87       	std	Y+11, r23	; 0x0b
    571e:	6a 87       	std	Y+10, r22	; 0x0a
  paxisSettings->motorStepsPerRevolution = 200;//El angulo de paso es 15 360/15 = 24, oseo que con 24 pasos se tiene una vuelta 
    5720:	88 ec       	ldi	r24, 0xC8	; 200
    5722:	90 e0       	ldi	r25, 0x00	; 0
    5724:	9d 87       	std	Y+13, r25	; 0x0d
    5726:	8c 87       	std	Y+12, r24	; 0x0c
  paxisSettings->encoderStepsPerRevolution = 480;
    5728:	80 ee       	ldi	r24, 0xE0	; 224
    572a:	91 e0       	ldi	r25, 0x01	; 1
    572c:	9f 87       	std	Y+15, r25	; 0x0f
    572e:	8e 87       	std	Y+14, r24	; 0x0e
  paxisSettings->ErrorLimit=200;
    5730:	88 ec       	ldi	r24, 0xC8	; 200
    5732:	90 e0       	ldi	r25, 0x00	; 0
    5734:	a0 e0       	ldi	r26, 0x00	; 0
    5736:	b0 e0       	ldi	r27, 0x00	; 0
    5738:	88 a3       	std	Y+32, r24	; 0x20
    573a:	99 a3       	std	Y+33, r25	; 0x21
    573c:	aa a3       	std	Y+34, r26	; 0x22
    573e:	bb a3       	std	Y+35, r27	; 0x23
  paxisSettings->TrackingWindow	= 30;
    5740:	8e e1       	ldi	r24, 0x1E	; 30
    5742:	90 e0       	ldi	r25, 0x00	; 0
    5744:	99 8b       	std	Y+17, r25	; 0x11
    5746:	88 8b       	std	Y+16, r24	; 0x10
  paxisSettings->SettleWindow = 22; //
    5748:	86 e1       	ldi	r24, 0x16	; 22
    574a:	90 e0       	ldi	r25, 0x00	; 0
    574c:	9b 8b       	std	Y+19, r25	; 0x13
    574e:	8a 8b       	std	Y+18, r24	; 0x12
  paxisSettings->SettleTime	= 833; // 0.5 seg  
    5750:	81 e4       	ldi	r24, 0x41	; 65
    5752:	93 e0       	ldi	r25, 0x03	; 3
    5754:	9d 8b       	std	Y+21, r25	; 0x15
    5756:	8c 8b       	std	Y+20, r24	; 0x14
  paxisSettings->motorPower = 98; // % of full power
    5758:	82 e6       	ldi	r24, 0x62	; 98
    575a:	90 e0       	ldi	r25, 0x00	; 0
    575c:	9f 8b       	std	Y+23, r25	; 0x17
    575e:	8e 8b       	std	Y+22, r24	; 0x16
  paxisSettings->numberPhases = 2;
    5760:	82 e0       	ldi	r24, 0x02	; 2
    5762:	90 e0       	ldi	r25, 0x00	; 0
    5764:	99 8f       	std	Y+25, r25	; 0x19
    5766:	88 8f       	std	Y+24, r24	; 0x18
  paxisSettings->limitVelocity = 1310720; //20*65536;    // (2500rpm/60s)*48spr*16usps/1623cycle/s) !! 2500 rmp is close to the limit of the numerical range
    5768:	80 e0       	ldi	r24, 0x00	; 0
    576a:	90 e0       	ldi	r25, 0x00	; 0
    576c:	a4 e1       	ldi	r26, 0x14	; 20
    576e:	b0 e0       	ldi	r27, 0x00	; 0
    5770:	88 a7       	std	Y+40, r24	; 0x28
    5772:	99 a7       	std	Y+41, r25	; 0x29
    5774:	aa a7       	std	Y+42, r26	; 0x2a
    5776:	bb a7       	std	Y+43, r27	; 0x2b
  paxisSettings->limitAcceleration = 786; //0.012*65536;  // absolute maximum values which the hardware can do
    5778:	82 e1       	ldi	r24, 0x12	; 18
    577a:	93 e0       	ldi	r25, 0x03	; 3
    577c:	a0 e0       	ldi	r26, 0x00	; 0
    577e:	b0 e0       	ldi	r27, 0x00	; 0
    5780:	8c a3       	std	Y+36, r24	; 0x24
    5782:	9d a3       	std	Y+37, r25	; 0x25
    5784:	ae a3       	std	Y+38, r26	; 0x26
    5786:	bf a3       	std	Y+39, r27	; 0x27
  paxisSettings->limitJerk = 128849; //0.00003*4294967296;  // default value for S-curve profile...400 acceleration cycles (0.25s)
    5788:	81 e5       	ldi	r24, 0x51	; 81
    578a:	97 ef       	ldi	r25, 0xF7	; 247
    578c:	a1 e0       	ldi	r26, 0x01	; 1
    578e:	b0 e0       	ldi	r27, 0x00	; 0
    5790:	8c a7       	std	Y+44, r24	; 0x2c
    5792:	9d a7       	std	Y+45, r25	; 0x2d
    5794:	ae a7       	std	Y+46, r26	; 0x2e
    5796:	bf a7       	std	Y+47, r27	; 0x2f
  paxisSettings->maxVelocity = 327680; //0.25*paxisSettings->limitVelocity;  // 25% of maximum
    5798:	80 e0       	ldi	r24, 0x00	; 0
    579a:	90 e0       	ldi	r25, 0x00	; 0
    579c:	a5 e0       	ldi	r26, 0x05	; 5
    579e:	b0 e0       	ldi	r27, 0x00	; 0
    57a0:	8c ab       	std	Y+52, r24	; 0x34
    57a2:	9d ab       	std	Y+53, r25	; 0x35
    57a4:	ae ab       	std	Y+54, r26	; 0x36
    57a6:	bf ab       	std	Y+55, r27	; 0x37
  paxisSettings->minVelocity = 13107; //0.01*paxisSettings->limitVelocity;  // 1%, for initial finding of the limit switches and home position
    57a8:	83 e3       	ldi	r24, 0x33	; 51
    57aa:	93 e3       	ldi	r25, 0x33	; 51
    57ac:	a0 e0       	ldi	r26, 0x00	; 0
    57ae:	b0 e0       	ldi	r27, 0x00	; 0
    57b0:	88 af       	std	Y+56, r24	; 0x38
    57b2:	99 af       	std	Y+57, r25	; 0x39
    57b4:	aa af       	std	Y+58, r26	; 0x3a
    57b6:	bb af       	std	Y+59, r27	; 0x3b
  paxisSettings->maxAcceleration = 197; //0.25*paxisSettings->limitAcceleration; // 25% of maximum
    57b8:	85 ec       	ldi	r24, 0xC5	; 197
    57ba:	90 e0       	ldi	r25, 0x00	; 0
    57bc:	a0 e0       	ldi	r26, 0x00	; 0
    57be:	b0 e0       	ldi	r27, 0x00	; 0
    57c0:	88 ab       	std	Y+48, r24	; 0x30
    57c2:	99 ab       	std	Y+49, r25	; 0x31
    57c4:	aa ab       	std	Y+50, r26	; 0x32
    57c6:	bb ab       	std	Y+51, r27	; 0x33
  paxisSettings->homeSwitchHandling = 0; // 3 switches: for neg. limit, pos. limit and home
    57c8:	1b 8e       	std	Y+27, r1	; 0x1b
    57ca:	1a 8e       	std	Y+26, r1	; 0x1a
  paxisSettings->gearNominator = 1;      // PC needs that to change rad into usteps
    57cc:	5d 8f       	std	Y+29, r21	; 0x1d
    57ce:	4c 8f       	std	Y+28, r20	; 0x1c
  paxisSettings->gearDenominator = 1;    // gear=Nominator/Denominator, step=rad*gear*other_stuff
    57d0:	5f 8f       	std	Y+31, r21	; 0x1f
    57d2:	4e 8f       	std	Y+30, r20	; 0x1e
  // specific settings:
  switch(axis) 
    57d4:	25 30       	cpi	r18, 0x05	; 5
    57d6:	31 05       	cpc	r19, r1
    57d8:	09 f4       	brne	.+2      	; 0x57dc <defaultAxisSettings+0xde>
    57da:	78 c1       	rjmp	.+752    	; 0x5acc <defaultAxisSettings+0x3ce>
    57dc:	26 30       	cpi	r18, 0x06	; 6
    57de:	31 05       	cpc	r19, r1
    57e0:	c4 f4       	brge	.+48     	; 0x5812 <defaultAxisSettings+0x114>
    57e2:	22 30       	cpi	r18, 0x02	; 2
    57e4:	31 05       	cpc	r19, r1
    57e6:	09 f4       	brne	.+2      	; 0x57ea <defaultAxisSettings+0xec>
    57e8:	cb c0       	rjmp	.+406    	; 0x5980 <defaultAxisSettings+0x282>
    57ea:	23 30       	cpi	r18, 0x03	; 3
    57ec:	31 05       	cpc	r19, r1
    57ee:	44 f4       	brge	.+16     	; 0x5800 <defaultAxisSettings+0x102>
    57f0:	21 15       	cp	r18, r1
    57f2:	31 05       	cpc	r19, r1
    57f4:	59 f1       	breq	.+86     	; 0x584c <defaultAxisSettings+0x14e>
    57f6:	21 30       	cpi	r18, 0x01	; 1
    57f8:	31 05       	cpc	r19, r1
    57fa:	09 f0       	breq	.+2      	; 0x57fe <defaultAxisSettings+0x100>
    57fc:	6b c1       	rjmp	.+726    	; 0x5ad4 <defaultAxisSettings+0x3d6>
    57fe:	73 c0       	rjmp	.+230    	; 0x58e6 <defaultAxisSettings+0x1e8>
    5800:	23 30       	cpi	r18, 0x03	; 3
    5802:	31 05       	cpc	r19, r1
    5804:	09 f4       	brne	.+2      	; 0x5808 <defaultAxisSettings+0x10a>
    5806:	05 c1       	rjmp	.+522    	; 0x5a12 <defaultAxisSettings+0x314>
    5808:	24 30       	cpi	r18, 0x04	; 4
    580a:	31 05       	cpc	r19, r1
    580c:	09 f0       	breq	.+2      	; 0x5810 <defaultAxisSettings+0x112>
    580e:	62 c1       	rjmp	.+708    	; 0x5ad4 <defaultAxisSettings+0x3d6>
    5810:	2f c1       	rjmp	.+606    	; 0x5a70 <defaultAxisSettings+0x372>
    5812:	28 30       	cpi	r18, 0x08	; 8
    5814:	31 05       	cpc	r19, r1
    5816:	09 f4       	brne	.+2      	; 0x581a <defaultAxisSettings+0x11c>
    5818:	59 c1       	rjmp	.+690    	; 0x5acc <defaultAxisSettings+0x3ce>
    581a:	29 30       	cpi	r18, 0x09	; 9
    581c:	31 05       	cpc	r19, r1
    581e:	4c f4       	brge	.+18     	; 0x5832 <defaultAxisSettings+0x134>
    5820:	26 30       	cpi	r18, 0x06	; 6
    5822:	31 05       	cpc	r19, r1
    5824:	09 f4       	brne	.+2      	; 0x5828 <defaultAxisSettings+0x12a>
    5826:	52 c1       	rjmp	.+676    	; 0x5acc <defaultAxisSettings+0x3ce>
    5828:	27 30       	cpi	r18, 0x07	; 7
    582a:	31 05       	cpc	r19, r1
    582c:	09 f0       	breq	.+2      	; 0x5830 <defaultAxisSettings+0x132>
    582e:	52 c1       	rjmp	.+676    	; 0x5ad4 <defaultAxisSettings+0x3d6>
    5830:	4d c1       	rjmp	.+666    	; 0x5acc <defaultAxisSettings+0x3ce>
    5832:	2a 30       	cpi	r18, 0x0A	; 10
    5834:	31 05       	cpc	r19, r1
    5836:	09 f4       	brne	.+2      	; 0x583a <defaultAxisSettings+0x13c>
    5838:	49 c1       	rjmp	.+658    	; 0x5acc <defaultAxisSettings+0x3ce>
    583a:	2a 30       	cpi	r18, 0x0A	; 10
    583c:	31 05       	cpc	r19, r1
    583e:	0c f4       	brge	.+2      	; 0x5842 <defaultAxisSettings+0x144>
    5840:	45 c1       	rjmp	.+650    	; 0x5acc <defaultAxisSettings+0x3ce>
    5842:	2b 30       	cpi	r18, 0x0B	; 11
    5844:	31 05       	cpc	r19, r1
    5846:	09 f0       	breq	.+2      	; 0x584a <defaultAxisSettings+0x14c>
    5848:	45 c1       	rjmp	.+650    	; 0x5ad4 <defaultAxisSettings+0x3d6>
    584a:	40 c1       	rjmp	.+640    	; 0x5acc <defaultAxisSettings+0x3ce>
{
   case AxisWaist:
		paxisSettings->motorStepsPerRevolution = 32;
    584c:	7d 87       	std	Y+13, r23	; 0x0d
    584e:	6c 87       	std	Y+12, r22	; 0x0c
		paxisSettings->numberPhases = 3;
    5850:	83 e0       	ldi	r24, 0x03	; 3
    5852:	90 e0       	ldi	r25, 0x00	; 0
    5854:	99 8f       	std	Y+25, r25	; 0x19
    5856:	88 8f       	std	Y+24, r24	; 0x18
		paxisSettings->gearNominator = 9959;      // PC needs that to change rad into usteps
    5858:	87 ee       	ldi	r24, 0xE7	; 231
    585a:	96 e2       	ldi	r25, 0x26	; 38
    585c:	9d 8f       	std	Y+29, r25	; 0x1d
    585e:	8c 8f       	std	Y+28, r24	; 0x1c
		paxisSettings->gearDenominator = 1000;	  
    5860:	88 ee       	ldi	r24, 0xE8	; 232
    5862:	93 e0       	ldi	r25, 0x03	; 3
    5864:	9f 8f       	std	Y+31, r25	; 0x1f
    5866:	8e 8f       	std	Y+30, r24	; 0x1e
		paxisSettings->maxVelocity = gradrosTOuPasos(paxisSettings,71.819,VELOCIDAD_TYPE);//80000; 
    5868:	ce 01       	movw	r24, r28
    586a:	44 e5       	ldi	r20, 0x54	; 84
    586c:	53 ea       	ldi	r21, 0xA3	; 163
    586e:	6f e8       	ldi	r22, 0x8F	; 143
    5870:	72 e4       	ldi	r23, 0x42	; 66
    5872:	21 e0       	ldi	r18, 0x01	; 1
    5874:	30 e0       	ldi	r19, 0x00	; 0
    5876:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    587a:	6c ab       	std	Y+52, r22	; 0x34
    587c:	7d ab       	std	Y+53, r23	; 0x35
    587e:	8e ab       	std	Y+54, r24	; 0x36
    5880:	9f ab       	std	Y+55, r25	; 0x37
		paxisSettings->minVelocity = gradrosTOuPasos(paxisSettings,53.864,VELOCIDAD_TYPE);//60000; 
    5882:	ce 01       	movw	r24, r28
    5884:	4c eb       	ldi	r20, 0xBC	; 188
    5886:	54 e7       	ldi	r21, 0x74	; 116
    5888:	67 e5       	ldi	r22, 0x57	; 87
    588a:	72 e4       	ldi	r23, 0x42	; 66
    588c:	21 e0       	ldi	r18, 0x01	; 1
    588e:	30 e0       	ldi	r19, 0x00	; 0
    5890:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    5894:	68 af       	std	Y+56, r22	; 0x38
    5896:	79 af       	std	Y+57, r23	; 0x39
    5898:	8a af       	std	Y+58, r24	; 0x3a
    589a:	9b af       	std	Y+59, r25	; 0x3b
		paxisSettings->homeVelocity = gradrosTOuPasos(paxisSettings,70,VELOCIDAD_TYPE);//  89111?
    589c:	ce 01       	movw	r24, r28
    589e:	40 e0       	ldi	r20, 0x00	; 0
    58a0:	50 e0       	ldi	r21, 0x00	; 0
    58a2:	6c e8       	ldi	r22, 0x8C	; 140
    58a4:	72 e4       	ldi	r23, 0x42	; 66
    58a6:	21 e0       	ldi	r18, 0x01	; 1
    58a8:	30 e0       	ldi	r19, 0x00	; 0
    58aa:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    58ae:	6c af       	std	Y+60, r22	; 0x3c
    58b0:	7d af       	std	Y+61, r23	; 0x3d
    58b2:	8e af       	std	Y+62, r24	; 0x3e
    58b4:	9f af       	std	Y+63, r25	; 0x3f
		paxisSettings->homeAcceleration= gradrosTOuPasos(paxisSettings,59.101,ACELERACION_TYPE); //40; 
    58b6:	ce 01       	movw	r24, r28
    58b8:	4d e6       	ldi	r20, 0x6D	; 109
    58ba:	57 e6       	ldi	r21, 0x67	; 103
    58bc:	6c e6       	ldi	r22, 0x6C	; 108
    58be:	72 e4       	ldi	r23, 0x42	; 66
    58c0:	22 e0       	ldi	r18, 0x02	; 2
    58c2:	30 e0       	ldi	r19, 0x00	; 0
    58c4:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    58c8:	c0 5c       	subi	r28, 0xC0	; 192
    58ca:	df 4f       	sbci	r29, 0xFF	; 255
    58cc:	68 83       	st	Y, r22
    58ce:	79 83       	std	Y+1, r23	; 0x01
    58d0:	8a 83       	std	Y+2, r24	; 0x02
    58d2:	9b 83       	std	Y+3, r25	; 0x03
    58d4:	c0 54       	subi	r28, 0x40	; 64
    58d6:	d0 40       	sbci	r29, 0x00	; 0
		paxisSettings->maxAxisAngle=122;
    58d8:	8a e7       	ldi	r24, 0x7A	; 122
    58da:	90 e0       	ldi	r25, 0x00	; 0
    58dc:	9f 83       	std	Y+7, r25	; 0x07
    58de:	8e 83       	std	Y+6, r24	; 0x06
		paxisSettings->minAxisAngle=-136;
    58e0:	88 e7       	ldi	r24, 0x78	; 120
    58e2:	9f ef       	ldi	r25, 0xFF	; 255
    58e4:	4a c0       	rjmp	.+148    	; 0x597a <defaultAxisSettings+0x27c>

    break;
    case AxisShoulder://HOMBRO
		paxisSettings->homeSwitchHandling = -1; // home = neg. limit
    58e6:	8f ef       	ldi	r24, 0xFF	; 255
    58e8:	9f ef       	ldi	r25, 0xFF	; 255
    58ea:	9b 8f       	std	Y+27, r25	; 0x1b
    58ec:	8a 8f       	std	Y+26, r24	; 0x1a
		paxisSettings->gearNominator = 11769;
    58ee:	89 ef       	ldi	r24, 0xF9	; 249
    58f0:	9d e2       	ldi	r25, 0x2D	; 45
    58f2:	9d 8f       	std	Y+29, r25	; 0x1d
    58f4:	8c 8f       	std	Y+28, r24	; 0x1c
		paxisSettings->gearDenominator = 100;
    58f6:	84 e6       	ldi	r24, 0x64	; 100
    58f8:	90 e0       	ldi	r25, 0x00	; 0
    58fa:	9f 8f       	std	Y+31, r25	; 0x1f
    58fc:	8e 8f       	std	Y+30, r24	; 0x1e
		paxisSettings->maxVelocity = gradrosTOuPasos(paxisSettings,2.6102,VELOCIDAD_TYPE);//214748; 
    58fe:	ce 01       	movw	r24, r28
    5900:	44 e8       	ldi	r20, 0x84	; 132
    5902:	5d e0       	ldi	r21, 0x0D	; 13
    5904:	67 e2       	ldi	r22, 0x27	; 39
    5906:	70 e4       	ldi	r23, 0x40	; 64
    5908:	21 e0       	ldi	r18, 0x01	; 1
    590a:	30 e0       	ldi	r19, 0x00	; 0
    590c:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    5910:	6c ab       	std	Y+52, r22	; 0x34
    5912:	7d ab       	std	Y+53, r23	; 0x35
    5914:	8e ab       	std	Y+54, r24	; 0x36
    5916:	9f ab       	std	Y+55, r25	; 0x37
		paxisSettings->minVelocity = gradrosTOuPasos(paxisSettings,0.8496,VELOCIDAD_TYPE);//69905; 
    5918:	ce 01       	movw	r24, r28
    591a:	43 e6       	ldi	r20, 0x63	; 99
    591c:	5f e7       	ldi	r21, 0x7F	; 127
    591e:	69 e5       	ldi	r22, 0x59	; 89
    5920:	7f e3       	ldi	r23, 0x3F	; 63
    5922:	21 e0       	ldi	r18, 0x01	; 1
    5924:	30 e0       	ldi	r19, 0x00	; 0
    5926:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    592a:	68 af       	std	Y+56, r22	; 0x38
    592c:	79 af       	std	Y+57, r23	; 0x39
    592e:	8a af       	std	Y+58, r24	; 0x3a
    5930:	9b af       	std	Y+59, r25	; 0x3b
	    paxisSettings->homeVelocity = gradrosTOuPasos(paxisSettings,20,VELOCIDAD_TYPE);//2468138?; 
    5932:	ce 01       	movw	r24, r28
    5934:	40 e0       	ldi	r20, 0x00	; 0
    5936:	50 e0       	ldi	r21, 0x00	; 0
    5938:	60 ea       	ldi	r22, 0xA0	; 160
    593a:	71 e4       	ldi	r23, 0x41	; 65
    593c:	21 e0       	ldi	r18, 0x01	; 1
    593e:	30 e0       	ldi	r19, 0x00	; 0
    5940:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    5944:	6c af       	std	Y+60, r22	; 0x3c
    5946:	7d af       	std	Y+61, r23	; 0x3d
    5948:	8e af       	std	Y+62, r24	; 0x3e
    594a:	9f af       	std	Y+63, r25	; 0x3f
		paxisSettings->homeAcceleration= gradrosTOuPasos(paxisSettings,9.9974,ACELERACION_TYPE);//494;  
    594c:	ce 01       	movw	r24, r28
    594e:	4a e5       	ldi	r20, 0x5A	; 90
    5950:	55 ef       	ldi	r21, 0xF5	; 245
    5952:	6f e1       	ldi	r22, 0x1F	; 31
    5954:	71 e4       	ldi	r23, 0x41	; 65
    5956:	22 e0       	ldi	r18, 0x02	; 2
    5958:	30 e0       	ldi	r19, 0x00	; 0
    595a:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    595e:	c0 5c       	subi	r28, 0xC0	; 192
    5960:	df 4f       	sbci	r29, 0xFF	; 255
    5962:	68 83       	st	Y, r22
    5964:	79 83       	std	Y+1, r23	; 0x01
    5966:	8a 83       	std	Y+2, r24	; 0x02
    5968:	9b 83       	std	Y+3, r25	; 0x03
    596a:	c0 54       	subi	r28, 0x40	; 64
    596c:	d0 40       	sbci	r29, 0x00	; 0
		paxisSettings->maxAxisAngle=10;
    596e:	8a e0       	ldi	r24, 0x0A	; 10
    5970:	90 e0       	ldi	r25, 0x00	; 0
    5972:	9f 83       	std	Y+7, r25	; 0x07
    5974:	8e 83       	std	Y+6, r24	; 0x06
		paxisSettings->minAxisAngle=-140;
    5976:	84 e7       	ldi	r24, 0x74	; 116
    5978:	9f ef       	ldi	r25, 0xFF	; 255
    597a:	99 87       	std	Y+9, r25	; 0x09
    597c:	88 87       	std	Y+8, r24	; 0x08
    597e:	aa c0       	rjmp	.+340    	; 0x5ad4 <defaultAxisSettings+0x3d6>
		
    break;
    case AxisElbow://CODO
		paxisSettings->homeSwitchHandling = 1; // home = rigth. limit
    5980:	5b 8f       	std	Y+27, r21	; 0x1b
    5982:	4a 8f       	std	Y+26, r20	; 0x1a
		paxisSettings->gearNominator = 11805;//11805//11768;//11955;  //12105;
    5984:	8d e1       	ldi	r24, 0x1D	; 29
    5986:	9e e2       	ldi	r25, 0x2E	; 46
    5988:	9d 8f       	std	Y+29, r25	; 0x1d
    598a:	8c 8f       	std	Y+28, r24	; 0x1c
		paxisSettings->gearDenominator = 100;
    598c:	84 e6       	ldi	r24, 0x64	; 100
    598e:	90 e0       	ldi	r25, 0x00	; 0
    5990:	9f 8f       	std	Y+31, r25	; 0x1f
    5992:	8e 8f       	std	Y+30, r24	; 0x1e
		paxisSettings->maxVelocity = gradrosTOuPasos(paxisSettings,1.2117,VELOCIDAD_TYPE);//100000; 
    5994:	ce 01       	movw	r24, r28
    5996:	4c ef       	ldi	r20, 0xFC	; 252
    5998:	58 e1       	ldi	r21, 0x18	; 24
    599a:	6b e9       	ldi	r22, 0x9B	; 155
    599c:	7f e3       	ldi	r23, 0x3F	; 63
    599e:	21 e0       	ldi	r18, 0x01	; 1
    59a0:	30 e0       	ldi	r19, 0x00	; 0
    59a2:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    59a6:	6c ab       	std	Y+52, r22	; 0x34
    59a8:	7d ab       	std	Y+53, r23	; 0x35
    59aa:	8e ab       	std	Y+54, r24	; 0x36
    59ac:	9f ab       	std	Y+55, r25	; 0x37
		paxisSettings->minVelocity = gradrosTOuPasos(paxisSettings,0.5965,VELOCIDAD_TYPE);//49231; 
    59ae:	ce 01       	movw	r24, r28
    59b0:	49 e3       	ldi	r20, 0x39	; 57
    59b2:	54 eb       	ldi	r21, 0xB4	; 180
    59b4:	68 e1       	ldi	r22, 0x18	; 24
    59b6:	7f e3       	ldi	r23, 0x3F	; 63
    59b8:	21 e0       	ldi	r18, 0x01	; 1
    59ba:	30 e0       	ldi	r19, 0x00	; 0
    59bc:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    59c0:	68 af       	std	Y+56, r22	; 0x38
    59c2:	79 af       	std	Y+57, r23	; 0x39
    59c4:	8a af       	std	Y+58, r24	; 0x3a
    59c6:	9b af       	std	Y+59, r25	; 0x3b
		paxisSettings->homeVelocity = gradrosTOuPasos(paxisSettings,20,VELOCIDAD_TYPE);//2475688?; 
    59c8:	ce 01       	movw	r24, r28
    59ca:	40 e0       	ldi	r20, 0x00	; 0
    59cc:	50 e0       	ldi	r21, 0x00	; 0
    59ce:	60 ea       	ldi	r22, 0xA0	; 160
    59d0:	71 e4       	ldi	r23, 0x41	; 65
    59d2:	21 e0       	ldi	r18, 0x01	; 1
    59d4:	30 e0       	ldi	r19, 0x00	; 0
    59d6:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    59da:	6c af       	std	Y+60, r22	; 0x3c
    59dc:	7d af       	std	Y+61, r23	; 0x3d
    59de:	8e af       	std	Y+62, r24	; 0x3e
    59e0:	9f af       	std	Y+63, r25	; 0x3f
		paxisSettings->homeAcceleration= gradrosTOuPasos(paxisSettings,9.9871,ACELERACION_TYPE);//495;  
    59e2:	ce 01       	movw	r24, r28
    59e4:	49 e2       	ldi	r20, 0x29	; 41
    59e6:	5b ec       	ldi	r21, 0xCB	; 203
    59e8:	6f e1       	ldi	r22, 0x1F	; 31
    59ea:	71 e4       	ldi	r23, 0x41	; 65
    59ec:	22 e0       	ldi	r18, 0x02	; 2
    59ee:	30 e0       	ldi	r19, 0x00	; 0
    59f0:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    59f4:	c0 5c       	subi	r28, 0xC0	; 192
    59f6:	df 4f       	sbci	r29, 0xFF	; 255
    59f8:	68 83       	st	Y, r22
    59fa:	79 83       	std	Y+1, r23	; 0x01
    59fc:	8a 83       	std	Y+2, r24	; 0x02
    59fe:	9b 83       	std	Y+3, r25	; 0x03
    5a00:	c0 54       	subi	r28, 0x40	; 64
    5a02:	d0 40       	sbci	r29, 0x00	; 0
		paxisSettings->maxAxisAngle=120;
    5a04:	88 e7       	ldi	r24, 0x78	; 120
    5a06:	90 e0       	ldi	r25, 0x00	; 0
    5a08:	9f 83       	std	Y+7, r25	; 0x07
    5a0a:	8e 83       	std	Y+6, r24	; 0x06
		paxisSettings->minAxisAngle=-126;
    5a0c:	82 e8       	ldi	r24, 0x82	; 130
    5a0e:	9f ef       	ldi	r25, 0xFF	; 255
    5a10:	b4 cf       	rjmp	.-152    	; 0x597a <defaultAxisSettings+0x27c>
		//paxisSettings->ustepsPerStep = 128;
		
    break;
    case AxisPitch://PITCH
		paxisSettings->homeSwitchHandling = 1; // home = rigth. limit
    5a12:	5b 8f       	std	Y+27, r21	; 0x1b
    5a14:	4a 8f       	std	Y+26, r20	; 0x1a
		paxisSettings->gearNominator = 20256;
    5a16:	80 e2       	ldi	r24, 0x20	; 32
    5a18:	9f e4       	ldi	r25, 0x4F	; 79
    5a1a:	9d 8f       	std	Y+29, r25	; 0x1d
    5a1c:	8c 8f       	std	Y+28, r24	; 0x1c
		paxisSettings->gearDenominator = 10000;// PC needs that to change rad into usteps
    5a1e:	80 e1       	ldi	r24, 0x10	; 16
    5a20:	97 e2       	ldi	r25, 0x27	; 39
    5a22:	9f 8f       	std	Y+31, r25	; 0x1f
    5a24:	8e 8f       	std	Y+30, r24	; 0x1e
		paxisSettings->homeVelocity = gradrosTOuPasos(paxisSettings,76.3825,VELOCIDAD_TYPE);//108158; // 20 deg/seg
    5a26:	ce 01       	movw	r24, r28
    5a28:	47 ed       	ldi	r20, 0xD7	; 215
    5a2a:	53 ec       	ldi	r21, 0xC3	; 195
    5a2c:	68 e9       	ldi	r22, 0x98	; 152
    5a2e:	72 e4       	ldi	r23, 0x42	; 66
    5a30:	21 e0       	ldi	r18, 0x01	; 1
    5a32:	30 e0       	ldi	r19, 0x00	; 0
    5a34:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    5a38:	6c af       	std	Y+60, r22	; 0x3c
    5a3a:	7d af       	std	Y+61, r23	; 0x3d
    5a3c:	8e af       	std	Y+62, r24	; 0x3e
    5a3e:	9f af       	std	Y+63, r25	; 0x3f
		paxisSettings->homeAcceleration= gradrosTOuPasos(paxisSettings,57.0858,ACELERACION_TYPE);//49;  // 30 deg/seg2
    5a40:	ce 01       	movw	r24, r28
    5a42:	4c ed       	ldi	r20, 0xDC	; 220
    5a44:	57 e5       	ldi	r21, 0x57	; 87
    5a46:	64 e6       	ldi	r22, 0x64	; 100
    5a48:	72 e4       	ldi	r23, 0x42	; 66
    5a4a:	22 e0       	ldi	r18, 0x02	; 2
    5a4c:	30 e0       	ldi	r19, 0x00	; 0
    5a4e:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    5a52:	c0 5c       	subi	r28, 0xC0	; 192
    5a54:	df 4f       	sbci	r29, 0xFF	; 255
    5a56:	68 83       	st	Y, r22
    5a58:	79 83       	std	Y+1, r23	; 0x01
    5a5a:	8a 83       	std	Y+2, r24	; 0x02
    5a5c:	9b 83       	std	Y+3, r25	; 0x03
    5a5e:	c0 54       	subi	r28, 0x40	; 64
    5a60:	d0 40       	sbci	r29, 0x00	; 0
		paxisSettings->maxAxisAngle=174;
    5a62:	8e ea       	ldi	r24, 0xAE	; 174
    5a64:	90 e0       	ldi	r25, 0x00	; 0
    5a66:	9f 83       	std	Y+7, r25	; 0x07
    5a68:	8e 83       	std	Y+6, r24	; 0x06
		paxisSettings->minAxisAngle=-20;
    5a6a:	8c ee       	ldi	r24, 0xEC	; 236
    5a6c:	9f ef       	ldi	r25, 0xFF	; 255
    5a6e:	85 cf       	rjmp	.-246    	; 0x597a <defaultAxisSettings+0x27c>
    break;
    case AxisRoll:
     	paxisSettings->interruptEnable= FALSE;
    5a70:	19 82       	std	Y+1, r1	; 0x01
		paxisSettings->gearNominator = 1327;
    5a72:	8f e2       	ldi	r24, 0x2F	; 47
    5a74:	95 e0       	ldi	r25, 0x05	; 5
    5a76:	9d 8f       	std	Y+29, r25	; 0x1d
    5a78:	8c 8f       	std	Y+28, r24	; 0x1c
		paxisSettings->gearDenominator = 1000;// PC needs that to change rad into usteps
    5a7a:	88 ee       	ldi	r24, 0xE8	; 232
    5a7c:	93 e0       	ldi	r25, 0x03	; 3
    5a7e:	9f 8f       	std	Y+31, r25	; 0x1f
    5a80:	8e 8f       	std	Y+30, r24	; 0x1e
		paxisSettings->homeVelocity = gradrosTOuPasos(paxisSettings,119.998,VELOCIDAD_TYPE);//111316; // 30 deg/seg
    5a82:	ce 01       	movw	r24, r28
    5a84:	4a ef       	ldi	r20, 0xFA	; 250
    5a86:	5e ef       	ldi	r21, 0xFE	; 254
    5a88:	6f ee       	ldi	r22, 0xEF	; 239
    5a8a:	72 e4       	ldi	r23, 0x42	; 66
    5a8c:	21 e0       	ldi	r18, 0x01	; 1
    5a8e:	30 e0       	ldi	r19, 0x00	; 0
    5a90:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    5a94:	6c af       	std	Y+60, r22	; 0x3c
    5a96:	7d af       	std	Y+61, r23	; 0x3d
    5a98:	8e af       	std	Y+62, r24	; 0x3e
    5a9a:	9f af       	std	Y+63, r25	; 0x3f
		paxisSettings->homeAcceleration= gradrosTOuPasos(paxisSettings,58.3918,ACELERACION_TYPE);//33;  // 30 deg/seg2
    5a9c:	ce 01       	movw	r24, r28
    5a9e:	44 e3       	ldi	r20, 0x34	; 52
    5aa0:	51 e9       	ldi	r21, 0x91	; 145
    5aa2:	69 e6       	ldi	r22, 0x69	; 105
    5aa4:	72 e4       	ldi	r23, 0x42	; 66
    5aa6:	22 e0       	ldi	r18, 0x02	; 2
    5aa8:	30 e0       	ldi	r19, 0x00	; 0
    5aaa:	0e 94 a5 2a 	call	0x554a	; 0x554a <gradrosTOuPasos>
    5aae:	c0 5c       	subi	r28, 0xC0	; 192
    5ab0:	df 4f       	sbci	r29, 0xFF	; 255
    5ab2:	68 83       	st	Y, r22
    5ab4:	79 83       	std	Y+1, r23	; 0x01
    5ab6:	8a 83       	std	Y+2, r24	; 0x02
    5ab8:	9b 83       	std	Y+3, r25	; 0x03
    5aba:	c0 54       	subi	r28, 0x40	; 64
    5abc:	d0 40       	sbci	r29, 0x00	; 0
		paxisSettings->maxAxisAngle=360;
    5abe:	88 e6       	ldi	r24, 0x68	; 104
    5ac0:	91 e0       	ldi	r25, 0x01	; 1
    5ac2:	9f 83       	std	Y+7, r25	; 0x07
    5ac4:	8e 83       	std	Y+6, r24	; 0x06
		paxisSettings->minAxisAngle=0;
    5ac6:	19 86       	std	Y+9, r1	; 0x09
    5ac8:	18 86       	std	Y+8, r1	; 0x08
    5aca:	04 c0       	rjmp	.+8      	; 0x5ad4 <defaultAxisSettings+0x3d6>
		paxisSettings->axisEnabled = FALSE;
		paxisSettings->interruptEnable= FALSE;
		paxisSettings->encoderEnable=FALSE; 
    break;
    case AxisAux7:
		paxisSettings->axisEnabled = FALSE;
    5acc:	18 82       	st	Y, r1
		paxisSettings->interruptEnable= FALSE;
    5ace:	19 82       	std	Y+1, r1	; 0x01
		paxisSettings->encoderEnable=FALSE; 
    5ad0:	1d 82       	std	Y+5, r1	; 0x05
    5ad2:	1c 82       	std	Y+4, r1	; 0x04
    break;
  } // switch
}// defaultAxisSettings
    5ad4:	df 91       	pop	r29
    5ad6:	cf 91       	pop	r28
    5ad8:	08 95       	ret

00005ada <setupAxisSettings>:

/*****************************************************************************************/
void setupAxisSettings(tAxisSettings *axisSettings) 
{
    5ada:	0f 93       	push	r16
    5adc:	1f 93       	push	r17
    5ade:	cf 93       	push	r28
    5ae0:	df 93       	push	r29
    5ae2:	8c 01       	movw	r16, r24
    5ae4:	c0 e0       	ldi	r28, 0x00	; 0
    5ae6:	d0 e0       	ldi	r29, 0x00	; 0
  int16 i;

  for(i=0; i<DOF; i++) 
  {
    defaultAxisSettings(i,&(axisSettings[i]));
    5ae8:	ce 01       	movw	r24, r28
    5aea:	b8 01       	movw	r22, r16
    5aec:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <defaultAxisSettings>
/*****************************************************************************************/
void setupAxisSettings(tAxisSettings *axisSettings) 
{
  int16 i;

  for(i=0; i<DOF; i++) 
    5af0:	21 96       	adiw	r28, 0x01	; 1
    5af2:	0c 5b       	subi	r16, 0xBC	; 188
    5af4:	1f 4f       	sbci	r17, 0xFF	; 255
    5af6:	c5 30       	cpi	r28, 0x05	; 5
    5af8:	d1 05       	cpc	r29, r1
    5afa:	b1 f7       	brne	.-20     	; 0x5ae8 <setupAxisSettings+0xe>
  {
    defaultAxisSettings(i,&(axisSettings[i]));
  }
} // setupAxisHandles
    5afc:	df 91       	pop	r29
    5afe:	cf 91       	pop	r28
    5b00:	1f 91       	pop	r17
    5b02:	0f 91       	pop	r16
    5b04:	08 95       	ret

00005b06 <initPacketIO>:

/*****************************************************************************************/
void initPacketIO(void) 
{
// initialize min and max fields for data tests (due to compiler problem with initialized structures)
	minPacketData[PacketNOP] = 0;
    5b06:	10 92 a2 28 	sts	0x28A2, r1
    5b0a:	10 92 a1 28 	sts	0x28A1, r1
	minPacketData[PacketCommand] = sizeof(tCommand);
    5b0e:	8b e1       	ldi	r24, 0x1B	; 27
    5b10:	90 e0       	ldi	r25, 0x00	; 0
    5b12:	90 93 a4 28 	sts	0x28A4, r25
    5b16:	80 93 a3 28 	sts	0x28A3, r24
	minPacketData[PacketVector] = 0;
    5b1a:	10 92 a6 28 	sts	0x28A6, r1
    5b1e:	10 92 a5 28 	sts	0x28A5, r1
	minPacketData[PacketFecha] = 0;
    5b22:	10 92 b6 28 	sts	0x28B6, r1
    5b26:	10 92 b5 28 	sts	0x28B5, r1
	minPacketData[PacketTrajectory] = sizeof(tTrajectory);
    5b2a:	86 e0       	ldi	r24, 0x06	; 6
    5b2c:	90 e0       	ldi	r25, 0x00	; 0
    5b2e:	90 93 a8 28 	sts	0x28A8, r25
    5b32:	80 93 a7 28 	sts	0x28A7, r24
	minPacketData[PacketString] = 1;
    5b36:	81 e0       	ldi	r24, 0x01	; 1
    5b38:	90 e0       	ldi	r25, 0x00	; 0
    5b3a:	90 93 ac 28 	sts	0x28AC, r25
    5b3e:	80 93 ab 28 	sts	0x28AB, r24
	minPacketData[PacketAxisSettings] = sizeof(PacketAxisSettings);
    5b42:	22 e0       	ldi	r18, 0x02	; 2
    5b44:	30 e0       	ldi	r19, 0x00	; 0
    5b46:	30 93 ae 28 	sts	0x28AE, r19
    5b4a:	20 93 ad 28 	sts	0x28AD, r18
	minPacketData[PacketAxisLimits] =sizeof(PacketAxisLimits);
    5b4e:	30 93 b0 28 	sts	0x28B0, r19
    5b52:	20 93 af 28 	sts	0x28AF, r18
	minPacketData[PacketHeader] =sizeof(tPacketHeader);
    5b56:	88 e0       	ldi	r24, 0x08	; 8
    5b58:	90 e0       	ldi	r25, 0x00	; 0
    5b5a:	90 93 b2 28 	sts	0x28B2, r25
    5b5e:	80 93 b1 28 	sts	0x28B1, r24
	minPacketData[Packetuint16] =sizeof(uint16);
    5b62:	30 93 bc 28 	sts	0x28BC, r19
    5b66:	20 93 bb 28 	sts	0x28BB, r18
} // initPacketIO
    5b6a:	08 95       	ret

00005b6c <calcChecksum>:

/*****************************************************************************************/
tDataChecksum calcChecksum(tDataLength length, uint8* pdata,tDataType dataType) 
{
    5b6c:	0f 93       	push	r16
    5b6e:	1f 93       	push	r17
    5b70:	cf 93       	push	r28
    5b72:	df 93       	push	r29
    5b74:	8c 01       	movw	r16, r24
    5b76:	eb 01       	movw	r28, r22
   tDataLength i;
   tDataChecksum sum = 0;
	tTrajectory *pTrajectory;
	int16 fin;

   if(dataType==PacketTrajectory || dataType==PacketTeachPendant)   
    5b78:	ca 01       	movw	r24, r20
    5b7a:	03 97       	sbiw	r24, 0x03	; 3
    5b7c:	02 97       	sbiw	r24, 0x02	; 2
    5b7e:	18 f5       	brcc	.+70     	; 0x5bc6 <calcChecksum+0x5a>
    5b80:	20 e0       	ldi	r18, 0x00	; 0
    5b82:	30 e0       	ldi	r19, 0x00	; 0
    5b84:	a0 e0       	ldi	r26, 0x00	; 0
    5b86:	b0 e0       	ldi	r27, 0x00	; 0
   {
        pTrajectory=(tTrajectory *)pdata;        
		//sumo los 4 primeros bytes osea los dos campos int16 (campos size e invalidMask).
		for(i=0; i<4; i++) 
			sum= sum+(tDataChecksum)pdata[i];      
    5b88:	fe 01       	movw	r30, r28
    5b8a:	e2 0f       	add	r30, r18
    5b8c:	f3 1f       	adc	r31, r19
    5b8e:	80 81       	ld	r24, Z
    5b90:	a8 0f       	add	r26, r24
    5b92:	b1 1d       	adc	r27, r1

   if(dataType==PacketTrajectory || dataType==PacketTeachPendant)   
   {
        pTrajectory=(tTrajectory *)pdata;        
		//sumo los 4 primeros bytes osea los dos campos int16 (campos size e invalidMask).
		for(i=0; i<4; i++) 
    5b94:	2f 5f       	subi	r18, 0xFF	; 255
    5b96:	3f 4f       	sbci	r19, 0xFF	; 255
    5b98:	24 30       	cpi	r18, 0x04	; 4
    5b9a:	31 05       	cpc	r19, r1
    5b9c:	a9 f7       	brne	.-22     	; 0x5b88 <calcChecksum+0x1c>
			sum= sum+(tDataChecksum)pdata[i];      
		//apunto al lo que apunta el apuntador point  
		pdata = (uint8*)pTrajectory->point;       
    5b9e:	6c 81       	ldd	r22, Y+4	; 0x04
    5ba0:	7d 81       	ldd	r23, Y+5	; 0x05
    5ba2:	20 e0       	ldi	r18, 0x00	; 0
    5ba4:	30 e0       	ldi	r19, 0x00	; 0
		//sumo todos los bytes pero a la longitud length le resto 
		//los dos campos int16 osea cuatro bytes que ya sume
		for(i=0; i<(length-4); i++) 
    5ba6:	a8 01       	movw	r20, r16
    5ba8:	44 50       	subi	r20, 0x04	; 4
    5baa:	50 40       	sbci	r21, 0x00	; 0
    5bac:	08 c0       	rjmp	.+16     	; 0x5bbe <calcChecksum+0x52>
			sum= sum+(tDataChecksum)pdata[i];     
    5bae:	fb 01       	movw	r30, r22
    5bb0:	e2 0f       	add	r30, r18
    5bb2:	f3 1f       	adc	r31, r19
    5bb4:	80 81       	ld	r24, Z
    5bb6:	a8 0f       	add	r26, r24
    5bb8:	b1 1d       	adc	r27, r1
			sum= sum+(tDataChecksum)pdata[i];      
		//apunto al lo que apunta el apuntador point  
		pdata = (uint8*)pTrajectory->point;       
		//sumo todos los bytes pero a la longitud length le resto 
		//los dos campos int16 osea cuatro bytes que ya sume
		for(i=0; i<(length-4); i++) 
    5bba:	2f 5f       	subi	r18, 0xFF	; 255
    5bbc:	3f 4f       	sbci	r19, 0xFF	; 255
    5bbe:	24 17       	cp	r18, r20
    5bc0:	35 07       	cpc	r19, r21
    5bc2:	ac f3       	brlt	.-22     	; 0x5bae <calcChecksum+0x42>
    5bc4:	2a c0       	rjmp	.+84     	; 0x5c1a <calcChecksum+0xae>
			sum= sum+(tDataChecksum)pdata[i];     
		return sum;
	} 
	if(dataType==PacketHeader)
    5bc6:	48 30       	cpi	r20, 0x08	; 8
    5bc8:	51 05       	cpc	r21, r1
    5bca:	29 f0       	breq	.+10     	; 0x5bd6 <calcChecksum+0x6a>
    5bcc:	20 e0       	ldi	r18, 0x00	; 0
    5bce:	30 e0       	ldi	r19, 0x00	; 0
    5bd0:	a0 e0       	ldi	r26, 0x00	; 0
    5bd2:	b0 e0       	ldi	r27, 0x00	; 0
    5bd4:	18 c0       	rjmp	.+48     	; 0x5c06 <calcChecksum+0x9a>
    5bd6:	20 e0       	ldi	r18, 0x00	; 0
    5bd8:	30 e0       	ldi	r19, 0x00	; 0
    5bda:	a0 e0       	ldi	r26, 0x00	; 0
    5bdc:	b0 e0       	ldi	r27, 0x00	; 0
		da como resultado un numero mayor y DIFERENTE!
		sizeof(tHeaderChecksum) = 8 byte		
		por lo tanto se suma todo menos un byte (que es el que corresponde con el campo Checksum)*/
		fin=sizeof(tPacketHeader)-sizeof(tHeaderChecksum);
		for(i=0; i<fin; i++)   
			sum += (tHeaderChecksum)pdata[i];
    5bde:	fe 01       	movw	r30, r28
    5be0:	e2 0f       	add	r30, r18
    5be2:	f3 1f       	adc	r31, r19
    5be4:	80 81       	ld	r24, Z
    5be6:	a8 0f       	add	r26, r24
    5be8:	b1 1d       	adc	r27, r1
		cero. Por lo tanto cuando se recalcula este para la trama recibida 
		da como resultado un numero mayor y DIFERENTE!
		sizeof(tHeaderChecksum) = 8 byte		
		por lo tanto se suma todo menos un byte (que es el que corresponde con el campo Checksum)*/
		fin=sizeof(tPacketHeader)-sizeof(tHeaderChecksum);
		for(i=0; i<fin; i++)   
    5bea:	2f 5f       	subi	r18, 0xFF	; 255
    5bec:	3f 4f       	sbci	r19, 0xFF	; 255
    5bee:	26 30       	cpi	r18, 0x06	; 6
    5bf0:	31 05       	cpc	r19, r1
    5bf2:	a9 f7       	brne	.-22     	; 0x5bde <calcChecksum+0x72>
    5bf4:	12 c0       	rjmp	.+36     	; 0x5c1a <calcChecksum+0xae>
			sum += (tHeaderChecksum)pdata[i];
		return sum; 
    }	
	//calquier otro paquete de datos	
      for(i=0; i<length; i++) 
          sum = sum + (tDataChecksum)pdata[i];  //calquier otro paquete de datos	
    5bf6:	fe 01       	movw	r30, r28
    5bf8:	e2 0f       	add	r30, r18
    5bfa:	f3 1f       	adc	r31, r19
    5bfc:	80 81       	ld	r24, Z
    5bfe:	a8 0f       	add	r26, r24
    5c00:	b1 1d       	adc	r27, r1
		for(i=0; i<fin; i++)   
			sum += (tHeaderChecksum)pdata[i];
		return sum; 
    }	
	//calquier otro paquete de datos	
      for(i=0; i<length; i++) 
    5c02:	2f 5f       	subi	r18, 0xFF	; 255
    5c04:	3f 4f       	sbci	r19, 0xFF	; 255
    5c06:	20 17       	cp	r18, r16
    5c08:	31 07       	cpc	r19, r17
    5c0a:	ac f3       	brlt	.-22     	; 0x5bf6 <calcChecksum+0x8a>
          printf("calcChecksum => (tDataChecksum)pdata[%d]=%X \n",i,(tDataChecksum)pdata[i]);
	#endif
	#ifdef DEBUGUSBLevel1
	printf("calcChecksum => cksum %X del paquete %s \n",sum,PacketMsg(dataType));							    
	#endif
	if(dataType==Packetuint16) //Este paquete puede contener como dato un cero, el significa pose no valida.
    5c0c:	4d 30       	cpi	r20, 0x0D	; 13
    5c0e:	51 05       	cpc	r21, r1
    5c10:	21 f4       	brne	.+8      	; 0x5c1a <calcChecksum+0xae>
	{		
		if(sum==0)
    5c12:	10 97       	sbiw	r26, 0x00	; 0
    5c14:	11 f4       	brne	.+4      	; 0x5c1a <calcChecksum+0xae>
    5c16:	a1 e0       	ldi	r26, 0x01	; 1
    5c18:	b0 e0       	ldi	r27, 0x00	; 0
			sum=1;
    }

	return sum;
} // calcChecksum
    5c1a:	cd 01       	movw	r24, r26
    5c1c:	df 91       	pop	r29
    5c1e:	cf 91       	pop	r28
    5c20:	1f 91       	pop	r17
    5c22:	0f 91       	pop	r16
    5c24:	08 95       	ret

00005c26 <checksumOk>:

/*****************************************************************************************/
int16 checksumOk (tDataLength length, uint8* data, tDataChecksum checksum,tDataType dataType) 
{
    5c26:	cf 93       	push	r28
    5c28:	df 93       	push	r29
    5c2a:	ea 01       	movw	r28, r20
	tHeaderChecksum testh;
  
	if(dataType==PacketHeader)
    5c2c:	28 30       	cpi	r18, 0x08	; 8
    5c2e:	31 05       	cpc	r19, r1
    5c30:	19 f4       	brne	.+6      	; 0x5c38 <checksumOk+0x12>
	{
		testh=(tHeaderChecksum)calcChecksum(length,data,dataType);
    5c32:	48 e0       	ldi	r20, 0x08	; 8
    5c34:	50 e0       	ldi	r21, 0x00	; 0
    5c36:	01 c0       	rjmp	.+2      	; 0x5c3a <checksumOk+0x14>
			#endif  
			return TRUE;
		}
	}
	else
    if(calcChecksum(length,data,dataType) == checksum)
    5c38:	a9 01       	movw	r20, r18
    5c3a:	0e 94 b6 2d 	call	0x5b6c	; 0x5b6c <calcChecksum>
    5c3e:	20 e0       	ldi	r18, 0x00	; 0
    5c40:	30 e0       	ldi	r19, 0x00	; 0
    5c42:	8c 17       	cp	r24, r28
    5c44:	9d 07       	cpc	r25, r29
    5c46:	11 f4       	brne	.+4      	; 0x5c4c <checksumOk+0x26>
    5c48:	21 e0       	ldi	r18, 0x01	; 1
    5c4a:	30 e0       	ldi	r19, 0x00	; 0
    5c4c:	c9 01       	movw	r24, r18
	}
	#ifdef DEBUGUSBLevel1
	printf("checksumOk=> Error CheckSum en PacketHeader = %X  \n",checksum);							    
	#endif  
	return FALSE;
} // checksumOk
    5c4e:	df 91       	pop	r29
    5c50:	cf 91       	pop	r28
    5c52:	08 95       	ret

00005c54 <readPacketHeaderRX>:

/*****************************************************************************************/
// Nota: Se llama initPacketIO() antes de usar readPacketHeaderRX para inicializar 
// la longitud de minima para cada tipo de paquete
int16 readPacketHeaderRX(tPacketHeader *ppacketHeader) 
{
    5c54:	cf 93       	push	r28
    5c56:	df 93       	push	r29
    5c58:	ec 01       	movw	r28, r24
	int16 i;
	uint8 *pdata;   
	
	pdata = (uint8*)ppacketHeader;					 
    5c5a:	bc 01       	movw	r22, r24
    5c5c:	20 e0       	ldi	r18, 0x00	; 0
    5c5e:	30 e0       	ldi	r19, 0x00	; 0
    5c60:	0d c0       	rjmp	.+26     	; 0x5c7c <readPacketHeaderRX+0x28>
	//se lee 8 bytes del buffer de datos para obtener el header
	for(i=0; i<sizeof(tPacketHeader); i++) 	
		pdata[i]=RXBUFFER[i];						 
    5c62:	fe 01       	movw	r30, r28
    5c64:	e2 0f       	add	r30, r18
    5c66:	f3 1f       	adc	r31, r19
    5c68:	a0 91 b5 79 	lds	r26, 0x79B5
    5c6c:	b0 91 b6 79 	lds	r27, 0x79B6
    5c70:	a2 0f       	add	r26, r18
    5c72:	b3 1f       	adc	r27, r19
    5c74:	8c 91       	ld	r24, X
    5c76:	80 83       	st	Z, r24
	int16 i;
	uint8 *pdata;   
	
	pdata = (uint8*)ppacketHeader;					 
	//se lee 8 bytes del buffer de datos para obtener el header
	for(i=0; i<sizeof(tPacketHeader); i++) 	
    5c78:	2f 5f       	subi	r18, 0xFF	; 255
    5c7a:	3f 4f       	sbci	r19, 0xFF	; 255
    5c7c:	28 30       	cpi	r18, 0x08	; 8
    5c7e:	31 05       	cpc	r19, r1
    5c80:	81 f7       	brne	.-32     	; 0x5c62 <readPacketHeaderRX+0xe>
		pdata[i]=RXBUFFER[i];						 
	//deteccion de errores
	// A el tipo de paquete le corresponde un numero  
	// este tiene que estar dentro el rango PacketNOP = 0 y PacketHeader = 13
	if( ( (*ppacketHeader).dataType < 0 || (*ppacketHeader).dataType > lastPacket ) ) 	
    5c82:	e8 81       	ld	r30, Y
    5c84:	f9 81       	ldd	r31, Y+1	; 0x01
    5c86:	ee 30       	cpi	r30, 0x0E	; 14
    5c88:	f1 05       	cpc	r31, r1
    5c8a:	18 f0       	brcs	.+6      	; 0x5c92 <readPacketHeaderRX+0x3e>
    5c8c:	23 e0       	ldi	r18, 0x03	; 3
    5c8e:	30 e0       	ldi	r19, 0x00	; 0
    5c90:	24 c0       	rjmp	.+72     	; 0x5cda <readPacketHeaderRX+0x86>
		return rcInvalidPacket;
	if((*ppacketHeader).dataLength < minPacketData[(*ppacketHeader).dataType]) 
    5c92:	ee 0f       	add	r30, r30
    5c94:	ff 1f       	adc	r31, r31
    5c96:	ef 55       	subi	r30, 0x5F	; 95
    5c98:	f7 4d       	sbci	r31, 0xD7	; 215
    5c9a:	2a 81       	ldd	r18, Y+2	; 0x02
    5c9c:	3b 81       	ldd	r19, Y+3	; 0x03
    5c9e:	80 81       	ld	r24, Z
    5ca0:	91 81       	ldd	r25, Z+1	; 0x01
    5ca2:	28 17       	cp	r18, r24
    5ca4:	39 07       	cpc	r19, r25
    5ca6:	1c f4       	brge	.+6      	; 0x5cae <readPacketHeaderRX+0x5a>
    5ca8:	27 e0       	ldi	r18, 0x07	; 7
    5caa:	30 e0       	ldi	r19, 0x00	; 0
    5cac:	16 c0       	rjmp	.+44     	; 0x5cda <readPacketHeaderRX+0x86>
		return rcTooFewData;
	//Compara el valor de  (*ppacketHeader).headerChecksum
	//con el calculado con el header recivido por pdata que proviene RXBUFFER
	if (!checksumOk(sizeof(tPacketHeader),pdata,(*ppacketHeader).headerChecksum,PacketHeader))
    5cae:	4e 81       	ldd	r20, Y+6	; 0x06
    5cb0:	5f 81       	ldd	r21, Y+7	; 0x07
    5cb2:	88 e0       	ldi	r24, 0x08	; 8
    5cb4:	90 e0       	ldi	r25, 0x00	; 0
    5cb6:	28 e0       	ldi	r18, 0x08	; 8
    5cb8:	30 e0       	ldi	r19, 0x00	; 0
    5cba:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <checksumOk>
    5cbe:	89 2b       	or	r24, r25
    5cc0:	19 f4       	brne	.+6      	; 0x5cc8 <readPacketHeaderRX+0x74>
    5cc2:	26 e0       	ldi	r18, 0x06	; 6
    5cc4:	30 e0       	ldi	r19, 0x00	; 0
    5cc6:	09 c0       	rjmp	.+18     	; 0x5cda <readPacketHeaderRX+0x86>
		return rcInvalidHeaderChecksum;
	//compruevo posible inconsistencia de paquete sin datos.
	/*Si el paquete es PacketTrace el *ppacketHeader).dataChecksum debe ser igual a 1 */
	if ((*ppacketHeader).dataChecksum==0)      //compruebo posible inconsistencia   
    5cc8:	8c 81       	ldd	r24, Y+4	; 0x04
    5cca:	9d 81       	ldd	r25, Y+5	; 0x05
    5ccc:	89 2b       	or	r24, r25
    5cce:	19 f0       	breq	.+6      	; 0x5cd6 <readPacketHeaderRX+0x82>
    5cd0:	20 e0       	ldi	r18, 0x00	; 0
    5cd2:	30 e0       	ldi	r19, 0x00	; 0
    5cd4:	02 c0       	rjmp	.+4      	; 0x5cda <readPacketHeaderRX+0x86>
    5cd6:	25 e0       	ldi	r18, 0x05	; 5
    5cd8:	30 e0       	ldi	r19, 0x00	; 0
			return rcInvalidChecksum;    

	return rcOK; 
} // readPacketHeader
    5cda:	c9 01       	movw	r24, r18
    5cdc:	df 91       	pop	r29
    5cde:	cf 91       	pop	r28
    5ce0:	08 95       	ret

00005ce2 <readPacketDataRX>:
/*****************************************************************************************/
//pdata es un apuntador a RXbuffer donde pdata[0] coresponde a el primer
//byte de la variable que quiero leer sin el header
//Es utilizada por todos los tipos de paquetes menos trajectory o PacketTeachPendant
int16 readPacketDataRX(tPacketHeader *ppacketHeader, uint8 *pdata) 
{
    5ce2:	0f 93       	push	r16
    5ce4:	1f 93       	push	r17
    5ce6:	cf 93       	push	r28
    5ce8:	df 93       	push	r29
    5cea:	ec 01       	movw	r28, r24
    5cec:	8b 01       	movw	r16, r22

	int16 i;
	
	tDataLength longitud;
	
	if((*ppacketHeader).dataLength != 0)
    5cee:	6a 81       	ldd	r22, Y+2	; 0x02
    5cf0:	7b 81       	ldd	r23, Y+3	; 0x03
    5cf2:	61 15       	cp	r22, r1
    5cf4:	71 05       	cpc	r23, r1
    5cf6:	19 f4       	brne	.+6      	; 0x5cfe <readPacketDataRX+0x1c>
    5cf8:	22 e0       	ldi	r18, 0x02	; 2
    5cfa:	30 e0       	ldi	r19, 0x00	; 0
    5cfc:	29 c0       	rjmp	.+82     	; 0x5d50 <readPacketDataRX+0x6e>
	{ 
		/*Si el paquete es PacketTrace su dataChecksum es igual a 1*/
		if((*ppacketHeader).dataChecksum != 0)
    5cfe:	8c 81       	ldd	r24, Y+4	; 0x04
    5d00:	9d 81       	ldd	r25, Y+5	; 0x05
    5d02:	89 2b       	or	r24, r25
    5d04:	19 f1       	breq	.+70     	; 0x5d4c <readPacketDataRX+0x6a>
    5d06:	20 e0       	ldi	r18, 0x00	; 0
    5d08:	30 e0       	ldi	r19, 0x00	; 0
    5d0a:	0d c0       	rjmp	.+26     	; 0x5d26 <readPacketDataRX+0x44>
			for(i=0; i<longitud; i++) 
				printf("readPacketDataRX=> RXBUFFER[%d]=%X\n",i,RXBUFFER[i]);							       
			#endif
			
			for(i=0; i<longitud; i++) 
				pdata[i]=RXBUFFER[i];   //pdata[0] tiene el primer dato
    5d0c:	f8 01       	movw	r30, r16
    5d0e:	e2 0f       	add	r30, r18
    5d10:	f3 1f       	adc	r31, r19
    5d12:	a0 91 b5 79 	lds	r26, 0x79B5
    5d16:	b0 91 b6 79 	lds	r27, 0x79B6
    5d1a:	a2 0f       	add	r26, r18
    5d1c:	b3 1f       	adc	r27, r19
    5d1e:	8c 91       	ld	r24, X
    5d20:	80 83       	st	Z, r24
			#ifdef DEBUGUSBLevel2
			for(i=0; i<longitud; i++) 
				printf("readPacketDataRX=> RXBUFFER[%d]=%X\n",i,RXBUFFER[i]);							       
			#endif
			
			for(i=0; i<longitud; i++) 
    5d22:	2f 5f       	subi	r18, 0xFF	; 255
    5d24:	3f 4f       	sbci	r19, 0xFF	; 255
    5d26:	26 17       	cp	r18, r22
    5d28:	37 07       	cpc	r19, r23
    5d2a:	84 f3       	brlt	.-32     	; 0x5d0c <readPacketDataRX+0x2a>
			for(i=0; i<longitud; i++) 
				printf("readPacketDataRX=> Actualizado en readPacketDataRX=> pdata[%d] =%X\n",i,pdata[i]);							       
			for(i=0; i<longitud; i++) 
				printf("readPacketDataRX=> Comprobado en readPacketDataRX=> RXBUFFER[%d]=%X\n",i,RXBUFFER[i]);							       		   
			#endif
			if((*ppacketHeader).dataType!=PacketTrace)
    5d2c:	28 81       	ld	r18, Y
    5d2e:	39 81       	ldd	r19, Y+1	; 0x01
    5d30:	2c 30       	cpi	r18, 0x0C	; 12
    5d32:	31 05       	cpc	r19, r1
    5d34:	41 f0       	breq	.+16     	; 0x5d46 <readPacketDataRX+0x64>
			{
				if( checksumOk(longitud,pdata,(*ppacketHeader).dataChecksum,(*ppacketHeader).dataType)== TRUE ) 
    5d36:	4c 81       	ldd	r20, Y+4	; 0x04
    5d38:	5d 81       	ldd	r21, Y+5	; 0x05
    5d3a:	cb 01       	movw	r24, r22
    5d3c:	b8 01       	movw	r22, r16
    5d3e:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <checksumOk>
    5d42:	01 97       	sbiw	r24, 0x01	; 1
    5d44:	19 f4       	brne	.+6      	; 0x5d4c <readPacketDataRX+0x6a>
    5d46:	20 e0       	ldi	r18, 0x00	; 0
    5d48:	30 e0       	ldi	r19, 0x00	; 0
    5d4a:	02 c0       	rjmp	.+4      	; 0x5d50 <readPacketDataRX+0x6e>
    5d4c:	25 e0       	ldi	r18, 0x05	; 5
    5d4e:	30 e0       	ldi	r19, 0x00	; 0

		}
		return  rcInvalidChecksum;
	}   	
	return rcInvalidData;
} // readPacketData
    5d50:	c9 01       	movw	r24, r18
    5d52:	df 91       	pop	r29
    5d54:	cf 91       	pop	r28
    5d56:	1f 91       	pop	r17
    5d58:	0f 91       	pop	r16
    5d5a:	08 95       	ret

00005d5c <fillPacketHeader>:
/*-------------------------------------WRITE---------------------------------------------*/
// fill the header structure and calculate the data and header checksum. Return rc

int16 fillPacketHeader(tPacketHeader *ppacketHeader, tDataType dataType, tDataLength dataLength, 
					 uint8 *pdata) 
{
    5d5c:	cf 93       	push	r28
    5d5e:	df 93       	push	r29
    5d60:	ec 01       	movw	r28, r24
    5d62:	fb 01       	movw	r30, r22
	(*ppacketHeader).dataChecksum = 0;    // will stay so if the packet has no data attached
    5d64:	1d 82       	std	Y+5, r1	; 0x05
    5d66:	1c 82       	std	Y+4, r1	; 0x04
	(*ppacketHeader).headerChecksum = 0;  // necessary initializazion for the following calculation!
    5d68:	1f 82       	std	Y+7, r1	; 0x07
    5d6a:	1e 82       	std	Y+6, r1	; 0x06
	(*ppacketHeader).dataType = dataType;
    5d6c:	79 83       	std	Y+1, r23	; 0x01
    5d6e:	68 83       	st	Y, r22
	(*ppacketHeader).dataLength = dataLength;
    5d70:	5b 83       	std	Y+3, r21	; 0x03
    5d72:	4a 83       	std	Y+2, r20	; 0x02
	if(dataType > lastPacket) 
    5d74:	6e 30       	cpi	r22, 0x0E	; 14
    5d76:	71 05       	cpc	r23, r1
    5d78:	1c f0       	brlt	.+6      	; 0x5d80 <fillPacketHeader+0x24>
    5d7a:	23 e0       	ldi	r18, 0x03	; 3
    5d7c:	30 e0       	ldi	r19, 0x00	; 0
    5d7e:	1e c0       	rjmp	.+60     	; 0x5dbc <fillPacketHeader+0x60>
		return rcInvalidPacket;  // ensure that we don't try to send invalid data:  
	if(dataLength > 0)                                 // calculate data checksum, if data is present
    5d80:	14 16       	cp	r1, r20
    5d82:	15 06       	cpc	r1, r21
    5d84:	1c f0       	brlt	.+6      	; 0x5d8c <fillPacketHeader+0x30>
    5d86:	27 e0       	ldi	r18, 0x07	; 7
    5d88:	30 e0       	ldi	r19, 0x00	; 0
    5d8a:	18 c0       	rjmp	.+48     	; 0x5dbc <fillPacketHeader+0x60>
	{
	    if((*ppacketHeader).dataType==PacketTrace)
    5d8c:	6c 30       	cpi	r22, 0x0C	; 12
    5d8e:	71 05       	cpc	r23, r1
    5d90:	19 f4       	brne	.+6      	; 0x5d98 <fillPacketHeader+0x3c>
			/*No es posible calcular el dataChecksum debido a la forma de como de manda este tipo
			de dato, se coloca a 1 para no tener problemas a la hora de leer*/
			(*ppacketHeader).dataChecksum = 1;
    5d92:	81 e0       	ldi	r24, 0x01	; 1
    5d94:	90 e0       	ldi	r25, 0x00	; 0
    5d96:	05 c0       	rjmp	.+10     	; 0x5da2 <fillPacketHeader+0x46>
		else
			(*ppacketHeader).dataChecksum = calcChecksum(dataLength,pdata,dataType); 
    5d98:	ca 01       	movw	r24, r20
    5d9a:	b9 01       	movw	r22, r18
    5d9c:	af 01       	movw	r20, r30
    5d9e:	0e 94 b6 2d 	call	0x5b6c	; 0x5b6c <calcChecksum>
    5da2:	9d 83       	std	Y+5, r25	; 0x05
    5da4:	8c 83       	std	Y+4, r24	; 0x04
	}
	else
		return rcTooFewData;       
	(*ppacketHeader).headerChecksum=(tHeaderChecksum)calcChecksum(sizeof(tPacketHeader),(uint8*)ppacketHeader,PacketHeader);
    5da6:	88 e0       	ldi	r24, 0x08	; 8
    5da8:	90 e0       	ldi	r25, 0x00	; 0
    5daa:	be 01       	movw	r22, r28
    5dac:	48 e0       	ldi	r20, 0x08	; 8
    5dae:	50 e0       	ldi	r21, 0x00	; 0
    5db0:	0e 94 b6 2d 	call	0x5b6c	; 0x5b6c <calcChecksum>
    5db4:	9f 83       	std	Y+7, r25	; 0x07
    5db6:	8e 83       	std	Y+6, r24	; 0x06
    5db8:	20 e0       	ldi	r18, 0x00	; 0
    5dba:	30 e0       	ldi	r19, 0x00	; 0
    return rcOK;
}
    5dbc:	c9 01       	movw	r24, r18
    5dbe:	df 91       	pop	r29
    5dc0:	cf 91       	pop	r28
    5dc2:	08 95       	ret

00005dc4 <Esimpar>:

#endif
/*****************************************************************************************/

int Esimpar(int i)
{
    5dc4:	62 e0       	ldi	r22, 0x02	; 2
    5dc6:	70 e0       	ldi	r23, 0x00	; 0
    5dc8:	0e 94 67 9c 	call	0x138ce	; 0x138ce <__divmodhi4>
    5dcc:	9c 01       	movw	r18, r24
    5dce:	00 97       	sbiw	r24, 0x00	; 0
    5dd0:	11 f0       	breq	.+4      	; 0x5dd6 <Esimpar+0x12>
    5dd2:	21 e0       	ldi	r18, 0x01	; 1
    5dd4:	30 e0       	ldi	r19, 0x00	; 0

	if(residuo==0)
		return FALSE;
		
	return TRUE;
}
    5dd6:	c9 01       	movw	r24, r18
    5dd8:	08 95       	ret

00005dda <Axis2AxisMask>:
/*****************************************************************************************/
#ifdef _AVR_IO_H_
// mapping which (logical) axis is to find on which MaskAxis corresponds to Axis:
AxisMask Axis2AxisMask(tAxis Axis)
{
	switch(Axis) 
    5dda:	83 30       	cpi	r24, 0x03	; 3
    5ddc:	91 05       	cpc	r25, r1
    5dde:	09 f1       	breq	.+66     	; 0x5e22 <Axis2AxisMask+0x48>
    5de0:	84 30       	cpi	r24, 0x04	; 4
    5de2:	91 05       	cpc	r25, r1
    5de4:	4c f4       	brge	.+18     	; 0x5df8 <Axis2AxisMask+0x1e>
    5de6:	81 30       	cpi	r24, 0x01	; 1
    5de8:	91 05       	cpc	r25, r1
    5dea:	91 f0       	breq	.+36     	; 0x5e10 <Axis2AxisMask+0x36>
    5dec:	82 30       	cpi	r24, 0x02	; 2
    5dee:	91 05       	cpc	r25, r1
    5df0:	ac f4       	brge	.+42     	; 0x5e1c <Axis2AxisMask+0x42>
    5df2:	89 2b       	or	r24, r25
    5df4:	81 f0       	breq	.+32     	; 0x5e16 <Axis2AxisMask+0x3c>
    5df6:	24 c0       	rjmp	.+72     	; 0x5e40 <Axis2AxisMask+0x66>
    5df8:	85 30       	cpi	r24, 0x05	; 5
    5dfa:	91 05       	cpc	r25, r1
    5dfc:	c1 f0       	breq	.+48     	; 0x5e2e <Axis2AxisMask+0x54>
    5dfe:	85 30       	cpi	r24, 0x05	; 5
    5e00:	91 05       	cpc	r25, r1
    5e02:	94 f0       	brlt	.+36     	; 0x5e28 <Axis2AxisMask+0x4e>
    5e04:	86 30       	cpi	r24, 0x06	; 6
    5e06:	91 05       	cpc	r25, r1
    5e08:	a9 f0       	breq	.+42     	; 0x5e34 <Axis2AxisMask+0x5a>
    5e0a:	07 97       	sbiw	r24, 0x07	; 7
    5e0c:	c9 f4       	brne	.+50     	; 0x5e40 <Axis2AxisMask+0x66>
    5e0e:	15 c0       	rjmp	.+42     	; 0x5e3a <Axis2AxisMask+0x60>
    5e10:	22 e0       	ldi	r18, 0x02	; 2
    5e12:	30 e0       	ldi	r19, 0x00	; 0
    5e14:	17 c0       	rjmp	.+46     	; 0x5e44 <Axis2AxisMask+0x6a>
    5e16:	21 e0       	ldi	r18, 0x01	; 1
    5e18:	30 e0       	ldi	r19, 0x00	; 0
    5e1a:	14 c0       	rjmp	.+40     	; 0x5e44 <Axis2AxisMask+0x6a>
    5e1c:	24 e0       	ldi	r18, 0x04	; 4
    5e1e:	30 e0       	ldi	r19, 0x00	; 0
    5e20:	11 c0       	rjmp	.+34     	; 0x5e44 <Axis2AxisMask+0x6a>
	{
		case AxisWaist 		: 	return WaistMask; 
		case AxisShoulder 	: 	return ShoulderMask; 
		case AxisElbow 		:	return ElbowMask; 
    5e22:	28 e0       	ldi	r18, 0x08	; 8
    5e24:	30 e0       	ldi	r19, 0x00	; 0
    5e26:	0e c0       	rjmp	.+28     	; 0x5e44 <Axis2AxisMask+0x6a>
		case AxisPitch 		: 	return PitchMask; 
    5e28:	20 e1       	ldi	r18, 0x10	; 16
    5e2a:	30 e0       	ldi	r19, 0x00	; 0
    5e2c:	0b c0       	rjmp	.+22     	; 0x5e44 <Axis2AxisMask+0x6a>
		
		case AxisRoll 		: 	return RollMask;
    5e2e:	20 e2       	ldi	r18, 0x20	; 32
    5e30:	30 e0       	ldi	r19, 0x00	; 0
    5e32:	08 c0       	rjmp	.+16     	; 0x5e44 <Axis2AxisMask+0x6a>
		case AxisAux1 		: 	return Aux1Mask; 
    5e34:	20 e4       	ldi	r18, 0x40	; 64
    5e36:	30 e0       	ldi	r19, 0x00	; 0
    5e38:	05 c0       	rjmp	.+10     	; 0x5e44 <Axis2AxisMask+0x6a>
		case AxisAux2 		: 	return Aux2Mask;    
    5e3a:	20 e8       	ldi	r18, 0x80	; 128
    5e3c:	30 e0       	ldi	r19, 0x00	; 0
    5e3e:	02 c0       	rjmp	.+4      	; 0x5e44 <Axis2AxisMask+0x6a>
		case AxisAux3 		: 	return Aux3Mask; 			
    5e40:	20 e0       	ldi	r18, 0x00	; 0
    5e42:	30 e0       	ldi	r19, 0x00	; 0
		
		default 			: 	return NOAxisMask;
	}
  return PMDAxis1;  // we must return something
} // Axis2AxisMask
    5e44:	c9 01       	movw	r24, r18
    5e46:	08 95       	ret

00005e48 <BUFFERPacketDataTX>:
}

/*****************************************************************************************/
// if data is ready, Se prepara el buffer para ser mandado almacenando la informacion necesaria en este
void BUFFERPacketDataTX(tPacketHeader *ppacketHeader, uint8 *pdata, tDataType tipo) 
{ 
    5e48:	af 92       	push	r10
    5e4a:	bf 92       	push	r11
    5e4c:	cf 92       	push	r12
    5e4e:	df 92       	push	r13
    5e50:	ef 92       	push	r14
    5e52:	ff 92       	push	r15
    5e54:	0f 93       	push	r16
    5e56:	1f 93       	push	r17
    5e58:	cf 93       	push	r28
    5e5a:	df 93       	push	r29
    5e5c:	8c 01       	movw	r16, r24
    5e5e:	eb 01       	movw	r28, r22
    5e60:	7a 01       	movw	r14, r20
  
	int16 i,j;
	tTrajectory *temp;
  
	switch (tipo)
    5e62:	43 30       	cpi	r20, 0x03	; 3
    5e64:	51 05       	cpc	r21, r1
    5e66:	0c f4       	brge	.+2      	; 0x5e6a <BUFFERPacketDataTX+0x22>
    5e68:	42 c0       	rjmp	.+132    	; 0x5eee <BUFFERPacketDataTX+0xa6>
    5e6a:	45 30       	cpi	r20, 0x05	; 5
    5e6c:	51 05       	cpc	r21, r1
    5e6e:	34 f0       	brlt	.+12     	; 0x5e7c <BUFFERPacketDataTX+0x34>
    5e70:	48 30       	cpi	r20, 0x08	; 8
    5e72:	51 05       	cpc	r21, r1
    5e74:	e1 f5       	brne	.+120    	; 0x5eee <BUFFERPacketDataTX+0xa6>
    5e76:	20 e0       	ldi	r18, 0x00	; 0
    5e78:	30 e0       	ldi	r19, 0x00	; 0
    5e7a:	11 c0       	rjmp	.+34     	; 0x5e9e <BUFFERPacketDataTX+0x56>
    5e7c:	db 01       	movw	r26, r22
    5e7e:	28 e0       	ldi	r18, 0x08	; 8
    5e80:	30 e0       	ldi	r19, 0x00	; 0
    5e82:	1b c0       	rjmp	.+54     	; 0x5eba <BUFFERPacketDataTX+0x72>
	{
		case PacketHeader:  
			// Se guarda el Header al principio de TXBUFFER
			for(i=0; i<sizeof(tPacketHeader); i++)   
				TXBUFFER[i]=pdata[i]; 
    5e84:	e0 91 b7 79 	lds	r30, 0x79B7
    5e88:	f0 91 b8 79 	lds	r31, 0x79B8
    5e8c:	e2 0f       	add	r30, r18
    5e8e:	f3 1f       	adc	r31, r19
    5e90:	de 01       	movw	r26, r28
    5e92:	a2 0f       	add	r26, r18
    5e94:	b3 1f       	adc	r27, r19
    5e96:	8c 91       	ld	r24, X
    5e98:	80 83       	st	Z, r24
  
	switch (tipo)
	{
		case PacketHeader:  
			// Se guarda el Header al principio de TXBUFFER
			for(i=0; i<sizeof(tPacketHeader); i++)   
    5e9a:	2f 5f       	subi	r18, 0xFF	; 255
    5e9c:	3f 4f       	sbci	r19, 0xFF	; 255
    5e9e:	28 30       	cpi	r18, 0x08	; 8
    5ea0:	31 05       	cpc	r19, r1
    5ea2:	81 f7       	brne	.-32     	; 0x5e84 <BUFFERPacketDataTX+0x3c>
    5ea4:	64 c0       	rjmp	.+200    	; 0x5f6e <BUFFERPacketDataTX+0x126>
		case PacketTrajectory:	
		case PacketTeachPendant:
			//me desplazo 8 bytes en TXBUFFER porque deben de contener le header																
			//copio los 4 bytes de la trayectoria, 2 campos  int16 (dummy y size)
			for(i=sizeof(tPacketHeader); i<4+sizeof(tPacketHeader); i++)   
				TXBUFFER[i]=pdata[i-sizeof(tPacketHeader)]; 
    5ea6:	e0 91 b7 79 	lds	r30, 0x79B7
    5eaa:	f0 91 b8 79 	lds	r31, 0x79B8
    5eae:	e2 0f       	add	r30, r18
    5eb0:	f3 1f       	adc	r31, r19
    5eb2:	8d 91       	ld	r24, X+
    5eb4:	80 83       	st	Z, r24
		break;
		case PacketTrajectory:	
		case PacketTeachPendant:
			//me desplazo 8 bytes en TXBUFFER porque deben de contener le header																
			//copio los 4 bytes de la trayectoria, 2 campos  int16 (dummy y size)
			for(i=sizeof(tPacketHeader); i<4+sizeof(tPacketHeader); i++)   
    5eb6:	2f 5f       	subi	r18, 0xFF	; 255
    5eb8:	3f 4f       	sbci	r19, 0xFF	; 255
    5eba:	2c 30       	cpi	r18, 0x0C	; 12
    5ebc:	31 05       	cpc	r19, r1
    5ebe:	99 f7       	brne	.-26     	; 0x5ea6 <BUFFERPacketDataTX+0x5e>
    5ec0:	ac 81       	ldd	r26, Y+4	; 0x04
    5ec2:	bd 81       	ldd	r27, Y+5	; 0x05
    5ec4:	2c e0       	ldi	r18, 0x0C	; 12
    5ec6:	30 e0       	ldi	r19, 0x00	; 0
    5ec8:	0a c0       	rjmp	.+20     	; 0x5ede <BUFFERPacketDataTX+0x96>
			//copio los datos en una variable temporal  de tipo tTrajectory para poder 	
			//acceder a el campo point y asi extraer el apuntador a los  puntos
			temp=(tTrajectory *)pdata;		
			pdata = (uint8*)temp->point;		
			for(j=i; j<ppacketHeader->dataLength+i; j++) 
				TXBUFFER[j]=pdata[j-i]; 	        
    5eca:	e0 91 b7 79 	lds	r30, 0x79B7
    5ece:	f0 91 b8 79 	lds	r31, 0x79B8
    5ed2:	e2 0f       	add	r30, r18
    5ed4:	f3 1f       	adc	r31, r19
    5ed6:	8d 91       	ld	r24, X+
    5ed8:	80 83       	st	Z, r24
				TXBUFFER[i]=pdata[i-sizeof(tPacketHeader)]; 
			//copio los datos en una variable temporal  de tipo tTrajectory para poder 	
			//acceder a el campo point y asi extraer el apuntador a los  puntos
			temp=(tTrajectory *)pdata;		
			pdata = (uint8*)temp->point;		
			for(j=i; j<ppacketHeader->dataLength+i; j++) 
    5eda:	2f 5f       	subi	r18, 0xFF	; 255
    5edc:	3f 4f       	sbci	r19, 0xFF	; 255
    5ede:	f8 01       	movw	r30, r16
    5ee0:	82 81       	ldd	r24, Z+2	; 0x02
    5ee2:	93 81       	ldd	r25, Z+3	; 0x03
    5ee4:	0c 96       	adiw	r24, 0x0c	; 12
    5ee6:	28 17       	cp	r18, r24
    5ee8:	39 07       	cpc	r19, r25
    5eea:	7c f3       	brlt	.-34     	; 0x5eca <BUFFERPacketDataTX+0x82>
    5eec:	40 c0       	rjmp	.+128    	; 0x5f6e <BUFFERPacketDataTX+0x126>
				TXBUFFER[j]=pdata[j-i]; 	        
		break;
		default:								//para todos los demas paquetes
			j=(int16)ppacketHeader->dataLength;
			j=j+sizeof(tPacketHeader);
    5eee:	d8 01       	movw	r26, r16
    5ef0:	12 96       	adiw	r26, 0x02	; 2
    5ef2:	cd 90       	ld	r12, X+
    5ef4:	dc 90       	ld	r13, X
    5ef6:	13 97       	sbiw	r26, 0x03	; 3
    5ef8:	e8 e0       	ldi	r30, 0x08	; 8
    5efa:	f0 e0       	ldi	r31, 0x00	; 0
    5efc:	ce 0e       	add	r12, r30
    5efe:	df 1e       	adc	r13, r31
    5f00:	8e 01       	movw	r16, r28
    5f02:	c8 e0       	ldi	r28, 0x08	; 8
    5f04:	d0 e0       	ldi	r29, 0x00	; 0
			for(i=sizeof(tPacketHeader);i<j;i++) 
			{
				TXBUFFER[i]=pdata[i-sizeof(tPacketHeader)]; //Coloca toda la informacion a enviar  
				if(tipo==Packetuint16)
				{
					printf("BUFFERPacketDataTX=> pdata[%d-sizeof(tPacketHeader)] = %d \n",i,pdata[i-sizeof(tPacketHeader)]);
    5f06:	9d ec       	ldi	r25, 0xCD	; 205
    5f08:	a9 2e       	mov	r10, r25
    5f0a:	96 e2       	ldi	r25, 0x26	; 38
    5f0c:	b9 2e       	mov	r11, r25
    5f0e:	2c c0       	rjmp	.+88     	; 0x5f68 <BUFFERPacketDataTX+0x120>
		default:								//para todos los demas paquetes
			j=(int16)ppacketHeader->dataLength;
			j=j+sizeof(tPacketHeader);
			for(i=sizeof(tPacketHeader);i<j;i++) 
			{
				TXBUFFER[i]=pdata[i-sizeof(tPacketHeader)]; //Coloca toda la informacion a enviar  
    5f10:	e0 91 b7 79 	lds	r30, 0x79B7
    5f14:	f0 91 b8 79 	lds	r31, 0x79B8
    5f18:	ec 0f       	add	r30, r28
    5f1a:	fd 1f       	adc	r31, r29
    5f1c:	d8 01       	movw	r26, r16
    5f1e:	8c 91       	ld	r24, X
    5f20:	80 83       	st	Z, r24
				if(tipo==Packetuint16)
    5f22:	bd e0       	ldi	r27, 0x0D	; 13
    5f24:	eb 16       	cp	r14, r27
    5f26:	f1 04       	cpc	r15, r1
    5f28:	e1 f4       	brne	.+56     	; 0x5f62 <BUFFERPacketDataTX+0x11a>
				{
					printf("BUFFERPacketDataTX=> pdata[%d-sizeof(tPacketHeader)] = %d \n",i,pdata[i-sizeof(tPacketHeader)]);
    5f2a:	00 d0       	rcall	.+0      	; 0x5f2c <BUFFERPacketDataTX+0xe4>
    5f2c:	00 d0       	rcall	.+0      	; 0x5f2e <BUFFERPacketDataTX+0xe6>
    5f2e:	00 d0       	rcall	.+0      	; 0x5f30 <BUFFERPacketDataTX+0xe8>
    5f30:	ed b7       	in	r30, 0x3d	; 61
    5f32:	fe b7       	in	r31, 0x3e	; 62
    5f34:	31 96       	adiw	r30, 0x01	; 1
    5f36:	ad b7       	in	r26, 0x3d	; 61
    5f38:	be b7       	in	r27, 0x3e	; 62
    5f3a:	12 96       	adiw	r26, 0x02	; 2
    5f3c:	bc 92       	st	X, r11
    5f3e:	ae 92       	st	-X, r10
    5f40:	11 97       	sbiw	r26, 0x01	; 1
    5f42:	d3 83       	std	Z+3, r29	; 0x03
    5f44:	c2 83       	std	Z+2, r28	; 0x02
    5f46:	d8 01       	movw	r26, r16
    5f48:	8c 91       	ld	r24, X
    5f4a:	84 83       	std	Z+4, r24	; 0x04
    5f4c:	15 82       	std	Z+5, r1	; 0x05
    5f4e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    5f52:	ed b7       	in	r30, 0x3d	; 61
    5f54:	fe b7       	in	r31, 0x3e	; 62
    5f56:	36 96       	adiw	r30, 0x06	; 6
    5f58:	0f b6       	in	r0, 0x3f	; 63
    5f5a:	f8 94       	cli
    5f5c:	fe bf       	out	0x3e, r31	; 62
    5f5e:	0f be       	out	0x3f, r0	; 63
    5f60:	ed bf       	out	0x3d, r30	; 61
				TXBUFFER[j]=pdata[j-i]; 	        
		break;
		default:								//para todos los demas paquetes
			j=(int16)ppacketHeader->dataLength;
			j=j+sizeof(tPacketHeader);
			for(i=sizeof(tPacketHeader);i<j;i++) 
    5f62:	21 96       	adiw	r28, 0x01	; 1
    5f64:	0f 5f       	subi	r16, 0xFF	; 255
    5f66:	1f 4f       	sbci	r17, 0xFF	; 255
    5f68:	cc 15       	cp	r28, r12
    5f6a:	dd 05       	cpc	r29, r13
    5f6c:	8c f2       	brlt	.-94     	; 0x5f10 <BUFFERPacketDataTX+0xc8>
				{
					printf("BUFFERPacketDataTX=> pdata[%d-sizeof(tPacketHeader)] = %d \n",i,pdata[i-sizeof(tPacketHeader)]);
				}
			}
	}  
} // sendPacketData
    5f6e:	df 91       	pop	r29
    5f70:	cf 91       	pop	r28
    5f72:	1f 91       	pop	r17
    5f74:	0f 91       	pop	r16
    5f76:	ff 90       	pop	r15
    5f78:	ef 90       	pop	r14
    5f7a:	df 90       	pop	r13
    5f7c:	cf 90       	pop	r12
    5f7e:	bf 90       	pop	r11
    5f80:	af 90       	pop	r10
    5f82:	08 95       	ret

00005f84 <Print_rxTrajectory>:
} // Axis2AxisMask


/*****************************************************************************************/
void Print_rxTrajectory(void)
{
    5f84:	2f 92       	push	r2
    5f86:	3f 92       	push	r3
    5f88:	4f 92       	push	r4
    5f8a:	5f 92       	push	r5
    5f8c:	6f 92       	push	r6
    5f8e:	7f 92       	push	r7
    5f90:	8f 92       	push	r8
    5f92:	9f 92       	push	r9
    5f94:	af 92       	push	r10
    5f96:	bf 92       	push	r11
    5f98:	cf 92       	push	r12
    5f9a:	df 92       	push	r13
    5f9c:	ef 92       	push	r14
    5f9e:	ff 92       	push	r15
    5fa0:	0f 93       	push	r16
    5fa2:	1f 93       	push	r17
    5fa4:	df 93       	push	r29
    5fa6:	cf 93       	push	r28
    5fa8:	00 d0       	rcall	.+0      	; 0x5faa <Print_rxTrajectory+0x26>
    5faa:	cd b7       	in	r28, 0x3d	; 61
    5fac:	de b7       	in	r29, 0x3e	; 62
	int16 pointIndex,axis,stop;
	
	printf("Print_rxTrajectory=> El Numero de puntos de la trayectoria es en packetIO.c => %d\n",rxTrajectory.size);
    5fae:	00 d0       	rcall	.+0      	; 0x5fb0 <Print_rxTrajectory+0x2c>
    5fb0:	00 d0       	rcall	.+0      	; 0x5fb2 <Print_rxTrajectory+0x2e>
    5fb2:	89 e0       	ldi	r24, 0x09	; 9
    5fb4:	97 e2       	ldi	r25, 0x27	; 39
    5fb6:	ed b7       	in	r30, 0x3d	; 61
    5fb8:	fe b7       	in	r31, 0x3e	; 62
    5fba:	92 83       	std	Z+2, r25	; 0x02
    5fbc:	81 83       	std	Z+1, r24	; 0x01
    5fbe:	80 91 a8 79 	lds	r24, 0x79A8
    5fc2:	90 91 a9 79 	lds	r25, 0x79A9
    5fc6:	94 83       	std	Z+4, r25	; 0x04
    5fc8:	83 83       	std	Z+3, r24	; 0x03
    5fca:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Print_rxTrajectory=> invalid mask en packetIO.c => %X\n",rxTrajectory.invalidmask);
    5fce:	8c e5       	ldi	r24, 0x5C	; 92
    5fd0:	97 e2       	ldi	r25, 0x27	; 39
    5fd2:	ed b7       	in	r30, 0x3d	; 61
    5fd4:	fe b7       	in	r31, 0x3e	; 62
    5fd6:	92 83       	std	Z+2, r25	; 0x02
    5fd8:	81 83       	std	Z+1, r24	; 0x01
    5fda:	80 91 aa 79 	lds	r24, 0x79AA
    5fde:	90 91 ab 79 	lds	r25, 0x79AB
    5fe2:	94 83       	std	Z+4, r25	; 0x04
    5fe4:	83 83       	std	Z+3, r24	; 0x03
    5fe6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    5fea:	88 24       	eor	r8, r8
    5fec:	99 24       	eor	r9, r9
    5fee:	aa 24       	eor	r10, r10
    5ff0:	bb 24       	eor	r11, r11
    5ff2:	0f 90       	pop	r0
    5ff4:	0f 90       	pop	r0
    5ff6:	0f 90       	pop	r0
    5ff8:	0f 90       	pop	r0
		{
			printf("Print_rxTrajectory=> La posicion de %s es en packetIO.c => %ld\n",AxisName(axis),
				   rxTrajectory.point[pointIndex].axis[axis].position);
			printf("Print_rxTrajectory=> La velocidad de %s es en packetIO.c => %ld\n",AxisName(axis),
				   rxTrajectory.point[pointIndex].axis[axis].velocity);
			printf("Print_rxTrajectory=> La aceleracion de %s es en packetIO.c => %ld\n",AxisName(axis),
    5ffa:	eb e5       	ldi	r30, 0x5B	; 91
    5ffc:	2e 2e       	mov	r2, r30
    5ffe:	e8 e2       	ldi	r30, 0x28	; 40
    6000:	3e 2e       	mov	r3, r30
				   rxTrajectory.point[pointIndex].axis[axis].acceleration);
			scanf("%d",&stop);
    6002:	7e e9       	ldi	r23, 0x9E	; 158
    6004:	47 2e       	mov	r4, r23
    6006:	78 e2       	ldi	r23, 0x28	; 40
    6008:	57 2e       	mov	r5, r23
    600a:	3e 01       	movw	r6, r28
    600c:	08 94       	sec
    600e:	61 1c       	adc	r6, r1
    6010:	71 1c       	adc	r7, r1
    6012:	d5 c0       	rjmp	.+426    	; 0x61be <Print_rxTrajectory+0x23a>
	printf("Print_rxTrajectory=> invalid mask en packetIO.c => %X\n",rxTrajectory.invalidmask);
	
	
	for(pointIndex=0;pointIndex < rxTrajectory.size;pointIndex++)
	{
		printf("Print_rxTrajectory=> En el punto %d de la trayectoria....(packetIO.c)\n",pointIndex+1);
    6014:	08 94       	sec
    6016:	81 1c       	adc	r8, r1
    6018:	91 1c       	adc	r9, r1
    601a:	00 d0       	rcall	.+0      	; 0x601c <Print_rxTrajectory+0x98>
    601c:	00 d0       	rcall	.+0      	; 0x601e <Print_rxTrajectory+0x9a>
    601e:	23 e9       	ldi	r18, 0x93	; 147
    6020:	37 e2       	ldi	r19, 0x27	; 39
    6022:	ed b7       	in	r30, 0x3d	; 61
    6024:	fe b7       	in	r31, 0x3e	; 62
    6026:	32 83       	std	Z+2, r19	; 0x02
    6028:	21 83       	std	Z+1, r18	; 0x01
    602a:	94 82       	std	Z+4, r9	; 0x04
    602c:	83 82       	std	Z+3, r8	; 0x03
    602e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    6032:	cc 24       	eor	r12, r12
    6034:	dd 24       	eor	r13, r13
    6036:	0f 90       	pop	r0
    6038:	0f 90       	pop	r0
    603a:	0f 90       	pop	r0
    603c:	0f 90       	pop	r0
			
		for(axis=0; axis < DOF; axis++) 
		{
			printf("Print_rxTrajectory=> La posicion de %s es en packetIO.c => %ld\n",AxisName(axis),
    603e:	c6 01       	movw	r24, r12
    6040:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    6044:	4d b7       	in	r20, 0x3d	; 61
    6046:	5e b7       	in	r21, 0x3e	; 62
    6048:	48 50       	subi	r20, 0x08	; 8
    604a:	50 40       	sbci	r21, 0x00	; 0
    604c:	0f b6       	in	r0, 0x3f	; 63
    604e:	f8 94       	cli
    6050:	5e bf       	out	0x3e, r21	; 62
    6052:	0f be       	out	0x3f, r0	; 63
    6054:	4d bf       	out	0x3d, r20	; 61
    6056:	2d b7       	in	r18, 0x3d	; 61
    6058:	3e b7       	in	r19, 0x3e	; 62
    605a:	2f 5f       	subi	r18, 0xFF	; 255
    605c:	3f 4f       	sbci	r19, 0xFF	; 255
    605e:	4a ed       	ldi	r20, 0xDA	; 218
    6060:	57 e2       	ldi	r21, 0x27	; 39
    6062:	ed b7       	in	r30, 0x3d	; 61
    6064:	fe b7       	in	r31, 0x3e	; 62
    6066:	52 83       	std	Z+2, r21	; 0x02
    6068:	41 83       	std	Z+1, r20	; 0x01
    606a:	f9 01       	movw	r30, r18
    606c:	93 83       	std	Z+3, r25	; 0x03
    606e:	82 83       	std	Z+2, r24	; 0x02
    6070:	e0 91 ac 79 	lds	r30, 0x79AC
    6074:	f0 91 ad 79 	lds	r31, 0x79AD
    6078:	ea 0d       	add	r30, r10
    607a:	fb 1d       	adc	r31, r11
    607c:	86 01       	movw	r16, r12
    607e:	00 0f       	add	r16, r16
    6080:	11 1f       	adc	r17, r17
    6082:	0c 0d       	add	r16, r12
    6084:	1d 1d       	adc	r17, r13
    6086:	78 01       	movw	r14, r16
    6088:	ee 0c       	add	r14, r14
    608a:	ff 1c       	adc	r15, r15
    608c:	ee 0c       	add	r14, r14
    608e:	ff 1c       	adc	r15, r15
    6090:	ee 0d       	add	r30, r14
    6092:	ff 1d       	adc	r31, r15
    6094:	80 81       	ld	r24, Z
    6096:	91 81       	ldd	r25, Z+1	; 0x01
    6098:	a2 81       	ldd	r26, Z+2	; 0x02
    609a:	b3 81       	ldd	r27, Z+3	; 0x03
    609c:	f9 01       	movw	r30, r18
    609e:	84 83       	std	Z+4, r24	; 0x04
    60a0:	95 83       	std	Z+5, r25	; 0x05
    60a2:	a6 83       	std	Z+6, r26	; 0x06
    60a4:	b7 83       	std	Z+7, r27	; 0x07
    60a6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
				   rxTrajectory.point[pointIndex].axis[axis].position);
			printf("Print_rxTrajectory=> La velocidad de %s es en packetIO.c => %ld\n",AxisName(axis),
    60aa:	2d b7       	in	r18, 0x3d	; 61
    60ac:	3e b7       	in	r19, 0x3e	; 62
    60ae:	28 5f       	subi	r18, 0xF8	; 248
    60b0:	3f 4f       	sbci	r19, 0xFF	; 255
    60b2:	0f b6       	in	r0, 0x3f	; 63
    60b4:	f8 94       	cli
    60b6:	3e bf       	out	0x3e, r19	; 62
    60b8:	0f be       	out	0x3f, r0	; 63
    60ba:	2d bf       	out	0x3d, r18	; 61
    60bc:	c6 01       	movw	r24, r12
    60be:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    60c2:	4d b7       	in	r20, 0x3d	; 61
    60c4:	5e b7       	in	r21, 0x3e	; 62
    60c6:	48 50       	subi	r20, 0x08	; 8
    60c8:	50 40       	sbci	r21, 0x00	; 0
    60ca:	0f b6       	in	r0, 0x3f	; 63
    60cc:	f8 94       	cli
    60ce:	5e bf       	out	0x3e, r21	; 62
    60d0:	0f be       	out	0x3f, r0	; 63
    60d2:	4d bf       	out	0x3d, r20	; 61
    60d4:	2d b7       	in	r18, 0x3d	; 61
    60d6:	3e b7       	in	r19, 0x3e	; 62
    60d8:	2f 5f       	subi	r18, 0xFF	; 255
    60da:	3f 4f       	sbci	r19, 0xFF	; 255
    60dc:	4a e1       	ldi	r20, 0x1A	; 26
    60de:	58 e2       	ldi	r21, 0x28	; 40
    60e0:	ed b7       	in	r30, 0x3d	; 61
    60e2:	fe b7       	in	r31, 0x3e	; 62
    60e4:	52 83       	std	Z+2, r21	; 0x02
    60e6:	41 83       	std	Z+1, r20	; 0x01
    60e8:	f9 01       	movw	r30, r18
    60ea:	93 83       	std	Z+3, r25	; 0x03
    60ec:	82 83       	std	Z+2, r24	; 0x02
    60ee:	e0 91 ac 79 	lds	r30, 0x79AC
    60f2:	f0 91 ad 79 	lds	r31, 0x79AD
    60f6:	ea 0d       	add	r30, r10
    60f8:	fb 1d       	adc	r31, r11
    60fa:	0f 5f       	subi	r16, 0xFF	; 255
    60fc:	1f 4f       	sbci	r17, 0xFF	; 255
    60fe:	00 0f       	add	r16, r16
    6100:	11 1f       	adc	r17, r17
    6102:	00 0f       	add	r16, r16
    6104:	11 1f       	adc	r17, r17
    6106:	e0 0f       	add	r30, r16
    6108:	f1 1f       	adc	r31, r17
    610a:	80 81       	ld	r24, Z
    610c:	91 81       	ldd	r25, Z+1	; 0x01
    610e:	a2 81       	ldd	r26, Z+2	; 0x02
    6110:	b3 81       	ldd	r27, Z+3	; 0x03
    6112:	f9 01       	movw	r30, r18
    6114:	84 83       	std	Z+4, r24	; 0x04
    6116:	95 83       	std	Z+5, r25	; 0x05
    6118:	a6 83       	std	Z+6, r26	; 0x06
    611a:	b7 83       	std	Z+7, r27	; 0x07
    611c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
				   rxTrajectory.point[pointIndex].axis[axis].velocity);
			printf("Print_rxTrajectory=> La aceleracion de %s es en packetIO.c => %ld\n",AxisName(axis),
    6120:	2d b7       	in	r18, 0x3d	; 61
    6122:	3e b7       	in	r19, 0x3e	; 62
    6124:	28 5f       	subi	r18, 0xF8	; 248
    6126:	3f 4f       	sbci	r19, 0xFF	; 255
    6128:	0f b6       	in	r0, 0x3f	; 63
    612a:	f8 94       	cli
    612c:	3e bf       	out	0x3e, r19	; 62
    612e:	0f be       	out	0x3f, r0	; 63
    6130:	2d bf       	out	0x3d, r18	; 61
    6132:	c6 01       	movw	r24, r12
    6134:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    6138:	4d b7       	in	r20, 0x3d	; 61
    613a:	5e b7       	in	r21, 0x3e	; 62
    613c:	48 50       	subi	r20, 0x08	; 8
    613e:	50 40       	sbci	r21, 0x00	; 0
    6140:	0f b6       	in	r0, 0x3f	; 63
    6142:	f8 94       	cli
    6144:	5e bf       	out	0x3e, r21	; 62
    6146:	0f be       	out	0x3f, r0	; 63
    6148:	4d bf       	out	0x3d, r20	; 61
    614a:	2d b7       	in	r18, 0x3d	; 61
    614c:	3e b7       	in	r19, 0x3e	; 62
    614e:	2f 5f       	subi	r18, 0xFF	; 255
    6150:	3f 4f       	sbci	r19, 0xFF	; 255
    6152:	ed b7       	in	r30, 0x3d	; 61
    6154:	fe b7       	in	r31, 0x3e	; 62
    6156:	32 82       	std	Z+2, r3	; 0x02
    6158:	21 82       	std	Z+1, r2	; 0x01
    615a:	f9 01       	movw	r30, r18
    615c:	93 83       	std	Z+3, r25	; 0x03
    615e:	82 83       	std	Z+2, r24	; 0x02
    6160:	e0 91 ac 79 	lds	r30, 0x79AC
    6164:	f0 91 ad 79 	lds	r31, 0x79AD
    6168:	ea 0d       	add	r30, r10
    616a:	fb 1d       	adc	r31, r11
    616c:	ee 0d       	add	r30, r14
    616e:	ff 1d       	adc	r31, r15
    6170:	80 85       	ldd	r24, Z+8	; 0x08
    6172:	91 85       	ldd	r25, Z+9	; 0x09
    6174:	a2 85       	ldd	r26, Z+10	; 0x0a
    6176:	b3 85       	ldd	r27, Z+11	; 0x0b
    6178:	f9 01       	movw	r30, r18
    617a:	84 83       	std	Z+4, r24	; 0x04
    617c:	95 83       	std	Z+5, r25	; 0x05
    617e:	a6 83       	std	Z+6, r26	; 0x06
    6180:	b7 83       	std	Z+7, r27	; 0x07
    6182:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
				   rxTrajectory.point[pointIndex].axis[axis].acceleration);
			scanf("%d",&stop);
    6186:	0f 90       	pop	r0
    6188:	0f 90       	pop	r0
    618a:	0f 90       	pop	r0
    618c:	0f 90       	pop	r0
    618e:	ed b7       	in	r30, 0x3d	; 61
    6190:	fe b7       	in	r31, 0x3e	; 62
    6192:	52 82       	std	Z+2, r5	; 0x02
    6194:	41 82       	std	Z+1, r4	; 0x01
    6196:	74 82       	std	Z+4, r7	; 0x04
    6198:	63 82       	std	Z+3, r6	; 0x03
    619a:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
	
	for(pointIndex=0;pointIndex < rxTrajectory.size;pointIndex++)
	{
		printf("Print_rxTrajectory=> En el punto %d de la trayectoria....(packetIO.c)\n",pointIndex+1);
			
		for(axis=0; axis < DOF; axis++) 
    619e:	08 94       	sec
    61a0:	c1 1c       	adc	r12, r1
    61a2:	d1 1c       	adc	r13, r1
    61a4:	0f 90       	pop	r0
    61a6:	0f 90       	pop	r0
    61a8:	0f 90       	pop	r0
    61aa:	0f 90       	pop	r0
    61ac:	f5 e0       	ldi	r31, 0x05	; 5
    61ae:	cf 16       	cp	r12, r31
    61b0:	d1 04       	cpc	r13, r1
    61b2:	09 f0       	breq	.+2      	; 0x61b6 <Print_rxTrajectory+0x232>
    61b4:	44 cf       	rjmp	.-376    	; 0x603e <Print_rxTrajectory+0xba>
    61b6:	2d e3       	ldi	r18, 0x3D	; 61
    61b8:	30 e0       	ldi	r19, 0x00	; 0
    61ba:	a2 0e       	add	r10, r18
    61bc:	b3 1e       	adc	r11, r19
	
	printf("Print_rxTrajectory=> El Numero de puntos de la trayectoria es en packetIO.c => %d\n",rxTrajectory.size);
	printf("Print_rxTrajectory=> invalid mask en packetIO.c => %X\n",rxTrajectory.invalidmask);
	
	
	for(pointIndex=0;pointIndex < rxTrajectory.size;pointIndex++)
    61be:	80 91 a8 79 	lds	r24, 0x79A8
    61c2:	90 91 a9 79 	lds	r25, 0x79A9
    61c6:	88 16       	cp	r8, r24
    61c8:	99 06       	cpc	r9, r25
    61ca:	0c f4       	brge	.+2      	; 0x61ce <Print_rxTrajectory+0x24a>
    61cc:	23 cf       	rjmp	.-442    	; 0x6014 <Print_rxTrajectory+0x90>
				   rxTrajectory.point[pointIndex].axis[axis].acceleration);
			scanf("%d",&stop);
			
		} 
	}	
}
    61ce:	0f 90       	pop	r0
    61d0:	0f 90       	pop	r0
    61d2:	cf 91       	pop	r28
    61d4:	df 91       	pop	r29
    61d6:	1f 91       	pop	r17
    61d8:	0f 91       	pop	r16
    61da:	ff 90       	pop	r15
    61dc:	ef 90       	pop	r14
    61de:	df 90       	pop	r13
    61e0:	cf 90       	pop	r12
    61e2:	bf 90       	pop	r11
    61e4:	af 90       	pop	r10
    61e6:	9f 90       	pop	r9
    61e8:	8f 90       	pop	r8
    61ea:	7f 90       	pop	r7
    61ec:	6f 90       	pop	r6
    61ee:	5f 90       	pop	r5
    61f0:	4f 90       	pop	r4
    61f2:	3f 90       	pop	r3
    61f4:	2f 90       	pop	r2
    61f6:	08 95       	ret

000061f8 <BUFFERunit16TX>:
}



int BUFFERunit16TX(uint8 * unit16TX) 
{
    61f8:	cf 92       	push	r12
    61fa:	df 92       	push	r13
    61fc:	ef 92       	push	r14
    61fe:	ff 92       	push	r15
    6200:	0f 93       	push	r16
    6202:	1f 93       	push	r17
    6204:	df 93       	push	r29
    6206:	cf 93       	push	r28
    6208:	cd b7       	in	r28, 0x3d	; 61
    620a:	de b7       	in	r29, 0x3e	; 62
    620c:	28 97       	sbiw	r28, 0x08	; 8
    620e:	0f b6       	in	r0, 0x3f	; 63
    6210:	f8 94       	cli
    6212:	de bf       	out	0x3e, r29	; 62
    6214:	0f be       	out	0x3f, r0	; 63
    6216:	cd bf       	out	0x3d, r28	; 61
    6218:	6c 01       	movw	r12, r24
	tPacketHeader packetHeader;
	int16 buffersize,Datasize;


	buffersize=sizeof(uint16) +sizeof(tPacketHeader);		   
	if(Esimpar(buffersize))
    621a:	8a e0       	ldi	r24, 0x0A	; 10
    621c:	90 e0       	ldi	r25, 0x00	; 0
    621e:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <Esimpar>
    6222:	89 2b       	or	r24, r25
    6224:	21 f4       	brne	.+8      	; 0x622e <BUFFERunit16TX+0x36>
    6226:	aa e0       	ldi	r26, 0x0A	; 10
    6228:	ea 2e       	mov	r14, r26
    622a:	f1 2c       	mov	r15, r1
    622c:	03 c0       	rjmp	.+6      	; 0x6234 <BUFFERunit16TX+0x3c>
    622e:	fb e0       	ldi	r31, 0x0B	; 11
    6230:	ef 2e       	mov	r14, r31
    6232:	f1 2c       	mov	r15, r1
	else
	{
		Datasize=buffersize-8;	
	}
		
	TXBUFFER=(uint8*)declarar(buffersize);
    6234:	c7 01       	movw	r24, r14
    6236:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    623a:	90 93 b8 79 	sts	0x79B8, r25
    623e:	80 93 b7 79 	sts	0x79B7, r24
	printf("BUFFERunit16TX => cantidad a mandar al PC %X\n",buffersize);			
	printf("BUFFERunit16TX => Datasize de 8bit = %X\n",Datasize);	
	printf("BUFFERunit16TX => *unit16TX => %d\n",*unit16TX);	
				
	#endif		
	fillPacketHeader(&packetHeader,Packetuint16,Datasize,(uint8*)unit16TX);
    6242:	8e 01       	movw	r16, r28
    6244:	0f 5f       	subi	r16, 0xFF	; 255
    6246:	1f 4f       	sbci	r17, 0xFF	; 255
    6248:	c8 01       	movw	r24, r16
    624a:	6d e0       	ldi	r22, 0x0D	; 13
    624c:	70 e0       	ldi	r23, 0x00	; 0
    624e:	42 e0       	ldi	r20, 0x02	; 2
    6250:	50 e0       	ldi	r21, 0x00	; 0
    6252:	96 01       	movw	r18, r12
    6254:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    6258:	c8 01       	movw	r24, r16
    625a:	b8 01       	movw	r22, r16
    625c:	48 e0       	ldi	r20, 0x08	; 8
    625e:	50 e0       	ldi	r21, 0x00	; 0
    6260:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	// meto a Fecha en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,unit16TX,Packetuint16);    
    6264:	c8 01       	movw	r24, r16
    6266:	b6 01       	movw	r22, r12
    6268:	4d e0       	ldi	r20, 0x0D	; 13
    626a:	50 e0       	ldi	r21, 0x00	; 0
    626c:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	return buffersize;
}
    6270:	c7 01       	movw	r24, r14
    6272:	28 96       	adiw	r28, 0x08	; 8
    6274:	0f b6       	in	r0, 0x3f	; 63
    6276:	f8 94       	cli
    6278:	de bf       	out	0x3e, r29	; 62
    627a:	0f be       	out	0x3f, r0	; 63
    627c:	cd bf       	out	0x3d, r28	; 61
    627e:	cf 91       	pop	r28
    6280:	df 91       	pop	r29
    6282:	1f 91       	pop	r17
    6284:	0f 91       	pop	r16
    6286:	ff 90       	pop	r15
    6288:	ef 90       	pop	r14
    628a:	df 90       	pop	r13
    628c:	cf 90       	pop	r12
    628e:	08 95       	ret

00006290 <BUFFERTraceTX>:

/*****************************************************************************************/
/*TraceTX la direccion del apuntador del primer dato*/
/*Esta funcion mete en TXBUFFER los datos del trazador*/
int BUFFERTraceTX(uint8 * TraceTX) 
{
    6290:	af 92       	push	r10
    6292:	bf 92       	push	r11
    6294:	cf 92       	push	r12
    6296:	df 92       	push	r13
    6298:	ef 92       	push	r14
    629a:	ff 92       	push	r15
    629c:	0f 93       	push	r16
    629e:	1f 93       	push	r17
    62a0:	df 93       	push	r29
    62a2:	cf 93       	push	r28
    62a4:	cd b7       	in	r28, 0x3d	; 61
    62a6:	de b7       	in	r29, 0x3e	; 62
    62a8:	28 97       	sbiw	r28, 0x08	; 8
    62aa:	0f b6       	in	r0, 0x3f	; 63
    62ac:	f8 94       	cli
    62ae:	de bf       	out	0x3e, r29	; 62
    62b0:	0f be       	out	0x3f, r0	; 63
    62b2:	cd bf       	out	0x3d, r28	; 61
    62b4:	5c 01       	movw	r10, r24
	int32     *pTraceBuffer;
	tPacketHeader packetHeader;
	int16 buffersize,Datasize;
	/*Estructuro el buffer a 32 bits*/
    pTraceBuffer=(int32*)TraceTX;
	buffersize=(  pTraceBuffer[0]*sizeof(int32)) +sizeof(tPacketHeader)+(sizeof(int32)*3);		   
    62b6:	fc 01       	movw	r30, r24
    62b8:	80 81       	ld	r24, Z
    62ba:	91 81       	ldd	r25, Z+1	; 0x01
    62bc:	a2 81       	ldd	r26, Z+2	; 0x02
    62be:	b3 81       	ldd	r27, Z+3	; 0x03
    62c0:	05 96       	adiw	r24, 0x05	; 5
    62c2:	a1 1d       	adc	r26, r1
    62c4:	b1 1d       	adc	r27, r1
    62c6:	02 e0       	ldi	r16, 0x02	; 2
    62c8:	88 0f       	add	r24, r24
    62ca:	99 1f       	adc	r25, r25
    62cc:	aa 1f       	adc	r26, r26
    62ce:	bb 1f       	adc	r27, r27
    62d0:	0a 95       	dec	r16
    62d2:	d1 f7       	brne	.-12     	; 0x62c8 <BUFFERTraceTX+0x38>
    62d4:	7c 01       	movw	r14, r24
	if(Esimpar(buffersize))
    62d6:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <Esimpar>
    62da:	89 2b       	or	r24, r25
    62dc:	41 f0       	breq	.+16     	; 0x62ee <BUFFERTraceTX+0x5e>
	{
		buffersize++;		
    62de:	08 94       	sec
    62e0:	e1 1c       	adc	r14, r1
    62e2:	f1 1c       	adc	r15, r1
		Datasize=buffersize-(sizeof(tPacketHeader)+1);	
    62e4:	17 ef       	ldi	r17, 0xF7	; 247
    62e6:	c1 2e       	mov	r12, r17
    62e8:	1f ef       	ldi	r17, 0xFF	; 255
    62ea:	d1 2e       	mov	r13, r17
    62ec:	04 c0       	rjmp	.+8      	; 0x62f6 <BUFFERTraceTX+0x66>
	}
	else
	{
		Datasize=buffersize-8;	
    62ee:	b8 ef       	ldi	r27, 0xF8	; 248
    62f0:	cb 2e       	mov	r12, r27
    62f2:	bf ef       	ldi	r27, 0xFF	; 255
    62f4:	db 2e       	mov	r13, r27
    62f6:	ce 0c       	add	r12, r14
    62f8:	df 1c       	adc	r13, r15
	}
		
	TXBUFFER=(uint8*)declarar(buffersize);
    62fa:	c7 01       	movw	r24, r14
    62fc:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    6300:	90 93 b8 79 	sts	0x79B8, r25
    6304:	80 93 b7 79 	sts	0x79B7, r24
	#ifdef DEBUGUSBLevel1
	printf("BUFFERTraceTX => cantidad a mandar al PC %X\n",buffersize);			
	printf("BUFFERTraceTX => Datasize de 8bit = %X\n",Datasize);			
	printf("BUFFERTraceTX => Cantidad de datos de 32bit = %lX\n",pTraceBuffer[0]);			
	#endif		
	fillPacketHeader(&packetHeader,PacketTrace,Datasize,(uint8*)TraceTX);
    6308:	8e 01       	movw	r16, r28
    630a:	0f 5f       	subi	r16, 0xFF	; 255
    630c:	1f 4f       	sbci	r17, 0xFF	; 255
    630e:	c8 01       	movw	r24, r16
    6310:	6c e0       	ldi	r22, 0x0C	; 12
    6312:	70 e0       	ldi	r23, 0x00	; 0
    6314:	a6 01       	movw	r20, r12
    6316:	95 01       	movw	r18, r10
    6318:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    631c:	c8 01       	movw	r24, r16
    631e:	b8 01       	movw	r22, r16
    6320:	48 e0       	ldi	r20, 0x08	; 8
    6322:	50 e0       	ldi	r21, 0x00	; 0
    6324:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	// meto a Fecha en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,TraceTX,PacketTrace);    
    6328:	c8 01       	movw	r24, r16
    632a:	b5 01       	movw	r22, r10
    632c:	4c e0       	ldi	r20, 0x0C	; 12
    632e:	50 e0       	ldi	r21, 0x00	; 0
    6330:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	return buffersize;
}
    6334:	c7 01       	movw	r24, r14
    6336:	28 96       	adiw	r28, 0x08	; 8
    6338:	0f b6       	in	r0, 0x3f	; 63
    633a:	f8 94       	cli
    633c:	de bf       	out	0x3e, r29	; 62
    633e:	0f be       	out	0x3f, r0	; 63
    6340:	cd bf       	out	0x3d, r28	; 61
    6342:	cf 91       	pop	r28
    6344:	df 91       	pop	r29
    6346:	1f 91       	pop	r17
    6348:	0f 91       	pop	r16
    634a:	ff 90       	pop	r15
    634c:	ef 90       	pop	r14
    634e:	df 90       	pop	r13
    6350:	cf 90       	pop	r12
    6352:	bf 90       	pop	r11
    6354:	af 90       	pop	r10
    6356:	08 95       	ret

00006358 <BUFFERAlarmaTX>:
	return buffersize;
} 

/*****************************************************************************************/
int BUFFERAlarmaTX(uint8 * AlarmaTX) 
{
    6358:	cf 92       	push	r12
    635a:	df 92       	push	r13
    635c:	ef 92       	push	r14
    635e:	ff 92       	push	r15
    6360:	0f 93       	push	r16
    6362:	1f 93       	push	r17
    6364:	df 93       	push	r29
    6366:	cf 93       	push	r28
    6368:	cd b7       	in	r28, 0x3d	; 61
    636a:	de b7       	in	r29, 0x3e	; 62
    636c:	28 97       	sbiw	r28, 0x08	; 8
    636e:	0f b6       	in	r0, 0x3f	; 63
    6370:	f8 94       	cli
    6372:	de bf       	out	0x3e, r29	; 62
    6374:	0f be       	out	0x3f, r0	; 63
    6376:	cd bf       	out	0x3d, r28	; 61
    6378:	6c 01       	movw	r12, r24
	#ifdef DEBUGUSBLevel2
	int16 j;
	#endif		
    
	buffersize=sizeof(tAlarm)+sizeof(tPacketHeader);		   
	if(Esimpar(buffersize))
    637a:	8f e0       	ldi	r24, 0x0F	; 15
    637c:	90 e0       	ldi	r25, 0x00	; 0
    637e:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <Esimpar>
    6382:	89 2b       	or	r24, r25
    6384:	21 f4       	brne	.+8      	; 0x638e <BUFFERAlarmaTX+0x36>
    6386:	9f e0       	ldi	r25, 0x0F	; 15
    6388:	e9 2e       	mov	r14, r25
    638a:	f1 2c       	mov	r15, r1
    638c:	03 c0       	rjmp	.+6      	; 0x6394 <BUFFERAlarmaTX+0x3c>
    638e:	80 e1       	ldi	r24, 0x10	; 16
    6390:	e8 2e       	mov	r14, r24
    6392:	f1 2c       	mov	r15, r1
	else
	{
		Datasize=buffersize-8;	
	}
		
	TXBUFFER=(uint8*)declarar(buffersize);
    6394:	c7 01       	movw	r24, r14
    6396:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    639a:	90 93 b8 79 	sts	0x79B8, r25
    639e:	80 93 b7 79 	sts	0x79B7, r24
	#endif		
	#ifdef DEBUGUSBLevel1
	printf("BUFFERFechaTX => cantidad a mandar al PC %X\n",buffersize);			
	printf("BUFFERFechaTX => Datasize = %X\n",Datasize);			
	#endif		
	fillPacketHeader(&packetHeader,PacketAlarma,Datasize,(uint8*)AlarmaTX);
    63a2:	8e 01       	movw	r16, r28
    63a4:	0f 5f       	subi	r16, 0xFF	; 255
    63a6:	1f 4f       	sbci	r17, 0xFF	; 255
    63a8:	c8 01       	movw	r24, r16
    63aa:	6b e0       	ldi	r22, 0x0B	; 11
    63ac:	70 e0       	ldi	r23, 0x00	; 0
    63ae:	47 e0       	ldi	r20, 0x07	; 7
    63b0:	50 e0       	ldi	r21, 0x00	; 0
    63b2:	96 01       	movw	r18, r12
    63b4:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    63b8:	c8 01       	movw	r24, r16
    63ba:	b8 01       	movw	r22, r16
    63bc:	48 e0       	ldi	r20, 0x08	; 8
    63be:	50 e0       	ldi	r21, 0x00	; 0
    63c0:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	// meto a Fecha en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,(uint8*)AlarmaTX,PacketAlarma);    
    63c4:	c8 01       	movw	r24, r16
    63c6:	b6 01       	movw	r22, r12
    63c8:	4b e0       	ldi	r20, 0x0B	; 11
    63ca:	50 e0       	ldi	r21, 0x00	; 0
    63cc:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	return buffersize;
} 
    63d0:	c7 01       	movw	r24, r14
    63d2:	28 96       	adiw	r28, 0x08	; 8
    63d4:	0f b6       	in	r0, 0x3f	; 63
    63d6:	f8 94       	cli
    63d8:	de bf       	out	0x3e, r29	; 62
    63da:	0f be       	out	0x3f, r0	; 63
    63dc:	cd bf       	out	0x3d, r28	; 61
    63de:	cf 91       	pop	r28
    63e0:	df 91       	pop	r29
    63e2:	1f 91       	pop	r17
    63e4:	0f 91       	pop	r16
    63e6:	ff 90       	pop	r15
    63e8:	ef 90       	pop	r14
    63ea:	df 90       	pop	r13
    63ec:	cf 90       	pop	r12
    63ee:	08 95       	ret

000063f0 <BUFFERFechaTX>:
} 

/*****************************************************************************************/

int BUFFERFechaTX(uint8 * Fecha) 
{
    63f0:	cf 92       	push	r12
    63f2:	df 92       	push	r13
    63f4:	ef 92       	push	r14
    63f6:	ff 92       	push	r15
    63f8:	0f 93       	push	r16
    63fa:	1f 93       	push	r17
    63fc:	df 93       	push	r29
    63fe:	cf 93       	push	r28
    6400:	cd b7       	in	r28, 0x3d	; 61
    6402:	de b7       	in	r29, 0x3e	; 62
    6404:	28 97       	sbiw	r28, 0x08	; 8
    6406:	0f b6       	in	r0, 0x3f	; 63
    6408:	f8 94       	cli
    640a:	de bf       	out	0x3e, r29	; 62
    640c:	0f be       	out	0x3f, r0	; 63
    640e:	cd bf       	out	0x3d, r28	; 61
    6410:	6c 01       	movw	r12, r24
	#ifdef DEBUGUSBLevel2
	int16 j;
	#endif		
    
	buffersize=sizeof(tFecha)+sizeof(tPacketHeader);		   
	if(Esimpar(buffersize))
    6412:	80 e1       	ldi	r24, 0x10	; 16
    6414:	90 e0       	ldi	r25, 0x00	; 0
    6416:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <Esimpar>
    641a:	89 2b       	or	r24, r25
    641c:	21 f4       	brne	.+8      	; 0x6426 <BUFFERFechaTX+0x36>
    641e:	30 e1       	ldi	r19, 0x10	; 16
    6420:	e3 2e       	mov	r14, r19
    6422:	f1 2c       	mov	r15, r1
    6424:	03 c0       	rjmp	.+6      	; 0x642c <BUFFERFechaTX+0x3c>
    6426:	21 e1       	ldi	r18, 0x11	; 17
    6428:	e2 2e       	mov	r14, r18
    642a:	f1 2c       	mov	r15, r1
	}
	else
	{
		Datasize=buffersize-sizeof(tPacketHeader);	
	}
	TXBUFFER=(uint8*)declarar(buffersize);
    642c:	c7 01       	movw	r24, r14
    642e:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    6432:	90 93 b8 79 	sts	0x79B8, r25
    6436:	80 93 b7 79 	sts	0x79B7, r24
	#endif		
	#ifdef DEBUGUSBLevel1
	printf("BUFFERFechaTX => cantidad a mandar al PC %X\n",buffersize);			
	printf("BUFFERFechaTX => Datasize = %X\n",Datasize);			
	#endif		
	fillPacketHeader(&packetHeader,PacketFecha,Datasize,(uint8*)Fecha);
    643a:	8e 01       	movw	r16, r28
    643c:	0f 5f       	subi	r16, 0xFF	; 255
    643e:	1f 4f       	sbci	r17, 0xFF	; 255
    6440:	c8 01       	movw	r24, r16
    6442:	6a e0       	ldi	r22, 0x0A	; 10
    6444:	70 e0       	ldi	r23, 0x00	; 0
    6446:	48 e0       	ldi	r20, 0x08	; 8
    6448:	50 e0       	ldi	r21, 0x00	; 0
    644a:	96 01       	movw	r18, r12
    644c:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    6450:	c8 01       	movw	r24, r16
    6452:	b8 01       	movw	r22, r16
    6454:	48 e0       	ldi	r20, 0x08	; 8
    6456:	50 e0       	ldi	r21, 0x00	; 0
    6458:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	// meto a Fecha en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,(uint8*)Fecha,PacketFecha);    
    645c:	c8 01       	movw	r24, r16
    645e:	b6 01       	movw	r22, r12
    6460:	4a e0       	ldi	r20, 0x0A	; 10
    6462:	50 e0       	ldi	r21, 0x00	; 0
    6464:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	return buffersize;
} 
    6468:	c7 01       	movw	r24, r14
    646a:	28 96       	adiw	r28, 0x08	; 8
    646c:	0f b6       	in	r0, 0x3f	; 63
    646e:	f8 94       	cli
    6470:	de bf       	out	0x3e, r29	; 62
    6472:	0f be       	out	0x3f, r0	; 63
    6474:	cd bf       	out	0x3d, r28	; 61
    6476:	cf 91       	pop	r28
    6478:	df 91       	pop	r29
    647a:	1f 91       	pop	r17
    647c:	0f 91       	pop	r16
    647e:	ff 90       	pop	r15
    6480:	ef 90       	pop	r14
    6482:	df 90       	pop	r13
    6484:	cf 90       	pop	r12
    6486:	08 95       	ret

00006488 <BUFFERVectorPoseTX>:
	return buffersize;
} // sendAxisLimits

/*****************************************************************************************/
int BUFFERVectorPoseTX(uint8 * pVectorpose) 
{
    6488:	af 92       	push	r10
    648a:	bf 92       	push	r11
    648c:	cf 92       	push	r12
    648e:	df 92       	push	r13
    6490:	ef 92       	push	r14
    6492:	ff 92       	push	r15
    6494:	0f 93       	push	r16
    6496:	1f 93       	push	r17
    6498:	df 93       	push	r29
    649a:	cf 93       	push	r28
    649c:	cd b7       	in	r28, 0x3d	; 61
    649e:	de b7       	in	r29, 0x3e	; 62
    64a0:	28 97       	sbiw	r28, 0x08	; 8
    64a2:	0f b6       	in	r0, 0x3f	; 63
    64a4:	f8 94       	cli
    64a6:	de bf       	out	0x3e, r29	; 62
    64a8:	0f be       	out	0x3f, r0	; 63
    64aa:	cd bf       	out	0x3d, r28	; 61
    64ac:	5c 01       	movw	r10, r24
	pvectortemp=(int16*)pVectorpose;
    Num_data=pvectortemp[0];
	#ifdef DEBUGUSBLevel1
	printf("BUFFERVectorPoseTX => Numero de datos en pvectortemp[0] %X\n",Num_data);			
	#endif		
	buffersize=sizeof(int16)*Num_data+sizeof(tPacketHeader);		   
    64ae:	fc 01       	movw	r30, r24
    64b0:	e0 80       	ld	r14, Z
    64b2:	f1 80       	ldd	r15, Z+1	; 0x01
    64b4:	84 e0       	ldi	r24, 0x04	; 4
    64b6:	90 e0       	ldi	r25, 0x00	; 0
    64b8:	e8 0e       	add	r14, r24
    64ba:	f9 1e       	adc	r15, r25
    64bc:	ee 0c       	add	r14, r14
    64be:	ff 1c       	adc	r15, r15
	if(Esimpar(buffersize))
    64c0:	c7 01       	movw	r24, r14
    64c2:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <Esimpar>
    64c6:	89 2b       	or	r24, r25
    64c8:	41 f0       	breq	.+16     	; 0x64da <BUFFERVectorPoseTX+0x52>
	{
		buffersize++;		
    64ca:	08 94       	sec
    64cc:	e1 1c       	adc	r14, r1
    64ce:	f1 1c       	adc	r15, r1
		Datasize=buffersize-(sizeof(tPacketHeader)+1);
    64d0:	57 ef       	ldi	r21, 0xF7	; 247
    64d2:	c5 2e       	mov	r12, r21
    64d4:	5f ef       	ldi	r21, 0xFF	; 255
    64d6:	d5 2e       	mov	r13, r21
    64d8:	04 c0       	rjmp	.+8      	; 0x64e2 <BUFFERVectorPoseTX+0x5a>
	}
	else
	{
		Datasize=buffersize-sizeof(tPacketHeader);
    64da:	48 ef       	ldi	r20, 0xF8	; 248
    64dc:	c4 2e       	mov	r12, r20
    64de:	4f ef       	ldi	r20, 0xFF	; 255
    64e0:	d4 2e       	mov	r13, r20
    64e2:	ce 0c       	add	r12, r14
    64e4:	df 1c       	adc	r13, r15
	}
	TXBUFFER=(uint8*)declarar(buffersize);
    64e6:	c7 01       	movw	r24, r14
    64e8:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    64ec:	90 93 b8 79 	sts	0x79B8, r25
    64f0:	80 93 b7 79 	sts	0x79B7, r24
	#ifdef DEBUGUSBLevel1
	printf("BUFFERVectorPoseTX => cantidad a mandar al PC %X\n",buffersize);			
	printf("BUFFERVectorPoseTX => Datasize = %X\n",Datasize);			
	#endif		
	fillPacketHeader(&packetHeader,PacketPosesvector,Datasize,(uint8*)pVectorpose);
    64f4:	8e 01       	movw	r16, r28
    64f6:	0f 5f       	subi	r16, 0xFF	; 255
    64f8:	1f 4f       	sbci	r17, 0xFF	; 255
    64fa:	c8 01       	movw	r24, r16
    64fc:	69 e0       	ldi	r22, 0x09	; 9
    64fe:	70 e0       	ldi	r23, 0x00	; 0
    6500:	a6 01       	movw	r20, r12
    6502:	95 01       	movw	r18, r10
    6504:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    6508:	c8 01       	movw	r24, r16
    650a:	b8 01       	movw	r22, r16
    650c:	48 e0       	ldi	r20, 0x08	; 8
    650e:	50 e0       	ldi	r21, 0x00	; 0
    6510:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	// meto el tAxisLimits en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,(uint8*)pVectorpose,PacketPosesvector);    
    6514:	c8 01       	movw	r24, r16
    6516:	b5 01       	movw	r22, r10
    6518:	49 e0       	ldi	r20, 0x09	; 9
    651a:	50 e0       	ldi	r21, 0x00	; 0
    651c:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	return buffersize;
} 
    6520:	c7 01       	movw	r24, r14
    6522:	28 96       	adiw	r28, 0x08	; 8
    6524:	0f b6       	in	r0, 0x3f	; 63
    6526:	f8 94       	cli
    6528:	de bf       	out	0x3e, r29	; 62
    652a:	0f be       	out	0x3f, r0	; 63
    652c:	cd bf       	out	0x3d, r28	; 61
    652e:	cf 91       	pop	r28
    6530:	df 91       	pop	r29
    6532:	1f 91       	pop	r17
    6534:	0f 91       	pop	r16
    6536:	ff 90       	pop	r15
    6538:	ef 90       	pop	r14
    653a:	df 90       	pop	r13
    653c:	cf 90       	pop	r12
    653e:	bf 90       	pop	r11
    6540:	af 90       	pop	r10
    6542:	08 95       	ret

00006544 <BUFFERAxisLimitsTX>:
} // sendAxisSettings

/*****************************************************************************************/
// send axis limits information
int BUFFERAxisLimitsTX(tAxisLimits *paxisLimits) 
{
    6544:	cf 92       	push	r12
    6546:	df 92       	push	r13
    6548:	ef 92       	push	r14
    654a:	ff 92       	push	r15
    654c:	0f 93       	push	r16
    654e:	1f 93       	push	r17
    6550:	df 93       	push	r29
    6552:	cf 93       	push	r28
    6554:	cd b7       	in	r28, 0x3d	; 61
    6556:	de b7       	in	r29, 0x3e	; 62
    6558:	28 97       	sbiw	r28, 0x08	; 8
    655a:	0f b6       	in	r0, 0x3f	; 63
    655c:	f8 94       	cli
    655e:	de bf       	out	0x3e, r29	; 62
    6560:	0f be       	out	0x3f, r0	; 63
    6562:	cd bf       	out	0x3d, r28	; 61
    6564:	d8 2e       	mov	r13, r24
    6566:	c9 2e       	mov	r12, r25

	tPacketHeader packetHeader;
	int16 buffersize,Datasize;
	
	buffersize=sizeof(tAxisLimits)+sizeof(tPacketHeader);	
	if(Esimpar(buffersize))
    6568:	80 e1       	ldi	r24, 0x10	; 16
    656a:	90 e0       	ldi	r25, 0x00	; 0
    656c:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <Esimpar>
    6570:	89 2b       	or	r24, r25
    6572:	21 f4       	brne	.+8      	; 0x657c <BUFFERAxisLimitsTX+0x38>
    6574:	e0 e1       	ldi	r30, 0x10	; 16
    6576:	ee 2e       	mov	r14, r30
    6578:	f1 2c       	mov	r15, r1
    657a:	03 c0       	rjmp	.+6      	; 0x6582 <BUFFERAxisLimitsTX+0x3e>
    657c:	71 e1       	ldi	r23, 0x11	; 17
    657e:	e7 2e       	mov	r14, r23
    6580:	f1 2c       	mov	r15, r1
	}
	else
	{
		Datasize=buffersize-8;						  	
	}		
	TXBUFFER=(uint8*)declarar(buffersize);
    6582:	c7 01       	movw	r24, r14
    6584:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    6588:	90 93 b8 79 	sts	0x79B8, r25
    658c:	80 93 b7 79 	sts	0x79B7, r24
	//sizeof(tAxisLimits)
	fillPacketHeader(&packetHeader,PacketAxisLimits,Datasize,(uint8*)paxisLimits);
    6590:	8e 01       	movw	r16, r28
    6592:	0f 5f       	subi	r16, 0xFF	; 255
    6594:	1f 4f       	sbci	r17, 0xFF	; 255
    6596:	c8 01       	movw	r24, r16
    6598:	67 e0       	ldi	r22, 0x07	; 7
    659a:	70 e0       	ldi	r23, 0x00	; 0
    659c:	48 e0       	ldi	r20, 0x08	; 8
    659e:	50 e0       	ldi	r21, 0x00	; 0
    65a0:	2d 2d       	mov	r18, r13
    65a2:	3c 2d       	mov	r19, r12
    65a4:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);      
    65a8:	c8 01       	movw	r24, r16
    65aa:	b8 01       	movw	r22, r16
    65ac:	48 e0       	ldi	r20, 0x08	; 8
    65ae:	50 e0       	ldi	r21, 0x00	; 0
    65b0:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	// meto el tAxisLimits en TXBUFFER  
	BUFFERPacketDataTX(&packetHeader,(uint8*)paxisLimits,PacketAxisLimits);    
    65b4:	c8 01       	movw	r24, r16
    65b6:	6d 2d       	mov	r22, r13
    65b8:	7c 2d       	mov	r23, r12
    65ba:	47 e0       	ldi	r20, 0x07	; 7
    65bc:	50 e0       	ldi	r21, 0x00	; 0
    65be:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	return buffersize;
} // sendAxisLimits
    65c2:	c7 01       	movw	r24, r14
    65c4:	28 96       	adiw	r28, 0x08	; 8
    65c6:	0f b6       	in	r0, 0x3f	; 63
    65c8:	f8 94       	cli
    65ca:	de bf       	out	0x3e, r29	; 62
    65cc:	0f be       	out	0x3f, r0	; 63
    65ce:	cd bf       	out	0x3d, r28	; 61
    65d0:	cf 91       	pop	r28
    65d2:	df 91       	pop	r29
    65d4:	1f 91       	pop	r17
    65d6:	0f 91       	pop	r16
    65d8:	ff 90       	pop	r15
    65da:	ef 90       	pop	r14
    65dc:	df 90       	pop	r13
    65de:	cf 90       	pop	r12
    65e0:	08 95       	ret

000065e2 <BUFFERAxisSettingsTX>:
} // sendTrajectory

/*****************************************************************************************/
// send axis limits information PC-uC uC-Pc
int BUFFERAxisSettingsTX(tAxisSettings *paxisSettings) 
{
    65e2:	cf 92       	push	r12
    65e4:	df 92       	push	r13
    65e6:	ef 92       	push	r14
    65e8:	ff 92       	push	r15
    65ea:	0f 93       	push	r16
    65ec:	1f 93       	push	r17
    65ee:	df 93       	push	r29
    65f0:	cf 93       	push	r28
    65f2:	cd b7       	in	r28, 0x3d	; 61
    65f4:	de b7       	in	r29, 0x3e	; 62
    65f6:	28 97       	sbiw	r28, 0x08	; 8
    65f8:	0f b6       	in	r0, 0x3f	; 63
    65fa:	f8 94       	cli
    65fc:	de bf       	out	0x3e, r29	; 62
    65fe:	0f be       	out	0x3f, r0	; 63
    6600:	cd bf       	out	0x3d, r28	; 61
    6602:	d8 2e       	mov	r13, r24
    6604:	c9 2e       	mov	r12, r25
	tPacketHeader packetHeader;
	int16 buffersize,Datasize;
	
	buffersize=sizeof(tAxisSettings)*DOF+sizeof(tPacketHeader);		   
	if(Esimpar(buffersize))
    6606:	8c e5       	ldi	r24, 0x5C	; 92
    6608:	91 e0       	ldi	r25, 0x01	; 1
    660a:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <Esimpar>
    660e:	89 2b       	or	r24, r25
    6610:	29 f4       	brne	.+10     	; 0x661c <BUFFERAxisSettingsTX+0x3a>
    6612:	ac e5       	ldi	r26, 0x5C	; 92
    6614:	ea 2e       	mov	r14, r26
    6616:	a1 e0       	ldi	r26, 0x01	; 1
    6618:	fa 2e       	mov	r15, r26
    661a:	04 c0       	rjmp	.+8      	; 0x6624 <BUFFERAxisSettingsTX+0x42>
    661c:	fd e5       	ldi	r31, 0x5D	; 93
    661e:	ef 2e       	mov	r14, r31
    6620:	f1 e0       	ldi	r31, 0x01	; 1
    6622:	ff 2e       	mov	r15, r31
	}
	else
	{
		Datasize=buffersize-8;						  	
	}		
	TXBUFFER=(uint8*)declarar(buffersize);
    6624:	c7 01       	movw	r24, r14
    6626:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    662a:	90 93 b8 79 	sts	0x79B8, r25
    662e:	80 93 b7 79 	sts	0x79B7, r24
	//sizeof(tAxisSettings)
	fillPacketHeader(&packetHeader,PacketAxisSettings,Datasize,(uint8*)paxisSettings);
    6632:	8e 01       	movw	r16, r28
    6634:	0f 5f       	subi	r16, 0xFF	; 255
    6636:	1f 4f       	sbci	r17, 0xFF	; 255
    6638:	c8 01       	movw	r24, r16
    663a:	66 e0       	ldi	r22, 0x06	; 6
    663c:	70 e0       	ldi	r23, 0x00	; 0
    663e:	44 e5       	ldi	r20, 0x54	; 84
    6640:	51 e0       	ldi	r21, 0x01	; 1
    6642:	2d 2d       	mov	r18, r13
    6644:	3c 2d       	mov	r19, r12
    6646:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);        
    664a:	c8 01       	movw	r24, r16
    664c:	b8 01       	movw	r22, r16
    664e:	48 e0       	ldi	r20, 0x08	; 8
    6650:	50 e0       	ldi	r21, 0x00	; 0
    6652:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	// meto el tAxisSttings en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)paxisSettings,PacketAxisSettings);  
    6656:	c8 01       	movw	r24, r16
    6658:	6d 2d       	mov	r22, r13
    665a:	7c 2d       	mov	r23, r12
    665c:	46 e0       	ldi	r20, 0x06	; 6
    665e:	50 e0       	ldi	r21, 0x00	; 0
    6660:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	return buffersize;
} // sendAxisSettings
    6664:	c7 01       	movw	r24, r14
    6666:	28 96       	adiw	r28, 0x08	; 8
    6668:	0f b6       	in	r0, 0x3f	; 63
    666a:	f8 94       	cli
    666c:	de bf       	out	0x3e, r29	; 62
    666e:	0f be       	out	0x3f, r0	; 63
    6670:	cd bf       	out	0x3d, r28	; 61
    6672:	cf 91       	pop	r28
    6674:	df 91       	pop	r29
    6676:	1f 91       	pop	r17
    6678:	0f 91       	pop	r16
    667a:	ff 90       	pop	r15
    667c:	ef 90       	pop	r14
    667e:	df 90       	pop	r13
    6680:	cf 90       	pop	r12
    6682:	08 95       	ret

00006684 <BUFFERTrajectoryTX>:
	
/*****************************************************************************************/
//Coloca la trayectoria + el header en TXBUFFER para luego ser enviada
//tipo puede ser PacketTeachPendant o PacketTrajectory 
int BUFFERTrajectoryTX(tTrajectory *pTrajectory,int16 puntos,tPacket tipo) 
{
    6684:	8f 92       	push	r8
    6686:	9f 92       	push	r9
    6688:	af 92       	push	r10
    668a:	bf 92       	push	r11
    668c:	cf 92       	push	r12
    668e:	df 92       	push	r13
    6690:	ef 92       	push	r14
    6692:	ff 92       	push	r15
    6694:	0f 93       	push	r16
    6696:	1f 93       	push	r17
    6698:	df 93       	push	r29
    669a:	cf 93       	push	r28
    669c:	cd b7       	in	r28, 0x3d	; 61
    669e:	de b7       	in	r29, 0x3e	; 62
    66a0:	28 97       	sbiw	r28, 0x08	; 8
    66a2:	0f b6       	in	r0, 0x3f	; 63
    66a4:	f8 94       	cli
    66a6:	de bf       	out	0x3e, r29	; 62
    66a8:	0f be       	out	0x3f, r0	; 63
    66aa:	cd bf       	out	0x3d, r28	; 61
    66ac:	98 2e       	mov	r9, r24
    66ae:	89 2e       	mov	r8, r25
    66b0:	5a 01       	movw	r10, r20
	tPacketHeader packetHeader;
	//asigno memoria para guardar la trayectoria, 
	//3 de  campos: una estructura tpoint * numero de puntos 
	//+ 2 campos  int16 (dummy y size) 
	//mas el tamao del header
	buffersize=sizeof(tpoint)*puntos+2*sizeof(int16)+sizeof(tPacketHeader); 
    66b2:	8d e3       	ldi	r24, 0x3D	; 61
    66b4:	90 e0       	ldi	r25, 0x00	; 0
    66b6:	68 9f       	mul	r22, r24
    66b8:	80 01       	movw	r16, r0
    66ba:	69 9f       	mul	r22, r25
    66bc:	10 0d       	add	r17, r0
    66be:	78 9f       	mul	r23, r24
    66c0:	10 0d       	add	r17, r0
    66c2:	11 24       	eor	r1, r1
    66c4:	8c e0       	ldi	r24, 0x0C	; 12
    66c6:	e8 2e       	mov	r14, r24
    66c8:	f1 2c       	mov	r15, r1
    66ca:	e0 0e       	add	r14, r16
    66cc:	f1 1e       	adc	r15, r17
	if(Esimpar(buffersize))
    66ce:	c7 01       	movw	r24, r14
    66d0:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <Esimpar>
    66d4:	b4 e0       	ldi	r27, 0x04	; 4
    66d6:	cb 2e       	mov	r12, r27
    66d8:	d1 2c       	mov	r13, r1
    66da:	c0 0e       	add	r12, r16
    66dc:	d1 1e       	adc	r13, r17
    66de:	89 2b       	or	r24, r25
    66e0:	29 f0       	breq	.+10     	; 0x66ec <BUFFERTrajectoryTX+0x68>
	{
		buffersize++;		
    66e2:	78 01       	movw	r14, r16
    66e4:	8d e0       	ldi	r24, 0x0D	; 13
    66e6:	90 e0       	ldi	r25, 0x00	; 0
    66e8:	e8 0e       	add	r14, r24
    66ea:	f9 1e       	adc	r15, r25
	else
	{
		Datasize=buffersize-8;						  	
	}
	
	TXBUFFER=(uint8*)declarar(buffersize);    
    66ec:	c7 01       	movw	r24, r14
    66ee:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    66f2:	90 93 b8 79 	sts	0x79B8, r25
    66f6:	80 93 b7 79 	sts	0x79B7, r24
	//Resto el numero de bytes del header pues este es la cantidad de datos 
	//que se quieren enviar	   	    
	//
	
	fillPacketHeader(&packetHeader,tipo,(tDataLength)Datasize,(uint8*)pTrajectory);
    66fa:	8e 01       	movw	r16, r28
    66fc:	0f 5f       	subi	r16, 0xFF	; 255
    66fe:	1f 4f       	sbci	r17, 0xFF	; 255
    6700:	c8 01       	movw	r24, r16
    6702:	b5 01       	movw	r22, r10
    6704:	a6 01       	movw	r20, r12
    6706:	29 2d       	mov	r18, r9
    6708:	38 2d       	mov	r19, r8
    670a:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <fillPacketHeader>
	printf("BUFFERTrajectoryTX=> header.datalength en BUFFERCommandTX=> %x\n", packetHeader.dataLength);
	printf("BUFFERTrajectoryTX=> packetHeader.dataChecksum en BUFFERCommandTX=> %x\n",packetHeader.dataChecksum);
	printf("BUFFERTrajectoryTX=> packetHeader.headerChecksum en BUFFERCommandTX=> %d\n",packetHeader.headerChecksum);	
	#endif
	//coloco el packet Header en el TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader); 
    670e:	c8 01       	movw	r24, r16
    6710:	b8 01       	movw	r22, r16
    6712:	48 e0       	ldi	r20, 0x08	; 8
    6714:	50 e0       	ldi	r21, 0x00	; 0
    6716:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	 //coloco los datos en el TXBUFFER independiente si es de tipo PacketTeachPendant 
	//o PacketTrajectory uso PacketTrajectory  
	BUFFERPacketDataTX(&packetHeader,(uint8*)pTrajectory,PacketTrajectory); 
    671a:	c8 01       	movw	r24, r16
    671c:	69 2d       	mov	r22, r9
    671e:	78 2d       	mov	r23, r8
    6720:	43 e0       	ldi	r20, 0x03	; 3
    6722:	50 e0       	ldi	r21, 0x00	; 0
    6724:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	return buffersize;
} // sendTrajectory
    6728:	c7 01       	movw	r24, r14
    672a:	28 96       	adiw	r28, 0x08	; 8
    672c:	0f b6       	in	r0, 0x3f	; 63
    672e:	f8 94       	cli
    6730:	de bf       	out	0x3e, r29	; 62
    6732:	0f be       	out	0x3f, r0	; 63
    6734:	cd bf       	out	0x3d, r28	; 61
    6736:	cf 91       	pop	r28
    6738:	df 91       	pop	r29
    673a:	1f 91       	pop	r17
    673c:	0f 91       	pop	r16
    673e:	ff 90       	pop	r15
    6740:	ef 90       	pop	r14
    6742:	df 90       	pop	r13
    6744:	cf 90       	pop	r12
    6746:	bf 90       	pop	r11
    6748:	af 90       	pop	r10
    674a:	9f 90       	pop	r9
    674c:	8f 90       	pop	r8
    674e:	08 95       	ret

00006750 <BUFFERCommandTX>:
} // sendPacketData

/*****************************************************************************************/
// a short way to send a command byte
int BUFFERCommandTX(tCommand* command) 
{
    6750:	cf 92       	push	r12
    6752:	df 92       	push	r13
    6754:	ef 92       	push	r14
    6756:	ff 92       	push	r15
    6758:	0f 93       	push	r16
    675a:	1f 93       	push	r17
    675c:	df 93       	push	r29
    675e:	cf 93       	push	r28
    6760:	cd b7       	in	r28, 0x3d	; 61
    6762:	de b7       	in	r29, 0x3e	; 62
    6764:	28 97       	sbiw	r28, 0x08	; 8
    6766:	0f b6       	in	r0, 0x3f	; 63
    6768:	f8 94       	cli
    676a:	de bf       	out	0x3e, r29	; 62
    676c:	0f be       	out	0x3f, r0	; 63
    676e:	cd bf       	out	0x3d, r28	; 61
    6770:	d8 2e       	mov	r13, r24
    6772:	c9 2e       	mov	r12, r25
	tPacketHeader packetHeader;
	int16 buffersize;	
	
	buffersize=sizeof(tCommand)+sizeof(tPacketHeader);
	if(Esimpar(buffersize))
    6774:	83 e2       	ldi	r24, 0x23	; 35
    6776:	90 e0       	ldi	r25, 0x00	; 0
    6778:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <Esimpar>
    677c:	89 2b       	or	r24, r25
    677e:	21 f0       	breq	.+8      	; 0x6788 <BUFFERCommandTX+0x38>
    6780:	24 e2       	ldi	r18, 0x24	; 36
    6782:	e2 2e       	mov	r14, r18
    6784:	f1 2c       	mov	r15, r1
    6786:	03 c0       	rjmp	.+6      	; 0x678e <BUFFERCommandTX+0x3e>
    6788:	93 e2       	ldi	r25, 0x23	; 35
    678a:	e9 2e       	mov	r14, r25
    678c:	f1 2c       	mov	r15, r1
		buffersize++;		
	TXBUFFER=(uint8*)declarar(buffersize);
    678e:	c7 01       	movw	r24, r14
    6790:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    6794:	90 93 b8 79 	sts	0x79B8, r25
    6798:	80 93 b7 79 	sts	0x79B7, r24
	//sizeof(tCommand)
	fillPacketHeader(&packetHeader,PacketCommand,sizeof(tCommand),(uint8*)command);
    679c:	8e 01       	movw	r16, r28
    679e:	0f 5f       	subi	r16, 0xFF	; 255
    67a0:	1f 4f       	sbci	r17, 0xFF	; 255
    67a2:	c8 01       	movw	r24, r16
    67a4:	61 e0       	ldi	r22, 0x01	; 1
    67a6:	70 e0       	ldi	r23, 0x00	; 0
    67a8:	4b e1       	ldi	r20, 0x1B	; 27
    67aa:	50 e0       	ldi	r21, 0x00	; 0
    67ac:	2d 2d       	mov	r18, r13
    67ae:	3c 2d       	mov	r19, r12
    67b0:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <fillPacketHeader>
	// meto el header en TXBUFFER	
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader); 
    67b4:	c8 01       	movw	r24, r16
    67b6:	b8 01       	movw	r22, r16
    67b8:	48 e0       	ldi	r20, 0x08	; 8
    67ba:	50 e0       	ldi	r21, 0x00	; 0
    67bc:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	printf("BUFFERCommandTX=> header.datalength en BUFFERCommandTX=> %x\n", packetHeader.dataLength);
	printf("BUFFERCommandTX=> packetHeader.dataChecksum en BUFFERCommandTX=> %x\n",packetHeader.dataChecksum);
	printf("BUFFERCommandTX=> packetHeader.headerChecksum en BUFFERCommandTX=> %d\n",packetHeader.headerChecksum);	
	#endif
	//meto el command en TXBUFFER despues del header 
	BUFFERPacketDataTX(&packetHeader,(uint8*)command,PacketCommand);     
    67c0:	c8 01       	movw	r24, r16
    67c2:	6d 2d       	mov	r22, r13
    67c4:	7c 2d       	mov	r23, r12
    67c6:	41 e0       	ldi	r20, 0x01	; 1
    67c8:	50 e0       	ldi	r21, 0x00	; 0
    67ca:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	return buffersize;
} // sendCommand
    67ce:	c7 01       	movw	r24, r14
    67d0:	28 96       	adiw	r28, 0x08	; 8
    67d2:	0f b6       	in	r0, 0x3f	; 63
    67d4:	f8 94       	cli
    67d6:	de bf       	out	0x3e, r29	; 62
    67d8:	0f be       	out	0x3f, r0	; 63
    67da:	cd bf       	out	0x3d, r28	; 61
    67dc:	cf 91       	pop	r28
    67de:	df 91       	pop	r29
    67e0:	1f 91       	pop	r17
    67e2:	0f 91       	pop	r16
    67e4:	ff 90       	pop	r15
    67e6:	ef 90       	pop	r14
    67e8:	df 90       	pop	r13
    67ea:	cf 90       	pop	r12
    67ec:	08 95       	ret

000067ee <readTrajectoryRX>:

/*****************************************************************************************/
//pTrajectory es la trayectoria destino
//RXBUFFER[0] tiene la estructura trayectoria no el header	
int16 readTrajectoryRX(tTrajectory *pTrajectory,tPacketHeader packetHeader) 
{
    67ee:	cf 92       	push	r12
    67f0:	df 92       	push	r13
    67f2:	ef 92       	push	r14
    67f4:	ff 92       	push	r15
    67f6:	0f 93       	push	r16
    67f8:	1f 93       	push	r17
    67fa:	df 93       	push	r29
    67fc:	cf 93       	push	r28
    67fe:	cd b7       	in	r28, 0x3d	; 61
    6800:	de b7       	in	r29, 0x3e	; 62
    6802:	28 97       	sbiw	r28, 0x08	; 8
    6804:	0f b6       	in	r0, 0x3f	; 63
    6806:	f8 94       	cli
    6808:	de bf       	out	0x3e, r29	; 62
    680a:	0f be       	out	0x3f, r0	; 63
    680c:	cd bf       	out	0x3d, r28	; 61
    680e:	7c 01       	movw	r14, r24
    6810:	09 83       	std	Y+1, r16	; 0x01
    6812:	1a 83       	std	Y+2, r17	; 0x02
    6814:	2b 83       	std	Y+3, r18	; 0x03
    6816:	3c 83       	std	Y+4, r19	; 0x04
    6818:	4d 83       	std	Y+5, r20	; 0x05
    681a:	5e 83       	std	Y+6, r21	; 0x06
    681c:	6f 83       	std	Y+7, r22	; 0x07
    681e:	78 87       	std	Y+8, r23	; 0x08
    6820:	0b 81       	ldd	r16, Y+3	; 0x03
    6822:	1c 81       	ldd	r17, Y+4	; 0x04
    6824:	cd 80       	ldd	r12, Y+5	; 0x05
    6826:	de 80       	ldd	r13, Y+6	; 0x06
  
	
	pdata = (uint8*)pTrajectory;				
	//Leemos  4 bytes  del RXBUFFER los 3 campos: puntos,dummy,*tpont 
	for(i=0; i<4; i++) 
		pdata[i]=RXBUFFER[i];
    6828:	e0 91 b5 79 	lds	r30, 0x79B5
    682c:	f0 91 b6 79 	lds	r31, 0x79B6
    6830:	80 81       	ld	r24, Z
    6832:	f7 01       	movw	r30, r14
    6834:	80 83       	st	Z, r24
    6836:	e0 91 b5 79 	lds	r30, 0x79B5
    683a:	f0 91 b6 79 	lds	r31, 0x79B6
    683e:	81 81       	ldd	r24, Z+1	; 0x01
    6840:	f7 01       	movw	r30, r14
    6842:	81 83       	std	Z+1, r24	; 0x01
    6844:	e0 91 b5 79 	lds	r30, 0x79B5
    6848:	f0 91 b6 79 	lds	r31, 0x79B6
    684c:	82 81       	ldd	r24, Z+2	; 0x02
    684e:	f7 01       	movw	r30, r14
    6850:	82 83       	std	Z+2, r24	; 0x02
    6852:	e0 91 b5 79 	lds	r30, 0x79B5
    6856:	f0 91 b6 79 	lds	r31, 0x79B6
    685a:	83 81       	ldd	r24, Z+3	; 0x03
    685c:	f7 01       	movw	r30, r14
    685e:	83 83       	std	Z+3, r24	; 0x03
	#endif
	//pTrajectory->size es la cantidad de puntos de la trayectoria, 
	//cada punto tiene un tamao tpoint 
    j=(pTrajectory->size)*sizeof(tpoint);       
	//Reservo espacio para guardar toda esa informacion que viene desde el USB
	pTrajectory->point=(tpoint *)declarar(j); 
    6860:	20 81       	ld	r18, Z
    6862:	31 81       	ldd	r19, Z+1	; 0x01
    6864:	8d e3       	ldi	r24, 0x3D	; 61
    6866:	90 e0       	ldi	r25, 0x00	; 0
    6868:	ac 01       	movw	r20, r24
    686a:	24 9f       	mul	r18, r20
    686c:	c0 01       	movw	r24, r0
    686e:	25 9f       	mul	r18, r21
    6870:	90 0d       	add	r25, r0
    6872:	34 9f       	mul	r19, r20
    6874:	90 0d       	add	r25, r0
    6876:	11 24       	eor	r1, r1
    6878:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    687c:	f7 01       	movw	r30, r14
    687e:	84 83       	std	Z+4, r24	; 0x04
    6880:	95 83       	std	Z+5, r25	; 0x05
    6882:	dc 01       	movw	r26, r24
    6884:	24 e0       	ldi	r18, 0x04	; 4
    6886:	30 e0       	ldi	r19, 0x00	; 0
    6888:	0a c0       	rjmp	.+20     	; 0x689e <readTrajectoryRX+0xb0>
	//En el siguiente  for pdata[0] corresponde a los datos a los que apunta pTrajectory->point
	//RXBUFFER[j] = tiene la informacion de los puntos que llegaron desde USB
	//i = 3, 3 campos puntos,dummy,y apuntador a tpont que ya incluido
	//j tiene que llegar hasta el final de los datos
	for(j=i; j<packetHeader.dataLength;j++) 
		pdata[j-i]=RXBUFFER[j]; 
    688a:	e0 91 b5 79 	lds	r30, 0x79B5
    688e:	f0 91 b6 79 	lds	r31, 0x79B6
    6892:	e2 0f       	add	r30, r18
    6894:	f3 1f       	adc	r31, r19
    6896:	80 81       	ld	r24, Z
    6898:	8d 93       	st	X+, r24
	pdata = (uint8*)pTrajectory->point;        
	//En el siguiente  for pdata[0] corresponde a los datos a los que apunta pTrajectory->point
	//RXBUFFER[j] = tiene la informacion de los puntos que llegaron desde USB
	//i = 3, 3 campos puntos,dummy,y apuntador a tpont que ya incluido
	//j tiene que llegar hasta el final de los datos
	for(j=i; j<packetHeader.dataLength;j++) 
    689a:	2f 5f       	subi	r18, 0xFF	; 255
    689c:	3f 4f       	sbci	r19, 0xFF	; 255
    689e:	20 17       	cp	r18, r16
    68a0:	31 07       	cpc	r19, r17
    68a2:	9c f3       	brlt	.-26     	; 0x688a <readTrajectoryRX+0x9c>
	    printf("readTrajectoryRX => RXBUFFER[%d]=%X pdata[%d]=%X \n",k+i,RXBUFFER[k+i],k,pdata[k]);							       
	}
	printf("readTrajectoryRX => Addr pTrajectory->point = %X \n",(int16)pTrajectory->point);							    
    #endif
	//checksumOk calcula el cheksum con los datos recibidos
	if(!checksumOk (packetHeader.dataLength,(uint8*)pTrajectory,packetHeader.dataChecksum,PacketTrajectory))
    68a4:	c8 01       	movw	r24, r16
    68a6:	b7 01       	movw	r22, r14
    68a8:	a6 01       	movw	r20, r12
    68aa:	23 e0       	ldi	r18, 0x03	; 3
    68ac:	30 e0       	ldi	r19, 0x00	; 0
    68ae:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <checksumOk>
    68b2:	89 2b       	or	r24, r25
    68b4:	19 f0       	breq	.+6      	; 0x68bc <readTrajectoryRX+0xce>
    68b6:	20 e0       	ldi	r18, 0x00	; 0
    68b8:	30 e0       	ldi	r19, 0x00	; 0
    68ba:	02 c0       	rjmp	.+4      	; 0x68c0 <readTrajectoryRX+0xd2>
    68bc:	25 e0       	ldi	r18, 0x05	; 5
    68be:	30 e0       	ldi	r19, 0x00	; 0
		return rcInvalidChecksum;
return rc;
} 
    68c0:	c9 01       	movw	r24, r18
    68c2:	28 96       	adiw	r28, 0x08	; 8
    68c4:	0f b6       	in	r0, 0x3f	; 63
    68c6:	f8 94       	cli
    68c8:	de bf       	out	0x3e, r29	; 62
    68ca:	0f be       	out	0x3f, r0	; 63
    68cc:	cd bf       	out	0x3d, r28	; 61
    68ce:	cf 91       	pop	r28
    68d0:	df 91       	pop	r29
    68d2:	1f 91       	pop	r17
    68d4:	0f 91       	pop	r16
    68d6:	ff 90       	pop	r15
    68d8:	ef 90       	pop	r14
    68da:	df 90       	pop	r13
    68dc:	cf 90       	pop	r12
    68de:	08 95       	ret

000068e0 <BUFFERStringTX>:
	return buffersize;
} // sendCommand

/*****************************************************************************************/
int BUFFERStringTX(uint8 *string) 
{  
    68e0:	cf 92       	push	r12
    68e2:	df 92       	push	r13
    68e4:	ef 92       	push	r14
    68e6:	ff 92       	push	r15
    68e8:	0f 93       	push	r16
    68ea:	1f 93       	push	r17
    68ec:	df 93       	push	r29
    68ee:	cf 93       	push	r28
    68f0:	cd b7       	in	r28, 0x3d	; 61
    68f2:	de b7       	in	r29, 0x3e	; 62
    68f4:	28 97       	sbiw	r28, 0x08	; 8
    68f6:	0f b6       	in	r0, 0x3f	; 63
    68f8:	f8 94       	cli
    68fa:	de bf       	out	0x3e, r29	; 62
    68fc:	0f be       	out	0x3f, r0	; 63
    68fe:	cd bf       	out	0x3d, r28	; 61
    6900:	d8 2e       	mov	r13, r24
    6902:	c9 2e       	mov	r12, r25
	int16 buffersize= 0;
	int16 Datasize= 0;
	tPacketHeader packetHeader;
    
	info=(uint8*)string;
	buffersize=strlen((char*)info)+sizeof(tPacketHeader);
    6904:	e8 2f       	mov	r30, r24
    6906:	f9 2f       	mov	r31, r25
    6908:	df 01       	movw	r26, r30
    690a:	0d 90       	ld	r0, X+
    690c:	00 20       	and	r0, r0
    690e:	e9 f7       	brne	.-6      	; 0x690a <BUFFERStringTX+0x2a>
    6910:	8d 01       	movw	r16, r26
    6912:	01 50       	subi	r16, 0x01	; 1
    6914:	10 40       	sbci	r17, 0x00	; 0
    6916:	0e 1b       	sub	r16, r30
    6918:	1f 0b       	sbc	r17, r31
    691a:	48 e0       	ldi	r20, 0x08	; 8
    691c:	e4 2e       	mov	r14, r20
    691e:	f1 2c       	mov	r15, r1
    6920:	e0 0e       	add	r14, r16
    6922:	f1 1e       	adc	r15, r17
	if(Esimpar(buffersize))
    6924:	c7 01       	movw	r24, r14
    6926:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <Esimpar>
    692a:	89 2b       	or	r24, r25
    692c:	29 f0       	breq	.+10     	; 0x6938 <BUFFERStringTX+0x58>
		buffersize++;		
    692e:	39 e0       	ldi	r19, 0x09	; 9
    6930:	e3 2e       	mov	r14, r19
    6932:	f1 2c       	mov	r15, r1
    6934:	e0 0e       	add	r14, r16
    6936:	f1 1e       	adc	r15, r17
	TXBUFFER=(uint8*)declarar(buffersize);
    6938:	c7 01       	movw	r24, r14
    693a:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    693e:	90 93 b8 79 	sts	0x79B8, r25
    6942:	80 93 b7 79 	sts	0x79B7, r24
	//Datasize tiene la logitud de la informacion en bytes
	Datasize=strlen((char*)info);
    6946:	ed 2d       	mov	r30, r13
    6948:	fc 2d       	mov	r31, r12
    694a:	df 01       	movw	r26, r30
    694c:	0d 90       	ld	r0, X+
    694e:	00 20       	and	r0, r0
    6950:	e9 f7       	brne	.-6      	; 0x694c <BUFFERStringTX+0x6c>
    6952:	11 97       	sbiw	r26, 0x01	; 1
    6954:	ae 1b       	sub	r26, r30
    6956:	bf 0b       	sbc	r27, r31
	fillPacketHeader(&packetHeader,PacketString,(tDataLength)Datasize,string);  
    6958:	8e 01       	movw	r16, r28
    695a:	0f 5f       	subi	r16, 0xFF	; 255
    695c:	1f 4f       	sbci	r17, 0xFF	; 255
    695e:	c8 01       	movw	r24, r16
    6960:	65 e0       	ldi	r22, 0x05	; 5
    6962:	70 e0       	ldi	r23, 0x00	; 0
    6964:	ad 01       	movw	r20, r26
    6966:	2d 2d       	mov	r18, r13
    6968:	3c 2d       	mov	r19, r12
    696a:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <fillPacketHeader>
	// meto el header en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,(uint8*)&packetHeader,PacketHeader);     
    696e:	c8 01       	movw	r24, r16
    6970:	b8 01       	movw	r22, r16
    6972:	48 e0       	ldi	r20, 0x08	; 8
    6974:	50 e0       	ldi	r21, 0x00	; 0
    6976:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	// meto el string en TXBUFFER
	BUFFERPacketDataTX(&packetHeader,string,PacketString);                   
    697a:	c8 01       	movw	r24, r16
    697c:	6d 2d       	mov	r22, r13
    697e:	7c 2d       	mov	r23, r12
    6980:	45 e0       	ldi	r20, 0x05	; 5
    6982:	50 e0       	ldi	r21, 0x00	; 0
    6984:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <BUFFERPacketDataTX>
	return buffersize;
} // sendString
    6988:	c7 01       	movw	r24, r14
    698a:	28 96       	adiw	r28, 0x08	; 8
    698c:	0f b6       	in	r0, 0x3f	; 63
    698e:	f8 94       	cli
    6990:	de bf       	out	0x3e, r29	; 62
    6992:	0f be       	out	0x3f, r0	; 63
    6994:	cd bf       	out	0x3d, r28	; 61
    6996:	cf 91       	pop	r28
    6998:	df 91       	pop	r29
    699a:	1f 91       	pop	r17
    699c:	0f 91       	pop	r16
    699e:	ff 90       	pop	r15
    69a0:	ef 90       	pop	r14
    69a2:	df 90       	pop	r13
    69a4:	cf 90       	pop	r12
    69a6:	08 95       	ret

000069a8 <dispatchPacket>:
#endif

/*****************************************************************************************/
#ifdef _AVR_IO_H_
int16 dispatchPacket(tPacket tipodato,uint8* datos)
{
    69a8:	cf 93       	push	r28
    69aa:	df 93       	push	r29
    69ac:	ac 01       	movw	r20, r24
	tTrajectory * Traytemp;//Trayectoria temporal para poder acceder a el campo size,
    int16 puntos;
    //Variables Transmicion 
	int16 rc,buffersize=0;       

	txPacket=tipodato;
    69ae:	90 93 8c 79 	sts	0x798C, r25
    69b2:	80 93 8b 79 	sts	0x798B, r24
	if(txPacket == PacketNOP || txPacket > lastPacket) 
    69b6:	00 97       	sbiw	r24, 0x00	; 0
    69b8:	09 f4       	brne	.+2      	; 0x69bc <dispatchPacket+0x14>
    69ba:	6b c0       	rjmp	.+214    	; 0x6a92 <dispatchPacket+0xea>
    69bc:	8e 30       	cpi	r24, 0x0E	; 14
    69be:	91 05       	cpc	r25, r1
    69c0:	0c f0       	brlt	.+2      	; 0x69c4 <dispatchPacket+0x1c>
    69c2:	67 c0       	rjmp	.+206    	; 0x6a92 <dispatchPacket+0xea>
		return rcInvalidPacket;   

	switch(txPacket)  
    69c4:	87 30       	cpi	r24, 0x07	; 7
    69c6:	91 05       	cpc	r25, r1
    69c8:	f1 f1       	breq	.+124    	; 0x6a46 <dispatchPacket+0x9e>
    69ca:	88 30       	cpi	r24, 0x08	; 8
    69cc:	91 05       	cpc	r25, r1
    69ce:	9c f4       	brge	.+38     	; 0x69f6 <dispatchPacket+0x4e>
    69d0:	85 30       	cpi	r24, 0x05	; 5
    69d2:	91 05       	cpc	r25, r1
    69d4:	44 f4       	brge	.+16     	; 0x69e6 <dispatchPacket+0x3e>
    69d6:	83 30       	cpi	r24, 0x03	; 3
    69d8:	91 05       	cpc	r25, r1
    69da:	14 f5       	brge	.+68     	; 0x6a20 <dispatchPacket+0x78>
    69dc:	81 30       	cpi	r24, 0x01	; 1
    69de:	91 05       	cpc	r25, r1
    69e0:	09 f0       	breq	.+2      	; 0x69e4 <dispatchPacket+0x3c>
    69e2:	57 c0       	rjmp	.+174    	; 0x6a92 <dispatchPacket+0xea>
    69e4:	24 c0       	rjmp	.+72     	; 0x6a2e <dispatchPacket+0x86>
    69e6:	85 30       	cpi	r24, 0x05	; 5
    69e8:	91 05       	cpc	r25, r1
    69ea:	29 f1       	breq	.+74     	; 0x6a36 <dispatchPacket+0x8e>
    69ec:	86 30       	cpi	r24, 0x06	; 6
    69ee:	91 05       	cpc	r25, r1
    69f0:	09 f0       	breq	.+2      	; 0x69f4 <dispatchPacket+0x4c>
    69f2:	4f c0       	rjmp	.+158    	; 0x6a92 <dispatchPacket+0xea>
    69f4:	24 c0       	rjmp	.+72     	; 0x6a3e <dispatchPacket+0x96>
    69f6:	8b 30       	cpi	r24, 0x0B	; 11
    69f8:	91 05       	cpc	r25, r1
    69fa:	89 f1       	breq	.+98     	; 0x6a5e <dispatchPacket+0xb6>
    69fc:	8c 30       	cpi	r24, 0x0C	; 12
    69fe:	91 05       	cpc	r25, r1
    6a00:	44 f4       	brge	.+16     	; 0x6a12 <dispatchPacket+0x6a>
    6a02:	89 30       	cpi	r24, 0x09	; 9
    6a04:	91 05       	cpc	r25, r1
    6a06:	19 f1       	breq	.+70     	; 0x6a4e <dispatchPacket+0xa6>
    6a08:	8a 30       	cpi	r24, 0x0A	; 10
    6a0a:	91 05       	cpc	r25, r1
    6a0c:	09 f0       	breq	.+2      	; 0x6a10 <dispatchPacket+0x68>
    6a0e:	41 c0       	rjmp	.+130    	; 0x6a92 <dispatchPacket+0xea>
    6a10:	22 c0       	rjmp	.+68     	; 0x6a56 <dispatchPacket+0xae>
    6a12:	8c 30       	cpi	r24, 0x0C	; 12
    6a14:	91 05       	cpc	r25, r1
    6a16:	39 f1       	breq	.+78     	; 0x6a66 <dispatchPacket+0xbe>
    6a18:	8d 30       	cpi	r24, 0x0D	; 13
    6a1a:	91 05       	cpc	r25, r1
    6a1c:	d1 f5       	brne	.+116    	; 0x6a92 <dispatchPacket+0xea>
    6a1e:	27 c0       	rjmp	.+78     	; 0x6a6e <dispatchPacket+0xc6>
	{  
		case PacketTeachPendant:
		case PacketTrajectory :
			// Como dispatchPacket es una funcion generica los datos vienen en bytes   
			Traytemp=(tTrajectory *)datos;  
    6a20:	fb 01       	movw	r30, r22
			//Con puntos puedo calcular el numero de bytes que necesito								  
			puntos=Traytemp->size;          
			//4 bytes por los dos campos int16 de la estructura trayectoria			
			buffersize=BUFFERTrajectoryTX(Traytemp,puntos,txPacket); 
    6a22:	60 81       	ld	r22, Z
    6a24:	71 81       	ldd	r23, Z+1	; 0x01
    6a26:	cf 01       	movw	r24, r30
    6a28:	0e 94 42 33 	call	0x6684	; 0x6684 <BUFFERTrajectoryTX>
    6a2c:	23 c0       	rjmp	.+70     	; 0x6a74 <dispatchPacket+0xcc>
        break;
		case PacketCommand:
			buffersize=BUFFERCommandTX((tCommand*)datos);
    6a2e:	cb 01       	movw	r24, r22
    6a30:	0e 94 a8 33 	call	0x6750	; 0x6750 <BUFFERCommandTX>
    6a34:	1f c0       	rjmp	.+62     	; 0x6a74 <dispatchPacket+0xcc>
			for(k=0; k<buffersize;k++) 
            printf("dispatchPacket => TXBUFFER[%d]=%X\n",k,TXBUFFER[k]);							    
			#endif		   
		break;
		case PacketString:    // send \0-terminated string, such as copyright or debug info   
			buffersize=BUFFERStringTX(datos);
    6a36:	cb 01       	movw	r24, r22
    6a38:	0e 94 70 34 	call	0x68e0	; 0x68e0 <BUFFERStringTX>
    6a3c:	1b c0       	rjmp	.+54     	; 0x6a74 <dispatchPacket+0xcc>
			printf("dispatchPacket=> strlen(info) en dispatchPacket=>%d \n",j);		   
			printf("dispatchPacket=> Tamao de los datos en dispatchPacket=>%d \n",buffersize);
			#endif
		break;
		case PacketAxisSettings:
			buffersize=BUFFERAxisSettingsTX((tAxisSettings*)datos);		   
    6a3e:	cb 01       	movw	r24, r22
    6a40:	0e 94 f1 32 	call	0x65e2	; 0x65e2 <BUFFERAxisSettingsTX>
    6a44:	17 c0       	rjmp	.+46     	; 0x6a74 <dispatchPacket+0xcc>
		break;
		case PacketAxisLimits:
			buffersize=BUFFERAxisLimitsTX((tAxisLimits*)datos);
    6a46:	cb 01       	movw	r24, r22
    6a48:	0e 94 a2 32 	call	0x6544	; 0x6544 <BUFFERAxisLimitsTX>
    6a4c:	13 c0       	rjmp	.+38     	; 0x6a74 <dispatchPacket+0xcc>
		break;
		case PacketPosesvector:
		    buffersize=BUFFERVectorPoseTX(datos); 
    6a4e:	cb 01       	movw	r24, r22
    6a50:	0e 94 44 32 	call	0x6488	; 0x6488 <BUFFERVectorPoseTX>
    6a54:	0f c0       	rjmp	.+30     	; 0x6a74 <dispatchPacket+0xcc>
		break;
		case PacketFecha:   // 14
			buffersize=BUFFERFechaTX(datos); 
    6a56:	cb 01       	movw	r24, r22
    6a58:	0e 94 f8 31 	call	0x63f0	; 0x63f0 <BUFFERFechaTX>
    6a5c:	0b c0       	rjmp	.+22     	; 0x6a74 <dispatchPacket+0xcc>
		break;
		case PacketAlarma:
			buffersize=BUFFERAlarmaTX(datos); 
    6a5e:	cb 01       	movw	r24, r22
    6a60:	0e 94 ac 31 	call	0x6358	; 0x6358 <BUFFERAlarmaTX>
    6a64:	07 c0       	rjmp	.+14     	; 0x6a74 <dispatchPacket+0xcc>
		break;
		case PacketTrace:
			buffersize=BUFFERTraceTX(datos);
    6a66:	cb 01       	movw	r24, r22
    6a68:	0e 94 48 31 	call	0x6290	; 0x6290 <BUFFERTraceTX>
    6a6c:	03 c0       	rjmp	.+6      	; 0x6a74 <dispatchPacket+0xcc>
		break;
		case Packetuint16:
			buffersize=BUFFERunit16TX(datos);
    6a6e:	cb 01       	movw	r24, r22
    6a70:	0e 94 fc 30 	call	0x61f8	; 0x61f8 <BUFFERunit16TX>
    6a74:	bc 01       	movw	r22, r24
			return rcInvalidPacket;
    } // switch txPacket
	//buffersize solo es par, es decir siempre el buffer es par. Aunque el dato a enviar 
	//tenga una longitud de bytes impar. Internamente tPacketHeader.dataLength siempre
	//tiene la cantidad de bytes correcta del dato.
	rc=Envio_USB(TXBUFFER,buffersize);  
    6a76:	80 91 b7 79 	lds	r24, 0x79B7
    6a7a:	90 91 b8 79 	lds	r25, 0x79B8
    6a7e:	0e 94 37 2b 	call	0x566e	; 0x566e <Envio_USB>
    6a82:	ec 01       	movw	r28, r24
	free(TXBUFFER);
    6a84:	80 91 b7 79 	lds	r24, 0x79B7
    6a88:	90 91 b8 79 	lds	r25, 0x79B8
    6a8c:	0e 94 78 9d 	call	0x13af0	; 0x13af0 <free>
    6a90:	02 c0       	rjmp	.+4      	; 0x6a96 <dispatchPacket+0xee>
return rc;
    6a92:	c3 e0       	ldi	r28, 0x03	; 3
    6a94:	d0 e0       	ldi	r29, 0x00	; 0
} // dispatchPacket
    6a96:	ce 01       	movw	r24, r28
    6a98:	df 91       	pop	r29
    6a9a:	cf 91       	pop	r28
    6a9c:	08 95       	ret

00006a9e <receiptPacket>:
// 4. Se lee el campo rxHeader.dataType del header recibido y se copia a rxPacket
// 5. Dependiendo del tipo de paquete se guarda en su respectiva variable

#ifdef _AVR_IO_H_
int16 receiptPacket(void)  
{
    6a9e:	0f 93       	push	r16
    6aa0:	1f 93       	push	r17
	uint16 spacefree;
	#endif
   	int16 rc;
	tDataLength longitud;    
   //Creo un Buffer para almacenar el header
	RXBUFFER=(uint8 *)declarar(8);                    
    6aa2:	88 e0       	ldi	r24, 0x08	; 8
    6aa4:	90 e0       	ldi	r25, 0x00	; 0
    6aa6:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    6aaa:	80 93 b5 79 	sts	0x79B5, r24
    6aae:	90 93 b6 79 	sts	0x79B6, r25
	printf("receiptPacket=> Addr RXBUFFER para almacenar los datos Header = %X \n",(int16)RXBUFFER);							    
	#endif
	
	//Siempre se manda primero el header y luego los dato
	//En esta funcin el uC recibe los datos desde la fifo, la cual es controlada por el GPIF
	rc = Leo_USB(RXBUFFER,8);
    6ab2:	68 e0       	ldi	r22, 0x08	; 8
    6ab4:	70 e0       	ldi	r23, 0x00	; 0
    6ab6:	0e 94 5b 2b 	call	0x56b6	; 0x56b6 <Leo_USB>
    6aba:	8c 01       	movw	r16, r24
	if(rc!=rcOK)
    6abc:	00 97       	sbiw	r24, 0x00	; 0
    6abe:	09 f0       	breq	.+2      	; 0x6ac2 <receiptPacket+0x24>
    6ac0:	0b c1       	rjmp	.+534    	; 0x6cd8 <receiptPacket+0x23a>
		return rc;				
	//Se lee el Header de RXBUFFER
	rc = readPacketHeaderRX(&rxHeader);				    
    6ac2:	83 e7       	ldi	r24, 0x73	; 115
    6ac4:	98 e7       	ldi	r25, 0x78	; 120
    6ac6:	0e 94 2a 2e 	call	0x5c54	; 0x5c54 <readPacketHeaderRX>
    6aca:	8c 01       	movw	r16, r24
	free(RXBUFFER); 
    6acc:	80 91 b5 79 	lds	r24, 0x79B5
    6ad0:	90 91 b6 79 	lds	r25, 0x79B6
    6ad4:	0e 94 78 9d 	call	0x13af0	; 0x13af0 <free>
	if(rc != rcOK) 
    6ad8:	01 15       	cp	r16, r1
    6ada:	11 05       	cpc	r17, r1
    6adc:	09 f0       	breq	.+2      	; 0x6ae0 <receiptPacket+0x42>
    6ade:	fc c0       	rjmp	.+504    	; 0x6cd8 <receiptPacket+0x23a>
		printf("receipPacket=> Error al leer el Header\n");							    
		#endif
		return rc;                       
	}
	// Reservo memoria a los datos
	longitud=rxHeader.dataLength;		
    6ae0:	00 91 75 78 	lds	r16, 0x7875
    6ae4:	10 91 76 78 	lds	r17, 0x7876
	/*tengo que crear un buffer siempre de datos pares pues USB siempre manda par*/
	if(Esimpar(longitud))
    6ae8:	c8 01       	movw	r24, r16
    6aea:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <Esimpar>
    6aee:	89 2b       	or	r24, r25
    6af0:	11 f0       	breq	.+4      	; 0x6af6 <receiptPacket+0x58>
		longitud++;
    6af2:	0f 5f       	subi	r16, 0xFF	; 255
    6af4:	1f 4f       	sbci	r17, 0xFF	; 255
	#ifdef DEBUGUSBLevel1
	spacefree=maxavail();
	printf("receiptPacket=> La cantidad de memoria ram disponible SIN rxbuffer declarado %d \n",spacefree);
	#endif	
		
	RXBUFFER=(uint8 *)declarar(longitud);    
    6af6:	c8 01       	movw	r24, r16
    6af8:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    6afc:	80 93 b5 79 	sts	0x79B5, r24
    6b00:	90 93 b6 79 	sts	0x79B6, r25
	#ifdef DEBUGUSBLevel1
	spacefree=maxavail();
	printf("receiptPacket=> La cantidad de memoria ram disponible CON rxbuffer declarado %d , con una log de %d\n",spacefree,longitud);
	#endif
	//En esta funcin el uC recibe los datos desde la fifo, la cual es controlada por el GPIF
	rc=Leo_USB(RXBUFFER,longitud); 
    6b04:	b8 01       	movw	r22, r16
    6b06:	0e 94 5b 2b 	call	0x56b6	; 0x56b6 <Leo_USB>
    6b0a:	8c 01       	movw	r16, r24
	if(rc!=rcOK)
    6b0c:	00 97       	sbiw	r24, 0x00	; 0
    6b0e:	09 f0       	breq	.+2      	; 0x6b12 <receiptPacket+0x74>
    6b10:	e3 c0       	rjmp	.+454    	; 0x6cd8 <receiptPacket+0x23a>
		printf("receipPacket=> Error al leer los datos\n");							    
		#endif
		return rc;				
	}
	
	rxPacket = rxHeader.dataType;	
    6b12:	80 91 73 78 	lds	r24, 0x7873
    6b16:	90 91 74 78 	lds	r25, 0x7874
    6b1a:	90 93 70 78 	sts	0x7870, r25
    6b1e:	80 93 6f 78 	sts	0x786F, r24
		{
			printf("receipPacket=> RXBUFFER[%d] = %X \n",i,RXBUFFER[i]);							    
		}
	#endif	
	
	switch(rxPacket)
    6b22:	87 30       	cpi	r24, 0x07	; 7
    6b24:	91 05       	cpc	r25, r1
    6b26:	09 f4       	brne	.+2      	; 0x6b2a <receiptPacket+0x8c>
    6b28:	75 c0       	rjmp	.+234    	; 0x6c14 <receiptPacket+0x176>
    6b2a:	88 30       	cpi	r24, 0x08	; 8
    6b2c:	91 05       	cpc	r25, r1
    6b2e:	94 f4       	brge	.+36     	; 0x6b54 <receiptPacket+0xb6>
    6b30:	85 30       	cpi	r24, 0x05	; 5
    6b32:	91 05       	cpc	r25, r1
    6b34:	3c f4       	brge	.+14     	; 0x6b44 <receiptPacket+0xa6>
    6b36:	83 30       	cpi	r24, 0x03	; 3
    6b38:	91 05       	cpc	r25, r1
    6b3a:	1c f5       	brge	.+70     	; 0x6b82 <receiptPacket+0xe4>
    6b3c:	01 97       	sbiw	r24, 0x01	; 1
    6b3e:	09 f0       	breq	.+2      	; 0x6b42 <receiptPacket+0xa4>
    6b40:	c5 c0       	rjmp	.+394    	; 0x6ccc <receiptPacket+0x22e>
    6b42:	47 c0       	rjmp	.+142    	; 0x6bd2 <receiptPacket+0x134>
    6b44:	85 30       	cpi	r24, 0x05	; 5
    6b46:	91 05       	cpc	r25, r1
    6b48:	09 f4       	brne	.+2      	; 0x6b4c <receiptPacket+0xae>
    6b4a:	58 c0       	rjmp	.+176    	; 0x6bfc <receiptPacket+0x15e>
    6b4c:	06 97       	sbiw	r24, 0x06	; 6
    6b4e:	09 f0       	breq	.+2      	; 0x6b52 <receiptPacket+0xb4>
    6b50:	bd c0       	rjmp	.+378    	; 0x6ccc <receiptPacket+0x22e>
    6b52:	59 c0       	rjmp	.+178    	; 0x6c06 <receiptPacket+0x168>
    6b54:	8b 30       	cpi	r24, 0x0B	; 11
    6b56:	91 05       	cpc	r25, r1
    6b58:	09 f4       	brne	.+2      	; 0x6b5c <receiptPacket+0xbe>
    6b5a:	8c c0       	rjmp	.+280    	; 0x6c74 <receiptPacket+0x1d6>
    6b5c:	8c 30       	cpi	r24, 0x0C	; 12
    6b5e:	91 05       	cpc	r25, r1
    6b60:	44 f4       	brge	.+16     	; 0x6b72 <receiptPacket+0xd4>
    6b62:	89 30       	cpi	r24, 0x09	; 9
    6b64:	91 05       	cpc	r25, r1
    6b66:	09 f4       	brne	.+2      	; 0x6b6a <receiptPacket+0xcc>
    6b68:	5d c0       	rjmp	.+186    	; 0x6c24 <receiptPacket+0x186>
    6b6a:	0a 97       	sbiw	r24, 0x0a	; 10
    6b6c:	09 f0       	breq	.+2      	; 0x6b70 <receiptPacket+0xd2>
    6b6e:	ae c0       	rjmp	.+348    	; 0x6ccc <receiptPacket+0x22e>
    6b70:	7c c0       	rjmp	.+248    	; 0x6c6a <receiptPacket+0x1cc>
    6b72:	8c 30       	cpi	r24, 0x0C	; 12
    6b74:	91 05       	cpc	r25, r1
    6b76:	09 f4       	brne	.+2      	; 0x6b7a <receiptPacket+0xdc>
    6b78:	87 c0       	rjmp	.+270    	; 0x6c88 <receiptPacket+0x1ea>
    6b7a:	0d 97       	sbiw	r24, 0x0d	; 13
    6b7c:	09 f0       	breq	.+2      	; 0x6b80 <receiptPacket+0xe2>
    6b7e:	a6 c0       	rjmp	.+332    	; 0x6ccc <receiptPacket+0x22e>
    6b80:	7e c0       	rjmp	.+252    	; 0x6c7e <receiptPacket+0x1e0>
		case PacketTeachPendant:
		case PacketTrajectory:	
			#ifdef DEBUGUSBLevel0
			printf("receipPacket=> FlagTrayectoryok = %d\n",FlagTrayectoryok);							    
			#endif
			if(FlagTrayectoryok)				
    6b82:	80 91 ae 74 	lds	r24, 0x74AE
    6b86:	90 91 af 74 	lds	r25, 0x74AF
    6b8a:	89 2b       	or	r24, r25
    6b8c:	31 f0       	breq	.+12     	; 0x6b9a <receiptPacket+0xfc>
				#ifdef DEBUGUSBLevel0
				spacefree=maxavail();
				printf("receipPacket=> La cantidad de memoria ram disponible %d \n",spacefree);
				printf("receipPacket=> rxTrajectory.point = %X\n",(int16)rxTrajectory.point);
				#endif
				free(rxTrajectory.point); 
    6b8e:	80 91 ac 79 	lds	r24, 0x79AC
    6b92:	90 91 ad 79 	lds	r25, 0x79AD
    6b96:	0e 94 78 9d 	call	0x13af0	; 0x13af0 <free>
				spacefree=maxavail();
				printf("receipPacket=> rxTrajectory.point  free...\n");	
				printf("receipPacket=> La cantidad de memoria ram disponible %d \n",spacefree);						    
				#endif		
			}
			rc=readTrajectoryRX(&rxTrajectory,rxHeader); 
    6b9a:	88 ea       	ldi	r24, 0xA8	; 168
    6b9c:	99 e7       	ldi	r25, 0x79	; 121
    6b9e:	00 91 73 78 	lds	r16, 0x7873
    6ba2:	10 91 74 78 	lds	r17, 0x7874
    6ba6:	20 91 75 78 	lds	r18, 0x7875
    6baa:	30 91 76 78 	lds	r19, 0x7876
    6bae:	40 91 77 78 	lds	r20, 0x7877
    6bb2:	50 91 78 78 	lds	r21, 0x7878
    6bb6:	60 91 79 78 	lds	r22, 0x7879
    6bba:	70 91 7a 78 	lds	r23, 0x787A
    6bbe:	0e 94 f7 33 	call	0x67ee	; 0x67ee <readTrajectoryRX>
    6bc2:	8c 01       	movw	r16, r24
			#ifdef DEBUGUSBLevel0
			printf("receipPacket=> He ejecutado readTrajectoryRX ...\n");							    
			#endif 
			FlagTrayectoryok=1;
    6bc4:	81 e0       	ldi	r24, 0x01	; 1
    6bc6:	90 e0       	ldi	r25, 0x00	; 0
    6bc8:	90 93 af 74 	sts	0x74AF, r25
    6bcc:	80 93 ae 74 	sts	0x74AE, r24
    6bd0:	7d c0       	rjmp	.+250    	; 0x6ccc <receiptPacket+0x22e>
		break;		
		case PacketCommand:
			rc = readPacketDataRX(&rxHeader, (uint8*)&rxCommand);
    6bd2:	83 e7       	ldi	r24, 0x73	; 115
    6bd4:	98 e7       	ldi	r25, 0x78	; 120
    6bd6:	6d e8       	ldi	r22, 0x8D	; 141
    6bd8:	79 e7       	ldi	r23, 0x79	; 121
    6bda:	0e 94 71 2e 	call	0x5ce2	; 0x5ce2 <readPacketDataRX>
    6bde:	8c 01       	movw	r16, r24
			if(rxCommand.CommandOP > lastCommand) 
    6be0:	80 91 8d 79 	lds	r24, 0x798D
    6be4:	90 91 8e 79 	lds	r25, 0x798E
    6be8:	43 97       	sbiw	r24, 0x13	; 19
    6bea:	0c f4       	brge	.+2      	; 0x6bee <receiptPacket+0x150>
    6bec:	6f c0       	rjmp	.+222    	; 0x6ccc <receiptPacket+0x22e>
			{
				rxCommand.CommandOP = CommandNOP;     // make access to CommandMsg[rxCommand] safe
    6bee:	10 92 8e 79 	sts	0x798E, r1
    6bf2:	10 92 8d 79 	sts	0x798D, r1
    6bf6:	04 e0       	ldi	r16, 0x04	; 4
    6bf8:	10 e0       	ldi	r17, 0x00	; 0
    6bfa:	6e c0       	rjmp	.+220    	; 0x6cd8 <receiptPacket+0x23a>
				return rcInvalidCommand;
			}
        break;   
		case PacketString:			 
			rc = readPacketDataRX(&rxHeader,(uint8*)rxString); //Max 255 char
    6bfc:	83 e7       	ldi	r24, 0x73	; 115
    6bfe:	98 e7       	ldi	r25, 0x78	; 120
    6c00:	6b e7       	ldi	r22, 0x7B	; 123
    6c02:	78 e7       	ldi	r23, 0x78	; 120
    6c04:	0b c0       	rjmp	.+22     	; 0x6c1c <receiptPacket+0x17e>
				
			}
			printf("receipPacket=>  rxHeader.dataLength = %d\n",rxHeader.dataLength);
			printf("receipPacket=>  sizeof(tAxisSettings) = %d\n",sizeof(tAxisSettings));
			#endif
			readPacketDataRX(&rxHeader, (uint8*)&(rxAxisSettings[0]) ); 
    6c06:	83 e7       	ldi	r24, 0x73	; 115
    6c08:	98 e7       	ldi	r25, 0x78	; 120
    6c0a:	69 ef       	ldi	r22, 0xF9	; 249
    6c0c:	76 e7       	ldi	r23, 0x76	; 118
    6c0e:	0e 94 71 2e 	call	0x5ce2	; 0x5ce2 <readPacketDataRX>
    6c12:	5c c0       	rjmp	.+184    	; 0x6ccc <receiptPacket+0x22e>
			printf("receiptPacket => rxAxisSettings[%d].ustepsPerStep= %d \n",i,rxAxisSettings[i].ustepsPerStep);
			#endif
			
		break;	 
		case PacketAxisLimits:
			rc = readPacketDataRX(&rxHeader, (uint8*)&rxAxisLimits); 
    6c14:	83 e7       	ldi	r24, 0x73	; 115
    6c16:	98 e7       	ldi	r25, 0x78	; 120
    6c18:	63 e8       	ldi	r22, 0x83	; 131
    6c1a:	79 e7       	ldi	r23, 0x79	; 121
    6c1c:	0e 94 71 2e 	call	0x5ce2	; 0x5ce2 <readPacketDataRX>
    6c20:	8c 01       	movw	r16, r24
    6c22:	54 c0       	rjmp	.+168    	; 0x6ccc <receiptPacket+0x22e>
		break;	 
		case PacketPosesvector:
			#ifdef DEBUGUSBLevel0
			printf("receipPacket=>  FlagrxVectorok = %d\n",FlagrxVectorok);							    
			#endif
			if(FlagrxVectorok)					
    6c24:	80 91 b0 74 	lds	r24, 0x74B0
    6c28:	90 91 b1 74 	lds	r25, 0x74B1
    6c2c:	89 2b       	or	r24, r25
    6c2e:	31 f0       	breq	.+12     	; 0x6c3c <receiptPacket+0x19e>
				free(rxvector); /*Liberamos a rxVector*/
    6c30:	80 91 71 78 	lds	r24, 0x7871
    6c34:	90 91 72 78 	lds	r25, 0x7872
    6c38:	0e 94 78 9d 	call	0x13af0	; 0x13af0 <free>
			/*Creamos uno nuevo*/
		    rxvector=(int16*)declarar(rxHeader.dataLength);
    6c3c:	80 91 75 78 	lds	r24, 0x7875
    6c40:	90 91 76 78 	lds	r25, 0x7876
    6c44:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    6c48:	bc 01       	movw	r22, r24
    6c4a:	80 93 71 78 	sts	0x7871, r24
    6c4e:	70 93 72 78 	sts	0x7872, r23
		    rc = readPacketDataRX(&rxHeader, (uint8*)rxvector); 
    6c52:	83 e7       	ldi	r24, 0x73	; 115
    6c54:	98 e7       	ldi	r25, 0x78	; 120
    6c56:	0e 94 71 2e 	call	0x5ce2	; 0x5ce2 <readPacketDataRX>
    6c5a:	8c 01       	movw	r16, r24
			FlagrxVectorok=1;
    6c5c:	81 e0       	ldi	r24, 0x01	; 1
    6c5e:	90 e0       	ldi	r25, 0x00	; 0
    6c60:	90 93 b1 74 	sts	0x74B1, r25
    6c64:	80 93 b0 74 	sts	0x74B0, r24
    6c68:	31 c0       	rjmp	.+98     	; 0x6ccc <receiptPacket+0x22e>
		break;
		case PacketFecha:
			rc = readPacketDataRX(&rxHeader, (uint8*)&rxFecha); 
    6c6a:	83 e7       	ldi	r24, 0x73	; 115
    6c6c:	98 e7       	ldi	r25, 0x78	; 120
    6c6e:	6b e7       	ldi	r22, 0x7B	; 123
    6c70:	79 e7       	ldi	r23, 0x79	; 121
    6c72:	d4 cf       	rjmp	.-88     	; 0x6c1c <receiptPacket+0x17e>
		break;
		case PacketAlarma:
			rc = readPacketDataRX(&rxHeader, (uint8*)&rxAlarma); 
    6c74:	83 e7       	ldi	r24, 0x73	; 115
    6c76:	98 e7       	ldi	r25, 0x78	; 120
    6c78:	6e ea       	ldi	r22, 0xAE	; 174
    6c7a:	79 e7       	ldi	r23, 0x79	; 121
    6c7c:	cf cf       	rjmp	.-98     	; 0x6c1c <receiptPacket+0x17e>
		break;
		case Packetuint16:
			rc = readPacketDataRX(&rxHeader, (uint8*)&rxPosesActual); 
    6c7e:	83 e7       	ldi	r24, 0x73	; 115
    6c80:	98 e7       	ldi	r25, 0x78	; 120
    6c82:	63 e1       	ldi	r22, 0x13	; 19
    6c84:	75 e7       	ldi	r23, 0x75	; 117
    6c86:	ca cf       	rjmp	.-108    	; 0x6c1c <receiptPacket+0x17e>
		break;
		case PacketTrace:
			#ifdef DEBUGUSBLevel0
			printf("receipPacket=> FlagTraceOK = %d\n",FlagTraceok);							    
			#endif
			if(FlagTraceok)					
    6c88:	80 91 b2 74 	lds	r24, 0x74B2
    6c8c:	90 91 b3 74 	lds	r25, 0x74B3
    6c90:	89 2b       	or	r24, r25
    6c92:	31 f0       	breq	.+12     	; 0x6ca0 <receiptPacket+0x202>
				free(rxTraceBuffer); 
    6c94:	80 91 5a 78 	lds	r24, 0x785A
    6c98:	90 91 5b 78 	lds	r25, 0x785B
    6c9c:	0e 94 78 9d 	call	0x13af0	; 0x13af0 <free>
			/*Creamos un buffer dinamico de la cantidad de datos de 8bits 
			presentes en la cantidad de datos de 32 bits enviados*/
			rxTraceBuffer=(int32*)declarar(rxHeader.dataLength);
    6ca0:	80 91 75 78 	lds	r24, 0x7875
    6ca4:	90 91 76 78 	lds	r25, 0x7876
    6ca8:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
    6cac:	bc 01       	movw	r22, r24
    6cae:	80 93 5a 78 	sts	0x785A, r24
    6cb2:	70 93 5b 78 	sts	0x785B, r23
			rc = readPacketDataRX(&rxHeader, (uint8*)rxTraceBuffer); 
    6cb6:	83 e7       	ldi	r24, 0x73	; 115
    6cb8:	98 e7       	ldi	r25, 0x78	; 120
    6cba:	0e 94 71 2e 	call	0x5ce2	; 0x5ce2 <readPacketDataRX>
    6cbe:	8c 01       	movw	r16, r24
			FlagTraceok=1;
    6cc0:	81 e0       	ldi	r24, 0x01	; 1
    6cc2:	90 e0       	ldi	r25, 0x00	; 0
    6cc4:	90 93 b3 74 	sts	0x74B3, r25
    6cc8:	80 93 b2 74 	sts	0x74B2, r24
		break;
	}//end case
	free(RXBUFFER);//libero el RXbuffer para poder recibir la siguiente	
    6ccc:	80 91 b5 79 	lds	r24, 0x79B5
    6cd0:	90 91 b6 79 	lds	r25, 0x79B6
    6cd4:	0e 94 78 9d 	call	0x13af0	; 0x13af0 <free>
	#ifdef DEBUGUSBLevel1
	spacefree=maxavail();
	printf("receipPacket=> La cantidad de memoria ram disponible CON rxbuffer LIBERADO.. %d \n",spacefree);
	#endif
	return rc;
} // receiptPacket
    6cd8:	c8 01       	movw	r24, r16
    6cda:	1f 91       	pop	r17
    6cdc:	0f 91       	pop	r16
    6cde:	08 95       	ret

00006ce0 <maxavail>:
}

/*****************************************************************************************/
#ifdef _AVR_IO_H_
uint16 maxavail(void) 
{
    6ce0:	cf 93       	push	r28
    6ce2:	df 93       	push	r29
    6ce4:	c0 e0       	ldi	r28, 0x00	; 0
    6ce6:	d0 e0       	ldi	r29, 0x00	; 0
	uint8 *ptr;                // pointer to allocated memory
	uint16 testsize;    // what we guess
	
	for(testsize=0; testsize < 65536;testsize++) //64K
	{ 
		ptr = (uint8*)malloc(testsize);
    6ce8:	ce 01       	movw	r24, r28
    6cea:	0e 94 cb 9c 	call	0x13996	; 0x13996 <malloc>
		if(ptr==NULL)  // failed, not enough memory... 
    6cee:	00 97       	sbiw	r24, 0x00	; 0
    6cf0:	21 f0       	breq	.+8      	; 0x6cfa <maxavail+0x1a>
		{
			break;
		}
		else 
		{
		free(ptr);
    6cf2:	0e 94 78 9d 	call	0x13af0	; 0x13af0 <free>
uint16 maxavail(void) 
{
	uint8 *ptr;                // pointer to allocated memory
	uint16 testsize;    // what we guess
	
	for(testsize=0; testsize < 65536;testsize++) //64K
    6cf6:	21 96       	adiw	r28, 0x01	; 1
    6cf8:	f7 cf       	rjmp	.-18     	; 0x6ce8 <maxavail+0x8>
		{
		free(ptr);
		}
	}
	return testsize;  // the previous value was ok...
} // maxavail
    6cfa:	ce 01       	movw	r24, r28
    6cfc:	df 91       	pop	r29
    6cfe:	cf 91       	pop	r28
    6d00:	08 95       	ret

00006d02 <declarar>:
#endif


/*****************************************************************************************/
void* declarar(size_t x)
{
    6d02:	0f 93       	push	r16
    6d04:	1f 93       	push	r17
    6d06:	cf 93       	push	r28
    6d08:	df 93       	push	r29
    6d0a:	18 2f       	mov	r17, r24
    6d0c:	09 2f       	mov	r16, r25
  void* p = malloc(x);
    6d0e:	0e 94 cb 9c 	call	0x13996	; 0x13996 <malloc>
    6d12:	ec 01       	movw	r28, r24
  if(p==NULL)
    6d14:	00 97       	sbiw	r24, 0x00	; 0
    6d16:	29 f4       	brne	.+10     	; 0x6d22 <declarar+0x20>
  {
	#ifdef _AVR_IO_H_
		printf("declarar=> ERROR NO HAY MEMORIA\n");
    6d18:	87 ec       	ldi	r24, 0xC7	; 199
    6d1a:	98 e2       	ldi	r25, 0x28	; 40
    6d1c:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
    6d20:	06 c0       	rjmp	.+12     	; 0x6d2e <declarar+0x2c>
	#endif
  }
  else						    
   memset(p, 0,x);
    6d22:	60 e0       	ldi	r22, 0x00	; 0
    6d24:	70 e0       	ldi	r23, 0x00	; 0
    6d26:	41 2f       	mov	r20, r17
    6d28:	50 2f       	mov	r21, r16
    6d2a:	0e 94 ce 9e 	call	0x13d9c	; 0x13d9c <memset>
  
 return p;
}
    6d2e:	ce 01       	movw	r24, r28
    6d30:	df 91       	pop	r29
    6d32:	cf 91       	pop	r28
    6d34:	1f 91       	pop	r17
    6d36:	0f 91       	pop	r16
    6d38:	08 95       	ret

00006d3a <AxisName>:

/*****************************************************************************************/
uint8 * AxisName(tAxis Axis)
{

   switch(Axis) 
    6d3a:	85 30       	cpi	r24, 0x05	; 5
    6d3c:	91 05       	cpc	r25, r1
    6d3e:	c9 f1       	breq	.+114    	; 0x6db2 <AxisName+0x78>
    6d40:	86 30       	cpi	r24, 0x06	; 6
    6d42:	91 05       	cpc	r25, r1
    6d44:	94 f4       	brge	.+36     	; 0x6d6a <AxisName+0x30>
    6d46:	82 30       	cpi	r24, 0x02	; 2
    6d48:	91 05       	cpc	r25, r1
    6d4a:	51 f1       	breq	.+84     	; 0x6da0 <AxisName+0x66>
    6d4c:	83 30       	cpi	r24, 0x03	; 3
    6d4e:	91 05       	cpc	r25, r1
    6d50:	34 f4       	brge	.+12     	; 0x6d5e <AxisName+0x24>
    6d52:	00 97       	sbiw	r24, 0x00	; 0
    6d54:	11 f1       	breq	.+68     	; 0x6d9a <AxisName+0x60>
    6d56:	01 97       	sbiw	r24, 0x01	; 1
    6d58:	09 f0       	breq	.+2      	; 0x6d5c <AxisName+0x22>
    6d5a:	40 c0       	rjmp	.+128    	; 0x6ddc <AxisName+0xa2>
    6d5c:	1b c0       	rjmp	.+54     	; 0x6d94 <AxisName+0x5a>
    6d5e:	83 30       	cpi	r24, 0x03	; 3
    6d60:	91 05       	cpc	r25, r1
    6d62:	09 f1       	breq	.+66     	; 0x6da6 <AxisName+0x6c>
    6d64:	04 97       	sbiw	r24, 0x04	; 4
    6d66:	d1 f5       	brne	.+116    	; 0x6ddc <AxisName+0xa2>
    6d68:	21 c0       	rjmp	.+66     	; 0x6dac <AxisName+0x72>
    6d6a:	88 30       	cpi	r24, 0x08	; 8
    6d6c:	91 05       	cpc	r25, r1
    6d6e:	51 f1       	breq	.+84     	; 0x6dc4 <AxisName+0x8a>
    6d70:	89 30       	cpi	r24, 0x09	; 9
    6d72:	91 05       	cpc	r25, r1
    6d74:	34 f4       	brge	.+12     	; 0x6d82 <AxisName+0x48>
    6d76:	86 30       	cpi	r24, 0x06	; 6
    6d78:	91 05       	cpc	r25, r1
    6d7a:	f1 f0       	breq	.+60     	; 0x6db8 <AxisName+0x7e>
    6d7c:	07 97       	sbiw	r24, 0x07	; 7
    6d7e:	71 f5       	brne	.+92     	; 0x6ddc <AxisName+0xa2>
    6d80:	1e c0       	rjmp	.+60     	; 0x6dbe <AxisName+0x84>
    6d82:	8a 30       	cpi	r24, 0x0A	; 10
    6d84:	91 05       	cpc	r25, r1
    6d86:	21 f1       	breq	.+72     	; 0x6dd0 <AxisName+0x96>
    6d88:	8a 30       	cpi	r24, 0x0A	; 10
    6d8a:	91 05       	cpc	r25, r1
    6d8c:	f4 f0       	brlt	.+60     	; 0x6dca <AxisName+0x90>
    6d8e:	0b 97       	sbiw	r24, 0x0b	; 11
    6d90:	29 f5       	brne	.+74     	; 0x6ddc <AxisName+0xa2>
    6d92:	21 c0       	rjmp	.+66     	; 0x6dd6 <AxisName+0x9c>
    6d94:	27 ee       	ldi	r18, 0xE7	; 231
    6d96:	38 e2       	ldi	r19, 0x28	; 40
    6d98:	23 c0       	rjmp	.+70     	; 0x6de0 <AxisName+0xa6>
    6d9a:	2e ee       	ldi	r18, 0xEE	; 238
    6d9c:	38 e2       	ldi	r19, 0x28	; 40
    6d9e:	20 c0       	rjmp	.+64     	; 0x6de0 <AxisName+0xa6>
    6da0:	26 ef       	ldi	r18, 0xF6	; 246
    6da2:	38 e2       	ldi	r19, 0x28	; 40
    6da4:	1d c0       	rjmp	.+58     	; 0x6de0 <AxisName+0xa6>
  {
    case (AxisWaist) 					: return (uint8*)"Cintura"; break;
    case (AxisShoulder) 				: return (uint8*)"Hombro"; break;
    case (AxisElbow) 					: return (uint8*)"Codo"; break;
    6da6:	2b ef       	ldi	r18, 0xFB	; 251
    6da8:	38 e2       	ldi	r19, 0x28	; 40
    6daa:	1a c0       	rjmp	.+52     	; 0x6de0 <AxisName+0xa6>
    case (AxisPitch) 					: return (uint8*)"Pitch"; break;
    6dac:	21 e0       	ldi	r18, 0x01	; 1
    6dae:	39 e2       	ldi	r19, 0x29	; 41
    6db0:	17 c0       	rjmp	.+46     	; 0x6de0 <AxisName+0xa6>
    case (AxisRoll) 					: return (uint8*)"Roll"; break;
    6db2:	26 e0       	ldi	r18, 0x06	; 6
    6db4:	39 e2       	ldi	r19, 0x29	; 41
    6db6:	14 c0       	rjmp	.+40     	; 0x6de0 <AxisName+0xa6>
    case (AxisAux1) 					: return (uint8*)"aux1"; break;
    6db8:	2b e0       	ldi	r18, 0x0B	; 11
    6dba:	39 e2       	ldi	r19, 0x29	; 41
    6dbc:	11 c0       	rjmp	.+34     	; 0x6de0 <AxisName+0xa6>
    case (AxisAux2) 					: return (uint8*)"aux2"; break;
    6dbe:	20 e1       	ldi	r18, 0x10	; 16
    6dc0:	39 e2       	ldi	r19, 0x29	; 41
    6dc2:	0e c0       	rjmp	.+28     	; 0x6de0 <AxisName+0xa6>
    case (AxisAux3) 					: return (uint8*)"aux3"; break;
    6dc4:	25 e1       	ldi	r18, 0x15	; 21
    6dc6:	39 e2       	ldi	r19, 0x29	; 41
    6dc8:	0b c0       	rjmp	.+22     	; 0x6de0 <AxisName+0xa6>
    case (AxisAux4) 					: return (uint8*)"aux4"; break;
    6dca:	2a e1       	ldi	r18, 0x1A	; 26
    6dcc:	39 e2       	ldi	r19, 0x29	; 41
    6dce:	08 c0       	rjmp	.+16     	; 0x6de0 <AxisName+0xa6>
	case (AxisAux5) 					: return (uint8*)"aux5"; break;
    6dd0:	2f e1       	ldi	r18, 0x1F	; 31
    6dd2:	39 e2       	ldi	r19, 0x29	; 41
    6dd4:	05 c0       	rjmp	.+10     	; 0x6de0 <AxisName+0xa6>
    case (AxisAux6) 					: return (uint8*)"aux6"; break;
    6dd6:	24 e2       	ldi	r18, 0x24	; 36
    6dd8:	39 e2       	ldi	r19, 0x29	; 41
    6dda:	02 c0       	rjmp	.+4      	; 0x6de0 <AxisName+0xa6>
    case (AxisAux7) 					: return (uint8*)"aux7"; break;    
    6ddc:	29 e2       	ldi	r18, 0x29	; 41
    6dde:	39 e2       	ldi	r19, 0x29	; 41
    
	default 							: return (uint8*)"invalid axis";
  }
} // AxisName
    6de0:	c9 01       	movw	r24, r18
    6de2:	08 95       	ret

00006de4 <TraceName>:

/*****************************************************************************************/
uint8 * TraceName(PMDTraceVariable Trace)
{

	switch(Trace) 
    6de4:	86 30       	cpi	r24, 0x06	; 6
    6de6:	79 f1       	breq	.+94     	; 0x6e46 <TraceName+0x62>
    6de8:	87 30       	cpi	r24, 0x07	; 7
    6dea:	70 f4       	brcc	.+28     	; 0x6e08 <TraceName+0x24>
    6dec:	83 30       	cpi	r24, 0x03	; 3
    6dee:	11 f1       	breq	.+68     	; 0x6e34 <TraceName+0x50>
    6df0:	84 30       	cpi	r24, 0x04	; 4
    6df2:	28 f4       	brcc	.+10     	; 0x6dfe <TraceName+0x1a>
    6df4:	81 30       	cpi	r24, 0x01	; 1
    6df6:	d9 f0       	breq	.+54     	; 0x6e2e <TraceName+0x4a>
    6df8:	82 30       	cpi	r24, 0x02	; 2
    6dfa:	d1 f5       	brne	.+116    	; 0x6e70 <TraceName+0x8c>
    6dfc:	15 c0       	rjmp	.+42     	; 0x6e28 <TraceName+0x44>
    6dfe:	84 30       	cpi	r24, 0x04	; 4
    6e00:	e1 f0       	breq	.+56     	; 0x6e3a <TraceName+0x56>
    6e02:	85 30       	cpi	r24, 0x05	; 5
    6e04:	a9 f5       	brne	.+106    	; 0x6e70 <TraceName+0x8c>
    6e06:	1c c0       	rjmp	.+56     	; 0x6e40 <TraceName+0x5c>
    6e08:	89 30       	cpi	r24, 0x09	; 9
    6e0a:	31 f1       	breq	.+76     	; 0x6e58 <TraceName+0x74>
    6e0c:	8a 30       	cpi	r24, 0x0A	; 10
    6e0e:	28 f4       	brcc	.+10     	; 0x6e1a <TraceName+0x36>
    6e10:	87 30       	cpi	r24, 0x07	; 7
    6e12:	e1 f0       	breq	.+56     	; 0x6e4c <TraceName+0x68>
    6e14:	88 30       	cpi	r24, 0x08	; 8
    6e16:	61 f5       	brne	.+88     	; 0x6e70 <TraceName+0x8c>
    6e18:	1c c0       	rjmp	.+56     	; 0x6e52 <TraceName+0x6e>
    6e1a:	8d 30       	cpi	r24, 0x0D	; 13
    6e1c:	01 f1       	breq	.+64     	; 0x6e5e <TraceName+0x7a>
    6e1e:	8e 30       	cpi	r24, 0x0E	; 14
    6e20:	09 f1       	breq	.+66     	; 0x6e64 <TraceName+0x80>
    6e22:	8c 30       	cpi	r24, 0x0C	; 12
    6e24:	29 f5       	brne	.+74     	; 0x6e70 <TraceName+0x8c>
    6e26:	21 c0       	rjmp	.+66     	; 0x6e6a <TraceName+0x86>
    6e28:	26 e3       	ldi	r18, 0x36	; 54
    6e2a:	39 e2       	ldi	r19, 0x29	; 41
    6e2c:	23 c0       	rjmp	.+70     	; 0x6e74 <TraceName+0x90>
    6e2e:	29 e4       	ldi	r18, 0x49	; 73
    6e30:	39 e2       	ldi	r19, 0x29	; 41
    6e32:	20 c0       	rjmp	.+64     	; 0x6e74 <TraceName+0x90>
    6e34:	2b e5       	ldi	r18, 0x5B	; 91
    6e36:	39 e2       	ldi	r19, 0x29	; 41
    6e38:	1d c0       	rjmp	.+58     	; 0x6e74 <TraceName+0x90>
	{
    case (PMDTracePositionError) 			: return (uint8*)"Error de Posicin"; break;
    case (PMDTraceCommandedPosition) 		: return (uint8*)"Posicion Comandada"; break;
    case (PMDTraceCommandedVelocity) 		: return (uint8*)"Velocidad Comandada"; break;
    6e3a:	2f e6       	ldi	r18, 0x6F	; 111
    6e3c:	39 e2       	ldi	r19, 0x29	; 41
    6e3e:	1a c0       	rjmp	.+52     	; 0x6e74 <TraceName+0x90>
    case (PMDTraceCommandedAcceleration) 	: return (uint8*)"Acceleracion Comandada"; break;
    6e40:	26 e8       	ldi	r18, 0x86	; 134
    6e42:	39 e2       	ldi	r19, 0x29	; 41
    6e44:	17 c0       	rjmp	.+46     	; 0x6e74 <TraceName+0x90>
    case (PMDTraceActualPosition) 			: return (uint8*)"Posicion Censada"; break;
    6e46:	27 e9       	ldi	r18, 0x97	; 151
    6e48:	39 e2       	ldi	r19, 0x29	; 41
    6e4a:	14 c0       	rjmp	.+40     	; 0x6e74 <TraceName+0x90>
    case (PMDTraceActualVelocity) 			: return (uint8*)"Velocidad Censada"; break;
    6e4c:	29 ea       	ldi	r18, 0xA9	; 169
    6e4e:	39 e2       	ldi	r19, 0x29	; 41
    6e50:	11 c0       	rjmp	.+34     	; 0x6e74 <TraceName+0x90>
    case (PMDTraceCurrentMotorCommand) 		: return (uint8*)"Registro MotorCommand"; break;
    6e52:	2f eb       	ldi	r18, 0xBF	; 191
    6e54:	39 e2       	ldi	r19, 0x29	; 41
    6e56:	0e c0       	rjmp	.+28     	; 0x6e74 <TraceName+0x90>
    case (PMDTraceTime) 					: return (uint8*)"Tiempo de Muestreo"; break;
    6e58:	22 ed       	ldi	r18, 0xD2	; 210
    6e5a:	39 e2       	ldi	r19, 0x29	; 41
    6e5c:	0b c0       	rjmp	.+22     	; 0x6e74 <TraceName+0x90>
	case (PMDTraceCaptureValue) 			: return (uint8*)"Registro de Captura"; break;
    6e5e:	26 ee       	ldi	r18, 0xE6	; 230
    6e60:	39 e2       	ldi	r19, 0x29	; 41
    6e62:	08 c0       	rjmp	.+16     	; 0x6e74 <TraceName+0x90>
    case (PMDTraceActivityStatus) 			: return (uint8*)"Registro ActivityStatus"; break;
    6e64:	2e ef       	ldi	r18, 0xFE	; 254
    6e66:	39 e2       	ldi	r19, 0x29	; 41
    6e68:	05 c0       	rjmp	.+10     	; 0x6e74 <TraceName+0x90>
    case (PMDTraceSignalStatus) 			: return (uint8*)"Registro SignalStatus"; break;
    6e6a:	24 e1       	ldi	r18, 0x14	; 20
    6e6c:	3a e2       	ldi	r19, 0x2A	; 42
    6e6e:	02 c0       	rjmp	.+4      	; 0x6e74 <TraceName+0x90>
	case (PMDTraceEventStatus) 				: return (uint8*)"Registro EventStatus"; break;
    6e70:	29 e2       	ldi	r18, 0x29	; 41
    6e72:	3a e2       	ldi	r19, 0x2A	; 42
    default 								: return (uint8*)"invalid Var";
  }
} // AxisName
    6e74:	c9 01       	movw	r24, r18
    6e76:	08 95       	ret

00006e78 <Tracetype>:

/*****************************************************************************************/
uint8 * Tracetype(PMDTraceVariable Trace)
{
	switch(Trace) 
    6e78:	86 30       	cpi	r24, 0x06	; 6
    6e7a:	d9 f0       	breq	.+54     	; 0x6eb2 <Tracetype+0x3a>
    6e7c:	87 30       	cpi	r24, 0x07	; 7
    6e7e:	60 f4       	brcc	.+24     	; 0x6e98 <Tracetype+0x20>
    6e80:	83 30       	cpi	r24, 0x03	; 3
    6e82:	b9 f0       	breq	.+46     	; 0x6eb2 <Tracetype+0x3a>
    6e84:	84 30       	cpi	r24, 0x04	; 4
    6e86:	18 f4       	brcc	.+6      	; 0x6e8e <Tracetype+0x16>
    6e88:	81 30       	cpi	r24, 0x01	; 1
    6e8a:	10 f1       	brcs	.+68     	; 0x6ed0 <Tracetype+0x58>
    6e8c:	15 c0       	rjmp	.+42     	; 0x6eb8 <Tracetype+0x40>
    6e8e:	84 30       	cpi	r24, 0x04	; 4
    6e90:	b1 f0       	breq	.+44     	; 0x6ebe <Tracetype+0x46>
    6e92:	85 30       	cpi	r24, 0x05	; 5
    6e94:	e9 f4       	brne	.+58     	; 0x6ed0 <Tracetype+0x58>
    6e96:	10 c0       	rjmp	.+32     	; 0x6eb8 <Tracetype+0x40>
    6e98:	89 30       	cpi	r24, 0x09	; 9
    6e9a:	b9 f0       	breq	.+46     	; 0x6eca <Tracetype+0x52>
    6e9c:	8a 30       	cpi	r24, 0x0A	; 10
    6e9e:	28 f4       	brcc	.+10     	; 0x6eaa <Tracetype+0x32>
    6ea0:	87 30       	cpi	r24, 0x07	; 7
    6ea2:	99 f0       	breq	.+38     	; 0x6eca <Tracetype+0x52>
    6ea4:	88 30       	cpi	r24, 0x08	; 8
    6ea6:	a1 f4       	brne	.+40     	; 0x6ed0 <Tracetype+0x58>
    6ea8:	0d c0       	rjmp	.+26     	; 0x6ec4 <Tracetype+0x4c>
    6eaa:	8c 50       	subi	r24, 0x0C	; 12
    6eac:	83 30       	cpi	r24, 0x03	; 3
    6eae:	80 f4       	brcc	.+32     	; 0x6ed0 <Tracetype+0x58>
    6eb0:	0c c0       	rjmp	.+24     	; 0x6eca <Tracetype+0x52>
    6eb2:	25 e3       	ldi	r18, 0x35	; 53
    6eb4:	3a e2       	ldi	r19, 0x2A	; 42
    6eb6:	0e c0       	rjmp	.+28     	; 0x6ed4 <Tracetype+0x5c>
    6eb8:	2e e3       	ldi	r18, 0x3E	; 62
    6eba:	3a e2       	ldi	r19, 0x2A	; 42
    6ebc:	0b c0       	rjmp	.+22     	; 0x6ed4 <Tracetype+0x5c>
    6ebe:	25 e4       	ldi	r18, 0x45	; 69
    6ec0:	3a e2       	ldi	r19, 0x2A	; 42
    6ec2:	08 c0       	rjmp	.+16     	; 0x6ed4 <Tracetype+0x5c>
		case (PMDTracePositionError): 		
		case (PMDTraceCommandedPosition): 	
		case (PMDTraceActualPosition) 			: return (uint8*)"Grados"; break;
		case (PMDTraceCommandedVelocity): 
		case (PMDTraceActualVelocity) 			: return (uint8*)"Grados/s"; break;
		case (PMDTraceCommandedAcceleration) 	: return (uint8*)"Grados/s^2"; break;
    6ec4:	20 e5       	ldi	r18, 0x50	; 80
    6ec6:	3a e2       	ldi	r19, 0x2A	; 42
    6ec8:	05 c0       	rjmp	.+10     	; 0x6ed4 <Tracetype+0x5c>
		case (PMDTraceTime) 					: return (uint8*)"ms"; break;
    6eca:	23 e5       	ldi	r18, 0x53	; 83
    6ecc:	3a e2       	ldi	r19, 0x2A	; 42
    6ece:	02 c0       	rjmp	.+4      	; 0x6ed4 <Tracetype+0x5c>
		case (PMDTraceCaptureValue): 			
		case (PMDTraceCurrentMotorCommand): 		
		case (PMDTraceEventStatus): 				
		case (PMDTraceActivityStatus): 			
		case (PMDTraceSignalStatus) 			: return (uint8*)"HEX"; break;
    6ed0:	27 e5       	ldi	r18, 0x57	; 87
    6ed2:	3a e2       	ldi	r19, 0x2A	; 42
		default 								: return (uint8*)"invalid";
	}
  }
    6ed4:	c9 01       	movw	r24, r18
    6ed6:	08 95       	ret

00006ed8 <CommandMsg>:

/*****************************************************************************************/
uint8 *CommandMsg(tCommand command)
 {
    6ed8:	df 93       	push	r29
    6eda:	cf 93       	push	r28
    6edc:	cd b7       	in	r28, 0x3d	; 61
    6ede:	de b7       	in	r29, 0x3e	; 62
  switch(command.CommandOP)
    6ee0:	ed 81       	ldd	r30, Y+5	; 0x05
    6ee2:	fe 81       	ldd	r31, Y+6	; 0x06
    6ee4:	e3 31       	cpi	r30, 0x13	; 19
    6ee6:	f1 05       	cpc	r31, r1
    6ee8:	08 f0       	brcs	.+2      	; 0x6eec <CommandMsg+0x14>
    6eea:	41 c0       	rjmp	.+130    	; 0x6f6e <CommandMsg+0x96>
    6eec:	ee 58       	subi	r30, 0x8E	; 142
    6eee:	ff 4f       	sbci	r31, 0xFF	; 255
    6ef0:	ee 0f       	add	r30, r30
    6ef2:	ff 1f       	adc	r31, r31
    6ef4:	05 90       	lpm	r0, Z+
    6ef6:	f4 91       	lpm	r31, Z+
    6ef8:	e0 2d       	mov	r30, r0
    6efa:	09 94       	ijmp
    6efc:	2f e5       	ldi	r18, 0x5F	; 95
    6efe:	3a e2       	ldi	r19, 0x2A	; 42
    6f00:	38 c0       	rjmp	.+112    	; 0x6f72 <CommandMsg+0x9a>
    6f02:	2b e6       	ldi	r18, 0x6B	; 107
    6f04:	3a e2       	ldi	r19, 0x2A	; 42
    6f06:	35 c0       	rjmp	.+106    	; 0x6f72 <CommandMsg+0x9a>
    6f08:	26 e7       	ldi	r18, 0x76	; 118
    6f0a:	3a e2       	ldi	r19, 0x2A	; 42
    6f0c:	32 c0       	rjmp	.+100    	; 0x6f72 <CommandMsg+0x9a>
 {
 
    case (CommandNOP) 					: return (uint8*)"no command"; break;
	case (CommandGoHome)			 	: return (uint8*)"go home cmd"; break;
	case (CommandGetAxisSettings) 		: return (uint8*)"get axis settings"; break;
    6f0e:	28 e8       	ldi	r18, 0x88	; 136
    6f10:	3a e2       	ldi	r19, 0x2A	; 42
    6f12:	2f c0       	rjmp	.+94     	; 0x6f72 <CommandMsg+0x9a>
    case (CommandOpenGripper) 			: return (uint8*)"open gripper cmd"; break;
    6f14:	29 e9       	ldi	r18, 0x99	; 153
    6f16:	3a e2       	ldi	r19, 0x2A	; 42
    6f18:	2c c0       	rjmp	.+88     	; 0x6f72 <CommandMsg+0x9a>
    case (CommandCloseGripper) 			: return (uint8*)"close gripper cmd"; break;
    6f1a:	2b ea       	ldi	r18, 0xAB	; 171
    6f1c:	3a e2       	ldi	r19, 0x2A	; 42
    6f1e:	29 c0       	rjmp	.+82     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandSetPoseEEPROM)			: return (uint8*)"Set Pose EEPROM cmd"; break;
    6f20:	2f eb       	ldi	r18, 0xBF	; 191
    6f22:	3a e2       	ldi	r19, 0x2A	; 42
    6f24:	26 c0       	rjmp	.+76     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandReSetPoseEEPROM)		: return (uint8*)"Reset Pose EEPROM cmd"; break;
    6f26:	25 ed       	ldi	r18, 0xD5	; 213
    6f28:	3a e2       	ldi	r19, 0x2A	; 42
    6f2a:	23 c0       	rjmp	.+70     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandGetPoseEEPROM)			: return (uint8*)"Get Pose EEPROM cmd"; break;
    6f2c:	29 ee       	ldi	r18, 0xE9	; 233
    6f2e:	3a e2       	ldi	r19, 0x2A	; 42
    6f30:	20 c0       	rjmp	.+64     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandGetPoseActual)			: return (uint8*)"Get Pose Actual cmd"; break;
    6f32:	2d ef       	ldi	r18, 0xFD	; 253
    6f34:	3a e2       	ldi	r19, 0x2A	; 42
    6f36:	1d c0       	rjmp	.+58     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandEraseEEPROM)			: return (uint8*)"Erase EEPROM cmd"; break;
    6f38:	2e e0       	ldi	r18, 0x0E	; 14
    6f3a:	3b e2       	ldi	r19, 0x2B	; 43
    6f3c:	1a c0       	rjmp	.+52     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandGetPosesID)			: return (uint8*)"Get Poses ID cmd"; break;
    6f3e:	2f e1       	ldi	r18, 0x1F	; 31
    6f40:	3b e2       	ldi	r19, 0x2B	; 43
    6f42:	17 c0       	rjmp	.+46     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandSetPMDTrace)			: return (uint8*)"Set PMD trace"; break;
    6f44:	2d e2       	ldi	r18, 0x2D	; 45
    6f46:	3b e2       	ldi	r19, 0x2B	; 43
    6f48:	14 c0       	rjmp	.+40     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandGetPMDTrace)			: return (uint8*)"Get PMD Trace"; break;
    6f4a:	2b e3       	ldi	r18, 0x3B	; 59
    6f4c:	3b e2       	ldi	r19, 0x2B	; 43
    6f4e:	11 c0       	rjmp	.+34     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandGetFecha)				: return (uint8*)"Get Fecha"; break;
    6f50:	25 e4       	ldi	r18, 0x45	; 69
    6f52:	3b e2       	ldi	r19, 0x2B	; 43
    6f54:	0e c0       	rjmp	.+28     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandGetMemory)				: return (uint8*)"Get Memory"; break;
    6f56:	20 e5       	ldi	r18, 0x50	; 80
    6f58:	3b e2       	ldi	r19, 0x2B	; 43
    6f5a:	0b c0       	rjmp	.+22     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandGetSensor)				: return (uint8*)"Get PMD Sensor"; break;
    6f5c:	2f e5       	ldi	r18, 0x5F	; 95
    6f5e:	3b e2       	ldi	r19, 0x2B	; 43
    6f60:	08 c0       	rjmp	.+16     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandGetEventStatus)		: return (uint8*)"Get PMD EventStatus"; break;
    6f62:	23 e7       	ldi	r18, 0x73	; 115
    6f64:	3b e2       	ldi	r19, 0x2B	; 43
    6f66:	05 c0       	rjmp	.+10     	; 0x6f72 <CommandMsg+0x9a>
	case (CommandGetAvtivityStatus)		: return (uint8*)"Get PMD AvtivityStatus"; break;
    6f68:	2a e8       	ldi	r18, 0x8A	; 138
    6f6a:	3b e2       	ldi	r19, 0x2B	; 43
    6f6c:	02 c0       	rjmp	.+4      	; 0x6f72 <CommandMsg+0x9a>
	case (CommandGetinfomov)			: return (uint8*)"Get PMD infomov"; break;
    6f6e:	2a e9       	ldi	r18, 0x9A	; 154
    6f70:	3b e2       	ldi	r19, 0x2B	; 43
	default 							: return (uint8*)"unknown cmd";
  }

//  return (uint8*)"CommandMsg";   // avoid compiler warning
} // CommandMsg
    6f72:	c9 01       	movw	r24, r18
    6f74:	cf 91       	pop	r28
    6f76:	df 91       	pop	r29
    6f78:	08 95       	ret

00006f7a <PacketMsg>:

/*****************************************************************************************/
uint8 *PacketMsg(tPacket packet) 
{

  switch(packet) {
    6f7a:	84 30       	cpi	r24, 0x04	; 4
    6f7c:	91 05       	cpc	r25, r1
    6f7e:	51 f1       	breq	.+84     	; 0x6fd4 <PacketMsg+0x5a>
    6f80:	85 30       	cpi	r24, 0x05	; 5
    6f82:	91 05       	cpc	r25, r1
    6f84:	7c f4       	brge	.+30     	; 0x6fa4 <PacketMsg+0x2a>
    6f86:	81 30       	cpi	r24, 0x01	; 1
    6f88:	91 05       	cpc	r25, r1
    6f8a:	c1 f0       	breq	.+48     	; 0x6fbc <PacketMsg+0x42>
    6f8c:	82 30       	cpi	r24, 0x02	; 2
    6f8e:	91 05       	cpc	r25, r1
    6f90:	1c f4       	brge	.+6      	; 0x6f98 <PacketMsg+0x1e>
    6f92:	89 2b       	or	r24, r25
    6f94:	b1 f0       	breq	.+44     	; 0x6fc2 <PacketMsg+0x48>
    6f96:	2d c0       	rjmp	.+90     	; 0x6ff2 <PacketMsg+0x78>
    6f98:	82 30       	cpi	r24, 0x02	; 2
    6f9a:	91 05       	cpc	r25, r1
    6f9c:	a9 f0       	breq	.+42     	; 0x6fc8 <PacketMsg+0x4e>
    6f9e:	03 97       	sbiw	r24, 0x03	; 3
    6fa0:	41 f5       	brne	.+80     	; 0x6ff2 <PacketMsg+0x78>
    6fa2:	15 c0       	rjmp	.+42     	; 0x6fce <PacketMsg+0x54>
    6fa4:	86 30       	cpi	r24, 0x06	; 6
    6fa6:	91 05       	cpc	r25, r1
    6fa8:	d9 f0       	breq	.+54     	; 0x6fe0 <PacketMsg+0x66>
    6faa:	86 30       	cpi	r24, 0x06	; 6
    6fac:	91 05       	cpc	r25, r1
    6fae:	ac f0       	brlt	.+42     	; 0x6fda <PacketMsg+0x60>
    6fb0:	87 30       	cpi	r24, 0x07	; 7
    6fb2:	91 05       	cpc	r25, r1
    6fb4:	c1 f0       	breq	.+48     	; 0x6fe6 <PacketMsg+0x6c>
    6fb6:	08 97       	sbiw	r24, 0x08	; 8
    6fb8:	e1 f4       	brne	.+56     	; 0x6ff2 <PacketMsg+0x78>
    6fba:	18 c0       	rjmp	.+48     	; 0x6fec <PacketMsg+0x72>
    6fbc:	26 ea       	ldi	r18, 0xA6	; 166
    6fbe:	3b e2       	ldi	r19, 0x2B	; 43
    6fc0:	1a c0       	rjmp	.+52     	; 0x6ff6 <PacketMsg+0x7c>
    6fc2:	21 eb       	ldi	r18, 0xB1	; 177
    6fc4:	3b e2       	ldi	r19, 0x2B	; 43
    6fc6:	17 c0       	rjmp	.+46     	; 0x6ff6 <PacketMsg+0x7c>
    6fc8:	2b eb       	ldi	r18, 0xBB	; 187
    6fca:	3b e2       	ldi	r19, 0x2B	; 43
    6fcc:	14 c0       	rjmp	.+40     	; 0x6ff6 <PacketMsg+0x7c>
    case (PacketNOP) 					:  return (uint8*)"no packet"; break;
    case (PacketCommand)				:  return (uint8*)"cmd packet"; break;
    case (PacketVector) 				:  return (uint8*)"vector packet"; break;
    6fce:	29 ec       	ldi	r18, 0xC9	; 201
    6fd0:	3b e2       	ldi	r19, 0x2B	; 43
    6fd2:	11 c0       	rjmp	.+34     	; 0x6ff6 <PacketMsg+0x7c>
    case (PacketTrajectory) 			:  return (uint8*)"trajectory packet"; break;
    6fd4:	2b ed       	ldi	r18, 0xDB	; 219
    6fd6:	3b e2       	ldi	r19, 0x2B	; 43
    6fd8:	0e c0       	rjmp	.+28     	; 0x6ff6 <PacketMsg+0x7c>
	case (PacketTeachPendant) 			:  return (uint8*)"TeachPendant packet"; break;
    6fda:	2f ee       	ldi	r18, 0xEF	; 239
    6fdc:	3b e2       	ldi	r19, 0x2B	; 43
    6fde:	0b c0       	rjmp	.+22     	; 0x6ff6 <PacketMsg+0x7c>
    case (PacketString) 				:  return (uint8*)"string packet"; break;
    6fe0:	2d ef       	ldi	r18, 0xFD	; 253
    6fe2:	3b e2       	ldi	r19, 0x2B	; 43
    6fe4:	08 c0       	rjmp	.+16     	; 0x6ff6 <PacketMsg+0x7c>
    case (PacketAxisSettings) 			: return (uint8*)"axis settings packet"; break;
    6fe6:	22 e1       	ldi	r18, 0x12	; 18
    6fe8:	3c e2       	ldi	r19, 0x2C	; 44
    6fea:	05 c0       	rjmp	.+10     	; 0x6ff6 <PacketMsg+0x7c>
    case (PacketAxisLimits) 			: return (uint8*)"axis limits packet"; break;
    6fec:	25 e2       	ldi	r18, 0x25	; 37
    6fee:	3c e2       	ldi	r19, 0x2C	; 44
    6ff0:	02 c0       	rjmp	.+4      	; 0x6ff6 <PacketMsg+0x7c>
	case (PacketHeader) 				: return (uint8*)"packet Header"; break;
    6ff2:	23 e3       	ldi	r18, 0x33	; 51
    6ff4:	3c e2       	ldi	r19, 0x2C	; 44
    
	default : return (uint8*)"unknown packet"; break;
  }

//  return (uint8*)"PacketMsg";    // avoid compiler warning
} // PacketMsg
    6ff6:	c9 01       	movw	r24, r18
    6ff8:	08 95       	ret

00006ffa <rcMsg>:

/*****************************************************************************************/
uint8 *rcMsg(tReturnCode rc) 
{

  switch(rc) {
    6ffa:	fc 01       	movw	r30, r24
    6ffc:	87 31       	cpi	r24, 0x17	; 23
    6ffe:	91 05       	cpc	r25, r1
    7000:	08 f0       	brcs	.+2      	; 0x7004 <rcMsg+0xa>
    7002:	44 c0       	rjmp	.+136    	; 0x708c <rcMsg+0x92>
    7004:	eb 57       	subi	r30, 0x7B	; 123
    7006:	ff 4f       	sbci	r31, 0xFF	; 255
    7008:	ee 0f       	add	r30, r30
    700a:	ff 1f       	adc	r31, r31
    700c:	05 90       	lpm	r0, Z+
    700e:	f4 91       	lpm	r31, Z+
    7010:	e0 2d       	mov	r30, r0
    7012:	09 94       	ijmp
    7014:	22 e4       	ldi	r18, 0x42	; 66
    7016:	3c e2       	ldi	r19, 0x2C	; 44
    7018:	3b c0       	rjmp	.+118    	; 0x7090 <rcMsg+0x96>
    701a:	21 e5       	ldi	r18, 0x51	; 81
    701c:	3c e2       	ldi	r19, 0x2C	; 44
    701e:	38 c0       	rjmp	.+112    	; 0x7090 <rcMsg+0x96>
    7020:	28 e5       	ldi	r18, 0x58	; 88
    7022:	3c e2       	ldi	r19, 0x2C	; 44
    7024:	35 c0       	rjmp	.+106    	; 0x7090 <rcMsg+0x96>
    case (rcOK) 						: return (uint8*)"all ok"; break;

// packet related:
    case (rcInvalidHeader) 				: return (uint8*)"invalid Header"; break;
    case (rcInvalidData) 				: return (uint8*)"invalid data"; break;
    7026:	25 e6       	ldi	r18, 0x65	; 101
    7028:	3c e2       	ldi	r19, 0x2C	; 44
    702a:	32 c0       	rjmp	.+100    	; 0x7090 <rcMsg+0x96>
    case (rcInvalidPacket) 				: return (uint8*)"invalid Packet"; break;
    702c:	24 e7       	ldi	r18, 0x74	; 116
    702e:	3c e2       	ldi	r19, 0x2C	; 44
    7030:	2f c0       	rjmp	.+94     	; 0x7090 <rcMsg+0x96>
    case (rcInvalidCommand) 			: return (uint8*)"invalid Command"; break;
    7032:	24 e8       	ldi	r18, 0x84	; 132
    7034:	3c e2       	ldi	r19, 0x2C	; 44
    7036:	2c c0       	rjmp	.+88     	; 0x7090 <rcMsg+0x96>
 //   case (rcInvalidError) 				: return (uint8*)"invalid Error"; break;
    case (rcInvalidChecksum) 			: return (uint8*)"invalidChecksum"; break;
    7038:	24 e9       	ldi	r18, 0x94	; 148
    703a:	3c e2       	ldi	r19, 0x2C	; 44
    703c:	29 c0       	rjmp	.+82     	; 0x7090 <rcMsg+0x96>
    case (rcInvalidHeaderChecksum) 		: return (uint8*)"invalidHeaderChecksum"; break;
    703e:	2a ea       	ldi	r18, 0xAA	; 170
    7040:	3c e2       	ldi	r19, 0x2C	; 44
    7042:	26 c0       	rjmp	.+76     	; 0x7090 <rcMsg+0x96>
    case (rcTooFewData) 				: return (uint8*)"too few data"; break;
    7044:	27 eb       	ldi	r18, 0xB7	; 183
    7046:	3c e2       	ldi	r19, 0x2C	; 44
    7048:	23 c0       	rjmp	.+70     	; 0x7090 <rcMsg+0x96>
//    case (rcTooMuchData) 				: return (uint8*)"too much data"; break;
    case (rcNoMemory) 					: return (uint8*)"no memory"; break;
    704a:	21 ec       	ldi	r18, 0xC1	; 193
    704c:	3c e2       	ldi	r19, 0x2C	; 44
    704e:	20 c0       	rjmp	.+64     	; 0x7090 <rcMsg+0x96>

// USB communication related:   
    case (rcTimeoutSendingData) 		: return (uint8*)"timeout sending data"; break;
    7050:	26 ed       	ldi	r18, 0xD6	; 214
    7052:	3c e2       	ldi	r19, 0x2C	; 44
    7054:	1d c0       	rjmp	.+58     	; 0x7090 <rcMsg+0x96>
    case (rcTimeoutReadingData) 		: return (uint8*)"timeout reading data"; break;
    7056:	2b ee       	ldi	r18, 0xEB	; 235
    7058:	3c e2       	ldi	r19, 0x2C	; 44
    705a:	1a c0       	rjmp	.+52     	; 0x7090 <rcMsg+0x96>
    case (rcCommunicationError) 		: return (uint8*)"communication error"; break;
    705c:	2f ef       	ldi	r18, 0xFF	; 255
    705e:	3c e2       	ldi	r19, 0x2C	; 44
    7060:	17 c0       	rjmp	.+46     	; 0x7090 <rcMsg+0x96>
//    case (rcUnexpectedResponse) 		: return (uint8*)"unexpected response"; break;
    case (rcUnexpectedState) 			: return (uint8*)"unexpected ISA interface state"; break;
    7062:	2e e1       	ldi	r18, 0x1E	; 30
    7064:	3d e2       	ldi	r19, 0x2D	; 45
    7066:	14 c0       	rjmp	.+40     	; 0x7090 <rcMsg+0x96>
//    case (rcUCisBusy) 					: return (uint8*)"uC is busy"; break;
//    case (rcUCNeedsReset) 				: return (uint8*)"uC needs reset"; break;
//    case (rcUCNeedsInitialization) 		: return (uint8*)"uC needs initialisation"; break;

// robot related:
    case (rcHardwareFailure) 			: return (uint8*)"hardware failure"; break;
    7068:	2f e2       	ldi	r18, 0x2F	; 47
    706a:	3d e2       	ldi	r19, 0x2D	; 45
    706c:	11 c0       	rjmp	.+34     	; 0x7090 <rcMsg+0x96>
//    case (rcVelocityLimitExceeded) 		: return (uint8*)"velocity too high"; break;
 //   case (rcAccelerationLimitExceeded) 	: return (uint8*)"acceleration too high"; break;
	
// for the PMD reset:
    case (rcPMDChipsetResetError) 		: return (uint8*)"PMD chipset reset error"; break;
    706e:	27 e4       	ldi	r18, 0x47	; 71
    7070:	3d e2       	ldi	r19, 0x2D	; 45
    7072:	0e c0       	rjmp	.+28     	; 0x7090 <rcMsg+0x96>
//    case (rcPMDCommandError) 			: return (uint8*)"PMD cmd error"; break;
    case (rcPMDchecksumError) 			: return (uint8*)"PMD checksum wrong"; break;
    7074:	2a e5       	ldi	r18, 0x5A	; 90
    7076:	3d e2       	ldi	r19, 0x2D	; 45
    7078:	0b c0       	rjmp	.+22     	; 0x7090 <rcMsg+0x96>
//    case (rcPMDstuckBit1) 				: return (uint8*)"PMD data line stuck at 1"; break;
 //   case (rcPMDtimeout) 				: return (uint8*)"PMD communication timeout"; break;
//    case (rcOtherError) 				: return (uint8*)"unspecified rc code"; break;
	
// file procecing related	
	case (rcFileOpenError) 				: return (uint8*)"Open File Error"; break;
    707a:	2a e6       	ldi	r18, 0x6A	; 106
    707c:	3d e2       	ldi	r19, 0x2D	; 45
    707e:	08 c0       	rjmp	.+16     	; 0x7090 <rcMsg+0x96>
	case (rcFileOpenOK) 				: return (uint8*)"Open File OK"; break;
    7080:	27 e7       	ldi	r18, 0x77	; 119
    7082:	3d e2       	ldi	r19, 0x2D	; 45
    7084:	05 c0       	rjmp	.+10     	; 0x7090 <rcMsg+0x96>
	case (rcFileReadOK) 				: return (uint8*)"Read File OK"; break;
    7086:	24 e8       	ldi	r18, 0x84	; 132
    7088:	3d e2       	ldi	r19, 0x2D	; 45
    708a:	02 c0       	rjmp	.+4      	; 0x7090 <rcMsg+0x96>
	case (rcFileReadError) 				: return (uint8*)"Read File Error"; break;
    708c:	24 e9       	ldi	r18, 0x94	; 148
    708e:	3d e2       	ldi	r19, 0x2D	; 45
    
	default : return (uint8*)"unknown rc code"; break;
  }

 // return (uint8*)"rcMsg";    // avoid compiler warning
} // rcMsg
    7090:	c9 01       	movw	r24, r18
    7092:	08 95       	ret

00007094 <PMDGetOpcodeText>:
//*****************************************************************************
uint8 *PMDGetOpcodeText(PMDuint16 opCode)
{
	opCode=opCode & 0xff;

	switch(opCode) {
    7094:	a0 e0       	ldi	r26, 0x00	; 0
    7096:	b0 e0       	ldi	r27, 0x00	; 0
    7098:	90 70       	andi	r25, 0x00	; 0
    709a:	a0 70       	andi	r26, 0x00	; 0
    709c:	b0 70       	andi	r27, 0x00	; 0
    709e:	fc 01       	movw	r30, r24
    70a0:	89 3f       	cpi	r24, 0xF9	; 249
    70a2:	91 05       	cpc	r25, r1
    70a4:	08 f0       	brcs	.+2      	; 0x70a8 <PMDGetOpcodeText+0x14>
    70a6:	f4 c1       	rjmp	.+1000   	; 0x7490 <PMDGetOpcodeText+0x3fc>
    70a8:	e4 56       	subi	r30, 0x64	; 100
    70aa:	ff 4f       	sbci	r31, 0xFF	; 255
    70ac:	ee 0f       	add	r30, r30
    70ae:	ff 1f       	adc	r31, r31
    70b0:	05 90       	lpm	r0, Z+
    70b2:	f4 91       	lpm	r31, Z+
    70b4:	e0 2d       	mov	r30, r0
    70b6:	09 94       	ijmp
    70b8:	24 ea       	ldi	r18, 0xA4	; 164
    70ba:	3d e2       	ldi	r19, 0x2D	; 45
    70bc:	eb c1       	rjmp	.+982    	; 0x7494 <PMDGetOpcodeText+0x400>
    70be:	22 eb       	ldi	r18, 0xB2	; 178
    70c0:	3d e2       	ldi	r19, 0x2D	; 45
    70c2:	e8 c1       	rjmp	.+976    	; 0x7494 <PMDGetOpcodeText+0x400>
    70c4:	26 eb       	ldi	r18, 0xB6	; 182
    70c6:	3d e2       	ldi	r19, 0x2D	; 45
    70c8:	e5 c1       	rjmp	.+970    	; 0x7494 <PMDGetOpcodeText+0x400>
	
	case (PMDOPNoOperation)				: return (uint8*)"Nop"; break;
	case (PMDOPSetMotorLimit) 			: return (uint8*)"SetMotorLimit"; break;
	case (PMDOPGetMotorLimit) 			: return (uint8*)"GetMotorLimit"; break;
    70ca:	24 ec       	ldi	r18, 0xC4	; 196
    70cc:	3d e2       	ldi	r19, 0x2D	; 45
    70ce:	e2 c1       	rjmp	.+964    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetMotorBias) 			: return (uint8*)"SetMotorBias"	; break;
    70d0:	21 ed       	ldi	r18, 0xD1	; 209
    70d2:	3d e2       	ldi	r19, 0x2D	; 45
    70d4:	df c1       	rjmp	.+958    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetPosition) 			: return (uint8*)"SetPosition"	; break;
    70d6:	2d ed       	ldi	r18, 0xDD	; 221
    70d8:	3d e2       	ldi	r19, 0x2D	; 45
    70da:	dc c1       	rjmp	.+952    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetVelocity) 			: return (uint8*)"SetVelocity"; break;
    70dc:	29 ee       	ldi	r18, 0xE9	; 233
    70de:	3d e2       	ldi	r19, 0x2D	; 45
    70e0:	d9 c1       	rjmp	.+946    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetJerk) 				: return (uint8*)"SetJerk"	; break;
    70e2:	21 ef       	ldi	r18, 0xF1	; 241
    70e4:	3d e2       	ldi	r19, 0x2D	; 45
    70e6:	d6 c1       	rjmp	.+940    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetGearRatio) 			: return (uint8*)"SetGearRatio"	; break;
    70e8:	2e ef       	ldi	r18, 0xFE	; 254
    70ea:	3d e2       	ldi	r19, 0x2D	; 45
    70ec:	d3 c1       	rjmp	.+934    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPUpdate) 					: return (uint8*)"Update"; break;
    70ee:	25 e0       	ldi	r18, 0x05	; 5
    70f0:	3e e2       	ldi	r19, 0x2E	; 46
    70f2:	d0 c1       	rjmp	.+928    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetCommandedPosition)	: return (uint8*)"GetCommandedPosition"	; break;
    70f4:	2a e1       	ldi	r18, 0x1A	; 26
    70f6:	3e e2       	ldi	r19, 0x2E	; 46
    70f8:	cd c1       	rjmp	.+922    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetCommandedVelocity) 	: return (uint8*)"GetCommandedVelocity"	; break;
    70fa:	2f e2       	ldi	r18, 0x2F	; 47
    70fc:	3e e2       	ldi	r19, 0x2E	; 46
    70fe:	ca c1       	rjmp	.+916    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetKp) 					: return (uint8*)"SetKp"; break;
    7100:	25 e3       	ldi	r18, 0x35	; 53
    7102:	3e e2       	ldi	r19, 0x2E	; 46
    7104:	c7 c1       	rjmp	.+910    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetKi) 					: return (uint8*)"SetKi"; break;
    7106:	2b e3       	ldi	r18, 0x3B	; 59
    7108:	3e e2       	ldi	r19, 0x2E	; 46
    710a:	c4 c1       	rjmp	.+904    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetKd) 					: return (uint8*)"SetKd"; break;
    710c:	21 e4       	ldi	r18, 0x41	; 65
    710e:	3e e2       	ldi	r19, 0x2E	; 46
    7110:	c1 c1       	rjmp	.+898    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetKvff) 				: return (uint8*)"SetKvff"; break;
    7112:	29 e4       	ldi	r18, 0x49	; 73
    7114:	3e e2       	ldi	r19, 0x2E	; 46
    7116:	be c1       	rjmp	.+892    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseAngle) 			: return (uint8*)"GetPhaseAngle"; break;
    7118:	27 e5       	ldi	r18, 0x57	; 87
    711a:	3e e2       	ldi	r19, 0x2E	; 46
    711c:	bb c1       	rjmp	.+886    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetMotorBias) 			: return (uint8*)"GetMotorBias"	; break;
    711e:	24 e6       	ldi	r18, 0x64	; 100
    7120:	3e e2       	ldi	r19, 0x2E	; 46
    7122:	b8 c1       	rjmp	.+880    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetInterruptMask) 		: return (uint8*)"SetInterruptMask"	; break;
    7124:	25 e7       	ldi	r18, 0x75	; 117
    7126:	3e e2       	ldi	r19, 0x2E	; 46
    7128:	b5 c1       	rjmp	.+874    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetEventStatus) 			: return (uint8*)"GetEventStatus"; break;
    712a:	24 e8       	ldi	r18, 0x84	; 132
    712c:	3e e2       	ldi	r19, 0x2E	; 46
    712e:	b2 c1       	rjmp	.+868    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPResetEventStatus) 		: return (uint8*)"ResetEventStatus"	; break;
    7130:	25 e9       	ldi	r18, 0x95	; 149
    7132:	3e e2       	ldi	r19, 0x2E	; 46
    7134:	af c1       	rjmp	.+862    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetCaptureValue) 		: return (uint8*)"GetCaptureValue"; break;
    7136:	25 ea       	ldi	r18, 0xA5	; 165
    7138:	3e e2       	ldi	r19, 0x2E	; 46
    713a:	ac c1       	rjmp	.+856    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetActualPosition) 		: return (uint8*)"GetActualPosition"; break;
    713c:	27 eb       	ldi	r18, 0xB7	; 183
    713e:	3e e2       	ldi	r19, 0x2E	; 46
    7140:	a9 c1       	rjmp	.+850    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetSampleTime) 			: return (uint8*)"SetSampleTime"; break;
    7142:	25 ec       	ldi	r18, 0xC5	; 197
    7144:	3e e2       	ldi	r19, 0x2E	; 46
    7146:	a6 c1       	rjmp	.+844    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPReset) 					: return (uint8*)"Reset"; break;
    7148:	2b ec       	ldi	r18, 0xCB	; 203
    714a:	3e e2       	ldi	r19, 0x2E	; 46
    714c:	a3 c1       	rjmp	.+838    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetCurrentMotorCommand)	: return (uint8*)"GetCurrentMotorCommand"; break;
    714e:	22 ee       	ldi	r18, 0xE2	; 226
    7150:	3e e2       	ldi	r19, 0x2E	; 46
    7152:	a0 c1       	rjmp	.+832    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetTime) 				: return (uint8*)"GetTime"; break;
    7154:	2a ee       	ldi	r18, 0xEA	; 234
    7156:	3e e2       	ldi	r19, 0x2E	; 46
    7158:	9d c1       	rjmp	.+826    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPClearPositionError) 		: return (uint8*)"ClearPositionError"; break;
    715a:	2d ef       	ldi	r18, 0xFD	; 253
    715c:	3e e2       	ldi	r19, 0x2E	; 46
    715e:	9a c1       	rjmp	.+820    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetPosition) 			: return (uint8*)"GetPosition"; break;
    7160:	29 e0       	ldi	r18, 0x09	; 9
    7162:	3f e2       	ldi	r19, 0x2F	; 47
    7164:	97 c1       	rjmp	.+814    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetVelocity) 			: return (uint8*)"GetVelocity"; break;
    7166:	25 e1       	ldi	r18, 0x15	; 21
    7168:	3f e2       	ldi	r19, 0x2F	; 47
    716a:	94 c1       	rjmp	.+808    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetAcceleration) 		: return (uint8*)"GetAcceleration"; break;
    716c:	25 e2       	ldi	r18, 0x25	; 37
    716e:	3f e2       	ldi	r19, 0x2F	; 47
    7170:	91 c1       	rjmp	.+802    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetActualPosition) 		: return (uint8*)"SetActualPosition"; break;
    7172:	27 e3       	ldi	r18, 0x37	; 55
    7174:	3f e2       	ldi	r19, 0x2F	; 47
    7176:	8e c1       	rjmp	.+796    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetKp) 					: return (uint8*)"GetKp"; break;
    7178:	2d e3       	ldi	r18, 0x3D	; 61
    717a:	3f e2       	ldi	r19, 0x2F	; 47
    717c:	8b c1       	rjmp	.+790    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetKi) 					: return (uint8*)"GetKi"; break;
    717e:	23 e4       	ldi	r18, 0x43	; 67
    7180:	3f e2       	ldi	r19, 0x2F	; 47
    7182:	88 c1       	rjmp	.+784    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetKd) 					: return (uint8*)"GetKd"; break;
    7184:	29 e4       	ldi	r18, 0x49	; 73
    7186:	3f e2       	ldi	r19, 0x2F	; 47
    7188:	85 c1       	rjmp	.+778    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetKvff) 				: return (uint8*)"GetKvff"; break;
    718a:	21 e5       	ldi	r18, 0x51	; 81
    718c:	3f e2       	ldi	r19, 0x2F	; 47
    718e:	82 c1       	rjmp	.+772    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetInterruptMask)		: return (uint8*)"GetInterruptMask"	; break;
    7190:	22 e6       	ldi	r18, 0x62	; 98
    7192:	3f e2       	ldi	r19, 0x2F	; 47
    7194:	7f c1       	rjmp	.+766    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetJerk) 				: return (uint8*)"GetJerk"; break;
    7196:	2a e6       	ldi	r18, 0x6A	; 106
    7198:	3f e2       	ldi	r19, 0x2F	; 47
    719a:	7c c1       	rjmp	.+760    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetGearRatio)			: return (uint8*)"GetGearRatio"	; break;
    719c:	27 e7       	ldi	r18, 0x77	; 119
    719e:	3f e2       	ldi	r19, 0x2F	; 47
    71a0:	79 c1       	rjmp	.+754    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPMultiUpdate) 			: return (uint8*)"MultiUpdate"; break;
    71a2:	23 e8       	ldi	r18, 0x83	; 131
    71a4:	3f e2       	ldi	r19, 0x2F	; 47
    71a6:	76 c1       	rjmp	.+748    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetSampleTime) 			: return (uint8*)"GetSampleTime"; break;
    71a8:	21 e9       	ldi	r18, 0x91	; 145
    71aa:	3f e2       	ldi	r19, 0x2F	; 47
    71ac:	73 c1       	rjmp	.+742    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetMotorCommand) 		: return (uint8*)"GetMotorCommand"; break;
    71ae:	21 ea       	ldi	r18, 0xA1	; 161
    71b0:	3f e2       	ldi	r19, 0x2F	; 47
    71b2:	70 c1       	rjmp	.+736    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetStartVelocity) 		: return (uint8*)"SetStartVelocity"; break;
    71b4:	22 eb       	ldi	r18, 0xB2	; 178
    71b6:	3f e2       	ldi	r19, 0x2F	; 47
    71b8:	6d c1       	rjmp	.+730    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetStartVelocity) 		: return (uint8*)"GetStartVelocity"; break;
    71ba:	23 ec       	ldi	r18, 0xC3	; 195
    71bc:	3f e2       	ldi	r19, 0x2F	; 47
    71be:	6a c1       	rjmp	.+724    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetOutputMode) 			: return (uint8*)"GetOutputMode"; break;
    71c0:	21 ed       	ldi	r18, 0xD1	; 209
    71c2:	3f e2       	ldi	r19, 0x2F	; 47
    71c4:	67 c1       	rjmp	.+718    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseInitializeTime)	: return (uint8*)"SetPhaseInitializeTime"; break;
    71c6:	28 ee       	ldi	r18, 0xE8	; 232
    71c8:	3f e2       	ldi	r19, 0x2F	; 47
    71ca:	64 c1       	rjmp	.+712    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseCounts) 			: return (uint8*)"SetPhaseCounts"; break;
    71cc:	27 ef       	ldi	r18, 0xF7	; 247
    71ce:	3f e2       	ldi	r19, 0x2F	; 47
    71d0:	61 c1       	rjmp	.+706    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseOffset) 			: return (uint8*)"SetPhaseOffset"; break;
    71d2:	26 e0       	ldi	r18, 0x06	; 6
    71d4:	30 e3       	ldi	r19, 0x30	; 48
    71d6:	5e c1       	rjmp	.+700    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetMotorCommand) 		: return (uint8*)"SetMotorCommand"; break;
    71d8:	26 e1       	ldi	r18, 0x16	; 22
    71da:	30 e3       	ldi	r19, 0x30	; 48
    71dc:	5b c1       	rjmp	.+694    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPInitializePhase) 		: return (uint8*)"InitializePhase"; break;
    71de:	26 e2       	ldi	r18, 0x26	; 38
    71e0:	30 e3       	ldi	r19, 0x30	; 48
    71e2:	58 c1       	rjmp	.+688    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseOffset) 			: return (uint8*)"GetPhaseOffset"; break;
    71e4:	25 e3       	ldi	r18, 0x35	; 53
    71e6:	30 e3       	ldi	r19, 0x30	; 48
    71e8:	55 c1       	rjmp	.+682    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseInitializeTime)	: return (uint8*)"GetPhaseInitializeTime"; break;
    71ea:	2c e4       	ldi	r18, 0x4C	; 76
    71ec:	30 e3       	ldi	r19, 0x30	; 48
    71ee:	52 c1       	rjmp	.+676    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseCounts) 			: return (uint8*)"GetPhaseCounts"; break;
    71f0:	2b e5       	ldi	r18, 0x5B	; 91
    71f2:	30 e3       	ldi	r19, 0x30	; 48
    71f4:	4f c1       	rjmp	.+670    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetLimitSwitchMode) 		: return (uint8*)"SetLimitSwitchMode"; break;
    71f6:	2e e6       	ldi	r18, 0x6E	; 110
    71f8:	30 e3       	ldi	r19, 0x30	; 48
    71fa:	4c c1       	rjmp	.+664    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetLimitSwitchMode) 		: return (uint8*)"GetLimitSwitchMode"; break;
    71fc:	21 e8       	ldi	r18, 0x81	; 129
    71fe:	30 e3       	ldi	r19, 0x30	; 48
    7200:	49 c1       	rjmp	.+658    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPWriteIO) 				: return (uint8*)"WriteIO"; break;
    7202:	29 e8       	ldi	r18, 0x89	; 137
    7204:	30 e3       	ldi	r19, 0x30	; 48
    7206:	46 c1       	rjmp	.+652    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPReadIO) 					: return (uint8*)"ReadIO"; break;
    7208:	20 e9       	ldi	r18, 0x90	; 144
    720a:	30 e3       	ldi	r19, 0x30	; 48
    720c:	43 c1       	rjmp	.+646    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseAngle) 			: return (uint8*)"SetPhaseAngle"; break;
    720e:	2e e9       	ldi	r18, 0x9E	; 158
    7210:	30 e3       	ldi	r19, 0x30	; 48
    7212:	40 c1       	rjmp	.+640    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetNumberPhases) 		: return (uint8*)"SetNumberPhases"; break;
    7214:	2e ea       	ldi	r18, 0xAE	; 174
    7216:	30 e3       	ldi	r19, 0x30	; 48
    7218:	3d c1       	rjmp	.+634    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetNumberPhases) 		: return (uint8*)"GetNumberPhases"; break;
    721a:	2e eb       	ldi	r18, 0xBE	; 190
    721c:	30 e3       	ldi	r19, 0x30	; 48
    721e:	3a c1       	rjmp	.+628    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetAxisMode) 			: return (uint8*)"SetAxisMode"	; break;
    7220:	2a ec       	ldi	r18, 0xCA	; 202
    7222:	30 e3       	ldi	r19, 0x30	; 48
    7224:	37 c1       	rjmp	.+622    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetAxisMode) 			: return (uint8*)"GetAxisMode"; break;
    7226:	26 ed       	ldi	r18, 0xD6	; 214
    7228:	30 e3       	ldi	r19, 0x30	; 48
    722a:	34 c1       	rjmp	.+616    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetDiagnosticPortMode)	: return (uint8*)"SetDiagnosticPortMode"; break;
    722c:	2c ee       	ldi	r18, 0xEC	; 236
    722e:	30 e3       	ldi	r19, 0x30	; 48
    7230:	31 c1       	rjmp	.+610    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetDiagnosticPortMode)	: return (uint8*)"GetDiagnosticPortMode"; break;
    7232:	22 e0       	ldi	r18, 0x02	; 2
    7234:	31 e3       	ldi	r19, 0x31	; 49
    7236:	2e c1       	rjmp	.+604    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetSerialPortMode) 		: return (uint8*)"SetSerialPortMode"; break;
    7238:	24 e1       	ldi	r18, 0x14	; 20
    723a:	31 e3       	ldi	r19, 0x31	; 49
    723c:	2b c1       	rjmp	.+598    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetSerialPortMode)		: return (uint8*)"GetSerialPortMode"; break;
    723e:	26 e2       	ldi	r18, 0x26	; 38
    7240:	31 e3       	ldi	r19, 0x31	; 49
    7242:	28 c1       	rjmp	.+592    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetEncoderModulus) 		: return (uint8*)"SetEncoderModulus"; break;
    7244:	28 e3       	ldi	r18, 0x38	; 56
    7246:	31 e3       	ldi	r19, 0x31	; 49
    7248:	25 c1       	rjmp	.+586    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetEncoderModulus) 		: return (uint8*)"GetEncoderModulus"; break;
    724a:	2a e4       	ldi	r18, 0x4A	; 74
    724c:	31 e3       	ldi	r19, 0x31	; 49
    724e:	22 c1       	rjmp	.+580    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetVersion) 				: return (uint8*)"GetVersion"; break;
    7250:	25 e5       	ldi	r18, 0x55	; 85
    7252:	31 e3       	ldi	r19, 0x31	; 49
    7254:	1f c1       	rjmp	.+574    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetAcceleration)			: return (uint8*)"SetAcceleration"; break;
    7256:	25 e6       	ldi	r18, 0x65	; 101
    7258:	31 e3       	ldi	r19, 0x31	; 49
    725a:	1c c1       	rjmp	.+568    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetDeceleration) 		: return (uint8*)"SetDeceleration"; break;
    725c:	25 e7       	ldi	r18, 0x75	; 117
    725e:	31 e3       	ldi	r19, 0x31	; 49
    7260:	19 c1       	rjmp	.+562    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetDeceleration) 		: return (uint8*)"GetDeceleration"; break;
    7262:	25 e8       	ldi	r18, 0x85	; 133
    7264:	31 e3       	ldi	r19, 0x31	; 49
    7266:	16 c1       	rjmp	.+556    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetKaff) 				: return (uint8*)"SetKaff"; break;
    7268:	2d e8       	ldi	r18, 0x8D	; 141
    726a:	31 e3       	ldi	r19, 0x31	; 49
    726c:	13 c1       	rjmp	.+550    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetKaff) 				: return (uint8*)"GetKaff"; break;
    726e:	25 e9       	ldi	r18, 0x95	; 149
    7270:	31 e3       	ldi	r19, 0x31	; 49
    7272:	10 c1       	rjmp	.+544    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetIntegrationLimit)		: return (uint8*)"SetIntegrationLimit"; break;
    7274:	29 ea       	ldi	r18, 0xA9	; 169
    7276:	31 e3       	ldi	r19, 0x31	; 49
    7278:	0d c1       	rjmp	.+538    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetIntegrationLimit) 	: return (uint8*)"GetIntegrationLimit"; break;
    727a:	2d eb       	ldi	r18, 0xBD	; 189
    727c:	31 e3       	ldi	r19, 0x31	; 49
    727e:	0a c1       	rjmp	.+532    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetPositionErrorLimit) 	: return (uint8*)"SetPositionErrorLimit"; break;
    7280:	23 ed       	ldi	r18, 0xD3	; 211
    7282:	31 e3       	ldi	r19, 0x31	; 49
    7284:	07 c1       	rjmp	.+526    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetPositionErrorLimit)	: return (uint8*)"GetPositionErrorLimit"; break;
    7286:	29 ee       	ldi	r18, 0xE9	; 233
    7288:	31 e3       	ldi	r19, 0x31	; 49
    728a:	04 c1       	rjmp	.+520    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetPositionError) 		: return (uint8*)"GetPositionError"	; break;
    728c:	2a ef       	ldi	r18, 0xFA	; 250
    728e:	31 e3       	ldi	r19, 0x31	; 49
    7290:	01 c1       	rjmp	.+514    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetIntegral) 			: return (uint8*)"GetIntegral"; break;
    7292:	26 e0       	ldi	r18, 0x06	; 6
    7294:	32 e3       	ldi	r19, 0x32	; 50
    7296:	fe c0       	rjmp	.+508    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetDerivative) 			: return (uint8*)"GetDerivative"; break;
    7298:	24 e1       	ldi	r18, 0x14	; 20
    729a:	32 e3       	ldi	r19, 0x32	; 50
    729c:	fb c0       	rjmp	.+502    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetDerivativeTime) 		: return (uint8*)"SetDerivativeTime"; break;
    729e:	26 e2       	ldi	r18, 0x26	; 38
    72a0:	32 e3       	ldi	r19, 0x32	; 50
    72a2:	f8 c0       	rjmp	.+496    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetDerivativeTime) 		: return (uint8*)"GetDerivativeTime"; break;
    72a4:	28 e3       	ldi	r18, 0x38	; 56
    72a6:	32 e3       	ldi	r19, 0x32	; 50
    72a8:	f5 c0       	rjmp	.+490    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetKout) 				: return (uint8*)"SetKout"; break;
    72aa:	20 e4       	ldi	r18, 0x40	; 64
    72ac:	32 e3       	ldi	r19, 0x32	; 50
    72ae:	f2 c0       	rjmp	.+484    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetKout) 				: return (uint8*)"GetKout"; break;
    72b0:	28 e4       	ldi	r18, 0x48	; 72
    72b2:	32 e3       	ldi	r19, 0x32	; 50
    72b4:	ef c0       	rjmp	.+478    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetProfileMode)			: return (uint8*)"SetProfileMode"; break;
    72b6:	27 e5       	ldi	r18, 0x57	; 87
    72b8:	32 e3       	ldi	r19, 0x32	; 50
    72ba:	ec c0       	rjmp	.+472    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetProfileMode) 			: return (uint8*)"GetProfileMode"; break;
    72bc:	26 e6       	ldi	r18, 0x66	; 102
    72be:	32 e3       	ldi	r19, 0x32	; 50
    72c0:	e9 c0       	rjmp	.+466    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetSignalSense) 			: return (uint8*)"SetSignalSense"; break;
    72c2:	25 e7       	ldi	r18, 0x75	; 117
    72c4:	32 e3       	ldi	r19, 0x32	; 50
    72c6:	e6 c0       	rjmp	.+460    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetSignalSense) 			: return (uint8*)"GetSignalSense"; break;
    72c8:	24 e8       	ldi	r18, 0x84	; 132
    72ca:	32 e3       	ldi	r19, 0x32	; 50
    72cc:	e3 c0       	rjmp	.+454    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetSignalStatus) 		: return (uint8*)"GetSignalStatus"; break;
    72ce:	24 e9       	ldi	r18, 0x94	; 148
    72d0:	32 e3       	ldi	r19, 0x32	; 50
    72d2:	e0 c0       	rjmp	.+448    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetHostIOError) 			: return (uint8*)"GetHostIOError"; break;
    72d4:	23 ea       	ldi	r18, 0xA3	; 163
    72d6:	32 e3       	ldi	r19, 0x32	; 50
    72d8:	dd c0       	rjmp	.+442    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetActivityStatus) 		: return (uint8*)"GetActivityStatus"; break;
    72da:	25 eb       	ldi	r18, 0xB5	; 181
    72dc:	32 e3       	ldi	r19, 0x32	; 50
    72de:	da c0       	rjmp	.+436    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetCommandedAcceleration): return (uint8*)"GetCommandedAcceleration"; break;
    72e0:	2e ec       	ldi	r18, 0xCE	; 206
    72e2:	32 e3       	ldi	r19, 0x32	; 50
    72e4:	d7 c0       	rjmp	.+430    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetTrackingWindow) 		: return (uint8*)"SetTrackingWindow"; break;
    72e6:	20 ee       	ldi	r18, 0xE0	; 224
    72e8:	32 e3       	ldi	r19, 0x32	; 50
    72ea:	d4 c0       	rjmp	.+424    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetTrackingWindow) 		: return (uint8*)"GetTrackingWindow"; break;
    72ec:	22 ef       	ldi	r18, 0xF2	; 242
    72ee:	32 e3       	ldi	r19, 0x32	; 50
    72f0:	d1 c0       	rjmp	.+418    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetSettleTime) 			: return (uint8*)"SetSettleTime"; break;
    72f2:	20 e0       	ldi	r18, 0x00	; 0
    72f4:	33 e3       	ldi	r19, 0x33	; 51
    72f6:	ce c0       	rjmp	.+412    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetSettleTime) 			: return (uint8*)"GetSettleTime"; break;
    72f8:	2e e0       	ldi	r18, 0x0E	; 14
    72fa:	33 e3       	ldi	r19, 0x33	; 51
    72fc:	cb c0       	rjmp	.+406    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPClearInterrupt) 			: return (uint8*)"ClearInterrupt"; break;
    72fe:	2d e1       	ldi	r18, 0x1D	; 29
    7300:	33 e3       	ldi	r19, 0x33	; 51
    7302:	c8 c0       	rjmp	.+400    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetActualVelocity) 		: return (uint8*)"GetActualVelocity"; break;
    7304:	2f e2       	ldi	r18, 0x2F	; 47
    7306:	33 e3       	ldi	r19, 0x33	; 51
    7308:	c5 c0       	rjmp	.+394    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetGearMaster) 			: return (uint8*)"SetGearMaster"; break;
    730a:	2d e3       	ldi	r18, 0x3D	; 61
    730c:	33 e3       	ldi	r19, 0x33	; 51
    730e:	c2 c0       	rjmp	.+388    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetGearMaster) 			: return (uint8*)"GetGearMaster"; break;
    7310:	2b e4       	ldi	r18, 0x4B	; 75
    7312:	33 e3       	ldi	r19, 0x33	; 51
    7314:	bf c0       	rjmp	.+382    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetTraceMode) 			: return (uint8*)"SetTraceMode"	; break;
    7316:	28 e5       	ldi	r18, 0x58	; 88
    7318:	33 e3       	ldi	r19, 0x33	; 51
    731a:	bc c0       	rjmp	.+376    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceMode) 			: return (uint8*)"GetTraceMode"	; break;
    731c:	25 e6       	ldi	r18, 0x65	; 101
    731e:	33 e3       	ldi	r19, 0x33	; 51
    7320:	b9 c0       	rjmp	.+370    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetTraceStart) 			: return (uint8*)"SetTraceStart"; break;
    7322:	23 e7       	ldi	r18, 0x73	; 115
    7324:	33 e3       	ldi	r19, 0x33	; 51
    7326:	b6 c0       	rjmp	.+364    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceStart) 			: return (uint8*)"GetTraceStart"; break;
    7328:	21 e8       	ldi	r18, 0x81	; 129
    732a:	33 e3       	ldi	r19, 0x33	; 51
    732c:	b3 c0       	rjmp	.+358    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetTraceStop) 			: return (uint8*)"SetTraceStop"	; break;
    732e:	2e e8       	ldi	r18, 0x8E	; 142
    7330:	33 e3       	ldi	r19, 0x33	; 51
    7332:	b0 c0       	rjmp	.+352    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceStop) 			: return (uint8*)"GetTraceStop"	; break;
    7334:	2b e9       	ldi	r18, 0x9B	; 155
    7336:	33 e3       	ldi	r19, 0x33	; 51
    7338:	ad c0       	rjmp	.+346    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetTraceVariable) 		: return (uint8*)"SetTraceVariable"; break;
    733a:	2c ea       	ldi	r18, 0xAC	; 172
    733c:	33 e3       	ldi	r19, 0x33	; 51
    733e:	aa c0       	rjmp	.+340    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceVariable) 		: return (uint8*)"GetTraceVariable"; break;
    7340:	2d eb       	ldi	r18, 0xBD	; 189
    7342:	33 e3       	ldi	r19, 0x33	; 51
    7344:	a7 c0       	rjmp	.+334    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetTracePeriod) 			: return (uint8*)"SetTracePeriod"; break;
    7346:	2c ec       	ldi	r18, 0xCC	; 204
    7348:	33 e3       	ldi	r19, 0x33	; 51
    734a:	a4 c0       	rjmp	.+328    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetTracePeriod) 			: return (uint8*)"GetTracePeriod"; break;
    734c:	2b ed       	ldi	r18, 0xDB	; 219
    734e:	33 e3       	ldi	r19, 0x33	; 51
    7350:	a1 c0       	rjmp	.+322    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceStatus) 			: return (uint8*)"GetTraceStatus"; break;
    7352:	2a ee       	ldi	r18, 0xEA	; 234
    7354:	33 e3       	ldi	r19, 0x33	; 51
    7356:	9e c0       	rjmp	.+316    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetTraceCount) 			: return (uint8*)"GetTraceCount"; break;
    7358:	28 ef       	ldi	r18, 0xF8	; 248
    735a:	33 e3       	ldi	r19, 0x33	; 51
    735c:	9b c0       	rjmp	.+310    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetSettleWindow) 		: return (uint8*)"SetSettleWindow"; break;
    735e:	28 e0       	ldi	r18, 0x08	; 8
    7360:	34 e3       	ldi	r19, 0x34	; 52
    7362:	98 c0       	rjmp	.+304    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetSettleWindow) 		: return (uint8*)"GetSettleWindow"; break;
    7364:	28 e1       	ldi	r18, 0x18	; 24
    7366:	34 e3       	ldi	r19, 0x34	; 52
    7368:	95 c0       	rjmp	.+298    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetActualPositionUnits)	: return (uint8*)"SetActualPositionUnits"; break;
    736a:	2f e2       	ldi	r18, 0x2F	; 47
    736c:	34 e3       	ldi	r19, 0x34	; 52
    736e:	92 c0       	rjmp	.+292    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetActualPositionUnits)	: return (uint8*)"GetActualPositionUnits"; break;
    7370:	26 e4       	ldi	r18, 0x46	; 70
    7372:	34 e3       	ldi	r19, 0x34	; 52
    7374:	8f c0       	rjmp	.+286    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetBufferStart) 			: return (uint8*)"SetBufferStart"; break;
    7376:	25 e5       	ldi	r18, 0x55	; 85
    7378:	34 e3       	ldi	r19, 0x34	; 52
    737a:	8c c0       	rjmp	.+280    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetBufferStart) 			: return (uint8*)"GetBufferStart"; break;
    737c:	24 e6       	ldi	r18, 0x64	; 100
    737e:	34 e3       	ldi	r19, 0x34	; 52
    7380:	89 c0       	rjmp	.+274    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetBufferLength) 		: return (uint8*)"SetBufferLength"; break;
    7382:	24 e7       	ldi	r18, 0x74	; 116
    7384:	34 e3       	ldi	r19, 0x34	; 52
    7386:	86 c0       	rjmp	.+268    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetBufferLength) 		: return (uint8*)"GetBufferLength"; break;
    7388:	24 e8       	ldi	r18, 0x84	; 132
    738a:	34 e3       	ldi	r19, 0x34	; 52
    738c:	83 c0       	rjmp	.+262    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetBufferWriteIndex) 	: return (uint8*)"SetBufferWriteIndex"; break;
    738e:	28 e9       	ldi	r18, 0x98	; 152
    7390:	34 e3       	ldi	r19, 0x34	; 52
    7392:	80 c0       	rjmp	.+256    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetBufferWriteIndex) 	: return (uint8*)"GetBufferWriteIndex"; break;
    7394:	2c ea       	ldi	r18, 0xAC	; 172
    7396:	34 e3       	ldi	r19, 0x34	; 52
    7398:	7d c0       	rjmp	.+250    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetBufferReadIndex) 		: return (uint8*)"SetBufferReadIndex"; break;
    739a:	2f eb       	ldi	r18, 0xBF	; 191
    739c:	34 e3       	ldi	r19, 0x34	; 52
    739e:	7a c0       	rjmp	.+244    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetBufferReadIndex) 		: return (uint8*)"GetBufferReadIndex"; break;
    73a0:	22 ed       	ldi	r18, 0xD2	; 210
    73a2:	34 e3       	ldi	r19, 0x34	; 52
    73a4:	77 c0       	rjmp	.+238    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPWriteBuffer) 			: return (uint8*)"WriteBuffer"; break;
    73a6:	2e ed       	ldi	r18, 0xDE	; 222
    73a8:	34 e3       	ldi	r19, 0x34	; 52
    73aa:	74 c0       	rjmp	.+232    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPReadBuffer) 				: return (uint8*)"ReadBuffer"; break;
    73ac:	29 ee       	ldi	r18, 0xE9	; 233
    73ae:	34 e3       	ldi	r19, 0x34	; 52
    73b0:	71 c0       	rjmp	.+226    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetBufferFunction) 		: return (uint8*)"SetBufferFunction"; break;
    73b2:	2b ef       	ldi	r18, 0xFB	; 251
    73b4:	34 e3       	ldi	r19, 0x34	; 52
    73b6:	6e c0       	rjmp	.+220    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetBufferFunction) 		: return (uint8*)"GetBufferFunction"; break;
    73b8:	2d e0       	ldi	r18, 0x0D	; 13
    73ba:	35 e3       	ldi	r19, 0x35	; 53
    73bc:	6b c0       	rjmp	.+214    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetStepRange) 			: return (uint8*)"GetStepRange"	; break;
    73be:	2a e1       	ldi	r18, 0x1A	; 26
    73c0:	35 e3       	ldi	r19, 0x35	; 53
    73c2:	68 c0       	rjmp	.+208    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetStepRange) 			: return (uint8*)"SetStepRange"; break;
    73c4:	27 e2       	ldi	r18, 0x27	; 39
    73c6:	35 e3       	ldi	r19, 0x35	; 53
    73c8:	65 c0       	rjmp	.+202    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetStopMode) 			: return (uint8*)"SetStopMode"; break;
    73ca:	23 e3       	ldi	r18, 0x33	; 51
    73cc:	35 e3       	ldi	r19, 0x35	; 53
    73ce:	62 c0       	rjmp	.+196    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetStopMode) 			: return (uint8*)"GetStopMode"; break;
    73d0:	2f e3       	ldi	r18, 0x3F	; 63
    73d2:	35 e3       	ldi	r19, 0x35	; 53
    73d4:	5f c0       	rjmp	.+190    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetAutoStopMode) 		: return (uint8*)"SetAutoStopMode"; break;
    73d6:	2f e4       	ldi	r18, 0x4F	; 79
    73d8:	35 e3       	ldi	r19, 0x35	; 53
    73da:	5c c0       	rjmp	.+184    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetAutoStopMode) 		: return (uint8*)"GetAutoStopMode"; break;
    73dc:	2f e5       	ldi	r18, 0x5F	; 95
    73de:	35 e3       	ldi	r19, 0x35	; 53
    73e0:	59 c0       	rjmp	.+178    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetBreakpoint) 			: return (uint8*)"SetBreakpoint"; break;
    73e2:	2d e6       	ldi	r18, 0x6D	; 109
    73e4:	35 e3       	ldi	r19, 0x35	; 53
    73e6:	56 c0       	rjmp	.+172    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetBreakpoint) 			: return (uint8*)"GetBreakpoint"; break;
    73e8:	2b e7       	ldi	r18, 0x7B	; 123
    73ea:	35 e3       	ldi	r19, 0x35	; 53
    73ec:	53 c0       	rjmp	.+166    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetBreakpointValue) 		: return (uint8*)"SetBreakpointValue"; break;
    73ee:	2e e8       	ldi	r18, 0x8E	; 142
    73f0:	35 e3       	ldi	r19, 0x35	; 53
    73f2:	50 c0       	rjmp	.+160    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetBreakpointValue) 		: return (uint8*)"GetBreakpointValue"; break;
    73f4:	21 ea       	ldi	r18, 0xA1	; 161
    73f6:	35 e3       	ldi	r19, 0x35	; 53
    73f8:	4d c0       	rjmp	.+154    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetCaptureSource) 		: return (uint8*)"SetCaptureSource"	; break;
    73fa:	22 eb       	ldi	r18, 0xB2	; 178
    73fc:	35 e3       	ldi	r19, 0x35	; 53
    73fe:	4a c0       	rjmp	.+148    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetCaptureSource) 		: return (uint8*)"GetCaptureSource"	; break;
    7400:	23 ec       	ldi	r18, 0xC3	; 195
    7402:	35 e3       	ldi	r19, 0x35	; 53
    7404:	47 c0       	rjmp	.+142    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetEncoderSource) 		: return (uint8*)"SetEncoderSource"	; break;
    7406:	24 ed       	ldi	r18, 0xD4	; 212
    7408:	35 e3       	ldi	r19, 0x35	; 53
    740a:	44 c0       	rjmp	.+136    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetEncoderSource) 		: return (uint8*)"GetEncoderSource"	; break;
    740c:	25 ee       	ldi	r18, 0xE5	; 229
    740e:	35 e3       	ldi	r19, 0x35	; 53
    7410:	41 c0       	rjmp	.+130    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetMotorMode) 			: return (uint8*)"SetMotorMode"	; break;
    7412:	22 ef       	ldi	r18, 0xF2	; 242
    7414:	35 e3       	ldi	r19, 0x35	; 53
    7416:	3e c0       	rjmp	.+124    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetMotorMode) 			: return (uint8*)"GetMotorMode"	; break;
    7418:	2f ef       	ldi	r18, 0xFF	; 255
    741a:	35 e3       	ldi	r19, 0x35	; 53
    741c:	3b c0       	rjmp	.+118    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetEncoderToStepRatio) 	: return (uint8*)"SetEncoderToStepRatio"; break;
    741e:	25 e1       	ldi	r18, 0x15	; 21
    7420:	36 e3       	ldi	r19, 0x36	; 54
    7422:	38 c0       	rjmp	.+112    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetEncoderToStepRatio) 	: return (uint8*)"GetEncoderToStepRatio"; break;
    7424:	2b e2       	ldi	r18, 0x2B	; 43
    7426:	36 e3       	ldi	r19, 0x36	; 54
    7428:	35 c0       	rjmp	.+106    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetOutputMode) 			: return (uint8*)"SetOutputMode"; break;
    742a:	29 e3       	ldi	r18, 0x39	; 57
    742c:	36 e3       	ldi	r19, 0x36	; 54
    742e:	32 c0       	rjmp	.+100    	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetInterruptAxis) 		: return (uint8*)"GetInterruptAxis"	; break;
    7430:	2a e4       	ldi	r18, 0x4A	; 74
    7432:	36 e3       	ldi	r19, 0x36	; 54
    7434:	2f c0       	rjmp	.+94     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetCommutationMode) 		: return (uint8*)"SetCommutationMode"; break;
    7436:	2d e5       	ldi	r18, 0x5D	; 93
    7438:	36 e3       	ldi	r19, 0x36	; 54
    743a:	2c c0       	rjmp	.+88     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetCommutationMode) 		: return (uint8*)"GetCommutationMode"; break;
    743c:	20 e7       	ldi	r18, 0x70	; 112
    743e:	36 e3       	ldi	r19, 0x36	; 54
    7440:	29 c0       	rjmp	.+82     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseInitializeMode) 	: return (uint8*)"SetPhaseInitializeMode"; break;
    7442:	27 e8       	ldi	r18, 0x87	; 135
    7444:	36 e3       	ldi	r19, 0x36	; 54
    7446:	26 c0       	rjmp	.+76     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseInitializeMode) 	: return (uint8*)"GetPhaseInitializeMode"; break;
    7448:	2e e9       	ldi	r18, 0x9E	; 158
    744a:	36 e3       	ldi	r19, 0x36	; 54
    744c:	23 c0       	rjmp	.+70     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhasePrescale) 		: return (uint8*)"SetPhasePrescale"; break;
    744e:	2f ea       	ldi	r18, 0xAF	; 175
    7450:	36 e3       	ldi	r19, 0x36	; 54
    7452:	20 c0       	rjmp	.+64     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhasePrescale) 		: return (uint8*)"GetPhasePrescale"; break;
    7454:	20 ec       	ldi	r18, 0xC0	; 192
    7456:	36 e3       	ldi	r19, 0x36	; 54
    7458:	1d c0       	rjmp	.+58     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetPhaseCorrectionMode) 	: return (uint8*)"SetPhaseCorrectionMode"; break;
    745a:	27 ed       	ldi	r18, 0xD7	; 215
    745c:	36 e3       	ldi	r19, 0x36	; 54
    745e:	1a c0       	rjmp	.+52     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseCorrectionMode) 	: return (uint8*)"GetPhaseCorrectionMode"; break;
    7460:	2e ee       	ldi	r18, 0xEE	; 238
    7462:	36 e3       	ldi	r19, 0x36	; 54
    7464:	17 c0       	rjmp	.+46     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetPhaseCommand) 		: return (uint8*)"GetPhaseCommand"; break;
    7466:	2e ef       	ldi	r18, 0xFE	; 254
    7468:	36 e3       	ldi	r19, 0x36	; 54
    746a:	14 c0       	rjmp	.+40     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetMotionCompleteMode) 	: return (uint8*)"SetMotionCompleteMode"; break;
    746c:	24 e1       	ldi	r18, 0x14	; 20
    746e:	37 e3       	ldi	r19, 0x37	; 55
    7470:	11 c0       	rjmp	.+34     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetMotionCompleteMode) 	: return (uint8*)"GetMotionCompleteMode"; break;
    7472:	2a e2       	ldi	r18, 0x2A	; 42
    7474:	37 e3       	ldi	r19, 0x37	; 55
    7476:	0e c0       	rjmp	.+28     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPSetAxisOutSource) 		: return (uint8*)"SetAxisOutSource"	; break;
    7478:	2b e3       	ldi	r18, 0x3B	; 59
    747a:	37 e3       	ldi	r19, 0x37	; 55
    747c:	0b c0       	rjmp	.+22     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetAxisOutSource) 		: return (uint8*)"GetAxisOutSource"	; break;
    747e:	2c e4       	ldi	r18, 0x4C	; 76
    7480:	37 e3       	ldi	r19, 0x37	; 55
    7482:	08 c0       	rjmp	.+16     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPReadAnalog) 				: return (uint8*)"ReadAnalog"; break;
    7484:	27 e5       	ldi	r18, 0x57	; 87
    7486:	37 e3       	ldi	r19, 0x37	; 55
    7488:	05 c0       	rjmp	.+10     	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPAdjustActualPosition)	: return (uint8*)"AdjustActualPosition"; break;
    748a:	2c e6       	ldi	r18, 0x6C	; 108
    748c:	37 e3       	ldi	r19, 0x37	; 55
    748e:	02 c0       	rjmp	.+4      	; 0x7494 <PMDGetOpcodeText+0x400>
	case (PMDOPGetChecksum) 			: return (uint8*)"GetChecksum"; break;
    7490:	28 e7       	ldi	r18, 0x78	; 120
    7492:	37 e3       	ldi	r19, 0x37	; 55
	
	default 							: return (uint8*)"Invalid opcode!"; break;
	}
}
    7494:	c9 01       	movw	r24, r18
    7496:	08 95       	ret

00007498 <PMDGetErrorMessage>:

/*****************************************************************************************/
uint8 *PMDGetErrorMessage(PMDuint16 errorCode) 
{

  switch(errorCode) {
    7498:	8f 30       	cpi	r24, 0x0F	; 15
    749a:	91 05       	cpc	r25, r1
    749c:	09 f4       	brne	.+2      	; 0x74a0 <PMDGetErrorMessage+0x8>
    749e:	c0 c0       	rjmp	.+384    	; 0x7620 <PMDGetErrorMessage+0x188>
    74a0:	80 31       	cpi	r24, 0x10	; 16
    74a2:	91 05       	cpc	r25, r1
    74a4:	a8 f5       	brcc	.+106    	; 0x7510 <PMDGetErrorMessage+0x78>
    74a6:	87 30       	cpi	r24, 0x07	; 7
    74a8:	91 05       	cpc	r25, r1
    74aa:	09 f4       	brne	.+2      	; 0x74ae <PMDGetErrorMessage+0x16>
    74ac:	a1 c0       	rjmp	.+322    	; 0x75f0 <PMDGetErrorMessage+0x158>
    74ae:	88 30       	cpi	r24, 0x08	; 8
    74b0:	91 05       	cpc	r25, r1
    74b2:	b8 f4       	brcc	.+46     	; 0x74e2 <PMDGetErrorMessage+0x4a>
    74b4:	83 30       	cpi	r24, 0x03	; 3
    74b6:	91 05       	cpc	r25, r1
    74b8:	09 f4       	brne	.+2      	; 0x74bc <PMDGetErrorMessage+0x24>
    74ba:	8e c0       	rjmp	.+284    	; 0x75d8 <PMDGetErrorMessage+0x140>
    74bc:	84 30       	cpi	r24, 0x04	; 4
    74be:	91 05       	cpc	r25, r1
    74c0:	40 f4       	brcc	.+16     	; 0x74d2 <PMDGetErrorMessage+0x3a>
    74c2:	81 30       	cpi	r24, 0x01	; 1
    74c4:	91 05       	cpc	r25, r1
    74c6:	09 f4       	brne	.+2      	; 0x74ca <PMDGetErrorMessage+0x32>
    74c8:	7e c0       	rjmp	.+252    	; 0x75c6 <PMDGetErrorMessage+0x12e>
    74ca:	02 97       	sbiw	r24, 0x02	; 2
    74cc:	08 f0       	brcs	.+2      	; 0x74d0 <PMDGetErrorMessage+0x38>
    74ce:	81 c0       	rjmp	.+258    	; 0x75d2 <PMDGetErrorMessage+0x13a>
    74d0:	7d c0       	rjmp	.+250    	; 0x75cc <PMDGetErrorMessage+0x134>
    74d2:	85 30       	cpi	r24, 0x05	; 5
    74d4:	91 05       	cpc	r25, r1
    74d6:	09 f4       	brne	.+2      	; 0x74da <PMDGetErrorMessage+0x42>
    74d8:	85 c0       	rjmp	.+266    	; 0x75e4 <PMDGetErrorMessage+0x14c>
    74da:	06 97       	sbiw	r24, 0x06	; 6
    74dc:	08 f0       	brcs	.+2      	; 0x74e0 <PMDGetErrorMessage+0x48>
    74de:	85 c0       	rjmp	.+266    	; 0x75ea <PMDGetErrorMessage+0x152>
    74e0:	7e c0       	rjmp	.+252    	; 0x75de <PMDGetErrorMessage+0x146>
    74e2:	8b 30       	cpi	r24, 0x0B	; 11
    74e4:	91 05       	cpc	r25, r1
    74e6:	09 f4       	brne	.+2      	; 0x74ea <PMDGetErrorMessage+0x52>
    74e8:	8f c0       	rjmp	.+286    	; 0x7608 <PMDGetErrorMessage+0x170>
    74ea:	8c 30       	cpi	r24, 0x0C	; 12
    74ec:	91 05       	cpc	r25, r1
    74ee:	40 f4       	brcc	.+16     	; 0x7500 <PMDGetErrorMessage+0x68>
    74f0:	89 30       	cpi	r24, 0x09	; 9
    74f2:	91 05       	cpc	r25, r1
    74f4:	09 f4       	brne	.+2      	; 0x74f8 <PMDGetErrorMessage+0x60>
    74f6:	82 c0       	rjmp	.+260    	; 0x75fc <PMDGetErrorMessage+0x164>
    74f8:	0a 97       	sbiw	r24, 0x0a	; 10
    74fa:	08 f0       	brcs	.+2      	; 0x74fe <PMDGetErrorMessage+0x66>
    74fc:	82 c0       	rjmp	.+260    	; 0x7602 <PMDGetErrorMessage+0x16a>
    74fe:	7b c0       	rjmp	.+246    	; 0x75f6 <PMDGetErrorMessage+0x15e>
    7500:	8d 30       	cpi	r24, 0x0D	; 13
    7502:	91 05       	cpc	r25, r1
    7504:	09 f4       	brne	.+2      	; 0x7508 <PMDGetErrorMessage+0x70>
    7506:	86 c0       	rjmp	.+268    	; 0x7614 <PMDGetErrorMessage+0x17c>
    7508:	0e 97       	sbiw	r24, 0x0e	; 14
    750a:	08 f0       	brcs	.+2      	; 0x750e <PMDGetErrorMessage+0x76>
    750c:	86 c0       	rjmp	.+268    	; 0x761a <PMDGetErrorMessage+0x182>
    750e:	7f c0       	rjmp	.+254    	; 0x760e <PMDGetErrorMessage+0x176>
    7510:	2f e7       	ldi	r18, 0x7F	; 127
    7512:	8d 3d       	cpi	r24, 0xDD	; 221
    7514:	92 07       	cpc	r25, r18
    7516:	09 f4       	brne	.+2      	; 0x751a <PMDGetErrorMessage+0x82>
    7518:	9b c0       	rjmp	.+310    	; 0x7650 <PMDGetErrorMessage+0x1b8>
    751a:	2f e7       	ldi	r18, 0x7F	; 127
    751c:	8e 3d       	cpi	r24, 0xDE	; 222
    751e:	92 07       	cpc	r25, r18
    7520:	38 f5       	brcc	.+78     	; 0x7570 <PMDGetErrorMessage+0xd8>
    7522:	2f e7       	ldi	r18, 0x7F	; 127
    7524:	83 3d       	cpi	r24, 0xD3	; 211
    7526:	92 07       	cpc	r25, r18
    7528:	09 f4       	brne	.+2      	; 0x752c <PMDGetErrorMessage+0x94>
    752a:	86 c0       	rjmp	.+268    	; 0x7638 <PMDGetErrorMessage+0x1a0>
    752c:	2f e7       	ldi	r18, 0x7F	; 127
    752e:	84 3d       	cpi	r24, 0xD4	; 212
    7530:	92 07       	cpc	r25, r18
    7532:	78 f4       	brcc	.+30     	; 0x7552 <PMDGetErrorMessage+0xba>
    7534:	2f e7       	ldi	r18, 0x7F	; 127
    7536:	81 3d       	cpi	r24, 0xD1	; 209
    7538:	92 07       	cpc	r25, r18
    753a:	09 f4       	brne	.+2      	; 0x753e <PMDGetErrorMessage+0xa6>
    753c:	77 c0       	rjmp	.+238    	; 0x762c <PMDGetErrorMessage+0x194>
    753e:	2f e7       	ldi	r18, 0x7F	; 127
    7540:	82 3d       	cpi	r24, 0xD2	; 210
    7542:	92 07       	cpc	r25, r18
    7544:	08 f0       	brcs	.+2      	; 0x7548 <PMDGetErrorMessage+0xb0>
    7546:	75 c0       	rjmp	.+234    	; 0x7632 <PMDGetErrorMessage+0x19a>
    7548:	80 5d       	subi	r24, 0xD0	; 208
    754a:	9f 47       	sbci	r25, 0x7F	; 127
    754c:	09 f0       	breq	.+2      	; 0x7550 <PMDGetErrorMessage+0xb8>
    754e:	9b c0       	rjmp	.+310    	; 0x7686 <PMDGetErrorMessage+0x1ee>
    7550:	6a c0       	rjmp	.+212    	; 0x7626 <PMDGetErrorMessage+0x18e>
    7552:	2f e7       	ldi	r18, 0x7F	; 127
    7554:	8b 3d       	cpi	r24, 0xDB	; 219
    7556:	92 07       	cpc	r25, r18
    7558:	09 f4       	brne	.+2      	; 0x755c <PMDGetErrorMessage+0xc4>
    755a:	74 c0       	rjmp	.+232    	; 0x7644 <PMDGetErrorMessage+0x1ac>
    755c:	2f e7       	ldi	r18, 0x7F	; 127
    755e:	8c 3d       	cpi	r24, 0xDC	; 220
    7560:	92 07       	cpc	r25, r18
    7562:	08 f0       	brcs	.+2      	; 0x7566 <PMDGetErrorMessage+0xce>
    7564:	72 c0       	rjmp	.+228    	; 0x764a <PMDGetErrorMessage+0x1b2>
    7566:	84 5d       	subi	r24, 0xD4	; 212
    7568:	9f 47       	sbci	r25, 0x7F	; 127
    756a:	09 f0       	breq	.+2      	; 0x756e <PMDGetErrorMessage+0xd6>
    756c:	8c c0       	rjmp	.+280    	; 0x7686 <PMDGetErrorMessage+0x1ee>
    756e:	67 c0       	rjmp	.+206    	; 0x763e <PMDGetErrorMessage+0x1a6>
    7570:	2f e7       	ldi	r18, 0x7F	; 127
    7572:	81 3e       	cpi	r24, 0xE1	; 225
    7574:	92 07       	cpc	r25, r18
    7576:	09 f4       	brne	.+2      	; 0x757a <PMDGetErrorMessage+0xe2>
    7578:	77 c0       	rjmp	.+238    	; 0x7668 <PMDGetErrorMessage+0x1d0>
    757a:	2f e7       	ldi	r18, 0x7F	; 127
    757c:	82 3e       	cpi	r24, 0xE2	; 226
    757e:	92 07       	cpc	r25, r18
    7580:	50 f4       	brcc	.+20     	; 0x7596 <PMDGetErrorMessage+0xfe>
    7582:	2f e7       	ldi	r18, 0x7F	; 127
    7584:	8f 3d       	cpi	r24, 0xDF	; 223
    7586:	92 07       	cpc	r25, r18
    7588:	09 f4       	brne	.+2      	; 0x758c <PMDGetErrorMessage+0xf4>
    758a:	68 c0       	rjmp	.+208    	; 0x765c <PMDGetErrorMessage+0x1c4>
    758c:	80 5e       	subi	r24, 0xE0	; 224
    758e:	9f 47       	sbci	r25, 0x7F	; 127
    7590:	08 f0       	brcs	.+2      	; 0x7594 <PMDGetErrorMessage+0xfc>
    7592:	67 c0       	rjmp	.+206    	; 0x7662 <PMDGetErrorMessage+0x1ca>
    7594:	60 c0       	rjmp	.+192    	; 0x7656 <PMDGetErrorMessage+0x1be>
    7596:	2f e7       	ldi	r18, 0x7F	; 127
    7598:	8d 3f       	cpi	r24, 0xFD	; 253
    759a:	92 07       	cpc	r25, r18
    759c:	09 f4       	brne	.+2      	; 0x75a0 <PMDGetErrorMessage+0x108>
    759e:	6a c0       	rjmp	.+212    	; 0x7674 <PMDGetErrorMessage+0x1dc>
    75a0:	2f e7       	ldi	r18, 0x7F	; 127
    75a2:	8e 3f       	cpi	r24, 0xFE	; 254
    75a4:	92 07       	cpc	r25, r18
    75a6:	28 f4       	brcc	.+10     	; 0x75b2 <PMDGetErrorMessage+0x11a>
    75a8:	8c 5f       	subi	r24, 0xFC	; 252
    75aa:	9f 47       	sbci	r25, 0x7F	; 127
    75ac:	09 f0       	breq	.+2      	; 0x75b0 <PMDGetErrorMessage+0x118>
    75ae:	6b c0       	rjmp	.+214    	; 0x7686 <PMDGetErrorMessage+0x1ee>
    75b0:	5e c0       	rjmp	.+188    	; 0x766e <PMDGetErrorMessage+0x1d6>
    75b2:	2f e7       	ldi	r18, 0x7F	; 127
    75b4:	8e 3f       	cpi	r24, 0xFE	; 254
    75b6:	92 07       	cpc	r25, r18
    75b8:	09 f4       	brne	.+2      	; 0x75bc <PMDGetErrorMessage+0x124>
    75ba:	5f c0       	rjmp	.+190    	; 0x767a <PMDGetErrorMessage+0x1e2>
    75bc:	8f 5f       	subi	r24, 0xFF	; 255
    75be:	9f 47       	sbci	r25, 0x7F	; 127
    75c0:	09 f0       	breq	.+2      	; 0x75c4 <PMDGetErrorMessage+0x12c>
    75c2:	61 c0       	rjmp	.+194    	; 0x7686 <PMDGetErrorMessage+0x1ee>
    75c4:	5d c0       	rjmp	.+186    	; 0x7680 <PMDGetErrorMessage+0x1e8>
    75c6:	28 e8       	ldi	r18, 0x88	; 136
    75c8:	37 e3       	ldi	r19, 0x37	; 55
    75ca:	5f c0       	rjmp	.+190    	; 0x768a <PMDGetErrorMessage+0x1f2>
    75cc:	27 e9       	ldi	r18, 0x97	; 151
    75ce:	37 e3       	ldi	r19, 0x37	; 55
    75d0:	5c c0       	rjmp	.+184    	; 0x768a <PMDGetErrorMessage+0x1f2>
    75d2:	20 ea       	ldi	r18, 0xA0	; 160
    75d4:	37 e3       	ldi	r19, 0x37	; 55
    75d6:	59 c0       	rjmp	.+178    	; 0x768a <PMDGetErrorMessage+0x1f2>
    
	// MC2400 Chipset error codes
	
	case ( PMD_ERR_OK) 						: return (uint8*)  "NO Error"; break;
	case ( PMD_ERR_ChipsetReset)  			: return (uint8*)  "Chipset Reset "; break;
    case ( PMD_ERR_InvalidInstruction)  	: return (uint8*)  "Invalid Instruction"; break;
    75d8:	24 eb       	ldi	r18, 0xB4	; 180
    75da:	37 e3       	ldi	r19, 0x37	; 55
    75dc:	56 c0       	rjmp	.+172    	; 0x768a <PMDGetErrorMessage+0x1f2>
    case ( PMD_ERR_InvalidAxis)  			: return (uint8*)  "Invalid Axis"; break;
    75de:	21 ec       	ldi	r18, 0xC1	; 193
    75e0:	37 e3       	ldi	r19, 0x37	; 55
    75e2:	53 c0       	rjmp	.+166    	; 0x768a <PMDGetErrorMessage+0x1f2>
    case ( PMD_ERR_InvalidParameter)  		: return (uint8*)  "Invalid Data Parameter"; break;
    75e4:	28 ed       	ldi	r18, 0xD8	; 216
    75e6:	37 e3       	ldi	r19, 0x37	; 55
    75e8:	50 c0       	rjmp	.+160    	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_TraceRunning)			: return (uint8*)  "Trace Currently Running" ;break;
    75ea:	20 ef       	ldi	r18, 0xF0	; 240
    75ec:	37 e3       	ldi	r19, 0x37	; 55
    75ee:	4d c0       	rjmp	.+154    	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_Flash)					: return (uint8*)  "Flash Error" ;break;
    75f0:	2c ef       	ldi	r18, 0xFC	; 252
    75f2:	37 e3       	ldi	r19, 0x37	; 55
    75f4:	4a c0       	rjmp	.+148    	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_BlockOutOfBounds)		: return (uint8*)  "Block Out of Bounds" ;break;
    75f6:	20 e1       	ldi	r18, 0x10	; 16
    75f8:	38 e3       	ldi	r19, 0x38	; 56
    75fa:	47 c0       	rjmp	.+142    	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_TraceBufferZero)			: return (uint8*)  "Zero Length Trace Buffer" ;break;
    75fc:	29 e2       	ldi	r18, 0x29	; 41
    75fe:	38 e3       	ldi	r19, 0x38	; 56
    7600:	44 c0       	rjmp	.+136    	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_BadSerialChecksum)		: return (uint8*)  "Invalid Checksum" ;break;
    7602:	2a e3       	ldi	r18, 0x3A	; 58
    7604:	38 e3       	ldi	r19, 0x38	; 56
    7606:	41 c0       	rjmp	.+130    	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_NotPrimaryPort)			: return (uint8*)  "Invalid Instruction For Diagnostic Port" ;break;
    7608:	22 e6       	ldi	r18, 0x62	; 98
    760a:	38 e3       	ldi	r19, 0x38	; 56
    760c:	3e c0       	rjmp	.+124    	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidNegativeValue)	: return (uint8*)  "Invalid Negative Value for Profile Mode" ;break;
    760e:	2a e8       	ldi	r18, 0x8A	; 138
    7610:	38 e3       	ldi	r19, 0x38	; 56
    7612:	3b c0       	rjmp	.+118    	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidParameterChange) 	: return (uint8*)  "Invalid Parameter Change for Profile Mode" ;break;
    7614:	24 eb       	ldi	r18, 0xB4	; 180
    7616:	38 e3       	ldi	r19, 0x38	; 56
    7618:	38 c0       	rjmp	.+112    	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_LimitEventPending)		: return (uint8*)  "Invalid Move with Limit Event Pending" ;break;
    761a:	2a ed       	ldi	r18, 0xDA	; 218
    761c:	38 e3       	ldi	r19, 0x38	; 56
    761e:	35 c0       	rjmp	.+106    	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidMoveIntoLimit)	: return (uint8*)  "Invalid Move into Limit" ;break;
    7620:	22 ef       	ldi	r18, 0xF2	; 242
    7622:	38 e3       	ldi	r19, 0x38	; 56
    7624:	32 c0       	rjmp	.+100    	; 0x768a <PMDGetErrorMessage+0x1f2>
    case ( PMD_ERR_InvalidClearInterrupt)	: return (uint8*)  "Invalid Clear Interrupt" ;break;
    7626:	2a e0       	ldi	r18, 0x0A	; 10
    7628:	39 e3       	ldi	r19, 0x39	; 57
    762a:	2f c0       	rjmp	.+94     	; 0x768a <PMDGetErrorMessage+0x1f2>
	
	// DK2000 initialization errors
	case ( PMD_ERR_InvalidOperation)		: return (uint8*)  "Invalid Operation" ;break;
    762c:	2c e1       	ldi	r18, 0x1C	; 28
    762e:	39 e3       	ldi	r19, 0x39	; 57
    7630:	2c c0       	rjmp	.+88     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_NotConnected)			: return (uint8*)  "Not Connected" ;break;
    7632:	2a e2       	ldi	r18, 0x2A	; 42
    7634:	39 e3       	ldi	r19, 0x39	; 57
    7636:	29 c0       	rjmp	.+82     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_ChipsetNotResponding)	: return (uint8*)  "Chipset Not Responding" ;break;
    7638:	21 e4       	ldi	r18, 0x41	; 65
    763a:	39 e3       	ldi	r19, 0x39	; 57
    763c:	26 c0       	rjmp	.+76     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_CommPortRead)			: return (uint8*)  "Comm Port Read" ;break;
    763e:	20 e5       	ldi	r18, 0x50	; 80
    7640:	39 e3       	ldi	r19, 0x39	; 57
    7642:	23 c0       	rjmp	.+70     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_CommPortWrite)			: return (uint8*)  "Comm Port Write" ;break;
    7644:	20 e6       	ldi	r18, 0x60	; 96
    7646:	39 e3       	ldi	r19, 0x39	; 57
    7648:	20 c0       	rjmp	.+64     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidSerialPort)		: return (uint8*)  "Invalid Serial Port" ;break;
    764a:	24 e7       	ldi	r18, 0x74	; 116
    764c:	39 e3       	ldi	r19, 0x39	; 57
    764e:	1d c0       	rjmp	.+58     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidDK2000IOBase)		: return (uint8*)  "Invalid DK2000 IO Base" ;break;
    7650:	2b e8       	ldi	r18, 0x8B	; 139
    7652:	39 e3       	ldi	r19, 0x39	; 57
    7654:	1a c0       	rjmp	.+52     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidDK2000IRQ)		: return (uint8*)  "Invalid DK2000 IRQ" ;break;
    7656:	2e e9       	ldi	r18, 0x9E	; 158
    7658:	39 e3       	ldi	r19, 0x39	; 57
    765a:	17 c0       	rjmp	.+46     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_InvalidDK2000IOMode)		: return (uint8*)  "Invalid DK2000 IO Mode" ;break;
    765c:	25 eb       	ldi	r18, 0xB5	; 181
    765e:	39 e3       	ldi	r19, 0x39	; 57
    7660:	14 c0       	rjmp	.+40     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_PMDNotInitialized)		: return (uint8*)  "PMD Not Initialized" ;break;
    7662:	29 ec       	ldi	r18, 0xC9	; 201
    7664:	39 e3       	ldi	r19, 0x39	; 57
    7666:	11 c0       	rjmp	.+34     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_OpeningWindowsDriver)	: return (uint8*)  "Cannot Open Windows Driver" ;break;
    7668:	24 ee       	ldi	r18, 0xE4	; 228
    766a:	39 e3       	ldi	r19, 0x39	; 57
    766c:	0e c0       	rjmp	.+28     	; 0x768a <PMDGetErrorMessage+0x1f2>
	
	// run-time errors
	case ( PMD_ERR_Driver)					: return (uint8*)  "Windows Driver Error" ;break;
    766e:	29 ef       	ldi	r18, 0xF9	; 249
    7670:	39 e3       	ldi	r19, 0x39	; 57
    7672:	0b c0       	rjmp	.+22     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_CommunicationsError)		: return (uint8*)  "Communication Error" ;break;
    7674:	2d e0       	ldi	r18, 0x0D	; 13
    7676:	3a e3       	ldi	r19, 0x3A	; 58
    7678:	08 c0       	rjmp	.+16     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_CommTimeoutError)		: return (uint8*)  "Communication Timeout Error" ;break;
    767a:	29 e2       	ldi	r18, 0x29	; 41
    767c:	3a e3       	ldi	r19, 0x3A	; 58
    767e:	05 c0       	rjmp	.+10     	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_ChecksumError)			: return (uint8*)  "Checksum Error" ;break;
    7680:	28 e3       	ldi	r18, 0x38	; 56
    7682:	3a e3       	ldi	r19, 0x3A	; 58
    7684:	02 c0       	rjmp	.+4      	; 0x768a <PMDGetErrorMessage+0x1f2>
	case ( PMD_ERR_CommandError)			: return (uint8*)  "Command Error" ;break;
    7686:	26 e4       	ldi	r18, 0x46	; 70
    7688:	3a e3       	ldi	r19, 0x3A	; 58
    
	default: return (uint8*)"Undefined error occurred";
  }

 // return (uint8*)"Undefined error occurred";    // avoid compiler warning
} // PMDGetErrorMessage
    768a:	c9 01       	movw	r24, r18
    768c:	08 95       	ret

0000768e <Dayname>:

/*****************************************************************************************/
uint8 *Dayname(tdia dia)
{

	switch(dia) 
    768e:	83 30       	cpi	r24, 0x03	; 3
    7690:	b9 f0       	breq	.+46     	; 0x76c0 <Dayname+0x32>
    7692:	84 30       	cpi	r24, 0x04	; 4
    7694:	28 f4       	brcc	.+10     	; 0x76a0 <Dayname+0x12>
    7696:	81 30       	cpi	r24, 0x01	; 1
    7698:	51 f0       	breq	.+20     	; 0x76ae <Dayname+0x20>
    769a:	82 30       	cpi	r24, 0x02	; 2
    769c:	70 f4       	brcc	.+28     	; 0x76ba <Dayname+0x2c>
    769e:	0a c0       	rjmp	.+20     	; 0x76b4 <Dayname+0x26>
    76a0:	85 30       	cpi	r24, 0x05	; 5
    76a2:	a1 f0       	breq	.+40     	; 0x76cc <Dayname+0x3e>
    76a4:	85 30       	cpi	r24, 0x05	; 5
    76a6:	78 f0       	brcs	.+30     	; 0x76c6 <Dayname+0x38>
    76a8:	86 30       	cpi	r24, 0x06	; 6
    76aa:	b1 f4       	brne	.+44     	; 0x76d8 <Dayname+0x4a>
    76ac:	12 c0       	rjmp	.+36     	; 0x76d2 <Dayname+0x44>
    76ae:	2f e5       	ldi	r18, 0x5F	; 95
    76b0:	3a e3       	ldi	r19, 0x3A	; 58
    76b2:	14 c0       	rjmp	.+40     	; 0x76dc <Dayname+0x4e>
    76b4:	25 e6       	ldi	r18, 0x65	; 101
    76b6:	3a e3       	ldi	r19, 0x3A	; 58
    76b8:	11 c0       	rjmp	.+34     	; 0x76dc <Dayname+0x4e>
    76ba:	2d e6       	ldi	r18, 0x6D	; 109
    76bc:	3a e3       	ldi	r19, 0x3A	; 58
    76be:	0e c0       	rjmp	.+28     	; 0x76dc <Dayname+0x4e>
	{
		case (Domingo) 					: return (uint8*)"Domingo"; break;
		case (Lunes) 					: return (uint8*)"Lunes"; break;
		case (Martes) 					: return (uint8*)"Martes"; break;
    76c0:	24 e7       	ldi	r18, 0x74	; 116
    76c2:	3a e3       	ldi	r19, 0x3A	; 58
    76c4:	0b c0       	rjmp	.+22     	; 0x76dc <Dayname+0x4e>
		case (Miercoles) 				: return (uint8*)"Miercoles"; break;
    76c6:	2e e7       	ldi	r18, 0x7E	; 126
    76c8:	3a e3       	ldi	r19, 0x3A	; 58
    76ca:	08 c0       	rjmp	.+16     	; 0x76dc <Dayname+0x4e>
		case (Jueves) 					: return (uint8*)"Jueves"; break;
    76cc:	25 e8       	ldi	r18, 0x85	; 133
    76ce:	3a e3       	ldi	r19, 0x3A	; 58
    76d0:	05 c0       	rjmp	.+10     	; 0x76dc <Dayname+0x4e>
		case (Viernes) 					: return (uint8*)"Viernes"; break;
    76d2:	2d e8       	ldi	r18, 0x8D	; 141
    76d4:	3a e3       	ldi	r19, 0x3A	; 58
    76d6:	02 c0       	rjmp	.+4      	; 0x76dc <Dayname+0x4e>
		case (Sabado) 					: return (uint8*)"Sabado"; break;
    76d8:	24 e9       	ldi	r18, 0x94	; 148
    76da:	3a e3       	ldi	r19, 0x3A	; 58
		   
		default 						: return (uint8*)"invalid day";
	}

} // Dayname
    76dc:	c9 01       	movw	r24, r18
    76de:	08 95       	ret

000076e0 <Monthname>:

/*****************************************************************************************/
uint8 *Monthname(tmes mes)
{

	switch(mes) 
    76e0:	86 30       	cpi	r24, 0x06	; 6
    76e2:	79 f1       	breq	.+94     	; 0x7742 <Monthname+0x62>
    76e4:	87 30       	cpi	r24, 0x07	; 7
    76e6:	70 f4       	brcc	.+28     	; 0x7704 <Monthname+0x24>
    76e8:	83 30       	cpi	r24, 0x03	; 3
    76ea:	11 f1       	breq	.+68     	; 0x7730 <Monthname+0x50>
    76ec:	84 30       	cpi	r24, 0x04	; 4
    76ee:	28 f4       	brcc	.+10     	; 0x76fa <Monthname+0x1a>
    76f0:	81 30       	cpi	r24, 0x01	; 1
    76f2:	d9 f0       	breq	.+54     	; 0x772a <Monthname+0x4a>
    76f4:	82 30       	cpi	r24, 0x02	; 2
    76f6:	d1 f5       	brne	.+116    	; 0x776c <Monthname+0x8c>
    76f8:	15 c0       	rjmp	.+42     	; 0x7724 <Monthname+0x44>
    76fa:	84 30       	cpi	r24, 0x04	; 4
    76fc:	e1 f0       	breq	.+56     	; 0x7736 <Monthname+0x56>
    76fe:	85 30       	cpi	r24, 0x05	; 5
    7700:	a9 f5       	brne	.+106    	; 0x776c <Monthname+0x8c>
    7702:	1c c0       	rjmp	.+56     	; 0x773c <Monthname+0x5c>
    7704:	89 30       	cpi	r24, 0x09	; 9
    7706:	31 f1       	breq	.+76     	; 0x7754 <Monthname+0x74>
    7708:	8a 30       	cpi	r24, 0x0A	; 10
    770a:	28 f4       	brcc	.+10     	; 0x7716 <Monthname+0x36>
    770c:	87 30       	cpi	r24, 0x07	; 7
    770e:	e1 f0       	breq	.+56     	; 0x7748 <Monthname+0x68>
    7710:	88 30       	cpi	r24, 0x08	; 8
    7712:	61 f5       	brne	.+88     	; 0x776c <Monthname+0x8c>
    7714:	1c c0       	rjmp	.+56     	; 0x774e <Monthname+0x6e>
    7716:	81 31       	cpi	r24, 0x11	; 17
    7718:	19 f1       	breq	.+70     	; 0x7760 <Monthname+0x80>
    771a:	82 31       	cpi	r24, 0x12	; 18
    771c:	21 f1       	breq	.+72     	; 0x7766 <Monthname+0x86>
    771e:	80 31       	cpi	r24, 0x10	; 16
    7720:	29 f5       	brne	.+74     	; 0x776c <Monthname+0x8c>
    7722:	1b c0       	rjmp	.+54     	; 0x775a <Monthname+0x7a>
    7724:	20 ea       	ldi	r18, 0xA0	; 160
    7726:	3a e3       	ldi	r19, 0x3A	; 58
    7728:	23 c0       	rjmp	.+70     	; 0x7770 <Monthname+0x90>
    772a:	28 ea       	ldi	r18, 0xA8	; 168
    772c:	3a e3       	ldi	r19, 0x3A	; 58
    772e:	20 c0       	rjmp	.+64     	; 0x7770 <Monthname+0x90>
    7730:	2e ea       	ldi	r18, 0xAE	; 174
    7732:	3a e3       	ldi	r19, 0x3A	; 58
    7734:	1d c0       	rjmp	.+58     	; 0x7770 <Monthname+0x90>
	{
		case (Enero) 					: return (uint8*)"Enero"; break;
		case (Febrero) 					: return (uint8*)"Febrero"; break;
		case (Marzo) 					: return (uint8*)"Marzo"; break;
    7736:	24 eb       	ldi	r18, 0xB4	; 180
    7738:	3a e3       	ldi	r19, 0x3A	; 58
    773a:	1a c0       	rjmp	.+52     	; 0x7770 <Monthname+0x90>
		case (Abril) 					: return (uint8*)"Abril"; break;
    773c:	2a eb       	ldi	r18, 0xBA	; 186
    773e:	3a e3       	ldi	r19, 0x3A	; 58
    7740:	17 c0       	rjmp	.+46     	; 0x7770 <Monthname+0x90>
		case (Mayo) 					: return (uint8*)"Mayo"; break;
    7742:	2f eb       	ldi	r18, 0xBF	; 191
    7744:	3a e3       	ldi	r19, 0x3A	; 58
    7746:	14 c0       	rjmp	.+40     	; 0x7770 <Monthname+0x90>
		case (Junio) 					: return (uint8*)"Junio"; break;
    7748:	25 ec       	ldi	r18, 0xC5	; 197
    774a:	3a e3       	ldi	r19, 0x3A	; 58
    774c:	11 c0       	rjmp	.+34     	; 0x7770 <Monthname+0x90>
		case (Julio) 					: return (uint8*)"Julio"; break;
    774e:	2b ec       	ldi	r18, 0xCB	; 203
    7750:	3a e3       	ldi	r19, 0x3A	; 58
    7752:	0e c0       	rjmp	.+28     	; 0x7770 <Monthname+0x90>
		case (Agosto) 					: return (uint8*)"Agosto"; break;
    7754:	22 ed       	ldi	r18, 0xD2	; 210
    7756:	3a e3       	ldi	r19, 0x3A	; 58
    7758:	0b c0       	rjmp	.+22     	; 0x7770 <Monthname+0x90>
		case (Septiembre) 				: return (uint8*)"Septiembre"; break;
    775a:	2d ed       	ldi	r18, 0xDD	; 221
    775c:	3a e3       	ldi	r19, 0x3A	; 58
    775e:	08 c0       	rjmp	.+16     	; 0x7770 <Monthname+0x90>
		case (Octubre) 					: return (uint8*)"Octubre"; break;
    7760:	25 ee       	ldi	r18, 0xE5	; 229
    7762:	3a e3       	ldi	r19, 0x3A	; 58
    7764:	05 c0       	rjmp	.+10     	; 0x7770 <Monthname+0x90>
		case (Noviembre) 				: return (uint8*)"Noviembre"; break;
    7766:	2f ee       	ldi	r18, 0xEF	; 239
    7768:	3a e3       	ldi	r19, 0x3A	; 58
    776a:	02 c0       	rjmp	.+4      	; 0x7770 <Monthname+0x90>
		case (Diciembre) 				: return (uint8*)"Diciembre"; break;
    776c:	29 ef       	ldi	r18, 0xF9	; 249
    776e:	3a e3       	ldi	r19, 0x3A	; 58
		
		default 						: return (uint8*)"invalid month";
	}

  //return (uint8*)"Monthname";  // avoid compiler warning
    7770:	c9 01       	movw	r24, r18
    7772:	08 95       	ret

00007774 <initCard>:

/****************************************************************************************/ 
void initCard(void)
{
 /////////////LED
 DDRE		=	_BV(LED1) | _BV(LED2) | _BV(Reset);				//Salidas
    7774:	2c e8       	ldi	r18, 0x8C	; 140
    7776:	2d b9       	out	0x0d, r18	; 13
 PORTE		=	_BV(LED1) | _BV(LED2);				                //Condiciones Iniciales							
    7778:	84 e8       	ldi	r24, 0x84	; 132
    777a:	8e b9       	out	0x0e, r24	; 14
 

 DDRB		=	_BV(LED0);
    777c:	80 e8       	ldi	r24, 0x80	; 128
    777e:	84 b9       	out	0x04, r24	; 4
 PORTB		=	_BV(LED0);											//Condiciones Iniciales
    7780:	85 b9       	out	0x05, r24	; 5
 
 //////////////PMDS
 PORTE      &= 	~(_BV(Reset));						                //Mantenido reset
    7782:	73 98       	cbi	0x0e, 3	; 14
 DDRD		=	_BV(HostSlct1) | _BV(HostSlct2) | _BV(HostSlct3) | _BV(Alarma); // Salidas.
    7784:	90 ef       	ldi	r25, 0xF0	; 240
    7786:	9a b9       	out	0x0a, r25	; 10
 PORTD		=	_BV(HostSlct1) | _BV(HostSlct2) | _BV(HostSlct3);	//Condiciones Iniciales
    7788:	80 e7       	ldi	r24, 0x70	; 112
    778a:	8b b9       	out	0x0b, r24	; 11

 
 
 DDRG 		= 	_BV(HostCmd) | _BV(HostWrite) | _BV(HostRead); 			// HostCmd,HostWrite,HostRead,Reset Salidas
    778c:	88 e3       	ldi	r24, 0x38	; 56
    778e:	83 bb       	out	0x13, r24	; 19
 PORTG		= 	_BV(HostWrite) | _BV(HostRead);							//Condiciones Iniciales
    7790:	80 e3       	ldi	r24, 0x30	; 48
    7792:	84 bb       	out	0x14, r24	; 20


 DDRH		=	_BV(USB_EN) | _BV(USB_WRITE) | _BV(USB_READ);		//Salidas
    7794:	8c e1       	ldi	r24, 0x1C	; 28
    7796:	80 93 01 01 	sts	0x0101, r24
 PORTH		=	_BV(USB_EN) | _BV(USB_WRITE) | _BV(USB_READ);   	//Condiciones Iniciales
    779a:	80 93 02 01 	sts	0x0102, r24
 
 
  
  
  //Mantener el motor apadado y coloca resistencias de Pull up en FINDER E FINDIZQ
  PORTF     =	_BV(DER) | _BV(IZQ) | _BV(FINDER) | _BV(FINIZQ);
    779e:	83 ec       	ldi	r24, 0xC3	; 195
    77a0:	81 bb       	out	0x11, r24	; 17
  
   //Solo Salidas DER y IQZ 
  DDRF		=	_BV(DER) | _BV(IZQ);
    77a2:	83 e0       	ldi	r24, 0x03	; 3
    77a4:	80 bb       	out	0x10, r24	; 16
/****************************** oTROS***************************************/

/** La interrupcion 3 (INT3) se activa en flanco de SUBIDA y la Interrupcion 2 (INT2)
	 se activa en flanco de Subida.*/

	EICRA		=	_BV(ISC31) | _BV(ISC30) | _BV(ISC21) | _BV(ISC20);
    77a6:	90 93 69 00 	sts	0x0069, r25

/** Las interrupciones INT4 E INT5 ( PMD1 y PMD2) se activan en flanco de Bajada.*/	
	
	EICRB		=	_BV(ISC51) | _BV(ISC41);
    77aa:	8a e0       	ldi	r24, 0x0A	; 10
    77ac:	80 93 6a 00 	sts	0x006A, r24
/**Habilito la Interrupcion Externa 2 (interrupcin Botn Parada Emergencia)
			la Interrupcion Externa 3 (interrupcin USB)
			la Interrupcion Externa 4 (interrupcin PMD1)
			la Interrupcion Externa 5 (interrupcin PMD2)*/
		
	EIMSK		=	_BV(INT5) | _BV(INT4) | _BV(INT3) | _BV(INT2);
    77b0:	8c e3       	ldi	r24, 0x3C	; 60
    77b2:	8d bb       	out	0x1d, r24	; 29

/** Habilito la Memoria RAM Externa con las siguientes caractersticas:
	-Toda la Memoria Ocupa un solo sector: SRL2, SRL1, y SRL0 estn en Cero.
	-con dos ciclos de espera: SRW11 y SRW10 bits estn en ALTO.  */
	
	XMCRA		=	_BV(SRE) | _BV(SRW11) | _BV(SRW10);
    77b4:	20 93 74 00 	sts	0x0074, r18

/** Timer/ Counter 1 Interrrupt Mask Register. Activo el Bit Timer/Counter1, Overflow
    interrupt Enable*/


	TIMSK1		=	_BV(TOIE1);	
    77b8:	91 e0       	ldi	r25, 0x01	; 1
    77ba:	90 93 6f 00 	sts	0x006F, r25
	
/** Modo de Operacion Normal, con un prescaler de CLK/1024 osea que trabaja con un reloj 
de 7.8125Khz por lo tanto cada 0,000128 seg aumenta se desborda cada 8,38848 seg*/	

	TCCR1B 		=	_BV(CS12) | _BV(CS10);
    77be:	85 e0       	ldi	r24, 0x05	; 5
    77c0:	80 93 81 00 	sts	0x0081, r24

/** Timer/ Counter 3 Interrrupt Mask Register. Activo el Bit Timer/Counter3, Overflow
    interrupt Enable*/


	TIMSK3		=	_BV(TOIE3);	
    77c4:	90 93 71 00 	sts	0x0071, r25
	
/** Modo de Operacion Normal, con un prescaler de CLK/1024*/	

	TCCR3B 		=	_BV(CS32) | _BV(CS30);
    77c8:	80 93 91 00 	sts	0x0091, r24
	
	

 }
    77cc:	08 95       	ret

000077ce <TIM16_ReadTCNTn>:
{
	unsigned char sreg;
	unsigned int i;
	
	/* Save global interrupt flag */
	sreg = SREG;
    77ce:	8f b7       	in	r24, 0x3f	; 63
	/* Disable interrupts */
	cli();
    77d0:	f8 94       	cli
	/* Read TCNTn into i */
	i = TCNT1;
    77d2:	e4 e8       	ldi	r30, 0x84	; 132
    77d4:	f0 e0       	ldi	r31, 0x00	; 0
    77d6:	20 81       	ld	r18, Z
    77d8:	31 81       	ldd	r19, Z+1	; 0x01
	TCNT1=0;
    77da:	11 82       	std	Z+1, r1	; 0x01
    77dc:	10 82       	st	Z, r1
	/* Restore global interrupt flag */
	SREG = sreg;
    77de:	8f bf       	out	0x3f, r24	; 63
	sei();
    77e0:	78 94       	sei
	return i;
}
    77e2:	c9 01       	movw	r24, r18
    77e4:	08 95       	ret

000077e6 <writePMDcommand>:
/*-----------------------Funciones Interface uControlador-PMDs--------------------------*/

void writePMDcommand(PMDuint16 PMDChipSet, PMDuint16 dataword)
{

	if(PMDChipSet==PMDChipSet1)
    77e6:	00 97       	sbiw	r24, 0x00	; 0
    77e8:	d9 f4       	brne	.+54     	; 0x7820 <writePMDcommand+0x3a>
	{
		PORTD			|=	_BV(HostSlct1);
    77ea:	5c 9a       	sbi	0x0b, 4	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    77ec:	84 b3       	in	r24, 0x14	; 20
    77ee:	80 63       	ori	r24, 0x30	; 48
    77f0:	84 bb       	out	0x14, r24	; 20
	
		HostControl 	&= 	~(_BV(HostCmd));						//HostCmd Bajo, Condiciones iniciales
    77f2:	a3 98       	cbi	0x14, 3	; 20
		Control_Port	=	0xFF;	  								//Coloco como salida el puerto 
    77f4:	8f ef       	ldi	r24, 0xFF	; 255
    77f6:	80 93 04 01 	sts	0x0104, r24
		PORTD		 	&= 	~(_BV(HostSlct1));						//Selecciono el Chipset 
    77fa:	5c 98       	cbi	0x0b, 4	; 11
		HostControl 	|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto
    77fc:	a3 9a       	sbi	0x14, 3	; 20
	
		HostData		= 	(PMDuint8)((dataword>>8) & 0xFF);		//Envo por el puerto de datos el byte mas 
    77fe:	70 93 05 01 	sts	0x0105, r23
																	//significativo  
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado.
    7802:	a4 98       	cbi	0x14, 4	; 20
    7804:	85 e0       	ldi	r24, 0x05	; 5
    7806:	98 2f       	mov	r25, r24
    7808:	9a 95       	dec	r25
    780a:	f1 f7       	brne	.-4      	; 0x7808 <writePMDcommand+0x22>
																	//Nota: trabajando a una velocidad de 8MHz se tiene 
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							//que el ciclo de cada instruccion del uC es de 125ns
    780c:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura. 
		HostData		=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto De datos el Byte menos signiicativo 
    780e:	60 93 05 01 	sts	0x0105, r22
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    7812:	a4 98       	cbi	0x14, 4	; 20
    7814:	8a 95       	dec	r24
    7816:	f1 f7       	brne	.-4      	; 0x7814 <writePMDcommand+0x2e>
																	//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    7818:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura.  
		
		HostControl 	&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel bajo
    781a:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 	|= 	_BV(HostSlct1);							//Deselecciono el Chipset. NOta Para la version 
    781c:	5c 9a       	sbi	0x0b, 4	; 11
    781e:	08 95       	ret
																	//con varios chipset se debe utilizarel puerto con una
																	// mascara para selecion y deseleccion respectivamente
	}
	
	if(PMDChipSet==PMDChipSet2)
    7820:	81 30       	cpi	r24, 0x01	; 1
    7822:	91 05       	cpc	r25, r1
    7824:	d9 f4       	brne	.+54     	; 0x785c <writePMDcommand+0x76>
	{
		PORTD			|=	_BV(HostSlct2);
    7826:	5d 9a       	sbi	0x0b, 5	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    7828:	84 b3       	in	r24, 0x14	; 20
    782a:	80 63       	ori	r24, 0x30	; 48
    782c:	84 bb       	out	0x14, r24	; 20
	
		HostControl 	&= 	~(_BV(HostCmd));						//HostCmd Bajo, Condiciones iniciales
    782e:	a3 98       	cbi	0x14, 3	; 20
		Control_Port	=	0xFF;	  								//Coloco como salida el puerto 
    7830:	8f ef       	ldi	r24, 0xFF	; 255
    7832:	80 93 04 01 	sts	0x0104, r24
		PORTD		 	&= 	~(_BV(HostSlct2));						//Selecciono el Chipset 
    7836:	5d 98       	cbi	0x0b, 5	; 11
		HostControl 	|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto
    7838:	a3 9a       	sbi	0x14, 3	; 20
	
		HostData		= 	(PMDuint8)((dataword>>8) & 0xFF);		//Envo por el puerto de datos el byte mas 
    783a:	70 93 05 01 	sts	0x0105, r23
																	//significativo  
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado.
    783e:	a4 98       	cbi	0x14, 4	; 20
    7840:	85 e0       	ldi	r24, 0x05	; 5
    7842:	98 2f       	mov	r25, r24
    7844:	9a 95       	dec	r25
    7846:	f1 f7       	brne	.-4      	; 0x7844 <writePMDcommand+0x5e>
																	//Nota: trabajando a una velocidad de 8MHz se tiene 
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							//que el ciclo de cada instruccion del uC es de 125ns
    7848:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura. 
		HostData		=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto De datos el Byte menos signiicativo 
    784a:	60 93 05 01 	sts	0x0105, r22
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    784e:	a4 98       	cbi	0x14, 4	; 20
    7850:	8a 95       	dec	r24
    7852:	f1 f7       	brne	.-4      	; 0x7850 <writePMDcommand+0x6a>
																	//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    7854:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura.  
		
		HostControl 	&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel bajo
    7856:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 	|= 	_BV(HostSlct2);							//Deselecciono el Chipset. NOta Para la version 
    7858:	5d 9a       	sbi	0x0b, 5	; 11
    785a:	08 95       	ret
																	//con varios chipset se debe utilizarel puerto con una
																	// mascara para selecion y deseleccion respectivamente
	}	
	
	if(PMDChipSet==PMDChipSet3)
    785c:	02 97       	sbiw	r24, 0x02	; 2
    785e:	d1 f4       	brne	.+52     	; 0x7894 <writePMDcommand+0xae>
	{
		PORTD			|=	_BV(HostSlct3);
    7860:	5e 9a       	sbi	0x0b, 6	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    7862:	84 b3       	in	r24, 0x14	; 20
    7864:	80 63       	ori	r24, 0x30	; 48
    7866:	84 bb       	out	0x14, r24	; 20
	
		HostControl 	&= 	~(_BV(HostCmd));						//HostCmd Bajo, Condiciones iniciales
    7868:	a3 98       	cbi	0x14, 3	; 20
		Control_Port	=	0xFF;	  								//Coloco como salida el puerto 
    786a:	8f ef       	ldi	r24, 0xFF	; 255
    786c:	80 93 04 01 	sts	0x0104, r24
		PORTD		 	&= 	~(_BV(HostSlct3));						//Selecciono el Chipset 
    7870:	5e 98       	cbi	0x0b, 6	; 11
		HostControl 	|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto
    7872:	a3 9a       	sbi	0x14, 3	; 20
	
		HostData		= 	(PMDuint8)((dataword>>8) & 0xFF);		//Envo por el puerto de datos el byte mas 
    7874:	70 93 05 01 	sts	0x0105, r23
																	//significativo  
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado.
    7878:	a4 98       	cbi	0x14, 4	; 20
    787a:	85 e0       	ldi	r24, 0x05	; 5
    787c:	98 2f       	mov	r25, r24
    787e:	9a 95       	dec	r25
    7880:	f1 f7       	brne	.-4      	; 0x787e <writePMDcommand+0x98>
																	//Nota: trabajando a una velocidad de 8MHz se tiene 
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							//que el ciclo de cada instruccion del uC es de 125ns
    7882:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura. 
		HostData		=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto De datos el Byte menos signiicativo 
    7884:	60 93 05 01 	sts	0x0105, r22
		HostControl		&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    7888:	a4 98       	cbi	0x14, 4	; 20
    788a:	8a 95       	dec	r24
    788c:	f1 f7       	brne	.-4      	; 0x788a <writePMDcommand+0xa4>
																	//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 	|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    788e:	a4 9a       	sbi	0x14, 4	; 20
																	// que es suficiente para relaizar el ciclo de escritura.  
		
		HostControl 	&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel bajo
    7890:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 	|= 	_BV(HostSlct3);							//Deselecciono el Chipset. NOta Para la version 
    7892:	5e 9a       	sbi	0x0b, 6	; 11
    7894:	08 95       	ret

00007896 <writePMDdata>:
}
/*----------------------------------------------------------------------------------------------------*/
void writePMDdata(PMDuint16 PMDChipSet, PMDuint16 dataword)
{

	if(PMDChipSet==PMDChipSet1)
    7896:	00 97       	sbiw	r24, 0x00	; 0
    7898:	d9 f4       	brne	.+54     	; 0x78d0 <writePMDdata+0x3a>
	{	
		PORTD				|=	_BV(HostSlct1);
    789a:	5c 9a       	sbi	0x0b, 4	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    789c:	84 b3       	in	r24, 0x14	; 20
    789e:	80 63       	ori	r24, 0x30	; 48
    78a0:	84 bb       	out	0x14, r24	; 20

		Control_Port		=	0xFF;			  						//Coloco como salida el puerto 
    78a2:	8f ef       	ldi	r24, 0xFF	; 255
    78a4:	80 93 04 01 	sts	0x0104, r24

		HostControl 		|= 	_BV(HostCmd);							//HostCmd Alto Condiciones iniciales
    78a8:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct1));						//Selecciono el Chipset 
    78aa:	5c 98       	cbi	0x0b, 4	; 11
		HostControl 		&= 	~(_BV(HostCmd));			 			//Coloco la Seal HostCmd a Nivel bajo
    78ac:	a3 98       	cbi	0x14, 3	; 20
		HostData			= 	(PMDuint8)((dataword>>8)&0xFF);		//Envo por el puerto de datos el byte mas significativo  
    78ae:	70 93 05 01 	sts	0x0105, r23
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    78b2:	a4 98       	cbi	0x14, 4	; 20
    78b4:	85 e0       	ldi	r24, 0x05	; 5
    78b6:	98 2f       	mov	r25, r24
    78b8:	9a 95       	dec	r25
    78ba:	f1 f7       	brne	.-4      	; 0x78b8 <writePMDdata+0x22>
																		//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    78bc:	a4 9a       	sbi	0x14, 4	; 20
																		// que es suficiente para relaizar el ciclo de escritura. 
		HostData			=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto e datos el Byte menos signiicativo 
    78be:	60 93 05 01 	sts	0x0105, r22
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. Nota: trabajando 
    78c2:	a4 98       	cbi	0x14, 4	; 20
    78c4:	8a 95       	dec	r24
    78c6:	f1 f7       	brne	.-4      	; 0x78c4 <writePMDdata+0x2e>
																		//a una velocidad de 8MHz se tiene que el ciclo de cada 
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							//instruccion del uC es de 125ns que es suficiente para
    78c8:	a4 9a       	sbi	0x14, 4	; 20
																		// relaizar el ciclo de escritura.  
	
		HostControl 		|= 	_BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    78ca:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct1); 						//Deselecciono el Chipset. NOta Para la version con
    78cc:	5c 9a       	sbi	0x0b, 4	; 11
    78ce:	08 95       	ret
																		//varios chipset se debe utilizarel puerto con una mascara
																		// para sellecion y deseleccion respectivamente
	}

	if(PMDChipSet==PMDChipSet2)
    78d0:	81 30       	cpi	r24, 0x01	; 1
    78d2:	91 05       	cpc	r25, r1
    78d4:	d9 f4       	brne	.+54     	; 0x790c <writePMDdata+0x76>
	{	
		PORTD				|=	_BV(HostSlct2);
    78d6:	5d 9a       	sbi	0x0b, 5	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    78d8:	84 b3       	in	r24, 0x14	; 20
    78da:	80 63       	ori	r24, 0x30	; 48
    78dc:	84 bb       	out	0x14, r24	; 20

		Control_Port		=	0xFF;			  						//Coloco como salida el puerto 
    78de:	8f ef       	ldi	r24, 0xFF	; 255
    78e0:	80 93 04 01 	sts	0x0104, r24

		HostControl 		|= 	_BV(HostCmd);							//HostCmd Alto Condiciones iniciales
    78e4:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct2));						//Selecciono el Chipset 
    78e6:	5d 98       	cbi	0x0b, 5	; 11
		HostControl 		&= 	~(_BV(HostCmd));			 			//Coloco la Seal HostCmd a Nivel bajo
    78e8:	a3 98       	cbi	0x14, 3	; 20
		HostData			= 	(PMDuint8)((dataword>>8)&0xFF);		//Envo por el puerto de datos el byte mas significativo  
    78ea:	70 93 05 01 	sts	0x0105, r23
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    78ee:	a4 98       	cbi	0x14, 4	; 20
    78f0:	85 e0       	ldi	r24, 0x05	; 5
    78f2:	98 2f       	mov	r25, r24
    78f4:	9a 95       	dec	r25
    78f6:	f1 f7       	brne	.-4      	; 0x78f4 <writePMDdata+0x5e>
																		//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    78f8:	a4 9a       	sbi	0x14, 4	; 20
																		// que es suficiente para relaizar el ciclo de escritura. 
		HostData			=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto e datos el Byte menos signiicativo 
    78fa:	60 93 05 01 	sts	0x0105, r22
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. Nota: trabajando 
    78fe:	a4 98       	cbi	0x14, 4	; 20
    7900:	8a 95       	dec	r24
    7902:	f1 f7       	brne	.-4      	; 0x7900 <writePMDdata+0x6a>
																		//a una velocidad de 8MHz se tiene que el ciclo de cada 
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							//instruccion del uC es de 125ns que es suficiente para
    7904:	a4 9a       	sbi	0x14, 4	; 20
																		// relaizar el ciclo de escritura.  
	
		HostControl 		|= 	_BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    7906:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct2); 						//Deselecciono el Chipset. NOta Para la version con
    7908:	5d 9a       	sbi	0x0b, 5	; 11
    790a:	08 95       	ret
																		//varios chipset se debe utilizarel puerto con una mascara
																		// para sellecion y deseleccion respectivamente
	}	

	if(PMDChipSet==PMDChipSet3)
    790c:	02 97       	sbiw	r24, 0x02	; 2
    790e:	d1 f4       	brne	.+52     	; 0x7944 <writePMDdata+0xae>
	{	
		PORTD				|=	_BV(HostSlct3);
    7910:	5e 9a       	sbi	0x0b, 6	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    7912:	84 b3       	in	r24, 0x14	; 20
    7914:	80 63       	ori	r24, 0x30	; 48
    7916:	84 bb       	out	0x14, r24	; 20

		Control_Port		=	0xFF;			  						//Coloco como salida el puerto 
    7918:	8f ef       	ldi	r24, 0xFF	; 255
    791a:	80 93 04 01 	sts	0x0104, r24

		HostControl 		|= 	_BV(HostCmd);							//HostCmd Alto Condiciones iniciales
    791e:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct3));						//Selecciono el Chipset 
    7920:	5e 98       	cbi	0x0b, 6	; 11
		HostControl 		&= 	~(_BV(HostCmd));			 			//Coloco la Seal HostCmd a Nivel bajo
    7922:	a3 98       	cbi	0x14, 3	; 20
		HostData			= 	(PMDuint8)((dataword>>8)&0xFF);		//Envo por el puerto de datos el byte mas significativo  
    7924:	70 93 05 01 	sts	0x0105, r23
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. 
    7928:	a4 98       	cbi	0x14, 4	; 20
    792a:	85 e0       	ldi	r24, 0x05	; 5
    792c:	98 2f       	mov	r25, r24
    792e:	9a 95       	dec	r25
    7930:	f1 f7       	brne	.-4      	; 0x792e <writePMDdata+0x98>
																		//Nota: trabajando a una velocidad de 8MHz se tiene
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							// que el ciclo de cada instruccion del uC es de 125ns
    7932:	a4 9a       	sbi	0x14, 4	; 20
																		// que es suficiente para relaizar el ciclo de escritura. 
		HostData			=	(PMDuint8)(dataword&0xFF);				//Envo por el Puerto e datos el Byte menos signiicativo 
    7934:	60 93 05 01 	sts	0x0105, r22
		HostControl			&= 	~(_BV(HostWrite));						//Realizo la escritura del byte enviado. Nota: trabajando 
    7938:	a4 98       	cbi	0x14, 4	; 20
    793a:	8a 95       	dec	r24
    793c:	f1 f7       	brne	.-4      	; 0x793a <writePMDdata+0xa4>
																		//a una velocidad de 8MHz se tiene que el ciclo de cada 
		_delay_us(2);
		HostControl 		|= 	_BV(HostWrite);							//instruccion del uC es de 125ns que es suficiente para
    793e:	a4 9a       	sbi	0x14, 4	; 20
																		// relaizar el ciclo de escritura.  
	
		HostControl 		|= 	_BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    7940:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct3); 						//Deselecciono el Chipset. NOta Para la version con
    7942:	5e 9a       	sbi	0x0b, 6	; 11
    7944:	08 95       	ret

00007946 <readPMDdata>:
PMDuint16 readPMDdata(PMDuint16 PMDChipSet)
{
	PMDuint16 i			=	0;
	PMDuint16 j			=	0;

	if(PMDChipSet==PMDChipSet1)
    7946:	00 97       	sbiw	r24, 0x00	; 0
    7948:	21 f5       	brne	.+72     	; 0x7992 <readPMDdata+0x4c>
	{
		PORTD			|=	_BV(HostSlct1);
    794a:	5c 9a       	sbi	0x0b, 4	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);					// Condiciones Iniciales		
    794c:	84 b3       	in	r24, 0x14	; 20
    794e:	80 63       	ori	r24, 0x30	; 48
    7950:	84 bb       	out	0x14, r24	; 20

	


		Control_Port		=	0x00;			  						//Coloco como entrada el puerto 
    7952:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;									//Resistencias de Pullups ( averiguar mas esto)
    7956:	8f ef       	ldi	r24, 0xFF	; 255
    7958:	80 93 05 01 	sts	0x0105, r24

		HostControl 		|=	_BV(HostCmd);							//HostCmd Alto. Condiciones Iniciales
    795c:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct1));						//Selecciono el Chipset 
    795e:	5c 98       	cbi	0x0b, 4	; 11
		HostControl 		&= 	~(_BV(HostCmd));						//Coloco la Seal HostCmd a Nivel bajo 
    7960:	a3 98       	cbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    7962:	a5 98       	cbi	0x14, 5	; 20
    7964:	95 e0       	ldi	r25, 0x05	; 5
    7966:	89 2f       	mov	r24, r25
    7968:	8a 95       	dec	r24
    796a:	f1 f7       	brne	.-4      	; 0x7968 <readPMDdata+0x22>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los
    796c:	80 91 03 01 	lds	r24, 0x0103
    7970:	58 2f       	mov	r21, r24
    7972:	40 e0       	ldi	r20, 0x00	; 0
																		//datos ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    7974:	a5 9a       	sbi	0x14, 5	; 20
    7976:	89 2f       	mov	r24, r25
    7978:	8a 95       	dec	r24
    797a:	f1 f7       	brne	.-4      	; 0x7978 <readPMDdata+0x32>
		_delay_us(2);

		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    797c:	a5 98       	cbi	0x14, 5	; 20
    797e:	9a 95       	dec	r25
    7980:	f1 f7       	brne	.-4      	; 0x797e <readPMDdata+0x38>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    7982:	80 91 03 01 	lds	r24, 0x0103
    7986:	28 2f       	mov	r18, r24
    7988:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    798a:	a5 9a       	sbi	0x14, 5	; 20

	
		HostControl 		|= _BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    798c:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= _BV(HostSlct1); 							//Deselecciono el Chipset.
    798e:	5c 9a       	sbi	0x0b, 4	; 11
    7990:	51 c0       	rjmp	.+162    	; 0x7a34 <readPMDdata+0xee>
	
	
		
	}

	if(PMDChipSet==PMDChipSet2)
    7992:	81 30       	cpi	r24, 0x01	; 1
    7994:	91 05       	cpc	r25, r1
    7996:	21 f5       	brne	.+72     	; 0x79e0 <readPMDdata+0x9a>
	{
		PORTD			|=	_BV(HostSlct2);
    7998:	5d 9a       	sbi	0x0b, 5	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);					// Condiciones Iniciales		
    799a:	84 b3       	in	r24, 0x14	; 20
    799c:	80 63       	ori	r24, 0x30	; 48
    799e:	84 bb       	out	0x14, r24	; 20

	


		Control_Port		=	0x00;			  						//Coloco como entrada el puerto 
    79a0:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;									//Resistencias de Pullups ( averiguar mas esto)
    79a4:	8f ef       	ldi	r24, 0xFF	; 255
    79a6:	80 93 05 01 	sts	0x0105, r24

		HostControl 		|=	_BV(HostCmd);							//HostCmd Alto. Condiciones Iniciales
    79aa:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct2));						//Selecciono el Chipset 
    79ac:	5d 98       	cbi	0x0b, 5	; 11
		HostControl 		&= 	~(_BV(HostCmd));						//Coloco la Seal HostCmd a Nivel bajo 
    79ae:	a3 98       	cbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    79b0:	a5 98       	cbi	0x14, 5	; 20
    79b2:	95 e0       	ldi	r25, 0x05	; 5
    79b4:	89 2f       	mov	r24, r25
    79b6:	8a 95       	dec	r24
    79b8:	f1 f7       	brne	.-4      	; 0x79b6 <readPMDdata+0x70>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los
    79ba:	80 91 03 01 	lds	r24, 0x0103
    79be:	58 2f       	mov	r21, r24
    79c0:	40 e0       	ldi	r20, 0x00	; 0
																		//datos ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    79c2:	a5 9a       	sbi	0x14, 5	; 20
    79c4:	89 2f       	mov	r24, r25
    79c6:	8a 95       	dec	r24
    79c8:	f1 f7       	brne	.-4      	; 0x79c6 <readPMDdata+0x80>
		_delay_us(2);

		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    79ca:	a5 98       	cbi	0x14, 5	; 20
    79cc:	9a 95       	dec	r25
    79ce:	f1 f7       	brne	.-4      	; 0x79cc <readPMDdata+0x86>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    79d0:	80 91 03 01 	lds	r24, 0x0103
    79d4:	28 2f       	mov	r18, r24
    79d6:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    79d8:	a5 9a       	sbi	0x14, 5	; 20

	
		HostControl 		|= _BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    79da:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= _BV(HostSlct2); 							//Deselecciono el Chipset.
    79dc:	5d 9a       	sbi	0x0b, 5	; 11
    79de:	2a c0       	rjmp	.+84     	; 0x7a34 <readPMDdata+0xee>
	
	
		
	}
	
	if(PMDChipSet==PMDChipSet3)
    79e0:	02 97       	sbiw	r24, 0x02	; 2
    79e2:	29 f0       	breq	.+10     	; 0x79ee <readPMDdata+0xa8>
    79e4:	40 e0       	ldi	r20, 0x00	; 0
    79e6:	50 e0       	ldi	r21, 0x00	; 0
    79e8:	20 e0       	ldi	r18, 0x00	; 0
    79ea:	30 e0       	ldi	r19, 0x00	; 0
    79ec:	23 c0       	rjmp	.+70     	; 0x7a34 <readPMDdata+0xee>
	{
		PORTD			|=	_BV(HostSlct3);
    79ee:	5e 9a       	sbi	0x0b, 6	; 11
		HostControl 	|=	_BV(HostWrite) | _BV(HostRead);					// Condiciones Iniciales		
    79f0:	84 b3       	in	r24, 0x14	; 20
    79f2:	80 63       	ori	r24, 0x30	; 48
    79f4:	84 bb       	out	0x14, r24	; 20

	


		Control_Port		=	0x00;			  						//Coloco como entrada el puerto 
    79f6:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;									//Resistencias de Pullups ( averiguar mas esto)
    79fa:	8f ef       	ldi	r24, 0xFF	; 255
    79fc:	80 93 05 01 	sts	0x0105, r24

		HostControl 		|=	_BV(HostCmd);							//HostCmd Alto. Condiciones Iniciales
    7a00:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct3));						//Selecciono el Chipset 
    7a02:	5e 98       	cbi	0x0b, 6	; 11
		HostControl 		&= 	~(_BV(HostCmd));						//Coloco la Seal HostCmd a Nivel bajo 
    7a04:	a3 98       	cbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    7a06:	a5 98       	cbi	0x14, 5	; 20
    7a08:	95 e0       	ldi	r25, 0x05	; 5
    7a0a:	89 2f       	mov	r24, r25
    7a0c:	8a 95       	dec	r24
    7a0e:	f1 f7       	brne	.-4      	; 0x7a0c <readPMDdata+0xc6>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los
    7a10:	80 91 03 01 	lds	r24, 0x0103
    7a14:	58 2f       	mov	r21, r24
    7a16:	40 e0       	ldi	r20, 0x00	; 0
																		//datos ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    7a18:	a5 9a       	sbi	0x14, 5	; 20
    7a1a:	89 2f       	mov	r24, r25
    7a1c:	8a 95       	dec	r24
    7a1e:	f1 f7       	brne	.-4      	; 0x7a1c <readPMDdata+0xd6>
		_delay_us(2);

		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    7a20:	a5 98       	cbi	0x14, 5	; 20
    7a22:	9a 95       	dec	r25
    7a24:	f1 f7       	brne	.-4      	; 0x7a22 <readPMDdata+0xdc>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    7a26:	80 91 03 01 	lds	r24, 0x0103
    7a2a:	28 2f       	mov	r18, r24
    7a2c:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    7a2e:	a5 9a       	sbi	0x14, 5	; 20

	
		HostControl 		|= _BV(HostCmd);							//Coloca la seal de HostCmd a Nivel Alto
    7a30:	a3 9a       	sbi	0x14, 3	; 20
		PORTD		 		|= _BV(HostSlct3); 							//Deselecciono el Chipset.
    7a32:	5e 9a       	sbi	0x0b, 6	; 11
    7a34:	24 2b       	or	r18, r20
    7a36:	35 2b       	or	r19, r21
		
	}
	
	
	return i | j;
}  
    7a38:	c9 01       	movw	r24, r18
    7a3a:	08 95       	ret

00007a3c <readPMDstatus>:
PMDuint16 readPMDstatus(PMDuint16 PMDChipSet)
{
	PMDuint16 i			=	0;
	PMDuint16 j			=	0;
	
	if(PMDChipSet==PMDChipSet1)
    7a3c:	00 97       	sbiw	r24, 0x00	; 0
    7a3e:	21 f5       	brne	.+72     	; 0x7a88 <readPMDstatus+0x4c>
	{
		PORTD				|=	_BV(HostSlct1);
    7a40:	5c 9a       	sbi	0x0b, 4	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    7a42:	84 b3       	in	r24, 0x14	; 20
    7a44:	80 63       	ori	r24, 0x30	; 48
    7a46:	84 bb       	out	0x14, r24	; 20
	
		


		Control_Port		=	0x00;									//Coloco como entrada el puerto A
    7a48:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;   								//Resistencias de Pullups ( averiguar mas esto)
    7a4c:	8f ef       	ldi	r24, 0xFF	; 255
    7a4e:	80 93 05 01 	sts	0x0105, r24
	
		HostControl 		&= 	~(_BV(HostCmd));						//HostCmd Bajo.Condiciones Iniciales
    7a52:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct1));						//Selecciono el Chipset 
    7a54:	5c 98       	cbi	0x0b, 4	; 11
		HostControl 		|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto 
    7a56:	a3 9a       	sbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    7a58:	a5 98       	cbi	0x14, 5	; 20
    7a5a:	95 e0       	ldi	r25, 0x05	; 5
    7a5c:	89 2f       	mov	r24, r25
    7a5e:	8a 95       	dec	r24
    7a60:	f1 f7       	brne	.-4      	; 0x7a5e <readPMDstatus+0x22>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los datos
    7a62:	80 91 03 01 	lds	r24, 0x0103
    7a66:	58 2f       	mov	r21, r24
    7a68:	40 e0       	ldi	r20, 0x00	; 0
																		//ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    7a6a:	a5 9a       	sbi	0x14, 5	; 20
    7a6c:	9a 95       	dec	r25
    7a6e:	f1 f7       	brne	.-4      	; 0x7a6c <readPMDstatus+0x30>
		_delay_us(2);
		
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    7a70:	a5 98       	cbi	0x14, 5	; 20
    7a72:	82 e0       	ldi	r24, 0x02	; 2
    7a74:	8a 95       	dec	r24
    7a76:	f1 f7       	brne	.-4      	; 0x7a74 <readPMDstatus+0x38>
		_delay_us(1);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    7a78:	80 91 03 01 	lds	r24, 0x0103
    7a7c:	28 2f       	mov	r18, r24
    7a7e:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead  
    7a80:	a5 9a       	sbi	0x14, 5	; 20
	
	
		HostControl 		&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel Bajo  
    7a82:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct1); 						//Deselecciono el Chipset
    7a84:	5c 9a       	sbi	0x0b, 4	; 11
    7a86:	51 c0       	rjmp	.+162    	; 0x7b2a <readPMDstatus+0xee>

		
	}
	
		if(PMDChipSet==PMDChipSet2)
    7a88:	81 30       	cpi	r24, 0x01	; 1
    7a8a:	91 05       	cpc	r25, r1
    7a8c:	21 f5       	brne	.+72     	; 0x7ad6 <readPMDstatus+0x9a>
	{
		PORTD				|=	_BV(HostSlct2);
    7a8e:	5d 9a       	sbi	0x0b, 5	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    7a90:	84 b3       	in	r24, 0x14	; 20
    7a92:	80 63       	ori	r24, 0x30	; 48
    7a94:	84 bb       	out	0x14, r24	; 20
	
		


		Control_Port		=	0x00;									//Coloco como entrada el puerto A
    7a96:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;   								//Resistencias de Pullups ( averiguar mas esto)
    7a9a:	8f ef       	ldi	r24, 0xFF	; 255
    7a9c:	80 93 05 01 	sts	0x0105, r24
	
		HostControl 		&= 	~(_BV(HostCmd));						//HostCmd Bajo.Condiciones Iniciales
    7aa0:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct2));						//Selecciono el Chipset 
    7aa2:	5d 98       	cbi	0x0b, 5	; 11
		HostControl 		|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto 
    7aa4:	a3 9a       	sbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    7aa6:	a5 98       	cbi	0x14, 5	; 20
    7aa8:	95 e0       	ldi	r25, 0x05	; 5
    7aaa:	89 2f       	mov	r24, r25
    7aac:	8a 95       	dec	r24
    7aae:	f1 f7       	brne	.-4      	; 0x7aac <readPMDstatus+0x70>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los datos
    7ab0:	80 91 03 01 	lds	r24, 0x0103
    7ab4:	58 2f       	mov	r21, r24
    7ab6:	40 e0       	ldi	r20, 0x00	; 0
																		//ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    7ab8:	a5 9a       	sbi	0x14, 5	; 20
    7aba:	9a 95       	dec	r25
    7abc:	f1 f7       	brne	.-4      	; 0x7aba <readPMDstatus+0x7e>
		_delay_us(2);
		
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    7abe:	a5 98       	cbi	0x14, 5	; 20
    7ac0:	82 e0       	ldi	r24, 0x02	; 2
    7ac2:	8a 95       	dec	r24
    7ac4:	f1 f7       	brne	.-4      	; 0x7ac2 <readPMDstatus+0x86>
		_delay_us(1);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    7ac6:	80 91 03 01 	lds	r24, 0x0103
    7aca:	28 2f       	mov	r18, r24
    7acc:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead  
    7ace:	a5 9a       	sbi	0x14, 5	; 20
	
	
		HostControl 		&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel Bajo  
    7ad0:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct2); 						//Deselecciono el Chipset
    7ad2:	5d 9a       	sbi	0x0b, 5	; 11
    7ad4:	2a c0       	rjmp	.+84     	; 0x7b2a <readPMDstatus+0xee>

		
	}

	if(PMDChipSet==PMDChipSet3)
    7ad6:	02 97       	sbiw	r24, 0x02	; 2
    7ad8:	29 f0       	breq	.+10     	; 0x7ae4 <readPMDstatus+0xa8>
    7ada:	40 e0       	ldi	r20, 0x00	; 0
    7adc:	50 e0       	ldi	r21, 0x00	; 0
    7ade:	20 e0       	ldi	r18, 0x00	; 0
    7ae0:	30 e0       	ldi	r19, 0x00	; 0
    7ae2:	23 c0       	rjmp	.+70     	; 0x7b2a <readPMDstatus+0xee>
	{
		PORTD				|=	_BV(HostSlct3);
    7ae4:	5e 9a       	sbi	0x0b, 6	; 11
		HostControl		 	|=	_BV(HostWrite) | _BV(HostRead);				// Condiciones Iniciales		
    7ae6:	84 b3       	in	r24, 0x14	; 20
    7ae8:	80 63       	ori	r24, 0x30	; 48
    7aea:	84 bb       	out	0x14, r24	; 20
	
		


		Control_Port		=	0x00;									//Coloco como entrada el puerto A
    7aec:	10 92 04 01 	sts	0x0104, r1
		HostData			=	0xFF;   								//Resistencias de Pullups ( averiguar mas esto)
    7af0:	8f ef       	ldi	r24, 0xFF	; 255
    7af2:	80 93 05 01 	sts	0x0105, r24
	
		HostControl 		&= 	~(_BV(HostCmd));						//HostCmd Bajo.Condiciones Iniciales
    7af6:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		&= 	~(_BV(HostSlct3));						//Selecciono el Chipset 
    7af8:	5e 98       	cbi	0x0b, 6	; 11
		HostControl 		|= 	_BV(HostCmd);							//Coloco la Seal HostCmd a Nivel Alto 
    7afa:	a3 9a       	sbi	0x14, 3	; 20
	
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    7afc:	a5 98       	cbi	0x14, 5	; 20
    7afe:	95 e0       	ldi	r25, 0x05	; 5
    7b00:	89 2f       	mov	r24, r25
    7b02:	8a 95       	dec	r24
    7b04:	f1 f7       	brne	.-4      	; 0x7b02 <readPMDstatus+0xc6>
		_delay_us(2);													//retardo de un 1uS para asegurar la lecltura del dato
		i					=	(ReadData & 0xFF)<<8;					//Hago corriminto hacia la izq en i de los datos
    7b06:	80 91 03 01 	lds	r24, 0x0103
    7b0a:	58 2f       	mov	r21, r24
    7b0c:	40 e0       	ldi	r20, 0x00	; 0
																		//ledos en el puerto 
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead
    7b0e:	a5 9a       	sbi	0x14, 5	; 20
    7b10:	9a 95       	dec	r25
    7b12:	f1 f7       	brne	.-4      	; 0x7b10 <readPMDstatus+0xd4>
		_delay_us(2);
		
		HostControl			&= 	~(_BV(HostRead));						//Aserto la seal de ~HostRead
    7b14:	a5 98       	cbi	0x14, 5	; 20
    7b16:	82 e0       	ldi	r24, 0x02	; 2
    7b18:	8a 95       	dec	r24
    7b1a:	f1 f7       	brne	.-4      	; 0x7b18 <readPMDstatus+0xdc>
		_delay_us(1);													//retardo de un 1uS para asegurar la lecltura del dato
		j					=	(ReadData & 0xFF);						//Asigno a j el valor ledo en el Puerto de Datos
    7b1c:	80 91 03 01 	lds	r24, 0x0103
    7b20:	28 2f       	mov	r18, r24
    7b22:	30 e0       	ldi	r19, 0x00	; 0
		HostControl 		|= 	_BV(HostRead);							//des_Aserto la seal de ~HostRead  
    7b24:	a5 9a       	sbi	0x14, 5	; 20
	
	
		HostControl 		&= 	~(_BV(HostCmd));						//Coloca la seal de HostCmd a Nivel Bajo  
    7b26:	a3 98       	cbi	0x14, 3	; 20
		PORTD		 		|= 	_BV(HostSlct3); 						//Deselecciono el Chipset
    7b28:	5e 9a       	sbi	0x0b, 6	; 11
    7b2a:	24 2b       	or	r18, r20
    7b2c:	35 2b       	or	r19, r21
		
	}
	

		return i | j;
}
    7b2e:	c9 01       	movw	r24, r18
    7b30:	08 95       	ret

00007b32 <writePMDreset>:
/*----------------------------------------------------------------------------------------------------*/
void writePMDreset(void)  
{
	PORTE 	|= _BV(Reset);												//reset alto
    7b32:	73 9a       	sbi	0x0e, 3	; 14
	PORTE 	&= ~(_BV(Reset));											//bajo reset
    7b34:	73 98       	cbi	0x0e, 3	; 14
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7b36:	80 e9       	ldi	r24, 0x90	; 144
    7b38:	91 e0       	ldi	r25, 0x01	; 1
    7b3a:	01 97       	sbiw	r24, 0x01	; 1
    7b3c:	f1 f7       	brne	.-4      	; 0x7b3a <writePMDreset+0x8>
	_delay_us(200);
	PORTE 	|= _BV(Reset);												//reset alto
    7b3e:	73 9a       	sbi	0x0e, 3	; 14
    7b40:	80 e9       	ldi	r24, 0x90	; 144
    7b42:	91 e0       	ldi	r25, 0x01	; 1
    7b44:	28 ec       	ldi	r18, 0xC8	; 200
    7b46:	30 e0       	ldi	r19, 0x00	; 0
    7b48:	f9 01       	movw	r30, r18
    7b4a:	31 97       	sbiw	r30, 0x01	; 1
    7b4c:	f1 f7       	brne	.-4      	; 0x7b4a <writePMDreset+0x18>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7b4e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7b50:	d9 f7       	brne	.-10     	; 0x7b48 <writePMDreset+0x16>
	_delay_ms(40);                     									//TIEMPO TOMADO DE C_MOTION ORIGINAL	 
	
}
    7b52:	08 95       	ret

00007b54 <GetAxissetting>:
	
	return Diferentes;
}
/**********************************************************************************************************************/
void GetAxissetting(uint8* TXAxissetting)
{
    7b54:	ac 01       	movw	r20, r24
    7b56:	20 e0       	ldi	r18, 0x00	; 0
    7b58:	30 e0       	ldi	r19, 0x00	; 0
	    
		offset=Buffersize*Axis;
		#ifdef DEBUGSETUP
		printf("GethAxissetting=> Actualizando Axis %d con offset = %d\n",Axis,offset);
		#endif	
		pdata=(uint8*)&hAxis[Axis].axisSettings;
    7b5a:	f9 01       	movw	r30, r18
    7b5c:	ee 0f       	add	r30, r30
    7b5e:	ff 1f       	adc	r31, r31
    7b60:	e2 0f       	add	r30, r18
    7b62:	f3 1f       	adc	r31, r19
    7b64:	85 e0       	ldi	r24, 0x05	; 5
    7b66:	ee 0f       	add	r30, r30
    7b68:	ff 1f       	adc	r31, r31
    7b6a:	8a 95       	dec	r24
    7b6c:	e1 f7       	brne	.-8      	; 0x7b66 <GetAxissetting+0x12>
    7b6e:	e3 5e       	subi	r30, 0xE3	; 227
    7b70:	fa 48       	sbci	r31, 0x8A	; 138
    7b72:	da 01       	movw	r26, r20
		fin=Buffersize+offset;
		for(i=offset;i<fin;i++) 
    7b74:	bf 01       	movw	r22, r30
    7b76:	6c 5b       	subi	r22, 0xBC	; 188
    7b78:	7f 4f       	sbci	r23, 0xFF	; 255
    7b7a:	02 c0       	rjmp	.+4      	; 0x7b80 <GetAxissetting+0x2c>
			TXAxissetting[i]=pdata[i-offset];  //desde pdata[0] hasta pdata[buffersize]
    7b7c:	81 91       	ld	r24, Z+
    7b7e:	8d 93       	st	X+, r24
		#ifdef DEBUGSETUP
		printf("GethAxissetting=> Actualizando Axis %d con offset = %d\n",Axis,offset);
		#endif	
		pdata=(uint8*)&hAxis[Axis].axisSettings;
		fin=Buffersize+offset;
		for(i=offset;i<fin;i++) 
    7b80:	e6 17       	cp	r30, r22
    7b82:	f7 07       	cpc	r31, r23
    7b84:	d9 f7       	brne	.-10     	; 0x7b7c <GetAxissetting+0x28>
	
	/*Obtengo el apuntador al primer dato, datos secuenciales, pero no son entre Axis*/
    
	Buffersize=sizeof(tAxisSettings);
	
    for(Axis=0;Axis<DOF;Axis++) 
    7b86:	2f 5f       	subi	r18, 0xFF	; 255
    7b88:	3f 4f       	sbci	r19, 0xFF	; 255
    7b8a:	4c 5b       	subi	r20, 0xBC	; 188
    7b8c:	5f 4f       	sbci	r21, 0xFF	; 255
    7b8e:	25 30       	cpi	r18, 0x05	; 5
    7b90:	31 05       	cpc	r19, r1
    7b92:	19 f7       	brne	.-58     	; 0x7b5a <GetAxissetting+0x6>
		fin=Buffersize+offset;
		for(i=offset;i<fin;i++) 
			TXAxissetting[i]=pdata[i-offset];  //desde pdata[0] hasta pdata[buffersize]
	}

}
    7b94:	08 95       	ret

00007b96 <PrintAxissetting>:



void PrintAxissetting(tAxisSettings axisSettings)
{
    7b96:	2f 92       	push	r2
    7b98:	3f 92       	push	r3
    7b9a:	4f 92       	push	r4
    7b9c:	5f 92       	push	r5
    7b9e:	6f 92       	push	r6
    7ba0:	7f 92       	push	r7
    7ba2:	8f 92       	push	r8
    7ba4:	9f 92       	push	r9
    7ba6:	af 92       	push	r10
    7ba8:	bf 92       	push	r11
    7baa:	cf 92       	push	r12
    7bac:	df 92       	push	r13
    7bae:	ef 92       	push	r14
    7bb0:	ff 92       	push	r15
    7bb2:	0f 93       	push	r16
    7bb4:	1f 93       	push	r17
    7bb6:	df 93       	push	r29
    7bb8:	cf 93       	push	r28
    7bba:	cd b7       	in	r28, 0x3d	; 61
    7bbc:	de b7       	in	r29, 0x3e	; 62
    7bbe:	ae 97       	sbiw	r28, 0x2e	; 46
    7bc0:	0f b6       	in	r0, 0x3f	; 63
    7bc2:	f8 94       	cli
    7bc4:	de bf       	out	0x3e, r29	; 62
    7bc6:	0f be       	out	0x3f, r0	; 63
    7bc8:	cd bf       	out	0x3d, r28	; 61
    7bca:	2d 96       	adiw	r28, 0x0d	; 13
    7bcc:	ce ac       	ldd	r12, Y+62	; 0x3e
    7bce:	df ac       	ldd	r13, Y+63	; 0x3f
    7bd0:	2d 97       	sbiw	r28, 0x0d	; 13
    7bd2:	24 96       	adiw	r28, 0x04	; 4
    7bd4:	0f ad       	ldd	r16, Y+63	; 0x3f
    7bd6:	24 97       	sbiw	r28, 0x04	; 4
    7bd8:	25 96       	adiw	r28, 0x05	; 5
    7bda:	ef ac       	ldd	r14, Y+63	; 0x3f
    7bdc:	25 97       	sbiw	r28, 0x05	; 5
    7bde:	27 96       	adiw	r28, 0x07	; 7
    7be0:	6e ac       	ldd	r6, Y+62	; 0x3e
    7be2:	7f ac       	ldd	r7, Y+63	; 0x3f
    7be4:	27 97       	sbiw	r28, 0x07	; 7
    7be6:	29 96       	adiw	r28, 0x09	; 9
    7be8:	8e ad       	ldd	r24, Y+62	; 0x3e
    7bea:	9f ad       	ldd	r25, Y+63	; 0x3f
    7bec:	29 97       	sbiw	r28, 0x09	; 9
    7bee:	9e a7       	std	Y+46, r25	; 0x2e
    7bf0:	8d a7       	std	Y+45, r24	; 0x2d
    7bf2:	2f 96       	adiw	r28, 0x0f	; 15
    7bf4:	ae ad       	ldd	r26, Y+62	; 0x3e
    7bf6:	bf ad       	ldd	r27, Y+63	; 0x3f
    7bf8:	2f 97       	sbiw	r28, 0x0f	; 15
    7bfa:	bc a7       	std	Y+44, r27	; 0x2c
    7bfc:	ab a7       	std	Y+43, r26	; 0x2b
    7bfe:	61 96       	adiw	r28, 0x11	; 17
    7c00:	ee ad       	ldd	r30, Y+62	; 0x3e
    7c02:	ff ad       	ldd	r31, Y+63	; 0x3f
    7c04:	61 97       	sbiw	r28, 0x11	; 17
    7c06:	fa a7       	std	Y+42, r31	; 0x2a
    7c08:	e9 a7       	std	Y+41, r30	; 0x29
    7c0a:	63 96       	adiw	r28, 0x13	; 19
    7c0c:	8e ad       	ldd	r24, Y+62	; 0x3e
    7c0e:	9f ad       	ldd	r25, Y+63	; 0x3f
    7c10:	63 97       	sbiw	r28, 0x13	; 19
    7c12:	98 a7       	std	Y+40, r25	; 0x28
    7c14:	8f a3       	std	Y+39, r24	; 0x27
    7c16:	65 96       	adiw	r28, 0x15	; 21
    7c18:	ae ad       	ldd	r26, Y+62	; 0x3e
    7c1a:	bf ad       	ldd	r27, Y+63	; 0x3f
    7c1c:	65 97       	sbiw	r28, 0x15	; 21
    7c1e:	be a3       	std	Y+38, r27	; 0x26
    7c20:	ad a3       	std	Y+37, r26	; 0x25
    7c22:	67 96       	adiw	r28, 0x17	; 23
    7c24:	ee ad       	ldd	r30, Y+62	; 0x3e
    7c26:	ff ad       	ldd	r31, Y+63	; 0x3f
    7c28:	67 97       	sbiw	r28, 0x17	; 23
    7c2a:	fc a3       	std	Y+36, r31	; 0x24
    7c2c:	eb a3       	std	Y+35, r30	; 0x23
    7c2e:	69 96       	adiw	r28, 0x19	; 25
    7c30:	8e ad       	ldd	r24, Y+62	; 0x3e
    7c32:	9f ad       	ldd	r25, Y+63	; 0x3f
    7c34:	69 97       	sbiw	r28, 0x19	; 25
    7c36:	9a a3       	std	Y+34, r25	; 0x22
    7c38:	89 a3       	std	Y+33, r24	; 0x21
    7c3a:	6b 96       	adiw	r28, 0x1b	; 27
    7c3c:	ae ad       	ldd	r26, Y+62	; 0x3e
    7c3e:	bf ad       	ldd	r27, Y+63	; 0x3f
    7c40:	6b 97       	sbiw	r28, 0x1b	; 27
    7c42:	b8 a3       	std	Y+32, r27	; 0x20
    7c44:	af 8f       	std	Y+31, r26	; 0x1f
    7c46:	6d 96       	adiw	r28, 0x1d	; 29
    7c48:	ee ad       	ldd	r30, Y+62	; 0x3e
    7c4a:	ff ad       	ldd	r31, Y+63	; 0x3f
    7c4c:	6d 97       	sbiw	r28, 0x1d	; 29
    7c4e:	fe 8f       	std	Y+30, r31	; 0x1e
    7c50:	ed 8f       	std	Y+29, r30	; 0x1d
    7c52:	6f 96       	adiw	r28, 0x1f	; 31
    7c54:	8e ad       	ldd	r24, Y+62	; 0x3e
    7c56:	9f ad       	ldd	r25, Y+63	; 0x3f
    7c58:	6f 97       	sbiw	r28, 0x1f	; 31
    7c5a:	9c 8f       	std	Y+28, r25	; 0x1c
    7c5c:	8b 8f       	std	Y+27, r24	; 0x1b
    7c5e:	a1 96       	adiw	r28, 0x21	; 33
    7c60:	ae ad       	ldd	r26, Y+62	; 0x3e
    7c62:	bf ad       	ldd	r27, Y+63	; 0x3f
    7c64:	a1 97       	sbiw	r28, 0x21	; 33
    7c66:	ba 8f       	std	Y+26, r27	; 0x1a
    7c68:	a9 8f       	std	Y+25, r26	; 0x19
    7c6a:	a3 96       	adiw	r28, 0x23	; 35
    7c6c:	ee ad       	ldd	r30, Y+62	; 0x3e
    7c6e:	ff ad       	ldd	r31, Y+63	; 0x3f
    7c70:	a3 97       	sbiw	r28, 0x23	; 35
    7c72:	f8 8f       	std	Y+24, r31	; 0x18
    7c74:	ef 8b       	std	Y+23, r30	; 0x17
    7c76:	a7 96       	adiw	r28, 0x27	; 39
    7c78:	8c ac       	ldd	r8, Y+60	; 0x3c
    7c7a:	9d ac       	ldd	r9, Y+61	; 0x3d
    7c7c:	ae ac       	ldd	r10, Y+62	; 0x3e
    7c7e:	bf ac       	ldd	r11, Y+63	; 0x3f
    7c80:	a7 97       	sbiw	r28, 0x27	; 39
    7c82:	ab 96       	adiw	r28, 0x2b	; 43
    7c84:	2c ac       	ldd	r2, Y+60	; 0x3c
    7c86:	3d ac       	ldd	r3, Y+61	; 0x3d
    7c88:	4e ac       	ldd	r4, Y+62	; 0x3e
    7c8a:	5f ac       	ldd	r5, Y+63	; 0x3f
    7c8c:	ab 97       	sbiw	r28, 0x2b	; 43
    7c8e:	af 96       	adiw	r28, 0x2f	; 47
    7c90:	8c ad       	ldd	r24, Y+60	; 0x3c
    7c92:	9d ad       	ldd	r25, Y+61	; 0x3d
    7c94:	ae ad       	ldd	r26, Y+62	; 0x3e
    7c96:	bf ad       	ldd	r27, Y+63	; 0x3f
    7c98:	af 97       	sbiw	r28, 0x2f	; 47
    7c9a:	8b 8b       	std	Y+19, r24	; 0x13
    7c9c:	9c 8b       	std	Y+20, r25	; 0x14
    7c9e:	ad 8b       	std	Y+21, r26	; 0x15
    7ca0:	be 8b       	std	Y+22, r27	; 0x16
    7ca2:	e3 96       	adiw	r28, 0x33	; 51
    7ca4:	8c ad       	ldd	r24, Y+60	; 0x3c
    7ca6:	9d ad       	ldd	r25, Y+61	; 0x3d
    7ca8:	ae ad       	ldd	r26, Y+62	; 0x3e
    7caa:	bf ad       	ldd	r27, Y+63	; 0x3f
    7cac:	e3 97       	sbiw	r28, 0x33	; 51
    7cae:	8f 87       	std	Y+15, r24	; 0x0f
    7cb0:	98 8b       	std	Y+16, r25	; 0x10
    7cb2:	a9 8b       	std	Y+17, r26	; 0x11
    7cb4:	ba 8b       	std	Y+18, r27	; 0x12
    7cb6:	e7 96       	adiw	r28, 0x37	; 55
    7cb8:	8c ad       	ldd	r24, Y+60	; 0x3c
    7cba:	9d ad       	ldd	r25, Y+61	; 0x3d
    7cbc:	ae ad       	ldd	r26, Y+62	; 0x3e
    7cbe:	bf ad       	ldd	r27, Y+63	; 0x3f
    7cc0:	e7 97       	sbiw	r28, 0x37	; 55
    7cc2:	8b 87       	std	Y+11, r24	; 0x0b
    7cc4:	9c 87       	std	Y+12, r25	; 0x0c
    7cc6:	ad 87       	std	Y+13, r26	; 0x0d
    7cc8:	be 87       	std	Y+14, r27	; 0x0e
    7cca:	eb 96       	adiw	r28, 0x3b	; 59
    7ccc:	8c ad       	ldd	r24, Y+60	; 0x3c
    7cce:	9d ad       	ldd	r25, Y+61	; 0x3d
    7cd0:	ae ad       	ldd	r26, Y+62	; 0x3e
    7cd2:	bf ad       	ldd	r27, Y+63	; 0x3f
    7cd4:	eb 97       	sbiw	r28, 0x3b	; 59
    7cd6:	8f 83       	std	Y+7, r24	; 0x07
    7cd8:	98 87       	std	Y+8, r25	; 0x08
    7cda:	a9 87       	std	Y+9, r26	; 0x09
    7cdc:	ba 87       	std	Y+10, r27	; 0x0a
    7cde:	ef 96       	adiw	r28, 0x3f	; 63
    7ce0:	8c ad       	ldd	r24, Y+60	; 0x3c
    7ce2:	9d ad       	ldd	r25, Y+61	; 0x3d
    7ce4:	ae ad       	ldd	r26, Y+62	; 0x3e
    7ce6:	bf ad       	ldd	r27, Y+63	; 0x3f
    7ce8:	ef 97       	sbiw	r28, 0x3f	; 63
    7cea:	8b 83       	std	Y+3, r24	; 0x03
    7cec:	9c 83       	std	Y+4, r25	; 0x04
    7cee:	ad 83       	std	Y+5, r26	; 0x05
    7cf0:	be 83       	std	Y+6, r27	; 0x06
	int test;
	
		printf("PrintAxissetting=> En  axisSettings.maxAxisAngle= %d \n",axisSettings.maxAxisAngle);
    7cf2:	00 d0       	rcall	.+0      	; 0x7cf4 <PrintAxissetting+0x15e>
    7cf4:	00 d0       	rcall	.+0      	; 0x7cf6 <PrintAxissetting+0x160>
    7cf6:	87 e0       	ldi	r24, 0x07	; 7
    7cf8:	9b e3       	ldi	r25, 0x3B	; 59
    7cfa:	ad b7       	in	r26, 0x3d	; 61
    7cfc:	be b7       	in	r27, 0x3e	; 62
    7cfe:	12 96       	adiw	r26, 0x02	; 2
    7d00:	9c 93       	st	X, r25
    7d02:	8e 93       	st	-X, r24
    7d04:	11 97       	sbiw	r26, 0x01	; 1
    7d06:	2b 96       	adiw	r28, 0x0b	; 11
    7d08:	8e ad       	ldd	r24, Y+62	; 0x3e
    7d0a:	9f ad       	ldd	r25, Y+63	; 0x3f
    7d0c:	2b 97       	sbiw	r28, 0x0b	; 11
    7d0e:	14 96       	adiw	r26, 0x04	; 4
    7d10:	9c 93       	st	X, r25
    7d12:	8e 93       	st	-X, r24
    7d14:	13 97       	sbiw	r26, 0x03	; 3
    7d16:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.minAxisAngle= %d \n",axisSettings.minAxisAngle);
    7d1a:	8e e3       	ldi	r24, 0x3E	; 62
    7d1c:	9b e3       	ldi	r25, 0x3B	; 59
    7d1e:	ed b7       	in	r30, 0x3d	; 61
    7d20:	fe b7       	in	r31, 0x3e	; 62
    7d22:	92 83       	std	Z+2, r25	; 0x02
    7d24:	81 83       	std	Z+1, r24	; 0x01
    7d26:	d4 82       	std	Z+4, r13	; 0x04
    7d28:	c3 82       	std	Z+3, r12	; 0x03
    7d2a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.axisEnabled= %d \n",axisSettings.axisEnabled);
    7d2e:	85 e7       	ldi	r24, 0x75	; 117
    7d30:	9b e3       	ldi	r25, 0x3B	; 59
    7d32:	ad b7       	in	r26, 0x3d	; 61
    7d34:	be b7       	in	r27, 0x3e	; 62
    7d36:	12 96       	adiw	r26, 0x02	; 2
    7d38:	9c 93       	st	X, r25
    7d3a:	8e 93       	st	-X, r24
    7d3c:	11 97       	sbiw	r26, 0x01	; 1
    7d3e:	11 27       	eor	r17, r17
    7d40:	07 fd       	sbrc	r16, 7
    7d42:	10 95       	com	r17
    7d44:	14 96       	adiw	r26, 0x04	; 4
    7d46:	1c 93       	st	X, r17
    7d48:	0e 93       	st	-X, r16
    7d4a:	13 97       	sbiw	r26, 0x03	; 3
    7d4c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.interruptEnable= %d \n",axisSettings.interruptEnable);
    7d50:	8b ea       	ldi	r24, 0xAB	; 171
    7d52:	9b e3       	ldi	r25, 0x3B	; 59
    7d54:	ed b7       	in	r30, 0x3d	; 61
    7d56:	fe b7       	in	r31, 0x3e	; 62
    7d58:	92 83       	std	Z+2, r25	; 0x02
    7d5a:	81 83       	std	Z+1, r24	; 0x01
    7d5c:	ff 24       	eor	r15, r15
    7d5e:	e7 fc       	sbrc	r14, 7
    7d60:	f0 94       	com	r15
    7d62:	f4 82       	std	Z+4, r15	; 0x04
    7d64:	e3 82       	std	Z+3, r14	; 0x03
    7d66:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.switchEnable= %d \n",axisSettings.switchEnable);
    7d6a:	85 ee       	ldi	r24, 0xE5	; 229
    7d6c:	9b e3       	ldi	r25, 0x3B	; 59
    7d6e:	ad b7       	in	r26, 0x3d	; 61
    7d70:	be b7       	in	r27, 0x3e	; 62
    7d72:	12 96       	adiw	r26, 0x02	; 2
    7d74:	9c 93       	st	X, r25
    7d76:	8e 93       	st	-X, r24
    7d78:	11 97       	sbiw	r26, 0x01	; 1
    7d7a:	14 96       	adiw	r26, 0x04	; 4
    7d7c:	7c 92       	st	X, r7
    7d7e:	6e 92       	st	-X, r6
    7d80:	13 97       	sbiw	r26, 0x03	; 3
    7d82:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.encoderEnable= %d \n",axisSettings.encoderEnable);
    7d86:	8c e1       	ldi	r24, 0x1C	; 28
    7d88:	9c e3       	ldi	r25, 0x3C	; 60
    7d8a:	ed b7       	in	r30, 0x3d	; 61
    7d8c:	fe b7       	in	r31, 0x3e	; 62
    7d8e:	92 83       	std	Z+2, r25	; 0x02
    7d90:	81 83       	std	Z+1, r24	; 0x01
    7d92:	8d a5       	ldd	r24, Y+45	; 0x2d
    7d94:	9e a5       	ldd	r25, Y+46	; 0x2e
    7d96:	94 83       	std	Z+4, r25	; 0x04
    7d98:	83 83       	std	Z+3, r24	; 0x03
    7d9a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.ustepsPerStep= %d \n",axisSettings.ustepsPerStep);
    7d9e:	84 e5       	ldi	r24, 0x54	; 84
    7da0:	9c e3       	ldi	r25, 0x3C	; 60
    7da2:	ad b7       	in	r26, 0x3d	; 61
    7da4:	be b7       	in	r27, 0x3e	; 62
    7da6:	12 96       	adiw	r26, 0x02	; 2
    7da8:	9c 93       	st	X, r25
    7daa:	8e 93       	st	-X, r24
    7dac:	11 97       	sbiw	r26, 0x01	; 1
    7dae:	eb a5       	ldd	r30, Y+43	; 0x2b
    7db0:	fc a5       	ldd	r31, Y+44	; 0x2c
    7db2:	14 96       	adiw	r26, 0x04	; 4
    7db4:	fc 93       	st	X, r31
    7db6:	ee 93       	st	-X, r30
    7db8:	13 97       	sbiw	r26, 0x03	; 3
    7dba:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.motorStepsPerRevolution= %d \n",axisSettings.motorStepsPerRevolution);
    7dbe:	8c e8       	ldi	r24, 0x8C	; 140
    7dc0:	9c e3       	ldi	r25, 0x3C	; 60
    7dc2:	ad b7       	in	r26, 0x3d	; 61
    7dc4:	be b7       	in	r27, 0x3e	; 62
    7dc6:	12 96       	adiw	r26, 0x02	; 2
    7dc8:	9c 93       	st	X, r25
    7dca:	8e 93       	st	-X, r24
    7dcc:	11 97       	sbiw	r26, 0x01	; 1
    7dce:	e9 a5       	ldd	r30, Y+41	; 0x29
    7dd0:	fa a5       	ldd	r31, Y+42	; 0x2a
    7dd2:	14 96       	adiw	r26, 0x04	; 4
    7dd4:	fc 93       	st	X, r31
    7dd6:	ee 93       	st	-X, r30
    7dd8:	13 97       	sbiw	r26, 0x03	; 3
    7dda:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.encoderStepsPerRevolution= %d \n",axisSettings.encoderStepsPerRevolution);
    7dde:	8e ec       	ldi	r24, 0xCE	; 206
    7de0:	9c e3       	ldi	r25, 0x3C	; 60
    7de2:	ad b7       	in	r26, 0x3d	; 61
    7de4:	be b7       	in	r27, 0x3e	; 62
    7de6:	12 96       	adiw	r26, 0x02	; 2
    7de8:	9c 93       	st	X, r25
    7dea:	8e 93       	st	-X, r24
    7dec:	11 97       	sbiw	r26, 0x01	; 1
    7dee:	ef a1       	ldd	r30, Y+39	; 0x27
    7df0:	f8 a5       	ldd	r31, Y+40	; 0x28
    7df2:	14 96       	adiw	r26, 0x04	; 4
    7df4:	fc 93       	st	X, r31
    7df6:	ee 93       	st	-X, r30
    7df8:	13 97       	sbiw	r26, 0x03	; 3
    7dfa:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.TrackingWindow= %d \n",axisSettings.TrackingWindow);
    7dfe:	82 e1       	ldi	r24, 0x12	; 18
    7e00:	9d e3       	ldi	r25, 0x3D	; 61
    7e02:	ad b7       	in	r26, 0x3d	; 61
    7e04:	be b7       	in	r27, 0x3e	; 62
    7e06:	12 96       	adiw	r26, 0x02	; 2
    7e08:	9c 93       	st	X, r25
    7e0a:	8e 93       	st	-X, r24
    7e0c:	11 97       	sbiw	r26, 0x01	; 1
    7e0e:	ed a1       	ldd	r30, Y+37	; 0x25
    7e10:	fe a1       	ldd	r31, Y+38	; 0x26
    7e12:	14 96       	adiw	r26, 0x04	; 4
    7e14:	fc 93       	st	X, r31
    7e16:	ee 93       	st	-X, r30
    7e18:	13 97       	sbiw	r26, 0x03	; 3
    7e1a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.SettleWindow= %d \n",axisSettings.SettleWindow);
    7e1e:	8b e4       	ldi	r24, 0x4B	; 75
    7e20:	9d e3       	ldi	r25, 0x3D	; 61
    7e22:	ad b7       	in	r26, 0x3d	; 61
    7e24:	be b7       	in	r27, 0x3e	; 62
    7e26:	12 96       	adiw	r26, 0x02	; 2
    7e28:	9c 93       	st	X, r25
    7e2a:	8e 93       	st	-X, r24
    7e2c:	11 97       	sbiw	r26, 0x01	; 1
    7e2e:	eb a1       	ldd	r30, Y+35	; 0x23
    7e30:	fc a1       	ldd	r31, Y+36	; 0x24
    7e32:	14 96       	adiw	r26, 0x04	; 4
    7e34:	fc 93       	st	X, r31
    7e36:	ee 93       	st	-X, r30
    7e38:	13 97       	sbiw	r26, 0x03	; 3
    7e3a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.SettleTime= %d \n",axisSettings.SettleTime);
    7e3e:	82 e8       	ldi	r24, 0x82	; 130
    7e40:	9d e3       	ldi	r25, 0x3D	; 61
    7e42:	ad b7       	in	r26, 0x3d	; 61
    7e44:	be b7       	in	r27, 0x3e	; 62
    7e46:	12 96       	adiw	r26, 0x02	; 2
    7e48:	9c 93       	st	X, r25
    7e4a:	8e 93       	st	-X, r24
    7e4c:	11 97       	sbiw	r26, 0x01	; 1
    7e4e:	e9 a1       	ldd	r30, Y+33	; 0x21
    7e50:	fa a1       	ldd	r31, Y+34	; 0x22
    7e52:	14 96       	adiw	r26, 0x04	; 4
    7e54:	fc 93       	st	X, r31
    7e56:	ee 93       	st	-X, r30
    7e58:	13 97       	sbiw	r26, 0x03	; 3
    7e5a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.motorPower= %d \n",axisSettings.motorPower);
    7e5e:	87 eb       	ldi	r24, 0xB7	; 183
    7e60:	9d e3       	ldi	r25, 0x3D	; 61
    7e62:	ad b7       	in	r26, 0x3d	; 61
    7e64:	be b7       	in	r27, 0x3e	; 62
    7e66:	12 96       	adiw	r26, 0x02	; 2
    7e68:	9c 93       	st	X, r25
    7e6a:	8e 93       	st	-X, r24
    7e6c:	11 97       	sbiw	r26, 0x01	; 1
    7e6e:	ef 8d       	ldd	r30, Y+31	; 0x1f
    7e70:	f8 a1       	ldd	r31, Y+32	; 0x20
    7e72:	14 96       	adiw	r26, 0x04	; 4
    7e74:	fc 93       	st	X, r31
    7e76:	ee 93       	st	-X, r30
    7e78:	13 97       	sbiw	r26, 0x03	; 3
    7e7a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.numberPhases= %d \n",axisSettings.numberPhases);
    7e7e:	8c ee       	ldi	r24, 0xEC	; 236
    7e80:	9d e3       	ldi	r25, 0x3D	; 61
    7e82:	ad b7       	in	r26, 0x3d	; 61
    7e84:	be b7       	in	r27, 0x3e	; 62
    7e86:	12 96       	adiw	r26, 0x02	; 2
    7e88:	9c 93       	st	X, r25
    7e8a:	8e 93       	st	-X, r24
    7e8c:	11 97       	sbiw	r26, 0x01	; 1
    7e8e:	ed 8d       	ldd	r30, Y+29	; 0x1d
    7e90:	fe 8d       	ldd	r31, Y+30	; 0x1e
    7e92:	14 96       	adiw	r26, 0x04	; 4
    7e94:	fc 93       	st	X, r31
    7e96:	ee 93       	st	-X, r30
    7e98:	13 97       	sbiw	r26, 0x03	; 3
    7e9a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.homeSwitchHandling= %d \n",axisSettings.homeSwitchHandling);
    7e9e:	83 e2       	ldi	r24, 0x23	; 35
    7ea0:	9e e3       	ldi	r25, 0x3E	; 62
    7ea2:	ad b7       	in	r26, 0x3d	; 61
    7ea4:	be b7       	in	r27, 0x3e	; 62
    7ea6:	12 96       	adiw	r26, 0x02	; 2
    7ea8:	9c 93       	st	X, r25
    7eaa:	8e 93       	st	-X, r24
    7eac:	11 97       	sbiw	r26, 0x01	; 1
    7eae:	eb 8d       	ldd	r30, Y+27	; 0x1b
    7eb0:	fc 8d       	ldd	r31, Y+28	; 0x1c
    7eb2:	14 96       	adiw	r26, 0x04	; 4
    7eb4:	fc 93       	st	X, r31
    7eb6:	ee 93       	st	-X, r30
    7eb8:	13 97       	sbiw	r26, 0x03	; 3
    7eba:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.gearNominator= %d \n",axisSettings.gearNominator);
    7ebe:	80 e6       	ldi	r24, 0x60	; 96
    7ec0:	9e e3       	ldi	r25, 0x3E	; 62
    7ec2:	ad b7       	in	r26, 0x3d	; 61
    7ec4:	be b7       	in	r27, 0x3e	; 62
    7ec6:	12 96       	adiw	r26, 0x02	; 2
    7ec8:	9c 93       	st	X, r25
    7eca:	8e 93       	st	-X, r24
    7ecc:	11 97       	sbiw	r26, 0x01	; 1
    7ece:	e9 8d       	ldd	r30, Y+25	; 0x19
    7ed0:	fa 8d       	ldd	r31, Y+26	; 0x1a
    7ed2:	14 96       	adiw	r26, 0x04	; 4
    7ed4:	fc 93       	st	X, r31
    7ed6:	ee 93       	st	-X, r30
    7ed8:	13 97       	sbiw	r26, 0x03	; 3
    7eda:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.gearDenominator= %d \n",axisSettings.gearDenominator);
    7ede:	88 e9       	ldi	r24, 0x98	; 152
    7ee0:	9e e3       	ldi	r25, 0x3E	; 62
    7ee2:	ad b7       	in	r26, 0x3d	; 61
    7ee4:	be b7       	in	r27, 0x3e	; 62
    7ee6:	12 96       	adiw	r26, 0x02	; 2
    7ee8:	9c 93       	st	X, r25
    7eea:	8e 93       	st	-X, r24
    7eec:	11 97       	sbiw	r26, 0x01	; 1
    7eee:	ef 89       	ldd	r30, Y+23	; 0x17
    7ef0:	f8 8d       	ldd	r31, Y+24	; 0x18
    7ef2:	14 96       	adiw	r26, 0x04	; 4
    7ef4:	fc 93       	st	X, r31
    7ef6:	ee 93       	st	-X, r30
    7ef8:	13 97       	sbiw	r26, 0x03	; 3
    7efa:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.ErrorLimit= %ld \n",axisSettings.ErrorLimit);
    7efe:	00 d0       	rcall	.+0      	; 0x7f00 <PrintAxissetting+0x36a>
    7f00:	82 ed       	ldi	r24, 0xD2	; 210
    7f02:	9e e3       	ldi	r25, 0x3E	; 62
    7f04:	ad b7       	in	r26, 0x3d	; 61
    7f06:	be b7       	in	r27, 0x3e	; 62
    7f08:	12 96       	adiw	r26, 0x02	; 2
    7f0a:	9c 93       	st	X, r25
    7f0c:	8e 93       	st	-X, r24
    7f0e:	11 97       	sbiw	r26, 0x01	; 1
    7f10:	ed b7       	in	r30, 0x3d	; 61
    7f12:	fe b7       	in	r31, 0x3e	; 62
    7f14:	83 82       	std	Z+3, r8	; 0x03
    7f16:	94 82       	std	Z+4, r9	; 0x04
    7f18:	a5 82       	std	Z+5, r10	; 0x05
    7f1a:	b6 82       	std	Z+6, r11	; 0x06
    7f1c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.limitAcceleration= %ld \n",axisSettings.limitAcceleration);	  
    7f20:	88 e0       	ldi	r24, 0x08	; 8
    7f22:	9f e3       	ldi	r25, 0x3F	; 63
    7f24:	ad b7       	in	r26, 0x3d	; 61
    7f26:	be b7       	in	r27, 0x3e	; 62
    7f28:	12 96       	adiw	r26, 0x02	; 2
    7f2a:	9c 93       	st	X, r25
    7f2c:	8e 93       	st	-X, r24
    7f2e:	11 97       	sbiw	r26, 0x01	; 1
    7f30:	ed b7       	in	r30, 0x3d	; 61
    7f32:	fe b7       	in	r31, 0x3e	; 62
    7f34:	23 82       	std	Z+3, r2	; 0x03
    7f36:	34 82       	std	Z+4, r3	; 0x04
    7f38:	45 82       	std	Z+5, r4	; 0x05
    7f3a:	56 82       	std	Z+6, r5	; 0x06
    7f3c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.limitVelocity= %ld \n",axisSettings.limitVelocity);
    7f40:	85 e4       	ldi	r24, 0x45	; 69
    7f42:	9f e3       	ldi	r25, 0x3F	; 63
    7f44:	ad b7       	in	r26, 0x3d	; 61
    7f46:	be b7       	in	r27, 0x3e	; 62
    7f48:	12 96       	adiw	r26, 0x02	; 2
    7f4a:	9c 93       	st	X, r25
    7f4c:	8e 93       	st	-X, r24
    7f4e:	11 97       	sbiw	r26, 0x01	; 1
    7f50:	8b 89       	ldd	r24, Y+19	; 0x13
    7f52:	9c 89       	ldd	r25, Y+20	; 0x14
    7f54:	ad 89       	ldd	r26, Y+21	; 0x15
    7f56:	be 89       	ldd	r27, Y+22	; 0x16
    7f58:	ed b7       	in	r30, 0x3d	; 61
    7f5a:	fe b7       	in	r31, 0x3e	; 62
    7f5c:	83 83       	std	Z+3, r24	; 0x03
    7f5e:	94 83       	std	Z+4, r25	; 0x04
    7f60:	a5 83       	std	Z+5, r26	; 0x05
    7f62:	b6 83       	std	Z+6, r27	; 0x06
    7f64:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.limitJerk= %ld \n",axisSettings.limitJerk);
    7f68:	8e e7       	ldi	r24, 0x7E	; 126
    7f6a:	9f e3       	ldi	r25, 0x3F	; 63
    7f6c:	ad b7       	in	r26, 0x3d	; 61
    7f6e:	be b7       	in	r27, 0x3e	; 62
    7f70:	12 96       	adiw	r26, 0x02	; 2
    7f72:	9c 93       	st	X, r25
    7f74:	8e 93       	st	-X, r24
    7f76:	11 97       	sbiw	r26, 0x01	; 1
    7f78:	8f 85       	ldd	r24, Y+15	; 0x0f
    7f7a:	98 89       	ldd	r25, Y+16	; 0x10
    7f7c:	a9 89       	ldd	r26, Y+17	; 0x11
    7f7e:	ba 89       	ldd	r27, Y+18	; 0x12
    7f80:	ed b7       	in	r30, 0x3d	; 61
    7f82:	fe b7       	in	r31, 0x3e	; 62
    7f84:	83 83       	std	Z+3, r24	; 0x03
    7f86:	94 83       	std	Z+4, r25	; 0x04
    7f88:	a5 83       	std	Z+5, r26	; 0x05
    7f8a:	b6 83       	std	Z+6, r27	; 0x06
    7f8c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.maxAcceleration= %ld \n",axisSettings.maxAcceleration);	 
    7f90:	83 eb       	ldi	r24, 0xB3	; 179
    7f92:	9f e3       	ldi	r25, 0x3F	; 63
    7f94:	ad b7       	in	r26, 0x3d	; 61
    7f96:	be b7       	in	r27, 0x3e	; 62
    7f98:	12 96       	adiw	r26, 0x02	; 2
    7f9a:	9c 93       	st	X, r25
    7f9c:	8e 93       	st	-X, r24
    7f9e:	11 97       	sbiw	r26, 0x01	; 1
    7fa0:	8b 85       	ldd	r24, Y+11	; 0x0b
    7fa2:	9c 85       	ldd	r25, Y+12	; 0x0c
    7fa4:	ad 85       	ldd	r26, Y+13	; 0x0d
    7fa6:	be 85       	ldd	r27, Y+14	; 0x0e
    7fa8:	ed b7       	in	r30, 0x3d	; 61
    7faa:	fe b7       	in	r31, 0x3e	; 62
    7fac:	83 83       	std	Z+3, r24	; 0x03
    7fae:	94 83       	std	Z+4, r25	; 0x04
    7fb0:	a5 83       	std	Z+5, r26	; 0x05
    7fb2:	b6 83       	std	Z+6, r27	; 0x06
    7fb4:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.maxVelocity= %ld \n",axisSettings.maxVelocity);
    7fb8:	8e ee       	ldi	r24, 0xEE	; 238
    7fba:	9f e3       	ldi	r25, 0x3F	; 63
    7fbc:	ad b7       	in	r26, 0x3d	; 61
    7fbe:	be b7       	in	r27, 0x3e	; 62
    7fc0:	12 96       	adiw	r26, 0x02	; 2
    7fc2:	9c 93       	st	X, r25
    7fc4:	8e 93       	st	-X, r24
    7fc6:	11 97       	sbiw	r26, 0x01	; 1
    7fc8:	8f 81       	ldd	r24, Y+7	; 0x07
    7fca:	98 85       	ldd	r25, Y+8	; 0x08
    7fcc:	a9 85       	ldd	r26, Y+9	; 0x09
    7fce:	ba 85       	ldd	r27, Y+10	; 0x0a
    7fd0:	ed b7       	in	r30, 0x3d	; 61
    7fd2:	fe b7       	in	r31, 0x3e	; 62
    7fd4:	83 83       	std	Z+3, r24	; 0x03
    7fd6:	94 83       	std	Z+4, r25	; 0x04
    7fd8:	a5 83       	std	Z+5, r26	; 0x05
    7fda:	b6 83       	std	Z+6, r27	; 0x06
    7fdc:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("PrintAxissetting=> En  axisSettings.minVelocity= %ld \n",axisSettings.minVelocity);	  
    7fe0:	85 e2       	ldi	r24, 0x25	; 37
    7fe2:	90 e4       	ldi	r25, 0x40	; 64
    7fe4:	ad b7       	in	r26, 0x3d	; 61
    7fe6:	be b7       	in	r27, 0x3e	; 62
    7fe8:	12 96       	adiw	r26, 0x02	; 2
    7fea:	9c 93       	st	X, r25
    7fec:	8e 93       	st	-X, r24
    7fee:	11 97       	sbiw	r26, 0x01	; 1
    7ff0:	8b 81       	ldd	r24, Y+3	; 0x03
    7ff2:	9c 81       	ldd	r25, Y+4	; 0x04
    7ff4:	ad 81       	ldd	r26, Y+5	; 0x05
    7ff6:	be 81       	ldd	r27, Y+6	; 0x06
    7ff8:	ed b7       	in	r30, 0x3d	; 61
    7ffa:	fe b7       	in	r31, 0x3e	; 62
    7ffc:	83 83       	std	Z+3, r24	; 0x03
    7ffe:	94 83       	std	Z+4, r25	; 0x04
    8000:	a5 83       	std	Z+5, r26	; 0x05
    8002:	b6 83       	std	Z+6, r27	; 0x06
    8004:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		scanf("%d",&test);
    8008:	0f 90       	pop	r0
    800a:	0f 90       	pop	r0
    800c:	8c e5       	ldi	r24, 0x5C	; 92
    800e:	90 e4       	ldi	r25, 0x40	; 64
    8010:	ad b7       	in	r26, 0x3d	; 61
    8012:	be b7       	in	r27, 0x3e	; 62
    8014:	12 96       	adiw	r26, 0x02	; 2
    8016:	9c 93       	st	X, r25
    8018:	8e 93       	st	-X, r24
    801a:	11 97       	sbiw	r26, 0x01	; 1
    801c:	ce 01       	movw	r24, r28
    801e:	01 96       	adiw	r24, 0x01	; 1
    8020:	14 96       	adiw	r26, 0x04	; 4
    8022:	9c 93       	st	X, r25
    8024:	8e 93       	st	-X, r24
    8026:	13 97       	sbiw	r26, 0x03	; 3
    8028:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
    802c:	0f 90       	pop	r0
    802e:	0f 90       	pop	r0
    8030:	0f 90       	pop	r0
    8032:	0f 90       	pop	r0
	
}
    8034:	ae 96       	adiw	r28, 0x2e	; 46
    8036:	0f b6       	in	r0, 0x3f	; 63
    8038:	f8 94       	cli
    803a:	de bf       	out	0x3e, r29	; 62
    803c:	0f be       	out	0x3f, r0	; 63
    803e:	cd bf       	out	0x3d, r28	; 61
    8040:	cf 91       	pop	r28
    8042:	df 91       	pop	r29
    8044:	1f 91       	pop	r17
    8046:	0f 91       	pop	r16
    8048:	ff 90       	pop	r15
    804a:	ef 90       	pop	r14
    804c:	df 90       	pop	r13
    804e:	cf 90       	pop	r12
    8050:	bf 90       	pop	r11
    8052:	af 90       	pop	r10
    8054:	9f 90       	pop	r9
    8056:	8f 90       	pop	r8
    8058:	7f 90       	pop	r7
    805a:	6f 90       	pop	r6
    805c:	5f 90       	pop	r5
    805e:	4f 90       	pop	r4
    8060:	3f 90       	pop	r3
    8062:	2f 90       	pop	r2
    8064:	08 95       	ret

00008066 <Axissetting2hAxisHandle>:
	PMDSetBreakpoint(&hAxis[Axis],(PMDuint16)breakpointID,(PMDAxis)breakAxis,(PMDuint8)action,(PMDuint8)trigger);

}
/**********************************************************************************************************************/
int Axissetting2hAxisHandle(uint8* rxAxissetting)
{
    8066:	6f 92       	push	r6
    8068:	7f 92       	push	r7
    806a:	8f 92       	push	r8
    806c:	9f 92       	push	r9
    806e:	af 92       	push	r10
    8070:	bf 92       	push	r11
    8072:	cf 92       	push	r12
    8074:	df 92       	push	r13
    8076:	ef 92       	push	r14
    8078:	ff 92       	push	r15
    807a:	0f 93       	push	r16
    807c:	1f 93       	push	r17
    807e:	df 93       	push	r29
    8080:	cf 93       	push	r28
    8082:	cd b7       	in	r28, 0x3d	; 61
    8084:	de b7       	in	r29, 0x3e	; 62
    8086:	c6 55       	subi	r28, 0x56	; 86
    8088:	d1 40       	sbci	r29, 0x01	; 1
    808a:	0f b6       	in	r0, 0x3f	; 63
    808c:	f8 94       	cli
    808e:	de bf       	out	0x3e, r29	; 62
    8090:	0f be       	out	0x3f, r0	; 63
    8092:	cd bf       	out	0x3d, r28	; 61
    8094:	4c 01       	movw	r8, r24
    8096:	00 e0       	ldi	r16, 0x00	; 0
    8098:	10 e0       	ldi	r17, 0x00	; 0
    809a:	aa 24       	eor	r10, r10
    809c:	bb 24       	eor	r11, r11
	#endif	
	for(Axis=0;Axis<DOF;Axis++) 
	{
		/* Leer la configuracion anterior para no reconfigurar lo mismo*/
		//Destino, Fuente.
		eeprom_read_block((void*)&Ram_axisSettings[Axis],(const void*)&EEprom_axisSettings[Axis],sizeof(tAxisSettings));
    809e:	64 e4       	ldi	r22, 0x44	; 68
    80a0:	c6 2e       	mov	r12, r22
    80a2:	d1 2c       	mov	r13, r1
    80a4:	53 e0       	ldi	r21, 0x03	; 3
    80a6:	65 2e       	mov	r6, r21
    80a8:	71 2c       	mov	r7, r1
    80aa:	6c 0e       	add	r6, r28
    80ac:	7d 1e       	adc	r7, r29
    80ae:	0c 9d       	mul	r16, r12
    80b0:	b0 01       	movw	r22, r0
    80b2:	0d 9d       	mul	r16, r13
    80b4:	70 0d       	add	r23, r0
    80b6:	1c 9d       	mul	r17, r12
    80b8:	70 0d       	add	r23, r0
    80ba:	11 24       	eor	r1, r1
    80bc:	73 01       	movw	r14, r6
    80be:	e6 0e       	add	r14, r22
    80c0:	f7 1e       	adc	r15, r23
    80c2:	6e 5f       	subi	r22, 0xFE	; 254
    80c4:	7f 4f       	sbci	r23, 0xFF	; 255
    80c6:	c7 01       	movw	r24, r14
    80c8:	44 e4       	ldi	r20, 0x44	; 68
    80ca:	50 e0       	ldi	r21, 0x00	; 0
    80cc:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
		pdataEEprom=(uint8*)&Ram_axisSettings[Axis];
    80d0:	20 e0       	ldi	r18, 0x00	; 0
    80d2:	30 e0       	ldi	r19, 0x00	; 0
    80d4:	1b c0       	rjmp	.+54     	; 0x810c <Axissetting2hAxisHandle+0xa6>
		//Comparo las configuraciones por eje
		for(i=0;i<sizeof(tAxisSettings);i++) 
		{
			//Utilizo el apuntador a bytes!
                        /*(sizeof(tAxisSettings)*Axis) significa la posicion inicial de cada eje*/
			if(pdataEEprom[i]!=rxAxissetting[(sizeof(tAxisSettings)*Axis)+i])
    80d6:	d7 01       	movw	r26, r14
    80d8:	a2 0f       	add	r26, r18
    80da:	b3 1f       	adc	r27, r19
    80dc:	0c 9d       	mul	r16, r12
    80de:	f0 01       	movw	r30, r0
    80e0:	0d 9d       	mul	r16, r13
    80e2:	f0 0d       	add	r31, r0
    80e4:	1c 9d       	mul	r17, r12
    80e6:	f0 0d       	add	r31, r0
    80e8:	11 24       	eor	r1, r1
    80ea:	e2 0f       	add	r30, r18
    80ec:	f3 1f       	adc	r31, r19
    80ee:	e8 0d       	add	r30, r8
    80f0:	f9 1d       	adc	r31, r9
    80f2:	9c 91       	ld	r25, X
    80f4:	80 81       	ld	r24, Z
    80f6:	98 17       	cp	r25, r24
    80f8:	39 f0       	breq	.+14     	; 0x8108 <Axissetting2hAxisHandle+0xa2>
    80fa:	24 e4       	ldi	r18, 0x44	; 68
    80fc:	30 e0       	ldi	r19, 0x00	; 0
    80fe:	05 e0       	ldi	r16, 0x05	; 5
    8100:	10 e0       	ldi	r17, 0x00	; 0
    8102:	41 e0       	ldi	r20, 0x01	; 1
    8104:	a4 2e       	mov	r10, r20
    8106:	b1 2c       	mov	r11, r1
		
		PrintAxissetting(Ram_axisSettings[Axis]);
		#endif
		
		//Comparo las configuraciones por eje
		for(i=0;i<sizeof(tAxisSettings);i++) 
    8108:	2f 5f       	subi	r18, 0xFF	; 255
    810a:	3f 4f       	sbci	r19, 0xFF	; 255
    810c:	24 34       	cpi	r18, 0x44	; 68
    810e:	31 05       	cpc	r19, r1
    8110:	10 f3       	brcs	.-60     	; 0x80d6 <Axissetting2hAxisHandle+0x70>
	Diferentes=0;
	
	#ifdef DEBUGSETUP
	printf("CopiartohAxissetting=> Iniciando la Comparacion\n");
	#endif	
	for(Axis=0;Axis<DOF;Axis++) 
    8112:	0f 5f       	subi	r16, 0xFF	; 255
    8114:	1f 4f       	sbci	r17, 0xFF	; 255
    8116:	05 30       	cpi	r16, 0x05	; 5
    8118:	11 05       	cpc	r17, r1
    811a:	4c f2       	brlt	.-110    	; 0x80ae <Axissetting2hAxisHandle+0x48>
		
		
	}
	
	
	if(Diferentes==1)
    811c:	81 e0       	ldi	r24, 0x01	; 1
    811e:	a8 16       	cp	r10, r24
    8120:	b1 04       	cpc	r11, r1
    8122:	09 f0       	breq	.+2      	; 0x8126 <Axissetting2hAxisHandle+0xc0>
    8124:	42 c0       	rjmp	.+132    	; 0x81aa <Axissetting2hAxisHandle+0x144>
	{
		//Activo el indicador de configuracion por EEprom pero primero leo el mismo
		//para ver si esta activado y no sobre escribirlo inecesariamente.
		eeprom_read_block((void*)&Ram_Reconf_Indicator,(const void*)&EEprom_Reconf_Indicator,sizeof(int16));
    8126:	8e 01       	movw	r16, r28
    8128:	0f 5f       	subi	r16, 0xFF	; 255
    812a:	1f 4f       	sbci	r17, 0xFF	; 255
    812c:	c8 01       	movw	r24, r16
    812e:	60 e0       	ldi	r22, 0x00	; 0
    8130:	70 e0       	ldi	r23, 0x00	; 0
    8132:	42 e0       	ldi	r20, 0x02	; 2
    8134:	50 e0       	ldi	r21, 0x00	; 0
    8136:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
		if(!Ram_Reconf_Indicator)
    813a:	89 81       	ldd	r24, Y+1	; 0x01
    813c:	9a 81       	ldd	r25, Y+2	; 0x02
    813e:	89 2b       	or	r24, r25
    8140:	49 f4       	brne	.+18     	; 0x8154 <Axissetting2hAxisHandle+0xee>
		{
			Ram_Reconf_Indicator=1;
    8142:	ba 82       	std	Y+2, r11	; 0x02
    8144:	a9 82       	std	Y+1, r10	; 0x01
			//Actualizo a el indicador
			//Fuente,Destino
			eeprom_write_block((const void*)&Ram_Reconf_Indicator,(void*)&EEprom_Reconf_Indicator,sizeof(int16));
    8146:	c8 01       	movw	r24, r16
    8148:	60 e0       	ldi	r22, 0x00	; 0
    814a:	70 e0       	ldi	r23, 0x00	; 0
    814c:	42 e0       	ldi	r20, 0x02	; 2
    814e:	50 e0       	ldi	r21, 0x00	; 0
    8150:	0e 94 b1 a0 	call	0x14162	; 0x14162 <__eewr_block_m1280>
    8154:	ee 24       	eor	r14, r14
    8156:	ff 24       	eor	r15, r15
    8158:	cc 24       	eor	r12, r12
    815a:	dd 24       	eor	r13, r13
    815c:	86 01       	movw	r16, r12
    815e:	0e 5f       	subi	r16, 0xFE	; 254
    8160:	1f 4f       	sbci	r17, 0xFF	; 255
			
			#ifdef DEBUGSETUP
			printf("CopiartohAxissetting=> Copiando la informacion en eeprom\n");
			#endif	
			//Copio la configuracion de ejes a la eepron
			eeprom_write_block((const void*)&prxAxissetting[Axis],(void*)&EEprom_axisSettings[Axis],sizeof(tAxisSettings));
    8162:	c4 01       	movw	r24, r8
    8164:	8c 0d       	add	r24, r12
    8166:	9d 1d       	adc	r25, r13
    8168:	b8 01       	movw	r22, r16
    816a:	44 e4       	ldi	r20, 0x44	; 68
    816c:	50 e0       	ldi	r21, 0x00	; 0
    816e:	0e 94 b1 a0 	call	0x14162	; 0x14162 <__eewr_block_m1280>
			
			//Actualizo hAxis[Axis]..axisSettings a la estructura axisSettings en EEprom
			eeprom_read_block((void*)&hAxis[Axis].axisSettings,(const void*)&EEprom_axisSettings[Axis],sizeof(tAxisSettings));
    8172:	c7 01       	movw	r24, r14
    8174:	88 0f       	add	r24, r24
    8176:	99 1f       	adc	r25, r25
    8178:	8e 0d       	add	r24, r14
    817a:	9f 1d       	adc	r25, r15
    817c:	25 e0       	ldi	r18, 0x05	; 5
    817e:	88 0f       	add	r24, r24
    8180:	99 1f       	adc	r25, r25
    8182:	2a 95       	dec	r18
    8184:	e1 f7       	brne	.-8      	; 0x817e <Axissetting2hAxisHandle+0x118>
    8186:	83 5e       	subi	r24, 0xE3	; 227
    8188:	9a 48       	sbci	r25, 0x8A	; 138
    818a:	b8 01       	movw	r22, r16
    818c:	44 e4       	ldi	r20, 0x44	; 68
    818e:	50 e0       	ldi	r21, 0x00	; 0
    8190:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
		Buffersize=sizeof(tAxisSettings);
		#ifdef DEBUGSETUP
		printf("CopiartohAxissetting=> Buffersize= %d\n",Buffersize);
		#endif	
		/*Copio la nueva configuracion a al eeprom y actualizo la configuracion en hAxis[Axis]..axisSetting */
		for(Axis=0;Axis<DOF;Axis++) 
    8194:	08 94       	sec
    8196:	e1 1c       	adc	r14, r1
    8198:	f1 1c       	adc	r15, r1
    819a:	84 e4       	ldi	r24, 0x44	; 68
    819c:	90 e0       	ldi	r25, 0x00	; 0
    819e:	c8 0e       	add	r12, r24
    81a0:	d9 1e       	adc	r13, r25
    81a2:	95 e0       	ldi	r25, 0x05	; 5
    81a4:	e9 16       	cp	r14, r25
    81a6:	f1 04       	cpc	r15, r1
    81a8:	c9 f6       	brne	.-78     	; 0x815c <Axissetting2hAxisHandle+0xf6>
		#endif		
		
	}
	
	return Diferentes;
}
    81aa:	c5 01       	movw	r24, r10
    81ac:	ca 5a       	subi	r28, 0xAA	; 170
    81ae:	de 4f       	sbci	r29, 0xFE	; 254
    81b0:	0f b6       	in	r0, 0x3f	; 63
    81b2:	f8 94       	cli
    81b4:	de bf       	out	0x3e, r29	; 62
    81b6:	0f be       	out	0x3f, r0	; 63
    81b8:	cd bf       	out	0x3d, r28	; 61
    81ba:	cf 91       	pop	r28
    81bc:	df 91       	pop	r29
    81be:	1f 91       	pop	r17
    81c0:	0f 91       	pop	r16
    81c2:	ff 90       	pop	r15
    81c4:	ef 90       	pop	r14
    81c6:	df 90       	pop	r13
    81c8:	cf 90       	pop	r12
    81ca:	bf 90       	pop	r11
    81cc:	af 90       	pop	r10
    81ce:	9f 90       	pop	r9
    81d0:	8f 90       	pop	r8
    81d2:	7f 90       	pop	r7
    81d4:	6f 90       	pop	r6
    81d6:	08 95       	ret

000081d8 <Config_BreakPoint>:
}


/**********************************************************************************************************************/
void  Config_BreakPoint(int16 Axis, int16 breakpointID,int16 breakAxis, int16 action, int16 trigger, PMDint32 breakpointvalue)
{
    81d8:	8f 92       	push	r8
    81da:	9f 92       	push	r9
    81dc:	af 92       	push	r10
    81de:	bf 92       	push	r11
    81e0:	cf 92       	push	r12
    81e2:	df 92       	push	r13
    81e4:	ef 92       	push	r14
    81e6:	ff 92       	push	r15
    81e8:	0f 93       	push	r16
    81ea:	1f 93       	push	r17
    81ec:	16 2f       	mov	r17, r22
    81ee:	97 2e       	mov	r9, r23
    81f0:	5a 01       	movw	r10, r20
    81f2:	82 2e       	mov	r8, r18
    81f4:	a7 01       	movw	r20, r14
    81f6:	96 01       	movw	r18, r12

	PMDSetBreakpointValue(&hAxis[Axis], (PMDuint16)breakpointID, breakpointvalue);
    81f8:	60 e6       	ldi	r22, 0x60	; 96
    81fa:	70 e0       	ldi	r23, 0x00	; 0
    81fc:	86 9f       	mul	r24, r22
    81fe:	70 01       	movw	r14, r0
    8200:	87 9f       	mul	r24, r23
    8202:	f0 0c       	add	r15, r0
    8204:	96 9f       	mul	r25, r22
    8206:	f0 0c       	add	r15, r0
    8208:	11 24       	eor	r1, r1
    820a:	89 e1       	ldi	r24, 0x19	; 25
    820c:	95 e7       	ldi	r25, 0x75	; 117
    820e:	e8 0e       	add	r14, r24
    8210:	f9 1e       	adc	r15, r25
    8212:	c7 01       	movw	r24, r14
    8214:	61 2f       	mov	r22, r17
    8216:	79 2d       	mov	r23, r9
    8218:	0e 94 6e 7e 	call	0xfcdc	; 0xfcdc <PMDSetBreakpointValue>
	
	PMDSetBreakpoint(&hAxis[Axis],(PMDuint16)breakpointID,(PMDAxis)breakAxis,(PMDuint8)action,(PMDuint8)trigger);
    821c:	c7 01       	movw	r24, r14
    821e:	61 2f       	mov	r22, r17
    8220:	79 2d       	mov	r23, r9
    8222:	a5 01       	movw	r20, r10
    8224:	28 2d       	mov	r18, r8
    8226:	0e 94 13 7d 	call	0xfa26	; 0xfa26 <PMDSetBreakpoint>

}
    822a:	1f 91       	pop	r17
    822c:	0f 91       	pop	r16
    822e:	ff 90       	pop	r15
    8230:	ef 90       	pop	r14
    8232:	df 90       	pop	r13
    8234:	cf 90       	pop	r12
    8236:	bf 90       	pop	r11
    8238:	af 90       	pop	r10
    823a:	9f 90       	pop	r9
    823c:	8f 90       	pop	r8
    823e:	08 95       	ret

00008240 <cargar_encoder>:
/**********************************************************************************************************************/
void cargar_encoder(int16 axis, PMDint32 posicion)
{


	PMDSetActualPosition(&hAxis[axis],posicion);
    8240:	20 e6       	ldi	r18, 0x60	; 96
    8242:	30 e0       	ldi	r19, 0x00	; 0
    8244:	fc 01       	movw	r30, r24
    8246:	e2 9f       	mul	r30, r18
    8248:	c0 01       	movw	r24, r0
    824a:	e3 9f       	mul	r30, r19
    824c:	90 0d       	add	r25, r0
    824e:	f2 9f       	mul	r31, r18
    8250:	90 0d       	add	r25, r0
    8252:	11 24       	eor	r1, r1
    8254:	87 5e       	subi	r24, 0xE7	; 231
    8256:	9a 48       	sbci	r25, 0x8A	; 138
    8258:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>

}
    825c:	08 95       	ret

0000825e <ajustar_posicion>:
/**********************************************************************************************************************/
void ajustar_posicion(int16 axis, PMDint32 posicion)
{


	PMDAdjustActualPosition(&hAxis[axis],posicion);
    825e:	20 e6       	ldi	r18, 0x60	; 96
    8260:	30 e0       	ldi	r19, 0x00	; 0
    8262:	fc 01       	movw	r30, r24
    8264:	e2 9f       	mul	r30, r18
    8266:	c0 01       	movw	r24, r0
    8268:	e3 9f       	mul	r30, r19
    826a:	90 0d       	add	r25, r0
    826c:	f2 9f       	mul	r31, r18
    826e:	90 0d       	add	r25, r0
    8270:	11 24       	eor	r1, r1
    8272:	87 5e       	subi	r24, 0xE7	; 231
    8274:	9a 48       	sbci	r25, 0x8A	; 138
    8276:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>

}
    827a:	08 95       	ret

0000827c <Clear_Position_Error>:
	}	
}

/**********************************************************************************************************************/
void Clear_Position_Error(void)
{
    827c:	0f 93       	push	r16
    827e:	1f 93       	push	r17
    8280:	cf 93       	push	r28
    8282:	df 93       	push	r29
    8284:	09 e1       	ldi	r16, 0x19	; 25
    8286:	15 e7       	ldi	r17, 0x75	; 117
    8288:	e8 01       	movw	r28, r16
	int16 axis;
	
	for(axis=0; axis < DOF; axis++) 
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE))
    828a:	8c 81       	ldd	r24, Y+4	; 0x04
    828c:	81 30       	cpi	r24, 0x01	; 1
    828e:	19 f4       	brne	.+6      	; 0x8296 <Clear_Position_Error+0x1a>
			PMDClearPositionError(&hAxis[axis]);
    8290:	ce 01       	movw	r24, r28
    8292:	0e 94 42 7c 	call	0xf884	; 0xf884 <PMDClearPositionError>
    8296:	c0 5a       	subi	r28, 0xA0	; 160
    8298:	df 4f       	sbci	r29, 0xFF	; 255
/**********************************************************************************************************************/
void Clear_Position_Error(void)
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++) 
    829a:	86 e7       	ldi	r24, 0x76	; 118
    829c:	c9 3f       	cpi	r28, 0xF9	; 249
    829e:	d8 07       	cpc	r29, r24
    82a0:	a1 f7       	brne	.-24     	; 0x828a <Clear_Position_Error+0xe>
			PMDClearPositionError(&hAxis[axis]);
	}
	
	for(axis=0; axis < DOF; axis++) 
	{ // for every chipset (all axis with axis number=1), call MultiUpdate once
		if(hAxis[axis].axis == 0) 
    82a2:	f8 01       	movw	r30, r16
    82a4:	82 81       	ldd	r24, Z+2	; 0x02
    82a6:	93 81       	ldd	r25, Z+3	; 0x03
    82a8:	89 2b       	or	r24, r25
    82aa:	29 f4       	brne	.+10     	; 0x82b6 <Clear_Position_Error+0x3a>
		{
			// Stop the robot (all axis in parallel)
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
    82ac:	c8 01       	movw	r24, r16
    82ae:	6f e0       	ldi	r22, 0x0F	; 15
    82b0:	70 e0       	ldi	r23, 0x00	; 0
    82b2:	0e 94 81 7a 	call	0xf502	; 0xf502 <PMDMultiUpdate>
    82b6:	00 5a       	subi	r16, 0xA0	; 160
    82b8:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE))
			PMDClearPositionError(&hAxis[axis]);
	}
	
	for(axis=0; axis < DOF; axis++) 
    82ba:	0c 17       	cp	r16, r28
    82bc:	1d 07       	cpc	r17, r29
    82be:	89 f7       	brne	.-30     	; 0x82a2 <Clear_Position_Error+0x26>
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
		} 
	}

	
}
    82c0:	df 91       	pop	r29
    82c2:	cf 91       	pop	r28
    82c4:	1f 91       	pop	r17
    82c6:	0f 91       	pop	r16
    82c8:	08 95       	ret

000082ca <Reset_Even_Status_Register>:
	return rcOK;
}

/**********************************************************************************************************************/
void Reset_Even_Status_Register(void)
{
    82ca:	cf 93       	push	r28
    82cc:	df 93       	push	r29
    82ce:	c9 e1       	ldi	r28, 0x19	; 25
    82d0:	d5 e7       	ldi	r29, 0x75	; 117
	int16 axis;
	
	for(axis=0; axis < DOF; axis++) 
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE))
    82d2:	8c 81       	ldd	r24, Y+4	; 0x04
    82d4:	81 30       	cpi	r24, 0x01	; 1
    82d6:	29 f4       	brne	.+10     	; 0x82e2 <Reset_Even_Status_Register+0x18>
			PMDResetEventStatus(&hAxis[axis],~PMDEventStatusMask); 
    82d8:	ce 01       	movw	r24, r28
    82da:	60 e0       	ldi	r22, 0x00	; 0
    82dc:	77 eb       	ldi	r23, 0xB7	; 183
    82de:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
    82e2:	c0 5a       	subi	r28, 0xA0	; 160
    82e4:	df 4f       	sbci	r29, 0xFF	; 255
/**********************************************************************************************************************/
void Reset_Even_Status_Register(void)
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++) 
    82e6:	86 e7       	ldi	r24, 0x76	; 118
    82e8:	c9 3f       	cpi	r28, 0xF9	; 249
    82ea:	d8 07       	cpc	r29, r24
    82ec:	91 f7       	brne	.-28     	; 0x82d2 <Reset_Even_Status_Register+0x8>
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE))
			PMDResetEventStatus(&hAxis[axis],~PMDEventStatusMask); 
	}	
}
    82ee:	df 91       	pop	r29
    82f0:	cf 91       	pop	r28
    82f2:	08 95       	ret

000082f4 <PMDsetupChipsets_USB>:
//-PMDSetEncoderSource
//-PMDSetEncoderToStepRatio
//-PMDSetAxisMode
//-PMDSetMotorMode
PMDresult PMDsetupChipsets_USB(PMDProfileMode Profile) 
{
    82f4:	ef 92       	push	r14
    82f6:	ff 92       	push	r15
    82f8:	0f 93       	push	r16
    82fa:	1f 93       	push	r17
    82fc:	cf 93       	push	r28
    82fe:	df 93       	push	r29
    8300:	e8 2e       	mov	r14, r24
    8302:	c9 e1       	ldi	r28, 0x19	; 25
    8304:	d5 e7       	ldi	r29, 0x75	; 117
    8306:	ff 24       	eor	r15, r15
    8308:	1c 2f       	mov	r17, r28
    830a:	0d 2f       	mov	r16, r29
  // look for a handle of every chipset to reset it...look for axis=1
	
	for(axis=0; axis < DOF; axis++)
	{
		//FIja la unidad del registo Actual position a uPasos
		PMDrc = PMDSetActualPositionUnits(&hAxis[axis],PMDSteps);     
    830c:	ce 01       	movw	r24, r28
    830e:	61 e0       	ldi	r22, 0x01	; 1
    8310:	70 e0       	ldi	r23, 0x00	; 0
    8312:	0e 94 69 7a 	call	0xf4d2	; 0xf4d2 <PMDSetActualPositionUnits>
		if(PMDrc != PMD_ERR_OK) 
    8316:	89 2b       	or	r24, r25
    8318:	19 f0       	breq	.+6      	; 0x8320 <PMDsetupChipsets_USB+0x2c>
    831a:	2d e0       	ldi	r18, 0x0D	; 13
    831c:	30 e0       	ldi	r19, 0x00	; 0
    831e:	a7 c0       	rjmp	.+334    	; 0x846e <PMDsetupChipsets_USB+0x17a>
		{
			return rcHardwareFailure;  // PMD didn't answer... comment 
										// out if UC should continue!		
		}		
		
		switch (axis)
    8320:	82 e0       	ldi	r24, 0x02	; 2
    8322:	f8 16       	cp	r15, r24
    8324:	79 f0       	breq	.+30     	; 0x8344 <PMDsetupChipsets_USB+0x50>
    8326:	8f 15       	cp	r24, r15
    8328:	30 f0       	brcs	.+12     	; 0x8336 <PMDsetupChipsets_USB+0x42>
    832a:	ff 20       	and	r15, r15
    832c:	79 f0       	breq	.+30     	; 0x834c <PMDsetupChipsets_USB+0x58>
    832e:	81 e0       	ldi	r24, 0x01	; 1
    8330:	f8 16       	cp	r15, r24
    8332:	71 f4       	brne	.+28     	; 0x8350 <PMDsetupChipsets_USB+0x5c>
    8334:	07 c0       	rjmp	.+14     	; 0x8344 <PMDsetupChipsets_USB+0x50>
    8336:	83 e0       	ldi	r24, 0x03	; 3
    8338:	f8 16       	cp	r15, r24
    833a:	21 f0       	breq	.+8      	; 0x8344 <PMDsetupChipsets_USB+0x50>
    833c:	84 e0       	ldi	r24, 0x04	; 4
    833e:	f8 16       	cp	r15, r24
    8340:	39 f4       	brne	.+14     	; 0x8350 <PMDsetupChipsets_USB+0x5c>
    8342:	04 c0       	rjmp	.+8      	; 0x834c <PMDsetupChipsets_USB+0x58>
						PMDSignalEncoderHomeMask |PMDSignalPositiveLimitMask |
						PMDSignalNegativeLimitMask | PMDSignalMotorOutputInvertMask);
			break;
			
			case (AxisPitch):
				 PMDSetSignalSense(&hAxis[axis],
    8344:	ce 01       	movw	r24, r28
    8346:	68 e3       	ldi	r22, 0x38	; 56
    8348:	70 e1       	ldi	r23, 0x10	; 16
    834a:	06 c0       	rjmp	.+12     	; 0x8358 <PMDsetupChipsets_USB+0x64>
						PMDSignalEncoderHomeMask | PMDSignalPositiveLimitMask |
						PMDSignalNegativeLimitMask |PMDSignalMotorOutputInvertMask);
			break;
			
			case (AxisRoll):
				 PMDSetSignalSense(&hAxis[axis],
    834c:	ce 01       	movw	r24, r28
    834e:	02 c0       	rjmp	.+4      	; 0x8354 <PMDsetupChipsets_USB+0x60>
						PMDSignalPositiveLimitMask |PMDSignalNegativeLimitMask | PMDSignalMotorOutputInvertMask);
			break;
			
			default:
				 PMDSetSignalSense(&hAxis[axis],
    8350:	81 2f       	mov	r24, r17
    8352:	90 2f       	mov	r25, r16
    8354:	60 e3       	ldi	r22, 0x30	; 48
    8356:	70 e1       	ldi	r23, 0x10	; 16
    8358:	0e 94 6f 7a 	call	0xf4de	; 0xf4de <PMDSetSignalSense>
						PMDSignalPositiveLimitMask |PMDSignalNegativeLimitMask | PMDSignalMotorOutputInvertMask);
			break;
			
		}			
		if((hAxis[axis].axisSettings.switchEnable == TRUE) && 
    835c:	8e 81       	ldd	r24, Y+6	; 0x06
    835e:	9f 81       	ldd	r25, Y+7	; 0x07
    8360:	01 97       	sbiw	r24, 0x01	; 1
    8362:	41 f4       	brne	.+16     	; 0x8374 <PMDsetupChipsets_USB+0x80>
    8364:	8c 81       	ldd	r24, Y+4	; 0x04
    8366:	81 30       	cpi	r24, 0x01	; 1
    8368:	29 f4       	brne	.+10     	; 0x8374 <PMDsetupChipsets_USB+0x80>
		(hAxis[axis].axisSettings.axisEnabled==TRUE))
		{
			//Se Habilitan los Switches de Fin de Carrera
			PMDSetLimitSwitchMode(&hAxis[axis],PMDLimitEnabled);
    836a:	81 2f       	mov	r24, r17
    836c:	90 2f       	mov	r25, r16
    836e:	61 e0       	ldi	r22, 0x01	; 1
    8370:	70 e0       	ldi	r23, 0x00	; 0
    8372:	04 c0       	rjmp	.+8      	; 0x837c <PMDsetupChipsets_USB+0x88>
		}
		else
		{
			////Se deshabilitan los Switches de Fin de Carrera
			PMDSetLimitSwitchMode(&hAxis[axis],PMDLimitDisabled);
    8374:	81 2f       	mov	r24, r17
    8376:	90 2f       	mov	r25, r16
    8378:	60 e0       	ldi	r22, 0x00	; 0
    837a:	70 e0       	ldi	r23, 0x00	; 0
    837c:	0e 94 bd 7a 	call	0xf57a	; 0xf57a <PMDSetLimitSwitchMode>
		}
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config switch %d\n",axis);
		#endif
		PMDSetPhaseCounts(&hAxis[axis],(4*hAxis[axis].axisSettings.ustepsPerStep)); 
    8380:	6e 85       	ldd	r22, Y+14	; 0x0e
    8382:	7f 85       	ldd	r23, Y+15	; 0x0f
    8384:	66 0f       	add	r22, r22
    8386:	77 1f       	adc	r23, r23
    8388:	66 0f       	add	r22, r22
    838a:	77 1f       	adc	r23, r23
    838c:	81 2f       	mov	r24, r17
    838e:	90 2f       	mov	r25, r16
    8390:	0e 94 27 7a 	call	0xf44e	; 0xf44e <PMDSetPhaseCounts>
		//configuracion de Encoder
		PMDSetTrackingWindow(&hAxis[axis], hAxis[axis].axisSettings.TrackingWindow);
    8394:	6c 89       	ldd	r22, Y+20	; 0x14
    8396:	7d 89       	ldd	r23, Y+21	; 0x15
    8398:	81 2f       	mov	r24, r17
    839a:	90 2f       	mov	r25, r16
    839c:	0e 94 93 7a 	call	0xf526	; 0xf526 <PMDSetTrackingWindow>
		printf("PMDsetupChipsets_dummy=> hAxis[%d].axisSettings.ustepsPerStep= %d\n",axis,hAxis[axis].axisSettings.ustepsPerStep);
		#endif

		
		//se habilitan las funciones de encoder
		if((hAxis[axis].axisSettings.encoderEnable == TRUE) && 
    83a0:	88 85       	ldd	r24, Y+8	; 0x08
    83a2:	99 85       	ldd	r25, Y+9	; 0x09
    83a4:	01 97       	sbiw	r24, 0x01	; 1
    83a6:	11 f5       	brne	.+68     	; 0x83ec <PMDsetupChipsets_USB+0xf8>
    83a8:	8c 81       	ldd	r24, Y+4	; 0x04
    83aa:	81 30       	cpi	r24, 0x01	; 1
    83ac:	f9 f4       	brne	.+62     	; 0x83ec <PMDsetupChipsets_USB+0xf8>
                   (hAxis[axis].axisSettings.axisEnabled==TRUE))
		{
			PMDSetSettleWindow(&hAxis[axis], hAxis[axis].axisSettings.SettleWindow);
    83ae:	6e 89       	ldd	r22, Y+22	; 0x16
    83b0:	7f 89       	ldd	r23, Y+23	; 0x17
    83b2:	81 2f       	mov	r24, r17
    83b4:	90 2f       	mov	r25, r16
    83b6:	0e 94 99 7a 	call	0xf532	; 0xf532 <PMDSetSettleWindow>
			PMDSetSettleTime(&hAxis[axis], hAxis[axis].axisSettings.SettleTime);
    83ba:	68 8d       	ldd	r22, Y+24	; 0x18
    83bc:	79 8d       	ldd	r23, Y+25	; 0x19
    83be:	81 2f       	mov	r24, r17
    83c0:	90 2f       	mov	r25, r16
    83c2:	0e 94 9f 7a 	call	0xf53e	; 0xf53e <PMDSetSettleTime>
		    PMDSetMotionCompleteMode(&hAxis[axis],PMDMotionCompleteActualPosition); //  automatic correction of errors
    83c6:	81 2f       	mov	r24, r17
    83c8:	90 2f       	mov	r25, r16
    83ca:	61 e0       	ldi	r22, 0x01	; 1
    83cc:	70 e0       	ldi	r23, 0x00	; 0
    83ce:	0e 94 8d 7a 	call	0xf51a	; 0xf51a <PMDSetMotionCompleteMode>
			//PMDSetPositionErrorLimit(&hAxis[axis],(30*hAxis[axis].axisSettings.ustepsPerStep
			//					 *hAxis[axis].axisSettings.motorStepsPerRevolution)/
			//					 hAxis[axis].axisSettings.encoderStepsPerRevolution);
			PMDSetPositionErrorLimit(&hAxis[axis],hAxis[axis].axisSettings.ErrorLimit);
    83d2:	4c a1       	ldd	r20, Y+36	; 0x24
    83d4:	5d a1       	ldd	r21, Y+37	; 0x25
    83d6:	6e a1       	ldd	r22, Y+38	; 0x26
    83d8:	7f a1       	ldd	r23, Y+39	; 0x27
    83da:	81 2f       	mov	r24, r17
    83dc:	90 2f       	mov	r25, r16
    83de:	0e 94 89 7e 	call	0xfd12	; 0xfd12 <PMDSetPositionErrorLimit>
			
			PMDClearPositionError(&hAxis[axis]);
    83e2:	81 2f       	mov	r24, r17
    83e4:	90 2f       	mov	r25, r16
    83e6:	0e 94 42 7c 	call	0xf884	; 0xf884 <PMDClearPositionError>
    83ea:	06 c0       	rjmp	.+12     	; 0x83f8 <PMDsetupChipsets_USB+0x104>
		}	
		else
		{
			PMDSetMotionCompleteMode(&hAxis[axis],PMDMotionCompleteCommandedPosition); // no automatic correction of errors
    83ec:	81 2f       	mov	r24, r17
    83ee:	90 2f       	mov	r25, r16
    83f0:	60 e0       	ldi	r22, 0x00	; 0
    83f2:	70 e0       	ldi	r23, 0x00	; 0
    83f4:	0e 94 8d 7a 	call	0xf51a	; 0xf51a <PMDSetMotionCompleteMode>
		}
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config SetSeetWindows,Settle time, Motion Complete,Pos. Error limit, Pos. error %d\n",axis);
		#endif
		//Fija la potencia del motor o torque
		PMDSetMotorCommand(&hAxis[axis],(hAxis[axis].axisSettings.motorPower*32768)/100);
    83f8:	6a 8d       	ldd	r22, Y+26	; 0x1a
    83fa:	7b 8d       	ldd	r23, Y+27	; 0x1b
    83fc:	88 27       	eor	r24, r24
    83fe:	77 fd       	sbrc	r23, 7
    8400:	80 95       	com	r24
    8402:	98 2f       	mov	r25, r24
    8404:	ef e0       	ldi	r30, 0x0F	; 15
    8406:	66 0f       	add	r22, r22
    8408:	77 1f       	adc	r23, r23
    840a:	88 1f       	adc	r24, r24
    840c:	99 1f       	adc	r25, r25
    840e:	ea 95       	dec	r30
    8410:	d1 f7       	brne	.-12     	; 0x8406 <PMDsetupChipsets_USB+0x112>
    8412:	24 e6       	ldi	r18, 0x64	; 100
    8414:	30 e0       	ldi	r19, 0x00	; 0
    8416:	40 e0       	ldi	r20, 0x00	; 0
    8418:	50 e0       	ldi	r21, 0x00	; 0
    841a:	0e 94 7a 9c 	call	0x138f4	; 0x138f4 <__divmodsi4>
    841e:	81 2f       	mov	r24, r17
    8420:	90 2f       	mov	r25, r16
    8422:	b9 01       	movw	r22, r18
    8424:	0e 94 45 7a 	call	0xf48a	; 0xf48a <PMDSetMotorCommand>
		//Se selecciona un tipo de perfil
		PMDSetProfileMode(&hAxis[axis],Profile);   // data interpretation mode
    8428:	81 2f       	mov	r24, r17
    842a:	90 2f       	mov	r25, r16
    842c:	6e 2d       	mov	r22, r14
    842e:	70 e0       	ldi	r23, 0x00	; 0
    8430:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
		//Detiene el motor cuando se produce un error en el movimiento (Motion Error).
		PMDSetAutoStopMode(&hAxis[axis],PMDAutoStopDisabled); 		
    8434:	81 2f       	mov	r24, r17
    8436:	90 2f       	mov	r25, r16
    8438:	60 e0       	ldi	r22, 0x00	; 0
    843a:	70 e0       	ldi	r23, 0x00	; 0
    843c:	0e 94 ab 7a 	call	0xf556	; 0xf556 <PMDSetAutoStopMode>
		
		PMDResetEventStatus(&hAxis[axis],~PMDEventStatusMask);
    8440:	81 2f       	mov	r24, r17
    8442:	90 2f       	mov	r25, r16
    8444:	60 e0       	ldi	r22, 0x00	; 0
    8446:	77 eb       	ldi	r23, 0xB7	; 183
    8448:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
		PMDClearInterrupt(&hAxis[axis]);
    844c:	81 2f       	mov	r24, r17
    844e:	90 2f       	mov	r25, r16
    8450:	0e 94 27 7c 	call	0xf84e	; 0xf84e <PMDClearInterrupt>
		PMDUpdate(&hAxis[axis]);
    8454:	81 2f       	mov	r24, r17
    8456:	90 2f       	mov	r25, r16
    8458:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
	uint8_t axis;
	PMDuint16 PMDrc;

  // look for a handle of every chipset to reset it...look for axis=1
	
	for(axis=0; axis < DOF; axis++)
    845c:	f3 94       	inc	r15
    845e:	c0 5a       	subi	r28, 0xA0	; 160
    8460:	df 4f       	sbci	r29, 0xFF	; 255
    8462:	85 e0       	ldi	r24, 0x05	; 5
    8464:	f8 16       	cp	r15, r24
    8466:	09 f0       	breq	.+2      	; 0x846a <PMDsetupChipsets_USB+0x176>
    8468:	4f cf       	rjmp	.-354    	; 0x8308 <PMDsetupChipsets_USB+0x14>
    846a:	20 e0       	ldi	r18, 0x00	; 0
    846c:	30 e0       	ldi	r19, 0x00	; 0
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config AxisMode,Motor Mode, Motor power,Auto Stop, Reset Event, Clear INT,Update  %d\n",axis);
		#endif		
	}	
	return rcOK;
}
    846e:	c9 01       	movw	r24, r18
    8470:	df 91       	pop	r29
    8472:	cf 91       	pop	r28
    8474:	1f 91       	pop	r17
    8476:	0f 91       	pop	r16
    8478:	ff 90       	pop	r15
    847a:	ef 90       	pop	r14
    847c:	08 95       	ret

0000847e <PMDChipsetReset>:
	return rcOK;
} 

/*********************************************************************************************/
PMDresult PMDChipsetReset(PMDAxisHandle* handle)  //Queda igual
{
    847e:	0f 93       	push	r16
    8480:	1f 93       	push	r17
    8482:	df 93       	push	r29
    8484:	cf 93       	push	r28
    8486:	00 d0       	rcall	.+0      	; 0x8488 <PMDChipsetReset+0xa>
    8488:	cd b7       	in	r28, 0x3d	; 61
    848a:	de b7       	in	r29, 0x3e	; 62
    848c:	8c 01       	movw	r16, r24
	PMDuint16 result;
	PMDuint16 status;
	 
   // reset the PMD chip set that this axis resides on
	// if more than one chip set is present, all of them should be reset here
	result = PMDReset(handle);
    848e:	0e 94 0c 7c 	call	0xf818	; 0xf818 <PMDReset>
	// with the parallel interface the result code will always be
	// PMD_ERR_CommandError since that bit is set whenever a reset
	// occurs.  If it ISN'T set then there is some other error
	if ( result == PMD_ERR_CommandError)
    8492:	8f 5f       	subi	r24, 0xFF	; 255
    8494:	9f 47       	sbci	r25, 0x7F	; 127
    8496:	99 f4       	brne	.+38     	; 0x84be <PMDChipsetReset+0x40>
	{
		result = PMDGetHostIOError(handle, &status);
    8498:	c8 01       	movw	r24, r16
    849a:	be 01       	movw	r22, r28
    849c:	6f 5f       	subi	r22, 0xFF	; 255
    849e:	7f 4f       	sbci	r23, 0xFF	; 255
    84a0:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
	   if ((result == PMD_ERR_OK) && (status == PMD_ERR_ChipsetReset))			 
    84a4:	89 2b       	or	r24, r25
    84a6:	59 f4       	brne	.+22     	; 0x84be <PMDChipsetReset+0x40>
    84a8:	89 81       	ldd	r24, Y+1	; 0x01
    84aa:	9a 81       	ldd	r25, Y+2	; 0x02
    84ac:	01 97       	sbiw	r24, 0x01	; 1
    84ae:	39 f4       	brne	.+14     	; 0x84be <PMDChipsetReset+0x40>
		{
			printf("PMDChipsetReset => PMDreset ejecutado correctamente\n\n");
    84b0:	8f e5       	ldi	r24, 0x5F	; 95
    84b2:	90 e4       	ldi	r25, 0x40	; 64
    84b4:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
    84b8:	20 e0       	ldi	r18, 0x00	; 0
    84ba:	30 e0       	ldi	r19, 0x00	; 0
    84bc:	06 c0       	rjmp	.+12     	; 0x84ca <PMDChipsetReset+0x4c>
			return rcOK;
		}
	}		 
	printf("PMDChipsetReset => PMDreset ejecutado INCORECTAMENTE!\n\n");
    84be:	84 e9       	ldi	r24, 0x94	; 148
    84c0:	90 e4       	ldi	r25, 0x40	; 64
    84c2:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
    84c6:	2e e0       	ldi	r18, 0x0E	; 14
    84c8:	30 e0       	ldi	r19, 0x00	; 0
  	return rcPMDChipsetResetError; //al main principal USAMOS rc........
} // PMDChipsetReset	
    84ca:	c9 01       	movw	r24, r18
    84cc:	0f 90       	pop	r0
    84ce:	0f 90       	pop	r0
    84d0:	cf 91       	pop	r28
    84d2:	df 91       	pop	r29
    84d4:	1f 91       	pop	r17
    84d6:	0f 91       	pop	r16
    84d8:	08 95       	ret

000084da <PMDsetupChipSets>:
	return rc;

}
/*********************************************************************************************/
PMDresult PMDsetupChipSets(PMDProfileMode Profile) 
{
    84da:	ef 92       	push	r14
    84dc:	ff 92       	push	r15
    84de:	0f 93       	push	r16
    84e0:	1f 93       	push	r17
    84e2:	cf 93       	push	r28
    84e4:	df 93       	push	r29
    84e6:	e8 2e       	mov	r14, r24
    84e8:	c9 e1       	ldi	r28, 0x19	; 25
    84ea:	d5 e7       	ldi	r29, 0x75	; 117
	PMDuint16 PMDrc,EncodertoStepRatio;

  // look for a handle of every chipset to reset it...look for axis=1
  for(axis=0; axis < DOF; axis++)
	{
		if(hAxis[axis].axis == 0)  
    84ec:	8a 81       	ldd	r24, Y+2	; 0x02
    84ee:	9b 81       	ldd	r25, Y+3	; 0x03
    84f0:	89 2b       	or	r24, r25
    84f2:	41 f4       	brne	.+16     	; 0x8504 <PMDsetupChipSets+0x2a>
		{
			PMDChipsetReset(&hAxis[axis]);	
    84f4:	ce 01       	movw	r24, r28
    84f6:	0e 94 3f 42 	call	0x847e	; 0x847e <PMDChipsetReset>
			/* "calibrate" the velocity and acceleration settings: adjust the sampling time (cycle time)
			minimum 4axis*154us/axis, max. value 65536us */
			PMDSetSampleTime(&hAxis[axis],4*150);			
    84fa:	ce 01       	movw	r24, r28
    84fc:	68 e5       	ldi	r22, 0x58	; 88
    84fe:	72 e0       	ldi	r23, 0x02	; 2
    8500:	0e 94 87 7a 	call	0xf50e	; 0xf50e <PMDSetSampleTime>
    8504:	c0 5a       	subi	r28, 0xA0	; 160
    8506:	df 4f       	sbci	r29, 0xFF	; 255
{
	uint8_t axis;
	PMDuint16 PMDrc,EncodertoStepRatio;

  // look for a handle of every chipset to reset it...look for axis=1
  for(axis=0; axis < DOF; axis++)
    8508:	86 e7       	ldi	r24, 0x76	; 118
    850a:	c9 3f       	cpi	r28, 0xF9	; 249
    850c:	d8 07       	cpc	r29, r24
    850e:	71 f7       	brne	.-36     	; 0x84ec <PMDsetupChipSets+0x12>
    8510:	0d e1       	ldi	r16, 0x1D	; 29
    8512:	15 e7       	ldi	r17, 0x75	; 117
    8514:	ff 24       	eor	r15, r15
    8516:	e8 01       	movw	r28, r16
    8518:	24 97       	sbiw	r28, 0x04	; 4
	
	for(axis=0; axis < DOF; axis++)
	{
		
		//FIja la unidad del registo Actual position a uPasos
		PMDrc = PMDSetActualPositionUnits(&hAxis[axis],PMDSteps);     
    851a:	ce 01       	movw	r24, r28
    851c:	61 e0       	ldi	r22, 0x01	; 1
    851e:	70 e0       	ldi	r23, 0x00	; 0
    8520:	0e 94 69 7a 	call	0xf4d2	; 0xf4d2 <PMDSetActualPositionUnits>
		if(PMDrc != PMD_ERR_OK) 
    8524:	89 2b       	or	r24, r25
    8526:	19 f0       	breq	.+6      	; 0x852e <PMDsetupChipSets+0x54>
    8528:	2d e0       	ldi	r18, 0x0D	; 13
    852a:	30 e0       	ldi	r19, 0x00	; 0
    852c:	db c0       	rjmp	.+438    	; 0x86e4 <PMDsetupChipSets+0x20a>
		{
			return rcHardwareFailure;  // PMD didn't answer... comment 
										// out if UC should continue!		
		}		
		
		switch (axis)
    852e:	e2 e0       	ldi	r30, 0x02	; 2
    8530:	fe 16       	cp	r15, r30
    8532:	79 f0       	breq	.+30     	; 0x8552 <PMDsetupChipSets+0x78>
    8534:	ef 15       	cp	r30, r15
    8536:	30 f0       	brcs	.+12     	; 0x8544 <PMDsetupChipSets+0x6a>
    8538:	ff 20       	and	r15, r15
    853a:	b9 f0       	breq	.+46     	; 0x856a <PMDsetupChipSets+0x90>
    853c:	f1 e0       	ldi	r31, 0x01	; 1
    853e:	ff 16       	cp	r15, r31
    8540:	a1 f4       	brne	.+40     	; 0x856a <PMDsetupChipSets+0x90>
    8542:	07 c0       	rjmp	.+14     	; 0x8552 <PMDsetupChipSets+0x78>
    8544:	83 e0       	ldi	r24, 0x03	; 3
    8546:	f8 16       	cp	r15, r24
    8548:	41 f0       	breq	.+16     	; 0x855a <PMDsetupChipSets+0x80>
    854a:	e4 e0       	ldi	r30, 0x04	; 4
    854c:	fe 16       	cp	r15, r30
    854e:	69 f4       	brne	.+26     	; 0x856a <PMDsetupChipSets+0x90>
    8550:	08 c0       	rjmp	.+16     	; 0x8562 <PMDsetupChipSets+0x88>
						PMDSignalEncoderHomeMask | PMDSignalPositiveLimitMask |
						PMDSignalNegativeLimitMask | PMDSignalMotorOutputInvertMask);
			break;
			
			case (AxisElbow):
				 PMDSetSignalSense(&hAxis[axis],
    8552:	ce 01       	movw	r24, r28
    8554:	68 e3       	ldi	r22, 0x38	; 56
    8556:	70 e1       	ldi	r23, 0x10	; 16
    8558:	0b c0       	rjmp	.+22     	; 0x8570 <PMDsetupChipSets+0x96>
						PMDSignalEncoderHomeMask |PMDSignalPositiveLimitMask |
						PMDSignalNegativeLimitMask | PMDSignalMotorOutputInvertMask);
			break;
			
			case (AxisPitch):
				 PMDSetSignalSense(&hAxis[axis],
    855a:	ce 01       	movw	r24, r28
    855c:	68 e3       	ldi	r22, 0x38	; 56
    855e:	70 e0       	ldi	r23, 0x00	; 0
    8560:	07 c0       	rjmp	.+14     	; 0x8570 <PMDsetupChipSets+0x96>
						PMDSignalEncoderHomeMask |PMDSignalPositiveLimitMask |
						PMDSignalNegativeLimitMask);
			break;
			
			case (AxisRoll):
				 PMDSetSignalSense(&hAxis[axis],
    8562:	ce 01       	movw	r24, r28
    8564:	60 e3       	ldi	r22, 0x30	; 48
    8566:	70 e0       	ldi	r23, 0x00	; 0
    8568:	03 c0       	rjmp	.+6      	; 0x8570 <PMDsetupChipSets+0x96>
						PMDSignalPositiveLimitMask |PMDSignalNegativeLimitMask);
			break;
			
			default:
				 PMDSetSignalSense(&hAxis[axis],
    856a:	ce 01       	movw	r24, r28
    856c:	60 e3       	ldi	r22, 0x30	; 48
    856e:	70 e1       	ldi	r23, 0x10	; 16
    8570:	0e 94 6f 7a 	call	0xf4de	; 0xf4de <PMDSetSignalSense>
			
		}	
		
		
		
		if((hAxis[axis].axisSettings.switchEnable == TRUE) && 
    8574:	f8 01       	movw	r30, r16
    8576:	82 81       	ldd	r24, Z+2	; 0x02
    8578:	93 81       	ldd	r25, Z+3	; 0x03
    857a:	01 97       	sbiw	r24, 0x01	; 1
    857c:	39 f4       	brne	.+14     	; 0x858c <PMDsetupChipSets+0xb2>
    857e:	80 81       	ld	r24, Z
    8580:	81 30       	cpi	r24, 0x01	; 1
    8582:	21 f4       	brne	.+8      	; 0x858c <PMDsetupChipSets+0xb2>
		(hAxis[axis].axisSettings.axisEnabled==TRUE))
		{
			//Se Habilitan los Switches de Fin de Carrera
			PMDSetLimitSwitchMode(&hAxis[axis],PMDLimitEnabled);
    8584:	ce 01       	movw	r24, r28
    8586:	61 e0       	ldi	r22, 0x01	; 1
    8588:	70 e0       	ldi	r23, 0x00	; 0
    858a:	03 c0       	rjmp	.+6      	; 0x8592 <PMDsetupChipSets+0xb8>
		}
		else
		{
			////Se deshabilitan los Switches de Fin de Carrera
			PMDSetLimitSwitchMode(&hAxis[axis],PMDLimitDisabled);
    858c:	ce 01       	movw	r24, r28
    858e:	60 e0       	ldi	r22, 0x00	; 0
    8590:	70 e0       	ldi	r23, 0x00	; 0
    8592:	0e 94 bd 7a 	call	0xf57a	; 0xf57a <PMDSetLimitSwitchMode>
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config switch %d\n",axis);
		#endif

		// Tipo de salida PWM 50/50
		PMDSetOutputMode(&hAxis[axis],PMDMotorOutputPWM5050Magnitude);  
    8596:	ce 01       	movw	r24, r28
    8598:	62 e0       	ldi	r22, 0x02	; 2
    859a:	70 e0       	ldi	r23, 0x00	; 0
    859c:	0e 94 51 7a 	call	0xf4a2	; 0xf4a2 <PMDSetOutputMode>
		//numero de fasese del motor 3
		PMDSetNumberPhases(&hAxis[axis],hAxis[axis].axisSettings.numberPhases);
    85a0:	f8 01       	movw	r30, r16
    85a2:	60 8d       	ldd	r22, Z+24	; 0x18
    85a4:	71 8d       	ldd	r23, Z+25	; 0x19
    85a6:	ce 01       	movw	r24, r28
    85a8:	0e 94 39 7a 	call	0xf472	; 0xf472 <PMDSetNumberPhases>
		//numero de pasos por upaso, esta funcion esta en Counts. 1 Counts = 4 uPasos
		PMDSetPhaseCounts(&hAxis[axis],(4*hAxis[axis].axisSettings.ustepsPerStep)); 
    85ac:	f8 01       	movw	r30, r16
    85ae:	62 85       	ldd	r22, Z+10	; 0x0a
    85b0:	73 85       	ldd	r23, Z+11	; 0x0b
    85b2:	66 0f       	add	r22, r22
    85b4:	77 1f       	adc	r23, r23
    85b6:	66 0f       	add	r22, r22
    85b8:	77 1f       	adc	r23, r23
    85ba:	ce 01       	movw	r24, r28
    85bc:	0e 94 27 7a 	call	0xf44e	; 0xf44e <PMDSetPhaseCounts>
		//configuracion de Encoder
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> uPasos = %d \n",hAxis[axis].axisSettings.ustepsPerStep);
		#endif
		
		PMDSetEncoderSource(&hAxis[axis],PMDEncoderSourceIncremental);  // incremental quadrature encoder
    85c0:	ce 01       	movw	r24, r28
    85c2:	60 e0       	ldi	r22, 0x00	; 0
    85c4:	70 e0       	ldi	r23, 0x00	; 0
    85c6:	0e 94 5d 7a 	call	0xf4ba	; 0xf4ba <PMDSetEncoderSource>
			//(pulses per round), (microsteps per step)*(steps per round)
		
		EncodertoStepRatio=hAxis[axis].axisSettings.ustepsPerStep*
										hAxis[axis].axisSettings.motorStepsPerRevolution;
		
			PMDSetEncoderToStepRatio(&hAxis[axis],hAxis[axis].axisSettings.encoderStepsPerRevolution
    85ca:	f8 01       	movw	r30, r16
    85cc:	66 85       	ldd	r22, Z+14	; 0x0e
    85ce:	77 85       	ldd	r23, Z+15	; 0x0f
    85d0:	24 85       	ldd	r18, Z+12	; 0x0c
    85d2:	35 85       	ldd	r19, Z+13	; 0x0d
    85d4:	82 85       	ldd	r24, Z+10	; 0x0a
    85d6:	93 85       	ldd	r25, Z+11	; 0x0b
    85d8:	28 9f       	mul	r18, r24
    85da:	a0 01       	movw	r20, r0
    85dc:	29 9f       	mul	r18, r25
    85de:	50 0d       	add	r21, r0
    85e0:	38 9f       	mul	r19, r24
    85e2:	50 0d       	add	r21, r0
    85e4:	11 24       	eor	r1, r1
    85e6:	ce 01       	movw	r24, r28
    85e8:	0e 94 0b 7d 	call	0xfa16	; 0xfa16 <PMDSetEncoderToStepRatio>
									,EncodertoStepRatio);
	 	
		PMDSetTrackingWindow(&hAxis[axis], hAxis[axis].axisSettings.TrackingWindow);
    85ec:	f8 01       	movw	r30, r16
    85ee:	60 89       	ldd	r22, Z+16	; 0x10
    85f0:	71 89       	ldd	r23, Z+17	; 0x11
    85f2:	ce 01       	movw	r24, r28
    85f4:	0e 94 93 7a 	call	0xf526	; 0xf526 <PMDSetTrackingWindow>
		printf("PMDsetupChipsets_dummy=> config Outputmode, #Phases, PhaseCounts,Encoder Source, EncoderRatio %d\n",axis);
		#endif

		
		//se habilitan las funciones de encoder
		if((hAxis[axis].axisSettings.encoderEnable == TRUE) && 
    85f8:	f8 01       	movw	r30, r16
    85fa:	84 81       	ldd	r24, Z+4	; 0x04
    85fc:	95 81       	ldd	r25, Z+5	; 0x05
    85fe:	01 97       	sbiw	r24, 0x01	; 1
    8600:	f9 f4       	brne	.+62     	; 0x8640 <PMDsetupChipSets+0x166>
    8602:	80 81       	ld	r24, Z
    8604:	81 30       	cpi	r24, 0x01	; 1
    8606:	e1 f4       	brne	.+56     	; 0x8640 <PMDsetupChipSets+0x166>
			(hAxis[axis].axisSettings.axisEnabled==TRUE))
		{
			PMDSetSettleWindow(&hAxis[axis], hAxis[axis].axisSettings.SettleWindow);
    8608:	62 89       	ldd	r22, Z+18	; 0x12
    860a:	73 89       	ldd	r23, Z+19	; 0x13
    860c:	ce 01       	movw	r24, r28
    860e:	0e 94 99 7a 	call	0xf532	; 0xf532 <PMDSetSettleWindow>
			PMDSetSettleTime(&hAxis[axis], hAxis[axis].axisSettings.SettleTime);
    8612:	f8 01       	movw	r30, r16
    8614:	64 89       	ldd	r22, Z+20	; 0x14
    8616:	75 89       	ldd	r23, Z+21	; 0x15
    8618:	ce 01       	movw	r24, r28
    861a:	0e 94 9f 7a 	call	0xf53e	; 0xf53e <PMDSetSettleTime>
		    PMDSetMotionCompleteMode(&hAxis[axis],PMDMotionCompleteActualPosition); //  automatic correction of errors
    861e:	ce 01       	movw	r24, r28
    8620:	61 e0       	ldi	r22, 0x01	; 1
    8622:	70 e0       	ldi	r23, 0x00	; 0
    8624:	0e 94 8d 7a 	call	0xf51a	; 0xf51a <PMDSetMotionCompleteMode>
			//PMDSetPositionErrorLimit(&hAxis[axis],(30*hAxis[axis].axisSettings.ustepsPerStep
			//					 *hAxis[axis].axisSettings.motorStepsPerRevolution)/
			//					 hAxis[axis].axisSettings.encoderStepsPerRevolution);
			PMDSetPositionErrorLimit(&hAxis[axis],hAxis[axis].axisSettings.ErrorLimit);
    8628:	f8 01       	movw	r30, r16
    862a:	40 a1       	ldd	r20, Z+32	; 0x20
    862c:	51 a1       	ldd	r21, Z+33	; 0x21
    862e:	62 a1       	ldd	r22, Z+34	; 0x22
    8630:	73 a1       	ldd	r23, Z+35	; 0x23
    8632:	ce 01       	movw	r24, r28
    8634:	0e 94 89 7e 	call	0xfd12	; 0xfd12 <PMDSetPositionErrorLimit>
			
			PMDClearPositionError(&hAxis[axis]);
    8638:	ce 01       	movw	r24, r28
    863a:	0e 94 42 7c 	call	0xf884	; 0xf884 <PMDClearPositionError>
    863e:	05 c0       	rjmp	.+10     	; 0x864a <PMDsetupChipSets+0x170>
		}	
		else
		{
			PMDSetMotionCompleteMode(&hAxis[axis],PMDMotionCompleteCommandedPosition); // no automatic correction of errors
    8640:	ce 01       	movw	r24, r28
    8642:	60 e0       	ldi	r22, 0x00	; 0
    8644:	70 e0       	ldi	r23, 0x00	; 0
    8646:	0e 94 8d 7a 	call	0xf51a	; 0xf51a <PMDSetMotionCompleteMode>
			
		}
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config SetSeetWindows,Settle time, Motion Complete,Pos. Error limit, Pos. error %d\n",axis);
		#endif
		if(hAxis[axis].axisSettings.axisEnabled==TRUE) 
    864a:	f8 01       	movw	r30, r16
    864c:	80 81       	ld	r24, Z
    864e:	81 30       	cpi	r24, 0x01	; 1
    8650:	49 f4       	brne	.+18     	; 0x8664 <PMDsetupChipSets+0x18a>
		{
			PMDSetAxisMode(&hAxis[axis],PMDAxisOn);              // enable Axis
    8652:	ce 01       	movw	r24, r28
    8654:	61 e0       	ldi	r22, 0x01	; 1
    8656:	70 e0       	ldi	r23, 0x00	; 0
    8658:	0e 94 73 79 	call	0xf2e6	; 0xf2e6 <PMDSetAxisMode>
			PMDSetMotorMode(&hAxis[axis],PMDMotorOn);            // enable trajectory generator
    865c:	ce 01       	movw	r24, r28
    865e:	61 e0       	ldi	r22, 0x01	; 1
    8660:	70 e0       	ldi	r23, 0x00	; 0
    8662:	08 c0       	rjmp	.+16     	; 0x8674 <PMDsetupChipSets+0x19a>
		} 
		else 
		{
			PMDSetAxisMode(&hAxis[axis],PMDAxisOff);             // disable Axis
    8664:	ce 01       	movw	r24, r28
    8666:	60 e0       	ldi	r22, 0x00	; 0
    8668:	70 e0       	ldi	r23, 0x00	; 0
    866a:	0e 94 73 79 	call	0xf2e6	; 0xf2e6 <PMDSetAxisMode>
			PMDSetMotorMode(&hAxis[axis],PMDMotorOff);           // disable trajectory generator
    866e:	ce 01       	movw	r24, r28
    8670:	60 e0       	ldi	r22, 0x00	; 0
    8672:	70 e0       	ldi	r23, 0x00	; 0
    8674:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
		}
		//Fija la potencia del motor o torque
		PMDSetMotorCommand(&hAxis[axis],(hAxis[axis].axisSettings.motorPower*32768)/100);
    8678:	f8 01       	movw	r30, r16
    867a:	66 89       	ldd	r22, Z+22	; 0x16
    867c:	77 89       	ldd	r23, Z+23	; 0x17
    867e:	88 27       	eor	r24, r24
    8680:	77 fd       	sbrc	r23, 7
    8682:	80 95       	com	r24
    8684:	98 2f       	mov	r25, r24
    8686:	af e0       	ldi	r26, 0x0F	; 15
    8688:	66 0f       	add	r22, r22
    868a:	77 1f       	adc	r23, r23
    868c:	88 1f       	adc	r24, r24
    868e:	99 1f       	adc	r25, r25
    8690:	aa 95       	dec	r26
    8692:	d1 f7       	brne	.-12     	; 0x8688 <PMDsetupChipSets+0x1ae>
    8694:	24 e6       	ldi	r18, 0x64	; 100
    8696:	30 e0       	ldi	r19, 0x00	; 0
    8698:	40 e0       	ldi	r20, 0x00	; 0
    869a:	50 e0       	ldi	r21, 0x00	; 0
    869c:	0e 94 7a 9c 	call	0x138f4	; 0x138f4 <__divmodsi4>
    86a0:	ce 01       	movw	r24, r28
    86a2:	b9 01       	movw	r22, r18
    86a4:	0e 94 45 7a 	call	0xf48a	; 0xf48a <PMDSetMotorCommand>
		//Se selecciona un tipo de perfil
		PMDSetProfileMode(&hAxis[axis],Profile);   // data interpretation mode
    86a8:	ce 01       	movw	r24, r28
    86aa:	6e 2d       	mov	r22, r14
    86ac:	70 e0       	ldi	r23, 0x00	; 0
    86ae:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
		//Detiene el motor cuando se produce un error en el movimiento (Motion Error).
		PMDSetAutoStopMode(&hAxis[axis],PMDAutoStopDisabled); 		
    86b2:	ce 01       	movw	r24, r28
    86b4:	60 e0       	ldi	r22, 0x00	; 0
    86b6:	70 e0       	ldi	r23, 0x00	; 0
    86b8:	0e 94 ab 7a 	call	0xf556	; 0xf556 <PMDSetAutoStopMode>
		
		PMDResetEventStatus(&hAxis[axis],~PMDEventStatusMask);
    86bc:	ce 01       	movw	r24, r28
    86be:	60 e0       	ldi	r22, 0x00	; 0
    86c0:	77 eb       	ldi	r23, 0xB7	; 183
    86c2:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
		PMDClearInterrupt(&hAxis[axis]);
    86c6:	ce 01       	movw	r24, r28
    86c8:	0e 94 27 7c 	call	0xf84e	; 0xf84e <PMDClearInterrupt>
		PMDUpdate(&hAxis[axis]);
    86cc:	ce 01       	movw	r24, r28
    86ce:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			#endif
		}
		
	}	
	
	for(axis=0; axis < DOF; axis++)
    86d2:	f3 94       	inc	r15
    86d4:	00 5a       	subi	r16, 0xA0	; 160
    86d6:	1f 4f       	sbci	r17, 0xFF	; 255
    86d8:	f5 e0       	ldi	r31, 0x05	; 5
    86da:	ff 16       	cp	r15, r31
    86dc:	09 f0       	breq	.+2      	; 0x86e0 <PMDsetupChipSets+0x206>
    86de:	1b cf       	rjmp	.-458    	; 0x8516 <PMDsetupChipSets+0x3c>
    86e0:	20 e0       	ldi	r18, 0x00	; 0
    86e2:	30 e0       	ldi	r19, 0x00	; 0
		#ifdef DEBUGSETUP
		printf("PMDsetupChipsets_dummy=> config AxisMode,Motor Mode, Motor power,Auto Stop, Reset Event, Clear INT,Update  %d\n",axis);
		#endif		
	}	
	return rcOK;
}
    86e4:	c9 01       	movw	r24, r18
    86e6:	df 91       	pop	r29
    86e8:	cf 91       	pop	r28
    86ea:	1f 91       	pop	r17
    86ec:	0f 91       	pop	r16
    86ee:	ff 90       	pop	r15
    86f0:	ef 90       	pop	r14
    86f2:	08 95       	ret

000086f4 <PMDchipsetOK>:
  	return rcPMDChipsetResetError; //al main principal USAMOS rc........
} // PMDChipsetReset	

/*********************************************************************************************/
PMDresult PMDchipsetOK(PMDuint16 PMDChipSet) // Le quite el parametro PMDAxisHandle* hAxis
{
    86f4:	8f 92       	push	r8
    86f6:	9f 92       	push	r9
    86f8:	af 92       	push	r10
    86fa:	bf 92       	push	r11
    86fc:	cf 92       	push	r12
    86fe:	df 92       	push	r13
    8700:	ef 92       	push	r14
    8702:	ff 92       	push	r15
    8704:	0f 93       	push	r16
    8706:	1f 93       	push	r17
    8708:	df 93       	push	r29
    870a:	cf 93       	push	r28
    870c:	00 d0       	rcall	.+0      	; 0x870e <PMDchipsetOK+0x1a>
    870e:	00 d0       	rcall	.+0      	; 0x8710 <PMDchipsetOK+0x1c>
    8710:	cd b7       	in	r28, 0x3d	; 61
    8712:	de b7       	in	r29, 0x3e	; 62
    8714:	6c 01       	movw	r12, r24
   PMDuint32 checksum=0;
    8716:	19 82       	std	Y+1, r1	; 0x01
    8718:	1a 82       	std	Y+2, r1	; 0x02
    871a:	1b 82       	std	Y+3, r1	; 0x03
    871c:	1c 82       	std	Y+4, r1	; 0x04
    871e:	00 e0       	ldi	r16, 0x00	; 0
    8720:	10 e0       	ldi	r17, 0x00	; 0
    8722:	ee 24       	eor	r14, r14
    8724:	ff 24       	eor	r15, r15
	// before reading from the PMD, we must reset the chipsets  
  
	for(axis=0; axis < DOF; axis++) 
	{

      if(hAxis[axis].chipset == PMDChipSet) //Buscamos un AxisHandle para ese chipset
    8726:	90 e6       	ldi	r25, 0x60	; 96
    8728:	89 2e       	mov	r8, r25
    872a:	91 2c       	mov	r9, r1
				return result;
			}
		  else
		   { 
				axistemp=axis;			 
				printf("PMDchipsetOK => Se ha reseteado el chipset %i con Axis %d\n",PMDChipSet,axis);	 
    872c:	8a e0       	ldi	r24, 0x0A	; 10
    872e:	a8 2e       	mov	r10, r24
    8730:	81 e4       	ldi	r24, 0x41	; 65
    8732:	b8 2e       	mov	r11, r24
	// before reading from the PMD, we must reset the chipsets  
  
	for(axis=0; axis < DOF; axis++) 
	{

      if(hAxis[axis].chipset == PMDChipSet) //Buscamos un AxisHandle para ese chipset
    8734:	08 9d       	mul	r16, r8
    8736:	f0 01       	movw	r30, r0
    8738:	09 9d       	mul	r16, r9
    873a:	f0 0d       	add	r31, r0
    873c:	18 9d       	mul	r17, r8
    873e:	f0 0d       	add	r31, r0
    8740:	11 24       	eor	r1, r1
    8742:	e7 5e       	subi	r30, 0xE7	; 231
    8744:	fa 48       	sbci	r31, 0x8A	; 138
    8746:	80 81       	ld	r24, Z
    8748:	91 81       	ldd	r25, Z+1	; 0x01
    874a:	8c 15       	cp	r24, r12
    874c:	9d 05       	cpc	r25, r13
    874e:	e9 f5       	brne	.+122    	; 0x87ca <PMDchipsetOK+0xd6>
	   {  
			result = PMDChipsetReset(&hAxis[axis]);
    8750:	cf 01       	movw	r24, r30
    8752:	0e 94 3f 42 	call	0x847e	; 0x847e <PMDChipsetReset>
    8756:	7c 01       	movw	r14, r24
	      if(result != rcOK)
    8758:	00 97       	sbiw	r24, 0x00	; 0
    875a:	c9 f0       	breq	.+50     	; 0x878e <PMDchipsetOK+0x9a>
			{
				printf("PMDchipsetOK => No se pudo resetear el chipset %i con Axis %d\n",PMDChipSet,axis);
    875c:	00 d0       	rcall	.+0      	; 0x875e <PMDchipsetOK+0x6a>
    875e:	00 d0       	rcall	.+0      	; 0x8760 <PMDchipsetOK+0x6c>
    8760:	00 d0       	rcall	.+0      	; 0x8762 <PMDchipsetOK+0x6e>
    8762:	ed b7       	in	r30, 0x3d	; 61
    8764:	fe b7       	in	r31, 0x3e	; 62
    8766:	31 96       	adiw	r30, 0x01	; 1
    8768:	8b ec       	ldi	r24, 0xCB	; 203
    876a:	90 e4       	ldi	r25, 0x40	; 64
    876c:	ad b7       	in	r26, 0x3d	; 61
    876e:	be b7       	in	r27, 0x3e	; 62
    8770:	12 96       	adiw	r26, 0x02	; 2
    8772:	9c 93       	st	X, r25
    8774:	8e 93       	st	-X, r24
    8776:	11 97       	sbiw	r26, 0x01	; 1
    8778:	d3 82       	std	Z+3, r13	; 0x03
    877a:	c2 82       	std	Z+2, r12	; 0x02
    877c:	15 83       	std	Z+5, r17	; 0x05
    877e:	04 83       	std	Z+4, r16	; 0x04
    8780:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    8784:	2d b7       	in	r18, 0x3d	; 61
    8786:	3e b7       	in	r19, 0x3e	; 62
    8788:	2a 5f       	subi	r18, 0xFA	; 250
    878a:	3f 4f       	sbci	r19, 0xFF	; 255
    878c:	88 c0       	rjmp	.+272    	; 0x889e <PMDchipsetOK+0x1aa>
				return result;
			}
		  else
		   { 
				axistemp=axis;			 
				printf("PMDchipsetOK => Se ha reseteado el chipset %i con Axis %d\n",PMDChipSet,axis);	 
    878e:	00 d0       	rcall	.+0      	; 0x8790 <PMDchipsetOK+0x9c>
    8790:	00 d0       	rcall	.+0      	; 0x8792 <PMDchipsetOK+0x9e>
    8792:	00 d0       	rcall	.+0      	; 0x8794 <PMDchipsetOK+0xa0>
    8794:	ed b7       	in	r30, 0x3d	; 61
    8796:	fe b7       	in	r31, 0x3e	; 62
    8798:	31 96       	adiw	r30, 0x01	; 1
    879a:	ad b7       	in	r26, 0x3d	; 61
    879c:	be b7       	in	r27, 0x3e	; 62
    879e:	12 96       	adiw	r26, 0x02	; 2
    87a0:	bc 92       	st	X, r11
    87a2:	ae 92       	st	-X, r10
    87a4:	11 97       	sbiw	r26, 0x01	; 1
    87a6:	d3 82       	std	Z+3, r13	; 0x03
    87a8:	c2 82       	std	Z+2, r12	; 0x02
    87aa:	15 83       	std	Z+5, r17	; 0x05
    87ac:	04 83       	std	Z+4, r16	; 0x04
    87ae:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    87b2:	78 01       	movw	r14, r16
    87b4:	05 e0       	ldi	r16, 0x05	; 5
    87b6:	10 e0       	ldi	r17, 0x00	; 0
    87b8:	2d b7       	in	r18, 0x3d	; 61
    87ba:	3e b7       	in	r19, 0x3e	; 62
    87bc:	2a 5f       	subi	r18, 0xFA	; 250
    87be:	3f 4f       	sbci	r19, 0xFF	; 255
    87c0:	0f b6       	in	r0, 0x3f	; 63
    87c2:	f8 94       	cli
    87c4:	3e bf       	out	0x3e, r19	; 62
    87c6:	0f be       	out	0x3f, r0	; 63
    87c8:	2d bf       	out	0x3d, r18	; 61
   PMDresult result;
   int16 axis,axistemp=0;  
  
	// before reading from the PMD, we must reset the chipsets  
  
	for(axis=0; axis < DOF; axis++) 
    87ca:	0f 5f       	subi	r16, 0xFF	; 255
    87cc:	1f 4f       	sbci	r17, 0xFF	; 255
    87ce:	05 30       	cpi	r16, 0x05	; 5
    87d0:	11 05       	cpc	r17, r1
    87d2:	0c f4       	brge	.+2      	; 0x87d6 <PMDchipsetOK+0xe2>
    87d4:	af cf       	rjmp	.-162    	; 0x8734 <PMDchipsetOK+0x40>
		   }
      }
	}
  
	// Leer el checksum del Chipset y comparar con 0x12345678
	printf("PMDchipsetOK =>Comprobando Checksum...\n");	
    87d6:	85 e4       	ldi	r24, 0x45	; 69
    87d8:	91 e4       	ldi	r25, 0x41	; 65
    87da:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	result=PMDGetChecksum(&hAxis[axistemp],&checksum); 
    87de:	80 e6       	ldi	r24, 0x60	; 96
    87e0:	90 e0       	ldi	r25, 0x00	; 0
    87e2:	dc 01       	movw	r26, r24
    87e4:	ea 9e       	mul	r14, r26
    87e6:	c0 01       	movw	r24, r0
    87e8:	eb 9e       	mul	r14, r27
    87ea:	90 0d       	add	r25, r0
    87ec:	fa 9e       	mul	r15, r26
    87ee:	90 0d       	add	r25, r0
    87f0:	11 24       	eor	r1, r1
    87f2:	87 5e       	subi	r24, 0xE7	; 231
    87f4:	9a 48       	sbci	r25, 0x8A	; 138
    87f6:	be 01       	movw	r22, r28
    87f8:	6f 5f       	subi	r22, 0xFF	; 255
    87fa:	7f 4f       	sbci	r23, 0xFF	; 255
    87fc:	0e 94 01 7b 	call	0xf602	; 0xf602 <PMDGetChecksum>
	if(checksum != 0x12345678) //Esto esta definido en el manual de programacion .
    8800:	29 81       	ldd	r18, Y+1	; 0x01
    8802:	3a 81       	ldd	r19, Y+2	; 0x02
    8804:	4b 81       	ldd	r20, Y+3	; 0x03
    8806:	5c 81       	ldd	r21, Y+4	; 0x04
    8808:	b6 01       	movw	r22, r12
    880a:	6f 5f       	subi	r22, 0xFF	; 255
    880c:	7f 4f       	sbci	r23, 0xFF	; 255
    880e:	28 37       	cpi	r18, 0x78	; 120
    8810:	b6 e5       	ldi	r27, 0x56	; 86
    8812:	3b 07       	cpc	r19, r27
    8814:	b4 e3       	ldi	r27, 0x34	; 52
    8816:	4b 07       	cpc	r20, r27
    8818:	b2 e1       	ldi	r27, 0x12	; 18
    881a:	5b 07       	cpc	r21, r27
    881c:	f9 f0       	breq	.+62     	; 0x885c <PMDchipsetOK+0x168>
	{
		printf("PMDchipsetOK =>PMD %i PMDchipset checksum test error: 0x12345678=>%lx\n",PMDChipSet+1,checksum);
    881e:	8d b7       	in	r24, 0x3d	; 61
    8820:	9e b7       	in	r25, 0x3e	; 62
    8822:	08 97       	sbiw	r24, 0x08	; 8
    8824:	0f b6       	in	r0, 0x3f	; 63
    8826:	f8 94       	cli
    8828:	9e bf       	out	0x3e, r25	; 62
    882a:	0f be       	out	0x3f, r0	; 63
    882c:	8d bf       	out	0x3d, r24	; 61
    882e:	ed b7       	in	r30, 0x3d	; 61
    8830:	fe b7       	in	r31, 0x3e	; 62
    8832:	31 96       	adiw	r30, 0x01	; 1
    8834:	8c e6       	ldi	r24, 0x6C	; 108
    8836:	91 e4       	ldi	r25, 0x41	; 65
    8838:	ad b7       	in	r26, 0x3d	; 61
    883a:	be b7       	in	r27, 0x3e	; 62
    883c:	12 96       	adiw	r26, 0x02	; 2
    883e:	9c 93       	st	X, r25
    8840:	8e 93       	st	-X, r24
    8842:	11 97       	sbiw	r26, 0x01	; 1
    8844:	73 83       	std	Z+3, r23	; 0x03
    8846:	62 83       	std	Z+2, r22	; 0x02
    8848:	24 83       	std	Z+4, r18	; 0x04
    884a:	35 83       	std	Z+5, r19	; 0x05
    884c:	46 83       	std	Z+6, r20	; 0x06
    884e:	57 83       	std	Z+7, r21	; 0x07
    8850:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    8854:	1f e0       	ldi	r17, 0x0F	; 15
    8856:	e1 2e       	mov	r14, r17
    8858:	f1 2c       	mov	r15, r1
    885a:	1d c0       	rjmp	.+58     	; 0x8896 <PMDchipsetOK+0x1a2>
		return rcPMDchecksumError;  // we got a wrong answer
	}
	printf("PMDchipsetOK =>PMD %i test succeeded %lx \n",PMDChipSet+1,checksum);
    885c:	8d b7       	in	r24, 0x3d	; 61
    885e:	9e b7       	in	r25, 0x3e	; 62
    8860:	08 97       	sbiw	r24, 0x08	; 8
    8862:	0f b6       	in	r0, 0x3f	; 63
    8864:	f8 94       	cli
    8866:	9e bf       	out	0x3e, r25	; 62
    8868:	0f be       	out	0x3f, r0	; 63
    886a:	8d bf       	out	0x3d, r24	; 61
    886c:	ed b7       	in	r30, 0x3d	; 61
    886e:	fe b7       	in	r31, 0x3e	; 62
    8870:	31 96       	adiw	r30, 0x01	; 1
    8872:	83 eb       	ldi	r24, 0xB3	; 179
    8874:	91 e4       	ldi	r25, 0x41	; 65
    8876:	ad b7       	in	r26, 0x3d	; 61
    8878:	be b7       	in	r27, 0x3e	; 62
    887a:	12 96       	adiw	r26, 0x02	; 2
    887c:	9c 93       	st	X, r25
    887e:	8e 93       	st	-X, r24
    8880:	11 97       	sbiw	r26, 0x01	; 1
    8882:	73 83       	std	Z+3, r23	; 0x03
    8884:	62 83       	std	Z+2, r22	; 0x02
    8886:	24 83       	std	Z+4, r18	; 0x04
    8888:	35 83       	std	Z+5, r19	; 0x05
    888a:	46 83       	std	Z+6, r20	; 0x06
    888c:	57 83       	std	Z+7, r21	; 0x07
    888e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    8892:	ee 24       	eor	r14, r14
    8894:	ff 24       	eor	r15, r15
    8896:	2d b7       	in	r18, 0x3d	; 61
    8898:	3e b7       	in	r19, 0x3e	; 62
    889a:	28 5f       	subi	r18, 0xF8	; 248
    889c:	3f 4f       	sbci	r19, 0xFF	; 255
    889e:	0f b6       	in	r0, 0x3f	; 63
    88a0:	f8 94       	cli
    88a2:	3e bf       	out	0x3e, r19	; 62
    88a4:	0f be       	out	0x3f, r0	; 63
    88a6:	2d bf       	out	0x3d, r18	; 61
	return rcOK;
} 
    88a8:	c7 01       	movw	r24, r14
    88aa:	0f 90       	pop	r0
    88ac:	0f 90       	pop	r0
    88ae:	0f 90       	pop	r0
    88b0:	0f 90       	pop	r0
    88b2:	cf 91       	pop	r28
    88b4:	df 91       	pop	r29
    88b6:	1f 91       	pop	r17
    88b8:	0f 91       	pop	r16
    88ba:	ff 90       	pop	r15
    88bc:	ef 90       	pop	r14
    88be:	df 90       	pop	r13
    88c0:	cf 90       	pop	r12
    88c2:	bf 90       	pop	r11
    88c4:	af 90       	pop	r10
    88c6:	9f 90       	pop	r9
    88c8:	8f 90       	pop	r8
    88ca:	08 95       	ret

000088cc <initAxisHandles>:


/******************************DEFINICION DE LAS FUNCIONES***********************************/

PMDresult initAxisHandles(void) 
{
    88cc:	cf 92       	push	r12
    88ce:	df 92       	push	r13
    88d0:	ef 92       	push	r14
    88d2:	ff 92       	push	r15
    88d4:	0f 93       	push	r16
    88d6:	1f 93       	push	r17
    88d8:	df 93       	push	r29
    88da:	cf 93       	push	r28
    88dc:	00 d0       	rcall	.+0      	; 0x88de <initAxisHandles+0x12>
    88de:	cd b7       	in	r28, 0x3d	; 61
    88e0:	de b7       	in	r29, 0x3e	; 62
    88e2:	69 e1       	ldi	r22, 0x19	; 25
    88e4:	e6 2e       	mov	r14, r22
    88e6:	65 e7       	ldi	r22, 0x75	; 117
    88e8:	f6 2e       	mov	r15, r22
    88ea:	cc 24       	eor	r12, r12
    88ec:	dd 24       	eor	r13, r13
	int16 Axis,rc;
	int16 Reconf_Enable;

	for(Axis=0; Axis<DOF; Axis++) 
	{  
		if(hAxis[Axis].transport_data == NULL) //Si no ha sido definida
    88ee:	2e e5       	ldi	r18, 0x5E	; 94
    88f0:	30 e0       	ldi	r19, 0x00	; 0
    88f2:	e2 0e       	add	r14, r18
    88f4:	f3 1e       	adc	r15, r19
    88f6:	f7 01       	movw	r30, r14
    88f8:	80 81       	ld	r24, Z
    88fa:	91 81       	ldd	r25, Z+1	; 0x01
    88fc:	22 ea       	ldi	r18, 0xA2	; 162
    88fe:	3f ef       	ldi	r19, 0xFF	; 255
    8900:	e2 0e       	add	r14, r18
    8902:	f3 1e       	adc	r15, r19
    8904:	89 2b       	or	r24, r25
    8906:	81 f4       	brne	.+32     	; 0x8928 <initAxisHandles+0x5c>
		{		
			rc = PMDSetupAxisInterface_Parallel(&hAxis[Axis], Axis2PMDAxis(Axis), Axis2PMDChipset(Axis));
    8908:	c6 01       	movw	r24, r12
    890a:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    890e:	8c 01       	movw	r16, r24
    8910:	c6 01       	movw	r24, r12
    8912:	0e 94 c8 7e 	call	0xfd90	; 0xfd90 <Axis2PMDChipset>
    8916:	ac 01       	movw	r20, r24
    8918:	c7 01       	movw	r24, r14
    891a:	b8 01       	movw	r22, r16
    891c:	0e 94 c3 7f 	call	0xff86	; 0xff86 <PMDSetupAxisInterface_Parallel>
    8920:	9c 01       	movw	r18, r24
			if(rc != rcOK) 
    8922:	00 97       	sbiw	r24, 0x00	; 0
    8924:	09 f0       	breq	.+2      	; 0x8928 <initAxisHandles+0x5c>
    8926:	4e c0       	rjmp	.+156    	; 0x89c4 <initAxisHandles+0xf8>
PMDresult initAxisHandles(void) 
{
	int16 Axis,rc;
	int16 Reconf_Enable;

	for(Axis=0; Axis<DOF; Axis++) 
    8928:	08 94       	sec
    892a:	c1 1c       	adc	r12, r1
    892c:	d1 1c       	adc	r13, r1
    892e:	80 e6       	ldi	r24, 0x60	; 96
    8930:	90 e0       	ldi	r25, 0x00	; 0
    8932:	e8 0e       	add	r14, r24
    8934:	f9 1e       	adc	r15, r25
    8936:	95 e0       	ldi	r25, 0x05	; 5
    8938:	c9 16       	cp	r12, r25
    893a:	d1 04       	cpc	r13, r1
    893c:	c1 f6       	brne	.-80     	; 0x88ee <initAxisHandles+0x22>
		}
	}	
   
	
	/* Leer el indicado de reconfiguracion*/
	eeprom_read_block((void*)&Reconf_Enable,(const void*)&EEprom_Reconf_Indicator,sizeof(int16));
    893e:	ce 01       	movw	r24, r28
    8940:	01 96       	adiw	r24, 0x01	; 1
    8942:	60 e0       	ldi	r22, 0x00	; 0
    8944:	70 e0       	ldi	r23, 0x00	; 0
    8946:	42 e0       	ldi	r20, 0x02	; 2
    8948:	50 e0       	ldi	r21, 0x00	; 0
    894a:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
    894e:	52 e0       	ldi	r21, 0x02	; 2
    8950:	c5 2e       	mov	r12, r21
    8952:	50 e0       	ldi	r21, 0x00	; 0
    8954:	d5 2e       	mov	r13, r21
    8956:	ee 24       	eor	r14, r14
    8958:	ff 24       	eor	r15, r15
	for(Axis=0; Axis<DOF; Axis++)
	{
		//Configura la structura tAxisSettings
		//limites de velocidad entre ostras cosas definidas en robotdata.c 
		/*Si no he reconfigurado utilizsr por defecto*/
                if(!Reconf_Enable)
    895a:	89 81       	ldd	r24, Y+1	; 0x01
    895c:	9a 81       	ldd	r25, Y+2	; 0x02
    895e:	87 01       	movw	r16, r14
    8960:	00 0f       	add	r16, r16
    8962:	11 1f       	adc	r17, r17
    8964:	89 2b       	or	r24, r25
    8966:	71 f4       	brne	.+28     	; 0x8984 <initAxisHandles+0xb8>
			defaultAxisSettings(Axis,&hAxis[Axis].axisSettings); 		
    8968:	0e 0d       	add	r16, r14
    896a:	1f 1d       	adc	r17, r15
    896c:	35 e0       	ldi	r19, 0x05	; 5
    896e:	00 0f       	add	r16, r16
    8970:	11 1f       	adc	r17, r17
    8972:	3a 95       	dec	r19
    8974:	e1 f7       	brne	.-8      	; 0x896e <initAxisHandles+0xa2>
    8976:	03 5e       	subi	r16, 0xE3	; 227
    8978:	1a 48       	sbci	r17, 0x8A	; 138
    897a:	c7 01       	movw	r24, r14
    897c:	b8 01       	movw	r22, r16
    897e:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <defaultAxisSettings>
    8982:	13 c0       	rjmp	.+38     	; 0x89aa <initAxisHandles+0xde>
		else
		{
			printf("initAxisHandles=> Configurando usando la eeprom\n");
    8984:	8e ed       	ldi	r24, 0xDE	; 222
    8986:	91 e4       	ldi	r25, 0x41	; 65
    8988:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
			//Configuro Usando la eeprom
			//Actualizo rxAxissetting a la estructura PMDAxisHandle hAxis	
			eeprom_read_block((void*)&hAxis[Axis].axisSettings,(const void*)&EEprom_axisSettings[Axis],sizeof(tAxisSettings));
    898c:	0e 0d       	add	r16, r14
    898e:	1f 1d       	adc	r17, r15
    8990:	25 e0       	ldi	r18, 0x05	; 5
    8992:	00 0f       	add	r16, r16
    8994:	11 1f       	adc	r17, r17
    8996:	2a 95       	dec	r18
    8998:	e1 f7       	brne	.-8      	; 0x8992 <initAxisHandles+0xc6>
    899a:	c8 01       	movw	r24, r16
    899c:	83 5e       	subi	r24, 0xE3	; 227
    899e:	9a 48       	sbci	r25, 0x8A	; 138
    89a0:	b6 01       	movw	r22, r12
    89a2:	44 e4       	ldi	r20, 0x44	; 68
    89a4:	50 e0       	ldi	r21, 0x00	; 0
    89a6:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
	
	/* Leer el indicado de reconfiguracion*/
	eeprom_read_block((void*)&Reconf_Enable,(const void*)&EEprom_Reconf_Indicator,sizeof(int16));
	
     
	for(Axis=0; Axis<DOF; Axis++)
    89aa:	08 94       	sec
    89ac:	e1 1c       	adc	r14, r1
    89ae:	f1 1c       	adc	r15, r1
    89b0:	e4 e4       	ldi	r30, 0x44	; 68
    89b2:	f0 e0       	ldi	r31, 0x00	; 0
    89b4:	ce 0e       	add	r12, r30
    89b6:	df 1e       	adc	r13, r31
    89b8:	f5 e0       	ldi	r31, 0x05	; 5
    89ba:	ef 16       	cp	r14, r31
    89bc:	f1 04       	cpc	r15, r1
    89be:	69 f6       	brne	.-102    	; 0x895a <initAxisHandles+0x8e>
    89c0:	20 e0       	ldi	r18, 0x00	; 0
    89c2:	30 e0       	ldi	r19, 0x00	; 0
		}
	}

	
	return rcOK;
} 
    89c4:	c9 01       	movw	r24, r18
    89c6:	0f 90       	pop	r0
    89c8:	0f 90       	pop	r0
    89ca:	cf 91       	pop	r28
    89cc:	df 91       	pop	r29
    89ce:	1f 91       	pop	r17
    89d0:	0f 91       	pop	r16
    89d2:	ff 90       	pop	r15
    89d4:	ef 90       	pop	r14
    89d6:	df 90       	pop	r13
    89d8:	cf 90       	pop	r12
    89da:	08 95       	ret

000089dc <selftestPMD>:
	return rcOK;
} 

/*********************************************************************************************/
PMDresult selftestPMD(void)  //Le quite el parametro PMDAxisHandle* hAxis
{
    89dc:	0f 93       	push	r16
    89de:	1f 93       	push	r17
    89e0:	cf 93       	push	r28
    89e2:	df 93       	push	r29
	int16 rc1= rcOK;                // return code
	int16 rc2 = rcOK; 
	int16 rc;
   
   rc1 = initAxisHandles();        //inicializamos todos los ejes hAxis
    89e4:	0e 94 66 44 	call	0x88cc	; 0x88cc <initAxisHandles>
   if(rc1!=rcOK)
    89e8:	89 2b       	or	r24, r25
    89ea:	59 f0       	breq	.+22     	; 0x8a02 <selftestPMD+0x26>
   { //Enviar Codigo de ERRoR por Leds , por Buzzer y Por Display.
		buzzer(2);
    89ec:	82 e0       	ldi	r24, 0x02	; 2
    89ee:	90 e0       	ldi	r25, 0x00	; 0
    89f0:	0e 94 41 8d 	call	0x11a82	; 0x11a82 <buzzer>
		delay_1s();
    89f4:	0e 94 37 8d 	call	0x11a6e	; 0x11a6e <delay_1s>
		buzzer(1); 
    89f8:	81 e0       	ldi	r24, 0x01	; 1
    89fa:	90 e0       	ldi	r25, 0x00	; 0
    89fc:	0e 94 41 8d 	call	0x11a82	; 0x11a82 <buzzer>
    8a00:	70 c0       	rjmp	.+224    	; 0x8ae2 <selftestPMD+0x106>
	}    
	
	else
	{
		
		printf("selftestPMD => Hard reset\n");	
    8a02:	8e e0       	ldi	r24, 0x0E	; 14
    8a04:	92 e4       	ldi	r25, 0x42	; 66
    8a06:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
		PMDHardReset(&hAxis[0]); 			//hacemos reset por hardware a PMD1 y PMD2
    8a0a:	89 e1       	ldi	r24, 0x19	; 25
    8a0c:	95 e7       	ldi	r25, 0x75	; 117
    8a0e:	0e 94 53 76 	call	0xeca6	; 0xeca6 <PMDHardReset>
		rc1 = PMDchipsetOK(PMDChipSet1); 	//COmprobamos el Checksum despus de reset
    8a12:	80 e0       	ldi	r24, 0x00	; 0
    8a14:	90 e0       	ldi	r25, 0x00	; 0
    8a16:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <PMDchipsetOK>
    8a1a:	8c 01       	movw	r16, r24
		if(rc1 != rcOK)						// Error de Checksum para Chipset 1
    8a1c:	00 97       	sbiw	r24, 0x00	; 0
    8a1e:	49 f1       	breq	.+82     	; 0x8a72 <selftestPMD+0x96>
		{
			Led_on(Amarillo);    
    8a20:	82 e0       	ldi	r24, 0x02	; 2
    8a22:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
			buzzer(1);
    8a26:	81 e0       	ldi	r24, 0x01	; 1
    8a28:	90 e0       	ldi	r25, 0x00	; 0
    8a2a:	0e 94 41 8d 	call	0x11a82	; 0x11a82 <buzzer>
			fprintf_P(stderr,PSTR("Error en Controlador 1 \n"));
    8a2e:	00 d0       	rcall	.+0      	; 0x8a30 <selftestPMD+0x54>
    8a30:	00 d0       	rcall	.+0      	; 0x8a32 <selftestPMD+0x56>
    8a32:	80 91 d2 79 	lds	r24, 0x79D2
    8a36:	90 91 d3 79 	lds	r25, 0x79D3
    8a3a:	ed b7       	in	r30, 0x3d	; 61
    8a3c:	fe b7       	in	r31, 0x3e	; 62
    8a3e:	92 83       	std	Z+2, r25	; 0x02
    8a40:	81 83       	std	Z+1, r24	; 0x01
    8a42:	8f ea       	ldi	r24, 0xAF	; 175
    8a44:	97 e1       	ldi	r25, 0x17	; 23
    8a46:	94 83       	std	Z+4, r25	; 0x04
    8a48:	83 83       	std	Z+3, r24	; 0x03
    8a4a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
			fprintf_P(stdout,PSTR("Error en el Controlador de motores No. 1 \n"));			
    8a4e:	80 91 d0 79 	lds	r24, 0x79D0
    8a52:	90 91 d1 79 	lds	r25, 0x79D1
    8a56:	ed b7       	in	r30, 0x3d	; 61
    8a58:	fe b7       	in	r31, 0x3e	; 62
    8a5a:	92 83       	std	Z+2, r25	; 0x02
    8a5c:	81 83       	std	Z+1, r24	; 0x01
    8a5e:	84 e8       	ldi	r24, 0x84	; 132
    8a60:	97 e1       	ldi	r25, 0x17	; 23
    8a62:	94 83       	std	Z+4, r25	; 0x04
    8a64:	83 83       	std	Z+3, r24	; 0x03
    8a66:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    8a6a:	0f 90       	pop	r0
    8a6c:	0f 90       	pop	r0
    8a6e:	0f 90       	pop	r0
    8a70:	0f 90       	pop	r0
		}
		// Chipset1 OK
		
		rc2 = PMDchipsetOK(PMDChipSet2);//COmprobamos el Checksum despues de reset
    8a72:	81 e0       	ldi	r24, 0x01	; 1
    8a74:	90 e0       	ldi	r25, 0x00	; 0
    8a76:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <PMDchipsetOK>
    8a7a:	ec 01       	movw	r28, r24
		if(rc2 != rcOK)					 // Error de Checksum para Chipset 2
    8a7c:	00 97       	sbiw	r24, 0x00	; 0
    8a7e:	49 f1       	breq	.+82     	; 0x8ad2 <selftestPMD+0xf6>
		{ //Enviar Codigo de ERRoR por Leds , por Buzzer y por Display.y salir del programa
		  
			Led_on(Rojo);    //
    8a80:	81 e0       	ldi	r24, 0x01	; 1
    8a82:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
			buzzer(1);
    8a86:	81 e0       	ldi	r24, 0x01	; 1
    8a88:	90 e0       	ldi	r25, 0x00	; 0
    8a8a:	0e 94 41 8d 	call	0x11a82	; 0x11a82 <buzzer>
			fprintf_P(stderr,PSTR("Error en Controlador 2 \n"));
    8a8e:	00 d0       	rcall	.+0      	; 0x8a90 <selftestPMD+0xb4>
    8a90:	00 d0       	rcall	.+0      	; 0x8a92 <selftestPMD+0xb6>
    8a92:	80 91 d2 79 	lds	r24, 0x79D2
    8a96:	90 91 d3 79 	lds	r25, 0x79D3
    8a9a:	ed b7       	in	r30, 0x3d	; 61
    8a9c:	fe b7       	in	r31, 0x3e	; 62
    8a9e:	92 83       	std	Z+2, r25	; 0x02
    8aa0:	81 83       	std	Z+1, r24	; 0x01
    8aa2:	8b e6       	ldi	r24, 0x6B	; 107
    8aa4:	97 e1       	ldi	r25, 0x17	; 23
    8aa6:	94 83       	std	Z+4, r25	; 0x04
    8aa8:	83 83       	std	Z+3, r24	; 0x03
    8aaa:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
			fprintf_P(stdout,PSTR("Error en el Controlador de motores No. 2 \n"));			
    8aae:	80 91 d0 79 	lds	r24, 0x79D0
    8ab2:	90 91 d1 79 	lds	r25, 0x79D1
    8ab6:	ed b7       	in	r30, 0x3d	; 61
    8ab8:	fe b7       	in	r31, 0x3e	; 62
    8aba:	92 83       	std	Z+2, r25	; 0x02
    8abc:	81 83       	std	Z+1, r24	; 0x01
    8abe:	80 e4       	ldi	r24, 0x40	; 64
    8ac0:	97 e1       	ldi	r25, 0x17	; 23
    8ac2:	94 83       	std	Z+4, r25	; 0x04
    8ac4:	83 83       	std	Z+3, r24	; 0x03
    8ac6:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    8aca:	0f 90       	pop	r0
    8acc:	0f 90       	pop	r0
    8ace:	0f 90       	pop	r0
    8ad0:	0f 90       	pop	r0
		}
		
		if((rc1 == rcOK) && (rc2 == rcOK))		//  Exito en ambos Checksum
    8ad2:	01 2b       	or	r16, r17
    8ad4:	31 f4       	brne	.+12     	; 0x8ae2 <selftestPMD+0x106>
    8ad6:	20 97       	sbiw	r28, 0x00	; 0
    8ad8:	61 f4       	brne	.+24     	; 0x8af2 <selftestPMD+0x116>
		{
			
			Led_on(Verde);							
    8ada:	80 e0       	ldi	r24, 0x00	; 0
    8adc:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
    8ae0:	08 c0       	rjmp	.+16     	; 0x8af2 <selftestPMD+0x116>
    8ae2:	21 e0       	ldi	r18, 0x01	; 1
    8ae4:	30 e0       	ldi	r19, 0x00	; 0

	rc= rc1 || rc2;
	
	return rc;

}
    8ae6:	c9 01       	movw	r24, r18
    8ae8:	df 91       	pop	r29
    8aea:	cf 91       	pop	r28
    8aec:	1f 91       	pop	r17
    8aee:	0f 91       	pop	r16
    8af0:	08 95       	ret
		}
		
		if((rc1 == rcOK) && (rc2 == rcOK))		//  Exito en ambos Checksum
		{
			
			Led_on(Verde);							
    8af2:	ce 01       	movw	r24, r28
    8af4:	20 97       	sbiw	r28, 0x00	; 0
    8af6:	11 f0       	breq	.+4      	; 0x8afc <selftestPMD+0x120>
    8af8:	81 e0       	ldi	r24, 0x01	; 1
    8afa:	90 e0       	ldi	r25, 0x00	; 0
    8afc:	9c 01       	movw	r18, r24
    8afe:	f3 cf       	rjmp	.-26     	; 0x8ae6 <selftestPMD+0x10a>

00008b00 <Tracevar2PMDVar>:
	}
	while (readindex < (total_data - nVariables));	
} 

int8 Tracevar2PMDVar(tCommand VisualTrace,int8 TracevarIndex)
{
    8b00:	df 93       	push	r29
    8b02:	cf 93       	push	r28
    8b04:	cd b7       	in	r28, 0x3d	; 61
    8b06:	de b7       	in	r29, 0x3e	; 62
	int8 Result,Axis;
	
	
	Axis=VisualTrace.Tracecomand[TracevarIndex].AxisTrace;
	if(Axis==AxisRoll) 
    8b08:	e8 a1       	ldd	r30, Y+32	; 0x20
    8b0a:	ff 27       	eor	r31, r31
    8b0c:	e7 fd       	sbrc	r30, 7
    8b0e:	f0 95       	com	r31
    8b10:	ee 0f       	add	r30, r30
    8b12:	ff 1f       	adc	r31, r31
    8b14:	85 e0       	ldi	r24, 0x05	; 5
    8b16:	90 e0       	ldi	r25, 0x00	; 0
    8b18:	8c 0f       	add	r24, r28
    8b1a:	9d 1f       	adc	r25, r29
    8b1c:	e8 0f       	add	r30, r24
    8b1e:	f9 1f       	adc	r31, r25
    8b20:	83 85       	ldd	r24, Z+11	; 0x0b
    8b22:	84 30       	cpi	r24, 0x04	; 4
    8b24:	31 f4       	brne	.+12     	; 0x8b32 <Tracevar2PMDVar+0x32>
	{
		Result=PMD2NVariables;
    8b26:	80 91 ba 79 	lds	r24, 0x79BA
		PMD2NVariables++;
    8b2a:	8f 5f       	subi	r24, 0xFF	; 255
    8b2c:	80 93 ba 79 	sts	0x79BA, r24
    8b30:	05 c0       	rjmp	.+10     	; 0x8b3c <Tracevar2PMDVar+0x3c>
	}
	else
	{
		Result=PMD1NVariables;
    8b32:	80 91 b9 79 	lds	r24, 0x79B9
		PMD1NVariables++;
    8b36:	8f 5f       	subi	r24, 0xFF	; 255
    8b38:	80 93 b9 79 	sts	0x79B9, r24
    8b3c:	81 50       	subi	r24, 0x01	; 1
	}
	
	return Result;

}
    8b3e:	cf 91       	pop	r28
    8b40:	df 91       	pop	r29
    8b42:	08 95       	ret

00008b44 <DisableVariable>:
	printf("EnvioTrazado2PC=> total_data=  %ld\n ",total_data);
	printf("EnvioTrazado2PC=> Saliendo readbuffer\n ");
} 

void DisableVariable(void)
{
    8b44:	0f 93       	push	r16
    8b46:	1f 93       	push	r17

	PMDSetTraceVariable(&hAxis[AxisWaist], PMDTrace1, Axis2PMDAxis(AxisWaist), PMDTraceNoVariable);
    8b48:	80 e0       	ldi	r24, 0x00	; 0
    8b4a:	90 e0       	ldi	r25, 0x00	; 0
    8b4c:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    8b50:	ac 01       	movw	r20, r24
    8b52:	09 e1       	ldi	r16, 0x19	; 25
    8b54:	15 e7       	ldi	r17, 0x75	; 117
    8b56:	c8 01       	movw	r24, r16
    8b58:	60 e0       	ldi	r22, 0x00	; 0
    8b5a:	70 e0       	ldi	r23, 0x00	; 0
    8b5c:	20 e0       	ldi	r18, 0x00	; 0
    8b5e:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisWaist], PMDTrace2, Axis2PMDAxis(AxisWaist), PMDTraceNoVariable);
    8b62:	80 e0       	ldi	r24, 0x00	; 0
    8b64:	90 e0       	ldi	r25, 0x00	; 0
    8b66:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    8b6a:	ac 01       	movw	r20, r24
    8b6c:	c8 01       	movw	r24, r16
    8b6e:	61 e0       	ldi	r22, 0x01	; 1
    8b70:	70 e0       	ldi	r23, 0x00	; 0
    8b72:	20 e0       	ldi	r18, 0x00	; 0
    8b74:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisWaist], PMDTrace3, Axis2PMDAxis(AxisWaist), PMDTraceNoVariable);
    8b78:	80 e0       	ldi	r24, 0x00	; 0
    8b7a:	90 e0       	ldi	r25, 0x00	; 0
    8b7c:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    8b80:	ac 01       	movw	r20, r24
    8b82:	c8 01       	movw	r24, r16
    8b84:	62 e0       	ldi	r22, 0x02	; 2
    8b86:	70 e0       	ldi	r23, 0x00	; 0
    8b88:	20 e0       	ldi	r18, 0x00	; 0
    8b8a:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisWaist], PMDTrace4, Axis2PMDAxis(AxisWaist), PMDTraceNoVariable);	
    8b8e:	80 e0       	ldi	r24, 0x00	; 0
    8b90:	90 e0       	ldi	r25, 0x00	; 0
    8b92:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    8b96:	ac 01       	movw	r20, r24
    8b98:	c8 01       	movw	r24, r16
    8b9a:	63 e0       	ldi	r22, 0x03	; 3
    8b9c:	70 e0       	ldi	r23, 0x00	; 0
    8b9e:	20 e0       	ldi	r18, 0x00	; 0
    8ba0:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisRoll], PMDTrace1, Axis2PMDAxis(AxisRoll), PMDTraceNoVariable);
    8ba4:	84 e0       	ldi	r24, 0x04	; 4
    8ba6:	90 e0       	ldi	r25, 0x00	; 0
    8ba8:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    8bac:	ac 01       	movw	r20, r24
    8bae:	09 e9       	ldi	r16, 0x99	; 153
    8bb0:	16 e7       	ldi	r17, 0x76	; 118
    8bb2:	c8 01       	movw	r24, r16
    8bb4:	60 e0       	ldi	r22, 0x00	; 0
    8bb6:	70 e0       	ldi	r23, 0x00	; 0
    8bb8:	20 e0       	ldi	r18, 0x00	; 0
    8bba:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisRoll], PMDTrace2, Axis2PMDAxis(AxisRoll), PMDTraceNoVariable);
    8bbe:	84 e0       	ldi	r24, 0x04	; 4
    8bc0:	90 e0       	ldi	r25, 0x00	; 0
    8bc2:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    8bc6:	ac 01       	movw	r20, r24
    8bc8:	c8 01       	movw	r24, r16
    8bca:	61 e0       	ldi	r22, 0x01	; 1
    8bcc:	70 e0       	ldi	r23, 0x00	; 0
    8bce:	20 e0       	ldi	r18, 0x00	; 0
    8bd0:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisRoll], PMDTrace3, Axis2PMDAxis(AxisRoll), PMDTraceNoVariable);
    8bd4:	84 e0       	ldi	r24, 0x04	; 4
    8bd6:	90 e0       	ldi	r25, 0x00	; 0
    8bd8:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    8bdc:	ac 01       	movw	r20, r24
    8bde:	c8 01       	movw	r24, r16
    8be0:	62 e0       	ldi	r22, 0x02	; 2
    8be2:	70 e0       	ldi	r23, 0x00	; 0
    8be4:	20 e0       	ldi	r18, 0x00	; 0
    8be6:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[AxisRoll], PMDTrace4, Axis2PMDAxis(AxisRoll), PMDTraceNoVariable);	
    8bea:	84 e0       	ldi	r24, 0x04	; 4
    8bec:	90 e0       	ldi	r25, 0x00	; 0
    8bee:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    8bf2:	ac 01       	movw	r20, r24
    8bf4:	c8 01       	movw	r24, r16
    8bf6:	63 e0       	ldi	r22, 0x03	; 3
    8bf8:	70 e0       	ldi	r23, 0x00	; 0
    8bfa:	20 e0       	ldi	r18, 0x00	; 0
    8bfc:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
    8c00:	1f 91       	pop	r17
    8c02:	0f 91       	pop	r16
    8c04:	08 95       	ret

00008c06 <EnvioTrazado2PC>:
}


/*****************************************************************************************/
void EnvioTrazado2PC(uint8 N_traceVariable)
{
    8c06:	6f 92       	push	r6
    8c08:	7f 92       	push	r7
    8c0a:	8f 92       	push	r8
    8c0c:	9f 92       	push	r9
    8c0e:	af 92       	push	r10
    8c10:	bf 92       	push	r11
    8c12:	cf 92       	push	r12
    8c14:	df 92       	push	r13
    8c16:	ef 92       	push	r14
    8c18:	ff 92       	push	r15
    8c1a:	0f 93       	push	r16
    8c1c:	1f 93       	push	r17
    8c1e:	df 93       	push	r29
    8c20:	cf 93       	push	r28
    8c22:	cd b7       	in	r28, 0x3d	; 61
    8c24:	de b7       	in	r29, 0x3e	; 62
    8c26:	a0 97       	sbiw	r28, 0x20	; 32
    8c28:	0f b6       	in	r0, 0x3f	; 63
    8c2a:	f8 94       	cli
    8c2c:	de bf       	out	0x3e, r29	; 62
    8c2e:	0f be       	out	0x3f, r0	; 63
    8c30:	cd bf       	out	0x3d, r28	; 61
    8c32:	18 2f       	mov	r17, r24
	uint8 Axis=0;
	PMDuint32 total_data_Chipset2=0;
    8c34:	19 82       	std	Y+1, r1	; 0x01
    8c36:	1a 82       	std	Y+2, r1	; 0x02
    8c38:	1b 82       	std	Y+3, r1	; 0x03
    8c3a:	1c 82       	std	Y+4, r1	; 0x04
	PMDuint32 total_data_Chipset1=0;
    8c3c:	1d 82       	std	Y+5, r1	; 0x05
    8c3e:	1e 82       	std	Y+6, r1	; 0x06
    8c40:	1f 82       	std	Y+7, r1	; 0x07
    8c42:	18 86       	std	Y+8, r1	; 0x08
	#ifdef DEBUGUSBLevel1
	uint16 spacefree;
	#endif
	total_data=0;
	
	PMDGetTraceCount(&hAxis[AxisWaist], &total_data_Chipset1);		
    8c44:	89 e1       	ldi	r24, 0x19	; 25
    8c46:	95 e7       	ldi	r25, 0x75	; 117
    8c48:	be 01       	movw	r22, r28
    8c4a:	6b 5f       	subi	r22, 0xFB	; 251
    8c4c:	7f 4f       	sbci	r23, 0xFF	; 255
    8c4e:	0e 94 0d 7b 	call	0xf61a	; 0xf61a <PMDGetTraceCount>
	printf("EnvioTrazado2PC=> total_data_Chipset1=  %ld\n",total_data_Chipset1);
    8c52:	00 d0       	rcall	.+0      	; 0x8c54 <EnvioTrazado2PC+0x4e>
    8c54:	00 d0       	rcall	.+0      	; 0x8c56 <EnvioTrazado2PC+0x50>
    8c56:	00 d0       	rcall	.+0      	; 0x8c58 <EnvioTrazado2PC+0x52>
    8c58:	88 e2       	ldi	r24, 0x28	; 40
    8c5a:	92 e4       	ldi	r25, 0x42	; 66
    8c5c:	ad b7       	in	r26, 0x3d	; 61
    8c5e:	be b7       	in	r27, 0x3e	; 62
    8c60:	12 96       	adiw	r26, 0x02	; 2
    8c62:	9c 93       	st	X, r25
    8c64:	8e 93       	st	-X, r24
    8c66:	11 97       	sbiw	r26, 0x01	; 1
    8c68:	8d 81       	ldd	r24, Y+5	; 0x05
    8c6a:	9e 81       	ldd	r25, Y+6	; 0x06
    8c6c:	af 81       	ldd	r26, Y+7	; 0x07
    8c6e:	b8 85       	ldd	r27, Y+8	; 0x08
    8c70:	ed b7       	in	r30, 0x3d	; 61
    8c72:	fe b7       	in	r31, 0x3e	; 62
    8c74:	83 83       	std	Z+3, r24	; 0x03
    8c76:	94 83       	std	Z+4, r25	; 0x04
    8c78:	a5 83       	std	Z+5, r26	; 0x05
    8c7a:	b6 83       	std	Z+6, r27	; 0x06
    8c7c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	PMDGetTraceCount(&hAxis[AxisRoll], &total_data_Chipset2);
    8c80:	8d b7       	in	r24, 0x3d	; 61
    8c82:	9e b7       	in	r25, 0x3e	; 62
    8c84:	06 96       	adiw	r24, 0x06	; 6
    8c86:	0f b6       	in	r0, 0x3f	; 63
    8c88:	f8 94       	cli
    8c8a:	9e bf       	out	0x3e, r25	; 62
    8c8c:	0f be       	out	0x3f, r0	; 63
    8c8e:	8d bf       	out	0x3d, r24	; 61
    8c90:	89 e9       	ldi	r24, 0x99	; 153
    8c92:	96 e7       	ldi	r25, 0x76	; 118
    8c94:	be 01       	movw	r22, r28
    8c96:	6f 5f       	subi	r22, 0xFF	; 255
    8c98:	7f 4f       	sbci	r23, 0xFF	; 255
    8c9a:	0e 94 0d 7b 	call	0xf61a	; 0xf61a <PMDGetTraceCount>
	printf("EnvioTrazado2PC=> total_data_Chipset2=  %ld\n",total_data_Chipset2);
    8c9e:	00 d0       	rcall	.+0      	; 0x8ca0 <EnvioTrazado2PC+0x9a>
    8ca0:	00 d0       	rcall	.+0      	; 0x8ca2 <EnvioTrazado2PC+0x9c>
    8ca2:	00 d0       	rcall	.+0      	; 0x8ca4 <EnvioTrazado2PC+0x9e>
    8ca4:	85 e5       	ldi	r24, 0x55	; 85
    8ca6:	92 e4       	ldi	r25, 0x42	; 66
    8ca8:	ad b7       	in	r26, 0x3d	; 61
    8caa:	be b7       	in	r27, 0x3e	; 62
    8cac:	12 96       	adiw	r26, 0x02	; 2
    8cae:	9c 93       	st	X, r25
    8cb0:	8e 93       	st	-X, r24
    8cb2:	11 97       	sbiw	r26, 0x01	; 1
    8cb4:	89 81       	ldd	r24, Y+1	; 0x01
    8cb6:	9a 81       	ldd	r25, Y+2	; 0x02
    8cb8:	ab 81       	ldd	r26, Y+3	; 0x03
    8cba:	bc 81       	ldd	r27, Y+4	; 0x04
    8cbc:	ed b7       	in	r30, 0x3d	; 61
    8cbe:	fe b7       	in	r31, 0x3e	; 62
    8cc0:	83 83       	std	Z+3, r24	; 0x03
    8cc2:	94 83       	std	Z+4, r25	; 0x04
    8cc4:	a5 83       	std	Z+5, r26	; 0x05
    8cc6:	b6 83       	std	Z+6, r27	; 0x06
    8cc8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	
	PMDSetBufferReadIndex(&hAxis[AxisWaist], BUFFER_ID,0);
    8ccc:	8d b7       	in	r24, 0x3d	; 61
    8cce:	9e b7       	in	r25, 0x3e	; 62
    8cd0:	06 96       	adiw	r24, 0x06	; 6
    8cd2:	0f b6       	in	r0, 0x3f	; 63
    8cd4:	f8 94       	cli
    8cd6:	9e bf       	out	0x3e, r25	; 62
    8cd8:	0f be       	out	0x3f, r0	; 63
    8cda:	8d bf       	out	0x3d, r24	; 61
    8cdc:	89 e1       	ldi	r24, 0x19	; 25
    8cde:	95 e7       	ldi	r25, 0x75	; 117
    8ce0:	60 e0       	ldi	r22, 0x00	; 0
    8ce2:	70 e0       	ldi	r23, 0x00	; 0
    8ce4:	20 e0       	ldi	r18, 0x00	; 0
    8ce6:	30 e0       	ldi	r19, 0x00	; 0
    8ce8:	40 e0       	ldi	r20, 0x00	; 0
    8cea:	50 e0       	ldi	r21, 0x00	; 0
    8cec:	0e 94 c4 7d 	call	0xfb88	; 0xfb88 <PMDSetBufferReadIndex>
	PMDSetBufferReadIndex(&hAxis[AxisRoll], BUFFER_ID,0);
    8cf0:	89 e9       	ldi	r24, 0x99	; 153
    8cf2:	96 e7       	ldi	r25, 0x76	; 118
    8cf4:	60 e0       	ldi	r22, 0x00	; 0
    8cf6:	70 e0       	ldi	r23, 0x00	; 0
    8cf8:	20 e0       	ldi	r18, 0x00	; 0
    8cfa:	30 e0       	ldi	r19, 0x00	; 0
    8cfc:	40 e0       	ldi	r20, 0x00	; 0
    8cfe:	50 e0       	ldi	r21, 0x00	; 0
    8d00:	0e 94 c4 7d 	call	0xfb88	; 0xfb88 <PMDSetBufferReadIndex>
	

	total_data=total_data_Chipset1+total_data_Chipset2;
    8d04:	2d 81       	ldd	r18, Y+5	; 0x05
    8d06:	3e 81       	ldd	r19, Y+6	; 0x06
    8d08:	4f 81       	ldd	r20, Y+7	; 0x07
    8d0a:	58 85       	ldd	r21, Y+8	; 0x08
    8d0c:	89 81       	ldd	r24, Y+1	; 0x01
    8d0e:	9a 81       	ldd	r25, Y+2	; 0x02
    8d10:	ab 81       	ldd	r26, Y+3	; 0x03
    8d12:	bc 81       	ldd	r27, Y+4	; 0x04
    8d14:	5c 01       	movw	r10, r24
    8d16:	6d 01       	movw	r12, r26
    8d18:	a2 0e       	add	r10, r18
    8d1a:	b3 1e       	adc	r11, r19
    8d1c:	c4 1e       	adc	r12, r20
    8d1e:	d5 1e       	adc	r13, r21
	/*He configurado alguna variable para trazar*/
	if(N_traceVariable>0 && N_traceVariable<=8)
    8d20:	11 50       	subi	r17, 0x01	; 1
    8d22:	18 30       	cpi	r17, 0x08	; 8
    8d24:	08 f0       	brcs	.+2      	; 0x8d28 <EnvioTrazado2PC+0x122>
    8d26:	b9 c0       	rjmp	.+370    	; 0x8e9a <EnvioTrazado2PC+0x294>
	{
		/*total_data = Numero de datos de 32 bists del trazado*/			
		Tracebufferdata[0]=total_data;
    8d28:	a9 8a       	std	Y+17, r10	; 0x11
    8d2a:	ba 8a       	std	Y+18, r11	; 0x12
    8d2c:	cb 8a       	std	Y+19, r12	; 0x13
    8d2e:	dc 8a       	std	Y+20, r13	; 0x14
		Tracebufferdata[1]=total_data_Chipset1;
    8d30:	2d 8b       	std	Y+21, r18	; 0x15
    8d32:	3e 8b       	std	Y+22, r19	; 0x16
    8d34:	4f 8b       	std	Y+23, r20	; 0x17
    8d36:	58 8f       	std	Y+24, r21	; 0x18
		Tracebufferdata[2]=total_data_Chipset2;
    8d38:	89 8f       	std	Y+25, r24	; 0x19
    8d3a:	9a 8f       	std	Y+26, r25	; 0x1a
    8d3c:	ab 8f       	std	Y+27, r26	; 0x1b
    8d3e:	bc 8f       	std	Y+28, r27	; 0x1c
		printf("EnvioTrazado2PC=> Tracebufferdata[0]=  %ld\n",Tracebufferdata[0]);
    8d40:	00 d0       	rcall	.+0      	; 0x8d42 <EnvioTrazado2PC+0x13c>
    8d42:	00 d0       	rcall	.+0      	; 0x8d44 <EnvioTrazado2PC+0x13e>
    8d44:	00 d0       	rcall	.+0      	; 0x8d46 <EnvioTrazado2PC+0x140>
    8d46:	ed b7       	in	r30, 0x3d	; 61
    8d48:	fe b7       	in	r31, 0x3e	; 62
    8d4a:	31 96       	adiw	r30, 0x01	; 1
    8d4c:	82 e8       	ldi	r24, 0x82	; 130
    8d4e:	92 e4       	ldi	r25, 0x42	; 66
    8d50:	ad b7       	in	r26, 0x3d	; 61
    8d52:	be b7       	in	r27, 0x3e	; 62
    8d54:	12 96       	adiw	r26, 0x02	; 2
    8d56:	9c 93       	st	X, r25
    8d58:	8e 93       	st	-X, r24
    8d5a:	11 97       	sbiw	r26, 0x01	; 1
    8d5c:	a2 82       	std	Z+2, r10	; 0x02
    8d5e:	b3 82       	std	Z+3, r11	; 0x03
    8d60:	c4 82       	std	Z+4, r12	; 0x04
    8d62:	d5 82       	std	Z+5, r13	; 0x05
    8d64:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		if(total_data_Chipset1>0)
			Axis=AxisWaist;
		/*Solo tamao de los datos, 4N+12 siempre es par*/
		buffersize=(Tracebufferdata[0]*sizeof(int32))+(sizeof(int32)*3);
		fillPacketHeader(&PacketHeader,PacketTrace,buffersize,NULL); 
    8d68:	ed b7       	in	r30, 0x3d	; 61
    8d6a:	fe b7       	in	r31, 0x3e	; 62
    8d6c:	36 96       	adiw	r30, 0x06	; 6
    8d6e:	0f b6       	in	r0, 0x3f	; 63
    8d70:	f8 94       	cli
    8d72:	fe bf       	out	0x3e, r31	; 62
    8d74:	0f be       	out	0x3f, r0	; 63
    8d76:	ed bf       	out	0x3d, r30	; 61
    8d78:	8e 01       	movw	r16, r28
    8d7a:	07 5f       	subi	r16, 0xF7	; 247
    8d7c:	1f 4f       	sbci	r17, 0xFF	; 255
    8d7e:	29 89       	ldd	r18, Y+17	; 0x11
    8d80:	3a 89       	ldd	r19, Y+18	; 0x12
    8d82:	4b 89       	ldd	r20, Y+19	; 0x13
    8d84:	5c 89       	ldd	r21, Y+20	; 0x14
    8d86:	2d 5f       	subi	r18, 0xFD	; 253
    8d88:	3f 4f       	sbci	r19, 0xFF	; 255
    8d8a:	4f 4f       	sbci	r20, 0xFF	; 255
    8d8c:	5f 4f       	sbci	r21, 0xFF	; 255
    8d8e:	62 e0       	ldi	r22, 0x02	; 2
    8d90:	22 0f       	add	r18, r18
    8d92:	33 1f       	adc	r19, r19
    8d94:	44 1f       	adc	r20, r20
    8d96:	55 1f       	adc	r21, r21
    8d98:	6a 95       	dec	r22
    8d9a:	d1 f7       	brne	.-12     	; 0x8d90 <EnvioTrazado2PC+0x18a>
    8d9c:	c8 01       	movw	r24, r16
    8d9e:	6c e0       	ldi	r22, 0x0C	; 12
    8da0:	70 e0       	ldi	r23, 0x00	; 0
    8da2:	a9 01       	movw	r20, r18
    8da4:	20 e0       	ldi	r18, 0x00	; 0
    8da6:	30 e0       	ldi	r19, 0x00	; 0
    8da8:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <fillPacketHeader>
		BufferData=(uint8*)&PacketHeader;
		Envio_USB(BufferData,sizeof(tPacketHeader));
    8dac:	c8 01       	movw	r24, r16
    8dae:	68 e0       	ldi	r22, 0x08	; 8
    8db0:	70 e0       	ldi	r23, 0x00	; 0
    8db2:	0e 94 37 2b 	call	0x566e	; 0x566e <Envio_USB>
		/*Mando el Tracebufferdata[0] */
		BufferData=(uint8*)&Tracebufferdata[0];
		Envio_USB(BufferData,sizeof(int32));
    8db6:	ce 01       	movw	r24, r28
    8db8:	41 96       	adiw	r24, 0x11	; 17
    8dba:	64 e0       	ldi	r22, 0x04	; 4
    8dbc:	70 e0       	ldi	r23, 0x00	; 0
    8dbe:	0e 94 37 2b 	call	0x566e	; 0x566e <Envio_USB>
		/*Mando el Tracebufferdata[1] */
		BufferData=(uint8*)&Tracebufferdata[1];
		Envio_USB(BufferData,sizeof(int32));
    8dc2:	ce 01       	movw	r24, r28
    8dc4:	45 96       	adiw	r24, 0x15	; 21
    8dc6:	64 e0       	ldi	r22, 0x04	; 4
    8dc8:	70 e0       	ldi	r23, 0x00	; 0
    8dca:	0e 94 37 2b 	call	0x566e	; 0x566e <Envio_USB>
		/*Mando el Tracebufferdata[2] */
		BufferData=(uint8*)&Tracebufferdata[2];
		Envio_USB(BufferData,sizeof(int32));
    8dce:	ce 01       	movw	r24, r28
    8dd0:	49 96       	adiw	r24, 0x19	; 25
    8dd2:	64 e0       	ldi	r22, 0x04	; 4
    8dd4:	70 e0       	ldi	r23, 0x00	; 0
    8dd6:	0e 94 37 2b 	call	0x566e	; 0x566e <Envio_USB>
		/*Grabo todos los datos*/
		printf("EnvioTrazado2PC=> Iniciando envio de trazado... \n");
    8dda:	8e ea       	ldi	r24, 0xAE	; 174
    8ddc:	92 e4       	ldi	r25, 0x42	; 66
    8dde:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
    8de2:	77 24       	eor	r7, r7
    8de4:	ee 24       	eor	r14, r14
    8de6:	ff 24       	eor	r15, r15
    8de8:	87 01       	movw	r16, r14
		{
			/*Estoy en el PMD2*/
			if(i>=(total_data_Chipset1))
				Axis=AxisRoll;
			/*Leo el dato*/
			PMDReadBuffer(&hAxis[Axis], BUFFER_ID,&Tracebufferdata[3]);	
    8dea:	30 e6       	ldi	r19, 0x60	; 96
    8dec:	63 2e       	mov	r6, r19
    8dee:	2d e1       	ldi	r18, 0x1D	; 29
    8df0:	82 2e       	mov	r8, r18
    8df2:	91 2c       	mov	r9, r1
    8df4:	8c 0e       	add	r8, r28
    8df6:	9d 1e       	adc	r9, r29
    8df8:	1f c0       	rjmp	.+62     	; 0x8e38 <EnvioTrazado2PC+0x232>
		/*Grabo todos los datos*/
		printf("EnvioTrazado2PC=> Iniciando envio de trazado... \n");
		for(i=0;i<total_data;i++)
		{
			/*Estoy en el PMD2*/
			if(i>=(total_data_Chipset1))
    8dfa:	8d 81       	ldd	r24, Y+5	; 0x05
    8dfc:	9e 81       	ldd	r25, Y+6	; 0x06
    8dfe:	af 81       	ldd	r26, Y+7	; 0x07
    8e00:	b8 85       	ldd	r27, Y+8	; 0x08
    8e02:	e8 16       	cp	r14, r24
    8e04:	f9 06       	cpc	r15, r25
    8e06:	0a 07       	cpc	r16, r26
    8e08:	1b 07       	cpc	r17, r27
    8e0a:	10 f0       	brcs	.+4      	; 0x8e10 <EnvioTrazado2PC+0x20a>
    8e0c:	94 e0       	ldi	r25, 0x04	; 4
    8e0e:	79 2e       	mov	r7, r25
				Axis=AxisRoll;
			/*Leo el dato*/
			PMDReadBuffer(&hAxis[Axis], BUFFER_ID,&Tracebufferdata[3]);	
    8e10:	76 9c       	mul	r7, r6
    8e12:	c0 01       	movw	r24, r0
    8e14:	11 24       	eor	r1, r1
    8e16:	87 5e       	subi	r24, 0xE7	; 231
    8e18:	9a 48       	sbci	r25, 0x8A	; 138
    8e1a:	60 e0       	ldi	r22, 0x00	; 0
    8e1c:	70 e0       	ldi	r23, 0x00	; 0
    8e1e:	a4 01       	movw	r20, r8
    8e20:	0e 94 65 7d 	call	0xfaca	; 0xfaca <PMDReadBuffer>
			/*Mando el Tracebufferdata[3], dato lleido de la memoria del PMD */
			BufferData=(uint8*)&Tracebufferdata[3];
			Envio_USB(BufferData,sizeof(int32));
    8e24:	c4 01       	movw	r24, r8
    8e26:	64 e0       	ldi	r22, 0x04	; 4
    8e28:	70 e0       	ldi	r23, 0x00	; 0
    8e2a:	0e 94 37 2b 	call	0x566e	; 0x566e <Envio_USB>
    8e2e:	08 94       	sec
    8e30:	e1 1c       	adc	r14, r1
    8e32:	f1 1c       	adc	r15, r1
    8e34:	01 1d       	adc	r16, r1
    8e36:	11 1d       	adc	r17, r1
		/*Mando el Tracebufferdata[2] */
		BufferData=(uint8*)&Tracebufferdata[2];
		Envio_USB(BufferData,sizeof(int32));
		/*Grabo todos los datos*/
		printf("EnvioTrazado2PC=> Iniciando envio de trazado... \n");
		for(i=0;i<total_data;i++)
    8e38:	ea 14       	cp	r14, r10
    8e3a:	fb 04       	cpc	r15, r11
    8e3c:	0c 05       	cpc	r16, r12
    8e3e:	1d 05       	cpc	r17, r13
    8e40:	e0 f2       	brcs	.-72     	; 0x8dfa <EnvioTrazado2PC+0x1f4>
			/*Mando el Tracebufferdata[3], dato lleido de la memoria del PMD */
			BufferData=(uint8*)&Tracebufferdata[3];
			Envio_USB(BufferData,sizeof(int32));
			//printf("Tracebufferdata[3]=  %ld, Index %d \n",(int32)Tracebufferdata[3],i);
		}
		printf("EnvioTrazado2PC=> Envio de trazado finalizado... \n");
    8e42:	8f ed       	ldi	r24, 0xDF	; 223
    8e44:	92 e4       	ldi	r25, 0x42	; 66
    8e46:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
		PMDSetBufferReadIndex(&hAxis[AxisWaist], BUFFER_ID,0);
    8e4a:	89 e1       	ldi	r24, 0x19	; 25
    8e4c:	95 e7       	ldi	r25, 0x75	; 117
    8e4e:	60 e0       	ldi	r22, 0x00	; 0
    8e50:	70 e0       	ldi	r23, 0x00	; 0
    8e52:	20 e0       	ldi	r18, 0x00	; 0
    8e54:	30 e0       	ldi	r19, 0x00	; 0
    8e56:	40 e0       	ldi	r20, 0x00	; 0
    8e58:	50 e0       	ldi	r21, 0x00	; 0
    8e5a:	0e 94 c4 7d 	call	0xfb88	; 0xfb88 <PMDSetBufferReadIndex>
		PMDSetBufferWriteIndex(&hAxis[AxisWaist], BUFFER_ID,0);
    8e5e:	89 e1       	ldi	r24, 0x19	; 25
    8e60:	95 e7       	ldi	r25, 0x75	; 117
    8e62:	60 e0       	ldi	r22, 0x00	; 0
    8e64:	70 e0       	ldi	r23, 0x00	; 0
    8e66:	20 e0       	ldi	r18, 0x00	; 0
    8e68:	30 e0       	ldi	r19, 0x00	; 0
    8e6a:	40 e0       	ldi	r20, 0x00	; 0
    8e6c:	50 e0       	ldi	r21, 0x00	; 0
    8e6e:	0e 94 e6 7d 	call	0xfbcc	; 0xfbcc <PMDSetBufferWriteIndex>
		PMDSetBufferReadIndex(&hAxis[AxisRoll], BUFFER_ID,0);
    8e72:	89 e9       	ldi	r24, 0x99	; 153
    8e74:	96 e7       	ldi	r25, 0x76	; 118
    8e76:	60 e0       	ldi	r22, 0x00	; 0
    8e78:	70 e0       	ldi	r23, 0x00	; 0
    8e7a:	20 e0       	ldi	r18, 0x00	; 0
    8e7c:	30 e0       	ldi	r19, 0x00	; 0
    8e7e:	40 e0       	ldi	r20, 0x00	; 0
    8e80:	50 e0       	ldi	r21, 0x00	; 0
    8e82:	0e 94 c4 7d 	call	0xfb88	; 0xfb88 <PMDSetBufferReadIndex>
		PMDSetBufferWriteIndex(&hAxis[AxisRoll], BUFFER_ID,0);
    8e86:	89 e9       	ldi	r24, 0x99	; 153
    8e88:	96 e7       	ldi	r25, 0x76	; 118
    8e8a:	60 e0       	ldi	r22, 0x00	; 0
    8e8c:	70 e0       	ldi	r23, 0x00	; 0
    8e8e:	20 e0       	ldi	r18, 0x00	; 0
    8e90:	30 e0       	ldi	r19, 0x00	; 0
    8e92:	40 e0       	ldi	r20, 0x00	; 0
    8e94:	50 e0       	ldi	r21, 0x00	; 0
    8e96:	0e 94 e6 7d 	call	0xfbcc	; 0xfbcc <PMDSetBufferWriteIndex>
	}
	printf("EnvioTrazado2PC=> total_data=  %ld\n ",total_data);
    8e9a:	00 d0       	rcall	.+0      	; 0x8e9c <EnvioTrazado2PC+0x296>
    8e9c:	00 d0       	rcall	.+0      	; 0x8e9e <EnvioTrazado2PC+0x298>
    8e9e:	00 d0       	rcall	.+0      	; 0x8ea0 <EnvioTrazado2PC+0x29a>
    8ea0:	81 e1       	ldi	r24, 0x11	; 17
    8ea2:	93 e4       	ldi	r25, 0x43	; 67
    8ea4:	ad b7       	in	r26, 0x3d	; 61
    8ea6:	be b7       	in	r27, 0x3e	; 62
    8ea8:	12 96       	adiw	r26, 0x02	; 2
    8eaa:	9c 93       	st	X, r25
    8eac:	8e 93       	st	-X, r24
    8eae:	11 97       	sbiw	r26, 0x01	; 1
    8eb0:	ed b7       	in	r30, 0x3d	; 61
    8eb2:	fe b7       	in	r31, 0x3e	; 62
    8eb4:	a3 82       	std	Z+3, r10	; 0x03
    8eb6:	b4 82       	std	Z+4, r11	; 0x04
    8eb8:	c5 82       	std	Z+5, r12	; 0x05
    8eba:	d6 82       	std	Z+6, r13	; 0x06
    8ebc:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("EnvioTrazado2PC=> Saliendo readbuffer\n ");
    8ec0:	0f 90       	pop	r0
    8ec2:	0f 90       	pop	r0
    8ec4:	0f 90       	pop	r0
    8ec6:	0f 90       	pop	r0
    8ec8:	86 e3       	ldi	r24, 0x36	; 54
    8eca:	93 e4       	ldi	r25, 0x43	; 67
    8ecc:	ad b7       	in	r26, 0x3d	; 61
    8ece:	be b7       	in	r27, 0x3e	; 62
    8ed0:	12 96       	adiw	r26, 0x02	; 2
    8ed2:	9c 93       	st	X, r25
    8ed4:	8e 93       	st	-X, r24
    8ed6:	11 97       	sbiw	r26, 0x01	; 1
    8ed8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    8edc:	0f 90       	pop	r0
    8ede:	0f 90       	pop	r0
} 
    8ee0:	a0 96       	adiw	r28, 0x20	; 32
    8ee2:	0f b6       	in	r0, 0x3f	; 63
    8ee4:	f8 94       	cli
    8ee6:	de bf       	out	0x3e, r29	; 62
    8ee8:	0f be       	out	0x3f, r0	; 63
    8eea:	cd bf       	out	0x3d, r28	; 61
    8eec:	cf 91       	pop	r28
    8eee:	df 91       	pop	r29
    8ef0:	1f 91       	pop	r17
    8ef2:	0f 91       	pop	r16
    8ef4:	ff 90       	pop	r15
    8ef6:	ef 90       	pop	r14
    8ef8:	df 90       	pop	r13
    8efa:	cf 90       	pop	r12
    8efc:	bf 90       	pop	r11
    8efe:	af 90       	pop	r10
    8f00:	9f 90       	pop	r9
    8f02:	8f 90       	pop	r8
    8f04:	7f 90       	pop	r7
    8f06:	6f 90       	pop	r6
    8f08:	08 95       	ret

00008f0a <DisplayTraceResults>:
	}
}

/*****************************************************************************************/
void DisplayTraceResults(int Chipset,PMDuint8 nVariables)
{
    8f0a:	2f 92       	push	r2
    8f0c:	3f 92       	push	r3
    8f0e:	4f 92       	push	r4
    8f10:	5f 92       	push	r5
    8f12:	6f 92       	push	r6
    8f14:	7f 92       	push	r7
    8f16:	8f 92       	push	r8
    8f18:	9f 92       	push	r9
    8f1a:	af 92       	push	r10
    8f1c:	bf 92       	push	r11
    8f1e:	cf 92       	push	r12
    8f20:	df 92       	push	r13
    8f22:	ef 92       	push	r14
    8f24:	ff 92       	push	r15
    8f26:	0f 93       	push	r16
    8f28:	1f 93       	push	r17
    8f2a:	df 93       	push	r29
    8f2c:	cf 93       	push	r28
    8f2e:	cd b7       	in	r28, 0x3d	; 61
    8f30:	de b7       	in	r29, 0x3e	; 62
    8f32:	2c 97       	sbiw	r28, 0x0c	; 12
    8f34:	0f b6       	in	r0, 0x3f	; 63
    8f36:	f8 94       	cli
    8f38:	de bf       	out	0x3e, r29	; 62
    8f3a:	0f be       	out	0x3f, r0	; 63
    8f3c:	cd bf       	out	0x3d, r28	; 61
    8f3e:	16 2f       	mov	r17, r22
	PMDlong32 bufferdata ;
    int Axis;

	
	Axis = AxisWaist;
	if(Chipset==2) 
    8f40:	02 97       	sbiw	r24, 0x02	; 2
    8f42:	19 f4       	brne	.+6      	; 0x8f4a <DisplayTraceResults+0x40>
    8f44:	24 e0       	ldi	r18, 0x04	; 4
    8f46:	30 e0       	ldi	r19, 0x00	; 0
    8f48:	02 c0       	rjmp	.+4      	; 0x8f4e <DisplayTraceResults+0x44>
    8f4a:	20 e0       	ldi	r18, 0x00	; 0
    8f4c:	30 e0       	ldi	r19, 0x00	; 0
		Axis = AxisRoll;
	PMDGetTraceCount(&hAxis[Axis], &total_data);
    8f4e:	80 e6       	ldi	r24, 0x60	; 96
    8f50:	90 e0       	ldi	r25, 0x00	; 0
    8f52:	28 9f       	mul	r18, r24
    8f54:	60 01       	movw	r12, r0
    8f56:	29 9f       	mul	r18, r25
    8f58:	d0 0c       	add	r13, r0
    8f5a:	38 9f       	mul	r19, r24
    8f5c:	d0 0c       	add	r13, r0
    8f5e:	11 24       	eor	r1, r1
    8f60:	89 e1       	ldi	r24, 0x19	; 25
    8f62:	95 e7       	ldi	r25, 0x75	; 117
    8f64:	c8 0e       	add	r12, r24
    8f66:	d9 1e       	adc	r13, r25
    8f68:	c6 01       	movw	r24, r12
    8f6a:	be 01       	movw	r22, r28
    8f6c:	6f 5f       	subi	r22, 0xFF	; 255
    8f6e:	7f 4f       	sbci	r23, 0xFF	; 255
    8f70:	0e 94 0d 7b 	call	0xf61a	; 0xf61a <PMDGetTraceCount>
	printf("DisplayTraceResults=> Total de Datos= %ld \n", total_data);
    8f74:	00 d0       	rcall	.+0      	; 0x8f76 <DisplayTraceResults+0x6c>
    8f76:	00 d0       	rcall	.+0      	; 0x8f78 <DisplayTraceResults+0x6e>
    8f78:	00 d0       	rcall	.+0      	; 0x8f7a <DisplayTraceResults+0x70>
    8f7a:	8e e5       	ldi	r24, 0x5E	; 94
    8f7c:	93 e4       	ldi	r25, 0x43	; 67
    8f7e:	ed b7       	in	r30, 0x3d	; 61
    8f80:	fe b7       	in	r31, 0x3e	; 62
    8f82:	92 83       	std	Z+2, r25	; 0x02
    8f84:	81 83       	std	Z+1, r24	; 0x01
    8f86:	89 81       	ldd	r24, Y+1	; 0x01
    8f88:	9a 81       	ldd	r25, Y+2	; 0x02
    8f8a:	ab 81       	ldd	r26, Y+3	; 0x03
    8f8c:	bc 81       	ldd	r27, Y+4	; 0x04
    8f8e:	83 83       	std	Z+3, r24	; 0x03
    8f90:	94 83       	std	Z+4, r25	; 0x04
    8f92:	a5 83       	std	Z+5, r26	; 0x05
    8f94:	b6 83       	std	Z+6, r27	; 0x06
    8f96:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    8f9a:	8d b7       	in	r24, 0x3d	; 61
    8f9c:	9e b7       	in	r25, 0x3e	; 62
    8f9e:	06 96       	adiw	r24, 0x06	; 6
    8fa0:	0f b6       	in	r0, 0x3f	; 63
    8fa2:	f8 94       	cli
    8fa4:	9e bf       	out	0x3e, r25	; 62
    8fa6:	0f be       	out	0x3f, r0	; 63
    8fa8:	8d bf       	out	0x3d, r24	; 61
	do
	{
		PMDGetBufferReadIndex(&hAxis[Axis], BUFFER_ID, &readindex);
		printf("DisplayTraceResults=> readindex= %ld",readindex);
		
		for(i=0 ; i<nVariables; i++)
    8faa:	81 2e       	mov	r8, r17
    8fac:	99 24       	eor	r9, r9
    8fae:	aa 24       	eor	r10, r10
    8fb0:	bb 24       	eor	r11, r11
		{
			PMDReadBuffer(&hAxis[Axis], BUFFER_ID, &bufferdata);	
    8fb2:	f9 e0       	ldi	r31, 0x09	; 9
    8fb4:	2f 2e       	mov	r2, r31
    8fb6:	31 2c       	mov	r3, r1
    8fb8:	2c 0e       	add	r2, r28
    8fba:	3d 1e       	adc	r3, r29
			if(i==3)			
				printf("DisplayTraceResults=> \t%#lX", bufferdata);
			else 
				printf("DisplayTraceResults=> \t%ld", bufferdata);
    8fbc:	eb ec       	ldi	r30, 0xCB	; 203
    8fbe:	4e 2e       	mov	r4, r30
    8fc0:	e3 e4       	ldi	r30, 0x43	; 67
    8fc2:	5e 2e       	mov	r5, r30
		
		for(i=0 ; i<nVariables; i++)
		{
			PMDReadBuffer(&hAxis[Axis], BUFFER_ID, &bufferdata);	
			if(i==3)			
				printf("DisplayTraceResults=> \t%#lX", bufferdata);
    8fc4:	7f ea       	ldi	r23, 0xAF	; 175
    8fc6:	67 2e       	mov	r6, r23
    8fc8:	73 e4       	ldi	r23, 0x43	; 67
    8fca:	77 2e       	mov	r7, r23
	PMDGetTraceCount(&hAxis[Axis], &total_data);
	printf("DisplayTraceResults=> Total de Datos= %ld \n", total_data);
	
	do
	{
		PMDGetBufferReadIndex(&hAxis[Axis], BUFFER_ID, &readindex);
    8fcc:	c6 01       	movw	r24, r12
    8fce:	60 e0       	ldi	r22, 0x00	; 0
    8fd0:	70 e0       	ldi	r23, 0x00	; 0
    8fd2:	ae 01       	movw	r20, r28
    8fd4:	4b 5f       	subi	r20, 0xFB	; 251
    8fd6:	5f 4f       	sbci	r21, 0xFF	; 255
    8fd8:	0e 94 2b 7d 	call	0xfa56	; 0xfa56 <PMDGetBufferReadIndex>
		printf("DisplayTraceResults=> readindex= %ld",readindex);
    8fdc:	00 d0       	rcall	.+0      	; 0x8fde <DisplayTraceResults+0xd4>
    8fde:	00 d0       	rcall	.+0      	; 0x8fe0 <DisplayTraceResults+0xd6>
    8fe0:	00 d0       	rcall	.+0      	; 0x8fe2 <DisplayTraceResults+0xd8>
    8fe2:	8a e8       	ldi	r24, 0x8A	; 138
    8fe4:	93 e4       	ldi	r25, 0x43	; 67
    8fe6:	ed b7       	in	r30, 0x3d	; 61
    8fe8:	fe b7       	in	r31, 0x3e	; 62
    8fea:	92 83       	std	Z+2, r25	; 0x02
    8fec:	81 83       	std	Z+1, r24	; 0x01
    8fee:	8d 81       	ldd	r24, Y+5	; 0x05
    8ff0:	9e 81       	ldd	r25, Y+6	; 0x06
    8ff2:	af 81       	ldd	r26, Y+7	; 0x07
    8ff4:	b8 85       	ldd	r27, Y+8	; 0x08
    8ff6:	83 83       	std	Z+3, r24	; 0x03
    8ff8:	94 83       	std	Z+4, r25	; 0x04
    8ffa:	a5 83       	std	Z+5, r26	; 0x05
    8ffc:	b6 83       	std	Z+6, r27	; 0x06
    8ffe:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    9002:	ee 24       	eor	r14, r14
    9004:	ff 24       	eor	r15, r15
    9006:	87 01       	movw	r16, r14
    9008:	8d b7       	in	r24, 0x3d	; 61
    900a:	9e b7       	in	r25, 0x3e	; 62
    900c:	06 96       	adiw	r24, 0x06	; 6
    900e:	0f b6       	in	r0, 0x3f	; 63
    9010:	f8 94       	cli
    9012:	9e bf       	out	0x3e, r25	; 62
    9014:	0f be       	out	0x3f, r0	; 63
    9016:	8d bf       	out	0x3d, r24	; 61
    9018:	32 c0       	rjmp	.+100    	; 0x907e <DisplayTraceResults+0x174>
		
		for(i=0 ; i<nVariables; i++)
		{
			PMDReadBuffer(&hAxis[Axis], BUFFER_ID, &bufferdata);	
    901a:	c6 01       	movw	r24, r12
    901c:	60 e0       	ldi	r22, 0x00	; 0
    901e:	70 e0       	ldi	r23, 0x00	; 0
    9020:	a1 01       	movw	r20, r2
    9022:	0e 94 65 7d 	call	0xfaca	; 0xfaca <PMDReadBuffer>
			if(i==3)			
    9026:	93 e0       	ldi	r25, 0x03	; 3
    9028:	e9 16       	cp	r14, r25
    902a:	f1 04       	cpc	r15, r1
    902c:	01 05       	cpc	r16, r1
    902e:	11 05       	cpc	r17, r1
    9030:	41 f4       	brne	.+16     	; 0x9042 <DisplayTraceResults+0x138>
				printf("DisplayTraceResults=> \t%#lX", bufferdata);
    9032:	00 d0       	rcall	.+0      	; 0x9034 <DisplayTraceResults+0x12a>
    9034:	00 d0       	rcall	.+0      	; 0x9036 <DisplayTraceResults+0x12c>
    9036:	00 d0       	rcall	.+0      	; 0x9038 <DisplayTraceResults+0x12e>
    9038:	ed b7       	in	r30, 0x3d	; 61
    903a:	fe b7       	in	r31, 0x3e	; 62
    903c:	72 82       	std	Z+2, r7	; 0x02
    903e:	61 82       	std	Z+1, r6	; 0x01
    9040:	07 c0       	rjmp	.+14     	; 0x9050 <DisplayTraceResults+0x146>
			else 
				printf("DisplayTraceResults=> \t%ld", bufferdata);
    9042:	00 d0       	rcall	.+0      	; 0x9044 <DisplayTraceResults+0x13a>
    9044:	00 d0       	rcall	.+0      	; 0x9046 <DisplayTraceResults+0x13c>
    9046:	00 d0       	rcall	.+0      	; 0x9048 <DisplayTraceResults+0x13e>
    9048:	ed b7       	in	r30, 0x3d	; 61
    904a:	fe b7       	in	r31, 0x3e	; 62
    904c:	52 82       	std	Z+2, r5	; 0x02
    904e:	41 82       	std	Z+1, r4	; 0x01
    9050:	89 85       	ldd	r24, Y+9	; 0x09
    9052:	9a 85       	ldd	r25, Y+10	; 0x0a
    9054:	ab 85       	ldd	r26, Y+11	; 0x0b
    9056:	bc 85       	ldd	r27, Y+12	; 0x0c
    9058:	83 83       	std	Z+3, r24	; 0x03
    905a:	94 83       	std	Z+4, r25	; 0x04
    905c:	a5 83       	std	Z+5, r26	; 0x05
    905e:	b6 83       	std	Z+6, r27	; 0x06
    9060:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    9064:	8d b7       	in	r24, 0x3d	; 61
    9066:	9e b7       	in	r25, 0x3e	; 62
    9068:	06 96       	adiw	r24, 0x06	; 6
    906a:	0f b6       	in	r0, 0x3f	; 63
    906c:	f8 94       	cli
    906e:	9e bf       	out	0x3e, r25	; 62
    9070:	0f be       	out	0x3f, r0	; 63
    9072:	8d bf       	out	0x3d, r24	; 61
	do
	{
		PMDGetBufferReadIndex(&hAxis[Axis], BUFFER_ID, &readindex);
		printf("DisplayTraceResults=> readindex= %ld",readindex);
		
		for(i=0 ; i<nVariables; i++)
    9074:	08 94       	sec
    9076:	e1 1c       	adc	r14, r1
    9078:	f1 1c       	adc	r15, r1
    907a:	01 1d       	adc	r16, r1
    907c:	11 1d       	adc	r17, r1
    907e:	e8 14       	cp	r14, r8
    9080:	f9 04       	cpc	r15, r9
    9082:	0a 05       	cpc	r16, r10
    9084:	1b 05       	cpc	r17, r11
    9086:	48 f2       	brcs	.-110    	; 0x901a <DisplayTraceResults+0x110>
				printf("DisplayTraceResults=> \t%#lX", bufferdata);
			else 
				printf("DisplayTraceResults=> \t%ld", bufferdata);
		}
		
		printf("\n");
    9088:	8a e0       	ldi	r24, 0x0A	; 10
    908a:	90 e0       	ldi	r25, 0x00	; 0
    908c:	0e 94 db 9f 	call	0x13fb6	; 0x13fb6 <putchar>
	}
	while (readindex < (total_data - nVariables));	
    9090:	89 81       	ldd	r24, Y+1	; 0x01
    9092:	9a 81       	ldd	r25, Y+2	; 0x02
    9094:	ab 81       	ldd	r26, Y+3	; 0x03
    9096:	bc 81       	ldd	r27, Y+4	; 0x04
    9098:	88 19       	sub	r24, r8
    909a:	99 09       	sbc	r25, r9
    909c:	aa 09       	sbc	r26, r10
    909e:	bb 09       	sbc	r27, r11
    90a0:	2d 81       	ldd	r18, Y+5	; 0x05
    90a2:	3e 81       	ldd	r19, Y+6	; 0x06
    90a4:	4f 81       	ldd	r20, Y+7	; 0x07
    90a6:	58 85       	ldd	r21, Y+8	; 0x08
    90a8:	28 17       	cp	r18, r24
    90aa:	39 07       	cpc	r19, r25
    90ac:	4a 07       	cpc	r20, r26
    90ae:	5b 07       	cpc	r21, r27
    90b0:	08 f4       	brcc	.+2      	; 0x90b4 <DisplayTraceResults+0x1aa>
    90b2:	8c cf       	rjmp	.-232    	; 0x8fcc <DisplayTraceResults+0xc2>
} 
    90b4:	2c 96       	adiw	r28, 0x0c	; 12
    90b6:	0f b6       	in	r0, 0x3f	; 63
    90b8:	f8 94       	cli
    90ba:	de bf       	out	0x3e, r29	; 62
    90bc:	0f be       	out	0x3f, r0	; 63
    90be:	cd bf       	out	0x3d, r28	; 61
    90c0:	cf 91       	pop	r28
    90c2:	df 91       	pop	r29
    90c4:	1f 91       	pop	r17
    90c6:	0f 91       	pop	r16
    90c8:	ff 90       	pop	r15
    90ca:	ef 90       	pop	r14
    90cc:	df 90       	pop	r13
    90ce:	cf 90       	pop	r12
    90d0:	bf 90       	pop	r11
    90d2:	af 90       	pop	r10
    90d4:	9f 90       	pop	r9
    90d6:	8f 90       	pop	r8
    90d8:	7f 90       	pop	r7
    90da:	6f 90       	pop	r6
    90dc:	5f 90       	pop	r5
    90de:	4f 90       	pop	r4
    90e0:	3f 90       	pop	r3
    90e2:	2f 90       	pop	r2
    90e4:	08 95       	ret

000090e6 <SetupSingleAxisTrace>:
	}
}

/*****************************************************************************************/
void SetupSingleAxisTrace(tAxis Axis)
{
    90e6:	cf 92       	push	r12
    90e8:	df 92       	push	r13
    90ea:	ef 92       	push	r14
    90ec:	ff 92       	push	r15
    90ee:	0f 93       	push	r16
    90f0:	6c 01       	movw	r12, r24
	
	PMDSetTraceVariable(&hAxis[Axis], PMDTrace1, Axis2PMDAxis(Axis), PMDTraceCommandedPosition );
    90f2:	80 e6       	ldi	r24, 0x60	; 96
    90f4:	90 e0       	ldi	r25, 0x00	; 0
    90f6:	c8 9e       	mul	r12, r24
    90f8:	70 01       	movw	r14, r0
    90fa:	c9 9e       	mul	r12, r25
    90fc:	f0 0c       	add	r15, r0
    90fe:	d8 9e       	mul	r13, r24
    9100:	f0 0c       	add	r15, r0
    9102:	11 24       	eor	r1, r1
    9104:	89 e1       	ldi	r24, 0x19	; 25
    9106:	95 e7       	ldi	r25, 0x75	; 117
    9108:	e8 0e       	add	r14, r24
    910a:	f9 1e       	adc	r15, r25
    910c:	c6 01       	movw	r24, r12
    910e:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    9112:	ac 01       	movw	r20, r24
    9114:	c7 01       	movw	r24, r14
    9116:	60 e0       	ldi	r22, 0x00	; 0
    9118:	70 e0       	ldi	r23, 0x00	; 0
    911a:	22 e0       	ldi	r18, 0x02	; 2
    911c:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[Axis], PMDTrace2, Axis2PMDAxis(Axis), PMDTraceActualPosition);
    9120:	c6 01       	movw	r24, r12
    9122:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    9126:	ac 01       	movw	r20, r24
    9128:	c7 01       	movw	r24, r14
    912a:	61 e0       	ldi	r22, 0x01	; 1
    912c:	70 e0       	ldi	r23, 0x00	; 0
    912e:	25 e0       	ldi	r18, 0x05	; 5
    9130:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[Axis], PMDTrace3, Axis2PMDAxis(Axis), PMDTracePositionError);
    9134:	c6 01       	movw	r24, r12
    9136:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    913a:	ac 01       	movw	r20, r24
    913c:	c7 01       	movw	r24, r14
    913e:	62 e0       	ldi	r22, 0x02	; 2
    9140:	70 e0       	ldi	r23, 0x00	; 0
    9142:	21 e0       	ldi	r18, 0x01	; 1
    9144:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
	PMDSetTraceVariable(&hAxis[Axis], PMDTrace4, Axis2PMDAxis(Axis), PMDTraceEventStatus);
    9148:	c6 01       	movw	r24, r12
    914a:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    914e:	ac 01       	movw	r20, r24
    9150:	c7 01       	movw	r24, r14
    9152:	63 e0       	ldi	r22, 0x03	; 3
    9154:	70 e0       	ldi	r23, 0x00	; 0
    9156:	2c e0       	ldi	r18, 0x0C	; 12
    9158:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
	
	PMDSetTracePeriod(&hAxis[Axis],200);				//120ms
    915c:	c7 01       	movw	r24, r14
    915e:	68 ec       	ldi	r22, 0xC8	; 200
    9160:	70 e0       	ldi	r23, 0x00	; 0
    9162:	0e 94 e1 79 	call	0xf3c2	; 0xf3c2 <PMDSetTracePeriod>
	PMDSetTraceMode(&hAxis[Axis],PMDTraceOneTime);	
    9166:	c7 01       	movw	r24, r14
    9168:	60 e0       	ldi	r22, 0x00	; 0
    916a:	70 e0       	ldi	r23, 0x00	; 0
    916c:	0e 94 f8 79 	call	0xf3f0	; 0xf3f0 <PMDSetTraceMode>
	PMDSetTraceStop(&hAxis[Axis], Axis2PMDAxis(Axis),  PMDTraceConditionEventStatus, PMDEventMotionCompleteBit, PMDTraceTriggerStateHigh );
    9170:	c6 01       	movw	r24, r12
    9172:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    9176:	bc 01       	movw	r22, r24
    9178:	c7 01       	movw	r24, r14
    917a:	42 e0       	ldi	r20, 0x02	; 2
    917c:	20 e0       	ldi	r18, 0x00	; 0
    917e:	01 e0       	ldi	r16, 0x01	; 1
    9180:	0e 94 79 79 	call	0xf2f2	; 0xf2f2 <PMDSetTraceStop>
	PMDSetTraceStart( &hAxis[Axis], Axis2PMDAxis(Axis), PMDTraceConditionUpdate, 0, 0);
    9184:	c6 01       	movw	r24, r12
    9186:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    918a:	bc 01       	movw	r22, r24
    918c:	c7 01       	movw	r24, r14
    918e:	41 e0       	ldi	r20, 0x01	; 1
    9190:	20 e0       	ldi	r18, 0x00	; 0
    9192:	00 e0       	ldi	r16, 0x00	; 0
    9194:	0e 94 ad 79 	call	0xf35a	; 0xf35a <PMDSetTraceStart>
	
}
    9198:	0f 91       	pop	r16
    919a:	ff 90       	pop	r15
    919c:	ef 90       	pop	r14
    919e:	df 90       	pop	r13
    91a0:	cf 90       	pop	r12
    91a2:	08 95       	ret

000091a4 <Memoryconfig>:



/*****************************************************************************************/
void Memoryconfig(void)
{
    91a4:	cf 93       	push	r28
    91a6:	df 93       	push	r29
    91a8:	c9 e1       	ldi	r28, 0x19	; 25
    91aa:	d5 e7       	ldi	r29, 0x75	; 117
	
	//Defino el Comienzo y la longitud del Buffer de memoria para ambos chipsets
	
	for(axis=0; axis < DOF; axis++)
	{
		if(hAxis[axis].axis == 0)  
    91ac:	8a 81       	ldd	r24, Y+2	; 0x02
    91ae:	9b 81       	ldd	r25, Y+3	; 0x03
    91b0:	89 2b       	or	r24, r25
    91b2:	91 f4       	brne	.+36     	; 0x91d8 <Memoryconfig+0x34>
		{
			PMDSetBufferStart(&hAxis[axis],BUFFER_ID,BUFFER_START);
    91b4:	ce 01       	movw	r24, r28
    91b6:	60 e0       	ldi	r22, 0x00	; 0
    91b8:	70 e0       	ldi	r23, 0x00	; 0
    91ba:	20 e0       	ldi	r18, 0x00	; 0
    91bc:	32 e0       	ldi	r19, 0x02	; 2
    91be:	40 e0       	ldi	r20, 0x00	; 0
    91c0:	50 e0       	ldi	r21, 0x00	; 0
    91c2:	0e 94 4c 7e 	call	0xfc98	; 0xfc98 <PMDSetBufferStart>
			PMDSetBufferLength(&hAxis[axis],BUFFER_ID,BUFFER_LENGTH);
    91c6:	ce 01       	movw	r24, r28
    91c8:	60 e0       	ldi	r22, 0x00	; 0
    91ca:	70 e0       	ldi	r23, 0x00	; 0
    91cc:	2c ef       	ldi	r18, 0xFC	; 252
    91ce:	3f e3       	ldi	r19, 0x3F	; 63
    91d0:	40 e0       	ldi	r20, 0x00	; 0
    91d2:	50 e0       	ldi	r21, 0x00	; 0
    91d4:	0e 94 2a 7e 	call	0xfc54	; 0xfc54 <PMDSetBufferLength>
    91d8:	c0 5a       	subi	r28, 0xA0	; 160
    91da:	df 4f       	sbci	r29, 0xFF	; 255
{
	uint8 axis;
	
	//Defino el Comienzo y la longitud del Buffer de memoria para ambos chipsets
	
	for(axis=0; axis < DOF; axis++)
    91dc:	86 e7       	ldi	r24, 0x76	; 118
    91de:	c9 3f       	cpi	r28, 0xF9	; 249
    91e0:	d8 07       	cpc	r29, r24
    91e2:	21 f7       	brne	.-56     	; 0x91ac <Memoryconfig+0x8>
		{
			PMDSetBufferStart(&hAxis[axis],BUFFER_ID,BUFFER_START);
			PMDSetBufferLength(&hAxis[axis],BUFFER_ID,BUFFER_LENGTH);
		}
	}
}
    91e4:	df 91       	pop	r29
    91e6:	cf 91       	pop	r28
    91e8:	08 95       	ret

000091ea <SetupAxisTrace>:
	PMDSetTraceStart( &hAxis[Axis], Axis2PMDAxis(Axis), PMDTraceConditionUpdate, 0, 0);
	
}
/*****************************************************************************************/
void SetupAxisTrace(tCommand VisualTrace)
{
    91ea:	2f 92       	push	r2
    91ec:	3f 92       	push	r3
    91ee:	4f 92       	push	r4
    91f0:	5f 92       	push	r5
    91f2:	6f 92       	push	r6
    91f4:	7f 92       	push	r7
    91f6:	8f 92       	push	r8
    91f8:	9f 92       	push	r9
    91fa:	af 92       	push	r10
    91fc:	bf 92       	push	r11
    91fe:	cf 92       	push	r12
    9200:	df 92       	push	r13
    9202:	ef 92       	push	r14
    9204:	ff 92       	push	r15
    9206:	0f 93       	push	r16
    9208:	1f 93       	push	r17
    920a:	df 93       	push	r29
    920c:	cf 93       	push	r28
    920e:	cd b7       	in	r28, 0x3d	; 61
    9210:	de b7       	in	r29, 0x3e	; 62
    9212:	a0 97       	sbiw	r28, 0x20	; 32
    9214:	0f b6       	in	r0, 0x3f	; 63
    9216:	f8 94       	cli
    9218:	de bf       	out	0x3e, r29	; 62
    921a:	0f be       	out	0x3f, r0	; 63
    921c:	cd bf       	out	0x3d, r28	; 61
    921e:	39 ac       	ldd	r3, Y+57	; 0x39
    9220:	2a ad       	ldd	r18, Y+58	; 0x3a
    9222:	2c 8f       	std	Y+28, r18	; 0x1c
    9224:	3b ad       	ldd	r19, Y+59	; 0x3b
    9226:	3d 8f       	std	Y+29, r19	; 0x1d
    9228:	8c ad       	ldd	r24, Y+60	; 0x3c
    922a:	8e 8f       	std	Y+30, r24	; 0x1e
    922c:	4d ac       	ldd	r4, Y+61	; 0x3d
    922e:	5e ac       	ldd	r5, Y+62	; 0x3e
    9230:	2f ac       	ldd	r2, Y+63	; 0x3f
	int8 i,Axis,NvaribleVisual,VariableConf;
	
	NvaribleVisual=VisualTrace.Dato;
	printf("SetupAxisTrace=> Numero de variables a configurar %d \n",NvaribleVisual);
    9232:	00 d0       	rcall	.+0      	; 0x9234 <SetupAxisTrace+0x4a>
    9234:	00 d0       	rcall	.+0      	; 0x9236 <SetupAxisTrace+0x4c>
    9236:	86 ee       	ldi	r24, 0xE6	; 230
    9238:	93 e4       	ldi	r25, 0x43	; 67
    923a:	ad b7       	in	r26, 0x3d	; 61
    923c:	be b7       	in	r27, 0x3e	; 62
    923e:	12 96       	adiw	r26, 0x02	; 2
    9240:	9c 93       	st	X, r25
    9242:	8e 93       	st	-X, r24
    9244:	11 97       	sbiw	r26, 0x01	; 1
    9246:	83 2d       	mov	r24, r3
    9248:	99 27       	eor	r25, r25
    924a:	87 fd       	sbrc	r24, 7
    924c:	90 95       	com	r25
    924e:	14 96       	adiw	r26, 0x04	; 4
    9250:	9c 93       	st	X, r25
    9252:	8e 93       	st	-X, r24
    9254:	13 97       	sbiw	r26, 0x03	; 3
    9256:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	Memoryconfig();
    925a:	0f 90       	pop	r0
    925c:	0f 90       	pop	r0
    925e:	0f 90       	pop	r0
    9260:	0f 90       	pop	r0
    9262:	0e 94 d2 48 	call	0x91a4	; 0x91a4 <Memoryconfig>
	printf("SetupAxisTrace=> Ejecute Memoryconfig \n");
    9266:	8d e1       	ldi	r24, 0x1D	; 29
    9268:	94 e4       	ldi	r25, 0x44	; 68
    926a:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	DisableVariable();
    926e:	0e 94 a2 45 	call	0x8b44	; 0x8b44 <DisableVariable>
	printf("SetupAxisTrace=> Ejecute DisableVariable \n");
    9272:	84 e4       	ldi	r24, 0x44	; 68
    9274:	94 e4       	ldi	r25, 0x44	; 68
    9276:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	if(NvaribleVisual>0 && NvaribleVisual <= 8) 
    927a:	83 2d       	mov	r24, r3
    927c:	81 50       	subi	r24, 0x01	; 1
    927e:	88 30       	cpi	r24, 0x08	; 8
    9280:	08 f0       	brcs	.+2      	; 0x9284 <SetupAxisTrace+0x9a>
    9282:	bf c0       	rjmp	.+382    	; 0x9402 <SetupAxisTrace+0x218>
	{
		/*Reiniciamos el contreo de variables configuradas (son globales)*/
		PMD1NVariables=0;
    9284:	10 92 b9 79 	sts	0x79B9, r1
		PMD2NVariables=0;
    9288:	10 92 ba 79 	sts	0x79BA, r1
    928c:	b0 e4       	ldi	r27, 0x40	; 64
    928e:	8b 2e       	mov	r8, r27
    9290:	91 2c       	mov	r9, r1
    9292:	8c 0e       	add	r8, r28
    9294:	9d 1e       	adc	r9, r29
    9296:	ac e0       	ldi	r26, 0x0C	; 12
    9298:	6a 2e       	mov	r6, r26
    929a:	71 2c       	mov	r7, r1
    929c:	6c 0e       	add	r6, r28
    929e:	7d 1e       	adc	r7, r29
    92a0:	ee 24       	eor	r14, r14
		for(i=0;i<NvaribleVisual;i++)
		{
			//Obtenemos el eje a configurar
			Axis=VisualTrace.Tracecomand[i].AxisTrace;
			//Obtenemos a que PMD pertenece, y llevamos la cuenta de la varialies configuradas para cada PMD
			VariableConf=Tracevar2PMDVar(VisualTrace,i);
    92a2:	e5 e3       	ldi	r30, 0x35	; 53
    92a4:	f0 e0       	ldi	r31, 0x00	; 0
    92a6:	ec 0f       	add	r30, r28
    92a8:	fd 1f       	adc	r31, r29
    92aa:	ef 8f       	std	Y+31, r30	; 0x1f
    92ac:	f8 a3       	std	Y+32, r31	; 0x20
    92ae:	a6 c0       	rjmp	.+332    	; 0x93fc <SetupAxisTrace+0x212>
		PMD1NVariables=0;
		PMD2NVariables=0;
		for(i=0;i<NvaribleVisual;i++)
		{
			//Obtenemos el eje a configurar
			Axis=VisualTrace.Tracecomand[i].AxisTrace;
    92b0:	d4 01       	movw	r26, r8
    92b2:	dc 90       	ld	r13, X
			//Obtenemos a que PMD pertenece, y llevamos la cuenta de la varialies configuradas para cada PMD
			VariableConf=Tracevar2PMDVar(VisualTrace,i);
    92b4:	39 ae       	std	Y+57, r3	; 0x39
    92b6:	bc 8d       	ldd	r27, Y+28	; 0x1c
    92b8:	ba af       	std	Y+58, r27	; 0x3a
    92ba:	ed 8d       	ldd	r30, Y+29	; 0x1d
    92bc:	eb af       	std	Y+59, r30	; 0x3b
    92be:	fe 8d       	ldd	r31, Y+30	; 0x1e
    92c0:	fc af       	std	Y+60, r31	; 0x3c
    92c2:	5e ae       	std	Y+62, r5	; 0x3e
    92c4:	4d ae       	std	Y+61, r4	; 0x3d
    92c6:	2f ae       	std	Y+63, r2	; 0x3f
    92c8:	de 01       	movw	r26, r28
    92ca:	11 96       	adiw	r26, 0x01	; 1
    92cc:	8f 8d       	ldd	r24, Y+31	; 0x1f
    92ce:	98 a1       	ldd	r25, Y+32	; 0x20
    92d0:	fc 01       	movw	r30, r24
    92d2:	8b e1       	ldi	r24, 0x1B	; 27
    92d4:	01 90       	ld	r0, Z+
    92d6:	0d 92       	st	X+, r0
    92d8:	81 50       	subi	r24, 0x01	; 1
    92da:	e1 f7       	brne	.-8      	; 0x92d4 <SetupAxisTrace+0xea>
{
	int8 Result,Axis;
	
	
	Axis=VisualTrace.Tracecomand[TracevarIndex].AxisTrace;
	if(Axis==AxisRoll) 
    92dc:	d3 01       	movw	r26, r6
    92de:	8c 91       	ld	r24, X
    92e0:	84 30       	cpi	r24, 0x04	; 4
    92e2:	31 f4       	brne	.+12     	; 0x92f0 <SetupAxisTrace+0x106>
	{
		Result=PMD2NVariables;
    92e4:	00 91 ba 79 	lds	r16, 0x79BA
		PMD2NVariables++;
    92e8:	0f 5f       	subi	r16, 0xFF	; 255
    92ea:	00 93 ba 79 	sts	0x79BA, r16
    92ee:	05 c0       	rjmp	.+10     	; 0x92fa <SetupAxisTrace+0x110>
	}
	else
	{
		Result=PMD1NVariables;
    92f0:	00 91 b9 79 	lds	r16, 0x79B9
		PMD1NVariables++;
    92f4:	0f 5f       	subi	r16, 0xFF	; 255
    92f6:	00 93 b9 79 	sts	0x79B9, r16
    92fa:	01 50       	subi	r16, 0x01	; 1
		{
			//Obtenemos el eje a configurar
			Axis=VisualTrace.Tracecomand[i].AxisTrace;
			//Obtenemos a que PMD pertenece, y llevamos la cuenta de la varialies configuradas para cada PMD
			VariableConf=Tracevar2PMDVar(VisualTrace,i);
			printf("SetupAxisTrace=> Configurando la variable %d = al CMD # %d en el EJE %s \n",VariableConf,VisualTrace.Tracecomand[i].TraceVar,AxisName(Axis));
    92fc:	f4 01       	movw	r30, r8
    92fe:	f1 80       	ldd	r15, Z+1	; 0x01
    9300:	ad 2c       	mov	r10, r13
    9302:	bb 24       	eor	r11, r11
    9304:	a7 fc       	sbrc	r10, 7
    9306:	b0 94       	com	r11
    9308:	c5 01       	movw	r24, r10
    930a:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    930e:	2d b7       	in	r18, 0x3d	; 61
    9310:	3e b7       	in	r19, 0x3e	; 62
    9312:	28 50       	subi	r18, 0x08	; 8
    9314:	30 40       	sbci	r19, 0x00	; 0
    9316:	0f b6       	in	r0, 0x3f	; 63
    9318:	f8 94       	cli
    931a:	3e bf       	out	0x3e, r19	; 62
    931c:	0f be       	out	0x3f, r0	; 63
    931e:	2d bf       	out	0x3d, r18	; 61
    9320:	ed b7       	in	r30, 0x3d	; 61
    9322:	fe b7       	in	r31, 0x3e	; 62
    9324:	31 96       	adiw	r30, 0x01	; 1
    9326:	2e e6       	ldi	r18, 0x6E	; 110
    9328:	34 e4       	ldi	r19, 0x44	; 68
    932a:	ad b7       	in	r26, 0x3d	; 61
    932c:	be b7       	in	r27, 0x3e	; 62
    932e:	12 96       	adiw	r26, 0x02	; 2
    9330:	3c 93       	st	X, r19
    9332:	2e 93       	st	-X, r18
    9334:	11 97       	sbiw	r26, 0x01	; 1
    9336:	11 27       	eor	r17, r17
    9338:	07 fd       	sbrc	r16, 7
    933a:	10 95       	com	r17
    933c:	13 83       	std	Z+3, r17	; 0x03
    933e:	02 83       	std	Z+2, r16	; 0x02
    9340:	2f 2d       	mov	r18, r15
    9342:	33 27       	eor	r19, r19
    9344:	27 fd       	sbrc	r18, 7
    9346:	30 95       	com	r19
    9348:	35 83       	std	Z+5, r19	; 0x05
    934a:	24 83       	std	Z+4, r18	; 0x04
    934c:	97 83       	std	Z+7, r25	; 0x07
    934e:	86 83       	std	Z+6, r24	; 0x06
    9350:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDSetTraceVariable(&hAxis[Axis],VariableConf,Axis2PMDAxis(Axis),VisualTrace.Tracecomand[i].TraceVar); 
    9354:	3d 2d       	mov	r19, r13
    9356:	80 e6       	ldi	r24, 0x60	; 96
    9358:	38 02       	muls	r19, r24
    935a:	60 01       	movw	r12, r0
    935c:	11 24       	eor	r1, r1
    935e:	a9 e1       	ldi	r26, 0x19	; 25
    9360:	b5 e7       	ldi	r27, 0x75	; 117
    9362:	ca 0e       	add	r12, r26
    9364:	db 1e       	adc	r13, r27
    9366:	ed b7       	in	r30, 0x3d	; 61
    9368:	fe b7       	in	r31, 0x3e	; 62
    936a:	38 96       	adiw	r30, 0x08	; 8
    936c:	0f b6       	in	r0, 0x3f	; 63
    936e:	f8 94       	cli
    9370:	fe bf       	out	0x3e, r31	; 62
    9372:	0f be       	out	0x3f, r0	; 63
    9374:	ed bf       	out	0x3d, r30	; 61
    9376:	c5 01       	movw	r24, r10
    9378:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    937c:	ac 01       	movw	r20, r24
    937e:	c6 01       	movw	r24, r12
    9380:	b8 01       	movw	r22, r16
    9382:	2f 2d       	mov	r18, r15
    9384:	0e 94 df 7c 	call	0xf9be	; 0xf9be <PMDSetTraceVariable>
			printf("SetupAxisTrace=> Configurando  Sample Trace_time %d \n",VisualTrace.TraceTime);		
    9388:	00 d0       	rcall	.+0      	; 0x938a <SetupAxisTrace+0x1a0>
    938a:	00 d0       	rcall	.+0      	; 0x938c <SetupAxisTrace+0x1a2>
    938c:	e8 eb       	ldi	r30, 0xB8	; 184
    938e:	f4 e4       	ldi	r31, 0x44	; 68
    9390:	ad b7       	in	r26, 0x3d	; 61
    9392:	be b7       	in	r27, 0x3e	; 62
    9394:	12 96       	adiw	r26, 0x02	; 2
    9396:	fc 93       	st	X, r31
    9398:	ee 93       	st	-X, r30
    939a:	11 97       	sbiw	r26, 0x01	; 1
    939c:	14 96       	adiw	r26, 0x04	; 4
    939e:	5c 92       	st	X, r5
    93a0:	4e 92       	st	-X, r4
    93a2:	13 97       	sbiw	r26, 0x03	; 3
    93a4:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDSetTracePeriod(&hAxis[Axis],VisualTrace.TraceTime);
    93a8:	0f 90       	pop	r0
    93aa:	0f 90       	pop	r0
    93ac:	0f 90       	pop	r0
    93ae:	0f 90       	pop	r0
    93b0:	c6 01       	movw	r24, r12
    93b2:	b2 01       	movw	r22, r4
    93b4:	0e 94 e1 79 	call	0xf3c2	; 0xf3c2 <PMDSetTracePeriod>
			PMDSetTraceMode(&hAxis[Axis],PMDTraceOneTime);	
    93b8:	c6 01       	movw	r24, r12
    93ba:	60 e0       	ldi	r22, 0x00	; 0
    93bc:	70 e0       	ldi	r23, 0x00	; 0
    93be:	0e 94 f8 79 	call	0xf3f0	; 0xf3f0 <PMDSetTraceMode>
			if(VisualTrace.TraceTraj==0)
    93c2:	22 20       	and	r2, r2
    93c4:	51 f4       	brne	.+20     	; 0x93da <SetupAxisTrace+0x1f0>
				PMDSetTraceStop(&hAxis[Axis], Axis2PMDAxis(Axis),  PMDTraceConditionEventStatus, PMDEventMotionCompleteBit, PMDTraceTriggerStateHigh );
    93c6:	c5 01       	movw	r24, r10
    93c8:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    93cc:	bc 01       	movw	r22, r24
    93ce:	c6 01       	movw	r24, r12
    93d0:	42 e0       	ldi	r20, 0x02	; 2
    93d2:	20 e0       	ldi	r18, 0x00	; 0
    93d4:	01 e0       	ldi	r16, 0x01	; 1
    93d6:	0e 94 79 79 	call	0xf2f2	; 0xf2f2 <PMDSetTraceStop>
			PMDSetTraceStart( &hAxis[Axis], Axis2PMDAxis(Axis), PMDTraceConditionUpdate, BUFFER_ID, PMDTraceTriggerStateHigh );
    93da:	c5 01       	movw	r24, r10
    93dc:	0e 94 db 7e 	call	0xfdb6	; 0xfdb6 <Axis2PMDAxis>
    93e0:	bc 01       	movw	r22, r24
    93e2:	c6 01       	movw	r24, r12
    93e4:	41 e0       	ldi	r20, 0x01	; 1
    93e6:	20 e0       	ldi	r18, 0x00	; 0
    93e8:	01 e0       	ldi	r16, 0x01	; 1
    93ea:	0e 94 ad 79 	call	0xf35a	; 0xf35a <PMDSetTraceStart>
	if(NvaribleVisual>0 && NvaribleVisual <= 8) 
	{
		/*Reiniciamos el contreo de variables configuradas (son globales)*/
		PMD1NVariables=0;
		PMD2NVariables=0;
		for(i=0;i<NvaribleVisual;i++)
    93ee:	e3 94       	inc	r14
    93f0:	22 e0       	ldi	r18, 0x02	; 2
    93f2:	30 e0       	ldi	r19, 0x00	; 0
    93f4:	82 0e       	add	r8, r18
    93f6:	93 1e       	adc	r9, r19
    93f8:	62 0e       	add	r6, r18
    93fa:	73 1e       	adc	r7, r19
    93fc:	e3 14       	cp	r14, r3
    93fe:	0c f4       	brge	.+2      	; 0x9402 <SetupAxisTrace+0x218>
    9400:	57 cf       	rjmp	.-338    	; 0x92b0 <SetupAxisTrace+0xc6>
				PMDSetTraceStop(&hAxis[Axis], Axis2PMDAxis(Axis),  PMDTraceConditionEventStatus, PMDEventMotionCompleteBit, PMDTraceTriggerStateHigh );
			PMDSetTraceStart( &hAxis[Axis], Axis2PMDAxis(Axis), PMDTraceConditionUpdate, BUFFER_ID, PMDTraceTriggerStateHigh );
		}
		
	}
}
    9402:	a0 96       	adiw	r28, 0x20	; 32
    9404:	0f b6       	in	r0, 0x3f	; 63
    9406:	f8 94       	cli
    9408:	de bf       	out	0x3e, r29	; 62
    940a:	0f be       	out	0x3f, r0	; 63
    940c:	cd bf       	out	0x3d, r28	; 61
    940e:	cf 91       	pop	r28
    9410:	df 91       	pop	r29
    9412:	1f 91       	pop	r17
    9414:	0f 91       	pop	r16
    9416:	ff 90       	pop	r15
    9418:	ef 90       	pop	r14
    941a:	df 90       	pop	r13
    941c:	cf 90       	pop	r12
    941e:	bf 90       	pop	r11
    9420:	af 90       	pop	r10
    9422:	9f 90       	pop	r9
    9424:	8f 90       	pop	r8
    9426:	7f 90       	pop	r7
    9428:	6f 90       	pop	r6
    942a:	5f 90       	pop	r5
    942c:	4f 90       	pop	r4
    942e:	3f 90       	pop	r3
    9430:	2f 90       	pop	r2
    9432:	08 95       	ret

00009434 <max>:
	
}

/**********************************************************************************************************************/
PMDint32 max(PMDint32 a, PMDint32 b)
{
    9434:	ef 92       	push	r14
    9436:	ff 92       	push	r15
    9438:	0f 93       	push	r16
    943a:	1f 93       	push	r17
    943c:	7b 01       	movw	r14, r22
    943e:	8c 01       	movw	r16, r24
    9440:	c9 01       	movw	r24, r18
    9442:	da 01       	movw	r26, r20
    9444:	9c 01       	movw	r18, r24
    9446:	ad 01       	movw	r20, r26
    9448:	2e 15       	cp	r18, r14
    944a:	3f 05       	cpc	r19, r15
    944c:	40 07       	cpc	r20, r16
    944e:	51 07       	cpc	r21, r17
    9450:	14 f4       	brge	.+4      	; 0x9456 <max+0x22>
    9452:	a8 01       	movw	r20, r16
    9454:	97 01       	movw	r18, r14
	if (a > b) 
		return a;
	else
		return b;
}
    9456:	b9 01       	movw	r22, r18
    9458:	ca 01       	movw	r24, r20
    945a:	1f 91       	pop	r17
    945c:	0f 91       	pop	r16
    945e:	ff 90       	pop	r15
    9460:	ef 90       	pop	r14
    9462:	08 95       	ret

00009464 <min>:

/**********************************************************************************************************************/
PMDint32 min(PMDint32 a, PMDint32 b)
{
    9464:	ef 92       	push	r14
    9466:	ff 92       	push	r15
    9468:	0f 93       	push	r16
    946a:	1f 93       	push	r17
    946c:	7b 01       	movw	r14, r22
    946e:	8c 01       	movw	r16, r24
    9470:	c9 01       	movw	r24, r18
    9472:	da 01       	movw	r26, r20
    9474:	9c 01       	movw	r18, r24
    9476:	ad 01       	movw	r20, r26
    9478:	e2 16       	cp	r14, r18
    947a:	f3 06       	cpc	r15, r19
    947c:	04 07       	cpc	r16, r20
    947e:	15 07       	cpc	r17, r21
    9480:	14 f4       	brge	.+4      	; 0x9486 <min+0x22>
    9482:	a8 01       	movw	r20, r16
    9484:	97 01       	movw	r18, r14
	if (a < b) 
		return a;
	else
		return b;
}
    9486:	b9 01       	movw	r22, r18
    9488:	ca 01       	movw	r24, r20
    948a:	1f 91       	pop	r17
    948c:	0f 91       	pop	r16
    948e:	ff 90       	pop	r15
    9490:	ef 90       	pop	r14
    9492:	08 95       	ret

00009494 <AjustarPosicionActual>:
	
}

/**********************************************************************************************************************/
void AjustarPosicionActual(tAxis Axis, PMDint32 AJUSTE)
{
    9494:	cf 92       	push	r12
    9496:	df 92       	push	r13
    9498:	ef 92       	push	r14
    949a:	ff 92       	push	r15
    949c:	0f 93       	push	r16
    949e:	1f 93       	push	r17
    94a0:	df 93       	push	r29
    94a2:	cf 93       	push	r28
    94a4:	cd b7       	in	r28, 0x3d	; 61
    94a6:	de b7       	in	r29, 0x3e	; 62
    94a8:	28 97       	sbiw	r28, 0x08	; 8
    94aa:	0f b6       	in	r0, 0x3f	; 63
    94ac:	f8 94       	cli
    94ae:	de bf       	out	0x3e, r29	; 62
    94b0:	0f be       	out	0x3f, r0	; 63
    94b2:	cd bf       	out	0x3d, r28	; 61
    94b4:	6a 01       	movw	r12, r20
    94b6:	7b 01       	movw	r14, r22
	PMDint32 registro_posicion, registro_encoder, AJUSTE_MODIFICADO;
	
	PMDGetPosition(&hAxis[Axis], &registro_posicion);
    94b8:	20 e6       	ldi	r18, 0x60	; 96
    94ba:	30 e0       	ldi	r19, 0x00	; 0
    94bc:	82 9f       	mul	r24, r18
    94be:	80 01       	movw	r16, r0
    94c0:	83 9f       	mul	r24, r19
    94c2:	10 0d       	add	r17, r0
    94c4:	92 9f       	mul	r25, r18
    94c6:	10 0d       	add	r17, r0
    94c8:	11 24       	eor	r1, r1
    94ca:	07 5e       	subi	r16, 0xE7	; 231
    94cc:	1a 48       	sbci	r17, 0x8A	; 138
    94ce:	c8 01       	movw	r24, r16
    94d0:	be 01       	movw	r22, r28
    94d2:	6f 5f       	subi	r22, 0xFF	; 255
    94d4:	7f 4f       	sbci	r23, 0xFF	; 255
    94d6:	0e 94 84 7b 	call	0xf708	; 0xf708 <PMDGetPosition>
	//Se halla el nuevo valor de AJUSTE.
	PMDGetActualPosition(&hAxis[Axis],&registro_encoder);
    94da:	c8 01       	movw	r24, r16
    94dc:	be 01       	movw	r22, r28
    94de:	6b 5f       	subi	r22, 0xFB	; 251
    94e0:	7f 4f       	sbci	r23, 0xFF	; 255
    94e2:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
	
	if(registro_posicion >  0)	  //no pasa nada							
    94e6:	89 81       	ldd	r24, Y+1	; 0x01
    94e8:	9a 81       	ldd	r25, Y+2	; 0x02
    94ea:	ab 81       	ldd	r26, Y+3	; 0x03
    94ec:	bc 81       	ldd	r27, Y+4	; 0x04
    94ee:	18 16       	cp	r1, r24
    94f0:	19 06       	cpc	r1, r25
    94f2:	1a 06       	cpc	r1, r26
    94f4:	1b 06       	cpc	r1, r27
    94f6:	24 f4       	brge	.+8      	; 0x9500 <AjustarPosicionActual+0x6c>
	{
		
		//Ajustar el registro de posicin actual con el valor de AJUSTE.
		PMDAdjustActualPosition(&hAxis[Axis],AJUSTE);
    94f8:	c8 01       	movw	r24, r16
    94fa:	b7 01       	movw	r22, r14
    94fc:	a6 01       	movw	r20, r12
    94fe:	10 c0       	rjmp	.+32     	; 0x9520 <AjustarPosicionActual+0x8c>
	}
	else //El movimiento anterior fu negativo.
	{
		//Cargar el registro de posicin actual con cero.
		PMDSetActualPosition(&hAxis[Axis],0);
    9500:	c8 01       	movw	r24, r16
    9502:	40 e0       	ldi	r20, 0x00	; 0
    9504:	50 e0       	ldi	r21, 0x00	; 0
    9506:	60 e0       	ldi	r22, 0x00	; 0
    9508:	70 e0       	ldi	r23, 0x00	; 0
    950a:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>
		
		AJUSTE_MODIFICADO = AJUSTE + registro_encoder;
		
		
		//Ajustar el registro de posicin actual con el valor de AJUSTE_MODIFICADO.
		PMDAdjustActualPosition(&hAxis[Axis],AJUSTE_MODIFICADO);		
    950e:	4d 81       	ldd	r20, Y+5	; 0x05
    9510:	5e 81       	ldd	r21, Y+6	; 0x06
    9512:	6f 81       	ldd	r22, Y+7	; 0x07
    9514:	78 85       	ldd	r23, Y+8	; 0x08
    9516:	4c 0d       	add	r20, r12
    9518:	5d 1d       	adc	r21, r13
    951a:	6e 1d       	adc	r22, r14
    951c:	7f 1d       	adc	r23, r15
    951e:	c8 01       	movw	r24, r16
    9520:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>
		
	}
	
	
}
    9524:	28 96       	adiw	r28, 0x08	; 8
    9526:	0f b6       	in	r0, 0x3f	; 63
    9528:	f8 94       	cli
    952a:	de bf       	out	0x3e, r29	; 62
    952c:	0f be       	out	0x3f, r0	; 63
    952e:	cd bf       	out	0x3d, r28	; 61
    9530:	cf 91       	pop	r28
    9532:	df 91       	pop	r29
    9534:	1f 91       	pop	r17
    9536:	0f 91       	pop	r16
    9538:	ff 90       	pop	r15
    953a:	ef 90       	pop	r14
    953c:	df 90       	pop	r13
    953e:	cf 90       	pop	r12
    9540:	08 95       	ret

00009542 <SetPosicionActual>:
	}
}
 
/**********************************************************************************************************************/
void SetPosicionActual(tAxis Axis, PMDint32 AJUSTE)
{
    9542:	cf 92       	push	r12
    9544:	df 92       	push	r13
    9546:	ef 92       	push	r14
    9548:	ff 92       	push	r15
    954a:	0f 93       	push	r16
    954c:	1f 93       	push	r17
    954e:	9c 01       	movw	r18, r24
    9550:	6a 01       	movw	r12, r20
    9552:	7b 01       	movw	r14, r22
	if(AJUSTE >=  0)								
    9554:	77 fd       	sbrc	r23, 7
    9556:	11 c0       	rjmp	.+34     	; 0x957a <SetPosicionActual+0x38>
	{
		
		PMDSetActualPosition(&hAxis[Axis],AJUSTE);
    9558:	80 e6       	ldi	r24, 0x60	; 96
    955a:	90 e0       	ldi	r25, 0x00	; 0
    955c:	ac 01       	movw	r20, r24
    955e:	24 9f       	mul	r18, r20
    9560:	c0 01       	movw	r24, r0
    9562:	25 9f       	mul	r18, r21
    9564:	90 0d       	add	r25, r0
    9566:	34 9f       	mul	r19, r20
    9568:	90 0d       	add	r25, r0
    956a:	11 24       	eor	r1, r1
    956c:	87 5e       	subi	r24, 0xE7	; 231
    956e:	9a 48       	sbci	r25, 0x8A	; 138
    9570:	b7 01       	movw	r22, r14
    9572:	a6 01       	movw	r20, r12
    9574:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>
    9578:	17 c0       	rjmp	.+46     	; 0x95a8 <SetPosicionActual+0x66>
	}
	else //Valor a cargar es negativo.
	{
		//Cargar el registro de posicin actual con cero.
		PMDSetActualPosition(&hAxis[Axis],0);
    957a:	80 e6       	ldi	r24, 0x60	; 96
    957c:	90 e0       	ldi	r25, 0x00	; 0
    957e:	28 9f       	mul	r18, r24
    9580:	80 01       	movw	r16, r0
    9582:	29 9f       	mul	r18, r25
    9584:	10 0d       	add	r17, r0
    9586:	38 9f       	mul	r19, r24
    9588:	10 0d       	add	r17, r0
    958a:	11 24       	eor	r1, r1
    958c:	07 5e       	subi	r16, 0xE7	; 231
    958e:	1a 48       	sbci	r17, 0x8A	; 138
    9590:	c8 01       	movw	r24, r16
    9592:	40 e0       	ldi	r20, 0x00	; 0
    9594:	50 e0       	ldi	r21, 0x00	; 0
    9596:	60 e0       	ldi	r22, 0x00	; 0
    9598:	70 e0       	ldi	r23, 0x00	; 0
    959a:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>
		
		//Ajustar el registro de posicin actual con el valor de AJUSTE.
		PMDAdjustActualPosition(&hAxis[Axis],AJUSTE);		
    959e:	c8 01       	movw	r24, r16
    95a0:	b7 01       	movw	r22, r14
    95a2:	a6 01       	movw	r20, r12
    95a4:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>
		
	}
	
	
}
    95a8:	1f 91       	pop	r17
    95aa:	0f 91       	pop	r16
    95ac:	ff 90       	pop	r15
    95ae:	ef 90       	pop	r14
    95b0:	df 90       	pop	r13
    95b2:	cf 90       	pop	r12
    95b4:	08 95       	ret

000095b6 <No_limit_switch>:
	
}

/**********************************************************************************************************************/
void No_limit_switch(int Ini_Axis)
{
    95b6:	4f 92       	push	r4
    95b8:	5f 92       	push	r5
    95ba:	6f 92       	push	r6
    95bc:	7f 92       	push	r7
    95be:	8f 92       	push	r8
    95c0:	9f 92       	push	r9
    95c2:	af 92       	push	r10
    95c4:	bf 92       	push	r11
    95c6:	cf 92       	push	r12
    95c8:	df 92       	push	r13
    95ca:	ef 92       	push	r14
    95cc:	ff 92       	push	r15
    95ce:	0f 93       	push	r16
    95d0:	1f 93       	push	r17
    95d2:	df 93       	push	r29
    95d4:	cf 93       	push	r28
    95d6:	00 d0       	rcall	.+0      	; 0x95d8 <No_limit_switch+0x22>
    95d8:	cd b7       	in	r28, 0x3d	; 61
    95da:	de b7       	in	r29, 0x3e	; 62
	PMDuint16 Axis,Limit_switch;
	
	//No se toma en cuenta roll ya que carese de sentido
	if(Ini_Axis!=AxisRoll)
    95dc:	84 30       	cpi	r24, 0x04	; 4
    95de:	91 05       	cpc	r25, r1
    95e0:	09 f4       	brne	.+2      	; 0x95e4 <No_limit_switch+0x2e>
    95e2:	92 c0       	rjmp	.+292    	; 0x9708 <No_limit_switch+0x152>
	{
		for(Axis=(Ini_Axis);Axis<DOF;Axis++)
    95e4:	8c 01       	movw	r16, r24
    95e6:	80 e6       	ldi	r24, 0x60	; 96
    95e8:	90 e0       	ldi	r25, 0x00	; 0
    95ea:	08 9f       	mul	r16, r24
    95ec:	70 01       	movw	r14, r0
    95ee:	09 9f       	mul	r16, r25
    95f0:	f0 0c       	add	r15, r0
    95f2:	18 9f       	mul	r17, r24
    95f4:	f0 0c       	add	r15, r0
    95f6:	11 24       	eor	r1, r1
    95f8:	29 e1       	ldi	r18, 0x19	; 25
    95fa:	35 e7       	ldi	r19, 0x75	; 117
    95fc:	e2 0e       	add	r14, r18
    95fe:	f3 1e       	adc	r15, r19
		{
			PMDGetSignalStatus(&hAxis[Axis],&Limit_switch); 
    9600:	2e 01       	movw	r4, r28
    9602:	08 94       	sec
    9604:	41 1c       	adc	r4, r1
    9606:	51 1c       	adc	r5, r1
			printf("No_limit_switch=> sensando de limites eje %s  en No_limit_switch = 0x%x\n ",AxisName(Axis),Limit_switch);
    9608:	2e ee       	ldi	r18, 0xEE	; 238
    960a:	62 2e       	mov	r6, r18
    960c:	24 e4       	ldi	r18, 0x44	; 68
    960e:	72 2e       	mov	r7, r18
			if(!((Limit_switch & PMDSignalPositiveLimitMask)!=0))//El lmite positivo est activo (presionado).
			{
				if(Axis!=AxisRoll)
				{
					printf("No_limit_switch=> Limites Positivo activado por el  eje %s\n ",AxisName(Axis));
    9610:	98 e3       	ldi	r25, 0x38	; 56
    9612:	89 2e       	mov	r8, r25
    9614:	95 e4       	ldi	r25, 0x45	; 69
    9616:	99 2e       	mov	r9, r25
			}		
			if(!((Limit_switch & PMDSignalNegativeLimitMask)!=0))
			{
				if(Axis!=AxisRoll)
				{
					printf("No_limit_switch=> Limites Negativo activado por el  eje %s\n ",AxisName(Axis));
    9618:	89 ec       	ldi	r24, 0xC9	; 201
    961a:	a8 2e       	mov	r10, r24
    961c:	85 e4       	ldi	r24, 0x45	; 69
    961e:	b8 2e       	mov	r11, r24
    9620:	6f c0       	rjmp	.+222    	; 0x9700 <No_limit_switch+0x14a>
	//No se toma en cuenta roll ya que carese de sentido
	if(Ini_Axis!=AxisRoll)
	{
		for(Axis=(Ini_Axis);Axis<DOF;Axis++)
		{
			PMDGetSignalStatus(&hAxis[Axis],&Limit_switch); 
    9622:	c7 01       	movw	r24, r14
    9624:	b2 01       	movw	r22, r4
    9626:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
    962a:	d0 2e       	mov	r13, r16
    962c:	c1 2e       	mov	r12, r17
			printf("No_limit_switch=> sensando de limites eje %s  en No_limit_switch = 0x%x\n ",AxisName(Axis),Limit_switch);
    962e:	c8 01       	movw	r24, r16
    9630:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    9634:	00 d0       	rcall	.+0      	; 0x9636 <No_limit_switch+0x80>
    9636:	00 d0       	rcall	.+0      	; 0x9638 <No_limit_switch+0x82>
    9638:	00 d0       	rcall	.+0      	; 0x963a <No_limit_switch+0x84>
    963a:	ed b7       	in	r30, 0x3d	; 61
    963c:	fe b7       	in	r31, 0x3e	; 62
    963e:	31 96       	adiw	r30, 0x01	; 1
    9640:	ad b7       	in	r26, 0x3d	; 61
    9642:	be b7       	in	r27, 0x3e	; 62
    9644:	12 96       	adiw	r26, 0x02	; 2
    9646:	7c 92       	st	X, r7
    9648:	6e 92       	st	-X, r6
    964a:	11 97       	sbiw	r26, 0x01	; 1
    964c:	93 83       	std	Z+3, r25	; 0x03
    964e:	82 83       	std	Z+2, r24	; 0x02
    9650:	89 81       	ldd	r24, Y+1	; 0x01
    9652:	9a 81       	ldd	r25, Y+2	; 0x02
    9654:	95 83       	std	Z+5, r25	; 0x05
    9656:	84 83       	std	Z+4, r24	; 0x04
    9658:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			if(!((Limit_switch & PMDSignalPositiveLimitMask)!=0))//El lmite positivo est activo (presionado).
    965c:	89 81       	ldd	r24, Y+1	; 0x01
    965e:	ed b7       	in	r30, 0x3d	; 61
    9660:	fe b7       	in	r31, 0x3e	; 62
    9662:	36 96       	adiw	r30, 0x06	; 6
    9664:	0f b6       	in	r0, 0x3f	; 63
    9666:	f8 94       	cli
    9668:	fe bf       	out	0x3e, r31	; 62
    966a:	0f be       	out	0x3f, r0	; 63
    966c:	ed bf       	out	0x3d, r30	; 61
    966e:	84 fd       	sbrc	r24, 4
    9670:	20 c0       	rjmp	.+64     	; 0x96b2 <No_limit_switch+0xfc>
			{
				if(Axis!=AxisRoll)
    9672:	04 30       	cpi	r16, 0x04	; 4
    9674:	11 05       	cpc	r17, r1
    9676:	c9 f0       	breq	.+50     	; 0x96aa <No_limit_switch+0xf4>
				{
					printf("No_limit_switch=> Limites Positivo activado por el  eje %s\n ",AxisName(Axis));
    9678:	c8 01       	movw	r24, r16
    967a:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    967e:	00 d0       	rcall	.+0      	; 0x9680 <No_limit_switch+0xca>
    9680:	00 d0       	rcall	.+0      	; 0x9682 <No_limit_switch+0xcc>
    9682:	ad b7       	in	r26, 0x3d	; 61
    9684:	be b7       	in	r27, 0x3e	; 62
    9686:	12 96       	adiw	r26, 0x02	; 2
    9688:	9c 92       	st	X, r9
    968a:	8e 92       	st	-X, r8
    968c:	11 97       	sbiw	r26, 0x01	; 1
    968e:	14 96       	adiw	r26, 0x04	; 4
    9690:	9c 93       	st	X, r25
    9692:	8e 93       	st	-X, r24
    9694:	13 97       	sbiw	r26, 0x03	; 3
    9696:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
					Positivehandling(Axis);	
    969a:	0f 90       	pop	r0
    969c:	0f 90       	pop	r0
    969e:	0f 90       	pop	r0
    96a0:	0f 90       	pop	r0
    96a2:	c8 01       	movw	r24, r16
    96a4:	0e 94 86 73 	call	0xe70c	; 0xe70c <Positivehandling>
    96a8:	04 c0       	rjmp	.+8      	; 0x96b2 <No_limit_switch+0xfc>
				}
				else
				{	
					//Tiene que estar desconectado o hubo un error con el movimiento de pitch, pues pitch tiene los
					//mismo interuptores.
					printf("No_limit_switch=> Cable #2 de Sensores esta DESCONECTADO! limite positivo activado \n");
    96aa:	85 e7       	ldi	r24, 0x75	; 117
    96ac:	95 e4       	ldi	r25, 0x45	; 69
    96ae:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
				}
			}		
			if(!((Limit_switch & PMDSignalNegativeLimitMask)!=0))
    96b2:	89 81       	ldd	r24, Y+1	; 0x01
    96b4:	85 fd       	sbrc	r24, 5
    96b6:	1e c0       	rjmp	.+60     	; 0x96f4 <No_limit_switch+0x13e>
			{
				if(Axis!=AxisRoll)
    96b8:	04 30       	cpi	r16, 0x04	; 4
    96ba:	11 05       	cpc	r17, r1
    96bc:	b9 f0       	breq	.+46     	; 0x96ec <No_limit_switch+0x136>
				{
					printf("No_limit_switch=> Limites Negativo activado por el  eje %s\n ",AxisName(Axis));
    96be:	8d 2d       	mov	r24, r13
    96c0:	9c 2d       	mov	r25, r12
    96c2:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    96c6:	00 d0       	rcall	.+0      	; 0x96c8 <No_limit_switch+0x112>
    96c8:	00 d0       	rcall	.+0      	; 0x96ca <No_limit_switch+0x114>
    96ca:	ed b7       	in	r30, 0x3d	; 61
    96cc:	fe b7       	in	r31, 0x3e	; 62
    96ce:	b2 82       	std	Z+2, r11	; 0x02
    96d0:	a1 82       	std	Z+1, r10	; 0x01
    96d2:	94 83       	std	Z+4, r25	; 0x04
    96d4:	83 83       	std	Z+3, r24	; 0x03
    96d6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
					Negativehandling(Axis);	
    96da:	0f 90       	pop	r0
    96dc:	0f 90       	pop	r0
    96de:	0f 90       	pop	r0
    96e0:	0f 90       	pop	r0
    96e2:	8d 2d       	mov	r24, r13
    96e4:	9c 2d       	mov	r25, r12
    96e6:	0e 94 65 72 	call	0xe4ca	; 0xe4ca <Negativehandling>
    96ea:	04 c0       	rjmp	.+8      	; 0x96f4 <No_limit_switch+0x13e>
				}
				else
				{
					//Tiene que estar desconectado o hubo un error con el movimiento de pitch, pues pitch tiene los
					//mismo interuptores.
					printf("No_limit_switch=> Cable #2 de Sensores esta DESCONECTADO! limite negativo activado \n");
    96ec:	86 e0       	ldi	r24, 0x06	; 6
    96ee:	96 e4       	ldi	r25, 0x46	; 70
    96f0:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	PMDuint16 Axis,Limit_switch;
	
	//No se toma en cuenta roll ya que carese de sentido
	if(Ini_Axis!=AxisRoll)
	{
		for(Axis=(Ini_Axis);Axis<DOF;Axis++)
    96f4:	0f 5f       	subi	r16, 0xFF	; 255
    96f6:	1f 4f       	sbci	r17, 0xFF	; 255
    96f8:	20 e6       	ldi	r18, 0x60	; 96
    96fa:	30 e0       	ldi	r19, 0x00	; 0
    96fc:	e2 0e       	add	r14, r18
    96fe:	f3 1e       	adc	r15, r19
    9700:	05 30       	cpi	r16, 0x05	; 5
    9702:	11 05       	cpc	r17, r1
    9704:	08 f4       	brcc	.+2      	; 0x9708 <No_limit_switch+0x152>
    9706:	8d cf       	rjmp	.-230    	; 0x9622 <No_limit_switch+0x6c>
				
			}
		}
	}
	
	printf("No_limit_switch=> END! \n");
    9708:	8a e5       	ldi	r24, 0x5A	; 90
    970a:	96 e4       	ldi	r25, 0x46	; 70
    970c:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
} 
    9710:	0f 90       	pop	r0
    9712:	0f 90       	pop	r0
    9714:	cf 91       	pop	r28
    9716:	df 91       	pop	r29
    9718:	1f 91       	pop	r17
    971a:	0f 91       	pop	r16
    971c:	ff 90       	pop	r15
    971e:	ef 90       	pop	r14
    9720:	df 90       	pop	r13
    9722:	cf 90       	pop	r12
    9724:	bf 90       	pop	r11
    9726:	af 90       	pop	r10
    9728:	9f 90       	pop	r9
    972a:	8f 90       	pop	r8
    972c:	7f 90       	pop	r7
    972e:	6f 90       	pop	r6
    9730:	5f 90       	pop	r5
    9732:	4f 90       	pop	r4
    9734:	08 95       	ret

00009736 <ObtenerPose>:



/**********************************************************************************************************************/
void ObtenerPose(PoseRobot *Pose)
{
    9736:	cf 92       	push	r12
    9738:	df 92       	push	r13
    973a:	ef 92       	push	r14
    973c:	ff 92       	push	r15
    973e:	0f 93       	push	r16
    9740:	1f 93       	push	r17
    9742:	df 93       	push	r29
    9744:	cf 93       	push	r28
    9746:	cd b7       	in	r28, 0x3d	; 61
    9748:	de b7       	in	r29, 0x3e	; 62
    974a:	2c 97       	sbiw	r28, 0x0c	; 12
    974c:	0f b6       	in	r0, 0x3f	; 63
    974e:	f8 94       	cli
    9750:	de bf       	out	0x3e, r29	; 62
    9752:	0f be       	out	0x3f, r0	; 63
    9754:	cd bf       	out	0x3d, r28	; 61
    9756:	6c 01       	movw	r12, r24

	PMDint32 Mov_Pitch_Anterior_RAM,Mov_Roll_Anterior_RAM,Pos_Elbow_corelacionada;

	//Carga posicion de cintura
	PMDGetPosition(&hAxis[AxisWaist],&Pose->Pos_Waist);
    9758:	bc 01       	movw	r22, r24
    975a:	6e 5f       	subi	r22, 0xFE	; 254
    975c:	7f 4f       	sbci	r23, 0xFF	; 255
    975e:	89 e1       	ldi	r24, 0x19	; 25
    9760:	95 e7       	ldi	r25, 0x75	; 117
    9762:	0e 94 84 7b 	call	0xf708	; 0xf708 <PMDGetPosition>
	
	//Carga poscion de hombro
	PMDGetPosition(&hAxis[AxisShoulder],&Pose->Pos_Shoulder);
    9766:	b6 01       	movw	r22, r12
    9768:	6a 5f       	subi	r22, 0xFA	; 250
    976a:	7f 4f       	sbci	r23, 0xFF	; 255
    976c:	89 e7       	ldi	r24, 0x79	; 121
    976e:	95 e7       	ldi	r25, 0x75	; 117
    9770:	0e 94 84 7b 	call	0xf708	; 0xf708 <PMDGetPosition>
	
	
	
	//Carga poscion de codo
	PMDGetPosition(&hAxis[AxisElbow],&Pos_Elbow_corelacionada);
    9774:	89 ed       	ldi	r24, 0xD9	; 217
    9776:	95 e7       	ldi	r25, 0x75	; 117
    9778:	be 01       	movw	r22, r28
    977a:	67 5f       	subi	r22, 0xF7	; 247
    977c:	7f 4f       	sbci	r23, 0xFF	; 255
    977e:	0e 94 84 7b 	call	0xf708	; 0xf708 <PMDGetPosition>
	printf("ObtenerPose=> Pose->Pos_Elbow con correlacionado = %ld\n",Pos_Elbow_corelacionada);
    9782:	00 d0       	rcall	.+0      	; 0x9784 <ObtenerPose+0x4e>
    9784:	00 d0       	rcall	.+0      	; 0x9786 <ObtenerPose+0x50>
    9786:	00 d0       	rcall	.+0      	; 0x9788 <ObtenerPose+0x52>
    9788:	82 e7       	ldi	r24, 0x72	; 114
    978a:	96 e4       	ldi	r25, 0x46	; 70
    978c:	ed b7       	in	r30, 0x3d	; 61
    978e:	fe b7       	in	r31, 0x3e	; 62
    9790:	92 83       	std	Z+2, r25	; 0x02
    9792:	81 83       	std	Z+1, r24	; 0x01
    9794:	89 85       	ldd	r24, Y+9	; 0x09
    9796:	9a 85       	ldd	r25, Y+10	; 0x0a
    9798:	ab 85       	ldd	r26, Y+11	; 0x0b
    979a:	bc 85       	ldd	r27, Y+12	; 0x0c
    979c:	83 83       	std	Z+3, r24	; 0x03
    979e:	94 83       	std	Z+4, r25	; 0x04
    97a0:	a5 83       	std	Z+5, r26	; 0x05
    97a2:	b6 83       	std	Z+6, r27	; 0x06
    97a4:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	Pose->Pos_Elbow = Pos_Elbow_corelacionada - (Pose->Pos_Shoulder*CORRELACION_HOMBRO_CODO);
    97a8:	69 85       	ldd	r22, Y+9	; 0x09
    97aa:	7a 85       	ldd	r23, Y+10	; 0x0a
    97ac:	8b 85       	ldd	r24, Y+11	; 0x0b
    97ae:	9c 85       	ldd	r25, Y+12	; 0x0c
    97b0:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    97b4:	7b 01       	movw	r14, r22
    97b6:	8c 01       	movw	r16, r24
    97b8:	f6 01       	movw	r30, r12
    97ba:	66 81       	ldd	r22, Z+6	; 0x06
    97bc:	77 81       	ldd	r23, Z+7	; 0x07
    97be:	80 85       	ldd	r24, Z+8	; 0x08
    97c0:	91 85       	ldd	r25, Z+9	; 0x09
    97c2:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    97c6:	2d e1       	ldi	r18, 0x1D	; 29
    97c8:	3a e5       	ldi	r19, 0x5A	; 90
    97ca:	44 e5       	ldi	r20, 0x54	; 84
    97cc:	5f eb       	ldi	r21, 0xBF	; 191
    97ce:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    97d2:	9b 01       	movw	r18, r22
    97d4:	ac 01       	movw	r20, r24
    97d6:	c8 01       	movw	r24, r16
    97d8:	b7 01       	movw	r22, r14
    97da:	0e 94 cf 99 	call	0x1339e	; 0x1339e <__addsf3>
    97de:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    97e2:	f6 01       	movw	r30, r12
    97e4:	62 87       	std	Z+10, r22	; 0x0a
    97e6:	73 87       	std	Z+11, r23	; 0x0b
    97e8:	84 87       	std	Z+12, r24	; 0x0c
    97ea:	95 87       	std	Z+13, r25	; 0x0d
	printf("ObtenerPose=> Pose->Pos_Elbow = %ld\n",Pose->Pos_Elbow);
    97ec:	2a ea       	ldi	r18, 0xAA	; 170
    97ee:	36 e4       	ldi	r19, 0x46	; 70
    97f0:	ed b7       	in	r30, 0x3d	; 61
    97f2:	fe b7       	in	r31, 0x3e	; 62
    97f4:	32 83       	std	Z+2, r19	; 0x02
    97f6:	21 83       	std	Z+1, r18	; 0x01
    97f8:	63 83       	std	Z+3, r22	; 0x03
    97fa:	74 83       	std	Z+4, r23	; 0x04
    97fc:	85 83       	std	Z+5, r24	; 0x05
    97fe:	96 83       	std	Z+6, r25	; 0x06
    9800:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	
	
	
	//Carga poscion de pitch
	eeprom_read_block((void*)&Mov_Pitch_Anterior_RAM,(const void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    9804:	8d b7       	in	r24, 0x3d	; 61
    9806:	9e b7       	in	r25, 0x3e	; 62
    9808:	06 96       	adiw	r24, 0x06	; 6
    980a:	0f b6       	in	r0, 0x3f	; 63
    980c:	f8 94       	cli
    980e:	9e bf       	out	0x3e, r25	; 62
    9810:	0f be       	out	0x3f, r0	; 63
    9812:	8d bf       	out	0x3d, r24	; 61
    9814:	ce 01       	movw	r24, r28
    9816:	01 96       	adiw	r24, 0x01	; 1
    9818:	6a e5       	ldi	r22, 0x5A	; 90
    981a:	71 e0       	ldi	r23, 0x01	; 1
    981c:	44 e0       	ldi	r20, 0x04	; 4
    981e:	50 e0       	ldi	r21, 0x00	; 0
    9820:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
	//#ifdef DEBUGROBOTICS
	printf("ObtenerPose=> Mov_Pitch_Anterior_RAM = %ld\n",Mov_Pitch_Anterior_RAM);
    9824:	00 d0       	rcall	.+0      	; 0x9826 <ObtenerPose+0xf0>
    9826:	00 d0       	rcall	.+0      	; 0x9828 <ObtenerPose+0xf2>
    9828:	00 d0       	rcall	.+0      	; 0x982a <ObtenerPose+0xf4>
    982a:	8f ec       	ldi	r24, 0xCF	; 207
    982c:	96 e4       	ldi	r25, 0x46	; 70
    982e:	ed b7       	in	r30, 0x3d	; 61
    9830:	fe b7       	in	r31, 0x3e	; 62
    9832:	92 83       	std	Z+2, r25	; 0x02
    9834:	81 83       	std	Z+1, r24	; 0x01
    9836:	89 81       	ldd	r24, Y+1	; 0x01
    9838:	9a 81       	ldd	r25, Y+2	; 0x02
    983a:	ab 81       	ldd	r26, Y+3	; 0x03
    983c:	bc 81       	ldd	r27, Y+4	; 0x04
    983e:	83 83       	std	Z+3, r24	; 0x03
    9840:	94 83       	std	Z+4, r25	; 0x04
    9842:	a5 83       	std	Z+5, r26	; 0x05
    9844:	b6 83       	std	Z+6, r27	; 0x06
    9846:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	//#endif
	Pose->Pos_Pitch=Mov_Pitch_Anterior_RAM - (Pos_Elbow_corelacionada *CORRELACION_CODO_PITCH) ;
    984a:	69 81       	ldd	r22, Y+1	; 0x01
    984c:	7a 81       	ldd	r23, Y+2	; 0x02
    984e:	8b 81       	ldd	r24, Y+3	; 0x03
    9850:	9c 81       	ldd	r25, Y+4	; 0x04
    9852:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    9856:	7b 01       	movw	r14, r22
    9858:	8c 01       	movw	r16, r24
    985a:	69 85       	ldd	r22, Y+9	; 0x09
    985c:	7a 85       	ldd	r23, Y+10	; 0x0a
    985e:	8b 85       	ldd	r24, Y+11	; 0x0b
    9860:	9c 85       	ldd	r25, Y+12	; 0x0c
    9862:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    9866:	29 ec       	ldi	r18, 0xC9	; 201
    9868:	3e e8       	ldi	r19, 0x8E	; 142
    986a:	4d e8       	ldi	r20, 0x8D	; 141
    986c:	5c eb       	ldi	r21, 0xBC	; 188
    986e:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    9872:	9b 01       	movw	r18, r22
    9874:	ac 01       	movw	r20, r24
    9876:	c8 01       	movw	r24, r16
    9878:	b7 01       	movw	r22, r14
    987a:	0e 94 cf 99 	call	0x1339e	; 0x1339e <__addsf3>
    987e:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    9882:	f6 01       	movw	r30, r12
    9884:	66 87       	std	Z+14, r22	; 0x0e
    9886:	77 87       	std	Z+15, r23	; 0x0f
    9888:	80 8b       	std	Z+16, r24	; 0x10
    988a:	91 8b       	std	Z+17, r25	; 0x11
	//#ifdef DEBUGROBOTICS
	printf("ObtenerPose=> Pose->Pos_Pitch = %ld\n",Pose->Pos_Pitch);
    988c:	2b ef       	ldi	r18, 0xFB	; 251
    988e:	36 e4       	ldi	r19, 0x46	; 70
    9890:	ed b7       	in	r30, 0x3d	; 61
    9892:	fe b7       	in	r31, 0x3e	; 62
    9894:	32 83       	std	Z+2, r19	; 0x02
    9896:	21 83       	std	Z+1, r18	; 0x01
    9898:	63 83       	std	Z+3, r22	; 0x03
    989a:	74 83       	std	Z+4, r23	; 0x04
    989c:	85 83       	std	Z+5, r24	; 0x05
    989e:	96 83       	std	Z+6, r25	; 0x06
    98a0:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	//#endif
	
	
	
	//Carga poscion de roll
	eeprom_read_block((void*)&Mov_Roll_Anterior_RAM,(const void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    98a4:	8d b7       	in	r24, 0x3d	; 61
    98a6:	9e b7       	in	r25, 0x3e	; 62
    98a8:	06 96       	adiw	r24, 0x06	; 6
    98aa:	0f b6       	in	r0, 0x3f	; 63
    98ac:	f8 94       	cli
    98ae:	9e bf       	out	0x3e, r25	; 62
    98b0:	0f be       	out	0x3f, r0	; 63
    98b2:	8d bf       	out	0x3d, r24	; 61
    98b4:	ce 01       	movw	r24, r28
    98b6:	05 96       	adiw	r24, 0x05	; 5
    98b8:	66 e5       	ldi	r22, 0x56	; 86
    98ba:	71 e0       	ldi	r23, 0x01	; 1
    98bc:	44 e0       	ldi	r20, 0x04	; 4
    98be:	50 e0       	ldi	r21, 0x00	; 0
    98c0:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
	//#ifdef DEBUGROBOTICS
	printf("ObtenerPose=> Mov_Roll_Anterior_RAM =  %ld\n",Mov_Roll_Anterior_RAM);
    98c4:	00 d0       	rcall	.+0      	; 0x98c6 <ObtenerPose+0x190>
    98c6:	00 d0       	rcall	.+0      	; 0x98c8 <ObtenerPose+0x192>
    98c8:	00 d0       	rcall	.+0      	; 0x98ca <ObtenerPose+0x194>
    98ca:	80 e2       	ldi	r24, 0x20	; 32
    98cc:	97 e4       	ldi	r25, 0x47	; 71
    98ce:	ed b7       	in	r30, 0x3d	; 61
    98d0:	fe b7       	in	r31, 0x3e	; 62
    98d2:	92 83       	std	Z+2, r25	; 0x02
    98d4:	81 83       	std	Z+1, r24	; 0x01
    98d6:	8d 81       	ldd	r24, Y+5	; 0x05
    98d8:	9e 81       	ldd	r25, Y+6	; 0x06
    98da:	af 81       	ldd	r26, Y+7	; 0x07
    98dc:	b8 85       	ldd	r27, Y+8	; 0x08
    98de:	83 83       	std	Z+3, r24	; 0x03
    98e0:	94 83       	std	Z+4, r25	; 0x04
    98e2:	a5 83       	std	Z+5, r26	; 0x05
    98e4:	b6 83       	std	Z+6, r27	; 0x06
    98e6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	//#endif
	Pose->Pos_Roll=Mov_Roll_Anterior_RAM;
    98ea:	8d 81       	ldd	r24, Y+5	; 0x05
    98ec:	9e 81       	ldd	r25, Y+6	; 0x06
    98ee:	af 81       	ldd	r26, Y+7	; 0x07
    98f0:	b8 85       	ldd	r27, Y+8	; 0x08
    98f2:	f6 01       	movw	r30, r12
    98f4:	82 8b       	std	Z+18, r24	; 0x12
    98f6:	93 8b       	std	Z+19, r25	; 0x13
    98f8:	a4 8b       	std	Z+20, r26	; 0x14
    98fa:	b5 8b       	std	Z+21, r27	; 0x15
    98fc:	8d b7       	in	r24, 0x3d	; 61
    98fe:	9e b7       	in	r25, 0x3e	; 62
    9900:	06 96       	adiw	r24, 0x06	; 6
    9902:	0f b6       	in	r0, 0x3f	; 63
    9904:	f8 94       	cli
    9906:	9e bf       	out	0x3e, r25	; 62
    9908:	0f be       	out	0x3f, r0	; 63
    990a:	8d bf       	out	0x3d, r24	; 61

}
    990c:	2c 96       	adiw	r28, 0x0c	; 12
    990e:	0f b6       	in	r0, 0x3f	; 63
    9910:	f8 94       	cli
    9912:	de bf       	out	0x3e, r29	; 62
    9914:	0f be       	out	0x3f, r0	; 63
    9916:	cd bf       	out	0x3d, r28	; 61
    9918:	cf 91       	pop	r28
    991a:	df 91       	pop	r29
    991c:	1f 91       	pop	r17
    991e:	0f 91       	pop	r16
    9920:	ff 90       	pop	r15
    9922:	ef 90       	pop	r14
    9924:	df 90       	pop	r13
    9926:	cf 90       	pop	r12
    9928:	08 95       	ret

0000992a <rangosrobot>:
/**********************************************************************************************************************/
void rangosrobot(tAxis Axis)
{
    992a:	af 92       	push	r10
    992c:	bf 92       	push	r11
    992e:	cf 92       	push	r12
    9930:	df 92       	push	r13
    9932:	ef 92       	push	r14
    9934:	ff 92       	push	r15
    9936:	0f 93       	push	r16
    9938:	1f 93       	push	r17
    993a:	df 93       	push	r29
    993c:	cf 93       	push	r28
    993e:	00 d0       	rcall	.+0      	; 0x9940 <rangosrobot+0x16>
    9940:	00 d0       	rcall	.+0      	; 0x9942 <rangosrobot+0x18>
    9942:	cd b7       	in	r28, 0x3d	; 61
    9944:	de b7       	in	r29, 0x3e	; 62
    9946:	7c 01       	movw	r14, r24
	double grad;
	
	
	
	
	PMDGetActualPosition(&hAxis[Axis],&position);
    9948:	80 e6       	ldi	r24, 0x60	; 96
    994a:	90 e0       	ldi	r25, 0x00	; 0
    994c:	9c 01       	movw	r18, r24
    994e:	e2 9e       	mul	r14, r18
    9950:	c0 01       	movw	r24, r0
    9952:	e3 9e       	mul	r14, r19
    9954:	90 0d       	add	r25, r0
    9956:	f2 9e       	mul	r15, r18
    9958:	90 0d       	add	r25, r0
    995a:	11 24       	eor	r1, r1
    995c:	09 e1       	ldi	r16, 0x19	; 25
    995e:	15 e7       	ldi	r17, 0x75	; 117
    9960:	80 0f       	add	r24, r16
    9962:	91 1f       	adc	r25, r17
    9964:	be 01       	movw	r22, r28
    9966:	6f 5f       	subi	r22, 0xFF	; 255
    9968:	7f 4f       	sbci	r23, 0xFF	; 255
    996a:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
	
	rad=ustep2rad(&hAxis[Axis].axisSettings, position);
    996e:	c7 01       	movw	r24, r14
    9970:	88 0f       	add	r24, r24
    9972:	99 1f       	adc	r25, r25
    9974:	8e 0d       	add	r24, r14
    9976:	9f 1d       	adc	r25, r15
    9978:	35 e0       	ldi	r19, 0x05	; 5
    997a:	88 0f       	add	r24, r24
    997c:	99 1f       	adc	r25, r25
    997e:	3a 95       	dec	r19
    9980:	e1 f7       	brne	.-8      	; 0x997a <rangosrobot+0x50>
    9982:	04 96       	adiw	r24, 0x04	; 4
    9984:	08 0f       	add	r16, r24
    9986:	19 1f       	adc	r17, r25
    9988:	69 81       	ldd	r22, Y+1	; 0x01
    998a:	7a 81       	ldd	r23, Y+2	; 0x02
    998c:	8b 81       	ldd	r24, Y+3	; 0x03
    998e:	9c 81       	ldd	r25, Y+4	; 0x04
    9990:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    9994:	ab 01       	movw	r20, r22
    9996:	bc 01       	movw	r22, r24
    9998:	c8 01       	movw	r24, r16
    999a:	0e 94 74 29 	call	0x52e8	; 0x52e8 <ustep2rad>
	grad=rad2grados(rad);
    999e:	0e 94 e9 29 	call	0x53d2	; 0x53d2 <rad2grados>
    99a2:	5b 01       	movw	r10, r22
    99a4:	6c 01       	movw	r12, r24
	
	printf("rangosrobot=> %s posicion = %ld \n",AxisName(Axis),position);	
    99a6:	c7 01       	movw	r24, r14
    99a8:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    99ac:	ad b7       	in	r26, 0x3d	; 61
    99ae:	be b7       	in	r27, 0x3e	; 62
    99b0:	18 97       	sbiw	r26, 0x08	; 8
    99b2:	0f b6       	in	r0, 0x3f	; 63
    99b4:	f8 94       	cli
    99b6:	be bf       	out	0x3e, r27	; 62
    99b8:	0f be       	out	0x3f, r0	; 63
    99ba:	ad bf       	out	0x3d, r26	; 61
    99bc:	ed b7       	in	r30, 0x3d	; 61
    99be:	fe b7       	in	r31, 0x3e	; 62
    99c0:	31 96       	adiw	r30, 0x01	; 1
    99c2:	2c e4       	ldi	r18, 0x4C	; 76
    99c4:	37 e4       	ldi	r19, 0x47	; 71
    99c6:	12 96       	adiw	r26, 0x02	; 2
    99c8:	3c 93       	st	X, r19
    99ca:	2e 93       	st	-X, r18
    99cc:	11 97       	sbiw	r26, 0x01	; 1
    99ce:	93 83       	std	Z+3, r25	; 0x03
    99d0:	82 83       	std	Z+2, r24	; 0x02
    99d2:	89 81       	ldd	r24, Y+1	; 0x01
    99d4:	9a 81       	ldd	r25, Y+2	; 0x02
    99d6:	ab 81       	ldd	r26, Y+3	; 0x03
    99d8:	bc 81       	ldd	r27, Y+4	; 0x04
    99da:	84 83       	std	Z+4, r24	; 0x04
    99dc:	95 83       	std	Z+5, r25	; 0x05
    99de:	a6 83       	std	Z+6, r26	; 0x06
    99e0:	b7 83       	std	Z+7, r27	; 0x07
    99e2:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("rangosrobot=> %s grados = %f \n \n",AxisName(Axis),grad);
    99e6:	2d b7       	in	r18, 0x3d	; 61
    99e8:	3e b7       	in	r19, 0x3e	; 62
    99ea:	28 5f       	subi	r18, 0xF8	; 248
    99ec:	3f 4f       	sbci	r19, 0xFF	; 255
    99ee:	0f b6       	in	r0, 0x3f	; 63
    99f0:	f8 94       	cli
    99f2:	3e bf       	out	0x3e, r19	; 62
    99f4:	0f be       	out	0x3f, r0	; 63
    99f6:	2d bf       	out	0x3d, r18	; 61
    99f8:	c7 01       	movw	r24, r14
    99fa:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    99fe:	ad b7       	in	r26, 0x3d	; 61
    9a00:	be b7       	in	r27, 0x3e	; 62
    9a02:	18 97       	sbiw	r26, 0x08	; 8
    9a04:	0f b6       	in	r0, 0x3f	; 63
    9a06:	f8 94       	cli
    9a08:	be bf       	out	0x3e, r27	; 62
    9a0a:	0f be       	out	0x3f, r0	; 63
    9a0c:	ad bf       	out	0x3d, r26	; 61
    9a0e:	ed b7       	in	r30, 0x3d	; 61
    9a10:	fe b7       	in	r31, 0x3e	; 62
    9a12:	31 96       	adiw	r30, 0x01	; 1
    9a14:	2e e6       	ldi	r18, 0x6E	; 110
    9a16:	37 e4       	ldi	r19, 0x47	; 71
    9a18:	12 96       	adiw	r26, 0x02	; 2
    9a1a:	3c 93       	st	X, r19
    9a1c:	2e 93       	st	-X, r18
    9a1e:	11 97       	sbiw	r26, 0x01	; 1
    9a20:	93 83       	std	Z+3, r25	; 0x03
    9a22:	82 83       	std	Z+2, r24	; 0x02
    9a24:	a4 82       	std	Z+4, r10	; 0x04
    9a26:	b5 82       	std	Z+5, r11	; 0x05
    9a28:	c6 82       	std	Z+6, r12	; 0x06
    9a2a:	d7 82       	std	Z+7, r13	; 0x07
    9a2c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    9a30:	2d b7       	in	r18, 0x3d	; 61
    9a32:	3e b7       	in	r19, 0x3e	; 62
    9a34:	28 5f       	subi	r18, 0xF8	; 248
    9a36:	3f 4f       	sbci	r19, 0xFF	; 255
    9a38:	0f b6       	in	r0, 0x3f	; 63
    9a3a:	f8 94       	cli
    9a3c:	3e bf       	out	0x3e, r19	; 62
    9a3e:	0f be       	out	0x3f, r0	; 63
    9a40:	2d bf       	out	0x3d, r18	; 61

	
}
    9a42:	0f 90       	pop	r0
    9a44:	0f 90       	pop	r0
    9a46:	0f 90       	pop	r0
    9a48:	0f 90       	pop	r0
    9a4a:	cf 91       	pop	r28
    9a4c:	df 91       	pop	r29
    9a4e:	1f 91       	pop	r17
    9a50:	0f 91       	pop	r16
    9a52:	ff 90       	pop	r15
    9a54:	ef 90       	pop	r14
    9a56:	df 90       	pop	r13
    9a58:	cf 90       	pop	r12
    9a5a:	bf 90       	pop	r11
    9a5c:	af 90       	pop	r10
    9a5e:	08 95       	ret

00009a60 <motioncomplete>:
  return TRUE;
} // PMDcheckIdle

/**********************************************************************************************************************/
void motioncomplete(int16 axis)
{
    9a60:	9c 01       	movw	r18, r24
	
	//Habilitar todos los ejes para el proximo movimiento limpiando  el bit
	//de Motion Complete ( Bit 0 del Event Status Register).
	
		if((hAxis[axis].axisSettings.axisEnabled == TRUE))
    9a62:	fc 01       	movw	r30, r24
    9a64:	ee 0f       	add	r30, r30
    9a66:	ff 1f       	adc	r31, r31
    9a68:	e8 0f       	add	r30, r24
    9a6a:	f9 1f       	adc	r31, r25
    9a6c:	55 e0       	ldi	r21, 0x05	; 5
    9a6e:	ee 0f       	add	r30, r30
    9a70:	ff 1f       	adc	r31, r31
    9a72:	5a 95       	dec	r21
    9a74:	e1 f7       	brne	.-8      	; 0x9a6e <motioncomplete+0xe>
    9a76:	e3 5e       	subi	r30, 0xE3	; 227
    9a78:	fa 48       	sbci	r31, 0x8A	; 138
    9a7a:	80 81       	ld	r24, Z
    9a7c:	81 30       	cpi	r24, 0x01	; 1
    9a7e:	81 f4       	brne	.+32     	; 0x9aa0 <motioncomplete+0x40>
			PMDResetEventStatus(&hAxis[axis],~ PMDEventMotionCompleteMask);	
    9a80:	80 e6       	ldi	r24, 0x60	; 96
    9a82:	90 e0       	ldi	r25, 0x00	; 0
    9a84:	ac 01       	movw	r20, r24
    9a86:	24 9f       	mul	r18, r20
    9a88:	c0 01       	movw	r24, r0
    9a8a:	25 9f       	mul	r18, r21
    9a8c:	90 0d       	add	r25, r0
    9a8e:	34 9f       	mul	r19, r20
    9a90:	90 0d       	add	r25, r0
    9a92:	11 24       	eor	r1, r1
    9a94:	87 5e       	subi	r24, 0xE7	; 231
    9a96:	9a 48       	sbci	r25, 0x8A	; 138
    9a98:	6e ef       	ldi	r22, 0xFE	; 254
    9a9a:	7f ef       	ldi	r23, 0xFF	; 255
    9a9c:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
    9aa0:	08 95       	ret

00009aa2 <abruptstop>:
		} 
	}
}
//*******************************************************************************************/
void abruptstop(void) 
{
    9aa2:	0f 93       	push	r16
    9aa4:	1f 93       	push	r17
    9aa6:	cf 93       	push	r28
    9aa8:	df 93       	push	r29
    9aaa:	c9 e1       	ldi	r28, 0x19	; 25
    9aac:	d5 e7       	ldi	r29, 0x75	; 117
    9aae:	8e 01       	movw	r16, r28
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
	{
		PMDSetStopMode(&hAxis[axis],PMDAbruptStopMode);
    9ab0:	c8 01       	movw	r24, r16
    9ab2:	61 e0       	ldi	r22, 0x01	; 1
    9ab4:	70 e0       	ldi	r23, 0x00	; 0
    9ab6:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
    9aba:	00 5a       	subi	r16, 0xA0	; 160
    9abc:	1f 4f       	sbci	r17, 0xFF	; 255
//*******************************************************************************************/
void abruptstop(void) 
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
    9abe:	86 e7       	ldi	r24, 0x76	; 118
    9ac0:	09 3f       	cpi	r16, 0xF9	; 249
    9ac2:	18 07       	cpc	r17, r24
    9ac4:	a9 f7       	brne	.-22     	; 0x9ab0 <abruptstop+0xe>
		PMDSetStopMode(&hAxis[axis],PMDAbruptStopMode);
	}
		
	for(axis=0; axis < DOF; axis++) 
	{ // for every chipset (all axis with axis number=1), call MultiUpdate once
		if(hAxis[axis].axis == 0) 
    9ac6:	8a 81       	ldd	r24, Y+2	; 0x02
    9ac8:	9b 81       	ldd	r25, Y+3	; 0x03
    9aca:	89 2b       	or	r24, r25
    9acc:	29 f4       	brne	.+10     	; 0x9ad8 <abruptstop+0x36>
		{
			// Stop the robot (all axis in parallel)
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
    9ace:	ce 01       	movw	r24, r28
    9ad0:	6f e0       	ldi	r22, 0x0F	; 15
    9ad2:	70 e0       	ldi	r23, 0x00	; 0
    9ad4:	0e 94 81 7a 	call	0xf502	; 0xf502 <PMDMultiUpdate>
    9ad8:	c0 5a       	subi	r28, 0xA0	; 160
    9ada:	df 4f       	sbci	r29, 0xFF	; 255
	for(axis=0; axis < DOF; axis++)
	{
		PMDSetStopMode(&hAxis[axis],PMDAbruptStopMode);
	}
		
	for(axis=0; axis < DOF; axis++) 
    9adc:	c0 17       	cp	r28, r16
    9ade:	d1 07       	cpc	r29, r17
    9ae0:	91 f7       	brne	.-28     	; 0x9ac6 <abruptstop+0x24>
			// Stop the robot (all axis in parallel)
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
		} 
	}

}
    9ae2:	df 91       	pop	r29
    9ae4:	cf 91       	pop	r28
    9ae6:	1f 91       	pop	r17
    9ae8:	0f 91       	pop	r16
    9aea:	08 95       	ret

00009aec <sofstop>:



//*******************************************************************************************/
void sofstop(void) 
{
    9aec:	0f 93       	push	r16
    9aee:	1f 93       	push	r17
    9af0:	cf 93       	push	r28
    9af2:	df 93       	push	r29
    9af4:	c9 e1       	ldi	r28, 0x19	; 25
    9af6:	d5 e7       	ldi	r29, 0x75	; 117
    9af8:	8e 01       	movw	r16, r28
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
	{
		PMDSetStopMode(&hAxis[axis],PMDSmoothStopMode);
    9afa:	c8 01       	movw	r24, r16
    9afc:	62 e0       	ldi	r22, 0x02	; 2
    9afe:	70 e0       	ldi	r23, 0x00	; 0
    9b00:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
    9b04:	00 5a       	subi	r16, 0xA0	; 160
    9b06:	1f 4f       	sbci	r17, 0xFF	; 255
//*******************************************************************************************/
void sofstop(void) 
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
    9b08:	86 e7       	ldi	r24, 0x76	; 118
    9b0a:	09 3f       	cpi	r16, 0xF9	; 249
    9b0c:	18 07       	cpc	r17, r24
    9b0e:	a9 f7       	brne	.-22     	; 0x9afa <sofstop+0xe>
		PMDSetStopMode(&hAxis[axis],PMDSmoothStopMode);
	}
		
	for(axis=0; axis < DOF; axis++) 
	{ // for every chipset (all axis with axis number=1), call MultiUpdate once
		if(hAxis[axis].axis == 0) 
    9b10:	8a 81       	ldd	r24, Y+2	; 0x02
    9b12:	9b 81       	ldd	r25, Y+3	; 0x03
    9b14:	89 2b       	or	r24, r25
    9b16:	29 f4       	brne	.+10     	; 0x9b22 <sofstop+0x36>
		{
			// Stop the robot (all axis in parallel)
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
    9b18:	ce 01       	movw	r24, r28
    9b1a:	6f e0       	ldi	r22, 0x0F	; 15
    9b1c:	70 e0       	ldi	r23, 0x00	; 0
    9b1e:	0e 94 81 7a 	call	0xf502	; 0xf502 <PMDMultiUpdate>
    9b22:	c0 5a       	subi	r28, 0xA0	; 160
    9b24:	df 4f       	sbci	r29, 0xFF	; 255
	for(axis=0; axis < DOF; axis++)
	{
		PMDSetStopMode(&hAxis[axis],PMDSmoothStopMode);
	}
		
	for(axis=0; axis < DOF; axis++) 
    9b26:	c0 17       	cp	r28, r16
    9b28:	d1 07       	cpc	r29, r17
    9b2a:	91 f7       	brne	.-28     	; 0x9b10 <sofstop+0x24>
		{
			// Stop the robot (all axis in parallel)
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    
		} 
	}
}
    9b2c:	df 91       	pop	r29
    9b2e:	cf 91       	pop	r28
    9b30:	1f 91       	pop	r17
    9b32:	0f 91       	pop	r16
    9b34:	08 95       	ret

00009b36 <Enable_Mov>:
		
}

/**********************************************************************************************************************/
void Enable_Mov(void)
{
    9b36:	cf 92       	push	r12
    9b38:	df 92       	push	r13
    9b3a:	ef 92       	push	r14
    9b3c:	ff 92       	push	r15
    9b3e:	0f 93       	push	r16
    9b40:	1f 93       	push	r17
    9b42:	df 93       	push	r29
    9b44:	cf 93       	push	r28
    9b46:	00 d0       	rcall	.+0      	; 0x9b48 <Enable_Mov+0x12>
    9b48:	cd b7       	in	r28, 0x3d	; 61
    9b4a:	de b7       	in	r29, 0x3e	; 62
    9b4c:	79 e1       	ldi	r23, 0x19	; 25
    9b4e:	e7 2e       	mov	r14, r23
    9b50:	75 e7       	ldi	r23, 0x75	; 117
    9b52:	f7 2e       	mov	r15, r23
    9b54:	00 e0       	ldi	r16, 0x00	; 0
    9b56:	10 e0       	ldi	r17, 0x00	; 0

	for(axis=0; axis < DOF; axis++) 
	{
		if(hAxis[axis].axisSettings.axisEnabled == TRUE)
		{		
			PMDGetEventStatus(&hAxis[axis],&status);
    9b58:	6e 01       	movw	r12, r28
    9b5a:	08 94       	sec
    9b5c:	c1 1c       	adc	r12, r1
    9b5e:	d1 1c       	adc	r13, r1
	int16 axis;
	PMDuint16 status;

	for(axis=0; axis < DOF; axis++) 
	{
		if(hAxis[axis].axisSettings.axisEnabled == TRUE)
    9b60:	f7 01       	movw	r30, r14
    9b62:	84 81       	ldd	r24, Z+4	; 0x04
    9b64:	81 30       	cpi	r24, 0x01	; 1
    9b66:	51 f4       	brne	.+20     	; 0x9b7c <Enable_Mov+0x46>
		{		
			PMDGetEventStatus(&hAxis[axis],&status);
    9b68:	c7 01       	movw	r24, r14
    9b6a:	b6 01       	movw	r22, r12
    9b6c:	0e 94 75 78 	call	0xf0ea	; 0xf0ea <PMDGetEventStatus>
			if ((status & PMDEventMotionCompleteMask) > 0) //Eje detenido, movimiento completado 
    9b70:	89 81       	ldd	r24, Y+1	; 0x01
    9b72:	80 ff       	sbrs	r24, 0
    9b74:	03 c0       	rjmp	.+6      	; 0x9b7c <Enable_Mov+0x46>
			{
				motioncomplete(axis);
    9b76:	c8 01       	movw	r24, r16
    9b78:	0e 94 30 4d 	call	0x9a60	; 0x9a60 <motioncomplete>
void Enable_Mov(void)
{
	int16 axis;
	PMDuint16 status;

	for(axis=0; axis < DOF; axis++) 
    9b7c:	0f 5f       	subi	r16, 0xFF	; 255
    9b7e:	1f 4f       	sbci	r17, 0xFF	; 255
    9b80:	80 e6       	ldi	r24, 0x60	; 96
    9b82:	90 e0       	ldi	r25, 0x00	; 0
    9b84:	e8 0e       	add	r14, r24
    9b86:	f9 1e       	adc	r15, r25
    9b88:	05 30       	cpi	r16, 0x05	; 5
    9b8a:	11 05       	cpc	r17, r1
    9b8c:	49 f7       	brne	.-46     	; 0x9b60 <Enable_Mov+0x2a>
				
			}
		}
	}
	
}
    9b8e:	0f 90       	pop	r0
    9b90:	0f 90       	pop	r0
    9b92:	cf 91       	pop	r28
    9b94:	df 91       	pop	r29
    9b96:	1f 91       	pop	r17
    9b98:	0f 91       	pop	r16
    9b9a:	ff 90       	pop	r15
    9b9c:	ef 90       	pop	r14
    9b9e:	df 90       	pop	r13
    9ba0:	cf 90       	pop	r12
    9ba2:	08 95       	ret

00009ba4 <PMDcheckIdle>:
}

/*********************************************************************************************/

PMDresult PMDcheckIdle(int16 mask)
{
    9ba4:	af 92       	push	r10
    9ba6:	bf 92       	push	r11
    9ba8:	cf 92       	push	r12
    9baa:	df 92       	push	r13
    9bac:	ef 92       	push	r14
    9bae:	ff 92       	push	r15
    9bb0:	0f 93       	push	r16
    9bb2:	1f 93       	push	r17
    9bb4:	df 93       	push	r29
    9bb6:	cf 93       	push	r28
    9bb8:	00 d0       	rcall	.+0      	; 0x9bba <PMDcheckIdle+0x16>
    9bba:	cd b7       	in	r28, 0x3d	; 61
    9bbc:	de b7       	in	r29, 0x3e	; 62
    9bbe:	6c 01       	movw	r12, r24
    9bc0:	e9 e1       	ldi	r30, 0x19	; 25
    9bc2:	ee 2e       	mov	r14, r30
    9bc4:	e5 e7       	ldi	r30, 0x75	; 117
    9bc6:	fe 2e       	mov	r15, r30
    9bc8:	00 e0       	ldi	r16, 0x00	; 0
    9bca:	10 e0       	ldi	r17, 0x00	; 0
	for(axis=0; axis < DOF; axis++) 
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE)&&
		  ((mask & (Axis2AxisMask(axis))) >0)) 
		{		
			PMDGetEventStatus(&hAxis[axis],&status);
    9bcc:	5e 01       	movw	r10, r28
    9bce:	08 94       	sec
    9bd0:	a1 1c       	adc	r10, r1
    9bd2:	b1 1c       	adc	r11, r1
	int16 axis;
	
  
	for(axis=0; axis < DOF; axis++) 
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE)&&
    9bd4:	f7 01       	movw	r30, r14
    9bd6:	84 81       	ldd	r24, Z+4	; 0x04
    9bd8:	81 30       	cpi	r24, 0x01	; 1
    9bda:	91 f4       	brne	.+36     	; 0x9c00 <PMDcheckIdle+0x5c>
    9bdc:	c8 01       	movw	r24, r16
    9bde:	0e 94 ed 2e 	call	0x5dda	; 0x5dda <Axis2AxisMask>
    9be2:	8c 21       	and	r24, r12
    9be4:	9d 21       	and	r25, r13
    9be6:	18 16       	cp	r1, r24
    9be8:	19 06       	cpc	r1, r25
    9bea:	54 f4       	brge	.+20     	; 0x9c00 <PMDcheckIdle+0x5c>
		  ((mask & (Axis2AxisMask(axis))) >0)) 
		{		
			PMDGetEventStatus(&hAxis[axis],&status);
    9bec:	c7 01       	movw	r24, r14
    9bee:	b5 01       	movw	r22, r10
    9bf0:	0e 94 75 78 	call	0xf0ea	; 0xf0ea <PMDGetEventStatus>
			
			
			if ((status & PMDEventMotionCompleteMask) == 0)
    9bf4:	89 81       	ldd	r24, Y+1	; 0x01
    9bf6:	80 fd       	sbrc	r24, 0
    9bf8:	03 c0       	rjmp	.+6      	; 0x9c00 <PMDcheckIdle+0x5c>
    9bfa:	20 e0       	ldi	r18, 0x00	; 0
    9bfc:	30 e0       	ldi	r19, 0x00	; 0
    9bfe:	0b c0       	rjmp	.+22     	; 0x9c16 <PMDcheckIdle+0x72>
		
	PMDuint16 status;
	int16 axis;
	
  
	for(axis=0; axis < DOF; axis++) 
    9c00:	0f 5f       	subi	r16, 0xFF	; 255
    9c02:	1f 4f       	sbci	r17, 0xFF	; 255
    9c04:	80 e6       	ldi	r24, 0x60	; 96
    9c06:	90 e0       	ldi	r25, 0x00	; 0
    9c08:	e8 0e       	add	r14, r24
    9c0a:	f9 1e       	adc	r15, r25
    9c0c:	05 30       	cpi	r16, 0x05	; 5
    9c0e:	11 05       	cpc	r17, r1
    9c10:	09 f7       	brne	.-62     	; 0x9bd4 <PMDcheckIdle+0x30>
    9c12:	21 e0       	ldi	r18, 0x01	; 1
    9c14:	30 e0       	ldi	r19, 0x00	; 0
				return FALSE;			
			}
		}
	}
  return TRUE;
} // PMDcheckIdle
    9c16:	c9 01       	movw	r24, r18
    9c18:	0f 90       	pop	r0
    9c1a:	0f 90       	pop	r0
    9c1c:	cf 91       	pop	r28
    9c1e:	df 91       	pop	r29
    9c20:	1f 91       	pop	r17
    9c22:	0f 91       	pop	r16
    9c24:	ff 90       	pop	r15
    9c26:	ef 90       	pop	r14
    9c28:	df 90       	pop	r13
    9c2a:	cf 90       	pop	r12
    9c2c:	bf 90       	pop	r11
    9c2e:	af 90       	pop	r10
    9c30:	08 95       	ret

00009c32 <Status_Axis>:
	
	printf("No_limit_switch=> END! \n");
} 
/**********************************************************************************************************************/
PMDresult Status_Axis(tAxis Axis) 
{
    9c32:	0f 93       	push	r16
    9c34:	1f 93       	push	r17
    9c36:	df 93       	push	r29
    9c38:	cf 93       	push	r28
    9c3a:	00 d0       	rcall	.+0      	; 0x9c3c <Status_Axis+0xa>
    9c3c:	cd b7       	in	r28, 0x3d	; 61
    9c3e:	de b7       	in	r29, 0x3e	; 62
    9c40:	8c 01       	movw	r16, r24

	uint16 status;
	
	
	PMDGetActivityStatus(&hAxis[Axis],&status);
    9c42:	80 e6       	ldi	r24, 0x60	; 96
    9c44:	90 e0       	ldi	r25, 0x00	; 0
    9c46:	9c 01       	movw	r18, r24
    9c48:	02 9f       	mul	r16, r18
    9c4a:	c0 01       	movw	r24, r0
    9c4c:	03 9f       	mul	r16, r19
    9c4e:	90 0d       	add	r25, r0
    9c50:	12 9f       	mul	r17, r18
    9c52:	90 0d       	add	r25, r0
    9c54:	11 24       	eor	r1, r1
    9c56:	87 5e       	subi	r24, 0xE7	; 231
    9c58:	9a 48       	sbci	r25, 0x8A	; 138
    9c5a:	be 01       	movw	r22, r28
    9c5c:	6f 5f       	subi	r22, 0xFF	; 255
    9c5e:	7f 4f       	sbci	r23, 0xFF	; 255
    9c60:	0e 94 6f 78 	call	0xf0de	; 0xf0de <PMDGetActivityStatus>
	
	if ((status & PMDActivityInMotionMask) !=0)  
    9c64:	89 81       	ldd	r24, Y+1	; 0x01
    9c66:	9a 81       	ldd	r25, Y+2	; 0x02
    9c68:	92 ff       	sbrs	r25, 2
    9c6a:	03 c0       	rjmp	.+6      	; 0x9c72 <Status_Axis+0x40>
    9c6c:	22 e1       	ldi	r18, 0x12	; 18
    9c6e:	30 e0       	ldi	r19, 0x00	; 0
    9c70:	0c c0       	rjmp	.+24     	; 0x9c8a <Status_Axis+0x58>
	{
		return rcPMDProfileactivo;
	}
	else
	{	
		if(!PMDcheckIdle(Axis2AxisMask(Axis)))
    9c72:	c8 01       	movw	r24, r16
    9c74:	0e 94 ed 2e 	call	0x5dda	; 0x5dda <Axis2AxisMask>
    9c78:	0e 94 d2 4d 	call	0x9ba4	; 0x9ba4 <PMDcheckIdle>
    9c7c:	89 2b       	or	r24, r25
    9c7e:	19 f0       	breq	.+6      	; 0x9c86 <Status_Axis+0x54>
    9c80:	20 e1       	ldi	r18, 0x10	; 16
    9c82:	30 e0       	ldi	r19, 0x00	; 0
    9c84:	02 c0       	rjmp	.+4      	; 0x9c8a <Status_Axis+0x58>
    9c86:	21 e1       	ldi	r18, 0x11	; 17
    9c88:	30 e0       	ldi	r19, 0x00	; 0
			return rcPMDAxisPresicionError;
		}
		/*Movimiento completado con presicion ya sea con o sin encoderes*/
		return rcPMDAxisPresicionMotionComplete;
	}
}
    9c8a:	c9 01       	movw	r24, r18
    9c8c:	0f 90       	pop	r0
    9c8e:	0f 90       	pop	r0
    9c90:	cf 91       	pop	r28
    9c92:	df 91       	pop	r29
    9c94:	1f 91       	pop	r17
    9c96:	0f 91       	pop	r16
    9c98:	08 95       	ret

00009c9a <inipitch_roll>:
		#endif
	}
}

void inipitch_roll(void)
{
    9c9a:	0f 93       	push	r16
    9c9c:	1f 93       	push	r17
    9c9e:	df 93       	push	r29
    9ca0:	cf 93       	push	r28
    9ca2:	00 d0       	rcall	.+0      	; 0x9ca4 <inipitch_roll+0xa>
    9ca4:	00 d0       	rcall	.+0      	; 0x9ca6 <inipitch_roll+0xc>
    9ca6:	cd b7       	in	r28, 0x3d	; 61
    9ca8:	de b7       	in	r29, 0x3e	; 62
	PMDint32 position=0;
    9caa:	19 82       	std	Y+1, r1	; 0x01
    9cac:	1a 82       	std	Y+2, r1	; 0x02
    9cae:	1b 82       	std	Y+3, r1	; 0x03
    9cb0:	1c 82       	std	Y+4, r1	; 0x04
	
	eeprom_write_block((const void*)&position,(void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    9cb2:	8e 01       	movw	r16, r28
    9cb4:	0f 5f       	subi	r16, 0xFF	; 255
    9cb6:	1f 4f       	sbci	r17, 0xFF	; 255
    9cb8:	c8 01       	movw	r24, r16
    9cba:	6a e5       	ldi	r22, 0x5A	; 90
    9cbc:	71 e0       	ldi	r23, 0x01	; 1
    9cbe:	44 e0       	ldi	r20, 0x04	; 4
    9cc0:	50 e0       	ldi	r21, 0x00	; 0
    9cc2:	0e 94 b1 a0 	call	0x14162	; 0x14162 <__eewr_block_m1280>
	eeprom_write_block((const void*)&position,(void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    9cc6:	c8 01       	movw	r24, r16
    9cc8:	66 e5       	ldi	r22, 0x56	; 86
    9cca:	71 e0       	ldi	r23, 0x01	; 1
    9ccc:	44 e0       	ldi	r20, 0x04	; 4
    9cce:	50 e0       	ldi	r21, 0x00	; 0
    9cd0:	0e 94 b1 a0 	call	0x14162	; 0x14162 <__eewr_block_m1280>
}
    9cd4:	0f 90       	pop	r0
    9cd6:	0f 90       	pop	r0
    9cd8:	0f 90       	pop	r0
    9cda:	0f 90       	pop	r0
    9cdc:	cf 91       	pop	r28
    9cde:	df 91       	pop	r29
    9ce0:	1f 91       	pop	r17
    9ce2:	0f 91       	pop	r16
    9ce4:	08 95       	ret

00009ce6 <mov_axis>:
 

//*********************************************************************************************/
void mov_axis(tAxis Axis,PMDint32 position, PMDint32 velocity, 
					PMDuint32 acceleration, PMDint16 actualizar)
{ 
    9ce6:	6f 92       	push	r6
    9ce8:	7f 92       	push	r7
    9cea:	8f 92       	push	r8
    9cec:	9f 92       	push	r9
    9cee:	af 92       	push	r10
    9cf0:	bf 92       	push	r11
    9cf2:	cf 92       	push	r12
    9cf4:	df 92       	push	r13
    9cf6:	ef 92       	push	r14
    9cf8:	ff 92       	push	r15
    9cfa:	0f 93       	push	r16
    9cfc:	1f 93       	push	r17
    9cfe:	cf 93       	push	r28
    9d00:	df 93       	push	r29
    9d02:	ec 01       	movw	r28, r24
    9d04:	38 01       	movw	r6, r16
    9d06:	49 01       	movw	r8, r18
	#ifdef DEBUGROBOTICS
	PMDint32 posicion_origen;
	#endif
	
	if(position!=none)
    9d08:	41 3f       	cpi	r20, 0xF1	; 241
    9d0a:	2f ef       	ldi	r18, 0xFF	; 255
    9d0c:	52 07       	cpc	r21, r18
    9d0e:	2f ef       	ldi	r18, 0xFF	; 255
    9d10:	62 07       	cpc	r22, r18
    9d12:	2f ef       	ldi	r18, 0xFF	; 255
    9d14:	72 07       	cpc	r23, r18
    9d16:	71 f0       	breq	.+28     	; 0x9d34 <mov_axis+0x4e>
		#ifdef DEBUGROBOTICS
		PMDGetCommandedPosition(&hAxis[Axis],&posicion_origen);
		printf("mov_axis=> registro de posicion inicial en el motor %s =  %ld\n ",AxisName(Axis), posicion_origen);
		printf("mov_axis=> registro de posicion final en el motor %s =  %ld\n ",AxisName(Axis), position);
		#endif
		PMDSetPosition(&hAxis[Axis],position);
    9d18:	80 e6       	ldi	r24, 0x60	; 96
    9d1a:	90 e0       	ldi	r25, 0x00	; 0
    9d1c:	9c 01       	movw	r18, r24
    9d1e:	c2 9f       	mul	r28, r18
    9d20:	c0 01       	movw	r24, r0
    9d22:	c3 9f       	mul	r28, r19
    9d24:	90 0d       	add	r25, r0
    9d26:	d2 9f       	mul	r29, r18
    9d28:	90 0d       	add	r25, r0
    9d2a:	11 24       	eor	r1, r1
    9d2c:	87 5e       	subi	r24, 0xE7	; 231
    9d2e:	9a 48       	sbci	r25, 0x8A	; 138
    9d30:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <PMDSetPosition>
	}
	if(velocity!=none)
    9d34:	31 ef       	ldi	r19, 0xF1	; 241
    9d36:	63 16       	cp	r6, r19
    9d38:	3f ef       	ldi	r19, 0xFF	; 255
    9d3a:	73 06       	cpc	r7, r19
    9d3c:	3f ef       	ldi	r19, 0xFF	; 255
    9d3e:	83 06       	cpc	r8, r19
    9d40:	3f ef       	ldi	r19, 0xFF	; 255
    9d42:	93 06       	cpc	r9, r19
    9d44:	81 f0       	breq	.+32     	; 0x9d66 <mov_axis+0x80>
	{
		#ifdef DEBUGROBOTICS
		printf("mov_axis=> registro de velocidad en el motor %s =  %ld\n ",AxisName(Axis), velocity);
		#endif
		PMDSetVelocity(&hAxis[Axis],velocity); //limite permitido 1310720 unidades en up/Sampletime	
    9d46:	80 e6       	ldi	r24, 0x60	; 96
    9d48:	90 e0       	ldi	r25, 0x00	; 0
    9d4a:	9c 01       	movw	r18, r24
    9d4c:	c2 9f       	mul	r28, r18
    9d4e:	c0 01       	movw	r24, r0
    9d50:	c3 9f       	mul	r28, r19
    9d52:	90 0d       	add	r25, r0
    9d54:	d2 9f       	mul	r29, r18
    9d56:	90 0d       	add	r25, r0
    9d58:	11 24       	eor	r1, r1
    9d5a:	87 5e       	subi	r24, 0xE7	; 231
    9d5c:	9a 48       	sbci	r25, 0x8A	; 138
    9d5e:	b4 01       	movw	r22, r8
    9d60:	a3 01       	movw	r20, r6
    9d62:	0e 94 ba 7e 	call	0xfd74	; 0xfd74 <PMDSetVelocity>
	}
	if(acceleration!=none)
    9d66:	31 ef       	ldi	r19, 0xF1	; 241
    9d68:	c3 16       	cp	r12, r19
    9d6a:	3f ef       	ldi	r19, 0xFF	; 255
    9d6c:	d3 06       	cpc	r13, r19
    9d6e:	3f ef       	ldi	r19, 0xFF	; 255
    9d70:	e3 06       	cpc	r14, r19
    9d72:	3f ef       	ldi	r19, 0xFF	; 255
    9d74:	f3 06       	cpc	r15, r19
    9d76:	81 f0       	breq	.+32     	; 0x9d98 <mov_axis+0xb2>
	{
		#ifdef DEBUGROBOTICS
		printf("mov_axis=> registro de aceleracion en el motor %s =  %ld\n ",AxisName(Axis), acceleration);
		#endif
		PMDSetAcceleration(&hAxis[Axis],acceleration); //limite permitido 786 uP/Sample	
    9d78:	80 e6       	ldi	r24, 0x60	; 96
    9d7a:	90 e0       	ldi	r25, 0x00	; 0
    9d7c:	9c 01       	movw	r18, r24
    9d7e:	c2 9f       	mul	r28, r18
    9d80:	c0 01       	movw	r24, r0
    9d82:	c3 9f       	mul	r28, r19
    9d84:	90 0d       	add	r25, r0
    9d86:	d2 9f       	mul	r29, r18
    9d88:	90 0d       	add	r25, r0
    9d8a:	11 24       	eor	r1, r1
    9d8c:	87 5e       	subi	r24, 0xE7	; 231
    9d8e:	9a 48       	sbci	r25, 0x8A	; 138
    9d90:	b7 01       	movw	r22, r14
    9d92:	a6 01       	movw	r20, r12
    9d94:	0e 94 ac 7e 	call	0xfd58	; 0xfd58 <PMDSetAcceleration>
	}
	if(actualizar==update)
    9d98:	30 ef       	ldi	r19, 0xF0	; 240
    9d9a:	a3 16       	cp	r10, r19
    9d9c:	3f ef       	ldi	r19, 0xFF	; 255
    9d9e:	b3 06       	cpc	r11, r19
    9da0:	71 f4       	brne	.+28     	; 0x9dbe <mov_axis+0xd8>
	{
		PMDUpdate(&hAxis[Axis]);
    9da2:	80 e6       	ldi	r24, 0x60	; 96
    9da4:	90 e0       	ldi	r25, 0x00	; 0
    9da6:	9c 01       	movw	r18, r24
    9da8:	c2 9f       	mul	r28, r18
    9daa:	c0 01       	movw	r24, r0
    9dac:	c3 9f       	mul	r28, r19
    9dae:	90 0d       	add	r25, r0
    9db0:	d2 9f       	mul	r29, r18
    9db2:	90 0d       	add	r25, r0
    9db4:	11 24       	eor	r1, r1
    9db6:	87 5e       	subi	r24, 0xE7	; 231
    9db8:	9a 48       	sbci	r25, 0x8A	; 138
    9dba:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
	{
		#ifdef DEBUGROBOTICS
		printf("mov_axis=> No Actualizando..\n ");
		#endif
	}
}
    9dbe:	df 91       	pop	r29
    9dc0:	cf 91       	pop	r28
    9dc2:	1f 91       	pop	r17
    9dc4:	0f 91       	pop	r16
    9dc6:	ff 90       	pop	r15
    9dc8:	ef 90       	pop	r14
    9dca:	df 90       	pop	r13
    9dcc:	cf 90       	pop	r12
    9dce:	bf 90       	pop	r11
    9dd0:	af 90       	pop	r10
    9dd2:	9f 90       	pop	r9
    9dd4:	8f 90       	pop	r8
    9dd6:	7f 90       	pop	r7
    9dd8:	6f 90       	pop	r6
    9dda:	08 95       	ret

00009ddc <StepCalibration>:

	
}
/**********************************************************************************************************************/
void StepCalibration(tAxis Axis)
{
    9ddc:	6f 92       	push	r6
    9dde:	7f 92       	push	r7
    9de0:	8f 92       	push	r8
    9de2:	9f 92       	push	r9
    9de4:	af 92       	push	r10
    9de6:	bf 92       	push	r11
    9de8:	cf 92       	push	r12
    9dea:	df 92       	push	r13
    9dec:	ef 92       	push	r14
    9dee:	ff 92       	push	r15
    9df0:	0f 93       	push	r16
    9df2:	1f 93       	push	r17
    9df4:	df 93       	push	r29
    9df6:	cf 93       	push	r28
    9df8:	cd b7       	in	r28, 0x3d	; 61
    9dfa:	de b7       	in	r29, 0x3e	; 62
    9dfc:	28 97       	sbiw	r28, 0x08	; 8
    9dfe:	0f b6       	in	r0, 0x3f	; 63
    9e00:	f8 94       	cli
    9e02:	de bf       	out	0x3e, r29	; 62
    9e04:	0f be       	out	0x3f, r0	; 63
    9e06:	cd bf       	out	0x3d, r28	; 61
    9e08:	7c 01       	movw	r14, r24


	PMDint32 position,encoder;
  
	PMDGetCommandedPosition(&hAxis[Axis],&position);
    9e0a:	80 e6       	ldi	r24, 0x60	; 96
    9e0c:	90 e0       	ldi	r25, 0x00	; 0
    9e0e:	e8 9e       	mul	r14, r24
    9e10:	30 01       	movw	r6, r0
    9e12:	e9 9e       	mul	r14, r25
    9e14:	70 0c       	add	r7, r0
    9e16:	f8 9e       	mul	r15, r24
    9e18:	70 0c       	add	r7, r0
    9e1a:	11 24       	eor	r1, r1
    9e1c:	89 e1       	ldi	r24, 0x19	; 25
    9e1e:	95 e7       	ldi	r25, 0x75	; 117
    9e20:	68 0e       	add	r6, r24
    9e22:	79 1e       	adc	r7, r25
    9e24:	c3 01       	movw	r24, r6
    9e26:	8e 01       	movw	r16, r28
    9e28:	0f 5f       	subi	r16, 0xFF	; 255
    9e2a:	1f 4f       	sbci	r17, 0xFF	; 255
    9e2c:	b8 01       	movw	r22, r16
    9e2e:	0e 94 5a 7b 	call	0xf6b4	; 0xf6b4 <PMDGetCommandedPosition>
	printf("StepCalibration=> Posicion Instantanea antes del ajuste %ld\n",position);
    9e32:	00 d0       	rcall	.+0      	; 0x9e34 <StepCalibration+0x58>
    9e34:	00 d0       	rcall	.+0      	; 0x9e36 <StepCalibration+0x5a>
    9e36:	00 d0       	rcall	.+0      	; 0x9e38 <StepCalibration+0x5c>
    9e38:	8f e8       	ldi	r24, 0x8F	; 143
    9e3a:	97 e4       	ldi	r25, 0x47	; 71
    9e3c:	ed b7       	in	r30, 0x3d	; 61
    9e3e:	fe b7       	in	r31, 0x3e	; 62
    9e40:	92 83       	std	Z+2, r25	; 0x02
    9e42:	81 83       	std	Z+1, r24	; 0x01
    9e44:	89 81       	ldd	r24, Y+1	; 0x01
    9e46:	9a 81       	ldd	r25, Y+2	; 0x02
    9e48:	ab 81       	ldd	r26, Y+3	; 0x03
    9e4a:	bc 81       	ldd	r27, Y+4	; 0x04
    9e4c:	83 83       	std	Z+3, r24	; 0x03
    9e4e:	94 83       	std	Z+4, r25	; 0x04
    9e50:	a5 83       	std	Z+5, r26	; 0x05
    9e52:	b6 83       	std	Z+6, r27	; 0x06
    9e54:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	PMDGetActualPosition(&hAxis[Axis],&encoder);
    9e58:	8d b7       	in	r24, 0x3d	; 61
    9e5a:	9e b7       	in	r25, 0x3e	; 62
    9e5c:	06 96       	adiw	r24, 0x06	; 6
    9e5e:	0f b6       	in	r0, 0x3f	; 63
    9e60:	f8 94       	cli
    9e62:	9e bf       	out	0x3e, r25	; 62
    9e64:	0f be       	out	0x3f, r0	; 63
    9e66:	8d bf       	out	0x3d, r24	; 61
    9e68:	b5 e0       	ldi	r27, 0x05	; 5
    9e6a:	8b 2e       	mov	r8, r27
    9e6c:	91 2c       	mov	r9, r1
    9e6e:	8c 0e       	add	r8, r28
    9e70:	9d 1e       	adc	r9, r29
    9e72:	c3 01       	movw	r24, r6
    9e74:	b4 01       	movw	r22, r8
    9e76:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
	printf("StepCalibration=> Lectura del encoder %ld\n",encoder);
    9e7a:	00 d0       	rcall	.+0      	; 0x9e7c <StepCalibration+0xa0>
    9e7c:	00 d0       	rcall	.+0      	; 0x9e7e <StepCalibration+0xa2>
    9e7e:	00 d0       	rcall	.+0      	; 0x9e80 <StepCalibration+0xa4>
    9e80:	8c ec       	ldi	r24, 0xCC	; 204
    9e82:	97 e4       	ldi	r25, 0x47	; 71
    9e84:	ed b7       	in	r30, 0x3d	; 61
    9e86:	fe b7       	in	r31, 0x3e	; 62
    9e88:	92 83       	std	Z+2, r25	; 0x02
    9e8a:	81 83       	std	Z+1, r24	; 0x01
    9e8c:	8d 81       	ldd	r24, Y+5	; 0x05
    9e8e:	9e 81       	ldd	r25, Y+6	; 0x06
    9e90:	af 81       	ldd	r26, Y+7	; 0x07
    9e92:	b8 85       	ldd	r27, Y+8	; 0x08
    9e94:	83 83       	std	Z+3, r24	; 0x03
    9e96:	94 83       	std	Z+4, r25	; 0x04
    9e98:	a5 83       	std	Z+5, r26	; 0x05
    9e9a:	b6 83       	std	Z+6, r27	; 0x06
    9e9c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	
	printf("StepCalibration=> Ajustando...\n");	
    9ea0:	8d b7       	in	r24, 0x3d	; 61
    9ea2:	9e b7       	in	r25, 0x3e	; 62
    9ea4:	06 96       	adiw	r24, 0x06	; 6
    9ea6:	0f b6       	in	r0, 0x3f	; 63
    9ea8:	f8 94       	cli
    9eaa:	9e bf       	out	0x3e, r25	; 62
    9eac:	0f be       	out	0x3f, r0	; 63
    9eae:	8d bf       	out	0x3d, r24	; 61
    9eb0:	87 ef       	ldi	r24, 0xF7	; 247
    9eb2:	97 e4       	ldi	r25, 0x47	; 71
    9eb4:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>

	PMDAdjustActualPosition(&hAxis[Axis],-encoder); 
    9eb8:	4d 81       	ldd	r20, Y+5	; 0x05
    9eba:	5e 81       	ldd	r21, Y+6	; 0x06
    9ebc:	6f 81       	ldd	r22, Y+7	; 0x07
    9ebe:	78 85       	ldd	r23, Y+8	; 0x08
    9ec0:	70 95       	com	r23
    9ec2:	60 95       	com	r22
    9ec4:	50 95       	com	r21
    9ec6:	41 95       	neg	r20
    9ec8:	5f 4f       	sbci	r21, 0xFF	; 255
    9eca:	6f 4f       	sbci	r22, 0xFF	; 255
    9ecc:	7f 4f       	sbci	r23, 0xFF	; 255
    9ece:	c3 01       	movw	r24, r6
    9ed0:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>
	PMDGetCommandedPosition(&hAxis[Axis],&position);
    9ed4:	c3 01       	movw	r24, r6
    9ed6:	b8 01       	movw	r22, r16
    9ed8:	0e 94 5a 7b 	call	0xf6b4	; 0xf6b4 <PMDGetCommandedPosition>
	printf("StepCalibration=> Posicion Instantanea despues del ajuste %ld\n",position);
    9edc:	00 d0       	rcall	.+0      	; 0x9ede <StepCalibration+0x102>
    9ede:	00 d0       	rcall	.+0      	; 0x9ee0 <StepCalibration+0x104>
    9ee0:	00 d0       	rcall	.+0      	; 0x9ee2 <StepCalibration+0x106>
    9ee2:	86 e1       	ldi	r24, 0x16	; 22
    9ee4:	98 e4       	ldi	r25, 0x48	; 72
    9ee6:	ed b7       	in	r30, 0x3d	; 61
    9ee8:	fe b7       	in	r31, 0x3e	; 62
    9eea:	92 83       	std	Z+2, r25	; 0x02
    9eec:	81 83       	std	Z+1, r24	; 0x01
    9eee:	89 81       	ldd	r24, Y+1	; 0x01
    9ef0:	9a 81       	ldd	r25, Y+2	; 0x02
    9ef2:	ab 81       	ldd	r26, Y+3	; 0x03
    9ef4:	bc 81       	ldd	r27, Y+4	; 0x04
    9ef6:	83 83       	std	Z+3, r24	; 0x03
    9ef8:	94 83       	std	Z+4, r25	; 0x04
    9efa:	a5 83       	std	Z+5, r26	; 0x05
    9efc:	b6 83       	std	Z+6, r27	; 0x06
    9efe:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	PMDGetActualPosition(&hAxis[Axis],&encoder);
    9f02:	8d b7       	in	r24, 0x3d	; 61
    9f04:	9e b7       	in	r25, 0x3e	; 62
    9f06:	06 96       	adiw	r24, 0x06	; 6
    9f08:	0f b6       	in	r0, 0x3f	; 63
    9f0a:	f8 94       	cli
    9f0c:	9e bf       	out	0x3e, r25	; 62
    9f0e:	0f be       	out	0x3f, r0	; 63
    9f10:	8d bf       	out	0x3d, r24	; 61
    9f12:	c3 01       	movw	r24, r6
    9f14:	b4 01       	movw	r22, r8
    9f16:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
	printf("StepCalibration=> Lectura encoder Despues de ajustar %ld\n",encoder);	
    9f1a:	00 d0       	rcall	.+0      	; 0x9f1c <StepCalibration+0x140>
    9f1c:	00 d0       	rcall	.+0      	; 0x9f1e <StepCalibration+0x142>
    9f1e:	00 d0       	rcall	.+0      	; 0x9f20 <StepCalibration+0x144>
    9f20:	85 e5       	ldi	r24, 0x55	; 85
    9f22:	98 e4       	ldi	r25, 0x48	; 72
    9f24:	ed b7       	in	r30, 0x3d	; 61
    9f26:	fe b7       	in	r31, 0x3e	; 62
    9f28:	92 83       	std	Z+2, r25	; 0x02
    9f2a:	81 83       	std	Z+1, r24	; 0x01
    9f2c:	8d 81       	ldd	r24, Y+5	; 0x05
    9f2e:	9e 81       	ldd	r25, Y+6	; 0x06
    9f30:	af 81       	ldd	r26, Y+7	; 0x07
    9f32:	b8 85       	ldd	r27, Y+8	; 0x08
    9f34:	83 83       	std	Z+3, r24	; 0x03
    9f36:	94 83       	std	Z+4, r25	; 0x04
    9f38:	a5 83       	std	Z+5, r26	; 0x05
    9f3a:	b6 83       	std	Z+6, r27	; 0x06
    9f3c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	mov_axis(Axis,INF,300000,100,update);
    9f40:	8d b7       	in	r24, 0x3d	; 61
    9f42:	9e b7       	in	r25, 0x3e	; 62
    9f44:	06 96       	adiw	r24, 0x06	; 6
    9f46:	0f b6       	in	r0, 0x3f	; 63
    9f48:	f8 94       	cli
    9f4a:	9e bf       	out	0x3e, r25	; 62
    9f4c:	0f be       	out	0x3f, r0	; 63
    9f4e:	8d bf       	out	0x3d, r24	; 61
    9f50:	c7 01       	movw	r24, r14
    9f52:	4f ef       	ldi	r20, 0xFF	; 255
    9f54:	5f ef       	ldi	r21, 0xFF	; 255
    9f56:	6f ef       	ldi	r22, 0xFF	; 255
    9f58:	7f e7       	ldi	r23, 0x7F	; 127
    9f5a:	00 ee       	ldi	r16, 0xE0	; 224
    9f5c:	13 e9       	ldi	r17, 0x93	; 147
    9f5e:	24 e0       	ldi	r18, 0x04	; 4
    9f60:	30 e0       	ldi	r19, 0x00	; 0
    9f62:	a4 e6       	ldi	r26, 0x64	; 100
    9f64:	ca 2e       	mov	r12, r26
    9f66:	d1 2c       	mov	r13, r1
    9f68:	e1 2c       	mov	r14, r1
    9f6a:	f1 2c       	mov	r15, r1
    9f6c:	f0 ef       	ldi	r31, 0xF0	; 240
    9f6e:	af 2e       	mov	r10, r31
    9f70:	ff ef       	ldi	r31, 0xFF	; 255
    9f72:	bf 2e       	mov	r11, r31
    9f74:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
	
	while(encoder < 480)
	{
     
	PMDGetActualPosition(&hAxis[Axis],&encoder);
    9f78:	18 2d       	mov	r17, r8
    9f7a:	89 2c       	mov	r8, r9
    9f7c:	05 c0       	rjmp	.+10     	; 0x9f88 <StepCalibration+0x1ac>
    9f7e:	c3 01       	movw	r24, r6
    9f80:	61 2f       	mov	r22, r17
    9f82:	78 2d       	mov	r23, r8
    9f84:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
	printf("StepCalibration=> Posicion Instantanea despues del ajuste %ld\n",position);
	PMDGetActualPosition(&hAxis[Axis],&encoder);
	printf("StepCalibration=> Lectura encoder Despues de ajustar %ld\n",encoder);	
	mov_axis(Axis,INF,300000,100,update);
	
	while(encoder < 480)
    9f88:	8d 81       	ldd	r24, Y+5	; 0x05
    9f8a:	9e 81       	ldd	r25, Y+6	; 0x06
    9f8c:	af 81       	ldd	r26, Y+7	; 0x07
    9f8e:	b8 85       	ldd	r27, Y+8	; 0x08
    9f90:	80 5e       	subi	r24, 0xE0	; 224
    9f92:	91 40       	sbci	r25, 0x01	; 1
    9f94:	a0 40       	sbci	r26, 0x00	; 0
    9f96:	b0 40       	sbci	r27, 0x00	; 0
    9f98:	94 f3       	brlt	.-28     	; 0x9f7e <StepCalibration+0x1a2>
     
	PMDGetActualPosition(&hAxis[Axis],&encoder);
	//printf("Encoder = %ld\n",encoder);	
	 
	}
	PMDSetStopMode(&hAxis[Axis],PMDAbruptStopMode);
    9f9a:	c3 01       	movw	r24, r6
    9f9c:	61 e0       	ldi	r22, 0x01	; 1
    9f9e:	70 e0       	ldi	r23, 0x00	; 0
    9fa0:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
	PMDUpdate(&hAxis[Axis]);
    9fa4:	c3 01       	movw	r24, r6
    9fa6:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
	PMDGetCommandedPosition(&hAxis[Axis],&position);
    9faa:	c3 01       	movw	r24, r6
    9fac:	be 01       	movw	r22, r28
    9fae:	6f 5f       	subi	r22, 0xFF	; 255
    9fb0:	7f 4f       	sbci	r23, 0xFF	; 255
    9fb2:	0e 94 5a 7b 	call	0xf6b4	; 0xf6b4 <PMDGetCommandedPosition>
	
	printf("StepCalibration=> Posicion Instantanea al completar 480 pulsos del encoder => %ld\n",position);  
    9fb6:	00 d0       	rcall	.+0      	; 0x9fb8 <StepCalibration+0x1dc>
    9fb8:	00 d0       	rcall	.+0      	; 0x9fba <StepCalibration+0x1de>
    9fba:	00 d0       	rcall	.+0      	; 0x9fbc <StepCalibration+0x1e0>
    9fbc:	8f e8       	ldi	r24, 0x8F	; 143
    9fbe:	98 e4       	ldi	r25, 0x48	; 72
    9fc0:	ed b7       	in	r30, 0x3d	; 61
    9fc2:	fe b7       	in	r31, 0x3e	; 62
    9fc4:	92 83       	std	Z+2, r25	; 0x02
    9fc6:	81 83       	std	Z+1, r24	; 0x01
    9fc8:	89 81       	ldd	r24, Y+1	; 0x01
    9fca:	9a 81       	ldd	r25, Y+2	; 0x02
    9fcc:	ab 81       	ldd	r26, Y+3	; 0x03
    9fce:	bc 81       	ldd	r27, Y+4	; 0x04
    9fd0:	83 83       	std	Z+3, r24	; 0x03
    9fd2:	94 83       	std	Z+4, r25	; 0x04
    9fd4:	a5 83       	std	Z+5, r26	; 0x05
    9fd6:	b6 83       	std	Z+6, r27	; 0x06
    9fd8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Encoder = %ld\n",encoder);	
    9fdc:	82 ee       	ldi	r24, 0xE2	; 226
    9fde:	98 e4       	ldi	r25, 0x48	; 72
    9fe0:	ed b7       	in	r30, 0x3d	; 61
    9fe2:	fe b7       	in	r31, 0x3e	; 62
    9fe4:	92 83       	std	Z+2, r25	; 0x02
    9fe6:	81 83       	std	Z+1, r24	; 0x01
    9fe8:	8d 81       	ldd	r24, Y+5	; 0x05
    9fea:	9e 81       	ldd	r25, Y+6	; 0x06
    9fec:	af 81       	ldd	r26, Y+7	; 0x07
    9fee:	b8 85       	ldd	r27, Y+8	; 0x08
    9ff0:	83 83       	std	Z+3, r24	; 0x03
    9ff2:	94 83       	std	Z+4, r25	; 0x04
    9ff4:	a5 83       	std	Z+5, r26	; 0x05
    9ff6:	b6 83       	std	Z+6, r27	; 0x06
    9ff8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    9ffc:	8d b7       	in	r24, 0x3d	; 61
    9ffe:	9e b7       	in	r25, 0x3e	; 62
    a000:	06 96       	adiw	r24, 0x06	; 6
    a002:	0f b6       	in	r0, 0x3f	; 63
    a004:	f8 94       	cli
    a006:	9e bf       	out	0x3e, r25	; 62
    a008:	0f be       	out	0x3f, r0	; 63
    a00a:	8d bf       	out	0x3d, r24	; 61

}
    a00c:	28 96       	adiw	r28, 0x08	; 8
    a00e:	0f b6       	in	r0, 0x3f	; 63
    a010:	f8 94       	cli
    a012:	de bf       	out	0x3e, r29	; 62
    a014:	0f be       	out	0x3f, r0	; 63
    a016:	cd bf       	out	0x3d, r28	; 61
    a018:	cf 91       	pop	r28
    a01a:	df 91       	pop	r29
    a01c:	1f 91       	pop	r17
    a01e:	0f 91       	pop	r16
    a020:	ff 90       	pop	r15
    a022:	ef 90       	pop	r14
    a024:	df 90       	pop	r13
    a026:	cf 90       	pop	r12
    a028:	bf 90       	pop	r11
    a02a:	af 90       	pop	r10
    a02c:	9f 90       	pop	r9
    a02e:	8f 90       	pop	r8
    a030:	7f 90       	pop	r7
    a032:	6f 90       	pop	r6
    a034:	08 95       	ret

0000a036 <roll>:


//**********************************************************************************************
void roll(PMDint32 position, PMDint32 velocity, PMDuint32 acceleration,
					PMDint16 actualizar,PMDint16 modo_movimiento)
{
    a036:	2f 92       	push	r2
    a038:	3f 92       	push	r3
    a03a:	4f 92       	push	r4
    a03c:	5f 92       	push	r5
    a03e:	6f 92       	push	r6
    a040:	7f 92       	push	r7
    a042:	8f 92       	push	r8
    a044:	9f 92       	push	r9
    a046:	af 92       	push	r10
    a048:	bf 92       	push	r11
    a04a:	cf 92       	push	r12
    a04c:	df 92       	push	r13
    a04e:	ef 92       	push	r14
    a050:	ff 92       	push	r15
    a052:	0f 93       	push	r16
    a054:	1f 93       	push	r17
    a056:	df 93       	push	r29
    a058:	cf 93       	push	r28
    a05a:	cd b7       	in	r28, 0x3d	; 61
    a05c:	de b7       	in	r29, 0x3e	; 62
    a05e:	2e 97       	sbiw	r28, 0x0e	; 14
    a060:	0f b6       	in	r0, 0x3f	; 63
    a062:	f8 94       	cli
    a064:	de bf       	out	0x3e, r29	; 62
    a066:	0f be       	out	0x3f, r0	; 63
    a068:	cd bf       	out	0x3d, r28	; 61
    a06a:	69 87       	std	Y+9, r22	; 0x09
    a06c:	7a 87       	std	Y+10, r23	; 0x0a
    a06e:	8b 87       	std	Y+11, r24	; 0x0b
    a070:	9c 87       	std	Y+12, r25	; 0x0c
    a072:	39 01       	movw	r6, r18
    a074:	4a 01       	movw	r8, r20
    a076:	17 01       	movw	r2, r14
    a078:	28 01       	movw	r4, r16
    a07a:	de 86       	std	Y+14, r13	; 0x0e
    a07c:	cd 86       	std	Y+13, r12	; 0x0d
	PMDint32  posicion_actual_motor_pitch,posicion_actual_motor_roll;
	#endif
	
	/*deshabilitando eventos de limite porque Roll no tiene interruptores 
	de fin de carrera*/
	PMDSetLimitSwitchMode(&hAxis[AxisRoll],PMDLimitDisabled);
    a07e:	89 e9       	ldi	r24, 0x99	; 153
    a080:	96 e7       	ldi	r25, 0x76	; 118
    a082:	60 e0       	ldi	r22, 0x00	; 0
    a084:	70 e0       	ldi	r23, 0x00	; 0
    a086:	0e 94 bd 7a 	call	0xf57a	; 0xf57a <PMDSetLimitSwitchMode>
	PMDSetLimitSwitchMode(&hAxis[AxisPitch],PMDLimitDisabled);
    a08a:	89 e3       	ldi	r24, 0x39	; 57
    a08c:	96 e7       	ldi	r25, 0x76	; 118
    a08e:	60 e0       	ldi	r22, 0x00	; 0
    a090:	70 e0       	ldi	r23, 0x00	; 0
    a092:	0e 94 bd 7a 	call	0xf57a	; 0xf57a <PMDSetLimitSwitchMode>
	PMDGetActualPosition(&hAxis[AxisRoll],&posicion_actual_motor_roll);
	printf("roll=> Posicion encoder actual del motor de pitch %ld\n",posicion_actual_motor_pitch);
	printf("roll=> Posicion encoder actual del motor de roll %ld\n",posicion_actual_motor_roll);
	#endif
	
	switch (modo_movimiento)
    a096:	21 e0       	ldi	r18, 0x01	; 1
    a098:	a2 16       	cp	r10, r18
    a09a:	b1 04       	cpc	r11, r1
    a09c:	31 f0       	breq	.+12     	; 0xa0aa <roll+0x74>
    a09e:	34 e0       	ldi	r19, 0x04	; 4
    a0a0:	a3 16       	cp	r10, r19
    a0a2:	b1 04       	cpc	r11, r1
    a0a4:	09 f0       	breq	.+2      	; 0xa0a8 <roll+0x72>
    a0a6:	70 c0       	rjmp	.+224    	; 0xa188 <roll+0x152>
    a0a8:	4f c0       	rjmp	.+158    	; 0xa148 <roll+0x112>
	{ 
		case (MOVIMIENTO_NORMAL):
			/* Leer el movimiento anterior de Roll que esta almacenado en EEPROM*/
			eeprom_read_block((void*)&Mov_Roll_Anterior_RAM,(const void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    a0aa:	ce 01       	movw	r24, r28
    a0ac:	01 96       	adiw	r24, 0x01	; 1
    a0ae:	66 e5       	ldi	r22, 0x56	; 86
    a0b0:	71 e0       	ldi	r23, 0x01	; 1
    a0b2:	44 e0       	ldi	r20, 0x04	; 4
    a0b4:	50 e0       	ldi	r21, 0x00	; 0
    a0b6:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
			//#ifdef DEBUGROBOTICS
				printf("roll => Movimiento de roll Anterior EEPROM de %s = %ld\n",AxisName(AxisRoll),Mov_Roll_Anterior_RAM);
    a0ba:	84 e0       	ldi	r24, 0x04	; 4
    a0bc:	90 e0       	ldi	r25, 0x00	; 0
    a0be:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    a0c2:	ad b7       	in	r26, 0x3d	; 61
    a0c4:	be b7       	in	r27, 0x3e	; 62
    a0c6:	18 97       	sbiw	r26, 0x08	; 8
    a0c8:	0f b6       	in	r0, 0x3f	; 63
    a0ca:	f8 94       	cli
    a0cc:	be bf       	out	0x3e, r27	; 62
    a0ce:	0f be       	out	0x3f, r0	; 63
    a0d0:	ad bf       	out	0x3d, r26	; 61
    a0d2:	ed b7       	in	r30, 0x3d	; 61
    a0d4:	fe b7       	in	r31, 0x3e	; 62
    a0d6:	31 96       	adiw	r30, 0x01	; 1
    a0d8:	21 ef       	ldi	r18, 0xF1	; 241
    a0da:	38 e4       	ldi	r19, 0x48	; 72
    a0dc:	12 96       	adiw	r26, 0x02	; 2
    a0de:	3c 93       	st	X, r19
    a0e0:	2e 93       	st	-X, r18
    a0e2:	11 97       	sbiw	r26, 0x01	; 1
    a0e4:	93 83       	std	Z+3, r25	; 0x03
    a0e6:	82 83       	std	Z+2, r24	; 0x02
    a0e8:	89 81       	ldd	r24, Y+1	; 0x01
    a0ea:	9a 81       	ldd	r25, Y+2	; 0x02
    a0ec:	ab 81       	ldd	r26, Y+3	; 0x03
    a0ee:	bc 81       	ldd	r27, Y+4	; 0x04
    a0f0:	84 83       	std	Z+4, r24	; 0x04
    a0f2:	95 83       	std	Z+5, r25	; 0x05
    a0f4:	a6 83       	std	Z+6, r26	; 0x06
    a0f6:	b7 83       	std	Z+7, r27	; 0x07
    a0f8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
				printf("roll => Actualizando ActualPosition motor de  PITCH y ROLL en roll();! \n");
    a0fc:	2d b7       	in	r18, 0x3d	; 61
    a0fe:	3e b7       	in	r19, 0x3e	; 62
    a100:	28 5f       	subi	r18, 0xF8	; 248
    a102:	3f 4f       	sbci	r19, 0xFF	; 255
    a104:	0f b6       	in	r0, 0x3f	; 63
    a106:	f8 94       	cli
    a108:	3e bf       	out	0x3e, r19	; 62
    a10a:	0f be       	out	0x3f, r0	; 63
    a10c:	2d bf       	out	0x3d, r18	; 61
    a10e:	89 e2       	ldi	r24, 0x29	; 41
    a110:	99 e4       	ldi	r25, 0x49	; 73
    a112:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
			//#endif	
			/* Carga el valor de movimiento anterior de Roll a los encoders de los motores de pitch y roll*/
			PMDSetActualPosition(&hAxis[AxisPitch],Mov_Roll_Anterior_RAM);
    a116:	49 81       	ldd	r20, Y+1	; 0x01
    a118:	5a 81       	ldd	r21, Y+2	; 0x02
    a11a:	6b 81       	ldd	r22, Y+3	; 0x03
    a11c:	7c 81       	ldd	r23, Y+4	; 0x04
    a11e:	89 e3       	ldi	r24, 0x39	; 57
    a120:	96 e7       	ldi	r25, 0x76	; 118
    a122:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>
			PMDSetActualPosition(&hAxis[AxisRoll],Mov_Roll_Anterior_RAM);
    a126:	49 81       	ldd	r20, Y+1	; 0x01
    a128:	5a 81       	ldd	r21, Y+2	; 0x02
    a12a:	6b 81       	ldd	r22, Y+3	; 0x03
    a12c:	7c 81       	ldd	r23, Y+4	; 0x04
    a12e:	89 e9       	ldi	r24, 0x99	; 153
    a130:	96 e7       	ldi	r25, 0x76	; 118
    a132:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>
			//Es un movimiento normal se debe de actualizar la posicion eeprom.
			eeprom_write_block((const void*)&position,(void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    a136:	ce 01       	movw	r24, r28
    a138:	09 96       	adiw	r24, 0x09	; 9
    a13a:	66 e5       	ldi	r22, 0x56	; 86
    a13c:	71 e0       	ldi	r23, 0x01	; 1
    a13e:	44 e0       	ldi	r20, 0x04	; 4
    a140:	50 e0       	ldi	r21, 0x00	; 0
    a142:	0e 94 b1 a0 	call	0x14162	; 0x14162 <__eewr_block_m1280>
    a146:	20 c0       	rjmp	.+64     	; 0xa188 <roll+0x152>
	    break;
	    case (INICIANDO_HOME_PITCH_ROLL):
			//Debo reinicar el movimiento anterior a cero. Para evitar descuadre del encoder cuando: 
			//-Hago HOME luego me muevo hacia una posicion X y luego hago home.
			//-Apago el controlador y se mueve por error el los motores de pitch y roll.
			temp=0;
    a148:	1d 82       	std	Y+5, r1	; 0x05
    a14a:	1e 82       	std	Y+6, r1	; 0x06
    a14c:	1f 82       	std	Y+7, r1	; 0x07
    a14e:	18 86       	std	Y+8, r1	; 0x08
			eeprom_write_block((const void*)&temp,(void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    a150:	ce 01       	movw	r24, r28
    a152:	05 96       	adiw	r24, 0x05	; 5
    a154:	66 e5       	ldi	r22, 0x56	; 86
    a156:	71 e0       	ldi	r23, 0x01	; 1
    a158:	44 e0       	ldi	r20, 0x04	; 4
    a15a:	50 e0       	ldi	r21, 0x00	; 0
    a15c:	0e 94 b1 a0 	call	0x14162	; 0x14162 <__eewr_block_m1280>
			//reinicio encoders de pitch y roll en cero
			printf("roll => iniciando encodificadores a cero. \n");
    a160:	81 e7       	ldi	r24, 0x71	; 113
    a162:	99 e4       	ldi	r25, 0x49	; 73
    a164:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
			PMDSetActualPosition(&hAxis[AxisPitch],0);
    a168:	89 e3       	ldi	r24, 0x39	; 57
    a16a:	96 e7       	ldi	r25, 0x76	; 118
    a16c:	40 e0       	ldi	r20, 0x00	; 0
    a16e:	50 e0       	ldi	r21, 0x00	; 0
    a170:	60 e0       	ldi	r22, 0x00	; 0
    a172:	70 e0       	ldi	r23, 0x00	; 0
    a174:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>
			PMDSetActualPosition(&hAxis[AxisRoll],0);
    a178:	89 e9       	ldi	r24, 0x99	; 153
    a17a:	96 e7       	ldi	r25, 0x76	; 118
    a17c:	40 e0       	ldi	r20, 0x00	; 0
    a17e:	50 e0       	ldi	r21, 0x00	; 0
    a180:	60 e0       	ldi	r22, 0x00	; 0
    a182:	70 e0       	ldi	r23, 0x00	; 0
    a184:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>
	printf("roll => Posicion encoder actual del motor de roll %ld\n",posicion_actual_motor_roll);
	#endif
	
		
	/*Realizo el Movimiento de Roll */	
	mov_axis(AxisPitch, position, velocity, acceleration, actualizar);
    a188:	49 85       	ldd	r20, Y+9	; 0x09
    a18a:	5a 85       	ldd	r21, Y+10	; 0x0a
    a18c:	6b 85       	ldd	r22, Y+11	; 0x0b
    a18e:	7c 85       	ldd	r23, Y+12	; 0x0c
    a190:	83 e0       	ldi	r24, 0x03	; 3
    a192:	90 e0       	ldi	r25, 0x00	; 0
    a194:	94 01       	movw	r18, r8
    a196:	83 01       	movw	r16, r6
    a198:	72 01       	movw	r14, r4
    a19a:	61 01       	movw	r12, r2
    a19c:	ad 84       	ldd	r10, Y+13	; 0x0d
    a19e:	be 84       	ldd	r11, Y+14	; 0x0e
    a1a0:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
	mov_axis(AxisRoll, position, (velocity), acceleration, actualizar);
    a1a4:	49 85       	ldd	r20, Y+9	; 0x09
    a1a6:	5a 85       	ldd	r21, Y+10	; 0x0a
    a1a8:	6b 85       	ldd	r22, Y+11	; 0x0b
    a1aa:	7c 85       	ldd	r23, Y+12	; 0x0c
    a1ac:	84 e0       	ldi	r24, 0x04	; 4
    a1ae:	90 e0       	ldi	r25, 0x00	; 0
    a1b0:	94 01       	movw	r18, r8
    a1b2:	83 01       	movw	r16, r6
    a1b4:	ad 84       	ldd	r10, Y+13	; 0x0d
    a1b6:	be 84       	ldd	r11, Y+14	; 0x0e
    a1b8:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>


}
    a1bc:	2e 96       	adiw	r28, 0x0e	; 14
    a1be:	0f b6       	in	r0, 0x3f	; 63
    a1c0:	f8 94       	cli
    a1c2:	de bf       	out	0x3e, r29	; 62
    a1c4:	0f be       	out	0x3f, r0	; 63
    a1c6:	cd bf       	out	0x3d, r28	; 61
    a1c8:	cf 91       	pop	r28
    a1ca:	df 91       	pop	r29
    a1cc:	1f 91       	pop	r17
    a1ce:	0f 91       	pop	r16
    a1d0:	ff 90       	pop	r15
    a1d2:	ef 90       	pop	r14
    a1d4:	df 90       	pop	r13
    a1d6:	cf 90       	pop	r12
    a1d8:	bf 90       	pop	r11
    a1da:	af 90       	pop	r10
    a1dc:	9f 90       	pop	r9
    a1de:	8f 90       	pop	r8
    a1e0:	7f 90       	pop	r7
    a1e2:	6f 90       	pop	r6
    a1e4:	5f 90       	pop	r5
    a1e6:	4f 90       	pop	r4
    a1e8:	3f 90       	pop	r3
    a1ea:	2f 90       	pop	r2
    a1ec:	08 95       	ret

0000a1ee <search_home_roll_positive>:
	printf("search_home_positive=> El Event status register del eje %s despues de limpiar es %X \n ",AxisName(Axis),status);	
	#endif
}
/**********************************************************************************************************************/
void search_home_roll_positive(PMDint32 *home)
{
    a1ee:	2f 92       	push	r2
    a1f0:	3f 92       	push	r3
    a1f2:	4f 92       	push	r4
    a1f4:	5f 92       	push	r5
    a1f6:	6f 92       	push	r6
    a1f8:	7f 92       	push	r7
    a1fa:	8f 92       	push	r8
    a1fc:	9f 92       	push	r9
    a1fe:	af 92       	push	r10
    a200:	bf 92       	push	r11
    a202:	cf 92       	push	r12
    a204:	df 92       	push	r13
    a206:	ef 92       	push	r14
    a208:	ff 92       	push	r15
    a20a:	0f 93       	push	r16
    a20c:	1f 93       	push	r17
    a20e:	df 93       	push	r29
    a210:	cf 93       	push	r28
    a212:	00 d0       	rcall	.+0      	; 0xa214 <search_home_roll_positive+0x26>
    a214:	00 d0       	rcall	.+0      	; 0xa216 <search_home_roll_positive+0x28>
    a216:	00 d0       	rcall	.+0      	; 0xa218 <search_home_roll_positive+0x2a>
    a218:	cd b7       	in	r28, 0x3d	; 61
    a21a:	de b7       	in	r29, 0x3e	; 62
    a21c:	4c 01       	movw	r8, r24

  	

	find_home_out=1;
	
	No_limit_switch(AxisPitch);
    a21e:	83 e0       	ldi	r24, 0x03	; 3
    a220:	90 e0       	ldi	r25, 0x00	; 0
    a222:	0e 94 db 4a 	call	0x95b6	; 0x95b6 <No_limit_switch>
	//Se cambia el perfil movimiento a perfil de  Velocidad	
	PMDSetProfileMode(&hAxis[AxisRoll],  PMDVelocityContouringProfile );
    a226:	89 e9       	ldi	r24, 0x99	; 153
    a228:	96 e7       	ldi	r25, 0x76	; 118
    a22a:	61 e0       	ldi	r22, 0x01	; 1
    a22c:	70 e0       	ldi	r23, 0x00	; 0
    a22e:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
	PMDSetProfileMode(&hAxis[AxisPitch],  PMDVelocityContouringProfile );
    a232:	89 e3       	ldi	r24, 0x39	; 57
    a234:	96 e7       	ldi	r25, 0x76	; 118
    a236:	61 e0       	ldi	r22, 0x01	; 1
    a238:	70 e0       	ldi	r23, 0x00	; 0
    a23a:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
	//Limpia el BiT de Position Capture Indicator en el Status Register
	PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventCaptureReceivedMask);	
    a23e:	89 e9       	ldi	r24, 0x99	; 153
    a240:	96 e7       	ldi	r25, 0x76	; 118
    a242:	67 ef       	ldi	r22, 0xF7	; 247
    a244:	7f ef       	ldi	r23, 0xFF	; 255
    a246:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
	//La senal de HOME sera utilizada como Disparo para la Captura de la Posicion
	PMDSetCaptureSource(&hAxis[AxisRoll],PMDCaptureSourceHome);
    a24a:	89 e9       	ldi	r24, 0x99	; 153
    a24c:	96 e7       	ldi	r25, 0x76	; 118
    a24e:	61 e0       	ldi	r22, 0x01	; 1
    a250:	70 e0       	ldi	r23, 0x00	; 0
    a252:	0e 94 63 7a 	call	0xf4c6	; 0xf4c6 <PMDSetCaptureSource>
	//Leyendo el registro de Captura de Posicion Causa "rearmar" 
	//el disparador con el fin de permitir mas capturas.
	PMDGetCaptureValue(&hAxis[AxisRoll],&temp); 
    a256:	89 e9       	ldi	r24, 0x99	; 153
    a258:	96 e7       	ldi	r25, 0x76	; 118
    a25a:	be 01       	movw	r22, r28
    a25c:	6d 5f       	subi	r22, 0xFD	; 253
    a25e:	7f 4f       	sbci	r23, 0xFF	; 255
    a260:	0e 94 24 7b 	call	0xf648	; 0xf648 <PMDGetCaptureValue>

	#ifdef DEBUGROBOTICS_HOME
	printf("search_home_roll_positive=> Ejecutado No_limit_switch\n");
    a264:	8c e9       	ldi	r24, 0x9C	; 156
    a266:	99 e4       	ldi	r25, 0x49	; 73
    a268:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	printf("search_home_roll_positive=> Moviendo Roll en direccion Positiva para Hallar HOME \n ");
    a26c:	00 d0       	rcall	.+0      	; 0xa26e <search_home_roll_positive+0x80>
    a26e:	82 ed       	ldi	r24, 0xD2	; 210
    a270:	99 e4       	ldi	r25, 0x49	; 73
    a272:	ed b7       	in	r30, 0x3d	; 61
    a274:	fe b7       	in	r31, 0x3e	; 62
    a276:	92 83       	std	Z+2, r25	; 0x02
    a278:	81 83       	std	Z+1, r24	; 0x01
    a27a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	#endif
	roll(none,0.7*(hAxis[AxisRoll].axisSettings.homeVelocity),
    a27e:	0f 90       	pop	r0
    a280:	0f 90       	pop	r0
    a282:	60 91 d9 76 	lds	r22, 0x76D9
    a286:	70 91 da 76 	lds	r23, 0x76DA
    a28a:	80 91 db 76 	lds	r24, 0x76DB
    a28e:	90 91 dc 76 	lds	r25, 0x76DC
    a292:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    a296:	23 e3       	ldi	r18, 0x33	; 51
    a298:	33 e3       	ldi	r19, 0x33	; 51
    a29a:	43 e3       	ldi	r20, 0x33	; 51
    a29c:	5f e3       	ldi	r21, 0x3F	; 63
    a29e:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    a2a2:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    a2a6:	9b 01       	movw	r18, r22
    a2a8:	ac 01       	movw	r20, r24
    a2aa:	e0 90 dd 76 	lds	r14, 0x76DD
    a2ae:	f0 90 de 76 	lds	r15, 0x76DE
    a2b2:	00 91 df 76 	lds	r16, 0x76DF
    a2b6:	10 91 e0 76 	lds	r17, 0x76E0
    a2ba:	61 ef       	ldi	r22, 0xF1	; 241
    a2bc:	7f ef       	ldi	r23, 0xFF	; 255
    a2be:	8f ef       	ldi	r24, 0xFF	; 255
    a2c0:	9f ef       	ldi	r25, 0xFF	; 255
    a2c2:	f0 ef       	ldi	r31, 0xF0	; 240
    a2c4:	cf 2e       	mov	r12, r31
    a2c6:	ff ef       	ldi	r31, 0xFF	; 255
    a2c8:	df 2e       	mov	r13, r31
    a2ca:	e4 e0       	ldi	r30, 0x04	; 4
    a2cc:	ae 2e       	mov	r10, r30
    a2ce:	b1 2c       	mov	r11, r1
    a2d0:	0e 94 1b 50 	call	0xa036	; 0xa036 <roll>
    a2d4:	22 e3       	ldi	r18, 0x32	; 50
    a2d6:	c2 2e       	mov	r12, r18
    a2d8:	d1 2c       	mov	r13, r1
			PMDUpdate(&hAxis[AxisPitch]);	
			//Adicionando correccion
			rad=grados2rad(AJUSTE_ROLL_HOME_POSI_TIME);
			Correcion=rad2usteps(&hAxis[AxisPitch].axisSettings,rad);
			printf("search_home_roll_positive=> Factor de correcion de roll (search_home_positive) en uPasos = %ld\n",Correcion);
			printf("search_home_roll_positive=> home = %ld\n",*home);
    a2da:	90 ef       	ldi	r25, 0xF0	; 240
    a2dc:	29 2e       	mov	r2, r25
    a2de:	9a e4       	ldi	r25, 0x4A	; 74
    a2e0:	39 2e       	mov	r3, r25
			*home = *home+Correcion;	
			printf("search_home_roll_positive=> home + Correcion = %ld\n",*home);	
    a2e2:	88 e1       	ldi	r24, 0x18	; 24
    a2e4:	48 2e       	mov	r4, r24
    a2e6:	8b e4       	ldi	r24, 0x4B	; 75
    a2e8:	58 2e       	mov	r5, r24
			
		timer --;
		
		#ifdef DEBUGROBOTICS_HOME		
		if(timer==0)
			printf("search_home_roll_positive=> Time OUT . \n ");				
    a2ea:	0c e4       	ldi	r16, 0x4C	; 76
    a2ec:	60 2e       	mov	r6, r16
    a2ee:	0b e4       	ldi	r16, 0x4B	; 75
    a2f0:	70 2e       	mov	r7, r16
		printf("search_home_roll_positive=> Moviendo en direccion positiva. \n ");
    a2f2:	16 e7       	ldi	r17, 0x76	; 118
    a2f4:	a1 2e       	mov	r10, r17
    a2f6:	1b e4       	ldi	r17, 0x4B	; 75
    a2f8:	b1 2e       	mov	r11, r17
	
	timer = 50;//50; 	//Este valor garantiza un movimiento de 45 grados en la direccion positiva
	
	do 
	{ 
		PMDGetEventStatus(&hAxis[AxisRoll],&status);
    a2fa:	89 e9       	ldi	r24, 0x99	; 153
    a2fc:	96 e7       	ldi	r25, 0x76	; 118
    a2fe:	be 01       	movw	r22, r28
    a300:	6f 5f       	subi	r22, 0xFF	; 255
    a302:	7f 4f       	sbci	r23, 0xFF	; 255
    a304:	0e 94 75 78 	call	0xf0ea	; 0xf0ea <PMDGetEventStatus>
		
		if((status & PMDEventCaptureReceivedMask) != 0) // se ha capturado home
    a308:	89 81       	ldd	r24, Y+1	; 0x01
    a30a:	83 fd       	sbrc	r24, 3
    a30c:	03 c0       	rjmp	.+6      	; 0xa314 <search_home_roll_positive+0x126>
    a30e:	01 e0       	ldi	r16, 0x01	; 1
    a310:	10 e0       	ldi	r17, 0x00	; 0
    a312:	86 c0       	rjmp	.+268    	; 0xa420 <search_home_roll_positive+0x232>
		{   
			#ifdef DEBUGROBOTICS_HOME
				printf("search_home_roll_positive=> Captura de HOME realizada. \n ");			
    a314:	00 d0       	rcall	.+0      	; 0xa316 <search_home_roll_positive+0x128>
    a316:	86 e2       	ldi	r24, 0x26	; 38
    a318:	9a e4       	ldi	r25, 0x4A	; 74
    a31a:	ed b7       	in	r30, 0x3d	; 61
    a31c:	fe b7       	in	r31, 0x3e	; 62
    a31e:	92 83       	std	Z+2, r25	; 0x02
    a320:	81 83       	std	Z+1, r24	; 0x01
    a322:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			#endif
			
			PMDGetCaptureValue(&hAxis[AxisRoll],home);
    a326:	0f 90       	pop	r0
    a328:	0f 90       	pop	r0
    a32a:	89 e9       	ldi	r24, 0x99	; 153
    a32c:	96 e7       	ldi	r25, 0x76	; 118
    a32e:	b4 01       	movw	r22, r8
    a330:	0e 94 24 7b 	call	0xf648	; 0xf648 <PMDGetCaptureValue>
			PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventCaptureReceivedMask);
    a334:	89 e9       	ldi	r24, 0x99	; 153
    a336:	96 e7       	ldi	r25, 0x76	; 118
    a338:	67 ef       	ldi	r22, 0xF7	; 247
    a33a:	7f ef       	ldi	r23, 0xFF	; 255
    a33c:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
			
			#ifdef DEBUGROBOTICS_HOME
				printf("search_home_roll_positive=> Parando Motor... \n ");
    a340:	00 d0       	rcall	.+0      	; 0xa342 <search_home_roll_positive+0x154>
    a342:	80 e6       	ldi	r24, 0x60	; 96
    a344:	9a e4       	ldi	r25, 0x4A	; 74
    a346:	ed b7       	in	r30, 0x3d	; 61
    a348:	fe b7       	in	r31, 0x3e	; 62
    a34a:	92 83       	std	Z+2, r25	; 0x02
    a34c:	81 83       	std	Z+1, r24	; 0x01
    a34e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
				
			//se Cambia la variable a 0 para salir del ciclo.
			find_home_out=0;
				
			//detener el movimiento
			PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
    a352:	0f 90       	pop	r0
    a354:	0f 90       	pop	r0
    a356:	89 e9       	ldi	r24, 0x99	; 153
    a358:	96 e7       	ldi	r25, 0x76	; 118
    a35a:	61 e0       	ldi	r22, 0x01	; 1
    a35c:	70 e0       	ldi	r23, 0x00	; 0
    a35e:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
			PMDUpdate(&hAxis[AxisRoll]);
    a362:	89 e9       	ldi	r24, 0x99	; 153
    a364:	96 e7       	ldi	r25, 0x76	; 118
    a366:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode ); 
    a36a:	89 e3       	ldi	r24, 0x39	; 57
    a36c:	96 e7       	ldi	r25, 0x76	; 118
    a36e:	61 e0       	ldi	r22, 0x01	; 1
    a370:	70 e0       	ldi	r23, 0x00	; 0
    a372:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
			PMDUpdate(&hAxis[AxisPitch]);	
    a376:	89 e3       	ldi	r24, 0x39	; 57
    a378:	96 e7       	ldi	r25, 0x76	; 118
    a37a:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			//Adicionando correccion
			rad=grados2rad(AJUSTE_ROLL_HOME_POSI_TIME);
    a37e:	60 e0       	ldi	r22, 0x00	; 0
    a380:	70 e0       	ldi	r23, 0x00	; 0
    a382:	80 ee       	ldi	r24, 0xE0	; 224
    a384:	90 ec       	ldi	r25, 0xC0	; 192
    a386:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <grados2rad>
    a38a:	ab 01       	movw	r20, r22
    a38c:	bc 01       	movw	r22, r24
			Correcion=rad2usteps(&hAxis[AxisPitch].axisSettings,rad);
    a38e:	8d e3       	ldi	r24, 0x3D	; 61
    a390:	96 e7       	ldi	r25, 0x76	; 118
    a392:	0e 94 10 29 	call	0x5220	; 0x5220 <rad2usteps>
    a396:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    a39a:	7b 01       	movw	r14, r22
    a39c:	8c 01       	movw	r16, r24
			printf("search_home_roll_positive=> Factor de correcion de roll (search_home_positive) en uPasos = %ld\n",Correcion);
    a39e:	00 d0       	rcall	.+0      	; 0xa3a0 <search_home_roll_positive+0x1b2>
    a3a0:	00 d0       	rcall	.+0      	; 0xa3a2 <search_home_roll_positive+0x1b4>
    a3a2:	00 d0       	rcall	.+0      	; 0xa3a4 <search_home_roll_positive+0x1b6>
    a3a4:	80 e9       	ldi	r24, 0x90	; 144
    a3a6:	9a e4       	ldi	r25, 0x4A	; 74
    a3a8:	ed b7       	in	r30, 0x3d	; 61
    a3aa:	fe b7       	in	r31, 0x3e	; 62
    a3ac:	92 83       	std	Z+2, r25	; 0x02
    a3ae:	81 83       	std	Z+1, r24	; 0x01
    a3b0:	e3 82       	std	Z+3, r14	; 0x03
    a3b2:	f4 82       	std	Z+4, r15	; 0x04
    a3b4:	05 83       	std	Z+5, r16	; 0x05
    a3b6:	16 83       	std	Z+6, r17	; 0x06
    a3b8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			printf("search_home_roll_positive=> home = %ld\n",*home);
    a3bc:	ed b7       	in	r30, 0x3d	; 61
    a3be:	fe b7       	in	r31, 0x3e	; 62
    a3c0:	32 82       	std	Z+2, r3	; 0x02
    a3c2:	21 82       	std	Z+1, r2	; 0x01
    a3c4:	f4 01       	movw	r30, r8
    a3c6:	80 81       	ld	r24, Z
    a3c8:	91 81       	ldd	r25, Z+1	; 0x01
    a3ca:	a2 81       	ldd	r26, Z+2	; 0x02
    a3cc:	b3 81       	ldd	r27, Z+3	; 0x03
    a3ce:	ed b7       	in	r30, 0x3d	; 61
    a3d0:	fe b7       	in	r31, 0x3e	; 62
    a3d2:	83 83       	std	Z+3, r24	; 0x03
    a3d4:	94 83       	std	Z+4, r25	; 0x04
    a3d6:	a5 83       	std	Z+5, r26	; 0x05
    a3d8:	b6 83       	std	Z+6, r27	; 0x06
    a3da:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			*home = *home+Correcion;	
    a3de:	f4 01       	movw	r30, r8
    a3e0:	80 81       	ld	r24, Z
    a3e2:	91 81       	ldd	r25, Z+1	; 0x01
    a3e4:	a2 81       	ldd	r26, Z+2	; 0x02
    a3e6:	b3 81       	ldd	r27, Z+3	; 0x03
    a3e8:	8e 0d       	add	r24, r14
    a3ea:	9f 1d       	adc	r25, r15
    a3ec:	a0 1f       	adc	r26, r16
    a3ee:	b1 1f       	adc	r27, r17
    a3f0:	80 83       	st	Z, r24
    a3f2:	91 83       	std	Z+1, r25	; 0x01
    a3f4:	a2 83       	std	Z+2, r26	; 0x02
    a3f6:	b3 83       	std	Z+3, r27	; 0x03
			printf("search_home_roll_positive=> home + Correcion = %ld\n",*home);	
    a3f8:	ed b7       	in	r30, 0x3d	; 61
    a3fa:	fe b7       	in	r31, 0x3e	; 62
    a3fc:	52 82       	std	Z+2, r5	; 0x02
    a3fe:	41 82       	std	Z+1, r4	; 0x01
    a400:	83 83       	std	Z+3, r24	; 0x03
    a402:	94 83       	std	Z+4, r25	; 0x04
    a404:	a5 83       	std	Z+5, r26	; 0x05
    a406:	b6 83       	std	Z+6, r27	; 0x06
    a408:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    a40c:	00 e0       	ldi	r16, 0x00	; 0
    a40e:	10 e0       	ldi	r17, 0x00	; 0
    a410:	8d b7       	in	r24, 0x3d	; 61
    a412:	9e b7       	in	r25, 0x3e	; 62
    a414:	06 96       	adiw	r24, 0x06	; 6
    a416:	0f b6       	in	r0, 0x3f	; 63
    a418:	f8 94       	cli
    a41a:	9e bf       	out	0x3e, r25	; 62
    a41c:	0f be       	out	0x3f, r0	; 63
    a41e:	8d bf       	out	0x3d, r24	; 61
			
		}
			
		timer --;
    a420:	08 94       	sec
    a422:	c1 08       	sbc	r12, r1
    a424:	d1 08       	sbc	r13, r1
		
		#ifdef DEBUGROBOTICS_HOME		
		if(timer==0)
    a426:	c1 14       	cp	r12, r1
    a428:	d1 04       	cpc	r13, r1
    a42a:	49 f4       	brne	.+18     	; 0xa43e <search_home_roll_positive+0x250>
			printf("search_home_roll_positive=> Time OUT . \n ");				
    a42c:	00 d0       	rcall	.+0      	; 0xa42e <search_home_roll_positive+0x240>
    a42e:	ed b7       	in	r30, 0x3d	; 61
    a430:	fe b7       	in	r31, 0x3e	; 62
    a432:	72 82       	std	Z+2, r7	; 0x02
    a434:	61 82       	std	Z+1, r6	; 0x01
    a436:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    a43a:	0f 90       	pop	r0
    a43c:	0f 90       	pop	r0
		printf("search_home_roll_positive=> Moviendo en direccion positiva. \n ");
    a43e:	00 d0       	rcall	.+0      	; 0xa440 <search_home_roll_positive+0x252>
    a440:	ed b7       	in	r30, 0x3d	; 61
    a442:	fe b7       	in	r31, 0x3e	; 62
    a444:	b2 82       	std	Z+2, r11	; 0x02
    a446:	a1 82       	std	Z+1, r10	; 0x01
    a448:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		#endif
	} 
	while  ((find_home_out==1) && (timer !=0));//Mientras encuentre HOME o no  se cumpla el timer
    a44c:	0f 90       	pop	r0
    a44e:	0f 90       	pop	r0
    a450:	01 30       	cpi	r16, 0x01	; 1
    a452:	11 05       	cpc	r17, r1
    a454:	21 f4       	brne	.+8      	; 0xa45e <search_home_roll_positive+0x270>
    a456:	c1 14       	cp	r12, r1
    a458:	d1 04       	cpc	r13, r1
    a45a:	09 f0       	breq	.+2      	; 0xa45e <search_home_roll_positive+0x270>
    a45c:	4e cf       	rjmp	.-356    	; 0xa2fa <search_home_roll_positive+0x10c>

	
	#ifdef DEBUGROBOTICS_HOME		
		printf("search_home_roll_positive=> El Valor del timer es  %d \n",timer);	
    a45e:	00 d0       	rcall	.+0      	; 0xa460 <search_home_roll_positive+0x272>
    a460:	00 d0       	rcall	.+0      	; 0xa462 <search_home_roll_positive+0x274>
    a462:	85 eb       	ldi	r24, 0xB5	; 181
    a464:	9b e4       	ldi	r25, 0x4B	; 75
    a466:	ed b7       	in	r30, 0x3d	; 61
    a468:	fe b7       	in	r31, 0x3e	; 62
    a46a:	92 83       	std	Z+2, r25	; 0x02
    a46c:	81 83       	std	Z+1, r24	; 0x01
    a46e:	d4 82       	std	Z+4, r13	; 0x04
    a470:	c3 82       	std	Z+3, r12	; 0x03
    a472:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	#endif	
	
	//detener  el movimiento
	PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
    a476:	0f 90       	pop	r0
    a478:	0f 90       	pop	r0
    a47a:	0f 90       	pop	r0
    a47c:	0f 90       	pop	r0
    a47e:	89 e9       	ldi	r24, 0x99	; 153
    a480:	96 e7       	ldi	r25, 0x76	; 118
    a482:	61 e0       	ldi	r22, 0x01	; 1
    a484:	70 e0       	ldi	r23, 0x00	; 0
    a486:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
	PMDUpdate(&hAxis[AxisRoll]);
    a48a:	89 e9       	ldi	r24, 0x99	; 153
    a48c:	96 e7       	ldi	r25, 0x76	; 118
    a48e:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
	PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode ); 
    a492:	89 e3       	ldi	r24, 0x39	; 57
    a494:	96 e7       	ldi	r25, 0x76	; 118
    a496:	61 e0       	ldi	r22, 0x01	; 1
    a498:	70 e0       	ldi	r23, 0x00	; 0
    a49a:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
	PMDUpdate(&hAxis[AxisPitch]);
    a49e:	89 e3       	ldi	r24, 0x39	; 57
    a4a0:	96 e7       	ldi	r25, 0x76	; 118
    a4a2:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
	
	/*Se cambia el perfil movimiento a perfil trapezoidal*/ 
	PMDSetProfileMode(&hAxis[AxisRoll], PMDTrapezoidalProfile);
    a4a6:	89 e9       	ldi	r24, 0x99	; 153
    a4a8:	96 e7       	ldi	r25, 0x76	; 118
    a4aa:	60 e0       	ldi	r22, 0x00	; 0
    a4ac:	70 e0       	ldi	r23, 0x00	; 0
    a4ae:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
	PMDSetProfileMode(&hAxis[AxisPitch], PMDTrapezoidalProfile);	
    a4b2:	89 e3       	ldi	r24, 0x39	; 57
    a4b4:	96 e7       	ldi	r25, 0x76	; 118
    a4b6:	60 e0       	ldi	r22, 0x00	; 0
    a4b8:	70 e0       	ldi	r23, 0x00	; 0
    a4ba:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
	
	

	
	
}
    a4be:	26 96       	adiw	r28, 0x06	; 6
    a4c0:	0f b6       	in	r0, 0x3f	; 63
    a4c2:	f8 94       	cli
    a4c4:	de bf       	out	0x3e, r29	; 62
    a4c6:	0f be       	out	0x3f, r0	; 63
    a4c8:	cd bf       	out	0x3d, r28	; 61
    a4ca:	cf 91       	pop	r28
    a4cc:	df 91       	pop	r29
    a4ce:	1f 91       	pop	r17
    a4d0:	0f 91       	pop	r16
    a4d2:	ff 90       	pop	r15
    a4d4:	ef 90       	pop	r14
    a4d6:	df 90       	pop	r13
    a4d8:	cf 90       	pop	r12
    a4da:	bf 90       	pop	r11
    a4dc:	af 90       	pop	r10
    a4de:	9f 90       	pop	r9
    a4e0:	8f 90       	pop	r8
    a4e2:	7f 90       	pop	r7
    a4e4:	6f 90       	pop	r6
    a4e6:	5f 90       	pop	r5
    a4e8:	4f 90       	pop	r4
    a4ea:	3f 90       	pop	r3
    a4ec:	2f 90       	pop	r2
    a4ee:	08 95       	ret

0000a4f0 <pitch>:


//**********************************************************************************************
void pitch(PMDint32 position, PMDint32 velocity, PMDuint32 acceleration,
					PMDint16 actualizar,PMDint16 modo_movimiento)
{
    a4f0:	2f 92       	push	r2
    a4f2:	3f 92       	push	r3
    a4f4:	4f 92       	push	r4
    a4f6:	5f 92       	push	r5
    a4f8:	6f 92       	push	r6
    a4fa:	7f 92       	push	r7
    a4fc:	8f 92       	push	r8
    a4fe:	9f 92       	push	r9
    a500:	af 92       	push	r10
    a502:	bf 92       	push	r11
    a504:	cf 92       	push	r12
    a506:	df 92       	push	r13
    a508:	ef 92       	push	r14
    a50a:	ff 92       	push	r15
    a50c:	0f 93       	push	r16
    a50e:	1f 93       	push	r17
    a510:	df 93       	push	r29
    a512:	cf 93       	push	r28
    a514:	cd b7       	in	r28, 0x3d	; 61
    a516:	de b7       	in	r29, 0x3e	; 62
    a518:	2e 97       	sbiw	r28, 0x0e	; 14
    a51a:	0f b6       	in	r0, 0x3f	; 63
    a51c:	f8 94       	cli
    a51e:	de bf       	out	0x3e, r29	; 62
    a520:	0f be       	out	0x3f, r0	; 63
    a522:	cd bf       	out	0x3d, r28	; 61
    a524:	69 87       	std	Y+9, r22	; 0x09
    a526:	7a 87       	std	Y+10, r23	; 0x0a
    a528:	8b 87       	std	Y+11, r24	; 0x0b
    a52a:	9c 87       	std	Y+12, r25	; 0x0c
    a52c:	39 01       	movw	r6, r18
    a52e:	4a 01       	movw	r8, r20
    a530:	17 01       	movw	r2, r14
    a532:	28 01       	movw	r4, r16
    a534:	de 86       	std	Y+14, r13	; 0x0e
    a536:	cd 86       	std	Y+13, r12	; 0x0d
	PMDint32 posicion_actual_motor_pitch, 
	posicion_actual_motor_roll;
	#endif
   
   /*habilitando eventos de limite para realizar movimientos de PiTch*/
	PMDSetLimitSwitchMode(&hAxis[AxisRoll],PMDLimitEnabled);
    a538:	89 e9       	ldi	r24, 0x99	; 153
    a53a:	96 e7       	ldi	r25, 0x76	; 118
    a53c:	61 e0       	ldi	r22, 0x01	; 1
    a53e:	70 e0       	ldi	r23, 0x00	; 0
    a540:	0e 94 bd 7a 	call	0xf57a	; 0xf57a <PMDSetLimitSwitchMode>
	PMDSetLimitSwitchMode(&hAxis[AxisPitch],PMDLimitEnabled);
    a544:	89 e3       	ldi	r24, 0x39	; 57
    a546:	96 e7       	ldi	r25, 0x76	; 118
    a548:	61 e0       	ldi	r22, 0x01	; 1
    a54a:	70 e0       	ldi	r23, 0x00	; 0
    a54c:	0e 94 bd 7a 	call	0xf57a	; 0xf57a <PMDSetLimitSwitchMode>
	PMDGetActualPosition(&hAxis[AxisRoll],&posicion_actual_motor_roll);
	printf("pitch=> Posicion encoder actual del motor de pitch %ld\n",posicion_actual_motor_pitch);
	printf("pitch=> Posicion encoder actual del motor de roll %ld\n",posicion_actual_motor_roll);
	#endif
	
	switch (modo_movimiento)
    a550:	21 e0       	ldi	r18, 0x01	; 1
    a552:	a2 16       	cp	r10, r18
    a554:	b1 04       	cpc	r11, r1
    a556:	31 f0       	breq	.+12     	; 0xa564 <pitch+0x74>
    a558:	34 e0       	ldi	r19, 0x04	; 4
    a55a:	a3 16       	cp	r10, r19
    a55c:	b1 04       	cpc	r11, r1
    a55e:	09 f0       	breq	.+2      	; 0xa562 <pitch+0x72>
    a560:	7d c0       	rjmp	.+250    	; 0xa65c <pitch+0x16c>
    a562:	60 c0       	rjmp	.+192    	; 0xa624 <pitch+0x134>
	{ 
		case (MOVIMIENTO_NORMAL):
			if(position!=none)
    a564:	89 85       	ldd	r24, Y+9	; 0x09
    a566:	9a 85       	ldd	r25, Y+10	; 0x0a
    a568:	ab 85       	ldd	r26, Y+11	; 0x0b
    a56a:	bc 85       	ldd	r27, Y+12	; 0x0c
    a56c:	81 5f       	subi	r24, 0xF1	; 241
    a56e:	9f 4f       	sbci	r25, 0xFF	; 255
    a570:	af 4f       	sbci	r26, 0xFF	; 255
    a572:	bf 4f       	sbci	r27, 0xFF	; 255
    a574:	09 f4       	brne	.+2      	; 0xa578 <pitch+0x88>
    a576:	72 c0       	rjmp	.+228    	; 0xa65c <pitch+0x16c>
			{
				//Leer el movimiento anterior de Pitch que esta almacenado en EEPROM
				eeprom_read_block((void*)&Mov_Pitch_Anterior_RAM,(const void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    a578:	ce 01       	movw	r24, r28
    a57a:	01 96       	adiw	r24, 0x01	; 1
    a57c:	6a e5       	ldi	r22, 0x5A	; 90
    a57e:	71 e0       	ldi	r23, 0x01	; 1
    a580:	44 e0       	ldi	r20, 0x04	; 4
    a582:	50 e0       	ldi	r21, 0x00	; 0
    a584:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
			//	#ifdef DEBUGROBOTICS
				printf("pitch=> Movimiento Anterior de pitch EEPROM de %s = %ld\n",AxisName(AxisPitch),Mov_Pitch_Anterior_RAM);
    a588:	83 e0       	ldi	r24, 0x03	; 3
    a58a:	90 e0       	ldi	r25, 0x00	; 0
    a58c:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    a590:	ad b7       	in	r26, 0x3d	; 61
    a592:	be b7       	in	r27, 0x3e	; 62
    a594:	18 97       	sbiw	r26, 0x08	; 8
    a596:	0f b6       	in	r0, 0x3f	; 63
    a598:	f8 94       	cli
    a59a:	be bf       	out	0x3e, r27	; 62
    a59c:	0f be       	out	0x3f, r0	; 63
    a59e:	ad bf       	out	0x3d, r26	; 61
    a5a0:	ed b7       	in	r30, 0x3d	; 61
    a5a2:	fe b7       	in	r31, 0x3e	; 62
    a5a4:	31 96       	adiw	r30, 0x01	; 1
    a5a6:	2d ee       	ldi	r18, 0xED	; 237
    a5a8:	3b e4       	ldi	r19, 0x4B	; 75
    a5aa:	12 96       	adiw	r26, 0x02	; 2
    a5ac:	3c 93       	st	X, r19
    a5ae:	2e 93       	st	-X, r18
    a5b0:	11 97       	sbiw	r26, 0x01	; 1
    a5b2:	93 83       	std	Z+3, r25	; 0x03
    a5b4:	82 83       	std	Z+2, r24	; 0x02
    a5b6:	89 81       	ldd	r24, Y+1	; 0x01
    a5b8:	9a 81       	ldd	r25, Y+2	; 0x02
    a5ba:	ab 81       	ldd	r26, Y+3	; 0x03
    a5bc:	bc 81       	ldd	r27, Y+4	; 0x04
    a5be:	84 83       	std	Z+4, r24	; 0x04
    a5c0:	95 83       	std	Z+5, r25	; 0x05
    a5c2:	a6 83       	std	Z+6, r26	; 0x06
    a5c4:	b7 83       	std	Z+7, r27	; 0x07
    a5c6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			//	#endif
				//Es un movimiento normal se debe de actualizar la eeprom.
			//#ifdef DEBUGROBOTICS
				printf("pitch=> Actualizando ActualPosition motor de  PITCH y ROLL en pitch();! \n");
    a5ca:	2d b7       	in	r18, 0x3d	; 61
    a5cc:	3e b7       	in	r19, 0x3e	; 62
    a5ce:	28 5f       	subi	r18, 0xF8	; 248
    a5d0:	3f 4f       	sbci	r19, 0xFF	; 255
    a5d2:	0f b6       	in	r0, 0x3f	; 63
    a5d4:	f8 94       	cli
    a5d6:	3e bf       	out	0x3e, r19	; 62
    a5d8:	0f be       	out	0x3f, r0	; 63
    a5da:	2d bf       	out	0x3d, r18	; 61
    a5dc:	86 e2       	ldi	r24, 0x26	; 38
    a5de:	9c e4       	ldi	r25, 0x4C	; 76
    a5e0:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
			//	#endif
				PMDSetActualPosition(&hAxis[AxisPitch],Mov_Pitch_Anterior_RAM);
    a5e4:	49 81       	ldd	r20, Y+1	; 0x01
    a5e6:	5a 81       	ldd	r21, Y+2	; 0x02
    a5e8:	6b 81       	ldd	r22, Y+3	; 0x03
    a5ea:	7c 81       	ldd	r23, Y+4	; 0x04
    a5ec:	89 e3       	ldi	r24, 0x39	; 57
    a5ee:	96 e7       	ldi	r25, 0x76	; 118
    a5f0:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>
				PMDSetActualPosition(&hAxis[AxisRoll],-(Mov_Pitch_Anterior_RAM));
    a5f4:	49 81       	ldd	r20, Y+1	; 0x01
    a5f6:	5a 81       	ldd	r21, Y+2	; 0x02
    a5f8:	6b 81       	ldd	r22, Y+3	; 0x03
    a5fa:	7c 81       	ldd	r23, Y+4	; 0x04
    a5fc:	70 95       	com	r23
    a5fe:	60 95       	com	r22
    a600:	50 95       	com	r21
    a602:	41 95       	neg	r20
    a604:	5f 4f       	sbci	r21, 0xFF	; 255
    a606:	6f 4f       	sbci	r22, 0xFF	; 255
    a608:	7f 4f       	sbci	r23, 0xFF	; 255
    a60a:	89 e9       	ldi	r24, 0x99	; 153
    a60c:	96 e7       	ldi	r25, 0x76	; 118
    a60e:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>
				//Actualizo el movimiento anterior con el actual, para el proximo movimiento.
				eeprom_write_block((const void*)&position,(void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    a612:	ce 01       	movw	r24, r28
    a614:	09 96       	adiw	r24, 0x09	; 9
    a616:	6a e5       	ldi	r22, 0x5A	; 90
    a618:	71 e0       	ldi	r23, 0x01	; 1
    a61a:	44 e0       	ldi	r20, 0x04	; 4
    a61c:	50 e0       	ldi	r21, 0x00	; 0
    a61e:	0e 94 b1 a0 	call	0x14162	; 0x14162 <__eewr_block_m1280>
    a622:	1c c0       	rjmp	.+56     	; 0xa65c <pitch+0x16c>
			//-Hago HOME luego me muevo hacia una posicion X y luego hago home.
			//-Apago el controlador y se mueve por error los motores de pitch y roll.
			#ifdef DEBUGROBOTICS
				printf("pitch=> Iniciando variable Mov_Pitch_Anterior a Cero.! \n");
			#endif
			temp=0;
    a624:	1d 82       	std	Y+5, r1	; 0x05
    a626:	1e 82       	std	Y+6, r1	; 0x06
    a628:	1f 82       	std	Y+7, r1	; 0x07
    a62a:	18 86       	std	Y+8, r1	; 0x08
			eeprom_write_block((const void*)&temp,(void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    a62c:	ce 01       	movw	r24, r28
    a62e:	05 96       	adiw	r24, 0x05	; 5
    a630:	6a e5       	ldi	r22, 0x5A	; 90
    a632:	71 e0       	ldi	r23, 0x01	; 1
    a634:	44 e0       	ldi	r20, 0x04	; 4
    a636:	50 e0       	ldi	r21, 0x00	; 0
    a638:	0e 94 b1 a0 	call	0x14162	; 0x14162 <__eewr_block_m1280>
			PMDSetActualPosition(&hAxis[AxisPitch],0);
    a63c:	89 e3       	ldi	r24, 0x39	; 57
    a63e:	96 e7       	ldi	r25, 0x76	; 118
    a640:	40 e0       	ldi	r20, 0x00	; 0
    a642:	50 e0       	ldi	r21, 0x00	; 0
    a644:	60 e0       	ldi	r22, 0x00	; 0
    a646:	70 e0       	ldi	r23, 0x00	; 0
    a648:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>
			PMDSetActualPosition(&hAxis[AxisRoll],0);
    a64c:	89 e9       	ldi	r24, 0x99	; 153
    a64e:	96 e7       	ldi	r25, 0x76	; 118
    a650:	40 e0       	ldi	r20, 0x00	; 0
    a652:	50 e0       	ldi	r21, 0x00	; 0
    a654:	60 e0       	ldi	r22, 0x00	; 0
    a656:	70 e0       	ldi	r23, 0x00	; 0
    a658:	0e 94 7b 7e 	call	0xfcf6	; 0xfcf6 <PMDSetActualPosition>
	
	/*Realizo el Movimiento en el motor de Pitch */	
	
	
	
	mov_axis(AxisPitch, position, velocity, acceleration, actualizar);
    a65c:	49 85       	ldd	r20, Y+9	; 0x09
    a65e:	5a 85       	ldd	r21, Y+10	; 0x0a
    a660:	6b 85       	ldd	r22, Y+11	; 0x0b
    a662:	7c 85       	ldd	r23, Y+12	; 0x0c
    a664:	83 e0       	ldi	r24, 0x03	; 3
    a666:	90 e0       	ldi	r25, 0x00	; 0
    a668:	94 01       	movw	r18, r8
    a66a:	83 01       	movw	r16, r6
    a66c:	72 01       	movw	r14, r4
    a66e:	61 01       	movw	r12, r2
    a670:	ad 84       	ldd	r10, Y+13	; 0x0d
    a672:	be 84       	ldd	r11, Y+14	; 0x0e
    a674:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
	/*none es utilizado cuando se utiliza un perfil de velocidad constante.*/
	if (position == none)
    a678:	89 85       	ldd	r24, Y+9	; 0x09
    a67a:	9a 85       	ldd	r25, Y+10	; 0x0a
    a67c:	ab 85       	ldd	r26, Y+11	; 0x0b
    a67e:	bc 85       	ldd	r27, Y+12	; 0x0c
    a680:	81 3f       	cpi	r24, 0xF1	; 241
    a682:	3f ef       	ldi	r19, 0xFF	; 255
    a684:	93 07       	cpc	r25, r19
    a686:	3f ef       	ldi	r19, 0xFF	; 255
    a688:	a3 07       	cpc	r26, r19
    a68a:	3f ef       	ldi	r19, 0xFF	; 255
    a68c:	b3 07       	cpc	r27, r19
    a68e:	71 f4       	brne	.+28     	; 0xa6ac <pitch+0x1bc>
	{
		
		/*Realizo el Movimiento en el motor de roll */	
		mov_axis(AxisRoll, position, -(velocity), acceleration, actualizar);
    a690:	00 27       	eor	r16, r16
    a692:	11 27       	eor	r17, r17
    a694:	98 01       	movw	r18, r16
    a696:	06 19       	sub	r16, r6
    a698:	17 09       	sbc	r17, r7
    a69a:	28 09       	sbc	r18, r8
    a69c:	39 09       	sbc	r19, r9
    a69e:	84 e0       	ldi	r24, 0x04	; 4
    a6a0:	90 e0       	ldi	r25, 0x00	; 0
    a6a2:	41 ef       	ldi	r20, 0xF1	; 241
    a6a4:	5f ef       	ldi	r21, 0xFF	; 255
    a6a6:	6f ef       	ldi	r22, 0xFF	; 255
    a6a8:	7f ef       	ldi	r23, 0xFF	; 255
    a6aa:	0d c0       	rjmp	.+26     	; 0xa6c6 <pitch+0x1d6>
	}
	else
	{
		/*Realizo el Movimiento en el motor de roll */	
		mov_axis(AxisRoll, -position, (velocity), acceleration, actualizar);
    a6ac:	44 27       	eor	r20, r20
    a6ae:	55 27       	eor	r21, r21
    a6b0:	ba 01       	movw	r22, r20
    a6b2:	48 1b       	sub	r20, r24
    a6b4:	59 0b       	sbc	r21, r25
    a6b6:	6a 0b       	sbc	r22, r26
    a6b8:	7b 0b       	sbc	r23, r27
    a6ba:	84 e0       	ldi	r24, 0x04	; 4
    a6bc:	90 e0       	ldi	r25, 0x00	; 0
    a6be:	94 01       	movw	r18, r8
    a6c0:	83 01       	movw	r16, r6
    a6c2:	72 01       	movw	r14, r4
    a6c4:	61 01       	movw	r12, r2
    a6c6:	ad 84       	ldd	r10, Y+13	; 0x0d
    a6c8:	be 84       	ldd	r11, Y+14	; 0x0e
    a6ca:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
		
		
	}
	
	
}
    a6ce:	2e 96       	adiw	r28, 0x0e	; 14
    a6d0:	0f b6       	in	r0, 0x3f	; 63
    a6d2:	f8 94       	cli
    a6d4:	de bf       	out	0x3e, r29	; 62
    a6d6:	0f be       	out	0x3f, r0	; 63
    a6d8:	cd bf       	out	0x3d, r28	; 61
    a6da:	cf 91       	pop	r28
    a6dc:	df 91       	pop	r29
    a6de:	1f 91       	pop	r17
    a6e0:	0f 91       	pop	r16
    a6e2:	ff 90       	pop	r15
    a6e4:	ef 90       	pop	r14
    a6e6:	df 90       	pop	r13
    a6e8:	cf 90       	pop	r12
    a6ea:	bf 90       	pop	r11
    a6ec:	af 90       	pop	r10
    a6ee:	9f 90       	pop	r9
    a6f0:	8f 90       	pop	r8
    a6f2:	7f 90       	pop	r7
    a6f4:	6f 90       	pop	r6
    a6f6:	5f 90       	pop	r5
    a6f8:	4f 90       	pop	r4
    a6fa:	3f 90       	pop	r3
    a6fc:	2f 90       	pop	r2
    a6fe:	08 95       	ret

0000a700 <calibration>:
		return b;
}

/**********************************************************************************************************************/
PMDint32 calibration(int16 Axis)
{
    a700:	2f 92       	push	r2
    a702:	3f 92       	push	r3
    a704:	4f 92       	push	r4
    a706:	5f 92       	push	r5
    a708:	6f 92       	push	r6
    a70a:	7f 92       	push	r7
    a70c:	8f 92       	push	r8
    a70e:	9f 92       	push	r9
    a710:	af 92       	push	r10
    a712:	bf 92       	push	r11
    a714:	cf 92       	push	r12
    a716:	df 92       	push	r13
    a718:	ef 92       	push	r14
    a71a:	ff 92       	push	r15
    a71c:	0f 93       	push	r16
    a71e:	1f 93       	push	r17
    a720:	df 93       	push	r29
    a722:	cf 93       	push	r28
    a724:	cd b7       	in	r28, 0x3d	; 61
    a726:	de b7       	in	r29, 0x3e	; 62
    a728:	64 97       	sbiw	r28, 0x14	; 20
    a72a:	0f b6       	in	r0, 0x3f	; 63
    a72c:	f8 94       	cli
    a72e:	de bf       	out	0x3e, r29	; 62
    a730:	0f be       	out	0x3f, r0	; 63
    a732:	cd bf       	out	0x3d, r28	; 61
    a734:	2c 01       	movw	r4, r24
	PMDuint16 signal_status;
	int16 i=0,Cont=0;
	

	//Elimina el Error.
	PMDClearPositionError(&hAxis[Axis]);
    a736:	80 e6       	ldi	r24, 0x60	; 96
    a738:	90 e0       	ldi	r25, 0x00	; 0
    a73a:	48 9e       	mul	r4, r24
    a73c:	10 01       	movw	r2, r0
    a73e:	49 9e       	mul	r4, r25
    a740:	30 0c       	add	r3, r0
    a742:	58 9e       	mul	r5, r24
    a744:	30 0c       	add	r3, r0
    a746:	11 24       	eor	r1, r1
    a748:	19 e1       	ldi	r17, 0x19	; 25
    a74a:	c1 2e       	mov	r12, r17
    a74c:	15 e7       	ldi	r17, 0x75	; 117
    a74e:	d1 2e       	mov	r13, r17
    a750:	2c 0c       	add	r2, r12
    a752:	3d 1c       	adc	r3, r13
    a754:	c1 01       	movw	r24, r2
    a756:	0e 94 42 7c 	call	0xf884	; 0xf884 <PMDClearPositionError>
    a75a:	21 e0       	ldi	r18, 0x01	; 1
    a75c:	30 e0       	ldi	r19, 0x00	; 0
    a75e:	40 e0       	ldi	r20, 0x00	; 0
    a760:	50 e8       	ldi	r21, 0x80	; 128
    a762:	2f 87       	std	Y+15, r18	; 0x0f
    a764:	38 8b       	std	Y+16, r19	; 0x10
    a766:	49 8b       	std	Y+17, r20	; 0x11
    a768:	5a 8b       	std	Y+18, r21	; 0x12
    a76a:	8f ef       	ldi	r24, 0xFF	; 255
    a76c:	9f ef       	ldi	r25, 0xFF	; 255
    a76e:	af ef       	ldi	r26, 0xFF	; 255
    a770:	bf e7       	ldi	r27, 0x7F	; 127
    a772:	8f 83       	std	Y+7, r24	; 0x07
    a774:	98 87       	std	Y+8, r25	; 0x08
    a776:	a9 87       	std	Y+9, r26	; 0x09
    a778:	ba 87       	std	Y+10, r27	; 0x0a
    a77a:	1b 86       	std	Y+11, r1	; 0x0b
    a77c:	1c 86       	std	Y+12, r1	; 0x0c
    a77e:	1d 86       	std	Y+13, r1	; 0x0d
    a780:	1e 86       	std	Y+14, r1	; 0x0e
    a782:	a2 e0       	ldi	r26, 0x02	; 2
    a784:	b0 e0       	ldi	r27, 0x00	; 0
    a786:	bc 8b       	std	Y+20, r27	; 0x14
    a788:	ab 8b       	std	Y+19, r26	; 0x13
	for (i=0; i<5; i++)
	{
		//Mover el eje en la direccion positiva del movimiento. Hasta el que llegue al limite de
		//fin de carrera
		
		switch (Axis)
    a78a:	b2 e0       	ldi	r27, 0x02	; 2
    a78c:	4b 16       	cp	r4, r27
    a78e:	51 04       	cpc	r5, r1
    a790:	69 f1       	breq	.+90     	; 0xa7ec <calibration+0xec>
    a792:	e3 e0       	ldi	r30, 0x03	; 3
    a794:	4e 16       	cp	r4, r30
    a796:	51 04       	cpc	r5, r1
    a798:	4c f4       	brge	.+18     	; 0xa7ac <calibration+0xac>
    a79a:	41 14       	cp	r4, r1
    a79c:	51 04       	cpc	r5, r1
    a79e:	81 f0       	breq	.+32     	; 0xa7c0 <calibration+0xc0>
    a7a0:	f1 e0       	ldi	r31, 0x01	; 1
    a7a2:	4f 16       	cp	r4, r31
    a7a4:	51 04       	cpc	r5, r1
    a7a6:	09 f0       	breq	.+2      	; 0xa7aa <calibration+0xaa>
    a7a8:	65 c0       	rjmp	.+202    	; 0xa874 <calibration+0x174>
    a7aa:	15 c0       	rjmp	.+42     	; 0xa7d6 <calibration+0xd6>
    a7ac:	23 e0       	ldi	r18, 0x03	; 3
    a7ae:	42 16       	cp	r4, r18
    a7b0:	51 04       	cpc	r5, r1
    a7b2:	91 f1       	breq	.+100    	; 0xa818 <calibration+0x118>
    a7b4:	34 e0       	ldi	r19, 0x04	; 4
    a7b6:	43 16       	cp	r4, r19
    a7b8:	51 04       	cpc	r5, r1
    a7ba:	09 f0       	breq	.+2      	; 0xa7be <calibration+0xbe>
    a7bc:	5b c0       	rjmp	.+182    	; 0xa874 <calibration+0x174>
    a7be:	43 c0       	rjmp	.+134    	; 0xa846 <calibration+0x146>
		{
			
			case (AxisWaist):
		      mov_axis(AxisWaist,INF,60000,100,update);
    a7c0:	80 e0       	ldi	r24, 0x00	; 0
    a7c2:	90 e0       	ldi	r25, 0x00	; 0
    a7c4:	4f ef       	ldi	r20, 0xFF	; 255
    a7c6:	5f ef       	ldi	r21, 0xFF	; 255
    a7c8:	6f ef       	ldi	r22, 0xFF	; 255
    a7ca:	7f e7       	ldi	r23, 0x7F	; 127
    a7cc:	00 e6       	ldi	r16, 0x60	; 96
    a7ce:	1a ee       	ldi	r17, 0xEA	; 234
    a7d0:	20 e0       	ldi	r18, 0x00	; 0
    a7d2:	30 e0       	ldi	r19, 0x00	; 0
    a7d4:	15 c0       	rjmp	.+42     	; 0xa800 <calibration+0x100>
		   break;
			
		   case (AxisShoulder):
		      mov_axis(AxisShoulder,INF,30000,100,update);
    a7d6:	81 e0       	ldi	r24, 0x01	; 1
    a7d8:	90 e0       	ldi	r25, 0x00	; 0
    a7da:	4f ef       	ldi	r20, 0xFF	; 255
    a7dc:	5f ef       	ldi	r21, 0xFF	; 255
    a7de:	6f ef       	ldi	r22, 0xFF	; 255
    a7e0:	7f e7       	ldi	r23, 0x7F	; 127
    a7e2:	00 e3       	ldi	r16, 0x30	; 48
    a7e4:	15 e7       	ldi	r17, 0x75	; 117
    a7e6:	20 e0       	ldi	r18, 0x00	; 0
    a7e8:	30 e0       	ldi	r19, 0x00	; 0
    a7ea:	0a c0       	rjmp	.+20     	; 0xa800 <calibration+0x100>
		   break;
			
			case (AxisElbow):
		      mov_axis(AxisElbow,INF,120000,100,update);
    a7ec:	82 e0       	ldi	r24, 0x02	; 2
    a7ee:	90 e0       	ldi	r25, 0x00	; 0
    a7f0:	4f ef       	ldi	r20, 0xFF	; 255
    a7f2:	5f ef       	ldi	r21, 0xFF	; 255
    a7f4:	6f ef       	ldi	r22, 0xFF	; 255
    a7f6:	7f e7       	ldi	r23, 0x7F	; 127
    a7f8:	00 ec       	ldi	r16, 0xC0	; 192
    a7fa:	14 ed       	ldi	r17, 0xD4	; 212
    a7fc:	21 e0       	ldi	r18, 0x01	; 1
    a7fe:	30 e0       	ldi	r19, 0x00	; 0
    a800:	b4 e6       	ldi	r27, 0x64	; 100
    a802:	cb 2e       	mov	r12, r27
    a804:	d1 2c       	mov	r13, r1
    a806:	e1 2c       	mov	r14, r1
    a808:	f1 2c       	mov	r15, r1
    a80a:	a0 ef       	ldi	r26, 0xF0	; 240
    a80c:	aa 2e       	mov	r10, r26
    a80e:	af ef       	ldi	r26, 0xFF	; 255
    a810:	ba 2e       	mov	r11, r26
    a812:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
    a816:	52 c0       	rjmp	.+164    	; 0xa8bc <calibration+0x1bc>
		   break;
			
			case (AxisPitch):
		      pitch(INF,35000,100,update,EN_CALIBRACION_PROCESOHOME);
    a818:	6f ef       	ldi	r22, 0xFF	; 255
    a81a:	7f ef       	ldi	r23, 0xFF	; 255
    a81c:	8f ef       	ldi	r24, 0xFF	; 255
    a81e:	9f e7       	ldi	r25, 0x7F	; 127
    a820:	28 eb       	ldi	r18, 0xB8	; 184
    a822:	38 e8       	ldi	r19, 0x88	; 136
    a824:	40 e0       	ldi	r20, 0x00	; 0
    a826:	50 e0       	ldi	r21, 0x00	; 0
    a828:	f4 e6       	ldi	r31, 0x64	; 100
    a82a:	ef 2e       	mov	r14, r31
    a82c:	f1 2c       	mov	r15, r1
    a82e:	01 2d       	mov	r16, r1
    a830:	11 2d       	mov	r17, r1
    a832:	e0 ef       	ldi	r30, 0xF0	; 240
    a834:	ce 2e       	mov	r12, r30
    a836:	ef ef       	ldi	r30, 0xFF	; 255
    a838:	de 2e       	mov	r13, r30
    a83a:	b3 e0       	ldi	r27, 0x03	; 3
    a83c:	ab 2e       	mov	r10, r27
    a83e:	b1 2c       	mov	r11, r1
    a840:	0e 94 78 52 	call	0xa4f0	; 0xa4f0 <pitch>
    a844:	3b c0       	rjmp	.+118    	; 0xa8bc <calibration+0x1bc>
		   break;
			
		   case (AxisRoll):
		      roll(INF,35000,100,update,EN_CALIBRACION_PROCESOHOME );
    a846:	6f ef       	ldi	r22, 0xFF	; 255
    a848:	7f ef       	ldi	r23, 0xFF	; 255
    a84a:	8f ef       	ldi	r24, 0xFF	; 255
    a84c:	9f e7       	ldi	r25, 0x7F	; 127
    a84e:	28 eb       	ldi	r18, 0xB8	; 184
    a850:	38 e8       	ldi	r19, 0x88	; 136
    a852:	40 e0       	ldi	r20, 0x00	; 0
    a854:	50 e0       	ldi	r21, 0x00	; 0
    a856:	a4 e6       	ldi	r26, 0x64	; 100
    a858:	ea 2e       	mov	r14, r26
    a85a:	f1 2c       	mov	r15, r1
    a85c:	01 2d       	mov	r16, r1
    a85e:	11 2d       	mov	r17, r1
    a860:	f0 ef       	ldi	r31, 0xF0	; 240
    a862:	cf 2e       	mov	r12, r31
    a864:	ff ef       	ldi	r31, 0xFF	; 255
    a866:	df 2e       	mov	r13, r31
    a868:	e3 e0       	ldi	r30, 0x03	; 3
    a86a:	ae 2e       	mov	r10, r30
    a86c:	b1 2c       	mov	r11, r1
    a86e:	0e 94 1b 50 	call	0xa036	; 0xa036 <roll>
    a872:	04 c0       	rjmp	.+8      	; 0xa87c <calibration+0x17c>
		   break;
			
		}
		
		
		if(Axis==AxisRoll)
    a874:	44 e0       	ldi	r20, 0x04	; 4
    a876:	44 16       	cp	r4, r20
    a878:	51 04       	cpc	r5, r1
    a87a:	01 f5       	brne	.+64     	; 0xa8bc <calibration+0x1bc>
		{
		    delay_1s();
    a87c:	0e 94 37 8d 	call	0x11a6e	; 0x11a6e <delay_1s>
			delay_1s();
    a880:	0e 94 37 8d 	call	0x11a6e	; 0x11a6e <delay_1s>
			do 
			{
				PMDGetSignalStatus(&hAxis[Axis], &signal_status);				
    a884:	c1 01       	movw	r24, r2
    a886:	be 01       	movw	r22, r28
    a888:	6f 5f       	subi	r22, 0xFF	; 255
    a88a:	7f 4f       	sbci	r23, 0xFF	; 255
    a88c:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
			} 
			while ((signal_status & PMDSignalEncoderHomeMask)!=0);
    a890:	89 81       	ldd	r24, Y+1	; 0x01
    a892:	83 fd       	sbrc	r24, 3
    a894:	f7 cf       	rjmp	.-18     	; 0xa884 <calibration+0x184>
			
			//Detener el Eje.(Ya que el Eje Roll no tiene Limites de fin de carrera.
			PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode); 
    a896:	c1 01       	movw	r24, r2
    a898:	61 e0       	ldi	r22, 0x01	; 1
    a89a:	70 e0       	ldi	r23, 0x00	; 0
    a89c:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
			PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode); 
    a8a0:	89 e3       	ldi	r24, 0x39	; 57
    a8a2:	96 e7       	ldi	r25, 0x76	; 118
    a8a4:	61 e0       	ldi	r22, 0x01	; 1
    a8a6:	70 e0       	ldi	r23, 0x00	; 0
    a8a8:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
			PMDUpdate(&hAxis[Axis]);	
    a8ac:	c1 01       	movw	r24, r2
    a8ae:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			PMDUpdate(&hAxis[AxisPitch]);	
    a8b2:	89 e3       	ldi	r24, 0x39	; 57
    a8b4:	96 e7       	ldi	r25, 0x76	; 118
    a8b6:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
    a8ba:	2d c0       	rjmp	.+90     	; 0xa916 <calibration+0x216>
		}
		else
		{
			do 
			{			
				PMDGetSignalStatus(&hAxis[Axis], &signal_status);				
    a8bc:	c1 01       	movw	r24, r2
    a8be:	be 01       	movw	r22, r28
    a8c0:	6f 5f       	subi	r22, 0xFF	; 255
    a8c2:	7f 4f       	sbci	r23, 0xFF	; 255
    a8c4:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
				printf("calibration=> El Signal status register al moverse en + del eje %s es %X \n",AxisName(Axis),signal_status);					
    a8c8:	c2 01       	movw	r24, r4
    a8ca:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    a8ce:	00 d0       	rcall	.+0      	; 0xa8d0 <calibration+0x1d0>
    a8d0:	00 d0       	rcall	.+0      	; 0xa8d2 <calibration+0x1d2>
    a8d2:	00 d0       	rcall	.+0      	; 0xa8d4 <calibration+0x1d4>
    a8d4:	ed b7       	in	r30, 0x3d	; 61
    a8d6:	fe b7       	in	r31, 0x3e	; 62
    a8d8:	31 96       	adiw	r30, 0x01	; 1
    a8da:	0f e6       	ldi	r16, 0x6F	; 111
    a8dc:	c0 2e       	mov	r12, r16
    a8de:	0c e4       	ldi	r16, 0x4C	; 76
    a8e0:	d0 2e       	mov	r13, r16
    a8e2:	ad b7       	in	r26, 0x3d	; 61
    a8e4:	be b7       	in	r27, 0x3e	; 62
    a8e6:	12 96       	adiw	r26, 0x02	; 2
    a8e8:	dc 92       	st	X, r13
    a8ea:	ce 92       	st	-X, r12
    a8ec:	11 97       	sbiw	r26, 0x01	; 1
    a8ee:	93 83       	std	Z+3, r25	; 0x03
    a8f0:	82 83       	std	Z+2, r24	; 0x02
    a8f2:	89 81       	ldd	r24, Y+1	; 0x01
    a8f4:	9a 81       	ldd	r25, Y+2	; 0x02
    a8f6:	95 83       	std	Z+5, r25	; 0x05
    a8f8:	84 83       	std	Z+4, r24	; 0x04
    a8fa:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			} 
			while ((signal_status & PMDSignalPositiveLimitMask)!=0);
    a8fe:	89 81       	ldd	r24, Y+1	; 0x01
    a900:	2d b7       	in	r18, 0x3d	; 61
    a902:	3e b7       	in	r19, 0x3e	; 62
    a904:	2a 5f       	subi	r18, 0xFA	; 250
    a906:	3f 4f       	sbci	r19, 0xFF	; 255
    a908:	0f b6       	in	r0, 0x3f	; 63
    a90a:	f8 94       	cli
    a90c:	3e bf       	out	0x3e, r19	; 62
    a90e:	0f be       	out	0x3f, r0	; 63
    a910:	2d bf       	out	0x3d, r18	; 61
    a912:	84 fd       	sbrc	r24, 4
    a914:	d3 cf       	rjmp	.-90     	; 0xa8bc <calibration+0x1bc>
		}
		
		// En este punto el Eje se Detiene automaticamente.
		
		//Leer Registro del Encoder
		PMDGetActualPosition(&hAxis[Axis],&read_encoder);
    a916:	c1 01       	movw	r24, r2
    a918:	be 01       	movw	r22, r28
    a91a:	6d 5f       	subi	r22, 0xFD	; 253
    a91c:	7f 4f       	sbci	r23, 0xFF	; 255
    a91e:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
		
		
			printf("calibration=> La Lectura del valor No %d del encoder del eje %s es : %08ld \n ",(2*i+1),AxisName(Axis),read_encoder);
    a922:	c2 01       	movw	r24, r4
    a924:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    a928:	4d b7       	in	r20, 0x3d	; 61
    a92a:	5e b7       	in	r21, 0x3e	; 62
    a92c:	4a 50       	subi	r20, 0x0A	; 10
    a92e:	50 40       	sbci	r21, 0x00	; 0
    a930:	0f b6       	in	r0, 0x3f	; 63
    a932:	f8 94       	cli
    a934:	5e bf       	out	0x3e, r21	; 62
    a936:	0f be       	out	0x3f, r0	; 63
    a938:	4d bf       	out	0x3d, r20	; 61
    a93a:	ed b7       	in	r30, 0x3d	; 61
    a93c:	fe b7       	in	r31, 0x3e	; 62
    a93e:	31 96       	adiw	r30, 0x01	; 1
    a940:	1a eb       	ldi	r17, 0xBA	; 186
    a942:	c1 2e       	mov	r12, r17
    a944:	1c e4       	ldi	r17, 0x4C	; 76
    a946:	d1 2e       	mov	r13, r17
    a948:	ad b7       	in	r26, 0x3d	; 61
    a94a:	be b7       	in	r27, 0x3e	; 62
    a94c:	12 96       	adiw	r26, 0x02	; 2
    a94e:	dc 92       	st	X, r13
    a950:	ce 92       	st	-X, r12
    a952:	11 97       	sbiw	r26, 0x01	; 1
    a954:	2b 89       	ldd	r18, Y+19	; 0x13
    a956:	3c 89       	ldd	r19, Y+20	; 0x14
    a958:	21 50       	subi	r18, 0x01	; 1
    a95a:	30 40       	sbci	r19, 0x00	; 0
    a95c:	33 83       	std	Z+3, r19	; 0x03
    a95e:	22 83       	std	Z+2, r18	; 0x02
    a960:	2f 5f       	subi	r18, 0xFF	; 255
    a962:	3f 4f       	sbci	r19, 0xFF	; 255
    a964:	3c 8b       	std	Y+20, r19	; 0x14
    a966:	2b 8b       	std	Y+19, r18	; 0x13
    a968:	95 83       	std	Z+5, r25	; 0x05
    a96a:	84 83       	std	Z+4, r24	; 0x04
    a96c:	8b 81       	ldd	r24, Y+3	; 0x03
    a96e:	9c 81       	ldd	r25, Y+4	; 0x04
    a970:	ad 81       	ldd	r26, Y+5	; 0x05
    a972:	be 81       	ldd	r27, Y+6	; 0x06
    a974:	86 83       	std	Z+6, r24	; 0x06
    a976:	97 83       	std	Z+7, r25	; 0x07
    a978:	a0 87       	std	Z+8, r26	; 0x08
    a97a:	b1 87       	std	Z+9, r27	; 0x09
    a97c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		  //  scanf("%d",&Cont);


		
		//Sacar Maximos y Minimos
		max_read = max(max_read, read_encoder);
    a980:	6b 80       	ldd	r6, Y+3	; 0x03
    a982:	7c 80       	ldd	r7, Y+4	; 0x04
    a984:	8d 80       	ldd	r8, Y+5	; 0x05
    a986:	9e 80       	ldd	r9, Y+6	; 0x06
		
		//sumar el valor leido
		sum=sum+read_encoder;
		
		//Borrar el registro del Encoder
		PMDAdjustActualPosition(&hAxis[Axis],-read_encoder);
    a988:	4d b7       	in	r20, 0x3d	; 61
    a98a:	5e b7       	in	r21, 0x3e	; 62
    a98c:	46 5f       	subi	r20, 0xF6	; 246
    a98e:	5f 4f       	sbci	r21, 0xFF	; 255
    a990:	0f b6       	in	r0, 0x3f	; 63
    a992:	f8 94       	cli
    a994:	5e bf       	out	0x3e, r21	; 62
    a996:	0f be       	out	0x3f, r0	; 63
    a998:	4d bf       	out	0x3d, r20	; 61
    a99a:	44 27       	eor	r20, r20
    a99c:	55 27       	eor	r21, r21
    a99e:	ba 01       	movw	r22, r20
    a9a0:	46 19       	sub	r20, r6
    a9a2:	57 09       	sbc	r21, r7
    a9a4:	68 09       	sbc	r22, r8
    a9a6:	79 09       	sbc	r23, r9
    a9a8:	c1 01       	movw	r24, r2
    a9aa:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>
		
		//Se limpia el Event Status Register, borrando la interrupcion 		
		PMDResetEventStatus(&hAxis[Axis],~PMDEventInPositiveLimitMask);
    a9ae:	c1 01       	movw	r24, r2
    a9b0:	6f ed       	ldi	r22, 0xDF	; 223
    a9b2:	7f ef       	ldi	r23, 0xFF	; 255
    a9b4:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
		
		//Se habilita el Generador de Trayectoria.
		PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  		
    a9b8:	c1 01       	movw	r24, r2
    a9ba:	61 e0       	ldi	r22, 0x01	; 1
    a9bc:	70 e0       	ldi	r23, 0x00	; 0
    a9be:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
		
		if(Axis==AxisPitch)
    a9c2:	53 e0       	ldi	r21, 0x03	; 3
    a9c4:	45 16       	cp	r4, r21
    a9c6:	51 04       	cpc	r5, r1
    a9c8:	61 f4       	brne	.+24     	; 0xa9e2 <calibration+0x2e2>
		{
			PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventInNegativeLimitMask);	
    a9ca:	89 e9       	ldi	r24, 0x99	; 153
    a9cc:	96 e7       	ldi	r25, 0x76	; 118
    a9ce:	6f eb       	ldi	r22, 0xBF	; 191
    a9d0:	7f ef       	ldi	r23, 0xFF	; 255
    a9d2:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 
    a9d6:	89 e9       	ldi	r24, 0x99	; 153
    a9d8:	96 e7       	ldi	r25, 0x76	; 118
    a9da:	61 e0       	ldi	r22, 0x01	; 1
    a9dc:	70 e0       	ldi	r23, 0x00	; 0
    a9de:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
		}	
		
		read_encoder=0;
    a9e2:	1b 82       	std	Y+3, r1	; 0x03
    a9e4:	1c 82       	std	Y+4, r1	; 0x04
    a9e6:	1d 82       	std	Y+5, r1	; 0x05
    a9e8:	1e 82       	std	Y+6, r1	; 0x06
	//fin de carrera
		#ifdef DEBUGROBOTICS
		printf("calibration=> Empezar Movimiento en direccion  negativa \n ");			
		#endif
		
		switch (Axis)
    a9ea:	82 e0       	ldi	r24, 0x02	; 2
    a9ec:	48 16       	cp	r4, r24
    a9ee:	51 04       	cpc	r5, r1
    a9f0:	69 f1       	breq	.+90     	; 0xaa4c <calibration+0x34c>
    a9f2:	93 e0       	ldi	r25, 0x03	; 3
    a9f4:	49 16       	cp	r4, r25
    a9f6:	51 04       	cpc	r5, r1
    a9f8:	4c f4       	brge	.+18     	; 0xaa0c <calibration+0x30c>
    a9fa:	41 14       	cp	r4, r1
    a9fc:	51 04       	cpc	r5, r1
    a9fe:	81 f0       	breq	.+32     	; 0xaa20 <calibration+0x320>
    aa00:	a1 e0       	ldi	r26, 0x01	; 1
    aa02:	4a 16       	cp	r4, r26
    aa04:	51 04       	cpc	r5, r1
    aa06:	09 f0       	breq	.+2      	; 0xaa0a <calibration+0x30a>
    aa08:	65 c0       	rjmp	.+202    	; 0xaad4 <calibration+0x3d4>
    aa0a:	15 c0       	rjmp	.+42     	; 0xaa36 <calibration+0x336>
    aa0c:	b3 e0       	ldi	r27, 0x03	; 3
    aa0e:	4b 16       	cp	r4, r27
    aa10:	51 04       	cpc	r5, r1
    aa12:	91 f1       	breq	.+100    	; 0xaa78 <calibration+0x378>
    aa14:	e4 e0       	ldi	r30, 0x04	; 4
    aa16:	4e 16       	cp	r4, r30
    aa18:	51 04       	cpc	r5, r1
    aa1a:	09 f0       	breq	.+2      	; 0xaa1e <calibration+0x31e>
    aa1c:	5b c0       	rjmp	.+182    	; 0xaad4 <calibration+0x3d4>
    aa1e:	43 c0       	rjmp	.+134    	; 0xaaa6 <calibration+0x3a6>
		{
			
			case (AxisWaist):
		      mov_axis(AxisWaist,-INF,60000,100,update);
    aa20:	80 e0       	ldi	r24, 0x00	; 0
    aa22:	90 e0       	ldi	r25, 0x00	; 0
    aa24:	41 e0       	ldi	r20, 0x01	; 1
    aa26:	50 e0       	ldi	r21, 0x00	; 0
    aa28:	60 e0       	ldi	r22, 0x00	; 0
    aa2a:	70 e8       	ldi	r23, 0x80	; 128
    aa2c:	00 e6       	ldi	r16, 0x60	; 96
    aa2e:	1a ee       	ldi	r17, 0xEA	; 234
    aa30:	20 e0       	ldi	r18, 0x00	; 0
    aa32:	30 e0       	ldi	r19, 0x00	; 0
    aa34:	15 c0       	rjmp	.+42     	; 0xaa60 <calibration+0x360>
		   break;
			
		   case (AxisShoulder):
		      mov_axis(AxisShoulder,-INF,30000,100,update);
    aa36:	81 e0       	ldi	r24, 0x01	; 1
    aa38:	90 e0       	ldi	r25, 0x00	; 0
    aa3a:	41 e0       	ldi	r20, 0x01	; 1
    aa3c:	50 e0       	ldi	r21, 0x00	; 0
    aa3e:	60 e0       	ldi	r22, 0x00	; 0
    aa40:	70 e8       	ldi	r23, 0x80	; 128
    aa42:	00 e3       	ldi	r16, 0x30	; 48
    aa44:	15 e7       	ldi	r17, 0x75	; 117
    aa46:	20 e0       	ldi	r18, 0x00	; 0
    aa48:	30 e0       	ldi	r19, 0x00	; 0
    aa4a:	0a c0       	rjmp	.+20     	; 0xaa60 <calibration+0x360>
		   break;
			
			case (AxisElbow):
		      mov_axis(AxisElbow,-INF,120000,100,update);
    aa4c:	82 e0       	ldi	r24, 0x02	; 2
    aa4e:	90 e0       	ldi	r25, 0x00	; 0
    aa50:	41 e0       	ldi	r20, 0x01	; 1
    aa52:	50 e0       	ldi	r21, 0x00	; 0
    aa54:	60 e0       	ldi	r22, 0x00	; 0
    aa56:	70 e8       	ldi	r23, 0x80	; 128
    aa58:	00 ec       	ldi	r16, 0xC0	; 192
    aa5a:	14 ed       	ldi	r17, 0xD4	; 212
    aa5c:	21 e0       	ldi	r18, 0x01	; 1
    aa5e:	30 e0       	ldi	r19, 0x00	; 0
    aa60:	b4 e6       	ldi	r27, 0x64	; 100
    aa62:	cb 2e       	mov	r12, r27
    aa64:	d1 2c       	mov	r13, r1
    aa66:	e1 2c       	mov	r14, r1
    aa68:	f1 2c       	mov	r15, r1
    aa6a:	a0 ef       	ldi	r26, 0xF0	; 240
    aa6c:	aa 2e       	mov	r10, r26
    aa6e:	af ef       	ldi	r26, 0xFF	; 255
    aa70:	ba 2e       	mov	r11, r26
    aa72:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
    aa76:	52 c0       	rjmp	.+164    	; 0xab1c <calibration+0x41c>
		   break;
			
			case (AxisPitch):
		      pitch(-INF,35000,100,update,EN_CALIBRACION_PROCESOHOME);
    aa78:	61 e0       	ldi	r22, 0x01	; 1
    aa7a:	70 e0       	ldi	r23, 0x00	; 0
    aa7c:	80 e0       	ldi	r24, 0x00	; 0
    aa7e:	90 e8       	ldi	r25, 0x80	; 128
    aa80:	28 eb       	ldi	r18, 0xB8	; 184
    aa82:	38 e8       	ldi	r19, 0x88	; 136
    aa84:	40 e0       	ldi	r20, 0x00	; 0
    aa86:	50 e0       	ldi	r21, 0x00	; 0
    aa88:	f4 e6       	ldi	r31, 0x64	; 100
    aa8a:	ef 2e       	mov	r14, r31
    aa8c:	f1 2c       	mov	r15, r1
    aa8e:	01 2d       	mov	r16, r1
    aa90:	11 2d       	mov	r17, r1
    aa92:	e0 ef       	ldi	r30, 0xF0	; 240
    aa94:	ce 2e       	mov	r12, r30
    aa96:	ef ef       	ldi	r30, 0xFF	; 255
    aa98:	de 2e       	mov	r13, r30
    aa9a:	b3 e0       	ldi	r27, 0x03	; 3
    aa9c:	ab 2e       	mov	r10, r27
    aa9e:	b1 2c       	mov	r11, r1
    aaa0:	0e 94 78 52 	call	0xa4f0	; 0xa4f0 <pitch>
    aaa4:	3b c0       	rjmp	.+118    	; 0xab1c <calibration+0x41c>
		   break;
			
		   case (AxisRoll):
		      roll(-INF,35000,100,update,EN_CALIBRACION_PROCESOHOME );
    aaa6:	61 e0       	ldi	r22, 0x01	; 1
    aaa8:	70 e0       	ldi	r23, 0x00	; 0
    aaaa:	80 e0       	ldi	r24, 0x00	; 0
    aaac:	90 e8       	ldi	r25, 0x80	; 128
    aaae:	28 eb       	ldi	r18, 0xB8	; 184
    aab0:	38 e8       	ldi	r19, 0x88	; 136
    aab2:	40 e0       	ldi	r20, 0x00	; 0
    aab4:	50 e0       	ldi	r21, 0x00	; 0
    aab6:	a4 e6       	ldi	r26, 0x64	; 100
    aab8:	ea 2e       	mov	r14, r26
    aaba:	f1 2c       	mov	r15, r1
    aabc:	01 2d       	mov	r16, r1
    aabe:	11 2d       	mov	r17, r1
    aac0:	f0 ef       	ldi	r31, 0xF0	; 240
    aac2:	cf 2e       	mov	r12, r31
    aac4:	ff ef       	ldi	r31, 0xFF	; 255
    aac6:	df 2e       	mov	r13, r31
    aac8:	e3 e0       	ldi	r30, 0x03	; 3
    aaca:	ae 2e       	mov	r10, r30
    aacc:	b1 2c       	mov	r11, r1
    aace:	0e 94 1b 50 	call	0xa036	; 0xa036 <roll>
    aad2:	04 c0       	rjmp	.+8      	; 0xaadc <calibration+0x3dc>
		   break;
		   
		}
		
		if(Axis==AxisRoll)
    aad4:	f4 e0       	ldi	r31, 0x04	; 4
    aad6:	4f 16       	cp	r4, r31
    aad8:	51 04       	cpc	r5, r1
    aada:	01 f5       	brne	.+64     	; 0xab1c <calibration+0x41c>
		{
		 //Modificado por david
		    delay_1s();
    aadc:	0e 94 37 8d 	call	0x11a6e	; 0x11a6e <delay_1s>
			delay_1s();
    aae0:	0e 94 37 8d 	call	0x11a6e	; 0x11a6e <delay_1s>
			
		 	
			do 
			{
				PMDGetSignalStatus(&hAxis[Axis], &signal_status);				
    aae4:	c1 01       	movw	r24, r2
    aae6:	be 01       	movw	r22, r28
    aae8:	6f 5f       	subi	r22, 0xFF	; 255
    aaea:	7f 4f       	sbci	r23, 0xFF	; 255
    aaec:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
			} 
			while ((signal_status & PMDSignalEncoderHomeMask)!=0);
    aaf0:	89 81       	ldd	r24, Y+1	; 0x01
    aaf2:	83 fd       	sbrc	r24, 3
    aaf4:	f7 cf       	rjmp	.-18     	; 0xaae4 <calibration+0x3e4>
			
			//Detener el Eje.(Ya que el Eje Roll no tiene Limites de fin de carrera.
			PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode); 
    aaf6:	c1 01       	movw	r24, r2
    aaf8:	61 e0       	ldi	r22, 0x01	; 1
    aafa:	70 e0       	ldi	r23, 0x00	; 0
    aafc:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
			PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode); 
    ab00:	89 e3       	ldi	r24, 0x39	; 57
    ab02:	96 e7       	ldi	r25, 0x76	; 118
    ab04:	61 e0       	ldi	r22, 0x01	; 1
    ab06:	70 e0       	ldi	r23, 0x00	; 0
    ab08:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
			PMDUpdate(&hAxis[Axis]);	
    ab0c:	c1 01       	movw	r24, r2
    ab0e:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			PMDUpdate(&hAxis[AxisPitch]);			
    ab12:	89 e3       	ldi	r24, 0x39	; 57
    ab14:	96 e7       	ldi	r25, 0x76	; 118
    ab16:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
    ab1a:	2d c0       	rjmp	.+90     	; 0xab76 <calibration+0x476>
		}
		else
		{
			do 
			{				
				PMDGetSignalStatus(&hAxis[Axis], &signal_status);					
    ab1c:	c1 01       	movw	r24, r2
    ab1e:	be 01       	movw	r22, r28
    ab20:	6f 5f       	subi	r22, 0xFF	; 255
    ab22:	7f 4f       	sbci	r23, 0xFF	; 255
    ab24:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
				printf("calibration=> El Signal status register del eje %s al moverse en - es %X \n",AxisName(Axis),signal_status);					
    ab28:	c2 01       	movw	r24, r4
    ab2a:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    ab2e:	00 d0       	rcall	.+0      	; 0xab30 <calibration+0x430>
    ab30:	00 d0       	rcall	.+0      	; 0xab32 <calibration+0x432>
    ab32:	00 d0       	rcall	.+0      	; 0xab34 <calibration+0x434>
    ab34:	ed b7       	in	r30, 0x3d	; 61
    ab36:	fe b7       	in	r31, 0x3e	; 62
    ab38:	31 96       	adiw	r30, 0x01	; 1
    ab3a:	b8 e0       	ldi	r27, 0x08	; 8
    ab3c:	cb 2e       	mov	r12, r27
    ab3e:	bd e4       	ldi	r27, 0x4D	; 77
    ab40:	db 2e       	mov	r13, r27
    ab42:	ad b7       	in	r26, 0x3d	; 61
    ab44:	be b7       	in	r27, 0x3e	; 62
    ab46:	12 96       	adiw	r26, 0x02	; 2
    ab48:	dc 92       	st	X, r13
    ab4a:	ce 92       	st	-X, r12
    ab4c:	11 97       	sbiw	r26, 0x01	; 1
    ab4e:	93 83       	std	Z+3, r25	; 0x03
    ab50:	82 83       	std	Z+2, r24	; 0x02
    ab52:	89 81       	ldd	r24, Y+1	; 0x01
    ab54:	9a 81       	ldd	r25, Y+2	; 0x02
    ab56:	95 83       	std	Z+5, r25	; 0x05
    ab58:	84 83       	std	Z+4, r24	; 0x04
    ab5a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			} 
			while ((signal_status & PMDSignalNegativeLimitMask)!=0);
    ab5e:	89 81       	ldd	r24, Y+1	; 0x01
    ab60:	2d b7       	in	r18, 0x3d	; 61
    ab62:	3e b7       	in	r19, 0x3e	; 62
    ab64:	2a 5f       	subi	r18, 0xFA	; 250
    ab66:	3f 4f       	sbci	r19, 0xFF	; 255
    ab68:	0f b6       	in	r0, 0x3f	; 63
    ab6a:	f8 94       	cli
    ab6c:	3e bf       	out	0x3e, r19	; 62
    ab6e:	0f be       	out	0x3f, r0	; 63
    ab70:	2d bf       	out	0x3d, r18	; 61
    ab72:	85 fd       	sbrc	r24, 5
    ab74:	d3 cf       	rjmp	.-90     	; 0xab1c <calibration+0x41c>
		}		
		
		// En este punto el Eje se Detiene automaticamente.
		
		//Leer Registro del Encoder
		PMDGetActualPosition(&hAxis[Axis],&read_encoder);
    ab76:	c1 01       	movw	r24, r2
    ab78:	be 01       	movw	r22, r28
    ab7a:	6d 5f       	subi	r22, 0xFD	; 253
    ab7c:	7f 4f       	sbci	r23, 0xFF	; 255
    ab7e:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
		printf("calibration=> La Lectura del valor No %d del encoder del eje %s es : %08ld \n ",(2*i+2),AxisName(Axis),read_encoder);
    ab82:	c2 01       	movw	r24, r4
    ab84:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    ab88:	4d b7       	in	r20, 0x3d	; 61
    ab8a:	5e b7       	in	r21, 0x3e	; 62
    ab8c:	4a 50       	subi	r20, 0x0A	; 10
    ab8e:	50 40       	sbci	r21, 0x00	; 0
    ab90:	0f b6       	in	r0, 0x3f	; 63
    ab92:	f8 94       	cli
    ab94:	5e bf       	out	0x3e, r21	; 62
    ab96:	0f be       	out	0x3f, r0	; 63
    ab98:	4d bf       	out	0x3d, r20	; 61
    ab9a:	ed b7       	in	r30, 0x3d	; 61
    ab9c:	fe b7       	in	r31, 0x3e	; 62
    ab9e:	31 96       	adiw	r30, 0x01	; 1
    aba0:	aa eb       	ldi	r26, 0xBA	; 186
    aba2:	ca 2e       	mov	r12, r26
    aba4:	ac e4       	ldi	r26, 0x4C	; 76
    aba6:	da 2e       	mov	r13, r26
    aba8:	ad b7       	in	r26, 0x3d	; 61
    abaa:	be b7       	in	r27, 0x3e	; 62
    abac:	12 96       	adiw	r26, 0x02	; 2
    abae:	dc 92       	st	X, r13
    abb0:	ce 92       	st	-X, r12
    abb2:	11 97       	sbiw	r26, 0x01	; 1
    abb4:	eb 88       	ldd	r14, Y+19	; 0x13
    abb6:	fc 88       	ldd	r15, Y+20	; 0x14
    abb8:	f3 82       	std	Z+3, r15	; 0x03
    abba:	e2 82       	std	Z+2, r14	; 0x02
    abbc:	95 83       	std	Z+5, r25	; 0x05
    abbe:	84 83       	std	Z+4, r24	; 0x04
    abc0:	8b 81       	ldd	r24, Y+3	; 0x03
    abc2:	9c 81       	ldd	r25, Y+4	; 0x04
    abc4:	ad 81       	ldd	r26, Y+5	; 0x05
    abc6:	be 81       	ldd	r27, Y+6	; 0x06
    abc8:	86 83       	std	Z+6, r24	; 0x06
    abca:	97 83       	std	Z+7, r25	; 0x07
    abcc:	a0 87       	std	Z+8, r26	; 0x08
    abce:	b1 87       	std	Z+9, r27	; 0x09
    abd0:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		//printf("La Lectura del valor del encoder del eje %s es : %08ld \n ",AxisName(Axis),read_encoder);
		//scanf("%d",&Cont);
		
		//Sacar Maximos y Minimos
		max_read = max(max_read, -read_encoder);
    abd4:	0b 81       	ldd	r16, Y+3	; 0x03
    abd6:	1c 81       	ldd	r17, Y+4	; 0x04
    abd8:	2d 81       	ldd	r18, Y+5	; 0x05
    abda:	3e 81       	ldd	r19, Y+6	; 0x06
    abdc:	44 27       	eor	r20, r20
    abde:	55 27       	eor	r21, r21
    abe0:	ba 01       	movw	r22, r20
    abe2:	40 1b       	sub	r20, r16
    abe4:	51 0b       	sbc	r21, r17
    abe6:	62 0b       	sbc	r22, r18
    abe8:	73 0b       	sbc	r23, r19
    abea:	db 01       	movw	r26, r22
    abec:	ca 01       	movw	r24, r20
    abee:	ed b7       	in	r30, 0x3d	; 61
    abf0:	fe b7       	in	r31, 0x3e	; 62
    abf2:	3a 96       	adiw	r30, 0x0a	; 10
    abf4:	0f b6       	in	r0, 0x3f	; 63
    abf6:	f8 94       	cli
    abf8:	fe bf       	out	0x3e, r31	; 62
    abfa:	0f be       	out	0x3f, r0	; 63
    abfc:	ed bf       	out	0x3d, r30	; 61
    abfe:	46 15       	cp	r20, r6
    ac00:	57 05       	cpc	r21, r7
    ac02:	68 05       	cpc	r22, r8
    ac04:	79 05       	cpc	r23, r9
    ac06:	14 f4       	brge	.+4      	; 0xac0c <calibration+0x50c>
    ac08:	d4 01       	movw	r26, r8
    ac0a:	c3 01       	movw	r24, r6
    ac0c:	cf 84       	ldd	r12, Y+15	; 0x0f
    ac0e:	d8 88       	ldd	r13, Y+16	; 0x10
    ac10:	e9 88       	ldd	r14, Y+17	; 0x11
    ac12:	fa 88       	ldd	r15, Y+18	; 0x12
    ac14:	c8 16       	cp	r12, r24
    ac16:	d9 06       	cpc	r13, r25
    ac18:	ea 06       	cpc	r14, r26
    ac1a:	fb 06       	cpc	r15, r27
    ac1c:	24 f4       	brge	.+8      	; 0xac26 <calibration+0x526>
    ac1e:	8f 87       	std	Y+15, r24	; 0x0f
    ac20:	98 8b       	std	Y+16, r25	; 0x10
    ac22:	a9 8b       	std	Y+17, r26	; 0x11
    ac24:	ba 8b       	std	Y+18, r27	; 0x12
    ac26:	db 01       	movw	r26, r22
    ac28:	ca 01       	movw	r24, r20
    ac2a:	64 16       	cp	r6, r20
    ac2c:	75 06       	cpc	r7, r21
    ac2e:	86 06       	cpc	r8, r22
    ac30:	97 06       	cpc	r9, r23
    ac32:	14 f4       	brge	.+4      	; 0xac38 <calibration+0x538>
    ac34:	d4 01       	movw	r26, r8
    ac36:	c3 01       	movw	r24, r6
    ac38:	cf 80       	ldd	r12, Y+7	; 0x07
    ac3a:	d8 84       	ldd	r13, Y+8	; 0x08
    ac3c:	e9 84       	ldd	r14, Y+9	; 0x09
    ac3e:	fa 84       	ldd	r15, Y+10	; 0x0a
    ac40:	8c 15       	cp	r24, r12
    ac42:	9d 05       	cpc	r25, r13
    ac44:	ae 05       	cpc	r26, r14
    ac46:	bf 05       	cpc	r27, r15
    ac48:	24 f4       	brge	.+8      	; 0xac52 <calibration+0x552>
    ac4a:	8f 83       	std	Y+7, r24	; 0x07
    ac4c:	98 87       	std	Y+8, r25	; 0x08
    ac4e:	a9 87       	std	Y+9, r26	; 0x09
    ac50:	ba 87       	std	Y+10, r27	; 0x0a
		//Sacar Maximos y Minimos
		max_read = max(max_read, read_encoder);
		min_read = min(min_read, read_encoder);
		
		//sumar el valor leido
		sum=sum+read_encoder;
    ac52:	60 1a       	sub	r6, r16
    ac54:	71 0a       	sbc	r7, r17
    ac56:	82 0a       	sbc	r8, r18
    ac58:	93 0a       	sbc	r9, r19
		//Sacar Maximos y Minimos
		max_read = max(max_read, -read_encoder);
		min_read = min(min_read, -read_encoder);
		
		//sumar el valor leido
		sum=sum-read_encoder;
    ac5a:	8b 85       	ldd	r24, Y+11	; 0x0b
    ac5c:	9c 85       	ldd	r25, Y+12	; 0x0c
    ac5e:	ad 85       	ldd	r26, Y+13	; 0x0d
    ac60:	be 85       	ldd	r27, Y+14	; 0x0e
    ac62:	86 0d       	add	r24, r6
    ac64:	97 1d       	adc	r25, r7
    ac66:	a8 1d       	adc	r26, r8
    ac68:	b9 1d       	adc	r27, r9
    ac6a:	8b 87       	std	Y+11, r24	; 0x0b
    ac6c:	9c 87       	std	Y+12, r25	; 0x0c
    ac6e:	ad 87       	std	Y+13, r26	; 0x0d
    ac70:	be 87       	std	Y+14, r27	; 0x0e
		
		//Borrar el registro del Encoder
		PMDAdjustActualPosition(&hAxis[Axis],-read_encoder);
    ac72:	c1 01       	movw	r24, r2
    ac74:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>
		
		//Se limpia el Event Status Register, borrando la interrupcion 		
		PMDResetEventStatus(&hAxis[Axis],~PMDEventInNegativeLimitMask);
    ac78:	c1 01       	movw	r24, r2
    ac7a:	6f eb       	ldi	r22, 0xBF	; 191
    ac7c:	7f ef       	ldi	r23, 0xFF	; 255
    ac7e:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
		
		//Se habilita el Generador de Trayectoria.
		PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  		
    ac82:	c1 01       	movw	r24, r2
    ac84:	61 e0       	ldi	r22, 0x01	; 1
    ac86:	70 e0       	ldi	r23, 0x00	; 0
    ac88:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
		
		if(Axis==AxisPitch)
    ac8c:	93 e0       	ldi	r25, 0x03	; 3
    ac8e:	49 16       	cp	r4, r25
    ac90:	51 04       	cpc	r5, r1
    ac92:	61 f4       	brne	.+24     	; 0xacac <calibration+0x5ac>
		{
			PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventInPositiveLimitMask);	
    ac94:	89 e9       	ldi	r24, 0x99	; 153
    ac96:	96 e7       	ldi	r25, 0x76	; 118
    ac98:	6f ed       	ldi	r22, 0xDF	; 223
    ac9a:	7f ef       	ldi	r23, 0xFF	; 255
    ac9c:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 
    aca0:	89 e9       	ldi	r24, 0x99	; 153
    aca2:	96 e7       	ldi	r25, 0x76	; 118
    aca4:	61 e0       	ldi	r22, 0x01	; 1
    aca6:	70 e0       	ldi	r23, 0x00	; 0
    aca8:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
		}
		read_encoder=0;
    acac:	1b 82       	std	Y+3, r1	; 0x03
    acae:	1c 82       	std	Y+4, r1	; 0x04
    acb0:	1d 82       	std	Y+5, r1	; 0x05
    acb2:	1e 82       	std	Y+6, r1	; 0x06
    acb4:	ab 89       	ldd	r26, Y+19	; 0x13
    acb6:	bc 89       	ldd	r27, Y+20	; 0x14
    acb8:	12 96       	adiw	r26, 0x02	; 2
    acba:	bc 8b       	std	Y+20, r27	; 0x14
    acbc:	ab 8b       	std	Y+19, r26	; 0x13
	sum=0;
	max_read= -INF;
	min_read=  INF;

	
	for (i=0; i<5; i++)
    acbe:	1c 97       	sbiw	r26, 0x0c	; 12
    acc0:	09 f0       	breq	.+2      	; 0xacc4 <calibration+0x5c4>
    acc2:	63 cd       	rjmp	.-1338   	; 0xa78a <calibration+0x8a>
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 
		}
		read_encoder=0;
	}
	
	printf("calibration=> Los Valores maximo y minimo son= %08ld y %08ld  \n ",max_read,min_read);
    acc4:	ed b7       	in	r30, 0x3d	; 61
    acc6:	fe b7       	in	r31, 0x3e	; 62
    acc8:	3a 97       	sbiw	r30, 0x0a	; 10
    acca:	0f b6       	in	r0, 0x3f	; 63
    accc:	f8 94       	cli
    acce:	fe bf       	out	0x3e, r31	; 62
    acd0:	0f be       	out	0x3f, r0	; 63
    acd2:	ed bf       	out	0x3d, r30	; 61
    acd4:	31 96       	adiw	r30, 0x01	; 1
    acd6:	83 e5       	ldi	r24, 0x53	; 83
    acd8:	9d e4       	ldi	r25, 0x4D	; 77
    acda:	ad b7       	in	r26, 0x3d	; 61
    acdc:	be b7       	in	r27, 0x3e	; 62
    acde:	12 96       	adiw	r26, 0x02	; 2
    ace0:	9c 93       	st	X, r25
    ace2:	8e 93       	st	-X, r24
    ace4:	11 97       	sbiw	r26, 0x01	; 1
    ace6:	cf 84       	ldd	r12, Y+15	; 0x0f
    ace8:	d8 88       	ldd	r13, Y+16	; 0x10
    acea:	e9 88       	ldd	r14, Y+17	; 0x11
    acec:	fa 88       	ldd	r15, Y+18	; 0x12
    acee:	c2 82       	std	Z+2, r12	; 0x02
    acf0:	d3 82       	std	Z+3, r13	; 0x03
    acf2:	e4 82       	std	Z+4, r14	; 0x04
    acf4:	f5 82       	std	Z+5, r15	; 0x05
    acf6:	2f 81       	ldd	r18, Y+7	; 0x07
    acf8:	38 85       	ldd	r19, Y+8	; 0x08
    acfa:	49 85       	ldd	r20, Y+9	; 0x09
    acfc:	5a 85       	ldd	r21, Y+10	; 0x0a
    acfe:	26 83       	std	Z+6, r18	; 0x06
    ad00:	37 83       	std	Z+7, r19	; 0x07
    ad02:	40 87       	std	Z+8, r20	; 0x08
    ad04:	51 87       	std	Z+9, r21	; 0x09
    ad06:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("calibration=> La sumatoria de los valores leidos es : %08ld \n",sum);
    ad0a:	0f 90       	pop	r0
    ad0c:	0f 90       	pop	r0
    ad0e:	0f 90       	pop	r0
    ad10:	0f 90       	pop	r0
    ad12:	84 e9       	ldi	r24, 0x94	; 148
    ad14:	9d e4       	ldi	r25, 0x4D	; 77
    ad16:	ad b7       	in	r26, 0x3d	; 61
    ad18:	be b7       	in	r27, 0x3e	; 62
    ad1a:	12 96       	adiw	r26, 0x02	; 2
    ad1c:	9c 93       	st	X, r25
    ad1e:	8e 93       	st	-X, r24
    ad20:	11 97       	sbiw	r26, 0x01	; 1
    ad22:	cb 84       	ldd	r12, Y+11	; 0x0b
    ad24:	dc 84       	ldd	r13, Y+12	; 0x0c
    ad26:	ed 84       	ldd	r14, Y+13	; 0x0d
    ad28:	fe 84       	ldd	r15, Y+14	; 0x0e
    ad2a:	13 96       	adiw	r26, 0x03	; 3
    ad2c:	cd 92       	st	X+, r12
    ad2e:	dd 92       	st	X+, r13
    ad30:	ed 92       	st	X+, r14
    ad32:	fc 92       	st	X, r15
    ad34:	16 97       	sbiw	r26, 0x06	; 6
    ad36:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    ad3a:	2f 81       	ldd	r18, Y+7	; 0x07
    ad3c:	38 85       	ldd	r19, Y+8	; 0x08
    ad3e:	49 85       	ldd	r20, Y+9	; 0x09
    ad40:	5a 85       	ldd	r21, Y+10	; 0x0a
    ad42:	c2 1a       	sub	r12, r18
    ad44:	d3 0a       	sbc	r13, r19
    ad46:	e4 0a       	sbc	r14, r20
    ad48:	f5 0a       	sbc	r15, r21
    ad4a:	8f 85       	ldd	r24, Y+15	; 0x0f
    ad4c:	98 89       	ldd	r25, Y+16	; 0x10
    ad4e:	a9 89       	ldd	r26, Y+17	; 0x11
    ad50:	ba 89       	ldd	r27, Y+18	; 0x12
    ad52:	c8 1a       	sub	r12, r24
    ad54:	d9 0a       	sbc	r13, r25
    ad56:	ea 0a       	sbc	r14, r26
    ad58:	fb 0a       	sbc	r15, r27
    ad5a:	c7 01       	movw	r24, r14
    ad5c:	b6 01       	movw	r22, r12
    ad5e:	28 e0       	ldi	r18, 0x08	; 8
    ad60:	30 e0       	ldi	r19, 0x00	; 0
    ad62:	40 e0       	ldi	r20, 0x00	; 0
    ad64:	50 e0       	ldi	r21, 0x00	; 0
    ad66:	0e 94 7a 9c 	call	0x138f4	; 0x138f4 <__divmodsi4>
    ad6a:	ca 01       	movw	r24, r20
    ad6c:	ad b7       	in	r26, 0x3d	; 61
    ad6e:	be b7       	in	r27, 0x3e	; 62
    ad70:	16 96       	adiw	r26, 0x06	; 6
    ad72:	0f b6       	in	r0, 0x3f	; 63
    ad74:	f8 94       	cli
    ad76:	be bf       	out	0x3e, r27	; 62
    ad78:	0f be       	out	0x3f, r0	; 63
    ad7a:	ad bf       	out	0x3d, r26	; 61
	read = (sum-(max_read + min_read))/(2*(i-1));
	
	return read;
}
    ad7c:	b9 01       	movw	r22, r18
    ad7e:	64 96       	adiw	r28, 0x14	; 20
    ad80:	0f b6       	in	r0, 0x3f	; 63
    ad82:	f8 94       	cli
    ad84:	de bf       	out	0x3e, r29	; 62
    ad86:	0f be       	out	0x3f, r0	; 63
    ad88:	cd bf       	out	0x3d, r28	; 61
    ad8a:	cf 91       	pop	r28
    ad8c:	df 91       	pop	r29
    ad8e:	1f 91       	pop	r17
    ad90:	0f 91       	pop	r16
    ad92:	ff 90       	pop	r15
    ad94:	ef 90       	pop	r14
    ad96:	df 90       	pop	r13
    ad98:	cf 90       	pop	r12
    ad9a:	bf 90       	pop	r11
    ad9c:	af 90       	pop	r10
    ad9e:	9f 90       	pop	r9
    ada0:	8f 90       	pop	r8
    ada2:	7f 90       	pop	r7
    ada4:	6f 90       	pop	r6
    ada6:	5f 90       	pop	r5
    ada8:	4f 90       	pop	r4
    adaa:	3f 90       	pop	r3
    adac:	2f 90       	pop	r2
    adae:	08 95       	ret

0000adb0 <mov_correlacionado_HOME>:
//Al mover el EJe1 se tiene que mover proporcionalmente el Eje2
void mov_correlacionado_HOME(tAxis Eje2, PMDint32 Posicion,
										 PMDint32 Velocity_Eje1, PMDint32 *Velocity_Eje2,
						                 PMDuint32 Acceleration_Eje1, PMDuint32 *Acceleration_Eje2, 
										 double FACTOR_CORRELACION)
{
    adb0:	4f 92       	push	r4
    adb2:	5f 92       	push	r5
    adb4:	6f 92       	push	r6
    adb6:	7f 92       	push	r7
    adb8:	8f 92       	push	r8
    adba:	9f 92       	push	r9
    adbc:	af 92       	push	r10
    adbe:	bf 92       	push	r11
    adc0:	cf 92       	push	r12
    adc2:	df 92       	push	r13
    adc4:	ef 92       	push	r14
    adc6:	ff 92       	push	r15
    adc8:	0f 93       	push	r16
    adca:	1f 93       	push	r17
    adcc:	df 93       	push	r29
    adce:	cf 93       	push	r28
    add0:	00 d0       	rcall	.+0      	; 0xadd2 <mov_correlacionado_HOME+0x22>
    add2:	00 d0       	rcall	.+0      	; 0xadd4 <mov_correlacionado_HOME+0x24>
    add4:	cd b7       	in	r28, 0x3d	; 61
    add6:	de b7       	in	r29, 0x3e	; 62
    add8:	2c 01       	movw	r4, r24
    adda:	49 83       	std	Y+1, r20	; 0x01
    addc:	5a 83       	std	Y+2, r21	; 0x02
    adde:	6b 83       	std	Y+3, r22	; 0x03
    ade0:	7c 83       	std	Y+4, r23	; 0x04
    ade2:	c9 01       	movw	r24, r18
    ade4:	b8 01       	movw	r22, r16
    ade6:	37 01       	movw	r6, r14
    ade8:	ef 88       	ldd	r14, Y+23	; 0x17
    adea:	f8 8c       	ldd	r15, Y+24	; 0x18
    adec:	09 8d       	ldd	r16, Y+25	; 0x19
    adee:	1a 8d       	ldd	r17, Y+26	; 0x1a

	
	
	/*La Velocidad del Eje2 es igual a la del Registro del Eje2 + la velocidad del Eje1 X factor de correlacion*/
	*Velocity_Eje2 = (Velocity_Eje1*FACTOR_CORRELACION);
    adf0:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    adf4:	a8 01       	movw	r20, r16
    adf6:	97 01       	movw	r18, r14
    adf8:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    adfc:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    ae00:	d3 01       	movw	r26, r6
    ae02:	6d 93       	st	X+, r22
    ae04:	7d 93       	st	X+, r23
    ae06:	8d 93       	st	X+, r24
    ae08:	9c 93       	st	X, r25
    ae0a:	13 97       	sbiw	r26, 0x03	; 3
	/*La Aceleracion del Eje2 es igual a la del Registro  del Eje 2 + la aceleracion del Eje1 X factor de correlacion*/
	*Acceleration_Eje2 =  (Acceleration_Eje1*FACTOR_CORRELACION);
    ae0c:	c6 01       	movw	r24, r12
    ae0e:	b5 01       	movw	r22, r10
    ae10:	0e 94 d0 9a 	call	0x135a0	; 0x135a0 <__floatunsisf>
    ae14:	a8 01       	movw	r20, r16
    ae16:	97 01       	movw	r18, r14
    ae18:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    ae1c:	0e 94 a4 9a 	call	0x13548	; 0x13548 <__fixunssfsi>
    ae20:	f4 01       	movw	r30, r8
    ae22:	60 83       	st	Z, r22
    ae24:	71 83       	std	Z+1, r23	; 0x01
    ae26:	82 83       	std	Z+2, r24	; 0x02
    ae28:	93 83       	std	Z+3, r25	; 0x03
	
	/*Imprimo para debug*/ 	 
	printf("mov_correlacionado_HOME=> Velocidad Eje %s = %ld\n",AxisName(Eje2),*Velocity_Eje2);	
    ae2a:	c2 01       	movw	r24, r4
    ae2c:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    ae30:	2d b7       	in	r18, 0x3d	; 61
    ae32:	3e b7       	in	r19, 0x3e	; 62
    ae34:	28 50       	subi	r18, 0x08	; 8
    ae36:	30 40       	sbci	r19, 0x00	; 0
    ae38:	0f b6       	in	r0, 0x3f	; 63
    ae3a:	f8 94       	cli
    ae3c:	3e bf       	out	0x3e, r19	; 62
    ae3e:	0f be       	out	0x3f, r0	; 63
    ae40:	2d bf       	out	0x3d, r18	; 61
    ae42:	ed b7       	in	r30, 0x3d	; 61
    ae44:	fe b7       	in	r31, 0x3e	; 62
    ae46:	31 96       	adiw	r30, 0x01	; 1
    ae48:	22 ed       	ldi	r18, 0xD2	; 210
    ae4a:	3d e4       	ldi	r19, 0x4D	; 77
    ae4c:	ad b7       	in	r26, 0x3d	; 61
    ae4e:	be b7       	in	r27, 0x3e	; 62
    ae50:	12 96       	adiw	r26, 0x02	; 2
    ae52:	3c 93       	st	X, r19
    ae54:	2e 93       	st	-X, r18
    ae56:	11 97       	sbiw	r26, 0x01	; 1
    ae58:	93 83       	std	Z+3, r25	; 0x03
    ae5a:	82 83       	std	Z+2, r24	; 0x02
    ae5c:	d3 01       	movw	r26, r6
    ae5e:	2d 91       	ld	r18, X+
    ae60:	3d 91       	ld	r19, X+
    ae62:	4d 91       	ld	r20, X+
    ae64:	5c 91       	ld	r21, X
    ae66:	24 83       	std	Z+4, r18	; 0x04
    ae68:	35 83       	std	Z+5, r19	; 0x05
    ae6a:	46 83       	std	Z+6, r20	; 0x06
    ae6c:	57 83       	std	Z+7, r21	; 0x07
    ae6e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("mov_correlacionado_HOME=> Aceleracion Eje %s = %ld\n",AxisName(Eje2),*Acceleration_Eje2);	
    ae72:	ed b7       	in	r30, 0x3d	; 61
    ae74:	fe b7       	in	r31, 0x3e	; 62
    ae76:	38 96       	adiw	r30, 0x08	; 8
    ae78:	0f b6       	in	r0, 0x3f	; 63
    ae7a:	f8 94       	cli
    ae7c:	fe bf       	out	0x3e, r31	; 62
    ae7e:	0f be       	out	0x3f, r0	; 63
    ae80:	ed bf       	out	0x3d, r30	; 61
    ae82:	c2 01       	movw	r24, r4
    ae84:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    ae88:	2d b7       	in	r18, 0x3d	; 61
    ae8a:	3e b7       	in	r19, 0x3e	; 62
    ae8c:	28 50       	subi	r18, 0x08	; 8
    ae8e:	30 40       	sbci	r19, 0x00	; 0
    ae90:	0f b6       	in	r0, 0x3f	; 63
    ae92:	f8 94       	cli
    ae94:	3e bf       	out	0x3e, r19	; 62
    ae96:	0f be       	out	0x3f, r0	; 63
    ae98:	2d bf       	out	0x3d, r18	; 61
    ae9a:	ed b7       	in	r30, 0x3d	; 61
    ae9c:	fe b7       	in	r31, 0x3e	; 62
    ae9e:	31 96       	adiw	r30, 0x01	; 1
    aea0:	24 e0       	ldi	r18, 0x04	; 4
    aea2:	3e e4       	ldi	r19, 0x4E	; 78
    aea4:	ad b7       	in	r26, 0x3d	; 61
    aea6:	be b7       	in	r27, 0x3e	; 62
    aea8:	12 96       	adiw	r26, 0x02	; 2
    aeaa:	3c 93       	st	X, r19
    aeac:	2e 93       	st	-X, r18
    aeae:	11 97       	sbiw	r26, 0x01	; 1
    aeb0:	93 83       	std	Z+3, r25	; 0x03
    aeb2:	82 83       	std	Z+2, r24	; 0x02
    aeb4:	d4 01       	movw	r26, r8
    aeb6:	2d 91       	ld	r18, X+
    aeb8:	3d 91       	ld	r19, X+
    aeba:	4d 91       	ld	r20, X+
    aebc:	5c 91       	ld	r21, X
    aebe:	24 83       	std	Z+4, r18	; 0x04
    aec0:	35 83       	std	Z+5, r19	; 0x05
    aec2:	46 83       	std	Z+6, r20	; 0x06
    aec4:	57 83       	std	Z+7, r21	; 0x07
    aec6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	
	
	/*Muevo el Eje2 con esos datos */
	if (Eje2==AxisPitch)
    aeca:	ed b7       	in	r30, 0x3d	; 61
    aecc:	fe b7       	in	r31, 0x3e	; 62
    aece:	38 96       	adiw	r30, 0x08	; 8
    aed0:	0f b6       	in	r0, 0x3f	; 63
    aed2:	f8 94       	cli
    aed4:	fe bf       	out	0x3e, r31	; 62
    aed6:	0f be       	out	0x3f, r0	; 63
    aed8:	ed bf       	out	0x3d, r30	; 61
    aeda:	d3 01       	movw	r26, r6
    aedc:	0d 91       	ld	r16, X+
    aede:	1d 91       	ld	r17, X+
    aee0:	2d 91       	ld	r18, X+
    aee2:	3c 91       	ld	r19, X
    aee4:	f4 01       	movw	r30, r8
    aee6:	c0 80       	ld	r12, Z
    aee8:	d1 80       	ldd	r13, Z+1	; 0x01
    aeea:	e2 80       	ldd	r14, Z+2	; 0x02
    aeec:	f3 80       	ldd	r15, Z+3	; 0x03
    aeee:	f3 e0       	ldi	r31, 0x03	; 3
    aef0:	4f 16       	cp	r4, r31
    aef2:	51 04       	cpc	r5, r1
    aef4:	91 f4       	brne	.+36     	; 0xaf1a <mov_correlacionado_HOME+0x16a>
	{		
		pitch(Posicion,*Velocity_Eje2,*Acceleration_Eje2,no_update,EN_CALIBRACION_PROCESOHOME);
    aef6:	69 81       	ldd	r22, Y+1	; 0x01
    aef8:	7a 81       	ldd	r23, Y+2	; 0x02
    aefa:	8b 81       	ldd	r24, Y+3	; 0x03
    aefc:	9c 81       	ldd	r25, Y+4	; 0x04
    aefe:	a9 01       	movw	r20, r18
    af00:	98 01       	movw	r18, r16
    af02:	87 01       	movw	r16, r14
    af04:	76 01       	movw	r14, r12
    af06:	af ee       	ldi	r26, 0xEF	; 239
    af08:	ca 2e       	mov	r12, r26
    af0a:	af ef       	ldi	r26, 0xFF	; 255
    af0c:	da 2e       	mov	r13, r26
    af0e:	f3 e0       	ldi	r31, 0x03	; 3
    af10:	af 2e       	mov	r10, r31
    af12:	b1 2c       	mov	r11, r1
    af14:	0e 94 78 52 	call	0xa4f0	; 0xa4f0 <pitch>
    af18:	0b c0       	rjmp	.+22     	; 0xaf30 <mov_correlacionado_HOME+0x180>
	}
	else
	{
		mov_axis(Eje2,Posicion,*Velocity_Eje2,*Acceleration_Eje2,no_update);	
    af1a:	c2 01       	movw	r24, r4
    af1c:	49 81       	ldd	r20, Y+1	; 0x01
    af1e:	5a 81       	ldd	r21, Y+2	; 0x02
    af20:	6b 81       	ldd	r22, Y+3	; 0x03
    af22:	7c 81       	ldd	r23, Y+4	; 0x04
    af24:	ef ee       	ldi	r30, 0xEF	; 239
    af26:	ae 2e       	mov	r10, r30
    af28:	ef ef       	ldi	r30, 0xFF	; 255
    af2a:	be 2e       	mov	r11, r30
    af2c:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
	}			
		
}
    af30:	0f 90       	pop	r0
    af32:	0f 90       	pop	r0
    af34:	0f 90       	pop	r0
    af36:	0f 90       	pop	r0
    af38:	cf 91       	pop	r28
    af3a:	df 91       	pop	r29
    af3c:	1f 91       	pop	r17
    af3e:	0f 91       	pop	r16
    af40:	ff 90       	pop	r15
    af42:	ef 90       	pop	r14
    af44:	df 90       	pop	r13
    af46:	cf 90       	pop	r12
    af48:	bf 90       	pop	r11
    af4a:	af 90       	pop	r10
    af4c:	9f 90       	pop	r9
    af4e:	8f 90       	pop	r8
    af50:	7f 90       	pop	r7
    af52:	6f 90       	pop	r6
    af54:	5f 90       	pop	r5
    af56:	4f 90       	pop	r4
    af58:	08 95       	ret

0000af5a <search_home_positive>:
	
	

}
void search_home_positive(int16 Axis,PMDint32 *home,PMDint32 *posicion,PMDint16 rangos)
{
    af5a:	2f 92       	push	r2
    af5c:	3f 92       	push	r3
    af5e:	4f 92       	push	r4
    af60:	5f 92       	push	r5
    af62:	6f 92       	push	r6
    af64:	7f 92       	push	r7
    af66:	8f 92       	push	r8
    af68:	9f 92       	push	r9
    af6a:	af 92       	push	r10
    af6c:	bf 92       	push	r11
    af6e:	cf 92       	push	r12
    af70:	df 92       	push	r13
    af72:	ef 92       	push	r14
    af74:	ff 92       	push	r15
    af76:	0f 93       	push	r16
    af78:	1f 93       	push	r17
    af7a:	df 93       	push	r29
    af7c:	cf 93       	push	r28
    af7e:	cd b7       	in	r28, 0x3d	; 61
    af80:	de b7       	in	r29, 0x3e	; 62
    af82:	6c 97       	sbiw	r28, 0x1c	; 28
    af84:	0f b6       	in	r0, 0x3f	; 63
    af86:	f8 94       	cli
    af88:	de bf       	out	0x3e, r29	; 62
    af8a:	0f be       	out	0x3f, r0	; 63
    af8c:	cd bf       	out	0x3d, r28	; 61
    af8e:	3c 01       	movw	r6, r24
    af90:	7a 8f       	std	Y+26, r23	; 0x1a
    af92:	69 8f       	std	Y+25, r22	; 0x19
    af94:	5c 8f       	std	Y+28, r21	; 0x1c
    af96:	4b 8f       	std	Y+27, r20	; 0x1b
    af98:	19 01       	movw	r2, r18
	find_home_out=1;
	
	

	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    af9a:	80 e6       	ldi	r24, 0x60	; 96
    af9c:	90 e0       	ldi	r25, 0x00	; 0
    af9e:	68 9e       	mul	r6, r24
    afa0:	20 01       	movw	r4, r0
    afa2:	69 9e       	mul	r6, r25
    afa4:	50 0c       	add	r5, r0
    afa6:	78 9e       	mul	r7, r24
    afa8:	50 0c       	add	r5, r0
    afaa:	11 24       	eor	r1, r1
    afac:	89 e1       	ldi	r24, 0x19	; 25
    afae:	95 e7       	ldi	r25, 0x75	; 117
    afb0:	48 0e       	add	r4, r24
    afb2:	59 1e       	adc	r5, r25
    afb4:	f3 e0       	ldi	r31, 0x03	; 3
    afb6:	8f 2e       	mov	r8, r31
    afb8:	91 2c       	mov	r9, r1
    afba:	8c 0e       	add	r8, r28
    afbc:	9d 1e       	adc	r9, r29
    afbe:	c2 01       	movw	r24, r4
    afc0:	b4 01       	movw	r22, r8
    afc2:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
	printf("search_home_positive=> HostIOError = %x para el eje %s\n ",test,AxisName(Axis));
    afc6:	0b 81       	ldd	r16, Y+3	; 0x03
    afc8:	1c 81       	ldd	r17, Y+4	; 0x04
    afca:	c3 01       	movw	r24, r6
    afcc:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    afd0:	00 d0       	rcall	.+0      	; 0xafd2 <search_home_positive+0x78>
    afd2:	00 d0       	rcall	.+0      	; 0xafd4 <search_home_positive+0x7a>
    afd4:	00 d0       	rcall	.+0      	; 0xafd6 <search_home_positive+0x7c>
    afd6:	ed b7       	in	r30, 0x3d	; 61
    afd8:	fe b7       	in	r31, 0x3e	; 62
    afda:	31 96       	adiw	r30, 0x01	; 1
    afdc:	28 e3       	ldi	r18, 0x38	; 56
    afde:	3e e4       	ldi	r19, 0x4E	; 78
    afe0:	ad b7       	in	r26, 0x3d	; 61
    afe2:	be b7       	in	r27, 0x3e	; 62
    afe4:	12 96       	adiw	r26, 0x02	; 2
    afe6:	3c 93       	st	X, r19
    afe8:	2e 93       	st	-X, r18
    afea:	11 97       	sbiw	r26, 0x01	; 1
    afec:	13 83       	std	Z+3, r17	; 0x03
    afee:	02 83       	std	Z+2, r16	; 0x02
    aff0:	95 83       	std	Z+5, r25	; 0x05
    aff2:	84 83       	std	Z+4, r24	; 0x04
    aff4:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	// hay que mover el motor en la direccion contraria
	//Por ejemplo, situacion de error 
	//En search_home_positive estoy moviendo el hombro
	//Por casualidad el codo o pitch esta tocando el interuptor positivo
	//por lo tanto antes de mover nada hay que desactivarlos.
	No_limit_switch(Axis);
    aff8:	ed b7       	in	r30, 0x3d	; 61
    affa:	fe b7       	in	r31, 0x3e	; 62
    affc:	36 96       	adiw	r30, 0x06	; 6
    affe:	0f b6       	in	r0, 0x3f	; 63
    b000:	f8 94       	cli
    b002:	fe bf       	out	0x3e, r31	; 62
    b004:	0f be       	out	0x3f, r0	; 63
    b006:	ed bf       	out	0x3d, r30	; 61
    b008:	c3 01       	movw	r24, r6
    b00a:	0e 94 db 4a 	call	0x95b6	; 0x95b6 <No_limit_switch>
	

	PMDGetHostIOError(&hAxis[Axis], &test);
    b00e:	c2 01       	movw	r24, r4
    b010:	b4 01       	movw	r22, r8
    b012:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
	//Limpia el BiT de Position Capture Indicator en el Status Register
	PMDResetEventStatus(&hAxis[Axis],~PMDEventCaptureReceivedMask);	
    b016:	c2 01       	movw	r24, r4
    b018:	67 ef       	ldi	r22, 0xF7	; 247
    b01a:	7f ef       	ldi	r23, 0xFF	; 255
    b01c:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
	//La senal de HOME sera utilizada como Disparo para la Captura de la Posicion
	PMDSetCaptureSource(&hAxis[Axis],PMDCaptureSourceHome);
    b020:	c2 01       	movw	r24, r4
    b022:	61 e0       	ldi	r22, 0x01	; 1
    b024:	70 e0       	ldi	r23, 0x00	; 0
    b026:	0e 94 63 7a 	call	0xf4c6	; 0xf4c6 <PMDSetCaptureSource>
	//Leyendo el registro de Captura de Posicion Causa "rearmar" 
	//el disparador con el fin de permitir mas capturas.
	PMDGetCaptureValue(&hAxis[Axis],&temp); 
    b02a:	c2 01       	movw	r24, r4
    b02c:	be 01       	movw	r22, r28
    b02e:	6b 5f       	subi	r22, 0xFB	; 251
    b030:	7f 4f       	sbci	r23, 0xFF	; 255
    b032:	0e 94 24 7b 	call	0xf648	; 0xf648 <PMDGetCaptureValue>
	

	#ifdef DEBUGROBOTICS_HOME
	printf("search_home_positive=> Ejecutado No_limit_switch\n");
    b036:	81 e7       	ldi	r24, 0x71	; 113
    b038:	9e e4       	ldi	r25, 0x4E	; 78
    b03a:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	printf("search_home_positive=> Busqueda home en dir Posi. del eje %s.\n ",AxisName(Axis));
    b03e:	c3 01       	movw	r24, r6
    b040:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    b044:	00 d0       	rcall	.+0      	; 0xb046 <search_home_positive+0xec>
    b046:	00 d0       	rcall	.+0      	; 0xb048 <search_home_positive+0xee>
    b048:	22 ea       	ldi	r18, 0xA2	; 162
    b04a:	3e e4       	ldi	r19, 0x4E	; 78
    b04c:	ad b7       	in	r26, 0x3d	; 61
    b04e:	be b7       	in	r27, 0x3e	; 62
    b050:	12 96       	adiw	r26, 0x02	; 2
    b052:	3c 93       	st	X, r19
    b054:	2e 93       	st	-X, r18
    b056:	11 97       	sbiw	r26, 0x01	; 1
    b058:	14 96       	adiw	r26, 0x04	; 4
    b05a:	9c 93       	st	X, r25
    b05c:	8e 93       	st	-X, r24
    b05e:	13 97       	sbiw	r26, 0x03	; 3
    b060:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	#endif

	switch (Axis)
    b064:	0f 90       	pop	r0
    b066:	0f 90       	pop	r0
    b068:	0f 90       	pop	r0
    b06a:	0f 90       	pop	r0
    b06c:	b2 e0       	ldi	r27, 0x02	; 2
    b06e:	6b 16       	cp	r6, r27
    b070:	71 04       	cpc	r7, r1
    b072:	09 f4       	brne	.+2      	; 0xb076 <search_home_positive+0x11c>
    b074:	bd c0       	rjmp	.+378    	; 0xb1f0 <search_home_positive+0x296>
    b076:	e3 e0       	ldi	r30, 0x03	; 3
    b078:	6e 16       	cp	r6, r30
    b07a:	71 04       	cpc	r7, r1
    b07c:	34 f4       	brge	.+12     	; 0xb08a <search_home_positive+0x130>
    b07e:	f1 e0       	ldi	r31, 0x01	; 1
    b080:	6f 16       	cp	r6, r31
    b082:	71 04       	cpc	r7, r1
    b084:	09 f0       	breq	.+2      	; 0xb088 <search_home_positive+0x12e>
    b086:	9f c1       	rjmp	.+830    	; 0xb3c6 <search_home_positive+0x46c>
    b088:	0b c0       	rjmp	.+22     	; 0xb0a0 <search_home_positive+0x146>
    b08a:	83 e0       	ldi	r24, 0x03	; 3
    b08c:	68 16       	cp	r6, r24
    b08e:	71 04       	cpc	r7, r1
    b090:	09 f4       	brne	.+2      	; 0xb094 <search_home_positive+0x13a>
    b092:	2b c1       	rjmp	.+598    	; 0xb2ea <search_home_positive+0x390>
    b094:	94 e0       	ldi	r25, 0x04	; 4
    b096:	69 16       	cp	r6, r25
    b098:	71 04       	cpc	r7, r1
    b09a:	09 f0       	breq	.+2      	; 0xb09e <search_home_positive+0x144>
    b09c:	94 c1       	rjmp	.+808    	; 0xb3c6 <search_home_positive+0x46c>
    b09e:	5a c1       	rjmp	.+692    	; 0xb354 <search_home_positive+0x3fa>
	{
		case (AxisShoulder):
		{
			//No codo depende de nadie va directo...  
			//(Siempre entra aqui cuando se usa con una trayectoria )..
			mov_axis(Axis,INF, 
    b0a0:	00 91 b9 75 	lds	r16, 0x75B9
    b0a4:	10 91 ba 75 	lds	r17, 0x75BA
    b0a8:	20 91 bb 75 	lds	r18, 0x75BB
    b0ac:	30 91 bc 75 	lds	r19, 0x75BC
    b0b0:	c0 90 bd 75 	lds	r12, 0x75BD
    b0b4:	d0 90 be 75 	lds	r13, 0x75BE
    b0b8:	e0 90 bf 75 	lds	r14, 0x75BF
    b0bc:	f0 90 c0 75 	lds	r15, 0x75C0
    b0c0:	81 e0       	ldi	r24, 0x01	; 1
    b0c2:	90 e0       	ldi	r25, 0x00	; 0
    b0c4:	4f ef       	ldi	r20, 0xFF	; 255
    b0c6:	5f ef       	ldi	r21, 0xFF	; 255
    b0c8:	6f ef       	ldi	r22, 0xFF	; 255
    b0ca:	7f e7       	ldi	r23, 0x7F	; 127
    b0cc:	ef ee       	ldi	r30, 0xEF	; 239
    b0ce:	ae 2e       	mov	r10, r30
    b0d0:	ef ef       	ldi	r30, 0xFF	; 255
    b0d2:	be 2e       	mov	r11, r30
    b0d4:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
			hAxis[Axis].axisSettings.homeVelocity*CORRELACION_HOMBRO_CODO*CORRELACION_CODO_PITCH,
			100,
			no_update,EN_CALIBRACION_PROCESOHOME );*/
			//Configurando los registros de codo, codo esta invertido invertido.
			
			mov_correlacionado_HOME(AxisElbow,INF,
    b0d8:	00 d0       	rcall	.+0      	; 0xb0da <search_home_positive+0x180>
    b0da:	00 d0       	rcall	.+0      	; 0xb0dc <search_home_positive+0x182>
    b0dc:	00 91 b9 75 	lds	r16, 0x75B9
    b0e0:	10 91 ba 75 	lds	r17, 0x75BA
    b0e4:	20 91 bb 75 	lds	r18, 0x75BB
    b0e8:	30 91 bc 75 	lds	r19, 0x75BC
    b0ec:	a0 90 bd 75 	lds	r10, 0x75BD
    b0f0:	b0 90 be 75 	lds	r11, 0x75BE
    b0f4:	c0 90 bf 75 	lds	r12, 0x75BF
    b0f8:	d0 90 c0 75 	lds	r13, 0x75C0
    b0fc:	8d e1       	ldi	r24, 0x1D	; 29
    b0fe:	9a e5       	ldi	r25, 0x5A	; 90
    b100:	a4 e5       	ldi	r26, 0x54	; 84
    b102:	bf e3       	ldi	r27, 0x3F	; 63
    b104:	ed b7       	in	r30, 0x3d	; 61
    b106:	fe b7       	in	r31, 0x3e	; 62
    b108:	81 83       	std	Z+1, r24	; 0x01
    b10a:	92 83       	std	Z+2, r25	; 0x02
    b10c:	a3 83       	std	Z+3, r26	; 0x03
    b10e:	b4 83       	std	Z+4, r27	; 0x04
    b110:	82 e0       	ldi	r24, 0x02	; 2
    b112:	90 e0       	ldi	r25, 0x00	; 0
    b114:	4f ef       	ldi	r20, 0xFF	; 255
    b116:	5f ef       	ldi	r21, 0xFF	; 255
    b118:	6f ef       	ldi	r22, 0xFF	; 255
    b11a:	7f e7       	ldi	r23, 0x7F	; 127
    b11c:	b9 e0       	ldi	r27, 0x09	; 9
    b11e:	eb 2e       	mov	r14, r27
    b120:	f1 2c       	mov	r15, r1
    b122:	ec 0e       	add	r14, r28
    b124:	fd 1e       	adc	r15, r29
    b126:	a1 e1       	ldi	r26, 0x11	; 17
    b128:	8a 2e       	mov	r8, r26
    b12a:	91 2c       	mov	r9, r1
    b12c:	8c 0e       	add	r8, r28
    b12e:	9d 1e       	adc	r9, r29
    b130:	0e 94 d8 56 	call	0xadb0	; 0xadb0 <mov_correlacionado_HOME>
												hAxis[Axis].axisSettings.homeVelocity,
												&Velocidad_eje2_temp,hAxis[Axis].axisSettings.homeAcceleration,
												&Aceleracion_eje2_temp,CORRELACION_HOMBRO_CODO);		
			//Configurando los registros de pitch, el pitch esta en el mismo sentido que el codo.
			mov_correlacionado_HOME(AxisPitch,INF,
    b134:	09 85       	ldd	r16, Y+9	; 0x09
    b136:	1a 85       	ldd	r17, Y+10	; 0x0a
    b138:	2b 85       	ldd	r18, Y+11	; 0x0b
    b13a:	3c 85       	ldd	r19, Y+12	; 0x0c
    b13c:	a9 88       	ldd	r10, Y+17	; 0x11
    b13e:	ba 88       	ldd	r11, Y+18	; 0x12
    b140:	cb 88       	ldd	r12, Y+19	; 0x13
    b142:	dc 88       	ldd	r13, Y+20	; 0x14
    b144:	89 ec       	ldi	r24, 0xC9	; 201
    b146:	9e e8       	ldi	r25, 0x8E	; 142
    b148:	ad e8       	ldi	r26, 0x8D	; 141
    b14a:	bc e3       	ldi	r27, 0x3C	; 60
    b14c:	ed b7       	in	r30, 0x3d	; 61
    b14e:	fe b7       	in	r31, 0x3e	; 62
    b150:	81 83       	std	Z+1, r24	; 0x01
    b152:	92 83       	std	Z+2, r25	; 0x02
    b154:	a3 83       	std	Z+3, r26	; 0x03
    b156:	b4 83       	std	Z+4, r27	; 0x04
    b158:	83 e0       	ldi	r24, 0x03	; 3
    b15a:	90 e0       	ldi	r25, 0x00	; 0
    b15c:	4f ef       	ldi	r20, 0xFF	; 255
    b15e:	5f ef       	ldi	r21, 0xFF	; 255
    b160:	6f ef       	ldi	r22, 0xFF	; 255
    b162:	7f e7       	ldi	r23, 0x7F	; 127
    b164:	fd e0       	ldi	r31, 0x0D	; 13
    b166:	ef 2e       	mov	r14, r31
    b168:	f1 2c       	mov	r15, r1
    b16a:	ec 0e       	add	r14, r28
    b16c:	fd 1e       	adc	r15, r29
    b16e:	e5 e1       	ldi	r30, 0x15	; 21
    b170:	8e 2e       	mov	r8, r30
    b172:	91 2c       	mov	r9, r1
    b174:	8c 0e       	add	r8, r28
    b176:	9d 1e       	adc	r9, r29
    b178:	0e 94 d8 56 	call	0xadb0	; 0xadb0 <mov_correlacionado_HOME>
												&Velocidad_final_pitch,Aceleracion_eje2_temp,
												&Aceleracion_final_pitch,
												CORRELACION_CODO_PITCH);
			
	
			printf("search_home_positive=>  Update AxisShoulder \n ");
    b17c:	0f 90       	pop	r0
    b17e:	0f 90       	pop	r0
    b180:	82 ee       	ldi	r24, 0xE2	; 226
    b182:	9e e4       	ldi	r25, 0x4E	; 78
    b184:	ad b7       	in	r26, 0x3d	; 61
    b186:	be b7       	in	r27, 0x3e	; 62
    b188:	12 96       	adiw	r26, 0x02	; 2
    b18a:	9c 93       	st	X, r25
    b18c:	8e 93       	st	-X, r24
    b18e:	11 97       	sbiw	r26, 0x01	; 1
    b190:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisShoulder]);
    b194:	0f 90       	pop	r0
    b196:	0f 90       	pop	r0
    b198:	89 e7       	ldi	r24, 0x79	; 121
    b19a:	95 e7       	ldi	r25, 0x75	; 117
    b19c:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			printf("search_home_positive=>  Update AxisElbow \n ");
    b1a0:	00 d0       	rcall	.+0      	; 0xb1a2 <search_home_positive+0x248>
    b1a2:	81 e1       	ldi	r24, 0x11	; 17
    b1a4:	9f e4       	ldi	r25, 0x4F	; 79
    b1a6:	ed b7       	in	r30, 0x3d	; 61
    b1a8:	fe b7       	in	r31, 0x3e	; 62
    b1aa:	92 83       	std	Z+2, r25	; 0x02
    b1ac:	81 83       	std	Z+1, r24	; 0x01
    b1ae:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisElbow]);	
    b1b2:	0f 90       	pop	r0
    b1b4:	0f 90       	pop	r0
    b1b6:	89 ed       	ldi	r24, 0xD9	; 217
    b1b8:	95 e7       	ldi	r25, 0x75	; 117
    b1ba:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			printf("search_home_positive=>  Update AxisPitch \n ");
    b1be:	00 d0       	rcall	.+0      	; 0xb1c0 <search_home_positive+0x266>
    b1c0:	8d e3       	ldi	r24, 0x3D	; 61
    b1c2:	9f e4       	ldi	r25, 0x4F	; 79
    b1c4:	ad b7       	in	r26, 0x3d	; 61
    b1c6:	be b7       	in	r27, 0x3e	; 62
    b1c8:	12 96       	adiw	r26, 0x02	; 2
    b1ca:	9c 93       	st	X, r25
    b1cc:	8e 93       	st	-X, r24
    b1ce:	11 97       	sbiw	r26, 0x01	; 1
    b1d0:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisPitch]);	
    b1d4:	0f 90       	pop	r0
    b1d6:	0f 90       	pop	r0
    b1d8:	89 e3       	ldi	r24, 0x39	; 57
    b1da:	96 e7       	ldi	r25, 0x76	; 118
    b1dc:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			printf("search_home_positive=>  Update AxisRoll \n ");
    b1e0:	00 d0       	rcall	.+0      	; 0xb1e2 <search_home_positive+0x288>
    b1e2:	89 e6       	ldi	r24, 0x69	; 105
    b1e4:	9f e4       	ldi	r25, 0x4F	; 79
    b1e6:	ed b7       	in	r30, 0x3d	; 61
    b1e8:	fe b7       	in	r31, 0x3e	; 62
    b1ea:	92 83       	std	Z+2, r25	; 0x02
    b1ec:	81 83       	std	Z+1, r24	; 0x01
    b1ee:	74 c0       	rjmp	.+232    	; 0xb2d8 <search_home_positive+0x37e>
			PMDUpdate(&hAxis[AxisRoll]);
		}	
		break;
		case (AxisElbow):
		{
			mov_axis(Axis,INF, 
    b1f0:	00 91 19 76 	lds	r16, 0x7619
    b1f4:	10 91 1a 76 	lds	r17, 0x761A
    b1f8:	20 91 1b 76 	lds	r18, 0x761B
    b1fc:	30 91 1c 76 	lds	r19, 0x761C
    b200:	c0 90 1d 76 	lds	r12, 0x761D
    b204:	d0 90 1e 76 	lds	r13, 0x761E
    b208:	e0 90 1f 76 	lds	r14, 0x761F
    b20c:	f0 90 20 76 	lds	r15, 0x7620
    b210:	82 e0       	ldi	r24, 0x02	; 2
    b212:	90 e0       	ldi	r25, 0x00	; 0
    b214:	4f ef       	ldi	r20, 0xFF	; 255
    b216:	5f ef       	ldi	r21, 0xFF	; 255
    b218:	6f ef       	ldi	r22, 0xFF	; 255
    b21a:	7f e7       	ldi	r23, 0x7F	; 127
    b21c:	bf ee       	ldi	r27, 0xEF	; 239
    b21e:	ab 2e       	mov	r10, r27
    b220:	bf ef       	ldi	r27, 0xFF	; 255
    b222:	bb 2e       	mov	r11, r27
    b224:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
			hAxis[Axis].axisSettings.homeVelocity*0.0166,
			300,
			no_update,EN_CALIBRACION_PROCESOHOME );
			*/
			
			mov_correlacionado_HOME(AxisPitch,INF,
    b228:	00 d0       	rcall	.+0      	; 0xb22a <search_home_positive+0x2d0>
    b22a:	00 d0       	rcall	.+0      	; 0xb22c <search_home_positive+0x2d2>
    b22c:	00 91 19 76 	lds	r16, 0x7619
    b230:	10 91 1a 76 	lds	r17, 0x761A
    b234:	20 91 1b 76 	lds	r18, 0x761B
    b238:	30 91 1c 76 	lds	r19, 0x761C
    b23c:	a0 90 1d 76 	lds	r10, 0x761D
    b240:	b0 90 1e 76 	lds	r11, 0x761E
    b244:	c0 90 1f 76 	lds	r12, 0x761F
    b248:	d0 90 20 76 	lds	r13, 0x7620
    b24c:	89 ec       	ldi	r24, 0xC9	; 201
    b24e:	9e e8       	ldi	r25, 0x8E	; 142
    b250:	ad e8       	ldi	r26, 0x8D	; 141
    b252:	bc e3       	ldi	r27, 0x3C	; 60
    b254:	ed b7       	in	r30, 0x3d	; 61
    b256:	fe b7       	in	r31, 0x3e	; 62
    b258:	81 83       	std	Z+1, r24	; 0x01
    b25a:	92 83       	std	Z+2, r25	; 0x02
    b25c:	a3 83       	std	Z+3, r26	; 0x03
    b25e:	b4 83       	std	Z+4, r27	; 0x04
    b260:	83 e0       	ldi	r24, 0x03	; 3
    b262:	90 e0       	ldi	r25, 0x00	; 0
    b264:	4f ef       	ldi	r20, 0xFF	; 255
    b266:	5f ef       	ldi	r21, 0xFF	; 255
    b268:	6f ef       	ldi	r22, 0xFF	; 255
    b26a:	7f e7       	ldi	r23, 0x7F	; 127
    b26c:	ad e0       	ldi	r26, 0x0D	; 13
    b26e:	ea 2e       	mov	r14, r26
    b270:	f1 2c       	mov	r15, r1
    b272:	ec 0e       	add	r14, r28
    b274:	fd 1e       	adc	r15, r29
    b276:	f5 e1       	ldi	r31, 0x15	; 21
    b278:	8f 2e       	mov	r8, r31
    b27a:	91 2c       	mov	r9, r1
    b27c:	8c 0e       	add	r8, r28
    b27e:	9d 1e       	adc	r9, r29
    b280:	0e 94 d8 56 	call	0xadb0	; 0xadb0 <mov_correlacionado_HOME>
												&Velocidad_final_pitch,hAxis[Axis].axisSettings.homeAcceleration,
												&Aceleracion_final_pitch,
												CORRELACION_CODO_PITCH);
			
	
			printf("search_home_positive=>  Update AxisElbow \n ");
    b284:	0f 90       	pop	r0
    b286:	0f 90       	pop	r0
    b288:	81 e1       	ldi	r24, 0x11	; 17
    b28a:	9f e4       	ldi	r25, 0x4F	; 79
    b28c:	ad b7       	in	r26, 0x3d	; 61
    b28e:	be b7       	in	r27, 0x3e	; 62
    b290:	12 96       	adiw	r26, 0x02	; 2
    b292:	9c 93       	st	X, r25
    b294:	8e 93       	st	-X, r24
    b296:	11 97       	sbiw	r26, 0x01	; 1
    b298:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisElbow]);	
    b29c:	0f 90       	pop	r0
    b29e:	0f 90       	pop	r0
    b2a0:	89 ed       	ldi	r24, 0xD9	; 217
    b2a2:	95 e7       	ldi	r25, 0x75	; 117
    b2a4:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			printf("search_home_positive=>  Update AxisPitch \n ");
    b2a8:	00 d0       	rcall	.+0      	; 0xb2aa <search_home_positive+0x350>
    b2aa:	8d e3       	ldi	r24, 0x3D	; 61
    b2ac:	9f e4       	ldi	r25, 0x4F	; 79
    b2ae:	ed b7       	in	r30, 0x3d	; 61
    b2b0:	fe b7       	in	r31, 0x3e	; 62
    b2b2:	92 83       	std	Z+2, r25	; 0x02
    b2b4:	81 83       	std	Z+1, r24	; 0x01
    b2b6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisPitch]);
    b2ba:	0f 90       	pop	r0
    b2bc:	0f 90       	pop	r0
    b2be:	89 e3       	ldi	r24, 0x39	; 57
    b2c0:	96 e7       	ldi	r25, 0x76	; 118
    b2c2:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			printf("search_home_positive=>  Update AxisRoll \n ");
    b2c6:	00 d0       	rcall	.+0      	; 0xb2c8 <search_home_positive+0x36e>
    b2c8:	89 e6       	ldi	r24, 0x69	; 105
    b2ca:	9f e4       	ldi	r25, 0x4F	; 79
    b2cc:	ad b7       	in	r26, 0x3d	; 61
    b2ce:	be b7       	in	r27, 0x3e	; 62
    b2d0:	12 96       	adiw	r26, 0x02	; 2
    b2d2:	9c 93       	st	X, r25
    b2d4:	8e 93       	st	-X, r24
    b2d6:	11 97       	sbiw	r26, 0x01	; 1
    b2d8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisRoll]);
    b2dc:	0f 90       	pop	r0
    b2de:	0f 90       	pop	r0
    b2e0:	89 e9       	ldi	r24, 0x99	; 153
    b2e2:	96 e7       	ldi	r25, 0x76	; 118
    b2e4:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
    b2e8:	8e c0       	rjmp	.+284    	; 0xb406 <search_home_positive+0x4ac>
		}
		break;
		case (AxisPitch):
		{
			pitch(INF, (hAxis[Axis].axisSettings.homeVelocity)/2,
    b2ea:	60 91 79 76 	lds	r22, 0x7679
    b2ee:	70 91 7a 76 	lds	r23, 0x767A
    b2f2:	80 91 7b 76 	lds	r24, 0x767B
    b2f6:	90 91 7c 76 	lds	r25, 0x767C
    b2fa:	22 e0       	ldi	r18, 0x02	; 2
    b2fc:	30 e0       	ldi	r19, 0x00	; 0
    b2fe:	40 e0       	ldi	r20, 0x00	; 0
    b300:	50 e0       	ldi	r21, 0x00	; 0
    b302:	0e 94 7a 9c 	call	0x138f4	; 0x138f4 <__divmodsi4>
    b306:	e0 90 7d 76 	lds	r14, 0x767D
    b30a:	f0 90 7e 76 	lds	r15, 0x767E
    b30e:	00 91 7f 76 	lds	r16, 0x767F
    b312:	10 91 80 76 	lds	r17, 0x7680
    b316:	6f ef       	ldi	r22, 0xFF	; 255
    b318:	7f ef       	ldi	r23, 0xFF	; 255
    b31a:	8f ef       	ldi	r24, 0xFF	; 255
    b31c:	9f e7       	ldi	r25, 0x7F	; 127
    b31e:	e0 ef       	ldi	r30, 0xF0	; 240
    b320:	ce 2e       	mov	r12, r30
    b322:	ef ef       	ldi	r30, 0xFF	; 255
    b324:	de 2e       	mov	r13, r30
    b326:	b4 e0       	ldi	r27, 0x04	; 4
    b328:	ab 2e       	mov	r10, r27
    b32a:	b1 2c       	mov	r11, r1
    b32c:	0e 94 78 52 	call	0xa4f0	; 0xa4f0 <pitch>
			hAxis[Axis].axisSettings.homeAcceleration, update,INICIANDO_HOME_PITCH_ROLL);
			#ifdef DEBUGROBOTICS_HOME
			PMDGetHostIOError(&hAxis[AxisRoll], &test);
    b330:	89 e9       	ldi	r24, 0x99	; 153
    b332:	96 e7       	ldi	r25, 0x76	; 118
    b334:	b4 01       	movw	r22, r8
    b336:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
			printf("search_home_positive=> HostIOError = %x del eje ROLL despues del update.\n ",test);
    b33a:	00 d0       	rcall	.+0      	; 0xb33c <search_home_positive+0x3e2>
    b33c:	00 d0       	rcall	.+0      	; 0xb33e <search_home_positive+0x3e4>
    b33e:	84 e9       	ldi	r24, 0x94	; 148
    b340:	9f e4       	ldi	r25, 0x4F	; 79
    b342:	ed b7       	in	r30, 0x3d	; 61
    b344:	fe b7       	in	r31, 0x3e	; 62
    b346:	92 83       	std	Z+2, r25	; 0x02
    b348:	81 83       	std	Z+1, r24	; 0x01
    b34a:	8b 81       	ldd	r24, Y+3	; 0x03
    b34c:	9c 81       	ldd	r25, Y+4	; 0x04
    b34e:	94 83       	std	Z+4, r25	; 0x04
    b350:	83 83       	std	Z+3, r24	; 0x03
    b352:	32 c0       	rjmp	.+100    	; 0xb3b8 <search_home_positive+0x45e>
			#endif
		}
	    break;
		
		case (AxisRoll):		
			roll(INF, hAxis[Axis].axisSettings.homeVelocity,
    b354:	20 91 d9 76 	lds	r18, 0x76D9
    b358:	30 91 da 76 	lds	r19, 0x76DA
    b35c:	40 91 db 76 	lds	r20, 0x76DB
    b360:	50 91 dc 76 	lds	r21, 0x76DC
    b364:	e0 90 dd 76 	lds	r14, 0x76DD
    b368:	f0 90 de 76 	lds	r15, 0x76DE
    b36c:	00 91 df 76 	lds	r16, 0x76DF
    b370:	10 91 e0 76 	lds	r17, 0x76E0
    b374:	6f ef       	ldi	r22, 0xFF	; 255
    b376:	7f ef       	ldi	r23, 0xFF	; 255
    b378:	8f ef       	ldi	r24, 0xFF	; 255
    b37a:	9f e7       	ldi	r25, 0x7F	; 127
    b37c:	a0 ef       	ldi	r26, 0xF0	; 240
    b37e:	ca 2e       	mov	r12, r26
    b380:	af ef       	ldi	r26, 0xFF	; 255
    b382:	da 2e       	mov	r13, r26
    b384:	f4 e0       	ldi	r31, 0x04	; 4
    b386:	af 2e       	mov	r10, r31
    b388:	b1 2c       	mov	r11, r1
    b38a:	0e 94 1b 50 	call	0xa036	; 0xa036 <roll>
			hAxis[Axis].axisSettings.homeAcceleration, update,INICIANDO_HOME_PITCH_ROLL );
			#ifdef DEBUGROBOTICS_HOME
			PMDGetHostIOError(&hAxis[AxisRoll], &test);
    b38e:	89 e9       	ldi	r24, 0x99	; 153
    b390:	96 e7       	ldi	r25, 0x76	; 118
    b392:	b4 01       	movw	r22, r8
    b394:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
			printf("search_home_positive=> HostIOError = %x del eje pitch despues del update.\n ",test);
    b398:	00 d0       	rcall	.+0      	; 0xb39a <search_home_positive+0x440>
    b39a:	00 d0       	rcall	.+0      	; 0xb39c <search_home_positive+0x442>
    b39c:	8f ed       	ldi	r24, 0xDF	; 223
    b39e:	9f e4       	ldi	r25, 0x4F	; 79
    b3a0:	ad b7       	in	r26, 0x3d	; 61
    b3a2:	be b7       	in	r27, 0x3e	; 62
    b3a4:	12 96       	adiw	r26, 0x02	; 2
    b3a6:	9c 93       	st	X, r25
    b3a8:	8e 93       	st	-X, r24
    b3aa:	11 97       	sbiw	r26, 0x01	; 1
    b3ac:	8b 81       	ldd	r24, Y+3	; 0x03
    b3ae:	9c 81       	ldd	r25, Y+4	; 0x04
    b3b0:	14 96       	adiw	r26, 0x04	; 4
    b3b2:	9c 93       	st	X, r25
    b3b4:	8e 93       	st	-X, r24
    b3b6:	13 97       	sbiw	r26, 0x03	; 3
    b3b8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    b3bc:	0f 90       	pop	r0
    b3be:	0f 90       	pop	r0
    b3c0:	0f 90       	pop	r0
    b3c2:	0f 90       	pop	r0
    b3c4:	20 c0       	rjmp	.+64     	; 0xb406 <search_home_positive+0x4ac>
			#endif
	
	    break;
		
		default:
			mov_axis(Axis,INF, hAxis[Axis].axisSettings.homeVelocity,
    b3c6:	80 e6       	ldi	r24, 0x60	; 96
    b3c8:	90 e0       	ldi	r25, 0x00	; 0
    b3ca:	68 9e       	mul	r6, r24
    b3cc:	f0 01       	movw	r30, r0
    b3ce:	69 9e       	mul	r6, r25
    b3d0:	f0 0d       	add	r31, r0
    b3d2:	78 9e       	mul	r7, r24
    b3d4:	f0 0d       	add	r31, r0
    b3d6:	11 24       	eor	r1, r1
    b3d8:	e7 5e       	subi	r30, 0xE7	; 231
    b3da:	fa 48       	sbci	r31, 0x8A	; 138
    b3dc:	e0 5c       	subi	r30, 0xC0	; 192
    b3de:	ff 4f       	sbci	r31, 0xFF	; 255
    b3e0:	01 91       	ld	r16, Z+
    b3e2:	11 91       	ld	r17, Z+
    b3e4:	21 91       	ld	r18, Z+
    b3e6:	31 91       	ld	r19, Z+
    b3e8:	c0 80       	ld	r12, Z
    b3ea:	d1 80       	ldd	r13, Z+1	; 0x01
    b3ec:	e2 80       	ldd	r14, Z+2	; 0x02
    b3ee:	f3 80       	ldd	r15, Z+3	; 0x03
    b3f0:	c3 01       	movw	r24, r6
    b3f2:	4f ef       	ldi	r20, 0xFF	; 255
    b3f4:	5f ef       	ldi	r21, 0xFF	; 255
    b3f6:	6f ef       	ldi	r22, 0xFF	; 255
    b3f8:	7f e7       	ldi	r23, 0x7F	; 127
    b3fa:	e0 ef       	ldi	r30, 0xF0	; 240
    b3fc:	ae 2e       	mov	r10, r30
    b3fe:	ef ef       	ldi	r30, 0xFF	; 255
    b400:	be 2e       	mov	r11, r30
    b402:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
	}
		
	

	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    b406:	c2 01       	movw	r24, r4
    b408:	be 01       	movw	r22, r28
    b40a:	6d 5f       	subi	r22, 0xFD	; 253
    b40c:	7f 4f       	sbci	r23, 0xFF	; 255
    b40e:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
	printf("search_home_positive=> HostIOError = %x del eje %s despues del Update.\n ",test,AxisName(Axis));
    b412:	0b 81       	ldd	r16, Y+3	; 0x03
    b414:	1c 81       	ldd	r17, Y+4	; 0x04
    b416:	c3 01       	movw	r24, r6
    b418:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    b41c:	00 d0       	rcall	.+0      	; 0xb41e <search_home_positive+0x4c4>
    b41e:	00 d0       	rcall	.+0      	; 0xb420 <search_home_positive+0x4c6>
    b420:	00 d0       	rcall	.+0      	; 0xb422 <search_home_positive+0x4c8>
    b422:	ed b7       	in	r30, 0x3d	; 61
    b424:	fe b7       	in	r31, 0x3e	; 62
    b426:	31 96       	adiw	r30, 0x01	; 1
    b428:	2b e2       	ldi	r18, 0x2B	; 43
    b42a:	30 e5       	ldi	r19, 0x50	; 80
    b42c:	ad b7       	in	r26, 0x3d	; 61
    b42e:	be b7       	in	r27, 0x3e	; 62
    b430:	12 96       	adiw	r26, 0x02	; 2
    b432:	3c 93       	st	X, r19
    b434:	2e 93       	st	-X, r18
    b436:	11 97       	sbiw	r26, 0x01	; 1
    b438:	13 83       	std	Z+3, r17	; 0x03
    b43a:	02 83       	std	Z+2, r16	; 0x02
    b43c:	95 83       	std	Z+5, r25	; 0x05
    b43e:	84 83       	std	Z+4, r24	; 0x04
    b440:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("search_home_positive=> Iniciando busqueda de home en el sentido positivo.\n");	
    b444:	ed b7       	in	r30, 0x3d	; 61
    b446:	fe b7       	in	r31, 0x3e	; 62
    b448:	36 96       	adiw	r30, 0x06	; 6
    b44a:	0f b6       	in	r0, 0x3f	; 63
    b44c:	f8 94       	cli
    b44e:	fe bf       	out	0x3e, r31	; 62
    b450:	0f be       	out	0x3f, r0	; 63
    b452:	ed bf       	out	0x3d, r30	; 61
    b454:	84 e7       	ldi	r24, 0x74	; 116
    b456:	90 e5       	ldi	r25, 0x50	; 80
    b458:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	#endif	
	
	
	do 
	{ 
		PMDGetEventStatus(&hAxis[Axis],&status);
    b45c:	4e 01       	movw	r8, r28
    b45e:	08 94       	sec
    b460:	81 1c       	adc	r8, r1
    b462:	91 1c       	adc	r9, r1
		
		if((status & PMDEventCaptureReceivedMask) != 0) 
		{   
			#ifdef DEBUGROBOTICS_HOME
			printf("search_home_positive=>  Captura de HOME realizada. \n ");			
    b464:	be eb       	ldi	r27, 0xBE	; 190
    b466:	ab 2e       	mov	r10, r27
    b468:	b0 e5       	ldi	r27, 0x50	; 80
    b46a:	bb 2e       	mov	r11, r27
						PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode ); 
						PMDUpdate(&hAxis[AxisPitch]);
					case (AxisPitch):
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
						PMDUpdate(&hAxis[AxisRoll]);
				    break;
    b46c:	08 94       	sec
    b46e:	61 1c       	adc	r6, r1
    b470:	71 1c       	adc	r7, r1
    b472:	80 e6       	ldi	r24, 0x60	; 96
    b474:	90 e0       	ldi	r25, 0x00	; 0
    b476:	68 9e       	mul	r6, r24
    b478:	60 01       	movw	r12, r0
    b47a:	69 9e       	mul	r6, r25
    b47c:	d0 0c       	add	r13, r0
    b47e:	78 9e       	mul	r7, r24
    b480:	d0 0c       	add	r13, r0
    b482:	11 24       	eor	r1, r1
    b484:	08 94       	sec
    b486:	61 08       	sbc	r6, r1
    b488:	71 08       	sbc	r7, r1
    b48a:	89 e1       	ldi	r24, 0x19	; 25
    b48c:	95 e7       	ldi	r25, 0x75	; 117
    b48e:	c8 0e       	add	r12, r24
    b490:	d9 1e       	adc	r13, r25
	#endif	
	
	
	do 
	{ 
		PMDGetEventStatus(&hAxis[Axis],&status);
    b492:	c2 01       	movw	r24, r4
    b494:	b4 01       	movw	r22, r8
    b496:	0e 94 75 78 	call	0xf0ea	; 0xf0ea <PMDGetEventStatus>
		
		if((status & PMDEventCaptureReceivedMask) != 0) 
    b49a:	89 81       	ldd	r24, Y+1	; 0x01
    b49c:	83 ff       	sbrs	r24, 3
    b49e:	5f c0       	rjmp	.+190    	; 0xb55e <search_home_positive+0x604>
		{   
			#ifdef DEBUGROBOTICS_HOME
			printf("search_home_positive=>  Captura de HOME realizada. \n ");			
    b4a0:	00 d0       	rcall	.+0      	; 0xb4a2 <search_home_positive+0x548>
    b4a2:	ad b7       	in	r26, 0x3d	; 61
    b4a4:	be b7       	in	r27, 0x3e	; 62
    b4a6:	12 96       	adiw	r26, 0x02	; 2
    b4a8:	bc 92       	st	X, r11
    b4aa:	ae 92       	st	-X, r10
    b4ac:	11 97       	sbiw	r26, 0x01	; 1
    b4ae:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			#endif
			PMDGetCaptureValue(&hAxis[Axis],home);
    b4b2:	0f 90       	pop	r0
    b4b4:	0f 90       	pop	r0
    b4b6:	c2 01       	movw	r24, r4
    b4b8:	69 8d       	ldd	r22, Y+25	; 0x19
    b4ba:	7a 8d       	ldd	r23, Y+26	; 0x1a
    b4bc:	0e 94 24 7b 	call	0xf648	; 0xf648 <PMDGetCaptureValue>
			PMDResetEventStatus(&hAxis[Axis],~PMDEventCaptureReceivedMask);
    b4c0:	c2 01       	movw	r24, r4
    b4c2:	67 ef       	ldi	r22, 0xF7	; 247
    b4c4:	7f ef       	ldi	r23, 0xFF	; 255
    b4c6:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
			
			if(rangos==FALSE) //se Hace Caputura de HOME y se quiere detener el motor
    b4ca:	21 14       	cp	r2, r1
    b4cc:	31 04       	cpc	r3, r1
    b4ce:	09 f0       	breq	.+2      	; 0xb4d2 <search_home_positive+0x578>
    b4d0:	46 c0       	rjmp	.+140    	; 0xb55e <search_home_positive+0x604>
				//del eje donde se esta buscando HOME.
				//Ejempo si estoy buscando el home de hombro hay que detener codo y pitch
				//Ya que Home se detiene automaticamente. 
				//Tambien hay que tomar en cuenta los casos especiales de Cintura y roll 
				//Que no se detiene al llegar el home.
				switch (Axis)
    b4d2:	b3 e0       	ldi	r27, 0x03	; 3
    b4d4:	6b 16       	cp	r6, r27
    b4d6:	71 04       	cpc	r7, r1
    b4d8:	01 f1       	breq	.+64     	; 0xb51a <search_home_positive+0x5c0>
    b4da:	e4 e0       	ldi	r30, 0x04	; 4
    b4dc:	6e 16       	cp	r6, r30
    b4de:	71 04       	cpc	r7, r1
    b4e0:	51 f0       	breq	.+20     	; 0xb4f6 <search_home_positive+0x59c>
    b4e2:	61 14       	cp	r6, r1
    b4e4:	71 04       	cpc	r7, r1
    b4e6:	31 f5       	brne	.+76     	; 0xb534 <search_home_positive+0x5da>
				{
				    case (AxisWaist):
						PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode ); 
    b4e8:	c2 01       	movw	r24, r4
    b4ea:	61 e0       	ldi	r22, 0x01	; 1
    b4ec:	70 e0       	ldi	r23, 0x00	; 0
    b4ee:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
						PMDUpdate(&hAxis[Axis]);
    b4f2:	c2 01       	movw	r24, r4
    b4f4:	1a c0       	rjmp	.+52     	; 0xb52a <search_home_positive+0x5d0>
				    break;
					case (AxisRoll):
						PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode ); 
    b4f6:	c2 01       	movw	r24, r4
    b4f8:	61 e0       	ldi	r22, 0x01	; 1
    b4fa:	70 e0       	ldi	r23, 0x00	; 0
    b4fc:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
						PMDUpdate(&hAxis[Axis]);
    b500:	c2 01       	movw	r24, r4
    b502:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
						PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode ); 
    b506:	89 e3       	ldi	r24, 0x39	; 57
    b508:	96 e7       	ldi	r25, 0x76	; 118
    b50a:	61 e0       	ldi	r22, 0x01	; 1
    b50c:	70 e0       	ldi	r23, 0x00	; 0
    b50e:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
						PMDUpdate(&hAxis[AxisPitch]);
    b512:	89 e3       	ldi	r24, 0x39	; 57
    b514:	96 e7       	ldi	r25, 0x76	; 118
    b516:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
					case (AxisPitch):
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
    b51a:	89 e9       	ldi	r24, 0x99	; 153
    b51c:	96 e7       	ldi	r25, 0x76	; 118
    b51e:	61 e0       	ldi	r22, 0x01	; 1
    b520:	70 e0       	ldi	r23, 0x00	; 0
    b522:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
						PMDUpdate(&hAxis[AxisRoll]);
    b526:	89 e9       	ldi	r24, 0x99	; 153
    b528:	96 e7       	ldi	r25, 0x76	; 118
    b52a:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
    b52e:	20 e0       	ldi	r18, 0x00	; 0
    b530:	30 e0       	ldi	r19, 0x00	; 0
    b532:	17 c0       	rjmp	.+46     	; 0xb562 <search_home_positive+0x608>
				    break;
    b534:	86 01       	movw	r16, r12
    b536:	73 01       	movw	r14, r6
    b538:	0a c0       	rjmp	.+20     	; 0xb54e <search_home_positive+0x5f4>
				    default:
						
				    	for(Axis_Update=Axis+1; Axis_Update < DOF; Axis_Update++) 
						{ 
							PMDSetStopMode(&hAxis[Axis_Update], PMDAbruptStopMode ); 
    b53a:	c8 01       	movw	r24, r16
    b53c:	61 e0       	ldi	r22, 0x01	; 1
    b53e:	70 e0       	ldi	r23, 0x00	; 0
    b540:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
							PMDUpdate(&hAxis[Axis_Update]);
    b544:	c8 01       	movw	r24, r16
    b546:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
    b54a:	00 5a       	subi	r16, 0xA0	; 160
    b54c:	1f 4f       	sbci	r17, 0xFF	; 255
    b54e:	08 94       	sec
    b550:	e1 1c       	adc	r14, r1
    b552:	f1 1c       	adc	r15, r1
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
						PMDUpdate(&hAxis[AxisRoll]);
				    break;
				    default:
						
				    	for(Axis_Update=Axis+1; Axis_Update < DOF; Axis_Update++) 
    b554:	f5 e0       	ldi	r31, 0x05	; 5
    b556:	ef 16       	cp	r14, r31
    b558:	f1 04       	cpc	r15, r1
    b55a:	7c f3       	brlt	.-34     	; 0xb53a <search_home_positive+0x5e0>
    b55c:	e8 cf       	rjmp	.-48     	; 0xb52e <search_home_positive+0x5d4>
    b55e:	21 e0       	ldi	r18, 0x01	; 1
    b560:	30 e0       	ldi	r19, 0x00	; 0
		#ifdef DEBUGROBOTICS_HOME
		//	printf("Moviendo en direccion positiva. \n ");
		//	printf("El Event status register del eje %s es %X \n",AxisName(Axis),status);	
		#endif
	} 
	while (((status & PMDEventInPositiveLimitMask) ==0) && (find_home_out==1));
    b562:	89 81       	ldd	r24, Y+1	; 0x01
    b564:	85 fd       	sbrc	r24, 5
    b566:	04 c0       	rjmp	.+8      	; 0xb570 <search_home_positive+0x616>
    b568:	21 30       	cpi	r18, 0x01	; 1
    b56a:	31 05       	cpc	r19, r1
    b56c:	09 f4       	brne	.+2      	; 0xb570 <search_home_positive+0x616>
    b56e:	91 cf       	rjmp	.-222    	; 0xb492 <search_home_positive+0x538>

	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    b570:	c2 01       	movw	r24, r4
    b572:	be 01       	movw	r22, r28
    b574:	6d 5f       	subi	r22, 0xFD	; 253
    b576:	7f 4f       	sbci	r23, 0xFF	; 255
    b578:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
	printf("search_home_positive=> Error en el eje %s despues del movimiento %x\n ",AxisName(Axis),test);
    b57c:	c3 01       	movw	r24, r6
    b57e:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    b582:	00 d0       	rcall	.+0      	; 0xb584 <search_home_positive+0x62a>
    b584:	00 d0       	rcall	.+0      	; 0xb586 <search_home_positive+0x62c>
    b586:	00 d0       	rcall	.+0      	; 0xb588 <search_home_positive+0x62e>
    b588:	ed b7       	in	r30, 0x3d	; 61
    b58a:	fe b7       	in	r31, 0x3e	; 62
    b58c:	31 96       	adiw	r30, 0x01	; 1
    b58e:	24 ef       	ldi	r18, 0xF4	; 244
    b590:	30 e5       	ldi	r19, 0x50	; 80
    b592:	ad b7       	in	r26, 0x3d	; 61
    b594:	be b7       	in	r27, 0x3e	; 62
    b596:	12 96       	adiw	r26, 0x02	; 2
    b598:	3c 93       	st	X, r19
    b59a:	2e 93       	st	-X, r18
    b59c:	11 97       	sbiw	r26, 0x01	; 1
    b59e:	93 83       	std	Z+3, r25	; 0x03
    b5a0:	82 83       	std	Z+2, r24	; 0x02
    b5a2:	8b 81       	ldd	r24, Y+3	; 0x03
    b5a4:	9c 81       	ldd	r25, Y+4	; 0x04
    b5a6:	95 83       	std	Z+5, r25	; 0x05
    b5a8:	84 83       	std	Z+4, r24	; 0x04
    b5aa:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	PMDGetEventStatus(&hAxis[Axis],&status);  
    b5ae:	ed b7       	in	r30, 0x3d	; 61
    b5b0:	fe b7       	in	r31, 0x3e	; 62
    b5b2:	36 96       	adiw	r30, 0x06	; 6
    b5b4:	0f b6       	in	r0, 0x3f	; 63
    b5b6:	f8 94       	cli
    b5b8:	fe bf       	out	0x3e, r31	; 62
    b5ba:	0f be       	out	0x3f, r0	; 63
    b5bc:	ed bf       	out	0x3d, r30	; 61
    b5be:	c2 01       	movw	r24, r4
    b5c0:	8e 01       	movw	r16, r28
    b5c2:	0f 5f       	subi	r16, 0xFF	; 255
    b5c4:	1f 4f       	sbci	r17, 0xFF	; 255
    b5c6:	b8 01       	movw	r22, r16
    b5c8:	0e 94 75 78 	call	0xf0ea	; 0xf0ea <PMDGetEventStatus>
	printf("search_home_positive=> El Event status register antes de limpiar del eje %s es %X \n",AxisName(Axis),status);	
    b5cc:	c3 01       	movw	r24, r6
    b5ce:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    b5d2:	00 d0       	rcall	.+0      	; 0xb5d4 <search_home_positive+0x67a>
    b5d4:	00 d0       	rcall	.+0      	; 0xb5d6 <search_home_positive+0x67c>
    b5d6:	00 d0       	rcall	.+0      	; 0xb5d8 <search_home_positive+0x67e>
    b5d8:	ed b7       	in	r30, 0x3d	; 61
    b5da:	fe b7       	in	r31, 0x3e	; 62
    b5dc:	31 96       	adiw	r30, 0x01	; 1
    b5de:	2a e3       	ldi	r18, 0x3A	; 58
    b5e0:	31 e5       	ldi	r19, 0x51	; 81
    b5e2:	ad b7       	in	r26, 0x3d	; 61
    b5e4:	be b7       	in	r27, 0x3e	; 62
    b5e6:	12 96       	adiw	r26, 0x02	; 2
    b5e8:	3c 93       	st	X, r19
    b5ea:	2e 93       	st	-X, r18
    b5ec:	11 97       	sbiw	r26, 0x01	; 1
    b5ee:	93 83       	std	Z+3, r25	; 0x03
    b5f0:	82 83       	std	Z+2, r24	; 0x02
    b5f2:	89 81       	ldd	r24, Y+1	; 0x01
    b5f4:	9a 81       	ldd	r25, Y+2	; 0x02
    b5f6:	95 83       	std	Z+5, r25	; 0x05
    b5f8:	84 83       	std	Z+4, r24	; 0x04
    b5fa:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	#endif	

	
	/*Se limpia el Event Status Register, borrando las interrupciones generadas: Evento de Limite
	Positivo y Fin de movimiento*/	
	Reset_Even_Status_Register();
    b5fe:	ed b7       	in	r30, 0x3d	; 61
    b600:	fe b7       	in	r31, 0x3e	; 62
    b602:	36 96       	adiw	r30, 0x06	; 6
    b604:	0f b6       	in	r0, 0x3f	; 63
    b606:	f8 94       	cli
    b608:	fe bf       	out	0x3e, r31	; 62
    b60a:	0f be       	out	0x3f, r0	; 63
    b60c:	ed bf       	out	0x3d, r30	; 61
    b60e:	0e 94 65 41 	call	0x82ca	; 0x82ca <Reset_Even_Status_Register>
	
	
	/* Se obtiene la posicion Actual del encoder*/
	PMDGetActualPosition(&hAxis[Axis],posicion);
    b612:	c2 01       	movw	r24, r4
    b614:	6b 8d       	ldd	r22, Y+27	; 0x1b
    b616:	7c 8d       	ldd	r23, Y+28	; 0x1c
    b618:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetEventStatus(&hAxis[Axis],&status);  
    b61c:	c2 01       	movw	r24, r4
    b61e:	b8 01       	movw	r22, r16
    b620:	0e 94 75 78 	call	0xf0ea	; 0xf0ea <PMDGetEventStatus>
	printf("search_home_positive=> El Event status register del eje %s despues de limpiar es %X \n ",AxisName(Axis),status);	
    b624:	c3 01       	movw	r24, r6
    b626:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    b62a:	00 d0       	rcall	.+0      	; 0xb62c <search_home_positive+0x6d2>
    b62c:	00 d0       	rcall	.+0      	; 0xb62e <search_home_positive+0x6d4>
    b62e:	00 d0       	rcall	.+0      	; 0xb630 <search_home_positive+0x6d6>
    b630:	ed b7       	in	r30, 0x3d	; 61
    b632:	fe b7       	in	r31, 0x3e	; 62
    b634:	31 96       	adiw	r30, 0x01	; 1
    b636:	2e e8       	ldi	r18, 0x8E	; 142
    b638:	31 e5       	ldi	r19, 0x51	; 81
    b63a:	ad b7       	in	r26, 0x3d	; 61
    b63c:	be b7       	in	r27, 0x3e	; 62
    b63e:	12 96       	adiw	r26, 0x02	; 2
    b640:	3c 93       	st	X, r19
    b642:	2e 93       	st	-X, r18
    b644:	11 97       	sbiw	r26, 0x01	; 1
    b646:	93 83       	std	Z+3, r25	; 0x03
    b648:	82 83       	std	Z+2, r24	; 0x02
    b64a:	89 81       	ldd	r24, Y+1	; 0x01
    b64c:	9a 81       	ldd	r25, Y+2	; 0x02
    b64e:	95 83       	std	Z+5, r25	; 0x05
    b650:	84 83       	std	Z+4, r24	; 0x04
    b652:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    b656:	ed b7       	in	r30, 0x3d	; 61
    b658:	fe b7       	in	r31, 0x3e	; 62
    b65a:	36 96       	adiw	r30, 0x06	; 6
    b65c:	0f b6       	in	r0, 0x3f	; 63
    b65e:	f8 94       	cli
    b660:	fe bf       	out	0x3e, r31	; 62
    b662:	0f be       	out	0x3f, r0	; 63
    b664:	ed bf       	out	0x3d, r30	; 61
	#endif
}
    b666:	6c 96       	adiw	r28, 0x1c	; 28
    b668:	0f b6       	in	r0, 0x3f	; 63
    b66a:	f8 94       	cli
    b66c:	de bf       	out	0x3e, r29	; 62
    b66e:	0f be       	out	0x3f, r0	; 63
    b670:	cd bf       	out	0x3d, r28	; 61
    b672:	cf 91       	pop	r28
    b674:	df 91       	pop	r29
    b676:	1f 91       	pop	r17
    b678:	0f 91       	pop	r16
    b67a:	ff 90       	pop	r15
    b67c:	ef 90       	pop	r14
    b67e:	df 90       	pop	r13
    b680:	cf 90       	pop	r12
    b682:	bf 90       	pop	r11
    b684:	af 90       	pop	r10
    b686:	9f 90       	pop	r9
    b688:	8f 90       	pop	r8
    b68a:	7f 90       	pop	r7
    b68c:	6f 90       	pop	r6
    b68e:	5f 90       	pop	r5
    b690:	4f 90       	pop	r4
    b692:	3f 90       	pop	r3
    b694:	2f 90       	pop	r2
    b696:	08 95       	ret

0000b698 <search_home_negative>:



/**********************************************************************************************************************/
void search_home_negative(int16 Axis,PMDint32 *home,PMDint32 *posicion,PMDint16 rangos)
{
    b698:	2f 92       	push	r2
    b69a:	3f 92       	push	r3
    b69c:	4f 92       	push	r4
    b69e:	5f 92       	push	r5
    b6a0:	6f 92       	push	r6
    b6a2:	7f 92       	push	r7
    b6a4:	8f 92       	push	r8
    b6a6:	9f 92       	push	r9
    b6a8:	af 92       	push	r10
    b6aa:	bf 92       	push	r11
    b6ac:	cf 92       	push	r12
    b6ae:	df 92       	push	r13
    b6b0:	ef 92       	push	r14
    b6b2:	ff 92       	push	r15
    b6b4:	0f 93       	push	r16
    b6b6:	1f 93       	push	r17
    b6b8:	df 93       	push	r29
    b6ba:	cf 93       	push	r28
    b6bc:	cd b7       	in	r28, 0x3d	; 61
    b6be:	de b7       	in	r29, 0x3e	; 62
    b6c0:	6c 97       	sbiw	r28, 0x1c	; 28
    b6c2:	0f b6       	in	r0, 0x3f	; 63
    b6c4:	f8 94       	cli
    b6c6:	de bf       	out	0x3e, r29	; 62
    b6c8:	0f be       	out	0x3f, r0	; 63
    b6ca:	cd bf       	out	0x3d, r28	; 61
    b6cc:	3c 01       	movw	r6, r24
    b6ce:	1b 01       	movw	r2, r22
    b6d0:	5a 8f       	std	Y+26, r21	; 0x1a
    b6d2:	49 8f       	std	Y+25, r20	; 0x19
    b6d4:	3c 8f       	std	Y+28, r19	; 0x1c
    b6d6:	2b 8f       	std	Y+27, r18	; 0x1b
	find_home_out=1;
	

	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    b6d8:	80 e6       	ldi	r24, 0x60	; 96
    b6da:	90 e0       	ldi	r25, 0x00	; 0
    b6dc:	68 9e       	mul	r6, r24
    b6de:	20 01       	movw	r4, r0
    b6e0:	69 9e       	mul	r6, r25
    b6e2:	50 0c       	add	r5, r0
    b6e4:	78 9e       	mul	r7, r24
    b6e6:	50 0c       	add	r5, r0
    b6e8:	11 24       	eor	r1, r1
    b6ea:	89 e1       	ldi	r24, 0x19	; 25
    b6ec:	95 e7       	ldi	r25, 0x75	; 117
    b6ee:	48 0e       	add	r4, r24
    b6f0:	59 1e       	adc	r5, r25
    b6f2:	13 e0       	ldi	r17, 0x03	; 3
    b6f4:	81 2e       	mov	r8, r17
    b6f6:	91 2c       	mov	r9, r1
    b6f8:	8c 0e       	add	r8, r28
    b6fa:	9d 1e       	adc	r9, r29
    b6fc:	c2 01       	movw	r24, r4
    b6fe:	b4 01       	movw	r22, r8
    b700:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
	printf("search_home_negative=> HostIOError = %x para el eje %s\n ",test,AxisName(Axis));
    b704:	0b 81       	ldd	r16, Y+3	; 0x03
    b706:	1c 81       	ldd	r17, Y+4	; 0x04
    b708:	c3 01       	movw	r24, r6
    b70a:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    b70e:	00 d0       	rcall	.+0      	; 0xb710 <search_home_negative+0x78>
    b710:	00 d0       	rcall	.+0      	; 0xb712 <search_home_negative+0x7a>
    b712:	00 d0       	rcall	.+0      	; 0xb714 <search_home_negative+0x7c>
    b714:	ed b7       	in	r30, 0x3d	; 61
    b716:	fe b7       	in	r31, 0x3e	; 62
    b718:	31 96       	adiw	r30, 0x01	; 1
    b71a:	25 ee       	ldi	r18, 0xE5	; 229
    b71c:	31 e5       	ldi	r19, 0x51	; 81
    b71e:	ad b7       	in	r26, 0x3d	; 61
    b720:	be b7       	in	r27, 0x3e	; 62
    b722:	12 96       	adiw	r26, 0x02	; 2
    b724:	3c 93       	st	X, r19
    b726:	2e 93       	st	-X, r18
    b728:	11 97       	sbiw	r26, 0x01	; 1
    b72a:	13 83       	std	Z+3, r17	; 0x03
    b72c:	02 83       	std	Z+2, r16	; 0x02
    b72e:	95 83       	std	Z+5, r25	; 0x05
    b730:	84 83       	std	Z+4, r24	; 0x04
    b732:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	#endif
	
	No_limit_switch(Axis);
    b736:	ed b7       	in	r30, 0x3d	; 61
    b738:	fe b7       	in	r31, 0x3e	; 62
    b73a:	36 96       	adiw	r30, 0x06	; 6
    b73c:	0f b6       	in	r0, 0x3f	; 63
    b73e:	f8 94       	cli
    b740:	fe bf       	out	0x3e, r31	; 62
    b742:	0f be       	out	0x3f, r0	; 63
    b744:	ed bf       	out	0x3d, r30	; 61
    b746:	c3 01       	movw	r24, r6
    b748:	0e 94 db 4a 	call	0x95b6	; 0x95b6 <No_limit_switch>
	//Limpia el BiT de Position Capture Indicator en el Status Register
	PMDResetEventStatus(&hAxis[Axis],~PMDEventCaptureReceivedMask);	
    b74c:	c2 01       	movw	r24, r4
    b74e:	67 ef       	ldi	r22, 0xF7	; 247
    b750:	7f ef       	ldi	r23, 0xFF	; 255
    b752:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
	//La senal de HOME sera utilizada como Disparo para la Captura de la Posicion
	PMDSetCaptureSource(&hAxis[Axis],PMDCaptureSourceHome);
    b756:	c2 01       	movw	r24, r4
    b758:	61 e0       	ldi	r22, 0x01	; 1
    b75a:	70 e0       	ldi	r23, 0x00	; 0
    b75c:	0e 94 63 7a 	call	0xf4c6	; 0xf4c6 <PMDSetCaptureSource>
	//Leyendo el registro de Captura de Posicion Causa "rearmar" 
	//el disparador con el fin de permitir mas capturas.
	PMDGetCaptureValue(&hAxis[Axis],&temp); 
    b760:	c2 01       	movw	r24, r4
    b762:	be 01       	movw	r22, r28
    b764:	6b 5f       	subi	r22, 0xFB	; 251
    b766:	7f 4f       	sbci	r23, 0xFF	; 255
    b768:	0e 94 24 7b 	call	0xf648	; 0xf648 <PMDGetCaptureValue>
	
	//#ifdef DEBUGROBOTICS_HOME
	printf("search_home_negative=> Ejecutado No_limit_switch\n");
    b76c:	8e e1       	ldi	r24, 0x1E	; 30
    b76e:	92 e5       	ldi	r25, 0x52	; 82
    b770:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	printf("search_home_negative=> Busqueda home en dir neg. del eje %s.\n ",AxisName(Axis));
    b774:	c3 01       	movw	r24, r6
    b776:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    b77a:	00 d0       	rcall	.+0      	; 0xb77c <search_home_negative+0xe4>
    b77c:	00 d0       	rcall	.+0      	; 0xb77e <search_home_negative+0xe6>
    b77e:	2f e4       	ldi	r18, 0x4F	; 79
    b780:	32 e5       	ldi	r19, 0x52	; 82
    b782:	ad b7       	in	r26, 0x3d	; 61
    b784:	be b7       	in	r27, 0x3e	; 62
    b786:	12 96       	adiw	r26, 0x02	; 2
    b788:	3c 93       	st	X, r19
    b78a:	2e 93       	st	-X, r18
    b78c:	11 97       	sbiw	r26, 0x01	; 1
    b78e:	14 96       	adiw	r26, 0x04	; 4
    b790:	9c 93       	st	X, r25
    b792:	8e 93       	st	-X, r24
    b794:	13 97       	sbiw	r26, 0x03	; 3
    b796:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	//#endif

	
	switch (Axis)
    b79a:	0f 90       	pop	r0
    b79c:	0f 90       	pop	r0
    b79e:	0f 90       	pop	r0
    b7a0:	0f 90       	pop	r0
    b7a2:	b2 e0       	ldi	r27, 0x02	; 2
    b7a4:	6b 16       	cp	r6, r27
    b7a6:	71 04       	cpc	r7, r1
    b7a8:	09 f4       	brne	.+2      	; 0xb7ac <search_home_negative+0x114>
    b7aa:	c1 c0       	rjmp	.+386    	; 0xb92e <search_home_negative+0x296>
    b7ac:	e3 e0       	ldi	r30, 0x03	; 3
    b7ae:	6e 16       	cp	r6, r30
    b7b0:	71 04       	cpc	r7, r1
    b7b2:	34 f4       	brge	.+12     	; 0xb7c0 <search_home_negative+0x128>
    b7b4:	f1 e0       	ldi	r31, 0x01	; 1
    b7b6:	6f 16       	cp	r6, r31
    b7b8:	71 04       	cpc	r7, r1
    b7ba:	09 f0       	breq	.+2      	; 0xb7be <search_home_negative+0x126>
    b7bc:	9d c1       	rjmp	.+826    	; 0xbaf8 <search_home_negative+0x460>
    b7be:	0b c0       	rjmp	.+22     	; 0xb7d6 <search_home_negative+0x13e>
    b7c0:	83 e0       	ldi	r24, 0x03	; 3
    b7c2:	68 16       	cp	r6, r24
    b7c4:	71 04       	cpc	r7, r1
    b7c6:	09 f4       	brne	.+2      	; 0xb7ca <search_home_negative+0x132>
    b7c8:	2f c1       	rjmp	.+606    	; 0xba28 <search_home_negative+0x390>
    b7ca:	94 e0       	ldi	r25, 0x04	; 4
    b7cc:	69 16       	cp	r6, r25
    b7ce:	71 04       	cpc	r7, r1
    b7d0:	09 f0       	breq	.+2      	; 0xb7d4 <search_home_negative+0x13c>
    b7d2:	92 c1       	rjmp	.+804    	; 0xbaf8 <search_home_negative+0x460>
    b7d4:	58 c1       	rjmp	.+688    	; 0xba86 <search_home_negative+0x3ee>
	{
		
		case (AxisShoulder):
		{
			printf("caso AxisShoulder\n");
    b7d6:	8e e8       	ldi	r24, 0x8E	; 142
    b7d8:	92 e5       	ldi	r25, 0x52	; 82
    b7da:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
			//No codo depende de nadie va directo...  
			//(Siempre entra aqui cuando se usa con una trayectoria )..
			//NO OLVIDAR CONFIGURAR LOS DEMAS COMO VELOCIDAD CONTINUA 
			mov_axis(Axis,-INF, 
    b7de:	00 91 b9 75 	lds	r16, 0x75B9
    b7e2:	10 91 ba 75 	lds	r17, 0x75BA
    b7e6:	20 91 bb 75 	lds	r18, 0x75BB
    b7ea:	30 91 bc 75 	lds	r19, 0x75BC
    b7ee:	c0 90 bd 75 	lds	r12, 0x75BD
    b7f2:	d0 90 be 75 	lds	r13, 0x75BE
    b7f6:	e0 90 bf 75 	lds	r14, 0x75BF
    b7fa:	f0 90 c0 75 	lds	r15, 0x75C0
    b7fe:	81 e0       	ldi	r24, 0x01	; 1
    b800:	90 e0       	ldi	r25, 0x00	; 0
    b802:	41 e0       	ldi	r20, 0x01	; 1
    b804:	50 e0       	ldi	r21, 0x00	; 0
    b806:	60 e0       	ldi	r22, 0x00	; 0
    b808:	70 e8       	ldi	r23, 0x80	; 128
    b80a:	bf ee       	ldi	r27, 0xEF	; 239
    b80c:	ab 2e       	mov	r10, r27
    b80e:	bf ef       	ldi	r27, 0xFF	; 255
    b810:	bb 2e       	mov	r11, r27
    b812:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
			100,
			no_update,EN_CALIBRACION_PROCESOHOME );
			*/
			
			//Configurando los registros de codo, codo esta invertido invertido.
			mov_correlacionado_HOME(AxisElbow,-INF,
    b816:	00 d0       	rcall	.+0      	; 0xb818 <search_home_negative+0x180>
    b818:	00 d0       	rcall	.+0      	; 0xb81a <search_home_negative+0x182>
    b81a:	00 91 b9 75 	lds	r16, 0x75B9
    b81e:	10 91 ba 75 	lds	r17, 0x75BA
    b822:	20 91 bb 75 	lds	r18, 0x75BB
    b826:	30 91 bc 75 	lds	r19, 0x75BC
    b82a:	a0 90 bd 75 	lds	r10, 0x75BD
    b82e:	b0 90 be 75 	lds	r11, 0x75BE
    b832:	c0 90 bf 75 	lds	r12, 0x75BF
    b836:	d0 90 c0 75 	lds	r13, 0x75C0
    b83a:	8d e1       	ldi	r24, 0x1D	; 29
    b83c:	9a e5       	ldi	r25, 0x5A	; 90
    b83e:	a4 e5       	ldi	r26, 0x54	; 84
    b840:	bf e3       	ldi	r27, 0x3F	; 63
    b842:	ed b7       	in	r30, 0x3d	; 61
    b844:	fe b7       	in	r31, 0x3e	; 62
    b846:	81 83       	std	Z+1, r24	; 0x01
    b848:	92 83       	std	Z+2, r25	; 0x02
    b84a:	a3 83       	std	Z+3, r26	; 0x03
    b84c:	b4 83       	std	Z+4, r27	; 0x04
    b84e:	82 e0       	ldi	r24, 0x02	; 2
    b850:	90 e0       	ldi	r25, 0x00	; 0
    b852:	41 e0       	ldi	r20, 0x01	; 1
    b854:	50 e0       	ldi	r21, 0x00	; 0
    b856:	60 e0       	ldi	r22, 0x00	; 0
    b858:	70 e8       	ldi	r23, 0x80	; 128
    b85a:	a9 e0       	ldi	r26, 0x09	; 9
    b85c:	ea 2e       	mov	r14, r26
    b85e:	f1 2c       	mov	r15, r1
    b860:	ec 0e       	add	r14, r28
    b862:	fd 1e       	adc	r15, r29
    b864:	f1 e1       	ldi	r31, 0x11	; 17
    b866:	8f 2e       	mov	r8, r31
    b868:	91 2c       	mov	r9, r1
    b86a:	8c 0e       	add	r8, r28
    b86c:	9d 1e       	adc	r9, r29
    b86e:	0e 94 d8 56 	call	0xadb0	; 0xadb0 <mov_correlacionado_HOME>
												hAxis[Axis].axisSettings.homeVelocity,
												&Velocidad_eje2_temp,hAxis[Axis].axisSettings.homeAcceleration,
												&Aceleracion_eje2_temp,CORRELACION_HOMBRO_CODO);		
			//Configurando los registros de pitch, el pitch esta en el mismo sentido que el codo.
			mov_correlacionado_HOME(AxisPitch,-INF,
    b872:	09 85       	ldd	r16, Y+9	; 0x09
    b874:	1a 85       	ldd	r17, Y+10	; 0x0a
    b876:	2b 85       	ldd	r18, Y+11	; 0x0b
    b878:	3c 85       	ldd	r19, Y+12	; 0x0c
    b87a:	a9 88       	ldd	r10, Y+17	; 0x11
    b87c:	ba 88       	ldd	r11, Y+18	; 0x12
    b87e:	cb 88       	ldd	r12, Y+19	; 0x13
    b880:	dc 88       	ldd	r13, Y+20	; 0x14
    b882:	89 ec       	ldi	r24, 0xC9	; 201
    b884:	9e e8       	ldi	r25, 0x8E	; 142
    b886:	ad e8       	ldi	r26, 0x8D	; 141
    b888:	bc e3       	ldi	r27, 0x3C	; 60
    b88a:	ed b7       	in	r30, 0x3d	; 61
    b88c:	fe b7       	in	r31, 0x3e	; 62
    b88e:	81 83       	std	Z+1, r24	; 0x01
    b890:	92 83       	std	Z+2, r25	; 0x02
    b892:	a3 83       	std	Z+3, r26	; 0x03
    b894:	b4 83       	std	Z+4, r27	; 0x04
    b896:	83 e0       	ldi	r24, 0x03	; 3
    b898:	90 e0       	ldi	r25, 0x00	; 0
    b89a:	41 e0       	ldi	r20, 0x01	; 1
    b89c:	50 e0       	ldi	r21, 0x00	; 0
    b89e:	60 e0       	ldi	r22, 0x00	; 0
    b8a0:	70 e8       	ldi	r23, 0x80	; 128
    b8a2:	ed e0       	ldi	r30, 0x0D	; 13
    b8a4:	ee 2e       	mov	r14, r30
    b8a6:	f1 2c       	mov	r15, r1
    b8a8:	ec 0e       	add	r14, r28
    b8aa:	fd 1e       	adc	r15, r29
    b8ac:	b5 e1       	ldi	r27, 0x15	; 21
    b8ae:	8b 2e       	mov	r8, r27
    b8b0:	91 2c       	mov	r9, r1
    b8b2:	8c 0e       	add	r8, r28
    b8b4:	9d 1e       	adc	r9, r29
    b8b6:	0e 94 d8 56 	call	0xadb0	; 0xadb0 <mov_correlacionado_HOME>
												Velocidad_eje2_temp,
												&Velocidad_final_pitch,Aceleracion_eje2_temp,
												&Aceleracion_final_pitch,
												CORRELACION_CODO_PITCH);
			
			printf("search_home_negative=> Update AxisShoulder \n ");
    b8ba:	0f 90       	pop	r0
    b8bc:	0f 90       	pop	r0
    b8be:	80 ea       	ldi	r24, 0xA0	; 160
    b8c0:	92 e5       	ldi	r25, 0x52	; 82
    b8c2:	ad b7       	in	r26, 0x3d	; 61
    b8c4:	be b7       	in	r27, 0x3e	; 62
    b8c6:	12 96       	adiw	r26, 0x02	; 2
    b8c8:	9c 93       	st	X, r25
    b8ca:	8e 93       	st	-X, r24
    b8cc:	11 97       	sbiw	r26, 0x01	; 1
    b8ce:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisShoulder]);
    b8d2:	0f 90       	pop	r0
    b8d4:	0f 90       	pop	r0
    b8d6:	89 e7       	ldi	r24, 0x79	; 121
    b8d8:	95 e7       	ldi	r25, 0x75	; 117
    b8da:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			printf("search_home_negative=> Update AxisElbow \n ");
    b8de:	00 d0       	rcall	.+0      	; 0xb8e0 <search_home_negative+0x248>
    b8e0:	8e ec       	ldi	r24, 0xCE	; 206
    b8e2:	92 e5       	ldi	r25, 0x52	; 82
    b8e4:	ed b7       	in	r30, 0x3d	; 61
    b8e6:	fe b7       	in	r31, 0x3e	; 62
    b8e8:	92 83       	std	Z+2, r25	; 0x02
    b8ea:	81 83       	std	Z+1, r24	; 0x01
    b8ec:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisElbow]);	
    b8f0:	0f 90       	pop	r0
    b8f2:	0f 90       	pop	r0
    b8f4:	89 ed       	ldi	r24, 0xD9	; 217
    b8f6:	95 e7       	ldi	r25, 0x75	; 117
    b8f8:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			printf("search_home_negative=> Update AxisPitch \n ");
    b8fc:	00 d0       	rcall	.+0      	; 0xb8fe <search_home_negative+0x266>
    b8fe:	89 ef       	ldi	r24, 0xF9	; 249
    b900:	92 e5       	ldi	r25, 0x52	; 82
    b902:	ad b7       	in	r26, 0x3d	; 61
    b904:	be b7       	in	r27, 0x3e	; 62
    b906:	12 96       	adiw	r26, 0x02	; 2
    b908:	9c 93       	st	X, r25
    b90a:	8e 93       	st	-X, r24
    b90c:	11 97       	sbiw	r26, 0x01	; 1
    b90e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisPitch]);	
    b912:	0f 90       	pop	r0
    b914:	0f 90       	pop	r0
    b916:	89 e3       	ldi	r24, 0x39	; 57
    b918:	96 e7       	ldi	r25, 0x76	; 118
    b91a:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			printf("search_home_negative=> Update AxisRoll \n ");
    b91e:	00 d0       	rcall	.+0      	; 0xb920 <search_home_negative+0x288>
    b920:	84 e2       	ldi	r24, 0x24	; 36
    b922:	93 e5       	ldi	r25, 0x53	; 83
    b924:	ed b7       	in	r30, 0x3d	; 61
    b926:	fe b7       	in	r31, 0x3e	; 62
    b928:	92 83       	std	Z+2, r25	; 0x02
    b92a:	81 83       	std	Z+1, r24	; 0x01
    b92c:	74 c0       	rjmp	.+232    	; 0xba16 <search_home_negative+0x37e>
			PMDUpdate(&hAxis[AxisRoll]);
		}
		break;
		case (AxisElbow):
		{
			mov_axis(Axis,-INF, 
    b92e:	00 91 19 76 	lds	r16, 0x7619
    b932:	10 91 1a 76 	lds	r17, 0x761A
    b936:	20 91 1b 76 	lds	r18, 0x761B
    b93a:	30 91 1c 76 	lds	r19, 0x761C
    b93e:	c0 90 1d 76 	lds	r12, 0x761D
    b942:	d0 90 1e 76 	lds	r13, 0x761E
    b946:	e0 90 1f 76 	lds	r14, 0x761F
    b94a:	f0 90 20 76 	lds	r15, 0x7620
    b94e:	82 e0       	ldi	r24, 0x02	; 2
    b950:	90 e0       	ldi	r25, 0x00	; 0
    b952:	41 e0       	ldi	r20, 0x01	; 1
    b954:	50 e0       	ldi	r21, 0x00	; 0
    b956:	60 e0       	ldi	r22, 0x00	; 0
    b958:	70 e8       	ldi	r23, 0x80	; 128
    b95a:	af ee       	ldi	r26, 0xEF	; 239
    b95c:	aa 2e       	mov	r10, r26
    b95e:	af ef       	ldi	r26, 0xFF	; 255
    b960:	ba 2e       	mov	r11, r26
    b962:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
			300,
			no_update,EN_CALIBRACION_PROCESOHOME );
			
			*/
			
			mov_correlacionado_HOME(AxisPitch,-INF,
    b966:	00 d0       	rcall	.+0      	; 0xb968 <search_home_negative+0x2d0>
    b968:	00 d0       	rcall	.+0      	; 0xb96a <search_home_negative+0x2d2>
    b96a:	00 91 19 76 	lds	r16, 0x7619
    b96e:	10 91 1a 76 	lds	r17, 0x761A
    b972:	20 91 1b 76 	lds	r18, 0x761B
    b976:	30 91 1c 76 	lds	r19, 0x761C
    b97a:	a0 90 1d 76 	lds	r10, 0x761D
    b97e:	b0 90 1e 76 	lds	r11, 0x761E
    b982:	c0 90 1f 76 	lds	r12, 0x761F
    b986:	d0 90 20 76 	lds	r13, 0x7620
    b98a:	89 ec       	ldi	r24, 0xC9	; 201
    b98c:	9e e8       	ldi	r25, 0x8E	; 142
    b98e:	ad e8       	ldi	r26, 0x8D	; 141
    b990:	bc e3       	ldi	r27, 0x3C	; 60
    b992:	ed b7       	in	r30, 0x3d	; 61
    b994:	fe b7       	in	r31, 0x3e	; 62
    b996:	81 83       	std	Z+1, r24	; 0x01
    b998:	92 83       	std	Z+2, r25	; 0x02
    b99a:	a3 83       	std	Z+3, r26	; 0x03
    b99c:	b4 83       	std	Z+4, r27	; 0x04
    b99e:	83 e0       	ldi	r24, 0x03	; 3
    b9a0:	90 e0       	ldi	r25, 0x00	; 0
    b9a2:	41 e0       	ldi	r20, 0x01	; 1
    b9a4:	50 e0       	ldi	r21, 0x00	; 0
    b9a6:	60 e0       	ldi	r22, 0x00	; 0
    b9a8:	70 e8       	ldi	r23, 0x80	; 128
    b9aa:	fd e0       	ldi	r31, 0x0D	; 13
    b9ac:	ef 2e       	mov	r14, r31
    b9ae:	f1 2c       	mov	r15, r1
    b9b0:	ec 0e       	add	r14, r28
    b9b2:	fd 1e       	adc	r15, r29
    b9b4:	e5 e1       	ldi	r30, 0x15	; 21
    b9b6:	8e 2e       	mov	r8, r30
    b9b8:	91 2c       	mov	r9, r1
    b9ba:	8c 0e       	add	r8, r28
    b9bc:	9d 1e       	adc	r9, r29
    b9be:	0e 94 d8 56 	call	0xadb0	; 0xadb0 <mov_correlacionado_HOME>
												hAxis[Axis].axisSettings.homeVelocity ,
												&Velocidad_final_pitch,hAxis[Axis].axisSettings.homeAcceleration,
												&Aceleracion_final_pitch,
												CORRELACION_CODO_PITCH);	
			printf("search_home_negative=> Update AxisElbow \n ");
    b9c2:	0f 90       	pop	r0
    b9c4:	0f 90       	pop	r0
    b9c6:	8e ec       	ldi	r24, 0xCE	; 206
    b9c8:	92 e5       	ldi	r25, 0x52	; 82
    b9ca:	ad b7       	in	r26, 0x3d	; 61
    b9cc:	be b7       	in	r27, 0x3e	; 62
    b9ce:	12 96       	adiw	r26, 0x02	; 2
    b9d0:	9c 93       	st	X, r25
    b9d2:	8e 93       	st	-X, r24
    b9d4:	11 97       	sbiw	r26, 0x01	; 1
    b9d6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisElbow]);
    b9da:	0f 90       	pop	r0
    b9dc:	0f 90       	pop	r0
    b9de:	89 ed       	ldi	r24, 0xD9	; 217
    b9e0:	95 e7       	ldi	r25, 0x75	; 117
    b9e2:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			printf("search_home_negative=> Update AxisPitch \n ");
    b9e6:	00 d0       	rcall	.+0      	; 0xb9e8 <search_home_negative+0x350>
    b9e8:	89 ef       	ldi	r24, 0xF9	; 249
    b9ea:	92 e5       	ldi	r25, 0x52	; 82
    b9ec:	ed b7       	in	r30, 0x3d	; 61
    b9ee:	fe b7       	in	r31, 0x3e	; 62
    b9f0:	92 83       	std	Z+2, r25	; 0x02
    b9f2:	81 83       	std	Z+1, r24	; 0x01
    b9f4:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisPitch]);	
    b9f8:	0f 90       	pop	r0
    b9fa:	0f 90       	pop	r0
    b9fc:	89 e3       	ldi	r24, 0x39	; 57
    b9fe:	96 e7       	ldi	r25, 0x76	; 118
    ba00:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			printf("search_home_negative=> Update AxisRoll \n ");
    ba04:	00 d0       	rcall	.+0      	; 0xba06 <search_home_negative+0x36e>
    ba06:	84 e2       	ldi	r24, 0x24	; 36
    ba08:	93 e5       	ldi	r25, 0x53	; 83
    ba0a:	ad b7       	in	r26, 0x3d	; 61
    ba0c:	be b7       	in	r27, 0x3e	; 62
    ba0e:	12 96       	adiw	r26, 0x02	; 2
    ba10:	9c 93       	st	X, r25
    ba12:	8e 93       	st	-X, r24
    ba14:	11 97       	sbiw	r26, 0x01	; 1
    ba16:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			PMDUpdate(&hAxis[AxisRoll]);
    ba1a:	0f 90       	pop	r0
    ba1c:	0f 90       	pop	r0
    ba1e:	89 e9       	ldi	r24, 0x99	; 153
    ba20:	96 e7       	ldi	r25, 0x76	; 118
    ba22:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
    ba26:	88 c0       	rjmp	.+272    	; 0xbb38 <search_home_negative+0x4a0>
		}
		break;					
		case (AxisPitch):
		{
			pitch(-INF, hAxis[Axis].axisSettings.homeVelocity,
    ba28:	20 91 79 76 	lds	r18, 0x7679
    ba2c:	30 91 7a 76 	lds	r19, 0x767A
    ba30:	40 91 7b 76 	lds	r20, 0x767B
    ba34:	50 91 7c 76 	lds	r21, 0x767C
    ba38:	e0 90 7d 76 	lds	r14, 0x767D
    ba3c:	f0 90 7e 76 	lds	r15, 0x767E
    ba40:	00 91 7f 76 	lds	r16, 0x767F
    ba44:	10 91 80 76 	lds	r17, 0x7680
    ba48:	61 e0       	ldi	r22, 0x01	; 1
    ba4a:	70 e0       	ldi	r23, 0x00	; 0
    ba4c:	80 e0       	ldi	r24, 0x00	; 0
    ba4e:	90 e8       	ldi	r25, 0x80	; 128
    ba50:	b0 ef       	ldi	r27, 0xF0	; 240
    ba52:	cb 2e       	mov	r12, r27
    ba54:	bf ef       	ldi	r27, 0xFF	; 255
    ba56:	db 2e       	mov	r13, r27
    ba58:	a4 e0       	ldi	r26, 0x04	; 4
    ba5a:	aa 2e       	mov	r10, r26
    ba5c:	b1 2c       	mov	r11, r1
    ba5e:	0e 94 78 52 	call	0xa4f0	; 0xa4f0 <pitch>
			hAxis[Axis].axisSettings.homeAcceleration,update,INICIANDO_HOME_PITCH_ROLL );
			
			
			#ifdef DEBUGROBOTICS_HOME
			PMDGetHostIOError(&hAxis[AxisRoll], &test);
    ba62:	89 e9       	ldi	r24, 0x99	; 153
    ba64:	96 e7       	ldi	r25, 0x76	; 118
    ba66:	b4 01       	movw	r22, r8
    ba68:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
			printf("search_home_negative=> HostIOError = %x del eje ROLL despues del update.\n ",test);
    ba6c:	00 d0       	rcall	.+0      	; 0xba6e <search_home_negative+0x3d6>
    ba6e:	00 d0       	rcall	.+0      	; 0xba70 <search_home_negative+0x3d8>
    ba70:	8e e4       	ldi	r24, 0x4E	; 78
    ba72:	93 e5       	ldi	r25, 0x53	; 83
    ba74:	ed b7       	in	r30, 0x3d	; 61
    ba76:	fe b7       	in	r31, 0x3e	; 62
    ba78:	92 83       	std	Z+2, r25	; 0x02
    ba7a:	81 83       	std	Z+1, r24	; 0x01
    ba7c:	8b 81       	ldd	r24, Y+3	; 0x03
    ba7e:	9c 81       	ldd	r25, Y+4	; 0x04
    ba80:	94 83       	std	Z+4, r25	; 0x04
    ba82:	83 83       	std	Z+3, r24	; 0x03
    ba84:	32 c0       	rjmp	.+100    	; 0xbaea <search_home_negative+0x452>
			#endif
		}
	    break;	
		case (AxisRoll):		
		{
			roll(-INF, hAxis[Axis].axisSettings.homeVelocity,
    ba86:	20 91 d9 76 	lds	r18, 0x76D9
    ba8a:	30 91 da 76 	lds	r19, 0x76DA
    ba8e:	40 91 db 76 	lds	r20, 0x76DB
    ba92:	50 91 dc 76 	lds	r21, 0x76DC
    ba96:	e0 90 dd 76 	lds	r14, 0x76DD
    ba9a:	f0 90 de 76 	lds	r15, 0x76DE
    ba9e:	00 91 df 76 	lds	r16, 0x76DF
    baa2:	10 91 e0 76 	lds	r17, 0x76E0
    baa6:	61 e0       	ldi	r22, 0x01	; 1
    baa8:	70 e0       	ldi	r23, 0x00	; 0
    baaa:	80 e0       	ldi	r24, 0x00	; 0
    baac:	90 e8       	ldi	r25, 0x80	; 128
    baae:	f0 ef       	ldi	r31, 0xF0	; 240
    bab0:	cf 2e       	mov	r12, r31
    bab2:	ff ef       	ldi	r31, 0xFF	; 255
    bab4:	df 2e       	mov	r13, r31
    bab6:	e4 e0       	ldi	r30, 0x04	; 4
    bab8:	ae 2e       	mov	r10, r30
    baba:	b1 2c       	mov	r11, r1
    babc:	0e 94 1b 50 	call	0xa036	; 0xa036 <roll>
			hAxis[Axis].axisSettings.homeAcceleration,update,INICIANDO_HOME_PITCH_ROLL );
			
			
			#ifdef DEBUGROBOTICS_HOME
			PMDGetHostIOError(&hAxis[AxisPitch], &test);
    bac0:	89 e3       	ldi	r24, 0x39	; 57
    bac2:	96 e7       	ldi	r25, 0x76	; 118
    bac4:	b4 01       	movw	r22, r8
    bac6:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
			printf("search_home_negative=> HostIOError = %x del eje PITCH despues del update.\n ",test);
    baca:	00 d0       	rcall	.+0      	; 0xbacc <search_home_negative+0x434>
    bacc:	00 d0       	rcall	.+0      	; 0xbace <search_home_negative+0x436>
    bace:	89 e9       	ldi	r24, 0x99	; 153
    bad0:	93 e5       	ldi	r25, 0x53	; 83
    bad2:	ad b7       	in	r26, 0x3d	; 61
    bad4:	be b7       	in	r27, 0x3e	; 62
    bad6:	12 96       	adiw	r26, 0x02	; 2
    bad8:	9c 93       	st	X, r25
    bada:	8e 93       	st	-X, r24
    badc:	11 97       	sbiw	r26, 0x01	; 1
    bade:	8b 81       	ldd	r24, Y+3	; 0x03
    bae0:	9c 81       	ldd	r25, Y+4	; 0x04
    bae2:	14 96       	adiw	r26, 0x04	; 4
    bae4:	9c 93       	st	X, r25
    bae6:	8e 93       	st	-X, r24
    bae8:	13 97       	sbiw	r26, 0x03	; 3
    baea:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    baee:	0f 90       	pop	r0
    baf0:	0f 90       	pop	r0
    baf2:	0f 90       	pop	r0
    baf4:	0f 90       	pop	r0
    baf6:	20 c0       	rjmp	.+64     	; 0xbb38 <search_home_negative+0x4a0>
			#endif
		}
	    break;
		//Solo cintura
		default:
			mov_axis(Axis,-INF,hAxis[Axis].axisSettings.homeVelocity,
    baf8:	80 e6       	ldi	r24, 0x60	; 96
    bafa:	90 e0       	ldi	r25, 0x00	; 0
    bafc:	68 9e       	mul	r6, r24
    bafe:	f0 01       	movw	r30, r0
    bb00:	69 9e       	mul	r6, r25
    bb02:	f0 0d       	add	r31, r0
    bb04:	78 9e       	mul	r7, r24
    bb06:	f0 0d       	add	r31, r0
    bb08:	11 24       	eor	r1, r1
    bb0a:	e7 5e       	subi	r30, 0xE7	; 231
    bb0c:	fa 48       	sbci	r31, 0x8A	; 138
    bb0e:	e0 5c       	subi	r30, 0xC0	; 192
    bb10:	ff 4f       	sbci	r31, 0xFF	; 255
    bb12:	01 91       	ld	r16, Z+
    bb14:	11 91       	ld	r17, Z+
    bb16:	21 91       	ld	r18, Z+
    bb18:	31 91       	ld	r19, Z+
    bb1a:	c0 80       	ld	r12, Z
    bb1c:	d1 80       	ldd	r13, Z+1	; 0x01
    bb1e:	e2 80       	ldd	r14, Z+2	; 0x02
    bb20:	f3 80       	ldd	r15, Z+3	; 0x03
    bb22:	c3 01       	movw	r24, r6
    bb24:	41 e0       	ldi	r20, 0x01	; 1
    bb26:	50 e0       	ldi	r21, 0x00	; 0
    bb28:	60 e0       	ldi	r22, 0x00	; 0
    bb2a:	70 e8       	ldi	r23, 0x80	; 128
    bb2c:	b0 ef       	ldi	r27, 0xF0	; 240
    bb2e:	ab 2e       	mov	r10, r27
    bb30:	bf ef       	ldi	r27, 0xFF	; 255
    bb32:	bb 2e       	mov	r11, r27
    bb34:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
	    break;
	}
	
	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    bb38:	c2 01       	movw	r24, r4
    bb3a:	be 01       	movw	r22, r28
    bb3c:	6d 5f       	subi	r22, 0xFD	; 253
    bb3e:	7f 4f       	sbci	r23, 0xFF	; 255
    bb40:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
	printf("search_home_negative=> HostIOError = %x del eje %s despues del Update.\n ",test,AxisName(Axis));
    bb44:	0b 81       	ldd	r16, Y+3	; 0x03
    bb46:	1c 81       	ldd	r17, Y+4	; 0x04
    bb48:	c3 01       	movw	r24, r6
    bb4a:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    bb4e:	00 d0       	rcall	.+0      	; 0xbb50 <search_home_negative+0x4b8>
    bb50:	00 d0       	rcall	.+0      	; 0xbb52 <search_home_negative+0x4ba>
    bb52:	00 d0       	rcall	.+0      	; 0xbb54 <search_home_negative+0x4bc>
    bb54:	ed b7       	in	r30, 0x3d	; 61
    bb56:	fe b7       	in	r31, 0x3e	; 62
    bb58:	31 96       	adiw	r30, 0x01	; 1
    bb5a:	25 ee       	ldi	r18, 0xE5	; 229
    bb5c:	33 e5       	ldi	r19, 0x53	; 83
    bb5e:	ad b7       	in	r26, 0x3d	; 61
    bb60:	be b7       	in	r27, 0x3e	; 62
    bb62:	12 96       	adiw	r26, 0x02	; 2
    bb64:	3c 93       	st	X, r19
    bb66:	2e 93       	st	-X, r18
    bb68:	11 97       	sbiw	r26, 0x01	; 1
    bb6a:	13 83       	std	Z+3, r17	; 0x03
    bb6c:	02 83       	std	Z+2, r16	; 0x02
    bb6e:	95 83       	std	Z+5, r25	; 0x05
    bb70:	84 83       	std	Z+4, r24	; 0x04
    bb72:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("search_home_negative=> Iniciando busqueda de home en el sentido negativo.\n");	
    bb76:	ed b7       	in	r30, 0x3d	; 61
    bb78:	fe b7       	in	r31, 0x3e	; 62
    bb7a:	36 96       	adiw	r30, 0x06	; 6
    bb7c:	0f b6       	in	r0, 0x3f	; 63
    bb7e:	f8 94       	cli
    bb80:	fe bf       	out	0x3e, r31	; 62
    bb82:	0f be       	out	0x3f, r0	; 63
    bb84:	ed bf       	out	0x3d, r30	; 61
    bb86:	8e e2       	ldi	r24, 0x2E	; 46
    bb88:	94 e5       	ldi	r25, 0x54	; 84
    bb8a:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	#endif

	do 
	{ 
		PMDGetEventStatus(&hAxis[Axis],&status);            
    bb8e:	4e 01       	movw	r8, r28
    bb90:	08 94       	sec
    bb92:	81 1c       	adc	r8, r1
    bb94:	91 1c       	adc	r9, r1
		
		if((status & PMDEventCaptureReceivedMask) != 0) 
		{   
			#ifdef DEBUGROBOTICS_HOME
			printf("search_home_negative=>  Captura de HOME realizada. \n ");			
    bb96:	a8 e7       	ldi	r26, 0x78	; 120
    bb98:	aa 2e       	mov	r10, r26
    bb9a:	a4 e5       	ldi	r26, 0x54	; 84
    bb9c:	ba 2e       	mov	r11, r26
						PMDUpdate(&hAxis[AxisPitch]);
						
					case (AxisPitch):
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
						PMDUpdate(&hAxis[AxisRoll]);
				    break;
    bb9e:	08 94       	sec
    bba0:	61 1c       	adc	r6, r1
    bba2:	71 1c       	adc	r7, r1
    bba4:	80 e6       	ldi	r24, 0x60	; 96
    bba6:	90 e0       	ldi	r25, 0x00	; 0
    bba8:	68 9e       	mul	r6, r24
    bbaa:	60 01       	movw	r12, r0
    bbac:	69 9e       	mul	r6, r25
    bbae:	d0 0c       	add	r13, r0
    bbb0:	78 9e       	mul	r7, r24
    bbb2:	d0 0c       	add	r13, r0
    bbb4:	11 24       	eor	r1, r1
    bbb6:	08 94       	sec
    bbb8:	61 08       	sbc	r6, r1
    bbba:	71 08       	sbc	r7, r1
    bbbc:	89 e1       	ldi	r24, 0x19	; 25
    bbbe:	95 e7       	ldi	r25, 0x75	; 117
    bbc0:	c8 0e       	add	r12, r24
    bbc2:	d9 1e       	adc	r13, r25
	printf("search_home_negative=> Iniciando busqueda de home en el sentido negativo.\n");	
	#endif

	do 
	{ 
		PMDGetEventStatus(&hAxis[Axis],&status);            
    bbc4:	c2 01       	movw	r24, r4
    bbc6:	b4 01       	movw	r22, r8
    bbc8:	0e 94 75 78 	call	0xf0ea	; 0xf0ea <PMDGetEventStatus>
		
		if((status & PMDEventCaptureReceivedMask) != 0) 
    bbcc:	89 81       	ldd	r24, Y+1	; 0x01
    bbce:	83 ff       	sbrs	r24, 3
    bbd0:	5f c0       	rjmp	.+190    	; 0xbc90 <search_home_negative+0x5f8>
		{   
			#ifdef DEBUGROBOTICS_HOME
			printf("search_home_negative=>  Captura de HOME realizada. \n ");			
    bbd2:	00 d0       	rcall	.+0      	; 0xbbd4 <search_home_negative+0x53c>
    bbd4:	ad b7       	in	r26, 0x3d	; 61
    bbd6:	be b7       	in	r27, 0x3e	; 62
    bbd8:	12 96       	adiw	r26, 0x02	; 2
    bbda:	bc 92       	st	X, r11
    bbdc:	ae 92       	st	-X, r10
    bbde:	11 97       	sbiw	r26, 0x01	; 1
    bbe0:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			#endif
			PMDGetCaptureValue(&hAxis[Axis],home);
    bbe4:	0f 90       	pop	r0
    bbe6:	0f 90       	pop	r0
    bbe8:	c2 01       	movw	r24, r4
    bbea:	b1 01       	movw	r22, r2
    bbec:	0e 94 24 7b 	call	0xf648	; 0xf648 <PMDGetCaptureValue>
			PMDResetEventStatus(&hAxis[Axis],~PMDEventCaptureReceivedMask);
    bbf0:	c2 01       	movw	r24, r4
    bbf2:	67 ef       	ldi	r22, 0xF7	; 247
    bbf4:	7f ef       	ldi	r23, 0xFF	; 255
    bbf6:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
			
			if(rangos==FALSE) //se Hace Caputura de HOME y se quiere detener el motor
    bbfa:	eb 8d       	ldd	r30, Y+27	; 0x1b
    bbfc:	fc 8d       	ldd	r31, Y+28	; 0x1c
    bbfe:	ef 2b       	or	r30, r31
    bc00:	09 f0       	breq	.+2      	; 0xbc04 <search_home_negative+0x56c>
    bc02:	46 c0       	rjmp	.+140    	; 0xbc90 <search_home_negative+0x5f8>
			{	
				
				//se Cambia la variable a 0 para salir del ciclo.
				find_home_out=0;
				//detener suavemente el movimiento	
				switch (Axis)
    bc04:	f3 e0       	ldi	r31, 0x03	; 3
    bc06:	6f 16       	cp	r6, r31
    bc08:	71 04       	cpc	r7, r1
    bc0a:	01 f1       	breq	.+64     	; 0xbc4c <search_home_negative+0x5b4>
    bc0c:	84 e0       	ldi	r24, 0x04	; 4
    bc0e:	68 16       	cp	r6, r24
    bc10:	71 04       	cpc	r7, r1
    bc12:	51 f0       	breq	.+20     	; 0xbc28 <search_home_negative+0x590>
    bc14:	61 14       	cp	r6, r1
    bc16:	71 04       	cpc	r7, r1
    bc18:	31 f5       	brne	.+76     	; 0xbc66 <search_home_negative+0x5ce>
				{
				    case (AxisWaist):
						PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode ); 
    bc1a:	c2 01       	movw	r24, r4
    bc1c:	61 e0       	ldi	r22, 0x01	; 1
    bc1e:	70 e0       	ldi	r23, 0x00	; 0
    bc20:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
						PMDUpdate(&hAxis[Axis]);
    bc24:	c2 01       	movw	r24, r4
    bc26:	1a c0       	rjmp	.+52     	; 0xbc5c <search_home_negative+0x5c4>
				    break;
					case (AxisRoll):
						PMDSetStopMode(&hAxis[Axis], PMDAbruptStopMode ); 
    bc28:	c2 01       	movw	r24, r4
    bc2a:	61 e0       	ldi	r22, 0x01	; 1
    bc2c:	70 e0       	ldi	r23, 0x00	; 0
    bc2e:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
						PMDSetStopMode(&hAxis[AxisPitch], PMDAbruptStopMode ); 
    bc32:	89 e3       	ldi	r24, 0x39	; 57
    bc34:	96 e7       	ldi	r25, 0x76	; 118
    bc36:	61 e0       	ldi	r22, 0x01	; 1
    bc38:	70 e0       	ldi	r23, 0x00	; 0
    bc3a:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
						PMDUpdate(&hAxis[Axis]);
    bc3e:	c2 01       	movw	r24, r4
    bc40:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
						PMDUpdate(&hAxis[AxisPitch]);
    bc44:	89 e3       	ldi	r24, 0x39	; 57
    bc46:	96 e7       	ldi	r25, 0x76	; 118
    bc48:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
						
					case (AxisPitch):
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
    bc4c:	89 e9       	ldi	r24, 0x99	; 153
    bc4e:	96 e7       	ldi	r25, 0x76	; 118
    bc50:	61 e0       	ldi	r22, 0x01	; 1
    bc52:	70 e0       	ldi	r23, 0x00	; 0
    bc54:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
						PMDUpdate(&hAxis[AxisRoll]);
    bc58:	89 e9       	ldi	r24, 0x99	; 153
    bc5a:	96 e7       	ldi	r25, 0x76	; 118
    bc5c:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
    bc60:	20 e0       	ldi	r18, 0x00	; 0
    bc62:	30 e0       	ldi	r19, 0x00	; 0
    bc64:	17 c0       	rjmp	.+46     	; 0xbc94 <search_home_negative+0x5fc>
				    break;
    bc66:	86 01       	movw	r16, r12
    bc68:	73 01       	movw	r14, r6
    bc6a:	0a c0       	rjmp	.+20     	; 0xbc80 <search_home_negative+0x5e8>
				    default:
				    	for(Axis_Update=Axis+1; Axis_Update < DOF; Axis_Update++) 
						{ 
							PMDSetStopMode(&hAxis[Axis_Update], PMDAbruptStopMode ); 
    bc6c:	c8 01       	movw	r24, r16
    bc6e:	61 e0       	ldi	r22, 0x01	; 1
    bc70:	70 e0       	ldi	r23, 0x00	; 0
    bc72:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
							PMDUpdate(&hAxis[Axis_Update]);
    bc76:	c8 01       	movw	r24, r16
    bc78:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
    bc7c:	00 5a       	subi	r16, 0xA0	; 160
    bc7e:	1f 4f       	sbci	r17, 0xFF	; 255
    bc80:	08 94       	sec
    bc82:	e1 1c       	adc	r14, r1
    bc84:	f1 1c       	adc	r15, r1
					case (AxisPitch):
						PMDSetStopMode(&hAxis[AxisRoll], PMDAbruptStopMode ); 
						PMDUpdate(&hAxis[AxisRoll]);
				    break;
				    default:
				    	for(Axis_Update=Axis+1; Axis_Update < DOF; Axis_Update++) 
    bc86:	95 e0       	ldi	r25, 0x05	; 5
    bc88:	e9 16       	cp	r14, r25
    bc8a:	f1 04       	cpc	r15, r1
    bc8c:	7c f3       	brlt	.-34     	; 0xbc6c <search_home_negative+0x5d4>
    bc8e:	e8 cf       	rjmp	.-48     	; 0xbc60 <search_home_negative+0x5c8>
    bc90:	21 e0       	ldi	r18, 0x01	; 1
    bc92:	30 e0       	ldi	r19, 0x00	; 0
		//printf(" Moviendo en direccion negativa. \n ");
			//printf("El Event status register del eje %s es %X \n",AxisName(Axis),status);			
		#endif
		
	}		
	while (((status & PMDEventInNegativeLimitMask) == 0) && (find_home_out==1));	
    bc94:	89 81       	ldd	r24, Y+1	; 0x01
    bc96:	86 fd       	sbrc	r24, 6
    bc98:	04 c0       	rjmp	.+8      	; 0xbca2 <search_home_negative+0x60a>
    bc9a:	21 30       	cpi	r18, 0x01	; 1
    bc9c:	31 05       	cpc	r19, r1
    bc9e:	09 f4       	brne	.+2      	; 0xbca2 <search_home_negative+0x60a>
    bca0:	91 cf       	rjmp	.-222    	; 0xbbc4 <search_home_negative+0x52c>
	
	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetHostIOError(&hAxis[Axis], &test);
    bca2:	c2 01       	movw	r24, r4
    bca4:	be 01       	movw	r22, r28
    bca6:	6d 5f       	subi	r22, 0xFD	; 253
    bca8:	7f 4f       	sbci	r23, 0xFF	; 255
    bcaa:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
	printf("search_home_negative=> Error en el eje %s despues del movimiento %x\n ",AxisName(Axis),test);
    bcae:	c3 01       	movw	r24, r6
    bcb0:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    bcb4:	00 d0       	rcall	.+0      	; 0xbcb6 <search_home_negative+0x61e>
    bcb6:	00 d0       	rcall	.+0      	; 0xbcb8 <search_home_negative+0x620>
    bcb8:	00 d0       	rcall	.+0      	; 0xbcba <search_home_negative+0x622>
    bcba:	ed b7       	in	r30, 0x3d	; 61
    bcbc:	fe b7       	in	r31, 0x3e	; 62
    bcbe:	31 96       	adiw	r30, 0x01	; 1
    bcc0:	2e ea       	ldi	r18, 0xAE	; 174
    bcc2:	34 e5       	ldi	r19, 0x54	; 84
    bcc4:	ad b7       	in	r26, 0x3d	; 61
    bcc6:	be b7       	in	r27, 0x3e	; 62
    bcc8:	12 96       	adiw	r26, 0x02	; 2
    bcca:	3c 93       	st	X, r19
    bccc:	2e 93       	st	-X, r18
    bcce:	11 97       	sbiw	r26, 0x01	; 1
    bcd0:	93 83       	std	Z+3, r25	; 0x03
    bcd2:	82 83       	std	Z+2, r24	; 0x02
    bcd4:	8b 81       	ldd	r24, Y+3	; 0x03
    bcd6:	9c 81       	ldd	r25, Y+4	; 0x04
    bcd8:	95 83       	std	Z+5, r25	; 0x05
    bcda:	84 83       	std	Z+4, r24	; 0x04
    bcdc:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	PMDGetEventStatus(&hAxis[Axis],&status);  
    bce0:	ed b7       	in	r30, 0x3d	; 61
    bce2:	fe b7       	in	r31, 0x3e	; 62
    bce4:	36 96       	adiw	r30, 0x06	; 6
    bce6:	0f b6       	in	r0, 0x3f	; 63
    bce8:	f8 94       	cli
    bcea:	fe bf       	out	0x3e, r31	; 62
    bcec:	0f be       	out	0x3f, r0	; 63
    bcee:	ed bf       	out	0x3d, r30	; 61
    bcf0:	c2 01       	movw	r24, r4
    bcf2:	8e 01       	movw	r16, r28
    bcf4:	0f 5f       	subi	r16, 0xFF	; 255
    bcf6:	1f 4f       	sbci	r17, 0xFF	; 255
    bcf8:	b8 01       	movw	r22, r16
    bcfa:	0e 94 75 78 	call	0xf0ea	; 0xf0ea <PMDGetEventStatus>
	printf("search_home_negative=> El Event status register antes de limpiar del eje %s es %X \n",AxisName(Axis),status);	
    bcfe:	c3 01       	movw	r24, r6
    bd00:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    bd04:	00 d0       	rcall	.+0      	; 0xbd06 <search_home_negative+0x66e>
    bd06:	00 d0       	rcall	.+0      	; 0xbd08 <search_home_negative+0x670>
    bd08:	00 d0       	rcall	.+0      	; 0xbd0a <search_home_negative+0x672>
    bd0a:	ed b7       	in	r30, 0x3d	; 61
    bd0c:	fe b7       	in	r31, 0x3e	; 62
    bd0e:	31 96       	adiw	r30, 0x01	; 1
    bd10:	24 ef       	ldi	r18, 0xF4	; 244
    bd12:	34 e5       	ldi	r19, 0x54	; 84
    bd14:	ad b7       	in	r26, 0x3d	; 61
    bd16:	be b7       	in	r27, 0x3e	; 62
    bd18:	12 96       	adiw	r26, 0x02	; 2
    bd1a:	3c 93       	st	X, r19
    bd1c:	2e 93       	st	-X, r18
    bd1e:	11 97       	sbiw	r26, 0x01	; 1
    bd20:	93 83       	std	Z+3, r25	; 0x03
    bd22:	82 83       	std	Z+2, r24	; 0x02
    bd24:	89 81       	ldd	r24, Y+1	; 0x01
    bd26:	9a 81       	ldd	r25, Y+2	; 0x02
    bd28:	95 83       	std	Z+5, r25	; 0x05
    bd2a:	84 83       	std	Z+4, r24	; 0x04
    bd2c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	

	
	/*Se limpia el Event Status Register, borrando las interrupciones generadas: Evento de Limite
	Negativo y Fin de movimiento*/	
	Reset_Even_Status_Register();
    bd30:	ed b7       	in	r30, 0x3d	; 61
    bd32:	fe b7       	in	r31, 0x3e	; 62
    bd34:	36 96       	adiw	r30, 0x06	; 6
    bd36:	0f b6       	in	r0, 0x3f	; 63
    bd38:	f8 94       	cli
    bd3a:	fe bf       	out	0x3e, r31	; 62
    bd3c:	0f be       	out	0x3f, r0	; 63
    bd3e:	ed bf       	out	0x3d, r30	; 61
    bd40:	0e 94 65 41 	call	0x82ca	; 0x82ca <Reset_Even_Status_Register>
	
	
	/* Se obtiene la posicion Actual del encoder*/
	PMDGetActualPosition(&hAxis[Axis],posicion);
    bd44:	c2 01       	movw	r24, r4
    bd46:	69 8d       	ldd	r22, Y+25	; 0x19
    bd48:	7a 8d       	ldd	r23, Y+26	; 0x1a
    bd4a:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
	
	
	#ifdef DEBUGROBOTICS_HOME
	PMDGetEventStatus(&hAxis[Axis],&status);  
    bd4e:	c2 01       	movw	r24, r4
    bd50:	b8 01       	movw	r22, r16
    bd52:	0e 94 75 78 	call	0xf0ea	; 0xf0ea <PMDGetEventStatus>
	printf("search_home_negative=> El Event status register del eje %s despues de limpiar es %X \n ",AxisName(Axis),status);	
    bd56:	c3 01       	movw	r24, r6
    bd58:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    bd5c:	00 d0       	rcall	.+0      	; 0xbd5e <search_home_negative+0x6c6>
    bd5e:	00 d0       	rcall	.+0      	; 0xbd60 <search_home_negative+0x6c8>
    bd60:	00 d0       	rcall	.+0      	; 0xbd62 <search_home_negative+0x6ca>
    bd62:	ed b7       	in	r30, 0x3d	; 61
    bd64:	fe b7       	in	r31, 0x3e	; 62
    bd66:	31 96       	adiw	r30, 0x01	; 1
    bd68:	28 e4       	ldi	r18, 0x48	; 72
    bd6a:	35 e5       	ldi	r19, 0x55	; 85
    bd6c:	ad b7       	in	r26, 0x3d	; 61
    bd6e:	be b7       	in	r27, 0x3e	; 62
    bd70:	12 96       	adiw	r26, 0x02	; 2
    bd72:	3c 93       	st	X, r19
    bd74:	2e 93       	st	-X, r18
    bd76:	11 97       	sbiw	r26, 0x01	; 1
    bd78:	93 83       	std	Z+3, r25	; 0x03
    bd7a:	82 83       	std	Z+2, r24	; 0x02
    bd7c:	89 81       	ldd	r24, Y+1	; 0x01
    bd7e:	9a 81       	ldd	r25, Y+2	; 0x02
    bd80:	95 83       	std	Z+5, r25	; 0x05
    bd82:	84 83       	std	Z+4, r24	; 0x04
    bd84:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    bd88:	ed b7       	in	r30, 0x3d	; 61
    bd8a:	fe b7       	in	r31, 0x3e	; 62
    bd8c:	36 96       	adiw	r30, 0x06	; 6
    bd8e:	0f b6       	in	r0, 0x3f	; 63
    bd90:	f8 94       	cli
    bd92:	fe bf       	out	0x3e, r31	; 62
    bd94:	0f be       	out	0x3f, r0	; 63
    bd96:	ed bf       	out	0x3d, r30	; 61
	#endif	
	
	

}
    bd98:	6c 96       	adiw	r28, 0x1c	; 28
    bd9a:	0f b6       	in	r0, 0x3f	; 63
    bd9c:	f8 94       	cli
    bd9e:	de bf       	out	0x3e, r29	; 62
    bda0:	0f be       	out	0x3f, r0	; 63
    bda2:	cd bf       	out	0x3d, r28	; 61
    bda4:	cf 91       	pop	r28
    bda6:	df 91       	pop	r29
    bda8:	1f 91       	pop	r17
    bdaa:	0f 91       	pop	r16
    bdac:	ff 90       	pop	r15
    bdae:	ef 90       	pop	r14
    bdb0:	df 90       	pop	r13
    bdb2:	cf 90       	pop	r12
    bdb4:	bf 90       	pop	r11
    bdb6:	af 90       	pop	r10
    bdb8:	9f 90       	pop	r9
    bdba:	8f 90       	pop	r8
    bdbc:	7f 90       	pop	r7
    bdbe:	6f 90       	pop	r6
    bdc0:	5f 90       	pop	r5
    bdc2:	4f 90       	pop	r4
    bdc4:	3f 90       	pop	r3
    bdc6:	2f 90       	pop	r2
    bdc8:	08 95       	ret

0000bdca <go_home>:
	printf("Encoder = %ld\n",encoder);	

}
/**********************************************************************************************************************/
void go_home(void)
{
    bdca:	2f 92       	push	r2
    bdcc:	3f 92       	push	r3
    bdce:	4f 92       	push	r4
    bdd0:	5f 92       	push	r5
    bdd2:	6f 92       	push	r6
    bdd4:	7f 92       	push	r7
    bdd6:	8f 92       	push	r8
    bdd8:	9f 92       	push	r9
    bdda:	af 92       	push	r10
    bddc:	bf 92       	push	r11
    bdde:	cf 92       	push	r12
    bde0:	df 92       	push	r13
    bde2:	ef 92       	push	r14
    bde4:	ff 92       	push	r15
    bde6:	0f 93       	push	r16
    bde8:	1f 93       	push	r17
    bdea:	df 93       	push	r29
    bdec:	cf 93       	push	r28
    bdee:	cd b7       	in	r28, 0x3d	; 61
    bdf0:	de b7       	in	r29, 0x3e	; 62
    bdf2:	ca 54       	subi	r28, 0x4A	; 74
    bdf4:	d0 40       	sbci	r29, 0x00	; 0
    bdf6:	0f b6       	in	r0, 0x3f	; 63
    bdf8:	f8 94       	cli
    bdfa:	de bf       	out	0x3e, r29	; 62
    bdfc:	0f be       	out	0x3f, r0	; 63
    bdfe:	cd bf       	out	0x3d, r28	; 61
	PMDint32 home=0,home1=INF,home2=INF,minPos,maxPos;
    be00:	1b 86       	std	Y+11, r1	; 0x0b
    be02:	1c 86       	std	Y+12, r1	; 0x0c
    be04:	1d 86       	std	Y+13, r1	; 0x0d
    be06:	1e 86       	std	Y+14, r1	; 0x0e
    be08:	8f ef       	ldi	r24, 0xFF	; 255
    be0a:	9f ef       	ldi	r25, 0xFF	; 255
    be0c:	af ef       	ldi	r26, 0xFF	; 255
    be0e:	bf e7       	ldi	r27, 0x7F	; 127
    be10:	8f 87       	std	Y+15, r24	; 0x0f
    be12:	98 8b       	std	Y+16, r25	; 0x10
    be14:	a9 8b       	std	Y+17, r26	; 0x11
    be16:	ba 8b       	std	Y+18, r27	; 0x12
    be18:	8b 8b       	std	Y+19, r24	; 0x13
    be1a:	9c 8b       	std	Y+20, r25	; 0x14
    be1c:	ad 8b       	std	Y+21, r26	; 0x15
    be1e:	be 8b       	std	Y+22, r27	; 0x16
	PMDuint32 acceleration1, deceleration;
	PMDuint16 cuentas_encoder, micropasos,test;
	#endif
		
	/* Desactivar las interrupciones generadas por los PMDs*/
	HostInterruptDisable();	
    be20:	0e 94 07 76 	call	0xec0e	; 0xec0e <HostInterruptDisable>
    be24:	0f 2e       	mov	r0, r31
    be26:	f0 e0       	ldi	r31, 0x00	; 0
    be28:	2f 2e       	mov	r2, r31
    be2a:	f0 e0       	ldi	r31, 0x00	; 0
    be2c:	3f 2e       	mov	r3, r31
    be2e:	f0 e0       	ldi	r31, 0x00	; 0
    be30:	4f 2e       	mov	r4, r31
    be32:	f0 e0       	ldi	r31, 0x00	; 0
    be34:	5f 2e       	mov	r5, r31
    be36:	f0 2d       	mov	r31, r0
    be38:	31 e0       	ldi	r19, 0x01	; 1
    be3a:	63 2e       	mov	r6, r19
    be3c:	71 2c       	mov	r7, r1
	
	
	
	for(Axis=AxisShoulder; Axis <= DOF; Axis++) 
	{	
		if(Axis==DOF)
    be3e:	25 e0       	ldi	r18, 0x05	; 5
    be40:	62 16       	cp	r6, r18
    be42:	71 04       	cpc	r7, r1
    be44:	11 f4       	brne	.+4      	; 0xbe4a <go_home+0x80>
    be46:	66 24       	eor	r6, r6
    be48:	77 24       	eor	r7, r7
			case (AxisRoll):
		    //fprintf_P(stderr,PSTR("Secuencia de HOME Roll \n"));  ;
		    break;	
		  
		}		
		printf("go_home=> --INICIO DE SECUENCIA DE HOME EJE %s--- \n ",AxisName(Axis));
    be4a:	c3 01       	movw	r24, r6
    be4c:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    be50:	00 d0       	rcall	.+0      	; 0xbe52 <go_home+0x88>
    be52:	00 d0       	rcall	.+0      	; 0xbe54 <go_home+0x8a>
    be54:	ef e9       	ldi	r30, 0x9F	; 159
    be56:	f5 e5       	ldi	r31, 0x55	; 85
    be58:	ad b7       	in	r26, 0x3d	; 61
    be5a:	be b7       	in	r27, 0x3e	; 62
    be5c:	12 96       	adiw	r26, 0x02	; 2
    be5e:	fc 93       	st	X, r31
    be60:	ee 93       	st	-X, r30
    be62:	11 97       	sbiw	r26, 0x01	; 1
    be64:	14 96       	adiw	r26, 0x04	; 4
    be66:	9c 93       	st	X, r25
    be68:	8e 93       	st	-X, r24
    be6a:	13 97       	sbiw	r26, 0x03	; 3
    be6c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("Saltar eje, teclee 1\n ");
    be70:	0f 90       	pop	r0
    be72:	0f 90       	pop	r0
    be74:	e4 ed       	ldi	r30, 0xD4	; 212
    be76:	f5 e5       	ldi	r31, 0x55	; 85
    be78:	ad b7       	in	r26, 0x3d	; 61
    be7a:	be b7       	in	r27, 0x3e	; 62
    be7c:	12 96       	adiw	r26, 0x02	; 2
    be7e:	fc 93       	st	X, r31
    be80:	ee 93       	st	-X, r30
    be82:	11 97       	sbiw	r26, 0x01	; 1
    be84:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		
		#ifdef DEBUGROBOTICS_HOME
		scanf("%d",&test);
    be88:	00 d0       	rcall	.+0      	; 0xbe8a <go_home+0xc0>
    be8a:	eb ee       	ldi	r30, 0xEB	; 235
    be8c:	f5 e5       	ldi	r31, 0x55	; 85
    be8e:	ad b7       	in	r26, 0x3d	; 61
    be90:	be b7       	in	r27, 0x3e	; 62
    be92:	12 96       	adiw	r26, 0x02	; 2
    be94:	fc 93       	st	X, r31
    be96:	ee 93       	st	-X, r30
    be98:	11 97       	sbiw	r26, 0x01	; 1
    be9a:	29 e0       	ldi	r18, 0x09	; 9
    be9c:	30 e0       	ldi	r19, 0x00	; 0
    be9e:	2c 0f       	add	r18, r28
    bea0:	3d 1f       	adc	r19, r29
    bea2:	14 96       	adiw	r26, 0x04	; 4
    bea4:	3c 93       	st	X, r19
    bea6:	2e 93       	st	-X, r18
    bea8:	13 97       	sbiw	r26, 0x03	; 3
    beaa:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
		#endif
		
		if(test!=1)
    beae:	0f 90       	pop	r0
    beb0:	0f 90       	pop	r0
    beb2:	0f 90       	pop	r0
    beb4:	0f 90       	pop	r0
    beb6:	89 85       	ldd	r24, Y+9	; 0x09
    beb8:	9a 85       	ldd	r25, Y+10	; 0x0a
    beba:	01 97       	sbiw	r24, 0x01	; 1
    bebc:	09 f4       	brne	.+2      	; 0xbec0 <go_home+0xf6>
    bebe:	2a c3       	rjmp	.+1620   	; 0xc514 <go_home+0x74a>
		{
			//-----------------------------------------------------------------------------------------------------
			// Busqueda el home.
			//-----------------------------------------------------------------------------------------------------
			switch(hAxis[Axis].axisSettings.homeSwitchHandling) 
    bec0:	80 e6       	ldi	r24, 0x60	; 96
    bec2:	90 e0       	ldi	r25, 0x00	; 0
    bec4:	68 9e       	mul	r6, r24
    bec6:	f0 01       	movw	r30, r0
    bec8:	69 9e       	mul	r6, r25
    beca:	f0 0d       	add	r31, r0
    becc:	78 9e       	mul	r7, r24
    bece:	f0 0d       	add	r31, r0
    bed0:	11 24       	eor	r1, r1
    bed2:	e7 5e       	subi	r30, 0xE7	; 231
    bed4:	fa 48       	sbci	r31, 0x8A	; 138
    bed6:	86 8d       	ldd	r24, Z+30	; 0x1e
    bed8:	97 8d       	ldd	r25, Z+31	; 0x1f
    beda:	00 97       	sbiw	r24, 0x00	; 0
    bedc:	09 f4       	brne	.+2      	; 0xbee0 <go_home+0x116>
    bede:	75 c0       	rjmp	.+234    	; 0xbfca <go_home+0x200>
    bee0:	81 30       	cpi	r24, 0x01	; 1
    bee2:	91 05       	cpc	r25, r1
    bee4:	e1 f1       	breq	.+120    	; 0xbf5e <go_home+0x194>
    bee6:	8f 5f       	subi	r24, 0xFF	; 255
    bee8:	9f 4f       	sbci	r25, 0xFF	; 255
    beea:	09 f0       	breq	.+2      	; 0xbeee <go_home+0x124>
    beec:	13 c3       	rjmp	.+1574   	; 0xc514 <go_home+0x74a>
				case -1 : //Hombro
				{
					//Como el interuptor es desactivo por No_limit_switch(), 
					//ya no hay necesidad de entrar a el limite para volver a salir.
					//Mover el Eje en Direccion Negativa llegando al Limite Negativo
					search_home_negative(Axis,&home1,&minPos,FALSE);
    beee:	c3 01       	movw	r24, r6
    bef0:	be 01       	movw	r22, r28
    bef2:	61 5f       	subi	r22, 0xF1	; 241
    bef4:	7f 4f       	sbci	r23, 0xFF	; 255
    bef6:	ae 01       	movw	r20, r28
    bef8:	49 5e       	subi	r20, 0xE9	; 233
    befa:	5f 4f       	sbci	r21, 0xFF	; 255
    befc:	20 e0       	ldi	r18, 0x00	; 0
    befe:	30 e0       	ldi	r19, 0x00	; 0
    bf00:	0e 94 4c 5b 	call	0xb698	; 0xb698 <search_home_negative>
					//Mover el Eje en Direccion Positiva parando cuando encuentre el HOME
					//Nunca lo va a encontrar porque al ejecutar No_limit_switch() no esta oprimido el interuptor.
					//search_home_positive(Axis,&home2,&maxPos,FALSE);	
					rad=grados2rad(AJUSTE_HOMBRO_HOME_NEGA);
    bf04:	66 e6       	ldi	r22, 0x66	; 102
    bf06:	76 e6       	ldi	r23, 0x66	; 102
    bf08:	86 ee       	ldi	r24, 0xE6	; 230
    bf0a:	9f e3       	ldi	r25, 0x3F	; 63
    bf0c:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <grados2rad>
    bf10:	1b 01       	movw	r2, r22
    bf12:	2c 01       	movw	r4, r24
					Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    bf14:	c3 01       	movw	r24, r6
    bf16:	88 0f       	add	r24, r24
    bf18:	99 1f       	adc	r25, r25
    bf1a:	86 0d       	add	r24, r6
    bf1c:	97 1d       	adc	r25, r7
    bf1e:	05 e0       	ldi	r16, 0x05	; 5
    bf20:	88 0f       	add	r24, r24
    bf22:	99 1f       	adc	r25, r25
    bf24:	0a 95       	dec	r16
    bf26:	e1 f7       	brne	.-8      	; 0xbf20 <go_home+0x156>
    bf28:	83 5e       	subi	r24, 0xE3	; 227
    bf2a:	9a 48       	sbci	r25, 0x8A	; 138
    bf2c:	b2 01       	movw	r22, r4
    bf2e:	a1 01       	movw	r20, r2
    bf30:	0e 94 10 29 	call	0x5220	; 0x5220 <rad2usteps>
    bf34:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    bf38:	7b 01       	movw	r14, r22
    bf3a:	8c 01       	movw	r16, r24
					printf("go_home=> Factor de correcion %s (search_home_negative) en uPasos = %ld\n",AxisName(Axis),Correcion);
    bf3c:	c3 01       	movw	r24, r6
    bf3e:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    bf42:	ad b7       	in	r26, 0x3d	; 61
    bf44:	be b7       	in	r27, 0x3e	; 62
    bf46:	18 97       	sbiw	r26, 0x08	; 8
    bf48:	0f b6       	in	r0, 0x3f	; 63
    bf4a:	f8 94       	cli
    bf4c:	be bf       	out	0x3e, r27	; 62
    bf4e:	0f be       	out	0x3f, r0	; 63
    bf50:	ad bf       	out	0x3d, r26	; 61
    bf52:	ed b7       	in	r30, 0x3d	; 61
    bf54:	fe b7       	in	r31, 0x3e	; 62
    bf56:	31 96       	adiw	r30, 0x01	; 1
    bf58:	2e ee       	ldi	r18, 0xEE	; 238
    bf5a:	35 e5       	ldi	r19, 0x55	; 85
    bf5c:	a4 c2       	rjmp	.+1352   	; 0xc4a6 <go_home+0x6dc>
				}
				break;
				case  1 : //Codo y Pitch
				{
					//Mover el Eje en Direccion Positiva hasta llegar al Limite Positivo.
					search_home_positive(Axis,&home1,&maxPos,FALSE);
    bf5e:	c3 01       	movw	r24, r6
    bf60:	be 01       	movw	r22, r28
    bf62:	61 5f       	subi	r22, 0xF1	; 241
    bf64:	7f 4f       	sbci	r23, 0xFF	; 255
    bf66:	ae 01       	movw	r20, r28
    bf68:	45 5e       	subi	r20, 0xE5	; 229
    bf6a:	5f 4f       	sbci	r21, 0xFF	; 255
    bf6c:	20 e0       	ldi	r18, 0x00	; 0
    bf6e:	30 e0       	ldi	r19, 0x00	; 0
    bf70:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <search_home_positive>
					//Mover el Eje en Direccion Negativa parando cuando encuentre el HOME
					//Nunca lo va a encontrar porque al ejecutar No_limit_switch() no esta oprimido el interuptor.
					//search_home_negative(Axis,&home2,&minPos,FALSE);				
					//home = home1;            // just use right limit
					if(Axis==AxisElbow)
    bf74:	32 e0       	ldi	r19, 0x02	; 2
    bf76:	63 16       	cp	r6, r19
    bf78:	71 04       	cpc	r7, r1
    bf7a:	29 f4       	brne	.+10     	; 0xbf86 <go_home+0x1bc>
					{
						//-9700
						//home=home-9700;
						rad=grados2rad(AJUSTE_CODO_HOME_POSI);
    bf7c:	60 e0       	ldi	r22, 0x00	; 0
    bf7e:	70 e0       	ldi	r23, 0x00	; 0
    bf80:	80 e2       	ldi	r24, 0x20	; 32
    bf82:	90 ec       	ldi	r25, 0xC0	; 192
    bf84:	08 c0       	rjmp	.+16     	; 0xbf96 <go_home+0x1cc>
						
					}	
					if(Axis==AxisPitch)
    bf86:	83 e0       	ldi	r24, 0x03	; 3
    bf88:	68 16       	cp	r6, r24
    bf8a:	71 04       	cpc	r7, r1
    bf8c:	41 f4       	brne	.+16     	; 0xbf9e <go_home+0x1d4>
					{
						//-1100
						//home=home-1100;
						rad=grados2rad(AJUSTE_PITCH_HOME_POSI);
    bf8e:	60 e0       	ldi	r22, 0x00	; 0
    bf90:	70 e0       	ldi	r23, 0x00	; 0
    bf92:	88 e7       	ldi	r24, 0x78	; 120
    bf94:	91 ec       	ldi	r25, 0xC1	; 193
    bf96:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <grados2rad>
    bf9a:	1b 01       	movw	r2, r22
    bf9c:	2c 01       	movw	r4, r24
					}
					
					Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    bf9e:	c3 01       	movw	r24, r6
    bfa0:	88 0f       	add	r24, r24
    bfa2:	99 1f       	adc	r25, r25
    bfa4:	86 0d       	add	r24, r6
    bfa6:	97 1d       	adc	r25, r7
    bfa8:	b5 e0       	ldi	r27, 0x05	; 5
    bfaa:	88 0f       	add	r24, r24
    bfac:	99 1f       	adc	r25, r25
    bfae:	ba 95       	dec	r27
    bfb0:	e1 f7       	brne	.-8      	; 0xbfaa <go_home+0x1e0>
    bfb2:	83 5e       	subi	r24, 0xE3	; 227
    bfb4:	9a 48       	sbci	r25, 0x8A	; 138
    bfb6:	b2 01       	movw	r22, r4
    bfb8:	a1 01       	movw	r20, r2
    bfba:	0e 94 10 29 	call	0x5220	; 0x5220 <rad2usteps>
    bfbe:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    bfc2:	7b 01       	movw	r14, r22
    bfc4:	8c 01       	movw	r16, r24
					printf("go_home=> Factor de correcion %s (search_home_positive) en uPasos = %ld\n",AxisName(Axis),Correcion);
    bfc6:	c3 01       	movw	r24, r6
    bfc8:	5f c2       	rjmp	.+1214   	; 0xc488 <go_home+0x6be>
				{
					/*si las articulaciones (cintura) esta en home entonces no se realiza
					ningun procedimiento de busqueda de home y se asigna como home
					su posicion actual.*/
					
					if (Axis==AxisWaist)
    bfca:	61 14       	cp	r6, r1
    bfcc:	71 04       	cpc	r7, r1
    bfce:	09 f0       	breq	.+2      	; 0xbfd2 <go_home+0x208>
    bfd0:	d8 c0       	rjmp	.+432    	; 0xc182 <go_home+0x3b8>
					{
						
						PMDGetSignalStatus(&hAxis[Axis], &signal_status);				
    bfd2:	89 e1       	ldi	r24, 0x19	; 25
    bfd4:	95 e7       	ldi	r25, 0x75	; 117
    bfd6:	be 01       	movw	r22, r28
    bfd8:	6f 5f       	subi	r22, 0xFF	; 255
    bfda:	7f 4f       	sbci	r23, 0xFF	; 255
    bfdc:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
						if((signal_status & PMDSignalEncoderHomeMask)==0) //si la articulacion esta en HOME
    bfe0:	89 81       	ldd	r24, Y+1	; 0x01
    bfe2:	83 fd       	sbrc	r24, 3
    bfe4:	08 c0       	rjmp	.+16     	; 0xbff6 <go_home+0x22c>
						{
							PMDGetActualPosition(&hAxis[Axis],&home);
    bfe6:	89 e1       	ldi	r24, 0x19	; 25
    bfe8:	95 e7       	ldi	r25, 0x75	; 117
    bfea:	be 01       	movw	r22, r28
    bfec:	65 5f       	subi	r22, 0xF5	; 245
    bfee:	7f 4f       	sbci	r23, 0xFF	; 255
    bff0:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
    bff4:	8f c2       	rjmp	.+1310   	; 0xc514 <go_home+0x74a>
						}
						else//si la articulacion no esta en HOME
						{
							//Mover el Eje en Direccion Negativa llegando al Limite Negativo
							search_home_negative(Axis,&home1,&minPos,FALSE);
    bff6:	80 e0       	ldi	r24, 0x00	; 0
    bff8:	90 e0       	ldi	r25, 0x00	; 0
    bffa:	be 01       	movw	r22, r28
    bffc:	61 5f       	subi	r22, 0xF1	; 241
    bffe:	7f 4f       	sbci	r23, 0xFF	; 255
    c000:	ae 01       	movw	r20, r28
    c002:	49 5e       	subi	r20, 0xE9	; 233
    c004:	5f 4f       	sbci	r21, 0xFF	; 255
    c006:	20 e0       	ldi	r18, 0x00	; 0
    c008:	30 e0       	ldi	r19, 0x00	; 0
    c00a:	0e 94 4c 5b 	call	0xb698	; 0xb698 <search_home_negative>
							//Si no se encuentra home
							if(home1==INF)
    c00e:	8f 85       	ldd	r24, Y+15	; 0x0f
    c010:	98 89       	ldd	r25, Y+16	; 0x10
    c012:	a9 89       	ldd	r26, Y+17	; 0x11
    c014:	ba 89       	ldd	r27, Y+18	; 0x12
    c016:	8f 5f       	subi	r24, 0xFF	; 255
    c018:	9f 4f       	sbci	r25, 0xFF	; 255
    c01a:	af 4f       	sbci	r26, 0xFF	; 255
    c01c:	bf 47       	sbci	r27, 0x7F	; 127
    c01e:	09 f0       	breq	.+2      	; 0xc022 <go_home+0x258>
    c020:	56 c0       	rjmp	.+172    	; 0xc0ce <go_home+0x304>
							{	
								//Mover el Eje en Direccion Positiva hasta llegar al Limite Positivo
								search_home_positive(Axis,&home2,&maxPos,FALSE);
    c022:	80 e0       	ldi	r24, 0x00	; 0
    c024:	90 e0       	ldi	r25, 0x00	; 0
    c026:	be 01       	movw	r22, r28
    c028:	6d 5e       	subi	r22, 0xED	; 237
    c02a:	7f 4f       	sbci	r23, 0xFF	; 255
    c02c:	ae 01       	movw	r20, r28
    c02e:	45 5e       	subi	r20, 0xE5	; 229
    c030:	5f 4f       	sbci	r21, 0xFF	; 255
    c032:	20 e0       	ldi	r18, 0x00	; 0
    c034:	30 e0       	ldi	r19, 0x00	; 0
    c036:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <search_home_positive>
								rad=grados2rad(AJUSTE_CINTURA_HOME_POSI); //ok
    c03a:	60 e0       	ldi	r22, 0x00	; 0
    c03c:	70 e0       	ldi	r23, 0x00	; 0
    c03e:	80 e0       	ldi	r24, 0x00	; 0
    c040:	9f e3       	ldi	r25, 0x3F	; 63
    c042:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <grados2rad>
    c046:	1b 01       	movw	r2, r22
    c048:	2c 01       	movw	r4, r24
								Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    c04a:	8d e1       	ldi	r24, 0x1D	; 29
    c04c:	95 e7       	ldi	r25, 0x75	; 117
    c04e:	b2 01       	movw	r22, r4
    c050:	a1 01       	movw	r20, r2
    c052:	0e 94 10 29 	call	0x5220	; 0x5220 <rad2usteps>
    c056:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    c05a:	7b 01       	movw	r14, r22
    c05c:	8c 01       	movw	r16, r24
								printf("go_home=> Factor de correcion %s (search_home_positive) en uPasos = %ld\n",AxisName(Axis),Correcion);
    c05e:	80 e0       	ldi	r24, 0x00	; 0
    c060:	90 e0       	ldi	r25, 0x00	; 0
    c062:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    c066:	ad b7       	in	r26, 0x3d	; 61
    c068:	be b7       	in	r27, 0x3e	; 62
    c06a:	18 97       	sbiw	r26, 0x08	; 8
    c06c:	0f b6       	in	r0, 0x3f	; 63
    c06e:	f8 94       	cli
    c070:	be bf       	out	0x3e, r27	; 62
    c072:	0f be       	out	0x3f, r0	; 63
    c074:	ad bf       	out	0x3d, r26	; 61
    c076:	ed b7       	in	r30, 0x3d	; 61
    c078:	fe b7       	in	r31, 0x3e	; 62
    c07a:	31 96       	adiw	r30, 0x01	; 1
    c07c:	2e e4       	ldi	r18, 0x4E	; 78
    c07e:	36 e5       	ldi	r19, 0x56	; 86
    c080:	12 96       	adiw	r26, 0x02	; 2
    c082:	3c 93       	st	X, r19
    c084:	2e 93       	st	-X, r18
    c086:	11 97       	sbiw	r26, 0x01	; 1
    c088:	93 83       	std	Z+3, r25	; 0x03
    c08a:	82 83       	std	Z+2, r24	; 0x02
    c08c:	e4 82       	std	Z+4, r14	; 0x04
    c08e:	f5 82       	std	Z+5, r15	; 0x05
    c090:	06 83       	std	Z+6, r16	; 0x06
    c092:	17 83       	std	Z+7, r17	; 0x07
    c094:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
								printf("go_home=> home2  = %ld\n",home2);
    c098:	0f 90       	pop	r0
    c09a:	0f 90       	pop	r0
    c09c:	e7 e9       	ldi	r30, 0x97	; 151
    c09e:	f6 e5       	ldi	r31, 0x56	; 86
    c0a0:	ad b7       	in	r26, 0x3d	; 61
    c0a2:	be b7       	in	r27, 0x3e	; 62
    c0a4:	12 96       	adiw	r26, 0x02	; 2
    c0a6:	fc 93       	st	X, r31
    c0a8:	ee 93       	st	-X, r30
    c0aa:	11 97       	sbiw	r26, 0x01	; 1
    c0ac:	8b 89       	ldd	r24, Y+19	; 0x13
    c0ae:	9c 89       	ldd	r25, Y+20	; 0x14
    c0b0:	ad 89       	ldd	r26, Y+21	; 0x15
    c0b2:	be 89       	ldd	r27, Y+22	; 0x16
    c0b4:	ed b7       	in	r30, 0x3d	; 61
    c0b6:	fe b7       	in	r31, 0x3e	; 62
    c0b8:	83 83       	std	Z+3, r24	; 0x03
    c0ba:	94 83       	std	Z+4, r25	; 0x04
    c0bc:	a5 83       	std	Z+5, r26	; 0x05
    c0be:	b6 83       	std	Z+6, r27	; 0x06
    c0c0:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
								home = home2+Correcion;
    c0c4:	8b 89       	ldd	r24, Y+19	; 0x13
    c0c6:	9c 89       	ldd	r25, Y+20	; 0x14
    c0c8:	ad 89       	ldd	r26, Y+21	; 0x15
    c0ca:	be 89       	ldd	r27, Y+22	; 0x16
    c0cc:	49 c0       	rjmp	.+146    	; 0xc160 <go_home+0x396>
							}
							else	
							{		
								rad=grados2rad(AJUSTE_CINTURA_HOME_NEGA);
    c0ce:	6a e9       	ldi	r22, 0x9A	; 154
    c0d0:	79 e9       	ldi	r23, 0x99	; 153
    c0d2:	89 e1       	ldi	r24, 0x19	; 25
    c0d4:	9f eb       	ldi	r25, 0xBF	; 191
    c0d6:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <grados2rad>
    c0da:	1b 01       	movw	r2, r22
    c0dc:	2c 01       	movw	r4, r24
								Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    c0de:	8d e1       	ldi	r24, 0x1D	; 29
    c0e0:	95 e7       	ldi	r25, 0x75	; 117
    c0e2:	b2 01       	movw	r22, r4
    c0e4:	a1 01       	movw	r20, r2
    c0e6:	0e 94 10 29 	call	0x5220	; 0x5220 <rad2usteps>
    c0ea:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    c0ee:	7b 01       	movw	r14, r22
    c0f0:	8c 01       	movw	r16, r24
								printf("go_home=> Factor de correcion %s (search_home_negative) en uPasos = %ld\n",AxisName(Axis),Correcion);
    c0f2:	80 e0       	ldi	r24, 0x00	; 0
    c0f4:	90 e0       	ldi	r25, 0x00	; 0
    c0f6:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    c0fa:	ad b7       	in	r26, 0x3d	; 61
    c0fc:	be b7       	in	r27, 0x3e	; 62
    c0fe:	18 97       	sbiw	r26, 0x08	; 8
    c100:	0f b6       	in	r0, 0x3f	; 63
    c102:	f8 94       	cli
    c104:	be bf       	out	0x3e, r27	; 62
    c106:	0f be       	out	0x3f, r0	; 63
    c108:	ad bf       	out	0x3d, r26	; 61
    c10a:	ed b7       	in	r30, 0x3d	; 61
    c10c:	fe b7       	in	r31, 0x3e	; 62
    c10e:	31 96       	adiw	r30, 0x01	; 1
    c110:	2e ee       	ldi	r18, 0xEE	; 238
    c112:	35 e5       	ldi	r19, 0x55	; 85
    c114:	12 96       	adiw	r26, 0x02	; 2
    c116:	3c 93       	st	X, r19
    c118:	2e 93       	st	-X, r18
    c11a:	11 97       	sbiw	r26, 0x01	; 1
    c11c:	93 83       	std	Z+3, r25	; 0x03
    c11e:	82 83       	std	Z+2, r24	; 0x02
    c120:	e4 82       	std	Z+4, r14	; 0x04
    c122:	f5 82       	std	Z+5, r15	; 0x05
    c124:	06 83       	std	Z+6, r16	; 0x06
    c126:	17 83       	std	Z+7, r17	; 0x07
    c128:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
								printf("go_home=> home1 = %ld\n",home1);
    c12c:	0f 90       	pop	r0
    c12e:	0f 90       	pop	r0
    c130:	e7 e3       	ldi	r30, 0x37	; 55
    c132:	f6 e5       	ldi	r31, 0x56	; 86
    c134:	ad b7       	in	r26, 0x3d	; 61
    c136:	be b7       	in	r27, 0x3e	; 62
    c138:	12 96       	adiw	r26, 0x02	; 2
    c13a:	fc 93       	st	X, r31
    c13c:	ee 93       	st	-X, r30
    c13e:	11 97       	sbiw	r26, 0x01	; 1
    c140:	8f 85       	ldd	r24, Y+15	; 0x0f
    c142:	98 89       	ldd	r25, Y+16	; 0x10
    c144:	a9 89       	ldd	r26, Y+17	; 0x11
    c146:	ba 89       	ldd	r27, Y+18	; 0x12
    c148:	ed b7       	in	r30, 0x3d	; 61
    c14a:	fe b7       	in	r31, 0x3e	; 62
    c14c:	83 83       	std	Z+3, r24	; 0x03
    c14e:	94 83       	std	Z+4, r25	; 0x04
    c150:	a5 83       	std	Z+5, r26	; 0x05
    c152:	b6 83       	std	Z+6, r27	; 0x06
    c154:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
								home = home1+Correcion;		
    c158:	8f 85       	ldd	r24, Y+15	; 0x0f
    c15a:	98 89       	ldd	r25, Y+16	; 0x10
    c15c:	a9 89       	ldd	r26, Y+17	; 0x11
    c15e:	ba 89       	ldd	r27, Y+18	; 0x12
    c160:	8e 0d       	add	r24, r14
    c162:	9f 1d       	adc	r25, r15
    c164:	a0 1f       	adc	r26, r16
    c166:	b1 1f       	adc	r27, r17
    c168:	8b 87       	std	Y+11, r24	; 0x0b
    c16a:	9c 87       	std	Y+12, r25	; 0x0c
    c16c:	ad 87       	std	Y+13, r26	; 0x0d
    c16e:	be 87       	std	Y+14, r27	; 0x0e
    c170:	2d b7       	in	r18, 0x3d	; 61
    c172:	3e b7       	in	r19, 0x3e	; 62
    c174:	2a 5f       	subi	r18, 0xFA	; 250
    c176:	3f 4f       	sbci	r19, 0xFF	; 255
    c178:	0f b6       	in	r0, 0x3f	; 63
    c17a:	f8 94       	cli
    c17c:	3e bf       	out	0x3e, r19	; 62
    c17e:	0f be       	out	0x3f, r0	; 63
    c180:	2d bf       	out	0x3d, r18	; 61
							}
							
						}
					}		
					if(Axis==AxisRoll)
    c182:	34 e0       	ldi	r19, 0x04	; 4
    c184:	63 16       	cp	r6, r19
    c186:	71 04       	cpc	r7, r1
    c188:	09 f0       	breq	.+2      	; 0xc18c <go_home+0x3c2>
    c18a:	c4 c1       	rjmp	.+904    	; 0xc514 <go_home+0x74a>
					{
						
						// Leer el movimiento anterior de Roll que esta almacenado en EEPROM
						eeprom_read_block((void*)&Mov_Roll_Anterior_RAM,(const void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    c18c:	ce 01       	movw	r24, r28
    c18e:	87 96       	adiw	r24, 0x27	; 39
    c190:	66 e5       	ldi	r22, 0x56	; 86
    c192:	71 e0       	ldi	r23, 0x01	; 1
    c194:	44 e0       	ldi	r20, 0x04	; 4
    c196:	50 e0       	ldi	r21, 0x00	; 0
    c198:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
						#ifdef DEBUGROBOTICS_HOME
							printf("go_home=> El valor anterior de Roll = %ld\n",Mov_Roll_Anterior_RAM);		
    c19c:	00 d0       	rcall	.+0      	; 0xc19e <go_home+0x3d4>
    c19e:	00 d0       	rcall	.+0      	; 0xc1a0 <go_home+0x3d6>
    c1a0:	00 d0       	rcall	.+0      	; 0xc1a2 <go_home+0x3d8>
    c1a2:	ef ea       	ldi	r30, 0xAF	; 175
    c1a4:	f6 e5       	ldi	r31, 0x56	; 86
    c1a6:	ad b7       	in	r26, 0x3d	; 61
    c1a8:	be b7       	in	r27, 0x3e	; 62
    c1aa:	12 96       	adiw	r26, 0x02	; 2
    c1ac:	fc 93       	st	X, r31
    c1ae:	ee 93       	st	-X, r30
    c1b0:	11 97       	sbiw	r26, 0x01	; 1
    c1b2:	8f a1       	ldd	r24, Y+39	; 0x27
    c1b4:	98 a5       	ldd	r25, Y+40	; 0x28
    c1b6:	a9 a5       	ldd	r26, Y+41	; 0x29
    c1b8:	ba a5       	ldd	r27, Y+42	; 0x2a
    c1ba:	ed b7       	in	r30, 0x3d	; 61
    c1bc:	fe b7       	in	r31, 0x3e	; 62
    c1be:	83 83       	std	Z+3, r24	; 0x03
    c1c0:	94 83       	std	Z+4, r25	; 0x04
    c1c2:	a5 83       	std	Z+5, r26	; 0x05
    c1c4:	b6 83       	std	Z+6, r27	; 0x06
    c1c6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
						#endif
						
						PMDGetSignalStatus(&hAxis[Axis], &signal_status);				
    c1ca:	2d b7       	in	r18, 0x3d	; 61
    c1cc:	3e b7       	in	r19, 0x3e	; 62
    c1ce:	2a 5f       	subi	r18, 0xFA	; 250
    c1d0:	3f 4f       	sbci	r19, 0xFF	; 255
    c1d2:	0f b6       	in	r0, 0x3f	; 63
    c1d4:	f8 94       	cli
    c1d6:	3e bf       	out	0x3e, r19	; 62
    c1d8:	0f be       	out	0x3f, r0	; 63
    c1da:	2d bf       	out	0x3d, r18	; 61
    c1dc:	89 e9       	ldi	r24, 0x99	; 153
    c1de:	96 e7       	ldi	r25, 0x76	; 118
    c1e0:	be 01       	movw	r22, r28
    c1e2:	6f 5f       	subi	r22, 0xFF	; 255
    c1e4:	7f 4f       	sbci	r23, 0xFF	; 255
    c1e6:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
						//si la articulacion esta en HOME 
						if((signal_status & PMDSignalEncoderHomeMask)!=0)	 
    c1ea:	89 81       	ldd	r24, Y+1	; 0x01
    c1ec:	83 ff       	sbrs	r24, 3
    c1ee:	21 c0       	rjmp	.+66     	; 0xc232 <go_home+0x468>
						{
							//Debo mover el roll para ajustar home con search_home_positive.
							roll(-15, hAxis[AxisRoll].axisSettings.homeVelocity,
    c1f0:	20 91 d9 76 	lds	r18, 0x76D9
    c1f4:	30 91 da 76 	lds	r19, 0x76DA
    c1f8:	40 91 db 76 	lds	r20, 0x76DB
    c1fc:	50 91 dc 76 	lds	r21, 0x76DC
    c200:	e0 90 dd 76 	lds	r14, 0x76DD
    c204:	f0 90 de 76 	lds	r15, 0x76DE
    c208:	00 91 df 76 	lds	r16, 0x76DF
    c20c:	10 91 e0 76 	lds	r17, 0x76E0
    c210:	61 ef       	ldi	r22, 0xF1	; 241
    c212:	7f ef       	ldi	r23, 0xFF	; 255
    c214:	8f ef       	ldi	r24, 0xFF	; 255
    c216:	9f ef       	ldi	r25, 0xFF	; 255
    c218:	a0 ef       	ldi	r26, 0xF0	; 240
    c21a:	ca 2e       	mov	r12, r26
    c21c:	af ef       	ldi	r26, 0xFF	; 255
    c21e:	da 2e       	mov	r13, r26
    c220:	f3 e0       	ldi	r31, 0x03	; 3
    c222:	af 2e       	mov	r10, r31
    c224:	b1 2c       	mov	r11, r1
    c226:	0e 94 1b 50 	call	0xa036	; 0xa036 <roll>
							hAxis[AxisRoll].axisSettings.homeAcceleration, update,EN_CALIBRACION_PROCESOHOME);
							Mov_Roll_Anterior_RAM=0;
    c22a:	1f a2       	std	Y+39, r1	; 0x27
    c22c:	18 a6       	std	Y+40, r1	; 0x28
    c22e:	19 a6       	std	Y+41, r1	; 0x29
    c230:	1a a6       	std	Y+42, r1	; 0x2a
						}
						#ifdef DEBUGROBOTICS_HOME
							printf("go_home=>  El eje de Roll No esta en HOME\n");		
    c232:	8a ed       	ldi	r24, 0xDA	; 218
    c234:	96 e5       	ldi	r25, 0x56	; 86
    c236:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
						#endif
						//Caso Inicializacion (HOME ejecutado o reprogramacion)
						if(Mov_Roll_Anterior_RAM==0)
    c23a:	8f a1       	ldd	r24, Y+39	; 0x27
    c23c:	98 a5       	ldd	r25, Y+40	; 0x28
    c23e:	a9 a5       	ldd	r26, Y+41	; 0x29
    c240:	ba a5       	ldd	r27, Y+42	; 0x2a
    c242:	00 97       	sbiw	r24, 0x00	; 0
    c244:	a1 05       	cpc	r26, r1
    c246:	b1 05       	cpc	r27, r1
    c248:	09 f0       	breq	.+2      	; 0xc24c <go_home+0x482>
    c24a:	80 c0       	rjmp	.+256    	; 0xc34c <go_home+0x582>
						{
							search_home_roll_positive(&home1);
    c24c:	ce 01       	movw	r24, r28
    c24e:	0f 96       	adiw	r24, 0x0f	; 15
    c250:	0e 94 f7 50 	call	0xa1ee	; 0xa1ee <search_home_roll_positive>
							if(home1==INF) //que se cumplio el timer y no encontro home
    c254:	8f 85       	ldd	r24, Y+15	; 0x0f
    c256:	98 89       	ldd	r25, Y+16	; 0x10
    c258:	a9 89       	ldd	r26, Y+17	; 0x11
    c25a:	ba 89       	ldd	r27, Y+18	; 0x12
    c25c:	8f 3f       	cpi	r24, 0xFF	; 255
    c25e:	3f ef       	ldi	r19, 0xFF	; 255
    c260:	93 07       	cpc	r25, r19
    c262:	3f ef       	ldi	r19, 0xFF	; 255
    c264:	a3 07       	cpc	r26, r19
    c266:	3f e7       	ldi	r19, 0x7F	; 127
    c268:	b3 07       	cpc	r27, r19
    c26a:	09 f0       	breq	.+2      	; 0xc26e <go_home+0x4a4>
    c26c:	6b c0       	rjmp	.+214    	; 0xc344 <go_home+0x57a>
							{
								printf("go_home=> caso home1==INF\n");
    c26e:	84 e0       	ldi	r24, 0x04	; 4
    c270:	97 e5       	ldi	r25, 0x57	; 87
    c272:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
								search_home_negative(Axis,&home1,&minPos,FALSE);//mover en direcion negativa y hallar Home
    c276:	84 e0       	ldi	r24, 0x04	; 4
    c278:	90 e0       	ldi	r25, 0x00	; 0
    c27a:	be 01       	movw	r22, r28
    c27c:	61 5f       	subi	r22, 0xF1	; 241
    c27e:	7f 4f       	sbci	r23, 0xFF	; 255
    c280:	ae 01       	movw	r20, r28
    c282:	49 5e       	subi	r20, 0xE9	; 233
    c284:	5f 4f       	sbci	r21, 0xFF	; 255
    c286:	20 e0       	ldi	r18, 0x00	; 0
    c288:	30 e0       	ldi	r19, 0x00	; 0
    c28a:	0e 94 4c 5b 	call	0xb698	; 0xb698 <search_home_negative>
								rad=grados2rad(AJUSTE_ROLL_HOME_NEGA);
    c28e:	60 e0       	ldi	r22, 0x00	; 0
    c290:	70 e0       	ldi	r23, 0x00	; 0
    c292:	80 ea       	ldi	r24, 0xA0	; 160
    c294:	91 e4       	ldi	r25, 0x41	; 65
    c296:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <grados2rad>
    c29a:	1b 01       	movw	r2, r22
    c29c:	2c 01       	movw	r4, r24
								Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    c29e:	8d e9       	ldi	r24, 0x9D	; 157
    c2a0:	96 e7       	ldi	r25, 0x76	; 118
    c2a2:	b2 01       	movw	r22, r4
    c2a4:	a1 01       	movw	r20, r2
    c2a6:	0e 94 10 29 	call	0x5220	; 0x5220 <rad2usteps>
    c2aa:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    c2ae:	7b 01       	movw	r14, r22
    c2b0:	8c 01       	movw	r16, r24
								printf("go_home=> Factor de correcion %s (search_home_negative) en uPasos = %ld\n",AxisName(Axis),Correcion);
    c2b2:	84 e0       	ldi	r24, 0x04	; 4
    c2b4:	90 e0       	ldi	r25, 0x00	; 0
    c2b6:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    c2ba:	ad b7       	in	r26, 0x3d	; 61
    c2bc:	be b7       	in	r27, 0x3e	; 62
    c2be:	18 97       	sbiw	r26, 0x08	; 8
    c2c0:	0f b6       	in	r0, 0x3f	; 63
    c2c2:	f8 94       	cli
    c2c4:	be bf       	out	0x3e, r27	; 62
    c2c6:	0f be       	out	0x3f, r0	; 63
    c2c8:	ad bf       	out	0x3d, r26	; 61
    c2ca:	ed b7       	in	r30, 0x3d	; 61
    c2cc:	fe b7       	in	r31, 0x3e	; 62
    c2ce:	31 96       	adiw	r30, 0x01	; 1
    c2d0:	2e ee       	ldi	r18, 0xEE	; 238
    c2d2:	35 e5       	ldi	r19, 0x55	; 85
    c2d4:	12 96       	adiw	r26, 0x02	; 2
    c2d6:	3c 93       	st	X, r19
    c2d8:	2e 93       	st	-X, r18
    c2da:	11 97       	sbiw	r26, 0x01	; 1
    c2dc:	93 83       	std	Z+3, r25	; 0x03
    c2de:	82 83       	std	Z+2, r24	; 0x02
    c2e0:	e4 82       	std	Z+4, r14	; 0x04
    c2e2:	f5 82       	std	Z+5, r15	; 0x05
    c2e4:	06 83       	std	Z+6, r16	; 0x06
    c2e6:	17 83       	std	Z+7, r17	; 0x07
    c2e8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
								printf("go_home=> home1 = %ld\n",home1);
    c2ec:	0f 90       	pop	r0
    c2ee:	0f 90       	pop	r0
    c2f0:	e7 e3       	ldi	r30, 0x37	; 55
    c2f2:	f6 e5       	ldi	r31, 0x56	; 86
    c2f4:	ad b7       	in	r26, 0x3d	; 61
    c2f6:	be b7       	in	r27, 0x3e	; 62
    c2f8:	12 96       	adiw	r26, 0x02	; 2
    c2fa:	fc 93       	st	X, r31
    c2fc:	ee 93       	st	-X, r30
    c2fe:	11 97       	sbiw	r26, 0x01	; 1
    c300:	8f 85       	ldd	r24, Y+15	; 0x0f
    c302:	98 89       	ldd	r25, Y+16	; 0x10
    c304:	a9 89       	ldd	r26, Y+17	; 0x11
    c306:	ba 89       	ldd	r27, Y+18	; 0x12
    c308:	ed b7       	in	r30, 0x3d	; 61
    c30a:	fe b7       	in	r31, 0x3e	; 62
    c30c:	83 83       	std	Z+3, r24	; 0x03
    c30e:	94 83       	std	Z+4, r25	; 0x04
    c310:	a5 83       	std	Z+5, r26	; 0x05
    c312:	b6 83       	std	Z+6, r27	; 0x06
    c314:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
								home = home1+Correcion;		
    c318:	8f 85       	ldd	r24, Y+15	; 0x0f
    c31a:	98 89       	ldd	r25, Y+16	; 0x10
    c31c:	a9 89       	ldd	r26, Y+17	; 0x11
    c31e:	ba 89       	ldd	r27, Y+18	; 0x12
    c320:	8e 0d       	add	r24, r14
    c322:	9f 1d       	adc	r25, r15
    c324:	a0 1f       	adc	r26, r16
    c326:	b1 1f       	adc	r27, r17
    c328:	8b 87       	std	Y+11, r24	; 0x0b
    c32a:	9c 87       	std	Y+12, r25	; 0x0c
    c32c:	ad 87       	std	Y+13, r26	; 0x0d
    c32e:	be 87       	std	Y+14, r27	; 0x0e
    c330:	2d b7       	in	r18, 0x3d	; 61
    c332:	3e b7       	in	r19, 0x3e	; 62
    c334:	2a 5f       	subi	r18, 0xFA	; 250
    c336:	3f 4f       	sbci	r19, 0xFF	; 255
    c338:	0f b6       	in	r0, 0x3f	; 63
    c33a:	f8 94       	cli
    c33c:	3e bf       	out	0x3e, r19	; 62
    c33e:	0f be       	out	0x3f, r0	; 63
    c340:	2d bf       	out	0x3d, r18	; 61
    c342:	04 c0       	rjmp	.+8      	; 0xc34c <go_home+0x582>
							}
							else
							{
								home = home1;
    c344:	8b 87       	std	Y+11, r24	; 0x0b
    c346:	9c 87       	std	Y+12, r25	; 0x0c
    c348:	ad 87       	std	Y+13, r26	; 0x0d
    c34a:	be 87       	std	Y+14, r27	; 0x0e
							}
						}
						
						//Verifico el signo del movimiento anterior
						if (Mov_Roll_Anterior_RAM > 0)// Positivo
    c34c:	8f a1       	ldd	r24, Y+39	; 0x27
    c34e:	98 a5       	ldd	r25, Y+40	; 0x28
    c350:	a9 a5       	ldd	r26, Y+41	; 0x29
    c352:	ba a5       	ldd	r27, Y+42	; 0x2a
    c354:	18 16       	cp	r1, r24
    c356:	19 06       	cpc	r1, r25
    c358:	1a 06       	cpc	r1, r26
    c35a:	1b 06       	cpc	r1, r27
    c35c:	0c f0       	brlt	.+2      	; 0xc360 <go_home+0x596>
    c35e:	6a c0       	rjmp	.+212    	; 0xc434 <go_home+0x66a>
						{
							printf("go_home=> caso Mov_Roll_Anterior_RAM > 0\n");
    c360:	8e e1       	ldi	r24, 0x1E	; 30
    c362:	97 e5       	ldi	r25, 0x57	; 87
    c364:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
							search_home_negative(Axis,&home1,&minPos,FALSE);
    c368:	84 e0       	ldi	r24, 0x04	; 4
    c36a:	90 e0       	ldi	r25, 0x00	; 0
    c36c:	be 01       	movw	r22, r28
    c36e:	61 5f       	subi	r22, 0xF1	; 241
    c370:	7f 4f       	sbci	r23, 0xFF	; 255
    c372:	ae 01       	movw	r20, r28
    c374:	49 5e       	subi	r20, 0xE9	; 233
    c376:	5f 4f       	sbci	r21, 0xFF	; 255
    c378:	20 e0       	ldi	r18, 0x00	; 0
    c37a:	30 e0       	ldi	r19, 0x00	; 0
    c37c:	0e 94 4c 5b 	call	0xb698	; 0xb698 <search_home_negative>
							rad=grados2rad(AJUSTE_ROLL_HOME_NEGA);
    c380:	60 e0       	ldi	r22, 0x00	; 0
    c382:	70 e0       	ldi	r23, 0x00	; 0
    c384:	80 ea       	ldi	r24, 0xA0	; 160
    c386:	91 e4       	ldi	r25, 0x41	; 65
    c388:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <grados2rad>
    c38c:	1b 01       	movw	r2, r22
    c38e:	2c 01       	movw	r4, r24
							Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    c390:	8d e9       	ldi	r24, 0x9D	; 157
    c392:	96 e7       	ldi	r25, 0x76	; 118
    c394:	b2 01       	movw	r22, r4
    c396:	a1 01       	movw	r20, r2
    c398:	0e 94 10 29 	call	0x5220	; 0x5220 <rad2usteps>
    c39c:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    c3a0:	7b 01       	movw	r14, r22
    c3a2:	8c 01       	movw	r16, r24
							printf("go_home=> Factor de correcion %s (search_home_negative) en uPasos = %ld\n",AxisName(Axis),Correcion);
    c3a4:	84 e0       	ldi	r24, 0x04	; 4
    c3a6:	90 e0       	ldi	r25, 0x00	; 0
    c3a8:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    c3ac:	ad b7       	in	r26, 0x3d	; 61
    c3ae:	be b7       	in	r27, 0x3e	; 62
    c3b0:	18 97       	sbiw	r26, 0x08	; 8
    c3b2:	0f b6       	in	r0, 0x3f	; 63
    c3b4:	f8 94       	cli
    c3b6:	be bf       	out	0x3e, r27	; 62
    c3b8:	0f be       	out	0x3f, r0	; 63
    c3ba:	ad bf       	out	0x3d, r26	; 61
    c3bc:	ed b7       	in	r30, 0x3d	; 61
    c3be:	fe b7       	in	r31, 0x3e	; 62
    c3c0:	31 96       	adiw	r30, 0x01	; 1
    c3c2:	2e ee       	ldi	r18, 0xEE	; 238
    c3c4:	35 e5       	ldi	r19, 0x55	; 85
    c3c6:	12 96       	adiw	r26, 0x02	; 2
    c3c8:	3c 93       	st	X, r19
    c3ca:	2e 93       	st	-X, r18
    c3cc:	11 97       	sbiw	r26, 0x01	; 1
    c3ce:	93 83       	std	Z+3, r25	; 0x03
    c3d0:	82 83       	std	Z+2, r24	; 0x02
    c3d2:	e4 82       	std	Z+4, r14	; 0x04
    c3d4:	f5 82       	std	Z+5, r15	; 0x05
    c3d6:	06 83       	std	Z+6, r16	; 0x06
    c3d8:	17 83       	std	Z+7, r17	; 0x07
    c3da:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
							printf("go_home=> home1 = %ld\n",home1);
    c3de:	0f 90       	pop	r0
    c3e0:	0f 90       	pop	r0
    c3e2:	e7 e3       	ldi	r30, 0x37	; 55
    c3e4:	f6 e5       	ldi	r31, 0x56	; 86
    c3e6:	ad b7       	in	r26, 0x3d	; 61
    c3e8:	be b7       	in	r27, 0x3e	; 62
    c3ea:	12 96       	adiw	r26, 0x02	; 2
    c3ec:	fc 93       	st	X, r31
    c3ee:	ee 93       	st	-X, r30
    c3f0:	11 97       	sbiw	r26, 0x01	; 1
    c3f2:	8f 85       	ldd	r24, Y+15	; 0x0f
    c3f4:	98 89       	ldd	r25, Y+16	; 0x10
    c3f6:	a9 89       	ldd	r26, Y+17	; 0x11
    c3f8:	ba 89       	ldd	r27, Y+18	; 0x12
    c3fa:	ed b7       	in	r30, 0x3d	; 61
    c3fc:	fe b7       	in	r31, 0x3e	; 62
    c3fe:	83 83       	std	Z+3, r24	; 0x03
    c400:	94 83       	std	Z+4, r25	; 0x04
    c402:	a5 83       	std	Z+5, r26	; 0x05
    c404:	b6 83       	std	Z+6, r27	; 0x06
    c406:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
							home = home1-Correcion;		
    c40a:	8f 85       	ldd	r24, Y+15	; 0x0f
    c40c:	98 89       	ldd	r25, Y+16	; 0x10
    c40e:	a9 89       	ldd	r26, Y+17	; 0x11
    c410:	ba 89       	ldd	r27, Y+18	; 0x12
    c412:	8e 19       	sub	r24, r14
    c414:	9f 09       	sbc	r25, r15
    c416:	a0 0b       	sbc	r26, r16
    c418:	b1 0b       	sbc	r27, r17
    c41a:	8b 87       	std	Y+11, r24	; 0x0b
    c41c:	9c 87       	std	Y+12, r25	; 0x0c
    c41e:	ad 87       	std	Y+13, r26	; 0x0d
    c420:	be 87       	std	Y+14, r27	; 0x0e
    c422:	2d b7       	in	r18, 0x3d	; 61
    c424:	3e b7       	in	r19, 0x3e	; 62
    c426:	2a 5f       	subi	r18, 0xFA	; 250
    c428:	3f 4f       	sbci	r19, 0xFF	; 255
    c42a:	0f b6       	in	r0, 0x3f	; 63
    c42c:	f8 94       	cli
    c42e:	3e bf       	out	0x3e, r19	; 62
    c430:	0f be       	out	0x3f, r0	; 63
    c432:	2d bf       	out	0x3d, r18	; 61
							
						}
						
						if (Mov_Roll_Anterior_RAM < 0) // Negativo
    c434:	8f a1       	ldd	r24, Y+39	; 0x27
    c436:	98 a5       	ldd	r25, Y+40	; 0x28
    c438:	a9 a5       	ldd	r26, Y+41	; 0x29
    c43a:	ba a5       	ldd	r27, Y+42	; 0x2a
    c43c:	b7 ff       	sbrs	r27, 7
    c43e:	6a c0       	rjmp	.+212    	; 0xc514 <go_home+0x74a>
						{
							printf("go_home=> caso Mov_Roll_Anterior_RAM < 0\n");
    c440:	87 e4       	ldi	r24, 0x47	; 71
    c442:	97 e5       	ldi	r25, 0x57	; 87
    c444:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
							search_home_positive(Axis,&home1,&maxPos,FALSE);
    c448:	84 e0       	ldi	r24, 0x04	; 4
    c44a:	90 e0       	ldi	r25, 0x00	; 0
    c44c:	be 01       	movw	r22, r28
    c44e:	61 5f       	subi	r22, 0xF1	; 241
    c450:	7f 4f       	sbci	r23, 0xFF	; 255
    c452:	ae 01       	movw	r20, r28
    c454:	45 5e       	subi	r20, 0xE5	; 229
    c456:	5f 4f       	sbci	r21, 0xFF	; 255
    c458:	20 e0       	ldi	r18, 0x00	; 0
    c45a:	30 e0       	ldi	r19, 0x00	; 0
    c45c:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <search_home_positive>
							rad=grados2rad(AJUSTE_ROLL_HOME_POSI);
    c460:	60 e0       	ldi	r22, 0x00	; 0
    c462:	70 e0       	ldi	r23, 0x00	; 0
    c464:	80 e0       	ldi	r24, 0x00	; 0
    c466:	91 ec       	ldi	r25, 0xC1	; 193
    c468:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <grados2rad>
    c46c:	1b 01       	movw	r2, r22
    c46e:	2c 01       	movw	r4, r24
							Correcion=rad2usteps(&hAxis[Axis].axisSettings,rad);
    c470:	8d e9       	ldi	r24, 0x9D	; 157
    c472:	96 e7       	ldi	r25, 0x76	; 118
    c474:	b2 01       	movw	r22, r4
    c476:	a1 01       	movw	r20, r2
    c478:	0e 94 10 29 	call	0x5220	; 0x5220 <rad2usteps>
    c47c:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    c480:	7b 01       	movw	r14, r22
    c482:	8c 01       	movw	r16, r24
							printf("go_home=> Factor de correcion %s (search_home_positive) en uPasos = %ld\n",AxisName(Axis),Correcion);
    c484:	84 e0       	ldi	r24, 0x04	; 4
    c486:	90 e0       	ldi	r25, 0x00	; 0
    c488:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    c48c:	ad b7       	in	r26, 0x3d	; 61
    c48e:	be b7       	in	r27, 0x3e	; 62
    c490:	18 97       	sbiw	r26, 0x08	; 8
    c492:	0f b6       	in	r0, 0x3f	; 63
    c494:	f8 94       	cli
    c496:	be bf       	out	0x3e, r27	; 62
    c498:	0f be       	out	0x3f, r0	; 63
    c49a:	ad bf       	out	0x3d, r26	; 61
    c49c:	ed b7       	in	r30, 0x3d	; 61
    c49e:	fe b7       	in	r31, 0x3e	; 62
    c4a0:	31 96       	adiw	r30, 0x01	; 1
    c4a2:	2e e4       	ldi	r18, 0x4E	; 78
    c4a4:	36 e5       	ldi	r19, 0x56	; 86
    c4a6:	12 96       	adiw	r26, 0x02	; 2
    c4a8:	3c 93       	st	X, r19
    c4aa:	2e 93       	st	-X, r18
    c4ac:	11 97       	sbiw	r26, 0x01	; 1
    c4ae:	93 83       	std	Z+3, r25	; 0x03
    c4b0:	82 83       	std	Z+2, r24	; 0x02
    c4b2:	e4 82       	std	Z+4, r14	; 0x04
    c4b4:	f5 82       	std	Z+5, r15	; 0x05
    c4b6:	06 83       	std	Z+6, r16	; 0x06
    c4b8:	17 83       	std	Z+7, r17	; 0x07
    c4ba:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
							printf("go_home=> home1 = %ld\n",home1);
    c4be:	0f 90       	pop	r0
    c4c0:	0f 90       	pop	r0
    c4c2:	e7 e3       	ldi	r30, 0x37	; 55
    c4c4:	f6 e5       	ldi	r31, 0x56	; 86
    c4c6:	ad b7       	in	r26, 0x3d	; 61
    c4c8:	be b7       	in	r27, 0x3e	; 62
    c4ca:	12 96       	adiw	r26, 0x02	; 2
    c4cc:	fc 93       	st	X, r31
    c4ce:	ee 93       	st	-X, r30
    c4d0:	11 97       	sbiw	r26, 0x01	; 1
    c4d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    c4d4:	98 89       	ldd	r25, Y+16	; 0x10
    c4d6:	a9 89       	ldd	r26, Y+17	; 0x11
    c4d8:	ba 89       	ldd	r27, Y+18	; 0x12
    c4da:	ed b7       	in	r30, 0x3d	; 61
    c4dc:	fe b7       	in	r31, 0x3e	; 62
    c4de:	83 83       	std	Z+3, r24	; 0x03
    c4e0:	94 83       	std	Z+4, r25	; 0x04
    c4e2:	a5 83       	std	Z+5, r26	; 0x05
    c4e4:	b6 83       	std	Z+6, r27	; 0x06
    c4e6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
							home = home1+Correcion;		
    c4ea:	8f 85       	ldd	r24, Y+15	; 0x0f
    c4ec:	98 89       	ldd	r25, Y+16	; 0x10
    c4ee:	a9 89       	ldd	r26, Y+17	; 0x11
    c4f0:	ba 89       	ldd	r27, Y+18	; 0x12
    c4f2:	8e 0d       	add	r24, r14
    c4f4:	9f 1d       	adc	r25, r15
    c4f6:	a0 1f       	adc	r26, r16
    c4f8:	b1 1f       	adc	r27, r17
    c4fa:	8b 87       	std	Y+11, r24	; 0x0b
    c4fc:	9c 87       	std	Y+12, r25	; 0x0c
    c4fe:	ad 87       	std	Y+13, r26	; 0x0d
    c500:	be 87       	std	Y+14, r27	; 0x0e
    c502:	2d b7       	in	r18, 0x3d	; 61
    c504:	3e b7       	in	r19, 0x3e	; 62
    c506:	2a 5f       	subi	r18, 0xFA	; 250
    c508:	3f 4f       	sbci	r19, 0xFF	; 255
    c50a:	0f b6       	in	r0, 0x3f	; 63
    c50c:	f8 94       	cli
    c50e:	3e bf       	out	0x3e, r19	; 62
    c510:	0f be       	out	0x3f, r0	; 63
    c512:	2d bf       	out	0x3d, r18	; 61
		//-----------------------------------------------------------------------------------------------------
		//Mover el eje al home encontrado + la correcion.
		//Necesitamos que el concodificador tenga el valor de home para los calculos de PMDAdjustActualPosition.
		//-----------------------------------------------------------------------------------------------------
		#ifdef DEBUGROBOTICS_HOME
		printf("go_home=> El valor de home encontrado! del eje %s = %ld. \n ",AxisName(Axis),home);
    c514:	c3 01       	movw	r24, r6
    c516:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    c51a:	ad b7       	in	r26, 0x3d	; 61
    c51c:	be b7       	in	r27, 0x3e	; 62
    c51e:	18 97       	sbiw	r26, 0x08	; 8
    c520:	0f b6       	in	r0, 0x3f	; 63
    c522:	f8 94       	cli
    c524:	be bf       	out	0x3e, r27	; 62
    c526:	0f be       	out	0x3f, r0	; 63
    c528:	ad bf       	out	0x3d, r26	; 61
    c52a:	ed b7       	in	r30, 0x3d	; 61
    c52c:	fe b7       	in	r31, 0x3e	; 62
    c52e:	31 96       	adiw	r30, 0x01	; 1
    c530:	20 e7       	ldi	r18, 0x70	; 112
    c532:	37 e5       	ldi	r19, 0x57	; 87
    c534:	12 96       	adiw	r26, 0x02	; 2
    c536:	3c 93       	st	X, r19
    c538:	2e 93       	st	-X, r18
    c53a:	11 97       	sbiw	r26, 0x01	; 1
    c53c:	93 83       	std	Z+3, r25	; 0x03
    c53e:	82 83       	std	Z+2, r24	; 0x02
    c540:	8b 85       	ldd	r24, Y+11	; 0x0b
    c542:	9c 85       	ldd	r25, Y+12	; 0x0c
    c544:	ad 85       	ldd	r26, Y+13	; 0x0d
    c546:	be 85       	ldd	r27, Y+14	; 0x0e
    c548:	84 83       	std	Z+4, r24	; 0x04
    c54a:	95 83       	std	Z+5, r25	; 0x05
    c54c:	a6 83       	std	Z+6, r26	; 0x06
    c54e:	b7 83       	std	Z+7, r27	; 0x07
    c550:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("go_home=> Moviendo el Eje %s hacia home \n ",AxisName(Axis));
    c554:	8d b7       	in	r24, 0x3d	; 61
    c556:	9e b7       	in	r25, 0x3e	; 62
    c558:	08 96       	adiw	r24, 0x08	; 8
    c55a:	0f b6       	in	r0, 0x3f	; 63
    c55c:	f8 94       	cli
    c55e:	9e bf       	out	0x3e, r25	; 62
    c560:	0f be       	out	0x3f, r0	; 63
    c562:	8d bf       	out	0x3d, r24	; 61
    c564:	c3 01       	movw	r24, r6
    c566:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    c56a:	00 d0       	rcall	.+0      	; 0xc56c <go_home+0x7a2>
    c56c:	00 d0       	rcall	.+0      	; 0xc56e <go_home+0x7a4>
    c56e:	ec ea       	ldi	r30, 0xAC	; 172
    c570:	f7 e5       	ldi	r31, 0x57	; 87
    c572:	ad b7       	in	r26, 0x3d	; 61
    c574:	be b7       	in	r27, 0x3e	; 62
    c576:	12 96       	adiw	r26, 0x02	; 2
    c578:	fc 93       	st	X, r31
    c57a:	ee 93       	st	-X, r30
    c57c:	11 97       	sbiw	r26, 0x01	; 1
    c57e:	14 96       	adiw	r26, 0x04	; 4
    c580:	9c 93       	st	X, r25
    c582:	8e 93       	st	-X, r24
    c584:	13 97       	sbiw	r26, 0x03	; 3
    c586:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		//scanf("%d",&test);
		#endif
		if(home!=INF)
    c58a:	8b 84       	ldd	r8, Y+11	; 0x0b
    c58c:	9c 84       	ldd	r9, Y+12	; 0x0c
    c58e:	ad 84       	ldd	r10, Y+13	; 0x0d
    c590:	be 84       	ldd	r11, Y+14	; 0x0e
    c592:	0f 90       	pop	r0
    c594:	0f 90       	pop	r0
    c596:	0f 90       	pop	r0
    c598:	0f 90       	pop	r0
    c59a:	ff ef       	ldi	r31, 0xFF	; 255
    c59c:	8f 16       	cp	r8, r31
    c59e:	ff ef       	ldi	r31, 0xFF	; 255
    c5a0:	9f 06       	cpc	r9, r31
    c5a2:	ff ef       	ldi	r31, 0xFF	; 255
    c5a4:	af 06       	cpc	r10, r31
    c5a6:	ff e7       	ldi	r31, 0x7F	; 127
    c5a8:	bf 06       	cpc	r11, r31
    c5aa:	09 f4       	brne	.+2      	; 0xc5ae <go_home+0x7e4>
    c5ac:	5f c0       	rjmp	.+190    	; 0xc66c <go_home+0x8a2>
		{
			switch (Axis)
    c5ae:	23 e0       	ldi	r18, 0x03	; 3
    c5b0:	62 16       	cp	r6, r18
    c5b2:	71 04       	cpc	r7, r1
    c5b4:	29 f0       	breq	.+10     	; 0xc5c0 <go_home+0x7f6>
    c5b6:	34 e0       	ldi	r19, 0x04	; 4
    c5b8:	63 16       	cp	r6, r19
    c5ba:	71 04       	cpc	r7, r1
    c5bc:	c9 f5       	brne	.+114    	; 0xc630 <go_home+0x866>
    c5be:	1c c0       	rjmp	.+56     	; 0xc5f8 <go_home+0x82e>
			{
				case (AxisPitch):	
					pitch(home,hAxis[Axis].axisSettings.homeVelocity,
    c5c0:	20 91 79 76 	lds	r18, 0x7679
    c5c4:	30 91 7a 76 	lds	r19, 0x767A
    c5c8:	40 91 7b 76 	lds	r20, 0x767B
    c5cc:	50 91 7c 76 	lds	r21, 0x767C
    c5d0:	e0 90 7d 76 	lds	r14, 0x767D
    c5d4:	f0 90 7e 76 	lds	r15, 0x767E
    c5d8:	00 91 7f 76 	lds	r16, 0x767F
    c5dc:	10 91 80 76 	lds	r17, 0x7680
    c5e0:	c5 01       	movw	r24, r10
    c5e2:	b4 01       	movw	r22, r8
    c5e4:	e0 ef       	ldi	r30, 0xF0	; 240
    c5e6:	ce 2e       	mov	r12, r30
    c5e8:	ef ef       	ldi	r30, 0xFF	; 255
    c5ea:	de 2e       	mov	r13, r30
    c5ec:	b2 e0       	ldi	r27, 0x02	; 2
    c5ee:	ab 2e       	mov	r10, r27
    c5f0:	b1 2c       	mov	r11, r1
    c5f2:	0e 94 78 52 	call	0xa4f0	; 0xa4f0 <pitch>
    c5f6:	3a c0       	rjmp	.+116    	; 0xc66c <go_home+0x8a2>
						hAxis[Axis].axisSettings.homeAcceleration,update,MOVIMIENTO_HACIA_HOME ); 
				break;
				case (AxisRoll):
					roll(home,hAxis[Axis].axisSettings.homeVelocity,
    c5f8:	20 91 d9 76 	lds	r18, 0x76D9
    c5fc:	30 91 da 76 	lds	r19, 0x76DA
    c600:	40 91 db 76 	lds	r20, 0x76DB
    c604:	50 91 dc 76 	lds	r21, 0x76DC
    c608:	e0 90 dd 76 	lds	r14, 0x76DD
    c60c:	f0 90 de 76 	lds	r15, 0x76DE
    c610:	00 91 df 76 	lds	r16, 0x76DF
    c614:	10 91 e0 76 	lds	r17, 0x76E0
    c618:	c5 01       	movw	r24, r10
    c61a:	b4 01       	movw	r22, r8
    c61c:	a0 ef       	ldi	r26, 0xF0	; 240
    c61e:	ca 2e       	mov	r12, r26
    c620:	af ef       	ldi	r26, 0xFF	; 255
    c622:	da 2e       	mov	r13, r26
    c624:	f2 e0       	ldi	r31, 0x02	; 2
    c626:	af 2e       	mov	r10, r31
    c628:	b1 2c       	mov	r11, r1
    c62a:	0e 94 1b 50 	call	0xa036	; 0xa036 <roll>
    c62e:	1e c0       	rjmp	.+60     	; 0xc66c <go_home+0x8a2>
						hAxis[Axis].axisSettings.homeAcceleration,update,MOVIMIENTO_HACIA_HOME );	
				break;
				default:
					mov_axis(Axis,home,hAxis[Axis].axisSettings.homeVelocity,
    c630:	80 e6       	ldi	r24, 0x60	; 96
    c632:	90 e0       	ldi	r25, 0x00	; 0
    c634:	68 9e       	mul	r6, r24
    c636:	f0 01       	movw	r30, r0
    c638:	69 9e       	mul	r6, r25
    c63a:	f0 0d       	add	r31, r0
    c63c:	78 9e       	mul	r7, r24
    c63e:	f0 0d       	add	r31, r0
    c640:	11 24       	eor	r1, r1
    c642:	e7 5e       	subi	r30, 0xE7	; 231
    c644:	fa 48       	sbci	r31, 0x8A	; 138
    c646:	e0 5c       	subi	r30, 0xC0	; 192
    c648:	ff 4f       	sbci	r31, 0xFF	; 255
    c64a:	01 91       	ld	r16, Z+
    c64c:	11 91       	ld	r17, Z+
    c64e:	21 91       	ld	r18, Z+
    c650:	31 91       	ld	r19, Z+
    c652:	c0 80       	ld	r12, Z
    c654:	d1 80       	ldd	r13, Z+1	; 0x01
    c656:	e2 80       	ldd	r14, Z+2	; 0x02
    c658:	f3 80       	ldd	r15, Z+3	; 0x03
    c65a:	c3 01       	movw	r24, r6
    c65c:	b5 01       	movw	r22, r10
    c65e:	a4 01       	movw	r20, r8
    c660:	e0 ef       	ldi	r30, 0xF0	; 240
    c662:	ae 2e       	mov	r10, r30
    c664:	ef ef       	ldi	r30, 0xFF	; 255
    c666:	be 2e       	mov	r11, r30
    c668:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
							hAxis[Axis].axisSettings.homeAcceleration,update); 
				break;
			}
		}	
		// se reinician las variables de Busqueda home1 y home2
		home1=INF;
    c66c:	8f ef       	ldi	r24, 0xFF	; 255
    c66e:	9f ef       	ldi	r25, 0xFF	; 255
    c670:	af ef       	ldi	r26, 0xFF	; 255
    c672:	bf e7       	ldi	r27, 0x7F	; 127
    c674:	8f 87       	std	Y+15, r24	; 0x0f
    c676:	98 8b       	std	Y+16, r25	; 0x10
    c678:	a9 8b       	std	Y+17, r26	; 0x11
    c67a:	ba 8b       	std	Y+18, r27	; 0x12
		home2=INF;
    c67c:	8b 8b       	std	Y+19, r24	; 0x13
    c67e:	9c 8b       	std	Y+20, r25	; 0x14
    c680:	ad 8b       	std	Y+21, r26	; 0x15
    c682:	be 8b       	std	Y+22, r27	; 0x16
		
		//-----------------------------------------------------------------------------------------------------
		//Informacion del movimiento al llegar home + correccion.
		//-----------------------------------------------------------------------------------------------------
		#ifdef DEBUGROBOTICS_HOME
		printf("go_home=> Informacion del movimiento antes de AJUSTAR! \n ");
    c684:	00 d0       	rcall	.+0      	; 0xc686 <go_home+0x8bc>
    c686:	e7 ed       	ldi	r30, 0xD7	; 215
    c688:	f7 e5       	ldi	r31, 0x57	; 87
    c68a:	ad b7       	in	r26, 0x3d	; 61
    c68c:	be b7       	in	r27, 0x3e	; 62
    c68e:	12 96       	adiw	r26, 0x02	; 2
    c690:	fc 93       	st	X, r31
    c692:	ee 93       	st	-X, r30
    c694:	11 97       	sbiw	r26, 0x01	; 1
    c696:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		infomov(Axis,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    c69a:	00 d0       	rcall	.+0      	; 0xc69c <go_home+0x8d2>
    c69c:	00 d0       	rcall	.+0      	; 0xc69e <go_home+0x8d4>
    c69e:	ed b7       	in	r30, 0x3d	; 61
    c6a0:	fe b7       	in	r31, 0x3e	; 62
    c6a2:	31 96       	adiw	r30, 0x01	; 1
    c6a4:	2f e1       	ldi	r18, 0x1F	; 31
    c6a6:	30 e0       	ldi	r19, 0x00	; 0
    c6a8:	2c 0f       	add	r18, r28
    c6aa:	3d 1f       	adc	r19, r29
    c6ac:	ad b7       	in	r26, 0x3d	; 61
    c6ae:	be b7       	in	r27, 0x3e	; 62
    c6b0:	12 96       	adiw	r26, 0x02	; 2
    c6b2:	3c 93       	st	X, r19
    c6b4:	2e 93       	st	-X, r18
    c6b6:	11 97       	sbiw	r26, 0x01	; 1
    c6b8:	85 e0       	ldi	r24, 0x05	; 5
    c6ba:	90 e0       	ldi	r25, 0x00	; 0
    c6bc:	8c 0f       	add	r24, r28
    c6be:	9d 1f       	adc	r25, r29
    c6c0:	93 83       	std	Z+3, r25	; 0x03
    c6c2:	82 83       	std	Z+2, r24	; 0x02
    c6c4:	a7 e0       	ldi	r26, 0x07	; 7
    c6c6:	b0 e0       	ldi	r27, 0x00	; 0
    c6c8:	ac 0f       	add	r26, r28
    c6ca:	bd 1f       	adc	r27, r29
    c6cc:	b5 83       	std	Z+5, r27	; 0x05
    c6ce:	a4 83       	std	Z+4, r26	; 0x04
    c6d0:	c3 01       	movw	r24, r6
    c6d2:	be 01       	movw	r22, r28
    c6d4:	65 5d       	subi	r22, 0xD5	; 213
    c6d6:	7f 4f       	sbci	r23, 0xFF	; 255
    c6d8:	ae 01       	movw	r20, r28
    c6da:	41 5d       	subi	r20, 0xD1	; 209
    c6dc:	5f 4f       	sbci	r21, 0xFF	; 255
    c6de:	9e 01       	movw	r18, r28
    c6e0:	2d 5b       	subi	r18, 0xBD	; 189
    c6e2:	3f 4f       	sbci	r19, 0xFF	; 255
    c6e4:	8e 01       	movw	r16, r28
    c6e6:	09 5b       	subi	r16, 0xB9	; 185
    c6e8:	1f 4f       	sbci	r17, 0xFF	; 255
    c6ea:	b3 e3       	ldi	r27, 0x33	; 51
    c6ec:	eb 2e       	mov	r14, r27
    c6ee:	f1 2c       	mov	r15, r1
    c6f0:	ec 0e       	add	r14, r28
    c6f2:	fd 1e       	adc	r15, r29
    c6f4:	a7 e3       	ldi	r26, 0x37	; 55
    c6f6:	ca 2e       	mov	r12, r26
    c6f8:	d1 2c       	mov	r13, r1
    c6fa:	cc 0e       	add	r12, r28
    c6fc:	dd 1e       	adc	r13, r29
    c6fe:	fb e3       	ldi	r31, 0x3B	; 59
    c700:	af 2e       	mov	r10, r31
    c702:	b1 2c       	mov	r11, r1
    c704:	ac 0e       	add	r10, r28
    c706:	bd 1e       	adc	r11, r29
    c708:	ef e3       	ldi	r30, 0x3F	; 63
    c70a:	8e 2e       	mov	r8, r30
    c70c:	91 2c       	mov	r9, r1
    c70e:	8c 0e       	add	r8, r28
    c710:	9d 1e       	adc	r9, r29
    c712:	0e 94 05 6d 	call	0xda0a	; 0xda0a <infomov>
				&commandedvelocity, &commandedacceleration, &readencoder1, &readerror,&cuentas_encoder,
				&micropasos);
		if(Axis==AxisRoll)
    c716:	ed b7       	in	r30, 0x3d	; 61
    c718:	fe b7       	in	r31, 0x3e	; 62
    c71a:	36 96       	adiw	r30, 0x06	; 6
    c71c:	0f b6       	in	r0, 0x3f	; 63
    c71e:	f8 94       	cli
    c720:	fe bf       	out	0x3e, r31	; 62
    c722:	0f be       	out	0x3f, r0	; 63
    c724:	ed bf       	out	0x3d, r30	; 61
    c726:	f4 e0       	ldi	r31, 0x04	; 4
    c728:	6f 16       	cp	r6, r31
    c72a:	71 04       	cpc	r7, r1
    c72c:	f9 f4       	brne	.+62     	; 0xc76c <go_home+0x9a2>
		{
			infomov(AxisPitch,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    c72e:	00 d0       	rcall	.+0      	; 0xc730 <go_home+0x966>
    c730:	00 d0       	rcall	.+0      	; 0xc732 <go_home+0x968>
    c732:	00 d0       	rcall	.+0      	; 0xc734 <go_home+0x96a>
    c734:	ed b7       	in	r30, 0x3d	; 61
    c736:	fe b7       	in	r31, 0x3e	; 62
    c738:	31 96       	adiw	r30, 0x01	; 1
    c73a:	2f e1       	ldi	r18, 0x1F	; 31
    c73c:	30 e0       	ldi	r19, 0x00	; 0
    c73e:	2c 0f       	add	r18, r28
    c740:	3d 1f       	adc	r19, r29
    c742:	ad b7       	in	r26, 0x3d	; 61
    c744:	be b7       	in	r27, 0x3e	; 62
    c746:	12 96       	adiw	r26, 0x02	; 2
    c748:	3c 93       	st	X, r19
    c74a:	2e 93       	st	-X, r18
    c74c:	11 97       	sbiw	r26, 0x01	; 1
    c74e:	85 e0       	ldi	r24, 0x05	; 5
    c750:	90 e0       	ldi	r25, 0x00	; 0
    c752:	8c 0f       	add	r24, r28
    c754:	9d 1f       	adc	r25, r29
    c756:	93 83       	std	Z+3, r25	; 0x03
    c758:	82 83       	std	Z+2, r24	; 0x02
    c75a:	a7 e0       	ldi	r26, 0x07	; 7
    c75c:	b0 e0       	ldi	r27, 0x00	; 0
    c75e:	ac 0f       	add	r26, r28
    c760:	bd 1f       	adc	r27, r29
    c762:	b5 83       	std	Z+5, r27	; 0x05
    c764:	a4 83       	std	Z+4, r26	; 0x04
    c766:	83 e0       	ldi	r24, 0x03	; 3
    c768:	90 e0       	ldi	r25, 0x00	; 0
    c76a:	23 c0       	rjmp	.+70     	; 0xc7b2 <go_home+0x9e8>
			&commandedvelocity, &commandedacceleration, &readencoder1, &readerror,&cuentas_encoder,
			&micropasos);PMDGetPositionError(&hAxis[AxisPitch], &readerror);
		}
		if(Axis==AxisPitch)
    c76c:	f3 e0       	ldi	r31, 0x03	; 3
    c76e:	6f 16       	cp	r6, r31
    c770:	71 04       	cpc	r7, r1
    c772:	09 f0       	breq	.+2      	; 0xc776 <go_home+0x9ac>
    c774:	4f c0       	rjmp	.+158    	; 0xc814 <go_home+0xa4a>
		{
			infomov(AxisRoll,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    c776:	00 d0       	rcall	.+0      	; 0xc778 <go_home+0x9ae>
    c778:	00 d0       	rcall	.+0      	; 0xc77a <go_home+0x9b0>
    c77a:	00 d0       	rcall	.+0      	; 0xc77c <go_home+0x9b2>
    c77c:	ed b7       	in	r30, 0x3d	; 61
    c77e:	fe b7       	in	r31, 0x3e	; 62
    c780:	31 96       	adiw	r30, 0x01	; 1
    c782:	2f e1       	ldi	r18, 0x1F	; 31
    c784:	30 e0       	ldi	r19, 0x00	; 0
    c786:	2c 0f       	add	r18, r28
    c788:	3d 1f       	adc	r19, r29
    c78a:	ad b7       	in	r26, 0x3d	; 61
    c78c:	be b7       	in	r27, 0x3e	; 62
    c78e:	12 96       	adiw	r26, 0x02	; 2
    c790:	3c 93       	st	X, r19
    c792:	2e 93       	st	-X, r18
    c794:	11 97       	sbiw	r26, 0x01	; 1
    c796:	85 e0       	ldi	r24, 0x05	; 5
    c798:	90 e0       	ldi	r25, 0x00	; 0
    c79a:	8c 0f       	add	r24, r28
    c79c:	9d 1f       	adc	r25, r29
    c79e:	93 83       	std	Z+3, r25	; 0x03
    c7a0:	82 83       	std	Z+2, r24	; 0x02
    c7a2:	a7 e0       	ldi	r26, 0x07	; 7
    c7a4:	b0 e0       	ldi	r27, 0x00	; 0
    c7a6:	ac 0f       	add	r26, r28
    c7a8:	bd 1f       	adc	r27, r29
    c7aa:	b5 83       	std	Z+5, r27	; 0x05
    c7ac:	a4 83       	std	Z+4, r26	; 0x04
    c7ae:	84 e0       	ldi	r24, 0x04	; 4
    c7b0:	90 e0       	ldi	r25, 0x00	; 0
    c7b2:	be 01       	movw	r22, r28
    c7b4:	65 5d       	subi	r22, 0xD5	; 213
    c7b6:	7f 4f       	sbci	r23, 0xFF	; 255
    c7b8:	ae 01       	movw	r20, r28
    c7ba:	41 5d       	subi	r20, 0xD1	; 209
    c7bc:	5f 4f       	sbci	r21, 0xFF	; 255
    c7be:	9e 01       	movw	r18, r28
    c7c0:	2d 5b       	subi	r18, 0xBD	; 189
    c7c2:	3f 4f       	sbci	r19, 0xFF	; 255
    c7c4:	8e 01       	movw	r16, r28
    c7c6:	09 5b       	subi	r16, 0xB9	; 185
    c7c8:	1f 4f       	sbci	r17, 0xFF	; 255
    c7ca:	b3 e3       	ldi	r27, 0x33	; 51
    c7cc:	eb 2e       	mov	r14, r27
    c7ce:	f1 2c       	mov	r15, r1
    c7d0:	ec 0e       	add	r14, r28
    c7d2:	fd 1e       	adc	r15, r29
    c7d4:	a7 e3       	ldi	r26, 0x37	; 55
    c7d6:	ca 2e       	mov	r12, r26
    c7d8:	d1 2c       	mov	r13, r1
    c7da:	cc 0e       	add	r12, r28
    c7dc:	dd 1e       	adc	r13, r29
    c7de:	fb e3       	ldi	r31, 0x3B	; 59
    c7e0:	af 2e       	mov	r10, r31
    c7e2:	b1 2c       	mov	r11, r1
    c7e4:	ac 0e       	add	r10, r28
    c7e6:	bd 1e       	adc	r11, r29
    c7e8:	ef e3       	ldi	r30, 0x3F	; 63
    c7ea:	8e 2e       	mov	r8, r30
    c7ec:	91 2c       	mov	r9, r1
    c7ee:	8c 0e       	add	r8, r28
    c7f0:	9d 1e       	adc	r9, r29
    c7f2:	0e 94 05 6d 	call	0xda0a	; 0xda0a <infomov>
			&commandedvelocity, &commandedacceleration, &readencoder1, &readerror,&cuentas_encoder,
			&micropasos);PMDGetPositionError(&hAxis[AxisPitch], &readerror);
    c7f6:	ed b7       	in	r30, 0x3d	; 61
    c7f8:	fe b7       	in	r31, 0x3e	; 62
    c7fa:	36 96       	adiw	r30, 0x06	; 6
    c7fc:	0f b6       	in	r0, 0x3f	; 63
    c7fe:	f8 94       	cli
    c800:	fe bf       	out	0x3e, r31	; 62
    c802:	0f be       	out	0x3f, r0	; 63
    c804:	ed bf       	out	0x3d, r30	; 61
    c806:	89 e3       	ldi	r24, 0x39	; 57
    c808:	96 e7       	ldi	r25, 0x76	; 118
    c80a:	be 01       	movw	r22, r28
    c80c:	61 5e       	subi	r22, 0xE1	; 225
    c80e:	7f 4f       	sbci	r23, 0xFF	; 255
    c810:	0e 94 36 7b 	call	0xf66c	; 0xf66c <PMDGetPositionError>
		//Espero a que los motores de detengan
		//-----------------------------------------------------------------------------------------------------
		do
		{
			//Hallo el El registro de actividad del eje
			PMDGetActivityStatus(&hAxis[Axis],&activity_status);
    c814:	80 e6       	ldi	r24, 0x60	; 96
    c816:	90 e0       	ldi	r25, 0x00	; 0
    c818:	68 9e       	mul	r6, r24
    c81a:	80 01       	movw	r16, r0
    c81c:	69 9e       	mul	r6, r25
    c81e:	10 0d       	add	r17, r0
    c820:	78 9e       	mul	r7, r24
    c822:	10 0d       	add	r17, r0
    c824:	11 24       	eor	r1, r1
    c826:	07 5e       	subi	r16, 0xE7	; 231
    c828:	1a 48       	sbci	r17, 0x8A	; 138
    c82a:	c8 01       	movw	r24, r16
    c82c:	be 01       	movw	r22, r28
    c82e:	6d 5f       	subi	r22, 0xFD	; 253
    c830:	7f 4f       	sbci	r23, 0xFF	; 255
    c832:	0e 94 6f 78 	call	0xf0de	; 0xf0de <PMDGetActivityStatus>
		}
		while ((activity_status & PMDActivityInMotionMask) !=0);
    c836:	8b 81       	ldd	r24, Y+3	; 0x03
    c838:	9c 81       	ldd	r25, Y+4	; 0x04
    c83a:	92 fd       	sbrc	r25, 2
    c83c:	f6 cf       	rjmp	.-20     	; 0xc82a <go_home+0xa60>
		
		
		//-----------------------------------------------------------------------------------------------------
		//Adjustando el Valor home encontrado a Cero
		//-----------------------------------------------------------------------------------------------------
		switch (Axis)
    c83e:	f3 e0       	ldi	r31, 0x03	; 3
    c840:	6f 16       	cp	r6, r31
    c842:	71 04       	cpc	r7, r1
    c844:	51 f0       	breq	.+20     	; 0xc85a <go_home+0xa90>
    c846:	8b 85       	ldd	r24, Y+11	; 0x0b
    c848:	9c 85       	ldd	r25, Y+12	; 0x0c
    c84a:	ad 85       	ldd	r26, Y+13	; 0x0d
    c84c:	be 85       	ldd	r27, Y+14	; 0x0e
    c84e:	24 e0       	ldi	r18, 0x04	; 4
    c850:	62 16       	cp	r6, r18
    c852:	71 04       	cpc	r7, r1
    c854:	09 f0       	breq	.+2      	; 0xc858 <go_home+0xa8e>
    c856:	78 c0       	rjmp	.+240    	; 0xc948 <go_home+0xb7e>
    c858:	25 c0       	rjmp	.+74     	; 0xc8a4 <go_home+0xada>
		{
			case (AxisPitch):	
				//Se coloca home positivo ya que el motor de roll esta invertido con respecto al motor de pitch
				PMDAdjustActualPosition(&hAxis[AxisRoll],home);	
    c85a:	4b 85       	ldd	r20, Y+11	; 0x0b
    c85c:	5c 85       	ldd	r21, Y+12	; 0x0c
    c85e:	6d 85       	ldd	r22, Y+13	; 0x0d
    c860:	7e 85       	ldd	r23, Y+14	; 0x0e
    c862:	89 e9       	ldi	r24, 0x99	; 153
    c864:	96 e7       	ldi	r25, 0x76	; 118
    c866:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>
				#ifdef DEBUGROBOTICS_HOME
				printf("Informacion del movimiento despues de AJUSTAR AxisRoll! \n");
    c86a:	81 e1       	ldi	r24, 0x11	; 17
    c86c:	98 e5       	ldi	r25, 0x58	; 88
    c86e:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
				infomov(AxisRoll,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    c872:	00 d0       	rcall	.+0      	; 0xc874 <go_home+0xaaa>
    c874:	00 d0       	rcall	.+0      	; 0xc876 <go_home+0xaac>
    c876:	00 d0       	rcall	.+0      	; 0xc878 <go_home+0xaae>
    c878:	ed b7       	in	r30, 0x3d	; 61
    c87a:	fe b7       	in	r31, 0x3e	; 62
    c87c:	31 96       	adiw	r30, 0x01	; 1
    c87e:	ce 01       	movw	r24, r28
    c880:	4f 96       	adiw	r24, 0x1f	; 31
    c882:	ad b7       	in	r26, 0x3d	; 61
    c884:	be b7       	in	r27, 0x3e	; 62
    c886:	12 96       	adiw	r26, 0x02	; 2
    c888:	9c 93       	st	X, r25
    c88a:	8e 93       	st	-X, r24
    c88c:	11 97       	sbiw	r26, 0x01	; 1
    c88e:	ce 01       	movw	r24, r28
    c890:	05 96       	adiw	r24, 0x05	; 5
    c892:	93 83       	std	Z+3, r25	; 0x03
    c894:	82 83       	std	Z+2, r24	; 0x02
    c896:	ce 01       	movw	r24, r28
    c898:	07 96       	adiw	r24, 0x07	; 7
    c89a:	95 83       	std	Z+5, r25	; 0x05
    c89c:	84 83       	std	Z+4, r24	; 0x04
    c89e:	84 e0       	ldi	r24, 0x04	; 4
    c8a0:	90 e0       	ldi	r25, 0x00	; 0
    c8a2:	27 c0       	rjmp	.+78     	; 0xc8f2 <go_home+0xb28>
				&micropasos);
			//	scanf("%d",&test);
				#endif
			break;
			case (AxisRoll):
				PMDAdjustActualPosition(&hAxis[AxisPitch],-home);
    c8a4:	44 27       	eor	r20, r20
    c8a6:	55 27       	eor	r21, r21
    c8a8:	ba 01       	movw	r22, r20
    c8aa:	48 1b       	sub	r20, r24
    c8ac:	59 0b       	sbc	r21, r25
    c8ae:	6a 0b       	sbc	r22, r26
    c8b0:	7b 0b       	sbc	r23, r27
    c8b2:	89 e3       	ldi	r24, 0x39	; 57
    c8b4:	96 e7       	ldi	r25, 0x76	; 118
    c8b6:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>
				#ifdef DEBUGROBOTICS_HOME
				printf("Informacion del movimiento despues de AJUSTAR AxisPitch! \n");
    c8ba:	8a e4       	ldi	r24, 0x4A	; 74
    c8bc:	98 e5       	ldi	r25, 0x58	; 88
    c8be:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
				infomov(AxisPitch,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    c8c2:	00 d0       	rcall	.+0      	; 0xc8c4 <go_home+0xafa>
    c8c4:	00 d0       	rcall	.+0      	; 0xc8c6 <go_home+0xafc>
    c8c6:	00 d0       	rcall	.+0      	; 0xc8c8 <go_home+0xafe>
    c8c8:	ed b7       	in	r30, 0x3d	; 61
    c8ca:	fe b7       	in	r31, 0x3e	; 62
    c8cc:	31 96       	adiw	r30, 0x01	; 1
    c8ce:	ce 01       	movw	r24, r28
    c8d0:	4f 96       	adiw	r24, 0x1f	; 31
    c8d2:	ad b7       	in	r26, 0x3d	; 61
    c8d4:	be b7       	in	r27, 0x3e	; 62
    c8d6:	12 96       	adiw	r26, 0x02	; 2
    c8d8:	9c 93       	st	X, r25
    c8da:	8e 93       	st	-X, r24
    c8dc:	11 97       	sbiw	r26, 0x01	; 1
    c8de:	ce 01       	movw	r24, r28
    c8e0:	05 96       	adiw	r24, 0x05	; 5
    c8e2:	93 83       	std	Z+3, r25	; 0x03
    c8e4:	82 83       	std	Z+2, r24	; 0x02
    c8e6:	ce 01       	movw	r24, r28
    c8e8:	07 96       	adiw	r24, 0x07	; 7
    c8ea:	95 83       	std	Z+5, r25	; 0x05
    c8ec:	84 83       	std	Z+4, r24	; 0x04
    c8ee:	83 e0       	ldi	r24, 0x03	; 3
    c8f0:	90 e0       	ldi	r25, 0x00	; 0
    c8f2:	be 01       	movw	r22, r28
    c8f4:	65 5d       	subi	r22, 0xD5	; 213
    c8f6:	7f 4f       	sbci	r23, 0xFF	; 255
    c8f8:	ae 01       	movw	r20, r28
    c8fa:	41 5d       	subi	r20, 0xD1	; 209
    c8fc:	5f 4f       	sbci	r21, 0xFF	; 255
    c8fe:	9e 01       	movw	r18, r28
    c900:	2d 5b       	subi	r18, 0xBD	; 189
    c902:	3f 4f       	sbci	r19, 0xFF	; 255
    c904:	8e 01       	movw	r16, r28
    c906:	09 5b       	subi	r16, 0xB9	; 185
    c908:	1f 4f       	sbci	r17, 0xFF	; 255
    c90a:	b3 e3       	ldi	r27, 0x33	; 51
    c90c:	eb 2e       	mov	r14, r27
    c90e:	f1 2c       	mov	r15, r1
    c910:	ec 0e       	add	r14, r28
    c912:	fd 1e       	adc	r15, r29
    c914:	a7 e3       	ldi	r26, 0x37	; 55
    c916:	ca 2e       	mov	r12, r26
    c918:	d1 2c       	mov	r13, r1
    c91a:	cc 0e       	add	r12, r28
    c91c:	dd 1e       	adc	r13, r29
    c91e:	fb e3       	ldi	r31, 0x3B	; 59
    c920:	af 2e       	mov	r10, r31
    c922:	b1 2c       	mov	r11, r1
    c924:	ac 0e       	add	r10, r28
    c926:	bd 1e       	adc	r11, r29
    c928:	ef e3       	ldi	r30, 0x3F	; 63
    c92a:	8e 2e       	mov	r8, r30
    c92c:	91 2c       	mov	r9, r1
    c92e:	8c 0e       	add	r8, r28
    c930:	9d 1e       	adc	r9, r29
    c932:	0e 94 05 6d 	call	0xda0a	; 0xda0a <infomov>
    c936:	ed b7       	in	r30, 0x3d	; 61
    c938:	fe b7       	in	r31, 0x3e	; 62
    c93a:	36 96       	adiw	r30, 0x06	; 6
    c93c:	0f b6       	in	r0, 0x3f	; 63
    c93e:	f8 94       	cli
    c940:	fe bf       	out	0x3e, r31	; 62
    c942:	0f be       	out	0x3f, r0	; 63
    c944:	ed bf       	out	0x3d, r30	; 61
    c946:	0a c0       	rjmp	.+20     	; 0xc95c <go_home+0xb92>
				&micropasos);
				//scanf("%d",&test);
				#endif
			break;
			default:
				PMDAdjustActualPosition(&hAxis[Axis],-home); 		
    c948:	44 27       	eor	r20, r20
    c94a:	55 27       	eor	r21, r21
    c94c:	ba 01       	movw	r22, r20
    c94e:	48 1b       	sub	r20, r24
    c950:	59 0b       	sbc	r21, r25
    c952:	6a 0b       	sbc	r22, r26
    c954:	7b 0b       	sbc	r23, r27
    c956:	c8 01       	movw	r24, r16
    c958:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>
		
		//-----------------------------------------------------------------------------------------------------
		//Imprimiendo estado del eje despues del ajuste
		//-----------------------------------------------------------------------------------------------------
		#ifdef DEBUGROBOTICS_HOME
		printf("go_home=> Informacion del movimiento despues de AJUSTAR! \n ");
    c95c:	00 d0       	rcall	.+0      	; 0xc95e <go_home+0xb94>
    c95e:	e4 e8       	ldi	r30, 0x84	; 132
    c960:	f8 e5       	ldi	r31, 0x58	; 88
    c962:	ad b7       	in	r26, 0x3d	; 61
    c964:	be b7       	in	r27, 0x3e	; 62
    c966:	12 96       	adiw	r26, 0x02	; 2
    c968:	fc 93       	st	X, r31
    c96a:	ee 93       	st	-X, r30
    c96c:	11 97       	sbiw	r26, 0x01	; 1
    c96e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		infomov(Axis,&position1, &velocity1, &acceleration1, &deceleration, &commandedposition,
    c972:	00 d0       	rcall	.+0      	; 0xc974 <go_home+0xbaa>
    c974:	00 d0       	rcall	.+0      	; 0xc976 <go_home+0xbac>
    c976:	ed b7       	in	r30, 0x3d	; 61
    c978:	fe b7       	in	r31, 0x3e	; 62
    c97a:	31 96       	adiw	r30, 0x01	; 1
    c97c:	ce 01       	movw	r24, r28
    c97e:	4f 96       	adiw	r24, 0x1f	; 31
    c980:	ad b7       	in	r26, 0x3d	; 61
    c982:	be b7       	in	r27, 0x3e	; 62
    c984:	12 96       	adiw	r26, 0x02	; 2
    c986:	9c 93       	st	X, r25
    c988:	8e 93       	st	-X, r24
    c98a:	11 97       	sbiw	r26, 0x01	; 1
    c98c:	ce 01       	movw	r24, r28
    c98e:	05 96       	adiw	r24, 0x05	; 5
    c990:	93 83       	std	Z+3, r25	; 0x03
    c992:	82 83       	std	Z+2, r24	; 0x02
    c994:	ce 01       	movw	r24, r28
    c996:	07 96       	adiw	r24, 0x07	; 7
    c998:	95 83       	std	Z+5, r25	; 0x05
    c99a:	84 83       	std	Z+4, r24	; 0x04
    c99c:	c3 01       	movw	r24, r6
    c99e:	be 01       	movw	r22, r28
    c9a0:	65 5d       	subi	r22, 0xD5	; 213
    c9a2:	7f 4f       	sbci	r23, 0xFF	; 255
    c9a4:	ae 01       	movw	r20, r28
    c9a6:	41 5d       	subi	r20, 0xD1	; 209
    c9a8:	5f 4f       	sbci	r21, 0xFF	; 255
    c9aa:	9e 01       	movw	r18, r28
    c9ac:	2d 5b       	subi	r18, 0xBD	; 189
    c9ae:	3f 4f       	sbci	r19, 0xFF	; 255
    c9b0:	8e 01       	movw	r16, r28
    c9b2:	09 5b       	subi	r16, 0xB9	; 185
    c9b4:	1f 4f       	sbci	r17, 0xFF	; 255
    c9b6:	b3 e3       	ldi	r27, 0x33	; 51
    c9b8:	eb 2e       	mov	r14, r27
    c9ba:	f1 2c       	mov	r15, r1
    c9bc:	ec 0e       	add	r14, r28
    c9be:	fd 1e       	adc	r15, r29
    c9c0:	a7 e3       	ldi	r26, 0x37	; 55
    c9c2:	ca 2e       	mov	r12, r26
    c9c4:	d1 2c       	mov	r13, r1
    c9c6:	cc 0e       	add	r12, r28
    c9c8:	dd 1e       	adc	r13, r29
    c9ca:	fb e3       	ldi	r31, 0x3B	; 59
    c9cc:	af 2e       	mov	r10, r31
    c9ce:	b1 2c       	mov	r11, r1
    c9d0:	ac 0e       	add	r10, r28
    c9d2:	bd 1e       	adc	r11, r29
    c9d4:	ef e3       	ldi	r30, 0x3F	; 63
    c9d6:	8e 2e       	mov	r8, r30
    c9d8:	91 2c       	mov	r9, r1
    c9da:	8c 0e       	add	r8, r28
    c9dc:	9d 1e       	adc	r9, r29
    c9de:	0e 94 05 6d 	call	0xda0a	; 0xda0a <infomov>
				&micropasos);
		#endif
		//-----------------------------------------------------------------------------------------------------
		//Caso especial de Axis == Cintura indica que se acabo el proceso.
		//-----------------------------------------------------------------------------------------------------
		if(Axis==AxisWaist)
    c9e2:	ed b7       	in	r30, 0x3d	; 61
    c9e4:	fe b7       	in	r31, 0x3e	; 62
    c9e6:	36 96       	adiw	r30, 0x06	; 6
    c9e8:	0f b6       	in	r0, 0x3f	; 63
    c9ea:	f8 94       	cli
    c9ec:	fe bf       	out	0x3e, r31	; 62
    c9ee:	0f be       	out	0x3f, r0	; 63
    c9f0:	ed bf       	out	0x3d, r30	; 61
    c9f2:	61 14       	cp	r6, r1
    c9f4:	71 04       	cpc	r7, r1
    c9f6:	99 f4       	brne	.+38     	; 0xca1e <go_home+0xc54>
    c9f8:	09 e1       	ldi	r16, 0x19	; 25
    c9fa:	15 e7       	ldi	r17, 0x75	; 117
    c9fc:	ee 24       	eor	r14, r14
    c9fe:	ff 24       	eor	r15, r15
	

	
	for(Axis=0; Axis < DOF; Axis++) 
	{	
		PMDGetActualPosition(&hAxis[Axis],&encoder);
    ca00:	23 e2       	ldi	r18, 0x23	; 35
    ca02:	82 2e       	mov	r8, r18
    ca04:	91 2c       	mov	r9, r1
    ca06:	8c 0e       	add	r8, r28
    ca08:	9d 1e       	adc	r9, r29
			PMDGetPositionError(&hAxis[Axis], &readerror);
			printf("go_home=> Error de posicion del Eje %s despues del proceso de home = %ld\n",AxisName(Axis),readerror);		
		#endif
		
		PMDAdjustActualPosition(&hAxis[Axis],-encoder); 		
		PMDGetPositionError(&hAxis[Axis], &readerror);
    ca0a:	9f e1       	ldi	r25, 0x1F	; 31
    ca0c:	a9 2e       	mov	r10, r25
    ca0e:	b1 2c       	mov	r11, r1
    ca10:	ac 0e       	add	r10, r28
    ca12:	bd 1e       	adc	r11, r29
		printf("go_home=> Error de posicion del Eje %s al finalizar el proceso de HOME = %ld\n",AxisName(Axis),readerror);		
    ca14:	80 ec       	ldi	r24, 0xC0	; 192
    ca16:	c8 2e       	mov	r12, r24
    ca18:	88 e5       	ldi	r24, 0x58	; 88
    ca1a:	d8 2e       	mov	r13, r24
    ca1c:	09 c0       	rjmp	.+18     	; 0xca30 <go_home+0xc66>
	/* Desactivar las interrupciones generadas por los PMDs*/
	HostInterruptDisable();	
	
	
	
	for(Axis=AxisShoulder; Axis <= DOF; Axis++) 
    ca1e:	08 94       	sec
    ca20:	61 1c       	adc	r6, r1
    ca22:	71 1c       	adc	r7, r1
    ca24:	f6 e0       	ldi	r31, 0x06	; 6
    ca26:	6f 16       	cp	r6, r31
    ca28:	71 04       	cpc	r7, r1
    ca2a:	0c f4       	brge	.+2      	; 0xca2e <go_home+0xc64>
    ca2c:	08 ca       	rjmp	.-3056   	; 0xbe3e <go_home+0x74>
    ca2e:	e4 cf       	rjmp	.-56     	; 0xc9f8 <go_home+0xc2e>
	

	
	for(Axis=0; Axis < DOF; Axis++) 
	{	
		PMDGetActualPosition(&hAxis[Axis],&encoder);
    ca30:	c8 01       	movw	r24, r16
    ca32:	b4 01       	movw	r22, r8
    ca34:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
			printf("go_home=> Posicion Encoder despues del proceso de home del Eje %s es= %ld\n",AxisName(Axis),encoder);		
			PMDGetPositionError(&hAxis[Axis], &readerror);
			printf("go_home=> Error de posicion del Eje %s despues del proceso de home = %ld\n",AxisName(Axis),readerror);		
		#endif
		
		PMDAdjustActualPosition(&hAxis[Axis],-encoder); 		
    ca38:	4b a1       	ldd	r20, Y+35	; 0x23
    ca3a:	5c a1       	ldd	r21, Y+36	; 0x24
    ca3c:	6d a1       	ldd	r22, Y+37	; 0x25
    ca3e:	7e a1       	ldd	r23, Y+38	; 0x26
    ca40:	70 95       	com	r23
    ca42:	60 95       	com	r22
    ca44:	50 95       	com	r21
    ca46:	41 95       	neg	r20
    ca48:	5f 4f       	sbci	r21, 0xFF	; 255
    ca4a:	6f 4f       	sbci	r22, 0xFF	; 255
    ca4c:	7f 4f       	sbci	r23, 0xFF	; 255
    ca4e:	c8 01       	movw	r24, r16
    ca50:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>
		PMDGetPositionError(&hAxis[Axis], &readerror);
    ca54:	c8 01       	movw	r24, r16
    ca56:	b5 01       	movw	r22, r10
    ca58:	0e 94 36 7b 	call	0xf66c	; 0xf66c <PMDGetPositionError>
		printf("go_home=> Error de posicion del Eje %s al finalizar el proceso de HOME = %ld\n",AxisName(Axis),readerror);		
    ca5c:	c7 01       	movw	r24, r14
    ca5e:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    ca62:	2d b7       	in	r18, 0x3d	; 61
    ca64:	3e b7       	in	r19, 0x3e	; 62
    ca66:	28 50       	subi	r18, 0x08	; 8
    ca68:	30 40       	sbci	r19, 0x00	; 0
    ca6a:	0f b6       	in	r0, 0x3f	; 63
    ca6c:	f8 94       	cli
    ca6e:	3e bf       	out	0x3e, r19	; 62
    ca70:	0f be       	out	0x3f, r0	; 63
    ca72:	2d bf       	out	0x3d, r18	; 61
    ca74:	ed b7       	in	r30, 0x3d	; 61
    ca76:	fe b7       	in	r31, 0x3e	; 62
    ca78:	31 96       	adiw	r30, 0x01	; 1
    ca7a:	ad b7       	in	r26, 0x3d	; 61
    ca7c:	be b7       	in	r27, 0x3e	; 62
    ca7e:	12 96       	adiw	r26, 0x02	; 2
    ca80:	dc 92       	st	X, r13
    ca82:	ce 92       	st	-X, r12
    ca84:	11 97       	sbiw	r26, 0x01	; 1
    ca86:	93 83       	std	Z+3, r25	; 0x03
    ca88:	82 83       	std	Z+2, r24	; 0x02
    ca8a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    ca8c:	98 a1       	ldd	r25, Y+32	; 0x20
    ca8e:	a9 a1       	ldd	r26, Y+33	; 0x21
    ca90:	ba a1       	ldd	r27, Y+34	; 0x22
    ca92:	84 83       	std	Z+4, r24	; 0x04
    ca94:	95 83       	std	Z+5, r25	; 0x05
    ca96:	a6 83       	std	Z+6, r26	; 0x06
    ca98:	b7 83       	std	Z+7, r27	; 0x07
    ca9a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>


	

	
	for(Axis=0; Axis < DOF; Axis++) 
    ca9e:	08 94       	sec
    caa0:	e1 1c       	adc	r14, r1
    caa2:	f1 1c       	adc	r15, r1
    caa4:	00 5a       	subi	r16, 0xA0	; 160
    caa6:	1f 4f       	sbci	r17, 0xFF	; 255
    caa8:	ed b7       	in	r30, 0x3d	; 61
    caaa:	fe b7       	in	r31, 0x3e	; 62
    caac:	38 96       	adiw	r30, 0x08	; 8
    caae:	0f b6       	in	r0, 0x3f	; 63
    cab0:	f8 94       	cli
    cab2:	fe bf       	out	0x3e, r31	; 62
    cab4:	0f be       	out	0x3f, r0	; 63
    cab6:	ed bf       	out	0x3d, r30	; 61
    cab8:	f5 e0       	ldi	r31, 0x05	; 5
    caba:	ef 16       	cp	r14, r31
    cabc:	f1 04       	cpc	r15, r1
    cabe:	09 f0       	breq	.+2      	; 0xcac2 <go_home+0xcf8>
    cac0:	b7 cf       	rjmp	.-146    	; 0xca30 <go_home+0xc66>
		PMDGetPositionError(&hAxis[Axis], &readerror);
		printf("go_home=> Error de posicion del Eje %s al finalizar el proceso de HOME = %ld\n",AxisName(Axis),readerror);		
	}
	//habilitada las interrupciones hacia el uControlador
	
	HostInterruptEnable();
    cac2:	0e 94 ef 75 	call	0xebde	; 0xebde <HostInterruptEnable>
	
}
    cac6:	c6 5b       	subi	r28, 0xB6	; 182
    cac8:	df 4f       	sbci	r29, 0xFF	; 255
    caca:	0f b6       	in	r0, 0x3f	; 63
    cacc:	f8 94       	cli
    cace:	de bf       	out	0x3e, r29	; 62
    cad0:	0f be       	out	0x3f, r0	; 63
    cad2:	cd bf       	out	0x3d, r28	; 61
    cad4:	cf 91       	pop	r28
    cad6:	df 91       	pop	r29
    cad8:	1f 91       	pop	r17
    cada:	0f 91       	pop	r16
    cadc:	ff 90       	pop	r15
    cade:	ef 90       	pop	r14
    cae0:	df 90       	pop	r13
    cae2:	cf 90       	pop	r12
    cae4:	bf 90       	pop	r11
    cae6:	af 90       	pop	r10
    cae8:	9f 90       	pop	r9
    caea:	8f 90       	pop	r8
    caec:	7f 90       	pop	r7
    caee:	6f 90       	pop	r6
    caf0:	5f 90       	pop	r5
    caf2:	4f 90       	pop	r4
    caf4:	3f 90       	pop	r3
    caf6:	2f 90       	pop	r2
    caf8:	08 95       	ret

0000cafa <initializeAxis>:
	
}

/*****************************************************************************************/ 
PMDresult initializeAxis(int16 Axis) //falta realizar para Pitch & Roll y enviar o guardar los Datos encontrados!!
{
    cafa:	8f 92       	push	r8
    cafc:	9f 92       	push	r9
    cafe:	af 92       	push	r10
    cb00:	bf 92       	push	r11
    cb02:	cf 92       	push	r12
    cb04:	df 92       	push	r13
    cb06:	ef 92       	push	r14
    cb08:	ff 92       	push	r15
    cb0a:	0f 93       	push	r16
    cb0c:	1f 93       	push	r17
    cb0e:	df 93       	push	r29
    cb10:	cf 93       	push	r28
    cb12:	cd b7       	in	r28, 0x3d	; 61
    cb14:	de b7       	in	r29, 0x3e	; 62
    cb16:	60 97       	sbiw	r28, 0x10	; 16
    cb18:	0f b6       	in	r0, 0x3f	; 63
    cb1a:	f8 94       	cli
    cb1c:	de bf       	out	0x3e, r29	; 62
    cb1e:	0f be       	out	0x3f, r0	; 63
    cb20:	cd bf       	out	0x3d, r28	; 61
    cb22:	4c 01       	movw	r8, r24
	PMDuint16 rc = rcOK;
	
	PMDint32 home=0,home1=INF,home2=INF,minPos,maxPos;
    cb24:	8f ef       	ldi	r24, 0xFF	; 255
    cb26:	9f ef       	ldi	r25, 0xFF	; 255
    cb28:	af ef       	ldi	r26, 0xFF	; 255
    cb2a:	bf e7       	ldi	r27, 0x7F	; 127
    cb2c:	89 83       	std	Y+1, r24	; 0x01
    cb2e:	9a 83       	std	Y+2, r25	; 0x02
    cb30:	ab 83       	std	Y+3, r26	; 0x03
    cb32:	bc 83       	std	Y+4, r27	; 0x04
    cb34:	8d 83       	std	Y+5, r24	; 0x05
    cb36:	9e 83       	std	Y+6, r25	; 0x06
    cb38:	af 83       	std	Y+7, r26	; 0x07
    cb3a:	b8 87       	std	Y+8, r27	; 0x08
		int16 temp1;
	#endif		


    // Deshabilitada las interrupciones hacia el uControlador
	HostInterruptDisable();							
    cb3c:	0e 94 07 76 	call	0xec0e	; 0xec0e <HostInterruptDisable>
	//Limpia la Posicion de Error. Posicion_Comandada=Posicion_Acutal
	PMDClearPositionError(&hAxis[Axis]); 			
    cb40:	80 e6       	ldi	r24, 0x60	; 96
    cb42:	90 e0       	ldi	r25, 0x00	; 0
    cb44:	88 9e       	mul	r8, r24
    cb46:	80 01       	movw	r16, r0
    cb48:	89 9e       	mul	r8, r25
    cb4a:	10 0d       	add	r17, r0
    cb4c:	98 9e       	mul	r9, r24
    cb4e:	10 0d       	add	r17, r0
    cb50:	11 24       	eor	r1, r1
    cb52:	07 5e       	subi	r16, 0xE7	; 231
    cb54:	1a 48       	sbci	r17, 0x8A	; 138
    cb56:	c8 01       	movw	r24, r16
    cb58:	0e 94 42 7c 	call	0xf884	; 0xf884 <PMDClearPositionError>
	PMDUpdate(&hAxis[Axis]);
    cb5c:	c8 01       	movw	r24, r16
    cb5e:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>

	printf("initializeAxis=> Inicializado eje %s\n  ",AxisName(Axis));
    cb62:	c4 01       	movw	r24, r8
    cb64:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    cb68:	00 d0       	rcall	.+0      	; 0xcb6a <initializeAxis+0x70>
    cb6a:	00 d0       	rcall	.+0      	; 0xcb6c <initializeAxis+0x72>
    cb6c:	2e e0       	ldi	r18, 0x0E	; 14
    cb6e:	39 e5       	ldi	r19, 0x59	; 89
    cb70:	ed b7       	in	r30, 0x3d	; 61
    cb72:	fe b7       	in	r31, 0x3e	; 62
    cb74:	32 83       	std	Z+2, r19	; 0x02
    cb76:	21 83       	std	Z+1, r18	; 0x01
    cb78:	94 83       	std	Z+4, r25	; 0x04
    cb7a:	83 83       	std	Z+3, r24	; 0x03
    cb7c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	#ifdef DEBUGROBOTICS
	//	scanf("%d",&temp1);
	#endif

	switch(Axis) 
    cb80:	0f 90       	pop	r0
    cb82:	0f 90       	pop	r0
    cb84:	0f 90       	pop	r0
    cb86:	0f 90       	pop	r0
    cb88:	c4 01       	movw	r24, r8
    cb8a:	02 97       	sbiw	r24, 0x02	; 2
    cb8c:	02 97       	sbiw	r24, 0x02	; 2
    cb8e:	18 f5       	brcc	.+70     	; 0xcbd6 <initializeAxis+0xdc>
	{
		case  (AxisPitch) :
		case  (AxisElbow) : 					
			
			//Si el eje es Pitch se debe limpiar la posicion de error para el motor Roll.
			if(Axis==AxisPitch)
    cb90:	f3 e0       	ldi	r31, 0x03	; 3
    cb92:	8f 16       	cp	r8, r31
    cb94:	91 04       	cpc	r9, r1
    cb96:	41 f4       	brne	.+16     	; 0xcba8 <initializeAxis+0xae>
			{
				PMDClearPositionError(&hAxis[AxisRoll]); 			
    cb98:	89 e9       	ldi	r24, 0x99	; 153
    cb9a:	96 e7       	ldi	r25, 0x76	; 118
    cb9c:	0e 94 42 7c 	call	0xf884	; 0xf884 <PMDClearPositionError>
				PMDUpdate(&hAxis[AxisRoll]);
    cba0:	89 e9       	ldi	r24, 0x99	; 153
    cba2:	96 e7       	ldi	r25, 0x76	; 118
    cba4:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			}
			
		    //Mover el Eje en Direccion Positiva
			search_home_positive(Axis,&home1,&maxPos,TRUE);
    cba8:	c4 01       	movw	r24, r8
    cbaa:	be 01       	movw	r22, r28
    cbac:	6f 5f       	subi	r22, 0xFF	; 255
    cbae:	7f 4f       	sbci	r23, 0xFF	; 255
    cbb0:	ae 01       	movw	r20, r28
    cbb2:	43 5f       	subi	r20, 0xF3	; 243
    cbb4:	5f 4f       	sbci	r21, 0xFF	; 255
    cbb6:	21 e0       	ldi	r18, 0x01	; 1
    cbb8:	30 e0       	ldi	r19, 0x00	; 0
    cbba:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <search_home_positive>
				printf("initializeAxis=> El valor maxPos del eje %s = %ld. \n ",AxisName(Axis),maxPos);
			//	scanf("%d",&temp1);
			#endif			
			
			//Mover el Eje en Direccion Negativa
			search_home_negative(Axis,&home2,&minPos,TRUE);
    cbbe:	c4 01       	movw	r24, r8
    cbc0:	be 01       	movw	r22, r28
    cbc2:	6b 5f       	subi	r22, 0xFB	; 251
    cbc4:	7f 4f       	sbci	r23, 0xFF	; 255
    cbc6:	ae 01       	movw	r20, r28
    cbc8:	47 5f       	subi	r20, 0xF7	; 247
    cbca:	5f 4f       	sbci	r21, 0xFF	; 255
    cbcc:	21 e0       	ldi	r18, 0x01	; 1
    cbce:	30 e0       	ldi	r19, 0x00	; 0
    cbd0:	0e 94 4c 5b 	call	0xb698	; 0xb698 <search_home_negative>
    cbd4:	16 c0       	rjmp	.+44     	; 0xcc02 <initializeAxis+0x108>
			//	scanf("%d",&temp1);
			#endif			
        break;
		default : 					 // just use neg. limit
			//Mover el Eje en Direccion Negativa
			search_home_negative(Axis,&home1,&minPos,TRUE);
    cbd6:	c4 01       	movw	r24, r8
    cbd8:	be 01       	movw	r22, r28
    cbda:	6f 5f       	subi	r22, 0xFF	; 255
    cbdc:	7f 4f       	sbci	r23, 0xFF	; 255
    cbde:	ae 01       	movw	r20, r28
    cbe0:	47 5f       	subi	r20, 0xF7	; 247
    cbe2:	5f 4f       	sbci	r21, 0xFF	; 255
    cbe4:	21 e0       	ldi	r18, 0x01	; 1
    cbe6:	30 e0       	ldi	r19, 0x00	; 0
    cbe8:	0e 94 4c 5b 	call	0xb698	; 0xb698 <search_home_negative>
			#endif
			//PMDResetEventStatus(&hAxis[Axis],~(PMDEventMotionCompleteMask | PMDEventInNegativeLimitMask));	
			//PMDSetMotorMode(&hAxis[Axis],PMDMotorOn); 
					 
			//Mover el Eje en Direccion Positiva
			search_home_positive(Axis,&home2,&maxPos,TRUE);
    cbec:	c4 01       	movw	r24, r8
    cbee:	be 01       	movw	r22, r28
    cbf0:	6b 5f       	subi	r22, 0xFB	; 251
    cbf2:	7f 4f       	sbci	r23, 0xFF	; 255
    cbf4:	ae 01       	movw	r20, r28
    cbf6:	43 5f       	subi	r20, 0xF3	; 243
    cbf8:	5f 4f       	sbci	r21, 0xFF	; 255
    cbfa:	21 e0       	ldi	r18, 0x01	; 1
    cbfc:	30 e0       	ldi	r19, 0x00	; 0
    cbfe:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <search_home_positive>
		break;
	}
	
	
	//------------- depending on the axis configuration, calibrate the HOME value.-----------------
	switch(hAxis[Axis].axisSettings.homeSwitchHandling) 
    cc02:	80 e6       	ldi	r24, 0x60	; 96
    cc04:	90 e0       	ldi	r25, 0x00	; 0
    cc06:	88 9e       	mul	r8, r24
    cc08:	f0 01       	movw	r30, r0
    cc0a:	89 9e       	mul	r8, r25
    cc0c:	f0 0d       	add	r31, r0
    cc0e:	98 9e       	mul	r9, r24
    cc10:	f0 0d       	add	r31, r0
    cc12:	11 24       	eor	r1, r1
    cc14:	e7 5e       	subi	r30, 0xE7	; 231
    cc16:	fa 48       	sbci	r31, 0x8A	; 138
    cc18:	86 8d       	ldd	r24, Z+30	; 0x1e
    cc1a:	97 8d       	ldd	r25, Z+31	; 0x1f
    cc1c:	2f ef       	ldi	r18, 0xFF	; 255
    cc1e:	8f 3f       	cpi	r24, 0xFF	; 255
    cc20:	92 07       	cpc	r25, r18
    cc22:	31 f0       	breq	.+12     	; 0xcc30 <initializeAxis+0x136>
    cc24:	01 97       	sbiw	r24, 0x01	; 1
    cc26:	21 f0       	breq	.+8      	; 0xcc30 <initializeAxis+0x136>
    cc28:	aa 24       	eor	r10, r10
    cc2a:	bb 24       	eor	r11, r11
    cc2c:	65 01       	movw	r12, r10
    cc2e:	04 c0       	rjmp	.+8      	; 0xcc38 <initializeAxis+0x13e>
	{
		case -1 : 
		case  1 : 
			home = home2;            // just use right limit
    cc30:	ad 80       	ldd	r10, Y+5	; 0x05
    cc32:	be 80       	ldd	r11, Y+6	; 0x06
    cc34:	cf 80       	ldd	r12, Y+7	; 0x07
    cc36:	d8 84       	ldd	r13, Y+8	; 0x08
				else					
			//		home = ((home1+home2)/2)-(AJUSTE_HOME2*(hAxis[Axis].axisSettings.ustepsPerStep)); // use medium position
        break;
	}	
	
	hAxis[Axis].axisLimits.minPosition = minPos-home;
    cc38:	80 e6       	ldi	r24, 0x60	; 96
    cc3a:	90 e0       	ldi	r25, 0x00	; 0
    cc3c:	88 9e       	mul	r8, r24
    cc3e:	70 01       	movw	r14, r0
    cc40:	89 9e       	mul	r8, r25
    cc42:	f0 0c       	add	r15, r0
    cc44:	98 9e       	mul	r9, r24
    cc46:	f0 0c       	add	r15, r0
    cc48:	11 24       	eor	r1, r1
    cc4a:	89 e1       	ldi	r24, 0x19	; 25
    cc4c:	95 e7       	ldi	r25, 0x75	; 117
    cc4e:	e8 0e       	add	r14, r24
    cc50:	f9 1e       	adc	r15, r25
    cc52:	e8 e4       	ldi	r30, 0x48	; 72
    cc54:	f0 e0       	ldi	r31, 0x00	; 0
    cc56:	ee 0e       	add	r14, r30
    cc58:	ff 1e       	adc	r15, r31
    cc5a:	89 85       	ldd	r24, Y+9	; 0x09
    cc5c:	9a 85       	ldd	r25, Y+10	; 0x0a
    cc5e:	ab 85       	ldd	r26, Y+11	; 0x0b
    cc60:	bc 85       	ldd	r27, Y+12	; 0x0c
    cc62:	8a 19       	sub	r24, r10
    cc64:	9b 09       	sbc	r25, r11
    cc66:	ac 09       	sbc	r26, r12
    cc68:	bd 09       	sbc	r27, r13
    cc6a:	f7 01       	movw	r30, r14
    cc6c:	81 93       	st	Z+, r24
    cc6e:	91 93       	st	Z+, r25
    cc70:	a1 93       	st	Z+, r26
    cc72:	b1 93       	st	Z+, r27
    cc74:	7f 01       	movw	r14, r30
	hAxis[Axis].axisLimits.maxPosition = maxPos-home;
    cc76:	8d 85       	ldd	r24, Y+13	; 0x0d
    cc78:	9e 85       	ldd	r25, Y+14	; 0x0e
    cc7a:	af 85       	ldd	r26, Y+15	; 0x0f
    cc7c:	b8 89       	ldd	r27, Y+16	; 0x10
    cc7e:	8a 19       	sub	r24, r10
    cc80:	9b 09       	sbc	r25, r11
    cc82:	ac 09       	sbc	r26, r12
    cc84:	bd 09       	sbc	r27, r13
    cc86:	80 83       	st	Z, r24
    cc88:	91 83       	std	Z+1, r25	; 0x01
    cc8a:	a2 83       	std	Z+2, r26	; 0x02
    cc8c:	b3 83       	std	Z+3, r27	; 0x03
    cc8e:	84 eb       	ldi	r24, 0xB4	; 180
    cc90:	9f ef       	ldi	r25, 0xFF	; 255
    cc92:	e8 0e       	add	r14, r24
    cc94:	f9 1e       	adc	r15, r25
	PMDAdjustActualPosition(&hAxis[Axis],-home); 
    cc96:	44 27       	eor	r20, r20
    cc98:	55 27       	eor	r21, r21
    cc9a:	ba 01       	movw	r22, r20
    cc9c:	4a 19       	sub	r20, r10
    cc9e:	5b 09       	sbc	r21, r11
    cca0:	6c 09       	sbc	r22, r12
    cca2:	7d 09       	sbc	r23, r13
    cca4:	c8 01       	movw	r24, r16
    cca6:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>
		printf("initializeAxis=> Valor final para maxPos del eje %s = %ld. \n ",AxisName(Axis),hAxis[Axis].axisLimits.maxPosition);
		printf("initializeAxis=> Valor final para minPos del eje %s = %ld. \n ",AxisName(Axis),hAxis[Axis].axisLimits.minPosition);
		printf("initializeAxis=> Moviendo hacia Home \n ");
	#endif
	
	switch (Axis)
    ccaa:	93 e0       	ldi	r25, 0x03	; 3
    ccac:	89 16       	cp	r8, r25
    ccae:	91 04       	cpc	r9, r1
    ccb0:	21 f5       	brne	.+72     	; 0xccfa <initializeAxis+0x200>
	{
		case (AxisPitch):
			//Se coloca home positivo ya que el motor de roll esta invertido con respecto al motor de pitch
			PMDAdjustActualPosition(&hAxis[AxisRoll],home);
    ccb2:	89 e9       	ldi	r24, 0x99	; 153
    ccb4:	96 e7       	ldi	r25, 0x76	; 118
    ccb6:	b6 01       	movw	r22, r12
    ccb8:	a5 01       	movw	r20, r10
    ccba:	0e 94 82 7e 	call	0xfd04	; 0xfd04 <PMDAdjustActualPosition>
			
			
			pitch(HOME,hAxis[Axis].axisSettings.homeVelocity,
    ccbe:	20 91 79 76 	lds	r18, 0x7679
    ccc2:	30 91 7a 76 	lds	r19, 0x767A
    ccc6:	40 91 7b 76 	lds	r20, 0x767B
    ccca:	50 91 7c 76 	lds	r21, 0x767C
    ccce:	e0 90 7d 76 	lds	r14, 0x767D
    ccd2:	f0 90 7e 76 	lds	r15, 0x767E
    ccd6:	00 91 7f 76 	lds	r16, 0x767F
    ccda:	10 91 80 76 	lds	r17, 0x7680
    ccde:	60 e0       	ldi	r22, 0x00	; 0
    cce0:	70 e0       	ldi	r23, 0x00	; 0
    cce2:	80 e0       	ldi	r24, 0x00	; 0
    cce4:	90 e0       	ldi	r25, 0x00	; 0
    cce6:	a0 ef       	ldi	r26, 0xF0	; 240
    cce8:	ca 2e       	mov	r12, r26
    ccea:	af ef       	ldi	r26, 0xFF	; 255
    ccec:	da 2e       	mov	r13, r26
    ccee:	f3 e0       	ldi	r31, 0x03	; 3
    ccf0:	af 2e       	mov	r10, r31
    ccf2:	b1 2c       	mov	r11, r1
    ccf4:	0e 94 78 52 	call	0xa4f0	; 0xa4f0 <pitch>
    ccf8:	19 c0       	rjmp	.+50     	; 0xcd2c <initializeAxis+0x232>
						hAxis[Axis].axisSettings.homeAcceleration,update,EN_CALIBRACION_PROCESOHOME ); 
		break;
		
		default:
			mov_axis(Axis,HOME,hAxis[Axis].axisSettings.homeVelocity,
    ccfa:	f7 01       	movw	r30, r14
    ccfc:	e0 5c       	subi	r30, 0xC0	; 192
    ccfe:	ff 4f       	sbci	r31, 0xFF	; 255
    cd00:	00 81       	ld	r16, Z
    cd02:	11 81       	ldd	r17, Z+1	; 0x01
    cd04:	22 81       	ldd	r18, Z+2	; 0x02
    cd06:	33 81       	ldd	r19, Z+3	; 0x03
    cd08:	f7 01       	movw	r30, r14
    cd0a:	ec 5b       	subi	r30, 0xBC	; 188
    cd0c:	ff 4f       	sbci	r31, 0xFF	; 255
    cd0e:	c0 80       	ld	r12, Z
    cd10:	d1 80       	ldd	r13, Z+1	; 0x01
    cd12:	e2 80       	ldd	r14, Z+2	; 0x02
    cd14:	f3 80       	ldd	r15, Z+3	; 0x03
    cd16:	c4 01       	movw	r24, r8
    cd18:	40 e0       	ldi	r20, 0x00	; 0
    cd1a:	50 e0       	ldi	r21, 0x00	; 0
    cd1c:	60 e0       	ldi	r22, 0x00	; 0
    cd1e:	70 e0       	ldi	r23, 0x00	; 0
    cd20:	e0 ef       	ldi	r30, 0xF0	; 240
    cd22:	ae 2e       	mov	r10, r30
    cd24:	ef ef       	ldi	r30, 0xFF	; 255
    cd26:	be 2e       	mov	r11, r30
    cd28:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
						hAxis[Axis].axisSettings.homeAcceleration,update); 
	    break;
	}

	//habilitada las interrupciones hacia el uControlador
	HostInterruptEnable();
    cd2c:	0e 94 ef 75 	call	0xebde	; 0xebde <HostInterruptEnable>
	return rc;
	
}
    cd30:	80 e0       	ldi	r24, 0x00	; 0
    cd32:	90 e0       	ldi	r25, 0x00	; 0
    cd34:	60 96       	adiw	r28, 0x10	; 16
    cd36:	0f b6       	in	r0, 0x3f	; 63
    cd38:	f8 94       	cli
    cd3a:	de bf       	out	0x3e, r29	; 62
    cd3c:	0f be       	out	0x3f, r0	; 63
    cd3e:	cd bf       	out	0x3d, r28	; 61
    cd40:	cf 91       	pop	r28
    cd42:	df 91       	pop	r29
    cd44:	1f 91       	pop	r17
    cd46:	0f 91       	pop	r16
    cd48:	ff 90       	pop	r15
    cd4a:	ef 90       	pop	r14
    cd4c:	df 90       	pop	r13
    cd4e:	cf 90       	pop	r12
    cd50:	bf 90       	pop	r11
    cd52:	af 90       	pop	r10
    cd54:	9f 90       	pop	r9
    cd56:	8f 90       	pop	r8
    cd58:	08 95       	ret

0000cd5a <mov_correlacionado>:
//**********************************************************************************************
//Solo carga los registros no efectua movimiento.
//Al mover el EJe1 se tiene que mover proporcionalmente el Eje2
void mov_correlacionado( tTrajectory   *TrajectoryPOINT, int16 pointIndex,
						tAxis Eje1, tAxis Eje2, double FACTOR_CORRELACION)
{
    cd5a:	2f 92       	push	r2
    cd5c:	3f 92       	push	r3
    cd5e:	4f 92       	push	r4
    cd60:	5f 92       	push	r5
    cd62:	6f 92       	push	r6
    cd64:	7f 92       	push	r7
    cd66:	8f 92       	push	r8
    cd68:	9f 92       	push	r9
    cd6a:	af 92       	push	r10
    cd6c:	bf 92       	push	r11
    cd6e:	cf 92       	push	r12
    cd70:	df 92       	push	r13
    cd72:	ef 92       	push	r14
    cd74:	ff 92       	push	r15
    cd76:	0f 93       	push	r16
    cd78:	1f 93       	push	r17
    cd7a:	df 93       	push	r29
    cd7c:	cf 93       	push	r28
    cd7e:	cd b7       	in	r28, 0x3d	; 61
    cd80:	de b7       	in	r29, 0x3e	; 62
    cd82:	69 97       	sbiw	r28, 0x19	; 25
    cd84:	0f b6       	in	r0, 0x3f	; 63
    cd86:	f8 94       	cli
    cd88:	de bf       	out	0x3e, r29	; 62
    cd8a:	0f be       	out	0x3f, r0	; 63
    cd8c:	cd bf       	out	0x3d, r28	; 61
    cd8e:	98 87       	std	Y+8, r25	; 0x08
    cd90:	8f 83       	std	Y+7, r24	; 0x07
    cd92:	1a 01       	movw	r2, r20
    cd94:	49 01       	movw	r8, r18
    cd96:	57 01       	movw	r10, r14
    cd98:	68 01       	movw	r12, r16
	#endif
	
	
	
	//Leyendo datos de la posicion final para el eje 1
	Velocity_Eje1=TrajectoryPOINT->point[pointIndex].axis[Eje1].velocity;
    cd9a:	8d e3       	ldi	r24, 0x3D	; 61
    cd9c:	90 e0       	ldi	r25, 0x00	; 0
    cd9e:	68 9f       	mul	r22, r24
    cda0:	90 01       	movw	r18, r0
    cda2:	69 9f       	mul	r22, r25
    cda4:	30 0d       	add	r19, r0
    cda6:	78 9f       	mul	r23, r24
    cda8:	30 0d       	add	r19, r0
    cdaa:	11 24       	eor	r1, r1
    cdac:	3e 83       	std	Y+6, r19	; 0x06
    cdae:	2d 83       	std	Y+5, r18	; 0x05
    cdb0:	ef 81       	ldd	r30, Y+7	; 0x07
    cdb2:	f8 85       	ldd	r31, Y+8	; 0x08
    cdb4:	04 80       	ldd	r0, Z+4	; 0x04
    cdb6:	f5 81       	ldd	r31, Z+5	; 0x05
    cdb8:	e0 2d       	mov	r30, r0
    cdba:	e2 0f       	add	r30, r18
    cdbc:	f3 1f       	adc	r31, r19
    cdbe:	fe 8b       	std	Y+22, r31	; 0x16
    cdc0:	ed 8b       	std	Y+21, r30	; 0x15
    cdc2:	da 01       	movw	r26, r20
    cdc4:	aa 0f       	add	r26, r26
    cdc6:	bb 1f       	adc	r27, r27
    cdc8:	a4 0f       	add	r26, r20
    cdca:	b5 1f       	adc	r27, r21
    cdcc:	fd 01       	movw	r30, r26
    cdce:	31 96       	adiw	r30, 0x01	; 1
    cdd0:	ee 0f       	add	r30, r30
    cdd2:	ff 1f       	adc	r31, r31
    cdd4:	ee 0f       	add	r30, r30
    cdd6:	ff 1f       	adc	r31, r31
    cdd8:	2d 89       	ldd	r18, Y+21	; 0x15
    cdda:	3e 89       	ldd	r19, Y+22	; 0x16
    cddc:	e2 0f       	add	r30, r18
    cdde:	f3 1f       	adc	r31, r19
    cde0:	60 81       	ld	r22, Z
    cde2:	71 81       	ldd	r23, Z+1	; 0x01
    cde4:	82 81       	ldd	r24, Z+2	; 0x02
    cde6:	93 81       	ldd	r25, Z+3	; 0x03
	Acceleration_Eje1=TrajectoryPOINT->point[pointIndex].axis[Eje1].acceleration;
    cde8:	aa 0f       	add	r26, r26
    cdea:	bb 1f       	adc	r27, r27
    cdec:	aa 0f       	add	r26, r26
    cdee:	bb 1f       	adc	r27, r27
    cdf0:	a2 0f       	add	r26, r18
    cdf2:	b3 1f       	adc	r27, r19
    cdf4:	18 96       	adiw	r26, 0x08	; 8
    cdf6:	ed 90       	ld	r14, X+
    cdf8:	fd 90       	ld	r15, X+
    cdfa:	0d 91       	ld	r16, X+
    cdfc:	1c 91       	ld	r17, X
    cdfe:	1b 97       	sbiw	r26, 0x0b	; 11
	position_Eje1 = TrajectoryPOINT->point[pointIndex].axis[Eje1].position;
    ce00:	2d 91       	ld	r18, X+
    ce02:	3d 91       	ld	r19, X+
    ce04:	4d 91       	ld	r20, X+
    ce06:	5c 91       	ld	r21, X
    ce08:	29 83       	std	Y+1, r18	; 0x01
    ce0a:	3a 83       	std	Y+2, r19	; 0x02
    ce0c:	4b 83       	std	Y+3, r20	; 0x03
    ce0e:	5c 83       	std	Y+4, r21	; 0x04
	
	//Leyendo datos de la posicion final para el eje 2
	position_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].position;
    ce10:	f4 01       	movw	r30, r8
    ce12:	ee 0f       	add	r30, r30
    ce14:	ff 1f       	adc	r31, r31
    ce16:	e8 0d       	add	r30, r8
    ce18:	f9 1d       	adc	r31, r9
    ce1a:	df 01       	movw	r26, r30
    ce1c:	aa 0f       	add	r26, r26
    ce1e:	bb 1f       	adc	r27, r27
    ce20:	aa 0f       	add	r26, r26
    ce22:	bb 1f       	adc	r27, r27
    ce24:	4d 89       	ldd	r20, Y+21	; 0x15
    ce26:	5e 89       	ldd	r21, Y+22	; 0x16
    ce28:	a4 0f       	add	r26, r20
    ce2a:	b5 1f       	adc	r27, r21
    ce2c:	4d 90       	ld	r4, X+
    ce2e:	5d 90       	ld	r5, X+
    ce30:	6d 90       	ld	r6, X+
    ce32:	7c 90       	ld	r7, X
    ce34:	13 97       	sbiw	r26, 0x03	; 3
	Velocity_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].velocity;
    ce36:	31 96       	adiw	r30, 0x01	; 1
    ce38:	ee 0f       	add	r30, r30
    ce3a:	ff 1f       	adc	r31, r31
    ce3c:	ee 0f       	add	r30, r30
    ce3e:	ff 1f       	adc	r31, r31
    ce40:	e4 0f       	add	r30, r20
    ce42:	f5 1f       	adc	r31, r21
    ce44:	50 81       	ld	r21, Z
    ce46:	59 8f       	std	Y+25, r21	; 0x19
    ce48:	31 81       	ldd	r19, Z+1	; 0x01
    ce4a:	42 81       	ldd	r20, Z+2	; 0x02
    ce4c:	53 81       	ldd	r21, Z+3	; 0x03
	Acceleration_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].acceleration;
    ce4e:	fd 01       	movw	r30, r26
    ce50:	38 96       	adiw	r30, 0x08	; 8
    ce52:	f8 8f       	std	Y+24, r31	; 0x18
    ce54:	ef 8b       	std	Y+23, r30	; 0x17
    ce56:	18 96       	adiw	r26, 0x08	; 8
    ce58:	fc 91       	ld	r31, X
    ce5a:	f9 8b       	std	Y+17, r31	; 0x11
    ce5c:	ef 89       	ldd	r30, Y+23	; 0x17
    ce5e:	f8 8d       	ldd	r31, Y+24	; 0x18
    ce60:	f1 81       	ldd	r31, Z+1	; 0x01
    ce62:	fa 8b       	std	Y+18, r31	; 0x12
    ce64:	ef 89       	ldd	r30, Y+23	; 0x17
    ce66:	f8 8d       	ldd	r31, Y+24	; 0x18
    ce68:	f2 81       	ldd	r31, Z+2	; 0x02
    ce6a:	fb 8b       	std	Y+19, r31	; 0x13
    ce6c:	ef 89       	ldd	r30, Y+23	; 0x17
    ce6e:	f8 8d       	ldd	r31, Y+24	; 0x18
    ce70:	f3 81       	ldd	r31, Z+3	; 0x03
    ce72:	fc 8b       	std	Y+20, r31	; 0x14
	
	/*La Velocidad del Eje2 es igual a la del Registro del Eje2 + la velocidad del Eje1 X factor de correlacion*/
	if(Velocity_Eje1 != 0)
    ce74:	61 15       	cp	r22, r1
    ce76:	71 05       	cpc	r23, r1
    ce78:	81 05       	cpc	r24, r1
    ce7a:	91 05       	cpc	r25, r1
    ce7c:	31 f4       	brne	.+12     	; 0xce8a <mov_correlacionado+0x130>
	Acceleration_Eje1=TrajectoryPOINT->point[pointIndex].axis[Eje1].acceleration;
	position_Eje1 = TrajectoryPOINT->point[pointIndex].axis[Eje1].position;
	
	//Leyendo datos de la posicion final para el eje 2
	position_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].position;
	Velocity_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].velocity;
    ce7e:	29 8d       	ldd	r18, Y+25	; 0x19
    ce80:	29 87       	std	Y+9, r18	; 0x09
    ce82:	3a 87       	std	Y+10, r19	; 0x0a
    ce84:	4b 87       	std	Y+11, r20	; 0x0b
    ce86:	5c 87       	std	Y+12, r21	; 0x0c
    ce88:	0c c0       	rjmp	.+24     	; 0xcea2 <mov_correlacionado+0x148>
	Acceleration_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].acceleration;
	
	/*La Velocidad del Eje2 es igual a la del Registro del Eje2 + la velocidad del Eje1 X factor de correlacion*/
	if(Velocity_Eje1 != 0)
	{
		Velocity_Eje2 = (Velocity_Eje1*FACTOR_CORRELACION);
    ce8a:	0e 94 d0 9a 	call	0x135a0	; 0x135a0 <__floatunsisf>
    ce8e:	a6 01       	movw	r20, r12
    ce90:	95 01       	movw	r18, r10
    ce92:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    ce96:	0e 94 a4 9a 	call	0x13548	; 0x13548 <__fixunssfsi>
    ce9a:	69 87       	std	Y+9, r22	; 0x09
    ce9c:	7a 87       	std	Y+10, r23	; 0x0a
    ce9e:	8b 87       	std	Y+11, r24	; 0x0b
    cea0:	9c 87       	std	Y+12, r25	; 0x0c
		
	}
	
	if(Acceleration_Eje1 != 0)
    cea2:	e1 14       	cp	r14, r1
    cea4:	f1 04       	cpc	r15, r1
    cea6:	01 05       	cpc	r16, r1
    cea8:	11 05       	cpc	r17, r1
    ceaa:	49 f4       	brne	.+18     	; 0xcebe <mov_correlacionado+0x164>
	position_Eje1 = TrajectoryPOINT->point[pointIndex].axis[Eje1].position;
	
	//Leyendo datos de la posicion final para el eje 2
	position_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].position;
	Velocity_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].velocity;
	Acceleration_Eje2 = TrajectoryPOINT->point[pointIndex].axis[Eje2].acceleration;
    ceac:	39 89       	ldd	r19, Y+17	; 0x11
    ceae:	3d 87       	std	Y+13, r19	; 0x0d
    ceb0:	4a 89       	ldd	r20, Y+18	; 0x12
    ceb2:	4e 87       	std	Y+14, r20	; 0x0e
    ceb4:	5b 89       	ldd	r21, Y+19	; 0x13
    ceb6:	5f 87       	std	Y+15, r21	; 0x0f
    ceb8:	8c 89       	ldd	r24, Y+20	; 0x14
    ceba:	88 8b       	std	Y+16, r24	; 0x10
    cebc:	0e c0       	rjmp	.+28     	; 0xceda <mov_correlacionado+0x180>
		
	}
	
	if(Acceleration_Eje1 != 0)
	{
		Acceleration_Eje2 =  (Acceleration_Eje1*FACTOR_CORRELACION);
    cebe:	c8 01       	movw	r24, r16
    cec0:	b7 01       	movw	r22, r14
    cec2:	0e 94 d0 9a 	call	0x135a0	; 0x135a0 <__floatunsisf>
    cec6:	a6 01       	movw	r20, r12
    cec8:	95 01       	movw	r18, r10
    ceca:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    cece:	0e 94 a4 9a 	call	0x13548	; 0x13548 <__fixunssfsi>
    ced2:	6d 87       	std	Y+13, r22	; 0x0d
    ced4:	7e 87       	std	Y+14, r23	; 0x0e
    ced6:	8f 87       	std	Y+15, r24	; 0x0f
    ced8:	98 8b       	std	Y+16, r25	; 0x10
	
	//INTERACCION Eje1-Eje2
	
	/*La Posicion del Eje2 es igual al valor almacenado en el registro del Eje2 + la poscion
	del Eje1*FaCTOR DE CORRELACION*/
	position_Eje2_de_Correlacion = position_Eje2+(position_Eje1 * FACTOR_CORRELACION);	
    ceda:	c3 01       	movw	r24, r6
    cedc:	b2 01       	movw	r22, r4
    cede:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    cee2:	7b 01       	movw	r14, r22
    cee4:	8c 01       	movw	r16, r24
    cee6:	69 81       	ldd	r22, Y+1	; 0x01
    cee8:	7a 81       	ldd	r23, Y+2	; 0x02
    ceea:	8b 81       	ldd	r24, Y+3	; 0x03
    ceec:	9c 81       	ldd	r25, Y+4	; 0x04
    ceee:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    cef2:	a6 01       	movw	r20, r12
    cef4:	95 01       	movw	r18, r10
    cef6:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    cefa:	9b 01       	movw	r18, r22
    cefc:	ac 01       	movw	r20, r24
    cefe:	c8 01       	movw	r24, r16
    cf00:	b7 01       	movw	r22, r14
    cf02:	0e 94 cf 99 	call	0x1339e	; 0x1339e <__addsf3>
    cf06:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    cf0a:	8b 01       	movw	r16, r22
    cf0c:	9c 01       	movw	r18, r24
    cf0e:	76 2e       	mov	r7, r22
    cf10:	61 2e       	mov	r6, r17
    cf12:	52 2e       	mov	r5, r18
    cf14:	43 2e       	mov	r4, r19
		printf("mov_correlacionado => position Eje %s deseada(Formula)= %ld\n",AxisName(Eje2),position_Eje2_de_Correlacion);
	
	 #endif
	
	/*Muevo el Eje2 con esos datos */
	if (Eje2==AxisPitch)
    cf16:	93 e0       	ldi	r25, 0x03	; 3
    cf18:	89 16       	cp	r8, r25
    cf1a:	91 04       	cpc	r9, r1
    cf1c:	d1 f4       	brne	.+52     	; 0xcf52 <mov_correlacionado+0x1f8>
	{	
		/*Almaceno la posicion final del pitch, es necesaria para 
                reconfiguracion del movimiento*/
                TrajectoryPOINT->point[pointIndex].axis[Eje2].position=position_Eje2_de_Correlacion;
    cf1e:	ed 89       	ldd	r30, Y+21	; 0x15
    cf20:	fe 89       	ldd	r31, Y+22	; 0x16
    cf22:	04 a3       	std	Z+36, r16	; 0x24
    cf24:	15 a3       	std	Z+37, r17	; 0x25
    cf26:	26 a3       	std	Z+38, r18	; 0x26
    cf28:	37 a3       	std	Z+39, r19	; 0x27
		pitch(position_Eje2_de_Correlacion,Velocity_Eje2,Acceleration_Eje2,no_update,MOVIMIENTO_NORMAL );
    cf2a:	b8 01       	movw	r22, r16
    cf2c:	c9 01       	movw	r24, r18
    cf2e:	29 85       	ldd	r18, Y+9	; 0x09
    cf30:	3a 85       	ldd	r19, Y+10	; 0x0a
    cf32:	4b 85       	ldd	r20, Y+11	; 0x0b
    cf34:	5c 85       	ldd	r21, Y+12	; 0x0c
    cf36:	ed 84       	ldd	r14, Y+13	; 0x0d
    cf38:	fe 84       	ldd	r15, Y+14	; 0x0e
    cf3a:	0f 85       	ldd	r16, Y+15	; 0x0f
    cf3c:	18 89       	ldd	r17, Y+16	; 0x10
    cf3e:	af ee       	ldi	r26, 0xEF	; 239
    cf40:	ca 2e       	mov	r12, r26
    cf42:	af ef       	ldi	r26, 0xFF	; 255
    cf44:	da 2e       	mov	r13, r26
    cf46:	f1 e0       	ldi	r31, 0x01	; 1
    cf48:	af 2e       	mov	r10, r31
    cf4a:	b1 2c       	mov	r11, r1
    cf4c:	0e 94 78 52 	call	0xa4f0	; 0xa4f0 <pitch>
    cf50:	11 c0       	rjmp	.+34     	; 0xcf74 <mov_correlacionado+0x21a>
	}
	else
	{
		mov_axis(Eje2,position_Eje2_de_Correlacion,Velocity_Eje2,Acceleration_Eje2,no_update);	
    cf52:	c4 01       	movw	r24, r8
    cf54:	a8 01       	movw	r20, r16
    cf56:	b9 01       	movw	r22, r18
    cf58:	09 85       	ldd	r16, Y+9	; 0x09
    cf5a:	1a 85       	ldd	r17, Y+10	; 0x0a
    cf5c:	2b 85       	ldd	r18, Y+11	; 0x0b
    cf5e:	3c 85       	ldd	r19, Y+12	; 0x0c
    cf60:	cd 84       	ldd	r12, Y+13	; 0x0d
    cf62:	de 84       	ldd	r13, Y+14	; 0x0e
    cf64:	ef 84       	ldd	r14, Y+15	; 0x0f
    cf66:	f8 88       	ldd	r15, Y+16	; 0x10
    cf68:	ef ee       	ldi	r30, 0xEF	; 239
    cf6a:	ae 2e       	mov	r10, r30
    cf6c:	ef ef       	ldi	r30, 0xFF	; 255
    cf6e:	be 2e       	mov	r11, r30
    cf70:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
	}			
	
	
	
	
	if(Eje1==AxisShoulder)
    cf74:	f1 e0       	ldi	r31, 0x01	; 1
    cf76:	2f 16       	cp	r2, r31
    cf78:	31 04       	cpc	r3, r1
    cf7a:	e9 f5       	brne	.+122    	; 0xcff6 <mov_correlacionado+0x29c>
	{
		#ifdef DEBUGROBOTICS				
		printf("mov_correlacionado =>  Actualizando valores de codo \n");
		#endif
		TrajectoryPOINT->point[pointIndex].axis[Eje2].position=position_Eje2_de_Correlacion;
    cf7c:	ef 81       	ldd	r30, Y+7	; 0x07
    cf7e:	f8 85       	ldd	r31, Y+8	; 0x08
    cf80:	84 81       	ldd	r24, Z+4	; 0x04
    cf82:	95 81       	ldd	r25, Z+5	; 0x05
    cf84:	2d 81       	ldd	r18, Y+5	; 0x05
    cf86:	3e 81       	ldd	r19, Y+6	; 0x06
    cf88:	82 0f       	add	r24, r18
    cf8a:	93 1f       	adc	r25, r19
    cf8c:	f4 01       	movw	r30, r8
    cf8e:	ee 0f       	add	r30, r30
    cf90:	ff 1f       	adc	r31, r31
    cf92:	e8 0d       	add	r30, r8
    cf94:	f9 1d       	adc	r31, r9
    cf96:	df 01       	movw	r26, r30
    cf98:	aa 0f       	add	r26, r26
    cf9a:	bb 1f       	adc	r27, r27
    cf9c:	aa 0f       	add	r26, r26
    cf9e:	bb 1f       	adc	r27, r27
    cfa0:	a8 0f       	add	r26, r24
    cfa2:	b9 1f       	adc	r27, r25
    cfa4:	7c 92       	st	X, r7
    cfa6:	11 96       	adiw	r26, 0x01	; 1
    cfa8:	6c 92       	st	X, r6
    cfaa:	11 97       	sbiw	r26, 0x01	; 1
    cfac:	12 96       	adiw	r26, 0x02	; 2
    cfae:	5c 92       	st	X, r5
    cfb0:	12 97       	sbiw	r26, 0x02	; 2
    cfb2:	13 96       	adiw	r26, 0x03	; 3
    cfb4:	4c 92       	st	X, r4
    cfb6:	13 97       	sbiw	r26, 0x03	; 3
		TrajectoryPOINT->point[pointIndex].axis[Eje2].velocity=Velocity_Eje2;
    cfb8:	9f 01       	movw	r18, r30
    cfba:	2f 5f       	subi	r18, 0xFF	; 255
    cfbc:	3f 4f       	sbci	r19, 0xFF	; 255
    cfbe:	22 0f       	add	r18, r18
    cfc0:	33 1f       	adc	r19, r19
    cfc2:	22 0f       	add	r18, r18
    cfc4:	33 1f       	adc	r19, r19
    cfc6:	28 0f       	add	r18, r24
    cfc8:	39 1f       	adc	r19, r25
    cfca:	49 85       	ldd	r20, Y+9	; 0x09
    cfcc:	f9 01       	movw	r30, r18
    cfce:	40 83       	st	Z, r20
    cfd0:	5a 85       	ldd	r21, Y+10	; 0x0a
    cfd2:	51 83       	std	Z+1, r21	; 0x01
    cfd4:	8b 85       	ldd	r24, Y+11	; 0x0b
    cfd6:	82 83       	std	Z+2, r24	; 0x02
    cfd8:	9c 85       	ldd	r25, Y+12	; 0x0c
    cfda:	93 83       	std	Z+3, r25	; 0x03
		TrajectoryPOINT->point[pointIndex].axis[Eje2].acceleration=Acceleration_Eje2;
    cfdc:	9d 01       	movw	r18, r26
    cfde:	28 5f       	subi	r18, 0xF8	; 248
    cfe0:	3f 4f       	sbci	r19, 0xFF	; 255
    cfe2:	ed 85       	ldd	r30, Y+13	; 0x0d
    cfe4:	18 96       	adiw	r26, 0x08	; 8
    cfe6:	ec 93       	st	X, r30
    cfe8:	4e 85       	ldd	r20, Y+14	; 0x0e
    cfea:	f9 01       	movw	r30, r18
    cfec:	41 83       	std	Z+1, r20	; 0x01
    cfee:	5f 85       	ldd	r21, Y+15	; 0x0f
    cff0:	52 83       	std	Z+2, r21	; 0x02
    cff2:	88 89       	ldd	r24, Y+16	; 0x10
    cff4:	83 83       	std	Z+3, r24	; 0x03
	#ifdef DEBUGROBOTICS				
	//scanf("%d",&temp);
	#endif
		
	
}
    cff6:	69 96       	adiw	r28, 0x19	; 25
    cff8:	0f b6       	in	r0, 0x3f	; 63
    cffa:	f8 94       	cli
    cffc:	de bf       	out	0x3e, r29	; 62
    cffe:	0f be       	out	0x3f, r0	; 63
    d000:	cd bf       	out	0x3d, r28	; 61
    d002:	cf 91       	pop	r28
    d004:	df 91       	pop	r29
    d006:	1f 91       	pop	r17
    d008:	0f 91       	pop	r16
    d00a:	ff 90       	pop	r15
    d00c:	ef 90       	pop	r14
    d00e:	df 90       	pop	r13
    d010:	cf 90       	pop	r12
    d012:	bf 90       	pop	r11
    d014:	af 90       	pop	r10
    d016:	9f 90       	pop	r9
    d018:	8f 90       	pop	r8
    d01a:	7f 90       	pop	r7
    d01c:	6f 90       	pop	r6
    d01e:	5f 90       	pop	r5
    d020:	4f 90       	pop	r4
    d022:	3f 90       	pop	r3
    d024:	2f 90       	pop	r2
    d026:	08 95       	ret

0000d028 <teach_pendant_point>:
	return rc;
	
}
/*****************************************************************************************/
void teach_pendant_point(tTrajectory   *TrajectoryPOINT,int16 pointIndex )
{
    d028:	2f 92       	push	r2
    d02a:	3f 92       	push	r3
    d02c:	4f 92       	push	r4
    d02e:	5f 92       	push	r5
    d030:	6f 92       	push	r6
    d032:	7f 92       	push	r7
    d034:	8f 92       	push	r8
    d036:	9f 92       	push	r9
    d038:	af 92       	push	r10
    d03a:	bf 92       	push	r11
    d03c:	cf 92       	push	r12
    d03e:	df 92       	push	r13
    d040:	ef 92       	push	r14
    d042:	ff 92       	push	r15
    d044:	0f 93       	push	r16
    d046:	1f 93       	push	r17
    d048:	df 93       	push	r29
    d04a:	cf 93       	push	r28
    d04c:	cd b7       	in	r28, 0x3d	; 61
    d04e:	de b7       	in	r29, 0x3e	; 62
    d050:	ae 97       	sbiw	r28, 0x2e	; 46
    d052:	0f b6       	in	r0, 0x3f	; 63
    d054:	f8 94       	cli
    d056:	de bf       	out	0x3e, r29	; 62
    d058:	0f be       	out	0x3f, r0	; 63
    d05a:	cd bf       	out	0x3d, r28	; 61
    d05c:	3c 01       	movw	r6, r24
    d05e:	2b 01       	movw	r4, r22
	position=0;
	velocity=0;
	acceleration=0;
	reconf_Elbow=0;
	reconf_Pitch=0;
	Enable_Mov();		
    d060:	0e 94 9b 4d 	call	0x9b36	; 0x9b36 <Enable_Mov>
	mask= TrajectoryPOINT->invalidmask;
    d064:	d3 01       	movw	r26, r6
    d066:	12 96       	adiw	r26, 0x02	; 2
    d068:	0d 90       	ld	r0, X+
    d06a:	bc 91       	ld	r27, X
    d06c:	a0 2d       	mov	r26, r0
    d06e:	ba 8b       	std	Y+18, r27	; 0x12
    d070:	a9 8b       	std	Y+17, r26	; 0x11
	
	
	/*Posicion Actual de Hombro y codo y Pitch*/
	PMDGetPosition(&hAxis[AxisShoulder],&actual_shoulder_position);
    d072:	89 e7       	ldi	r24, 0x79	; 121
    d074:	95 e7       	ldi	r25, 0x75	; 117
    d076:	be 01       	movw	r22, r28
    d078:	6d 5f       	subi	r22, 0xFD	; 253
    d07a:	7f 4f       	sbci	r23, 0xFF	; 255
    d07c:	0e 94 84 7b 	call	0xf708	; 0xf708 <PMDGetPosition>
	PMDGetPosition(&hAxis[AxisElbow],&actual_elbow_position);
    d080:	89 ed       	ldi	r24, 0xD9	; 217
    d082:	95 e7       	ldi	r25, 0x75	; 117
    d084:	be 01       	movw	r22, r28
    d086:	69 5f       	subi	r22, 0xF9	; 249
    d088:	7f 4f       	sbci	r23, 0xFF	; 255
    d08a:	0e 94 84 7b 	call	0xf708	; 0xf708 <PMDGetPosition>
	
	
	printf("teach_pendant_point=> Ejecutando movimiento o pose asignada\n");
    d08e:	86 e3       	ldi	r24, 0x36	; 54
    d090:	99 e5       	ldi	r25, 0x59	; 89
    d092:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
					default:
						//Aplica solo  para cintura.
						
					break;
				}				
				TrajectoryPOINT->point[pointIndex].axis[axis].position= actual_position;
    d096:	8d e3       	ldi	r24, 0x3D	; 61
    d098:	90 e0       	ldi	r25, 0x00	; 0
    d09a:	48 9e       	mul	r4, r24
    d09c:	10 01       	movw	r2, r0
    d09e:	49 9e       	mul	r4, r25
    d0a0:	30 0c       	add	r3, r0
    d0a2:	58 9e       	mul	r5, r24
    d0a4:	30 0c       	add	r3, r0
    d0a6:	11 24       	eor	r1, r1
    d0a8:	e9 e1       	ldi	r30, 0x19	; 25
    d0aa:	f5 e7       	ldi	r31, 0x75	; 117
    d0ac:	f8 8b       	std	Y+16, r31	; 0x10
    d0ae:	ef 87       	std	Y+15, r30	; 0x0f
    d0b0:	5f 01       	movw	r10, r30
    d0b2:	cc 24       	eor	r12, r12
    d0b4:	dd 24       	eor	r13, r13
		{	
			 // El eje no esta habilitado para el movimiento, igual tengo que mantener la posicion actual
			if( ( mask & Axis2AxisMask(axis) )== 0 )     
			{
				//Obtengo la posicion ANTES de actualizar!
				PMDGetPosition(&hAxis[axis],&actual_position);	
    d0b6:	8b e0       	ldi	r24, 0x0B	; 11
    d0b8:	88 2e       	mov	r8, r24
    d0ba:	91 2c       	mov	r9, r1
    d0bc:	8c 0e       	add	r8, r28
    d0be:	9d 1e       	adc	r9, r29
	//Configuro condiciones iniciales (Caso en el eje no se selecciona para el movimiento, 
	//por tal motivo debe mantener el valor en donde se encuentra)
	for(axis=0; axis < DOF; axis++) 
	{  
		
		if ( hAxis[axis].axisSettings.axisEnabled == TRUE) 		
    d0c0:	d5 01       	movw	r26, r10
    d0c2:	14 96       	adiw	r26, 0x04	; 4
    d0c4:	8c 91       	ld	r24, X
    d0c6:	81 30       	cpi	r24, 0x01	; 1
    d0c8:	09 f0       	breq	.+2      	; 0xd0cc <teach_pendant_point+0xa4>
    d0ca:	8b c0       	rjmp	.+278    	; 0xd1e2 <teach_pendant_point+0x1ba>
		{	
			 // El eje no esta habilitado para el movimiento, igual tengo que mantener la posicion actual
			if( ( mask & Axis2AxisMask(axis) )== 0 )     
    d0cc:	c6 01       	movw	r24, r12
    d0ce:	0e 94 ed 2e 	call	0x5dda	; 0x5dda <Axis2AxisMask>
    d0d2:	e9 89       	ldd	r30, Y+17	; 0x11
    d0d4:	fa 89       	ldd	r31, Y+18	; 0x12
    d0d6:	8e 23       	and	r24, r30
    d0d8:	9f 23       	and	r25, r31
    d0da:	89 2b       	or	r24, r25
    d0dc:	09 f0       	breq	.+2      	; 0xd0e0 <teach_pendant_point+0xb8>
    d0de:	81 c0       	rjmp	.+258    	; 0xd1e2 <teach_pendant_point+0x1ba>
			{
				//Obtengo la posicion ANTES de actualizar!
				PMDGetPosition(&hAxis[axis],&actual_position);	
    d0e0:	c5 01       	movw	r24, r10
    d0e2:	b4 01       	movw	r22, r8
    d0e4:	0e 94 84 7b 	call	0xf708	; 0xf708 <PMDGetPosition>
				
				switch (axis)
    d0e8:	f2 e0       	ldi	r31, 0x02	; 2
    d0ea:	cf 16       	cp	r12, r31
    d0ec:	d1 04       	cpc	r13, r1
    d0ee:	e9 f0       	breq	.+58     	; 0xd12a <teach_pendant_point+0x102>
    d0f0:	23 e0       	ldi	r18, 0x03	; 3
    d0f2:	c2 16       	cp	r12, r18
    d0f4:	d1 04       	cpc	r13, r1
    d0f6:	34 f4       	brge	.+12     	; 0xd104 <teach_pendant_point+0xdc>
    d0f8:	31 e0       	ldi	r19, 0x01	; 1
    d0fa:	c3 16       	cp	r12, r19
    d0fc:	d1 04       	cpc	r13, r1
    d0fe:	09 f0       	breq	.+2      	; 0xd102 <teach_pendant_point+0xda>
    d100:	56 c0       	rjmp	.+172    	; 0xd1ae <teach_pendant_point+0x186>
    d102:	0a c0       	rjmp	.+20     	; 0xd118 <teach_pendant_point+0xf0>
    d104:	83 e0       	ldi	r24, 0x03	; 3
    d106:	c8 16       	cp	r12, r24
    d108:	d1 04       	cpc	r13, r1
    d10a:	11 f1       	breq	.+68     	; 0xd150 <teach_pendant_point+0x128>
    d10c:	94 e0       	ldi	r25, 0x04	; 4
    d10e:	c9 16       	cp	r12, r25
    d110:	d1 04       	cpc	r13, r1
    d112:	09 f0       	breq	.+2      	; 0xd116 <teach_pendant_point+0xee>
    d114:	4c c0       	rjmp	.+152    	; 0xd1ae <teach_pendant_point+0x186>
    d116:	44 c0       	rjmp	.+136    	; 0xd1a0 <teach_pendant_point+0x178>
				{
					
					case (AxisShoulder):
						actual_position=actual_shoulder_position;
    d118:	8b 81       	ldd	r24, Y+3	; 0x03
    d11a:	9c 81       	ldd	r25, Y+4	; 0x04
    d11c:	ad 81       	ldd	r26, Y+5	; 0x05
    d11e:	be 81       	ldd	r27, Y+6	; 0x06
    d120:	8b 87       	std	Y+11, r24	; 0x0b
    d122:	9c 87       	std	Y+12, r25	; 0x0c
    d124:	ad 87       	std	Y+13, r26	; 0x0d
    d126:	be 87       	std	Y+14, r27	; 0x0e
    d128:	42 c0       	rjmp	.+132    	; 0xd1ae <teach_pendant_point+0x186>
					break;
					case (AxisElbow):
						/*Se tiene la siguiente formula:
						Pos_Codo= Pos_Codo_inicial + PosHombro*(R_Codo/R_Hombro)
						Como es necesario la posicion inicial del codo se despeja, Pos_Codo_inicial.*/
						actual_position=(actual_position)-(actual_shoulder_position*CORRELACION_HOMBRO_CODO);					
    d12a:	6b 85       	ldd	r22, Y+11	; 0x0b
    d12c:	7c 85       	ldd	r23, Y+12	; 0x0c
    d12e:	8d 85       	ldd	r24, Y+13	; 0x0d
    d130:	9e 85       	ldd	r25, Y+14	; 0x0e
    d132:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    d136:	7b 01       	movw	r14, r22
    d138:	8c 01       	movw	r16, r24
    d13a:	6b 81       	ldd	r22, Y+3	; 0x03
    d13c:	7c 81       	ldd	r23, Y+4	; 0x04
    d13e:	8d 81       	ldd	r24, Y+5	; 0x05
    d140:	9e 81       	ldd	r25, Y+6	; 0x06
    d142:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    d146:	2d e1       	ldi	r18, 0x1D	; 29
    d148:	3a e5       	ldi	r19, 0x5A	; 90
    d14a:	44 e5       	ldi	r20, 0x54	; 84
    d14c:	5f eb       	ldi	r21, 0xBF	; 191
    d14e:	19 c0       	rjmp	.+50     	; 0xd182 <teach_pendant_point+0x15a>
					break;
					case (AxisPitch):
						/* Leer el movimiento anterior de Pitch que esta almacenado en EEPROM*/
						eeprom_read_block((void*)&actual_position,(const void*)&Mov_Pitch_Anterior,sizeof(PMDint32));
    d150:	c4 01       	movw	r24, r8
    d152:	6a e5       	ldi	r22, 0x5A	; 90
    d154:	71 e0       	ldi	r23, 0x01	; 1
    d156:	44 e0       	ldi	r20, 0x04	; 4
    d158:	50 e0       	ldi	r21, 0x00	; 0
    d15a:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
						actual_position = (actual_position)-(actual_elbow_position*CORRELACION_CODO_PITCH);
    d15e:	6b 85       	ldd	r22, Y+11	; 0x0b
    d160:	7c 85       	ldd	r23, Y+12	; 0x0c
    d162:	8d 85       	ldd	r24, Y+13	; 0x0d
    d164:	9e 85       	ldd	r25, Y+14	; 0x0e
    d166:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    d16a:	7b 01       	movw	r14, r22
    d16c:	8c 01       	movw	r16, r24
    d16e:	6f 81       	ldd	r22, Y+7	; 0x07
    d170:	78 85       	ldd	r23, Y+8	; 0x08
    d172:	89 85       	ldd	r24, Y+9	; 0x09
    d174:	9a 85       	ldd	r25, Y+10	; 0x0a
    d176:	0e 94 d2 9a 	call	0x135a4	; 0x135a4 <__floatsisf>
    d17a:	29 ec       	ldi	r18, 0xC9	; 201
    d17c:	3e e8       	ldi	r19, 0x8E	; 142
    d17e:	4d e8       	ldi	r20, 0x8D	; 141
    d180:	5c eb       	ldi	r21, 0xBC	; 188
    d182:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
    d186:	9b 01       	movw	r18, r22
    d188:	ac 01       	movw	r20, r24
    d18a:	c8 01       	movw	r24, r16
    d18c:	b7 01       	movw	r22, r14
    d18e:	0e 94 cf 99 	call	0x1339e	; 0x1339e <__addsf3>
    d192:	0e 94 9f 9a 	call	0x1353e	; 0x1353e <__fixsfsi>
    d196:	6b 87       	std	Y+11, r22	; 0x0b
    d198:	7c 87       	std	Y+12, r23	; 0x0c
    d19a:	8d 87       	std	Y+13, r24	; 0x0d
    d19c:	9e 87       	std	Y+14, r25	; 0x0e
    d19e:	07 c0       	rjmp	.+14     	; 0xd1ae <teach_pendant_point+0x186>
					break;
					case (AxisRoll):
						/* Leer el movimiento anterior de Roll que esta almacenado en EEPROM*/
						eeprom_read_block((void*)&actual_position,(const void*)&Mov_Roll_Anterior,sizeof(PMDint32));
    d1a0:	c4 01       	movw	r24, r8
    d1a2:	66 e5       	ldi	r22, 0x56	; 86
    d1a4:	71 e0       	ldi	r23, 0x01	; 1
    d1a6:	44 e0       	ldi	r20, 0x04	; 4
    d1a8:	50 e0       	ldi	r21, 0x00	; 0
    d1aa:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
					default:
						//Aplica solo  para cintura.
						
					break;
				}				
				TrajectoryPOINT->point[pointIndex].axis[axis].position= actual_position;
    d1ae:	d3 01       	movw	r26, r6
    d1b0:	14 96       	adiw	r26, 0x04	; 4
    d1b2:	ed 91       	ld	r30, X+
    d1b4:	fc 91       	ld	r31, X
    d1b6:	15 97       	sbiw	r26, 0x05	; 5
    d1b8:	e2 0d       	add	r30, r2
    d1ba:	f3 1d       	adc	r31, r3
    d1bc:	c6 01       	movw	r24, r12
    d1be:	88 0f       	add	r24, r24
    d1c0:	99 1f       	adc	r25, r25
    d1c2:	8c 0d       	add	r24, r12
    d1c4:	9d 1d       	adc	r25, r13
    d1c6:	88 0f       	add	r24, r24
    d1c8:	99 1f       	adc	r25, r25
    d1ca:	88 0f       	add	r24, r24
    d1cc:	99 1f       	adc	r25, r25
    d1ce:	e8 0f       	add	r30, r24
    d1d0:	f9 1f       	adc	r31, r25
    d1d2:	8b 85       	ldd	r24, Y+11	; 0x0b
    d1d4:	9c 85       	ldd	r25, Y+12	; 0x0c
    d1d6:	ad 85       	ldd	r26, Y+13	; 0x0d
    d1d8:	be 85       	ldd	r27, Y+14	; 0x0e
    d1da:	80 83       	st	Z, r24
    d1dc:	91 83       	std	Z+1, r25	; 0x01
    d1de:	a2 83       	std	Z+2, r26	; 0x02
    d1e0:	b3 83       	std	Z+3, r27	; 0x03
		printf("teach_pendant_point=> actual_Elbow_position = %ld\n",actual_elbow_position);	
		printf("teach_pendant_point=> actual_pitch_position = %ld\n",actual_pitch_position);	
	#endif
	//Configuro condiciones iniciales (Caso en el eje no se selecciona para el movimiento, 
	//por tal motivo debe mantener el valor en donde se encuentra)
	for(axis=0; axis < DOF; axis++) 
    d1e2:	08 94       	sec
    d1e4:	c1 1c       	adc	r12, r1
    d1e6:	d1 1c       	adc	r13, r1
    d1e8:	e0 e6       	ldi	r30, 0x60	; 96
    d1ea:	f0 e0       	ldi	r31, 0x00	; 0
    d1ec:	ae 0e       	add	r10, r30
    d1ee:	bf 1e       	adc	r11, r31
    d1f0:	f5 e0       	ldi	r31, 0x05	; 5
    d1f2:	cf 16       	cp	r12, r31
    d1f4:	d1 04       	cpc	r13, r1
    d1f6:	09 f0       	breq	.+2      	; 0xd1fa <teach_pendant_point+0x1d2>
    d1f8:	63 cf       	rjmp	.-314    	; 0xd0c0 <teach_pendant_point+0x98>
				#endif
			}
		}
	}
	/*Salvo la velocidad y aceleracion de usuario de pitch y codo */
	velocity_elbow_usr=TrajectoryPOINT->point[pointIndex].axis[AxisElbow].velocity;
    d1fa:	d3 01       	movw	r26, r6
    d1fc:	14 96       	adiw	r26, 0x04	; 4
    d1fe:	ed 91       	ld	r30, X+
    d200:	fc 91       	ld	r31, X
    d202:	15 97       	sbiw	r26, 0x05	; 5
    d204:	e2 0d       	add	r30, r2
    d206:	f3 1d       	adc	r31, r3
    d208:	84 8d       	ldd	r24, Z+28	; 0x1c
    d20a:	95 8d       	ldd	r25, Z+29	; 0x1d
    d20c:	a6 8d       	ldd	r26, Z+30	; 0x1e
    d20e:	b7 8d       	ldd	r27, Z+31	; 0x1f
    d210:	8b 8f       	std	Y+27, r24	; 0x1b
    d212:	9c 8f       	std	Y+28, r25	; 0x1c
    d214:	ad 8f       	std	Y+29, r26	; 0x1d
    d216:	be 8f       	std	Y+30, r27	; 0x1e
	acceleration_elbow_usr=TrajectoryPOINT->point[pointIndex].axis[AxisElbow].acceleration;
    d218:	80 a1       	ldd	r24, Z+32	; 0x20
    d21a:	91 a1       	ldd	r25, Z+33	; 0x21
    d21c:	a2 a1       	ldd	r26, Z+34	; 0x22
    d21e:	b3 a1       	ldd	r27, Z+35	; 0x23
    d220:	8b 8b       	std	Y+19, r24	; 0x13
    d222:	9c 8b       	std	Y+20, r25	; 0x14
    d224:	ad 8b       	std	Y+21, r26	; 0x15
    d226:	be 8b       	std	Y+22, r27	; 0x16
	velocity_pich_usr=TrajectoryPOINT->point[pointIndex].axis[AxisPitch].velocity;
    d228:	80 a5       	ldd	r24, Z+40	; 0x28
    d22a:	91 a5       	ldd	r25, Z+41	; 0x29
    d22c:	a2 a5       	ldd	r26, Z+42	; 0x2a
    d22e:	b3 a5       	ldd	r27, Z+43	; 0x2b
    d230:	8f 8b       	std	Y+23, r24	; 0x17
    d232:	98 8f       	std	Y+24, r25	; 0x18
    d234:	a9 8f       	std	Y+25, r26	; 0x19
    d236:	ba 8f       	std	Y+26, r27	; 0x1a
	acceleration_pich_usr=TrajectoryPOINT->point[pointIndex].axis[AxisPitch].acceleration;
    d238:	94 a5       	ldd	r25, Z+44	; 0x2c
    d23a:	9b a7       	std	Y+43, r25	; 0x2b
    d23c:	a5 a5       	ldd	r26, Z+45	; 0x2d
    d23e:	ac a7       	std	Y+44, r26	; 0x2c
    d240:	b6 a5       	ldd	r27, Z+46	; 0x2e
    d242:	bd a7       	std	Y+45, r27	; 0x2d
    d244:	27 a5       	ldd	r18, Z+47	; 0x2f
    d246:	2e a7       	std	Y+46, r18	; 0x2e
    d248:	1f a2       	std	Y+39, r1	; 0x27
    d24a:	18 a6       	std	Y+40, r1	; 0x28
    d24c:	19 a6       	std	Y+41, r1	; 0x29
    d24e:	1a a6       	std	Y+42, r1	; 0x2a
    d250:	1b a2       	std	Y+35, r1	; 0x23
    d252:	1c a2       	std	Y+36, r1	; 0x24
    d254:	1d a2       	std	Y+37, r1	; 0x25
    d256:	1e a2       	std	Y+38, r1	; 0x26
    d258:	1f 8e       	std	Y+31, r1	; 0x1f
    d25a:	18 a2       	std	Y+32, r1	; 0x20
    d25c:	19 a2       	std	Y+33, r1	; 0x21
    d25e:	1a a2       	std	Y+34, r1	; 0x22
    d260:	88 24       	eor	r8, r8
    d262:	99 24       	eor	r9, r9
	//Busco el primer eje seleccionado y configuro el resto, es decir que si encuentro que hombro es el primero, 
	//configuro hombro, codo, pitch y salgo imediatamente del for para no reconfigurar con datos erroneos los demas ejes
	for(axis=0; axis < DOF; axis++) 
	{  
		
		if ( hAxis[axis].axisSettings.axisEnabled == TRUE) 		
    d264:	f4 01       	movw	r30, r8
    d266:	ee 0f       	add	r30, r30
    d268:	ff 1f       	adc	r31, r31
    d26a:	e8 0d       	add	r30, r8
    d26c:	f9 1d       	adc	r31, r9
    d26e:	a5 e0       	ldi	r26, 0x05	; 5
    d270:	ee 0f       	add	r30, r30
    d272:	ff 1f       	adc	r31, r31
    d274:	aa 95       	dec	r26
    d276:	e1 f7       	brne	.-8      	; 0xd270 <teach_pendant_point+0x248>
    d278:	e3 5e       	subi	r30, 0xE3	; 227
    d27a:	fa 48       	sbci	r31, 0x8A	; 138
    d27c:	80 81       	ld	r24, Z
    d27e:	81 30       	cpi	r24, 0x01	; 1
    d280:	09 f0       	breq	.+2      	; 0xd284 <teach_pendant_point+0x25c>
    d282:	d6 c0       	rjmp	.+428    	; 0xd430 <teach_pendant_point+0x408>
		{	
			 // El eje esta habilitado para el movimiento,
			if( ( mask & Axis2AxisMask(axis) )!= 0 )     
    d284:	c4 01       	movw	r24, r8
    d286:	0e 94 ed 2e 	call	0x5dda	; 0x5dda <Axis2AxisMask>
    d28a:	a9 89       	ldd	r26, Y+17	; 0x11
    d28c:	ba 89       	ldd	r27, Y+18	; 0x12
    d28e:	8a 23       	and	r24, r26
    d290:	9b 23       	and	r25, r27
    d292:	89 2b       	or	r24, r25
    d294:	09 f4       	brne	.+2      	; 0xd298 <teach_pendant_point+0x270>
    d296:	cc c0       	rjmp	.+408    	; 0xd430 <teach_pendant_point+0x408>
			{	
				switch (axis)
    d298:	b2 e0       	ldi	r27, 0x02	; 2
    d29a:	8b 16       	cp	r8, r27
    d29c:	91 04       	cpc	r9, r1
    d29e:	81 f1       	breq	.+96     	; 0xd300 <teach_pendant_point+0x2d8>
    d2a0:	e3 e0       	ldi	r30, 0x03	; 3
    d2a2:	8e 16       	cp	r8, r30
    d2a4:	91 04       	cpc	r9, r1
    d2a6:	34 f4       	brge	.+12     	; 0xd2b4 <teach_pendant_point+0x28c>
    d2a8:	f1 e0       	ldi	r31, 0x01	; 1
    d2aa:	8f 16       	cp	r8, r31
    d2ac:	91 04       	cpc	r9, r1
    d2ae:	09 f0       	breq	.+2      	; 0xd2b2 <teach_pendant_point+0x28a>
    d2b0:	94 c0       	rjmp	.+296    	; 0xd3da <teach_pendant_point+0x3b2>
    d2b2:	0b c0       	rjmp	.+22     	; 0xd2ca <teach_pendant_point+0x2a2>
    d2b4:	23 e0       	ldi	r18, 0x03	; 3
    d2b6:	82 16       	cp	r8, r18
    d2b8:	91 04       	cpc	r9, r1
    d2ba:	09 f4       	brne	.+2      	; 0xd2be <teach_pendant_point+0x296>
    d2bc:	49 c0       	rjmp	.+146    	; 0xd350 <teach_pendant_point+0x328>
    d2be:	34 e0       	ldi	r19, 0x04	; 4
    d2c0:	83 16       	cp	r8, r19
    d2c2:	91 04       	cpc	r9, r1
    d2c4:	09 f0       	breq	.+2      	; 0xd2c8 <teach_pendant_point+0x2a0>
    d2c6:	89 c0       	rjmp	.+274    	; 0xd3da <teach_pendant_point+0x3b2>
    d2c8:	68 c0       	rjmp	.+208    	; 0xd39a <teach_pendant_point+0x372>
				{
					case (AxisShoulder):
						//No depende de nadie va directo...  
						//(Siempre entra aqui cuando se usa con una trayectoria )..
						mov_axis(AxisShoulder,TrajectoryPOINT->point[pointIndex].axis[axis].position, 
    d2ca:	d3 01       	movw	r26, r6
    d2cc:	14 96       	adiw	r26, 0x04	; 4
    d2ce:	ed 91       	ld	r30, X+
    d2d0:	fc 91       	ld	r31, X
    d2d2:	15 97       	sbiw	r26, 0x05	; 5
    d2d4:	e2 0d       	add	r30, r2
    d2d6:	f3 1d       	adc	r31, r3
    d2d8:	44 85       	ldd	r20, Z+12	; 0x0c
    d2da:	55 85       	ldd	r21, Z+13	; 0x0d
    d2dc:	66 85       	ldd	r22, Z+14	; 0x0e
    d2de:	77 85       	ldd	r23, Z+15	; 0x0f
    d2e0:	00 89       	ldd	r16, Z+16	; 0x10
    d2e2:	11 89       	ldd	r17, Z+17	; 0x11
    d2e4:	22 89       	ldd	r18, Z+18	; 0x12
    d2e6:	33 89       	ldd	r19, Z+19	; 0x13
    d2e8:	c4 88       	ldd	r12, Z+20	; 0x14
    d2ea:	d5 88       	ldd	r13, Z+21	; 0x15
    d2ec:	e6 88       	ldd	r14, Z+22	; 0x16
    d2ee:	f7 88       	ldd	r15, Z+23	; 0x17
    d2f0:	81 e0       	ldi	r24, 0x01	; 1
    d2f2:	90 e0       	ldi	r25, 0x00	; 0
    d2f4:	ef ee       	ldi	r30, 0xEF	; 239
    d2f6:	ae 2e       	mov	r10, r30
    d2f8:	ef ef       	ldi	r30, 0xFF	; 255
    d2fa:	be 2e       	mov	r11, r30
    d2fc:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
						axis=AxisPitch;
					break;
					case (AxisElbow):
							//Si el hombro se ha movido tengo que tomarlo en cuenta para calcular la 
							//posicion del codo
							mov_correlacionado(TrajectoryPOINT,pointIndex,AxisShoulder,AxisElbow,CORRELACION_HOMBRO_CODO);				
    d300:	c3 01       	movw	r24, r6
    d302:	b2 01       	movw	r22, r4
    d304:	41 e0       	ldi	r20, 0x01	; 1
    d306:	50 e0       	ldi	r21, 0x00	; 0
    d308:	22 e0       	ldi	r18, 0x02	; 2
    d30a:	30 e0       	ldi	r19, 0x00	; 0
    d30c:	0f 2e       	mov	r0, r31
    d30e:	fd e1       	ldi	r31, 0x1D	; 29
    d310:	ef 2e       	mov	r14, r31
    d312:	fa e5       	ldi	r31, 0x5A	; 90
    d314:	ff 2e       	mov	r15, r31
    d316:	f4 e5       	ldi	r31, 0x54	; 84
    d318:	0f 2f       	mov	r16, r31
    d31a:	ff e3       	ldi	r31, 0x3F	; 63
    d31c:	1f 2f       	mov	r17, r31
    d31e:	f0 2d       	mov	r31, r0
    d320:	0e 94 ad 66 	call	0xcd5a	; 0xcd5a <mov_correlacionado>
							mov_correlacionado(TrajectoryPOINT,pointIndex,AxisElbow,AxisPitch,CORRELACION_CODO_PITCH);
    d324:	c3 01       	movw	r24, r6
    d326:	b2 01       	movw	r22, r4
    d328:	42 e0       	ldi	r20, 0x02	; 2
    d32a:	50 e0       	ldi	r21, 0x00	; 0
    d32c:	23 e0       	ldi	r18, 0x03	; 3
    d32e:	30 e0       	ldi	r19, 0x00	; 0
    d330:	0f 2e       	mov	r0, r31
    d332:	f9 ec       	ldi	r31, 0xC9	; 201
    d334:	ef 2e       	mov	r14, r31
    d336:	fe e8       	ldi	r31, 0x8E	; 142
    d338:	ff 2e       	mov	r15, r31
    d33a:	fd e8       	ldi	r31, 0x8D	; 141
    d33c:	0f 2f       	mov	r16, r31
    d33e:	fc e3       	ldi	r31, 0x3C	; 60
    d340:	1f 2f       	mov	r17, r31
    d342:	f0 2d       	mov	r31, r0
    d344:	0e 94 ad 66 	call	0xcd5a	; 0xcd5a <mov_correlacionado>
    d348:	33 e0       	ldi	r19, 0x03	; 3
    d34a:	83 2e       	mov	r8, r19
    d34c:	91 2c       	mov	r9, r1
    d34e:	70 c0       	rjmp	.+224    	; 0xd430 <teach_pendant_point+0x408>
					case (AxisPitch):
						#ifdef DEBUGROBOTICS				
							printf("teach_pendant_point=> cargando valores de Pitch\n");
							//scanf("%d",&temp);
						#endif
						mov_correlacionado(TrajectoryPOINT,pointIndex,AxisShoulder,AxisElbow,CORRELACION_HOMBRO_CODO);
    d350:	c3 01       	movw	r24, r6
    d352:	b2 01       	movw	r22, r4
    d354:	41 e0       	ldi	r20, 0x01	; 1
    d356:	50 e0       	ldi	r21, 0x00	; 0
    d358:	22 e0       	ldi	r18, 0x02	; 2
    d35a:	30 e0       	ldi	r19, 0x00	; 0
    d35c:	0f 2e       	mov	r0, r31
    d35e:	fd e1       	ldi	r31, 0x1D	; 29
    d360:	ef 2e       	mov	r14, r31
    d362:	fa e5       	ldi	r31, 0x5A	; 90
    d364:	ff 2e       	mov	r15, r31
    d366:	f4 e5       	ldi	r31, 0x54	; 84
    d368:	0f 2f       	mov	r16, r31
    d36a:	ff e3       	ldi	r31, 0x3F	; 63
    d36c:	1f 2f       	mov	r17, r31
    d36e:	f0 2d       	mov	r31, r0
    d370:	0e 94 ad 66 	call	0xcd5a	; 0xcd5a <mov_correlacionado>
						mov_correlacionado(TrajectoryPOINT,pointIndex,AxisElbow,AxisPitch,CORRELACION_CODO_PITCH);					
    d374:	c3 01       	movw	r24, r6
    d376:	b2 01       	movw	r22, r4
    d378:	42 e0       	ldi	r20, 0x02	; 2
    d37a:	50 e0       	ldi	r21, 0x00	; 0
    d37c:	23 e0       	ldi	r18, 0x03	; 3
    d37e:	30 e0       	ldi	r19, 0x00	; 0
    d380:	0f 2e       	mov	r0, r31
    d382:	f9 ec       	ldi	r31, 0xC9	; 201
    d384:	ef 2e       	mov	r14, r31
    d386:	fe e8       	ldi	r31, 0x8E	; 142
    d388:	ff 2e       	mov	r15, r31
    d38a:	fd e8       	ldi	r31, 0x8D	; 141
    d38c:	0f 2f       	mov	r16, r31
    d38e:	fc e3       	ldi	r31, 0x3C	; 60
    d390:	1f 2f       	mov	r17, r31
    d392:	f0 2d       	mov	r31, r0
    d394:	0e 94 ad 66 	call	0xcd5a	; 0xcd5a <mov_correlacionado>
    d398:	4b c0       	rjmp	.+150    	; 0xd430 <teach_pendant_point+0x408>
					case (AxisRoll):
						#ifdef DEBUGROBOTICS				
							printf("teach_pendant_point=> cargando valores de Roll\n");
						//	scanf("%d",&temp);
						#endif
						position     = TrajectoryPOINT->point[pointIndex].axis[axis].position;
    d39a:	d3 01       	movw	r26, r6
    d39c:	14 96       	adiw	r26, 0x04	; 4
    d39e:	ed 91       	ld	r30, X+
    d3a0:	fc 91       	ld	r31, X
    d3a2:	15 97       	sbiw	r26, 0x05	; 5
    d3a4:	e2 0d       	add	r30, r2
    d3a6:	f3 1d       	adc	r31, r3
    d3a8:	80 a9       	ldd	r24, Z+48	; 0x30
    d3aa:	91 a9       	ldd	r25, Z+49	; 0x31
    d3ac:	a2 a9       	ldd	r26, Z+50	; 0x32
    d3ae:	b3 a9       	ldd	r27, Z+51	; 0x33
    d3b0:	8f a3       	std	Y+39, r24	; 0x27
    d3b2:	98 a7       	std	Y+40, r25	; 0x28
    d3b4:	a9 a7       	std	Y+41, r26	; 0x29
    d3b6:	ba a7       	std	Y+42, r27	; 0x2a
						velocity     = TrajectoryPOINT->point[pointIndex].axis[axis].velocity;
    d3b8:	84 a9       	ldd	r24, Z+52	; 0x34
    d3ba:	95 a9       	ldd	r25, Z+53	; 0x35
    d3bc:	a6 a9       	ldd	r26, Z+54	; 0x36
    d3be:	b7 a9       	ldd	r27, Z+55	; 0x37
    d3c0:	8b a3       	std	Y+35, r24	; 0x23
    d3c2:	9c a3       	std	Y+36, r25	; 0x24
    d3c4:	ad a3       	std	Y+37, r26	; 0x25
    d3c6:	be a3       	std	Y+38, r27	; 0x26
						acceleration = TrajectoryPOINT->point[pointIndex].axis[axis].acceleration;
    d3c8:	80 ad       	ldd	r24, Z+56	; 0x38
    d3ca:	91 ad       	ldd	r25, Z+57	; 0x39
    d3cc:	a2 ad       	ldd	r26, Z+58	; 0x3a
    d3ce:	b3 ad       	ldd	r27, Z+59	; 0x3b
    d3d0:	8f 8f       	std	Y+31, r24	; 0x1f
    d3d2:	98 a3       	std	Y+32, r25	; 0x20
    d3d4:	a9 a3       	std	Y+33, r26	; 0x21
    d3d6:	ba a3       	std	Y+34, r27	; 0x22
    d3d8:	2b c0       	rjmp	.+86     	; 0xd430 <teach_pendant_point+0x408>
						
					break;								
					default:
						//Aplican para cintura
						mov_axis(axis,TrajectoryPOINT->point[pointIndex].axis[axis].position, 
    d3da:	f3 01       	movw	r30, r6
    d3dc:	a4 81       	ldd	r26, Z+4	; 0x04
    d3de:	b5 81       	ldd	r27, Z+5	; 0x05
    d3e0:	a2 0d       	add	r26, r2
    d3e2:	b3 1d       	adc	r27, r3
    d3e4:	c4 01       	movw	r24, r8
    d3e6:	88 0f       	add	r24, r24
    d3e8:	99 1f       	adc	r25, r25
    d3ea:	88 0d       	add	r24, r8
    d3ec:	99 1d       	adc	r25, r9
    d3ee:	fc 01       	movw	r30, r24
    d3f0:	ee 0f       	add	r30, r30
    d3f2:	ff 1f       	adc	r31, r31
    d3f4:	ee 0f       	add	r30, r30
    d3f6:	ff 1f       	adc	r31, r31
    d3f8:	ea 0f       	add	r30, r26
    d3fa:	fb 1f       	adc	r31, r27
    d3fc:	40 81       	ld	r20, Z
    d3fe:	51 81       	ldd	r21, Z+1	; 0x01
    d400:	62 81       	ldd	r22, Z+2	; 0x02
    d402:	73 81       	ldd	r23, Z+3	; 0x03
    d404:	01 96       	adiw	r24, 0x01	; 1
    d406:	88 0f       	add	r24, r24
    d408:	99 1f       	adc	r25, r25
    d40a:	88 0f       	add	r24, r24
    d40c:	99 1f       	adc	r25, r25
    d40e:	a8 0f       	add	r26, r24
    d410:	b9 1f       	adc	r27, r25
    d412:	0d 91       	ld	r16, X+
    d414:	1d 91       	ld	r17, X+
    d416:	2d 91       	ld	r18, X+
    d418:	3c 91       	ld	r19, X
    d41a:	c0 84       	ldd	r12, Z+8	; 0x08
    d41c:	d1 84       	ldd	r13, Z+9	; 0x09
    d41e:	e2 84       	ldd	r14, Z+10	; 0x0a
    d420:	f3 84       	ldd	r15, Z+11	; 0x0b
    d422:	c4 01       	movw	r24, r8
    d424:	ef ee       	ldi	r30, 0xEF	; 239
    d426:	ae 2e       	mov	r10, r30
    d428:	ef ef       	ldi	r30, 0xFF	; 255
    d42a:	be 2e       	mov	r11, r30
    d42c:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
	acceleration_elbow_usr=TrajectoryPOINT->point[pointIndex].axis[AxisElbow].acceleration;
	velocity_pich_usr=TrajectoryPOINT->point[pointIndex].axis[AxisPitch].velocity;
	acceleration_pich_usr=TrajectoryPOINT->point[pointIndex].axis[AxisPitch].acceleration;
	//Busco el primer eje seleccionado y configuro el resto, es decir que si encuentro que hombro es el primero, 
	//configuro hombro, codo, pitch y salgo imediatamente del for para no reconfigurar con datos erroneos los demas ejes
	for(axis=0; axis < DOF; axis++) 
    d430:	08 94       	sec
    d432:	81 1c       	adc	r8, r1
    d434:	91 1c       	adc	r9, r1
    d436:	f5 e0       	ldi	r31, 0x05	; 5
    d438:	8f 16       	cp	r8, r31
    d43a:	91 04       	cpc	r9, r1
    d43c:	0c f4       	brge	.+2      	; 0xd440 <teach_pendant_point+0x418>
    d43e:	12 cf       	rjmp	.-476    	; 0xd264 <teach_pendant_point+0x23c>
	
	
	/*Se realiza el movimiento simultaneo de las articulaciones*/
	for(axis=0; axis < DOF; axis++) 
	{ 
		if(hAxis[axis].axis == 0) 
    d440:	af 85       	ldd	r26, Y+15	; 0x0f
    d442:	b8 89       	ldd	r27, Y+16	; 0x10
    d444:	12 96       	adiw	r26, 0x02	; 2
    d446:	8d 91       	ld	r24, X+
    d448:	9c 91       	ld	r25, X
    d44a:	13 97       	sbiw	r26, 0x03	; 3
    d44c:	89 2b       	or	r24, r25
    d44e:	29 f4       	brne	.+10     	; 0xd45a <teach_pendant_point+0x432>
		{
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    // move the robot (all axis in parallel)
    d450:	cd 01       	movw	r24, r26
    d452:	6f e0       	ldi	r22, 0x0F	; 15
    d454:	70 e0       	ldi	r23, 0x00	; 0
    d456:	0e 94 81 7a 	call	0xf502	; 0xf502 <PMDMultiUpdate>
    d45a:	ef 85       	ldd	r30, Y+15	; 0x0f
    d45c:	f8 89       	ldd	r31, Y+16	; 0x10
    d45e:	e0 5a       	subi	r30, 0xA0	; 160
    d460:	ff 4f       	sbci	r31, 0xFF	; 255
    d462:	f8 8b       	std	Y+16, r31	; 0x10
    d464:	ef 87       	std	Y+15, r30	; 0x0f
		}
	}
	
	
	/*Se realiza el movimiento simultaneo de las articulaciones*/
	for(axis=0; axis < DOF; axis++) 
    d466:	e9 5f       	subi	r30, 0xF9	; 249
    d468:	f6 47       	sbci	r31, 0x76	; 118
    d46a:	51 f7       	brne	.-44     	; 0xd440 <teach_pendant_point+0x418>
    d46c:	20 e0       	ldi	r18, 0x00	; 0
    d46e:	30 e0       	ldi	r19, 0x00	; 0
    d470:	48 ec       	ldi	r20, 0xC8	; 200
    d472:	50 e0       	ldi	r21, 0x00	; 0
    d474:	0a c0       	rjmp	.+20     	; 0xd48a <teach_pendant_point+0x462>
    d476:	fa 01       	movw	r30, r20
    d478:	31 97       	sbiw	r30, 0x01	; 1
    d47a:	f1 f7       	brne	.-4      	; 0xd478 <teach_pendant_point+0x450>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    d47c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    d47e:	d9 f7       	brne	.-10     	; 0xd476 <teach_pendant_point+0x44e>
			PMDMultiUpdate(&hAxis[axis],PMDAxis1Mask|PMDAxis2Mask|PMDAxis3Mask|PMDAxis4Mask);    // move the robot (all axis in parallel)
		} 
	}
	
	/*Espero un segundo a que los ejes comiencen a moverse*/
	for(test8=0; test8 < 10; test8++) 
    d480:	2f 5f       	subi	r18, 0xFF	; 255
    d482:	3f 4f       	sbci	r19, 0xFF	; 255
    d484:	2a 30       	cpi	r18, 0x0A	; 10
    d486:	31 05       	cpc	r19, r1
    d488:	19 f0       	breq	.+6      	; 0xd490 <teach_pendant_point+0x468>
    d48a:	88 ee       	ldi	r24, 0xE8	; 232
    d48c:	93 e0       	ldi	r25, 0x03	; 3
    d48e:	f3 cf       	rjmp	.-26     	; 0xd476 <teach_pendant_point+0x44e>
    d490:	00 e0       	ldi	r16, 0x00	; 0
    d492:	10 e0       	ldi	r17, 0x00	; 0
    d494:	ee 24       	eor	r14, r14
    d496:	ff 24       	eor	r15, r15
	}
	
	do
	{
		//Hallo el El registro de actividad en el hombro
		PMDGetActivityStatus(&hAxis[AxisShoulder],&status);
    d498:	4e 01       	movw	r8, r28
    d49a:	08 94       	sec
    d49c:	81 1c       	adc	r8, r1
    d49e:	91 1c       	adc	r9, r1
    d4a0:	89 e7       	ldi	r24, 0x79	; 121
    d4a2:	95 e7       	ldi	r25, 0x75	; 117
    d4a4:	b4 01       	movw	r22, r8
    d4a6:	0e 94 6f 78 	call	0xf0de	; 0xf0de <PMDGetActivityStatus>
		//Si hombro se mueve
		if ((status & PMDActivityInMotionMask) !=0)  
    d4aa:	89 81       	ldd	r24, Y+1	; 0x01
    d4ac:	9a 81       	ldd	r25, Y+2	; 0x02
    d4ae:	92 fd       	sbrc	r25, 2
    d4b0:	6d c0       	rjmp	.+218    	; 0xd58c <teach_pendant_point+0x564>
		{
			//tengo que mover el codo con la misma velocidad para no chocar	
		}
		else
		{	//Ya me puedo mover a la velocidad escogida por el usuario.
			if(reconf_Elbow==0)
    d4b2:	01 2b       	or	r16, r17
    d4b4:	a1 f4       	brne	.+40     	; 0xd4de <teach_pendant_point+0x4b6>
				printf("teach_pendant_point=> Reconfigurando Codo\n");
				printf("teach_pendant_point=> Velocidad codo usuario = %ld\n",velocity_elbow_usr);	
				printf("teach_pendant_point=> Aceleracion codo usuario = %ld\n",acceleration_elbow_usr);	
				#endif
				reconf_Elbow=1;
				PMDSetVelocity(&hAxis[AxisElbow],velocity_elbow_usr); 
    d4b6:	89 ed       	ldi	r24, 0xD9	; 217
    d4b8:	95 e7       	ldi	r25, 0x75	; 117
    d4ba:	4b 8d       	ldd	r20, Y+27	; 0x1b
    d4bc:	5c 8d       	ldd	r21, Y+28	; 0x1c
    d4be:	6d 8d       	ldd	r22, Y+29	; 0x1d
    d4c0:	7e 8d       	ldd	r23, Y+30	; 0x1e
    d4c2:	0e 94 ba 7e 	call	0xfd74	; 0xfd74 <PMDSetVelocity>
				PMDSetAcceleration(&hAxis[AxisElbow],acceleration_elbow_usr); 
    d4c6:	89 ed       	ldi	r24, 0xD9	; 217
    d4c8:	95 e7       	ldi	r25, 0x75	; 117
    d4ca:	4b 89       	ldd	r20, Y+19	; 0x13
    d4cc:	5c 89       	ldd	r21, Y+20	; 0x14
    d4ce:	6d 89       	ldd	r22, Y+21	; 0x15
    d4d0:	7e 89       	ldd	r23, Y+22	; 0x16
    d4d2:	0e 94 ac 7e 	call	0xfd58	; 0xfd58 <PMDSetAcceleration>
				PMDUpdate(&hAxis[AxisElbow]);
    d4d6:	89 ed       	ldi	r24, 0xD9	; 217
    d4d8:	95 e7       	ldi	r25, 0x75	; 117
    d4da:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
			}
			//Hallo el El registro de actividad en el codo
			PMDGetActivityStatus(&hAxis[AxisElbow],&status);
    d4de:	89 ed       	ldi	r24, 0xD9	; 217
    d4e0:	95 e7       	ldi	r25, 0x75	; 117
    d4e2:	b4 01       	movw	r22, r8
    d4e4:	0e 94 6f 78 	call	0xf0de	; 0xf0de <PMDGetActivityStatus>
			//Si codo se mueve
			if ((status & PMDActivityInMotionMask) !=0)
    d4e8:	89 81       	ldd	r24, Y+1	; 0x01
    d4ea:	9a 81       	ldd	r25, Y+2	; 0x02
    d4ec:	92 fd       	sbrc	r25, 2
    d4ee:	4c c0       	rjmp	.+152    	; 0xd588 <teach_pendant_point+0x560>
				//tengo que mover el pitch con la misma velocidad para no chocar	
			}
			else
			{
				//Ya me puedo mover a la velocidad escogida por el usuario.
				if(reconf_Pitch==0)
    d4f0:	e1 14       	cp	r14, r1
    d4f2:	f1 04       	cpc	r15, r1
    d4f4:	09 f0       	breq	.+2      	; 0xd4f8 <teach_pendant_point+0x4d0>
    d4f6:	48 c0       	rjmp	.+144    	; 0xd588 <teach_pendant_point+0x560>
				{
					reconf_Pitch=1;
					if(velocity_pich_usr>0)
    d4f8:	8f 89       	ldd	r24, Y+23	; 0x17
    d4fa:	98 8d       	ldd	r25, Y+24	; 0x18
    d4fc:	a9 8d       	ldd	r26, Y+25	; 0x19
    d4fe:	ba 8d       	ldd	r27, Y+26	; 0x1a
    d500:	18 16       	cp	r1, r24
    d502:	19 06       	cpc	r1, r25
    d504:	1a 06       	cpc	r1, r26
    d506:	1b 06       	cpc	r1, r27
    d508:	cc f5       	brge	.+114    	; 0xd57c <teach_pendant_point+0x554>
						printf("teach_pendant_point=> Velocidad Pitch usuario = %ld\n",velocity_pich_usr);	
						printf("teach_pendant_point=> Aceleracion Pitch usuario = %ld\n",acceleration_pich_usr);	
						printf("teach_pendant_point=> Posicion final de  Pitch= %ld\n",TrajectoryPOINT->point[pointIndex].axis[AxisPitch].position);	
						#endif
						//No puede usar la funcion pitch porque se reinicia los encoderes..
						mov_axis(AxisPitch, TrajectoryPOINT->point[pointIndex].axis[AxisPitch].position, 
    d50a:	d3 01       	movw	r26, r6
    d50c:	14 96       	adiw	r26, 0x04	; 4
    d50e:	ed 91       	ld	r30, X+
    d510:	fc 91       	ld	r31, X
    d512:	15 97       	sbiw	r26, 0x05	; 5
    d514:	e2 0d       	add	r30, r2
    d516:	f3 1d       	adc	r31, r3
    d518:	44 a1       	ldd	r20, Z+36	; 0x24
    d51a:	55 a1       	ldd	r21, Z+37	; 0x25
    d51c:	66 a1       	ldd	r22, Z+38	; 0x26
    d51e:	77 a1       	ldd	r23, Z+39	; 0x27
    d520:	83 e0       	ldi	r24, 0x03	; 3
    d522:	90 e0       	ldi	r25, 0x00	; 0
    d524:	0f 89       	ldd	r16, Y+23	; 0x17
    d526:	18 8d       	ldd	r17, Y+24	; 0x18
    d528:	29 8d       	ldd	r18, Y+25	; 0x19
    d52a:	3a 8d       	ldd	r19, Y+26	; 0x1a
    d52c:	cb a4       	ldd	r12, Y+43	; 0x2b
    d52e:	dc a4       	ldd	r13, Y+44	; 0x2c
    d530:	ed a4       	ldd	r14, Y+45	; 0x2d
    d532:	fe a4       	ldd	r15, Y+46	; 0x2e
    d534:	b0 ef       	ldi	r27, 0xF0	; 240
    d536:	ab 2e       	mov	r10, r27
    d538:	bf ef       	ldi	r27, 0xFF	; 255
    d53a:	bb 2e       	mov	r11, r27
    d53c:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
						velocity_pich_usr, acceleration_pich_usr, update);
						mov_axis(AxisRoll, -TrajectoryPOINT->point[pointIndex].axis[AxisPitch].position,
    d540:	d3 01       	movw	r26, r6
    d542:	14 96       	adiw	r26, 0x04	; 4
    d544:	ed 91       	ld	r30, X+
    d546:	fc 91       	ld	r31, X
    d548:	15 97       	sbiw	r26, 0x05	; 5
    d54a:	e2 0d       	add	r30, r2
    d54c:	f3 1d       	adc	r31, r3
    d54e:	44 a1       	ldd	r20, Z+36	; 0x24
    d550:	55 a1       	ldd	r21, Z+37	; 0x25
    d552:	66 a1       	ldd	r22, Z+38	; 0x26
    d554:	77 a1       	ldd	r23, Z+39	; 0x27
    d556:	70 95       	com	r23
    d558:	60 95       	com	r22
    d55a:	50 95       	com	r21
    d55c:	41 95       	neg	r20
    d55e:	5f 4f       	sbci	r21, 0xFF	; 255
    d560:	6f 4f       	sbci	r22, 0xFF	; 255
    d562:	7f 4f       	sbci	r23, 0xFF	; 255
    d564:	84 e0       	ldi	r24, 0x04	; 4
    d566:	90 e0       	ldi	r25, 0x00	; 0
    d568:	0f 89       	ldd	r16, Y+23	; 0x17
    d56a:	18 8d       	ldd	r17, Y+24	; 0x18
    d56c:	29 8d       	ldd	r18, Y+25	; 0x19
    d56e:	3a 8d       	ldd	r19, Y+26	; 0x1a
    d570:	cb a4       	ldd	r12, Y+43	; 0x2b
    d572:	dc a4       	ldd	r13, Y+44	; 0x2c
    d574:	ed a4       	ldd	r14, Y+45	; 0x2d
    d576:	fe a4       	ldd	r15, Y+46	; 0x2e
    d578:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
    d57c:	01 e0       	ldi	r16, 0x01	; 1
    d57e:	10 e0       	ldi	r17, 0x00	; 0
    d580:	a1 e0       	ldi	r26, 0x01	; 1
    d582:	ea 2e       	mov	r14, r26
    d584:	f1 2c       	mov	r15, r1
    d586:	02 c0       	rjmp	.+4      	; 0xd58c <teach_pendant_point+0x564>
    d588:	01 e0       	ldi	r16, 0x01	; 1
    d58a:	10 e0       	ldi	r17, 0x00	; 0
				}
			}
		}
		
	}	
	while( PMDcheckIdle(mask & ~Axis2AxisMask(AxisRoll))==FALSE);
    d58c:	84 e0       	ldi	r24, 0x04	; 4
    d58e:	90 e0       	ldi	r25, 0x00	; 0
    d590:	0e 94 ed 2e 	call	0x5dda	; 0x5dda <Axis2AxisMask>
    d594:	80 95       	com	r24
    d596:	90 95       	com	r25
    d598:	e9 89       	ldd	r30, Y+17	; 0x11
    d59a:	fa 89       	ldd	r31, Y+18	; 0x12
    d59c:	8e 23       	and	r24, r30
    d59e:	9f 23       	and	r25, r31
    d5a0:	0e 94 d2 4d 	call	0x9ba4	; 0x9ba4 <PMDcheckIdle>
    d5a4:	89 2b       	or	r24, r25
    d5a6:	09 f4       	brne	.+2      	; 0xd5aa <teach_pendant_point+0x582>
    d5a8:	7b cf       	rjmp	.-266    	; 0xd4a0 <teach_pendant_point+0x478>

	
	//Una vez el robot este totalmente detenido se empieza a efectur el movimiento de Roll 
	//(si existe) para eso se debe habiliar los ejes de pitch and Roll limpiando  el bit
	//de Motion Complete ( Bit 0 del Event Status Register).	
	if((hAxis[AxisRoll].axisSettings.axisEnabled == TRUE) && 
    d5aa:	80 91 9d 76 	lds	r24, 0x769D
    d5ae:	81 30       	cpi	r24, 0x01	; 1
    d5b0:	39 f5       	brne	.+78     	; 0xd600 <teach_pendant_point+0x5d8>
    d5b2:	84 e0       	ldi	r24, 0x04	; 4
    d5b4:	90 e0       	ldi	r25, 0x00	; 0
    d5b6:	0e 94 ed 2e 	call	0x5dda	; 0x5dda <Axis2AxisMask>
    d5ba:	29 89       	ldd	r18, Y+17	; 0x11
    d5bc:	3a 89       	ldd	r19, Y+18	; 0x12
    d5be:	82 23       	and	r24, r18
    d5c0:	93 23       	and	r25, r19
    d5c2:	18 16       	cp	r1, r24
    d5c4:	19 06       	cpc	r1, r25
    d5c6:	e4 f4       	brge	.+56     	; 0xd600 <teach_pendant_point+0x5d8>
		((mask & (Axis2AxisMask(AxisRoll))) >0  )) 
	{ 
		Enable_Mov();
    d5c8:	0e 94 9b 4d 	call	0x9b36	; 0x9b36 <Enable_Mov>
		roll(position,velocity,acceleration,update,MOVIMIENTO_NORMAL );			//Efectuo movimiento de Roll.
    d5cc:	6f a1       	ldd	r22, Y+39	; 0x27
    d5ce:	78 a5       	ldd	r23, Y+40	; 0x28
    d5d0:	89 a5       	ldd	r24, Y+41	; 0x29
    d5d2:	9a a5       	ldd	r25, Y+42	; 0x2a
    d5d4:	2b a1       	ldd	r18, Y+35	; 0x23
    d5d6:	3c a1       	ldd	r19, Y+36	; 0x24
    d5d8:	4d a1       	ldd	r20, Y+37	; 0x25
    d5da:	5e a1       	ldd	r21, Y+38	; 0x26
    d5dc:	ef 8c       	ldd	r14, Y+31	; 0x1f
    d5de:	f8 a0       	ldd	r15, Y+32	; 0x20
    d5e0:	09 a1       	ldd	r16, Y+33	; 0x21
    d5e2:	1a a1       	ldd	r17, Y+34	; 0x22
    d5e4:	f0 ef       	ldi	r31, 0xF0	; 240
    d5e6:	cf 2e       	mov	r12, r31
    d5e8:	ff ef       	ldi	r31, 0xFF	; 255
    d5ea:	df 2e       	mov	r13, r31
    d5ec:	e1 e0       	ldi	r30, 0x01	; 1
    d5ee:	ae 2e       	mov	r10, r30
    d5f0:	b1 2c       	mov	r11, r1
    d5f2:	0e 94 1b 50 	call	0xa036	; 0xa036 <roll>
    d5f6:	04 c0       	rjmp	.+8      	; 0xd600 <teach_pendant_point+0x5d8>
	}

	while( PMDcheckIdle(mask & Axis2AxisMask(AxisRoll))==FALSE)	
	{	

		printf("teach_pendant_point=> Efectuando Movimiento de Roll.\n");
    d5f8:	82 e7       	ldi	r24, 0x72	; 114
    d5fa:	99 e5       	ldi	r25, 0x59	; 89
    d5fc:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	{ 
		Enable_Mov();
		roll(position,velocity,acceleration,update,MOVIMIENTO_NORMAL );			//Efectuo movimiento de Roll.
	}

	while( PMDcheckIdle(mask & Axis2AxisMask(AxisRoll))==FALSE)	
    d600:	84 e0       	ldi	r24, 0x04	; 4
    d602:	90 e0       	ldi	r25, 0x00	; 0
    d604:	0e 94 ed 2e 	call	0x5dda	; 0x5dda <Axis2AxisMask>
    d608:	a9 89       	ldd	r26, Y+17	; 0x11
    d60a:	ba 89       	ldd	r27, Y+18	; 0x12
    d60c:	8a 23       	and	r24, r26
    d60e:	9b 23       	and	r25, r27
    d610:	0e 94 d2 4d 	call	0x9ba4	; 0x9ba4 <PMDcheckIdle>
    d614:	89 2b       	or	r24, r25
    d616:	81 f3       	breq	.-32     	; 0xd5f8 <teach_pendant_point+0x5d0>
	}

	//Habilitar todos los ejes para el proximo movimiento limpiando la el bit
	//de Motion Complete ( Bit 0 del Event Status Register).*/

	Enable_Mov();
    d618:	0e 94 9b 4d 	call	0x9b36	; 0x9b36 <Enable_Mov>
	
	printf("teach_pendant_point=> Fin del Movimiento \n");
    d61c:	87 ea       	ldi	r24, 0xA7	; 167
    d61e:	99 e5       	ldi	r25, 0x59	; 89
    d620:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	
	
}
    d624:	ae 96       	adiw	r28, 0x2e	; 46
    d626:	0f b6       	in	r0, 0x3f	; 63
    d628:	f8 94       	cli
    d62a:	de bf       	out	0x3e, r29	; 62
    d62c:	0f be       	out	0x3f, r0	; 63
    d62e:	cd bf       	out	0x3d, r28	; 61
    d630:	cf 91       	pop	r28
    d632:	df 91       	pop	r29
    d634:	1f 91       	pop	r17
    d636:	0f 91       	pop	r16
    d638:	ff 90       	pop	r15
    d63a:	ef 90       	pop	r14
    d63c:	df 90       	pop	r13
    d63e:	cf 90       	pop	r12
    d640:	bf 90       	pop	r11
    d642:	af 90       	pop	r10
    d644:	9f 90       	pop	r9
    d646:	8f 90       	pop	r8
    d648:	7f 90       	pop	r7
    d64a:	6f 90       	pop	r6
    d64c:	5f 90       	pop	r5
    d64e:	4f 90       	pop	r4
    d650:	3f 90       	pop	r3
    d652:	2f 90       	pop	r2
    d654:	08 95       	ret

0000d656 <PMDprocessTrajectory>:
	
}

//**********************************************************************************************
void PMDprocessTrajectory(tTrajectory* Trajectory, int16 TraceOP)
{
    d656:	af 92       	push	r10
    d658:	bf 92       	push	r11
    d65a:	cf 92       	push	r12
    d65c:	df 92       	push	r13
    d65e:	ef 92       	push	r14
    d660:	ff 92       	push	r15
    d662:	0f 93       	push	r16
    d664:	1f 93       	push	r17
    d666:	cf 93       	push	r28
    d668:	df 93       	push	r29
    d66a:	7c 01       	movw	r14, r24
    d66c:	6b 01       	movw	r12, r22
    d66e:	c0 e0       	ldi	r28, 0x00	; 0
    d670:	d0 e0       	ldi	r29, 0x00	; 0
    d672:	00 e0       	ldi	r16, 0x00	; 0
    d674:	10 e0       	ldi	r17, 0x00	; 0
	printf("PMDprocessTrajectory=> El Numero de puntos de la trayectoria es en PMDfunctions.c => %d\n",Trajectory->size);
	printf("PMDprocessTrajectory=> invalid mask en PMDfunctions.c => %X\n",Trajectory->invalidmask);
	#endif
	do
	{  
		printf("PMDprocessTrajectory=> Procesado el  punto %d \n",pointIndex);
    d676:	91 ed       	ldi	r25, 0xD1	; 209
    d678:	a9 2e       	mov	r10, r25
    d67a:	99 e5       	ldi	r25, 0x59	; 89
    d67c:	b9 2e       	mov	r11, r25
    d67e:	00 d0       	rcall	.+0      	; 0xd680 <PMDprocessTrajectory+0x2a>
    d680:	00 d0       	rcall	.+0      	; 0xd682 <PMDprocessTrajectory+0x2c>
    d682:	ad b7       	in	r26, 0x3d	; 61
    d684:	be b7       	in	r27, 0x3e	; 62
    d686:	12 96       	adiw	r26, 0x02	; 2
    d688:	bc 92       	st	X, r11
    d68a:	ae 92       	st	-X, r10
    d68c:	11 97       	sbiw	r26, 0x01	; 1
    d68e:	14 96       	adiw	r26, 0x04	; 4
    d690:	dc 93       	st	X, r29
    d692:	ce 93       	st	-X, r28
    d694:	13 97       	sbiw	r26, 0x03	; 3
    d696:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
				Trajectory->point[pointIndex].axis[AxisRoll].position);
		#endif
		//Cargo la posicion, velocidad, aceleracion con pointIndex tomando encuenta 
		//La interaccion de los ejes, espera a que termine el movimiento de cintura, 
		//hombro, codo y pich para finalmente  ejecutar roll
		teach_pendant_point(Trajectory,pointIndex);
    d69a:	0f 90       	pop	r0
    d69c:	0f 90       	pop	r0
    d69e:	0f 90       	pop	r0
    d6a0:	0f 90       	pop	r0
    d6a2:	c7 01       	movw	r24, r14
    d6a4:	be 01       	movw	r22, r28
    d6a6:	0e 94 14 68 	call	0xd028	; 0xd028 <teach_pendant_point>
		/*Ejecuto movimiento del gripper*/
		if(Trajectory->point[pointIndex].Gripper_Status==1)
    d6aa:	d7 01       	movw	r26, r14
    d6ac:	14 96       	adiw	r26, 0x04	; 4
    d6ae:	ed 91       	ld	r30, X+
    d6b0:	fc 91       	ld	r31, X
    d6b2:	15 97       	sbiw	r26, 0x05	; 5
    d6b4:	e0 0f       	add	r30, r16
    d6b6:	f1 1f       	adc	r31, r17
    d6b8:	84 ad       	ldd	r24, Z+60	; 0x3c
    d6ba:	81 30       	cpi	r24, 0x01	; 1
    d6bc:	11 f4       	brne	.+4      	; 0xd6c2 <PMDprocessTrajectory+0x6c>
		{
			closeGripper();
    d6be:	0e 94 91 91 	call	0x12322	; 0x12322 <closeGripper>
			#ifdef DEBUGROBOTICS
			printf("PMDprocessTrajectory=> Pose con gripper cerrado\n");	
			#endif
		}
		if(Trajectory->point[pointIndex].Gripper_Status==0)
    d6c2:	d7 01       	movw	r26, r14
    d6c4:	14 96       	adiw	r26, 0x04	; 4
    d6c6:	ed 91       	ld	r30, X+
    d6c8:	fc 91       	ld	r31, X
    d6ca:	15 97       	sbiw	r26, 0x05	; 5
    d6cc:	e0 0f       	add	r30, r16
    d6ce:	f1 1f       	adc	r31, r17
    d6d0:	84 ad       	ldd	r24, Z+60	; 0x3c
    d6d2:	88 23       	and	r24, r24
    d6d4:	11 f4       	brne	.+4      	; 0xd6da <PMDprocessTrajectory+0x84>
		{
			openGripper();
    d6d6:	0e 94 60 91 	call	0x122c0	; 0x122c0 <openGripper>
			#ifdef DEBUGROBOTICS
			printf("PMDprocessTrajectory=> Pose con gripper abierto\n");	
			#endif
		}
		pointIndex++;				
    d6da:	21 96       	adiw	r28, 0x01	; 1
    d6dc:	03 5c       	subi	r16, 0xC3	; 195
    d6de:	1f 4f       	sbci	r17, 0xFF	; 255
	}
	while (pointIndex <  (Trajectory->size)); //pointIndex es la variable que marca el punto en ejecucion 
    d6e0:	f7 01       	movw	r30, r14
    d6e2:	80 81       	ld	r24, Z
    d6e4:	91 81       	ldd	r25, Z+1	; 0x01
    d6e6:	c8 17       	cp	r28, r24
    d6e8:	d9 07       	cpc	r29, r25
    d6ea:	4c f2       	brlt	.-110    	; 0xd67e <PMDprocessTrajectory+0x28>
    printf("PMDprocessTrajectory=>  Saliendo de PMDprocessTrajectory\n");
    d6ec:	81 e0       	ldi	r24, 0x01	; 1
    d6ee:	9a e5       	ldi	r25, 0x5A	; 90
    d6f0:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	//He configurado trazar una trajectoria
	if(TraceOP==1)
    d6f4:	f1 e0       	ldi	r31, 0x01	; 1
    d6f6:	cf 16       	cp	r12, r31
    d6f8:	d1 04       	cpc	r13, r1
    d6fa:	49 f4       	brne	.+18     	; 0xd70e <PMDprocessTrajectory+0xb8>
	{
		//Parao el trazado para PMD1
		PMDSetTraceStop(&hAxis[AxisWaist],AxisWaist,PMDTraceConditionImmediate,0,0);
    d6fc:	89 e1       	ldi	r24, 0x19	; 25
    d6fe:	95 e7       	ldi	r25, 0x75	; 117
    d700:	60 e0       	ldi	r22, 0x00	; 0
    d702:	70 e0       	ldi	r23, 0x00	; 0
    d704:	40 e0       	ldi	r20, 0x00	; 0
    d706:	20 e0       	ldi	r18, 0x00	; 0
    d708:	00 e0       	ldi	r16, 0x00	; 0
    d70a:	0e 94 79 79 	call	0xf2f2	; 0xf2f2 <PMDSetTraceStop>
		//PMDSetTraceStop(&hAxis[axis], axis,PMDTraceConditionImmediate,0,0);
	}

	
} 
    d70e:	df 91       	pop	r29
    d710:	cf 91       	pop	r28
    d712:	1f 91       	pop	r17
    d714:	0f 91       	pop	r16
    d716:	ff 90       	pop	r15
    d718:	ef 90       	pop	r14
    d71a:	df 90       	pop	r13
    d71c:	cf 90       	pop	r12
    d71e:	bf 90       	pop	r11
    d720:	af 90       	pop	r10
    d722:	08 95       	ret

0000d724 <checkconnect>:
	
	return ErrorPMD;
}
/**********************************************************************************************************************/
int16 checkconnect(void)
{
    d724:	2f 92       	push	r2
    d726:	3f 92       	push	r3
    d728:	4f 92       	push	r4
    d72a:	5f 92       	push	r5
    d72c:	6f 92       	push	r6
    d72e:	7f 92       	push	r7
    d730:	8f 92       	push	r8
    d732:	9f 92       	push	r9
    d734:	af 92       	push	r10
    d736:	bf 92       	push	r11
    d738:	cf 92       	push	r12
    d73a:	df 92       	push	r13
    d73c:	ef 92       	push	r14
    d73e:	ff 92       	push	r15
    d740:	0f 93       	push	r16
    d742:	1f 93       	push	r17
    d744:	df 93       	push	r29
    d746:	cf 93       	push	r28
    d748:	00 d0       	rcall	.+0      	; 0xd74a <checkconnect+0x26>
    d74a:	cd b7       	in	r28, 0x3d	; 61
    d74c:	de b7       	in	r29, 0x3e	; 62
	
	rc=rcOK;
	
	/** SE observa el Estado del Boton de Parada de Emergecia **/
	
	if(bit_is_set(PIND, Estado_Boton_Emergencia))
    d74e:	4a 9b       	sbis	0x09, 2	; 9
    d750:	1c c0       	rjmp	.+56     	; 0xd78a <checkconnect+0x66>
	{
		buzzer(1);
    d752:	81 e0       	ldi	r24, 0x01	; 1
    d754:	90 e0       	ldi	r25, 0x00	; 0
    d756:	0e 94 41 8d 	call	0x11a82	; 0x11a82 <buzzer>
		
		printf("checkconnect=> Boton de Parada de Emergencia Activo \n");
    d75a:	8a e3       	ldi	r24, 0x3A	; 58
    d75c:	9a e5       	ldi	r25, 0x5A	; 90
    d75e:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
		fprintf_P(stderr,PSTR("Boton de Parada de Emergencia Activo \n"));
    d762:	00 d0       	rcall	.+0      	; 0xd764 <checkconnect+0x40>
    d764:	00 d0       	rcall	.+0      	; 0xd766 <checkconnect+0x42>
    d766:	80 91 d2 79 	lds	r24, 0x79D2
    d76a:	90 91 d3 79 	lds	r25, 0x79D3
    d76e:	ed b7       	in	r30, 0x3d	; 61
    d770:	fe b7       	in	r31, 0x3e	; 62
    d772:	92 83       	std	Z+2, r25	; 0x02
    d774:	81 83       	std	Z+1, r24	; 0x01
    d776:	80 e1       	ldi	r24, 0x10	; 16
    d778:	98 e1       	ldi	r25, 0x18	; 24
    d77a:	94 83       	std	Z+4, r25	; 0x04
    d77c:	83 83       	std	Z+3, r24	; 0x03
    d77e:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    d782:	0f 90       	pop	r0
    d784:	0f 90       	pop	r0
    d786:	0f 90       	pop	r0
    d788:	0f 90       	pop	r0
    d78a:	49 e1       	ldi	r20, 0x19	; 25
    d78c:	c4 2e       	mov	r12, r20
    d78e:	45 e7       	ldi	r20, 0x75	; 117
    d790:	d4 2e       	mov	r13, r20
    d792:	ee 24       	eor	r14, r14
    d794:	ff 24       	eor	r15, r15
    d796:	00 e0       	ldi	r16, 0x00	; 0
    d798:	10 e0       	ldi	r17, 0x00	; 0
		
	}
	for(Axis=0; Axis < DOF; Axis++) 
	{
		
		PMDGetSignalStatus(&hAxis[Axis],&signal_status);	
    d79a:	1e 01       	movw	r2, r28
    d79c:	08 94       	sec
    d79e:	21 1c       	adc	r2, r1
    d7a0:	31 1c       	adc	r3, r1
			{
				
				buzzer_ms(50);
				buzzer_ms(50);
				Chipset=Axis2PMDChipset(Axis)+1;
				printf("checkconnect=> Cable #%d de Sensores esta desconectado \n",Chipset);
    d7a2:	3f e6       	ldi	r19, 0x6F	; 111
    d7a4:	43 2e       	mov	r4, r19
    d7a6:	3a e5       	ldi	r19, 0x5A	; 90
    d7a8:	53 2e       	mov	r5, r19
				printf("checkconnect=> Los switch del eje de %s estan desconectados \n",AxisName(Axis));
    d7aa:	28 ea       	ldi	r18, 0xA8	; 168
    d7ac:	62 2e       	mov	r6, r18
    d7ae:	2a e5       	ldi	r18, 0x5A	; 90
    d7b0:	72 2e       	mov	r7, r18
				//impresion de caracteres Display
				if (Chipset==1)
					fprintf_P(stderr,PSTR("Cable #1 de sensores desconectado \n"));
				
				if (Chipset==2)
					fprintf_P(stderr,PSTR("Cable #2 de sensores desconectado \n"));
    d7b2:	98 ec       	ldi	r25, 0xC8	; 200
    d7b4:	89 2e       	mov	r8, r25
    d7b6:	97 e1       	ldi	r25, 0x17	; 23
    d7b8:	99 2e       	mov	r9, r25
				printf("checkconnect=> Cable #%d de Sensores esta desconectado \n",Chipset);
				printf("checkconnect=> Los switch del eje de %s estan desconectados \n",AxisName(Axis));
				
				//impresion de caracteres Display
				if (Chipset==1)
					fprintf_P(stderr,PSTR("Cable #1 de sensores desconectado \n"));
    d7ba:	8c ee       	ldi	r24, 0xEC	; 236
    d7bc:	a8 2e       	mov	r10, r24
    d7be:	87 e1       	ldi	r24, 0x17	; 23
    d7c0:	b8 2e       	mov	r11, r24
		
	}
	for(Axis=0; Axis < DOF; Axis++) 
	{
		
		PMDGetSignalStatus(&hAxis[Axis],&signal_status);	
    d7c2:	c6 01       	movw	r24, r12
    d7c4:	b1 01       	movw	r22, r2
    d7c6:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
		
		if ((signal_status & PMDSignalPositiveLimitMask) ==0) //Significa que esta activado el Limite Positivo
    d7ca:	89 81       	ldd	r24, Y+1	; 0x01
    d7cc:	84 fd       	sbrc	r24, 4
    d7ce:	5d c0       	rjmp	.+186    	; 0xd88a <checkconnect+0x166>
		{
			
			/*Verificar si los cables de Sensores estan conectados*/
			if((signal_status & PMDSignalNegativeLimitMask) ==0)
    d7d0:	85 fd       	sbrc	r24, 5
    d7d2:	5b c0       	rjmp	.+182    	; 0xd88a <checkconnect+0x166>
			{
				
				buzzer_ms(50);
    d7d4:	62 e3       	ldi	r22, 0x32	; 50
    d7d6:	70 e0       	ldi	r23, 0x00	; 0
    d7d8:	80 e0       	ldi	r24, 0x00	; 0
    d7da:	90 e0       	ldi	r25, 0x00	; 0
    d7dc:	0e 94 56 8d 	call	0x11aac	; 0x11aac <buzzer_ms>
				buzzer_ms(50);
    d7e0:	62 e3       	ldi	r22, 0x32	; 50
    d7e2:	70 e0       	ldi	r23, 0x00	; 0
    d7e4:	80 e0       	ldi	r24, 0x00	; 0
    d7e6:	90 e0       	ldi	r25, 0x00	; 0
    d7e8:	0e 94 56 8d 	call	0x11aac	; 0x11aac <buzzer_ms>
				Chipset=Axis2PMDChipset(Axis)+1;
    d7ec:	c7 01       	movw	r24, r14
    d7ee:	0e 94 c8 7e 	call	0xfd90	; 0xfd90 <Axis2PMDChipset>
    d7f2:	8c 01       	movw	r16, r24
    d7f4:	0f 5f       	subi	r16, 0xFF	; 255
    d7f6:	1f 4f       	sbci	r17, 0xFF	; 255
				printf("checkconnect=> Cable #%d de Sensores esta desconectado \n",Chipset);
    d7f8:	00 d0       	rcall	.+0      	; 0xd7fa <checkconnect+0xd6>
    d7fa:	00 d0       	rcall	.+0      	; 0xd7fc <checkconnect+0xd8>
    d7fc:	ed b7       	in	r30, 0x3d	; 61
    d7fe:	fe b7       	in	r31, 0x3e	; 62
    d800:	52 82       	std	Z+2, r5	; 0x02
    d802:	41 82       	std	Z+1, r4	; 0x01
    d804:	14 83       	std	Z+4, r17	; 0x04
    d806:	03 83       	std	Z+3, r16	; 0x03
    d808:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
				printf("checkconnect=> Los switch del eje de %s estan desconectados \n",AxisName(Axis));
    d80c:	0f 90       	pop	r0
    d80e:	0f 90       	pop	r0
    d810:	0f 90       	pop	r0
    d812:	0f 90       	pop	r0
    d814:	c7 01       	movw	r24, r14
    d816:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    d81a:	00 d0       	rcall	.+0      	; 0xd81c <checkconnect+0xf8>
    d81c:	00 d0       	rcall	.+0      	; 0xd81e <checkconnect+0xfa>
    d81e:	ed b7       	in	r30, 0x3d	; 61
    d820:	fe b7       	in	r31, 0x3e	; 62
    d822:	72 82       	std	Z+2, r7	; 0x02
    d824:	61 82       	std	Z+1, r6	; 0x01
    d826:	94 83       	std	Z+4, r25	; 0x04
    d828:	83 83       	std	Z+3, r24	; 0x03
    d82a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
				
				//impresion de caracteres Display
				if (Chipset==1)
    d82e:	0f 90       	pop	r0
    d830:	0f 90       	pop	r0
    d832:	0f 90       	pop	r0
    d834:	0f 90       	pop	r0
    d836:	01 30       	cpi	r16, 0x01	; 1
    d838:	11 05       	cpc	r17, r1
    d83a:	69 f4       	brne	.+26     	; 0xd856 <checkconnect+0x132>
					fprintf_P(stderr,PSTR("Cable #1 de sensores desconectado \n"));
    d83c:	00 d0       	rcall	.+0      	; 0xd83e <checkconnect+0x11a>
    d83e:	00 d0       	rcall	.+0      	; 0xd840 <checkconnect+0x11c>
    d840:	80 91 d2 79 	lds	r24, 0x79D2
    d844:	90 91 d3 79 	lds	r25, 0x79D3
    d848:	ed b7       	in	r30, 0x3d	; 61
    d84a:	fe b7       	in	r31, 0x3e	; 62
    d84c:	92 83       	std	Z+2, r25	; 0x02
    d84e:	81 83       	std	Z+1, r24	; 0x01
    d850:	b4 82       	std	Z+4, r11	; 0x04
    d852:	a3 82       	std	Z+3, r10	; 0x03
    d854:	12 c0       	rjmp	.+36     	; 0xd87a <checkconnect+0x156>
				
				if (Chipset==2)
    d856:	02 30       	cpi	r16, 0x02	; 2
    d858:	11 05       	cpc	r17, r1
    d85a:	19 f0       	breq	.+6      	; 0xd862 <checkconnect+0x13e>
    d85c:	0f ef       	ldi	r16, 0xFF	; 255
    d85e:	1f ef       	ldi	r17, 0xFF	; 255
    d860:	14 c0       	rjmp	.+40     	; 0xd88a <checkconnect+0x166>
					fprintf_P(stderr,PSTR("Cable #2 de sensores desconectado \n"));
    d862:	00 d0       	rcall	.+0      	; 0xd864 <checkconnect+0x140>
    d864:	00 d0       	rcall	.+0      	; 0xd866 <checkconnect+0x142>
    d866:	80 91 d2 79 	lds	r24, 0x79D2
    d86a:	90 91 d3 79 	lds	r25, 0x79D3
    d86e:	ed b7       	in	r30, 0x3d	; 61
    d870:	fe b7       	in	r31, 0x3e	; 62
    d872:	92 83       	std	Z+2, r25	; 0x02
    d874:	81 83       	std	Z+1, r24	; 0x01
    d876:	94 82       	std	Z+4, r9	; 0x04
    d878:	83 82       	std	Z+3, r8	; 0x03
    d87a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
    d87e:	0f ef       	ldi	r16, 0xFF	; 255
    d880:	1f ef       	ldi	r17, 0xFF	; 255
    d882:	0f 90       	pop	r0
    d884:	0f 90       	pop	r0
    d886:	0f 90       	pop	r0
    d888:	0f 90       	pop	r0
		
		printf("checkconnect=> Boton de Parada de Emergencia Activo \n");
		fprintf_P(stderr,PSTR("Boton de Parada de Emergencia Activo \n"));
		
	}
	for(Axis=0; Axis < DOF; Axis++) 
    d88a:	08 94       	sec
    d88c:	e1 1c       	adc	r14, r1
    d88e:	f1 1c       	adc	r15, r1
    d890:	80 e6       	ldi	r24, 0x60	; 96
    d892:	90 e0       	ldi	r25, 0x00	; 0
    d894:	c8 0e       	add	r12, r24
    d896:	d9 1e       	adc	r13, r25
    d898:	95 e0       	ldi	r25, 0x05	; 5
    d89a:	e9 16       	cp	r14, r25
    d89c:	f1 04       	cpc	r15, r1
    d89e:	09 f0       	breq	.+2      	; 0xd8a2 <checkconnect+0x17e>
    d8a0:	90 cf       	rjmp	.-224    	; 0xd7c2 <checkconnect+0x9e>
		}
		
	}
	
	return rc;
}
    d8a2:	c8 01       	movw	r24, r16
    d8a4:	0f 90       	pop	r0
    d8a6:	0f 90       	pop	r0
    d8a8:	cf 91       	pop	r28
    d8aa:	df 91       	pop	r29
    d8ac:	1f 91       	pop	r17
    d8ae:	0f 91       	pop	r16
    d8b0:	ff 90       	pop	r15
    d8b2:	ef 90       	pop	r14
    d8b4:	df 90       	pop	r13
    d8b6:	cf 90       	pop	r12
    d8b8:	bf 90       	pop	r11
    d8ba:	af 90       	pop	r10
    d8bc:	9f 90       	pop	r9
    d8be:	8f 90       	pop	r8
    d8c0:	7f 90       	pop	r7
    d8c2:	6f 90       	pop	r6
    d8c4:	5f 90       	pop	r5
    d8c6:	4f 90       	pop	r4
    d8c8:	3f 90       	pop	r3
    d8ca:	2f 90       	pop	r2
    d8cc:	08 95       	ret

0000d8ce <Print_Handlesinfo>:
}

/**********************************************************************************************************************/

void Print_Handlesinfo(void)
{
    d8ce:	8f 92       	push	r8
    d8d0:	9f 92       	push	r9
    d8d2:	af 92       	push	r10
    d8d4:	bf 92       	push	r11
    d8d6:	cf 92       	push	r12
    d8d8:	df 92       	push	r13
    d8da:	ef 92       	push	r14
    d8dc:	ff 92       	push	r15
    d8de:	0f 93       	push	r16
    d8e0:	1f 93       	push	r17
    d8e2:	cf 93       	push	r28
    d8e4:	df 93       	push	r29
    d8e6:	09 e1       	ldi	r16, 0x19	; 25
    d8e8:	15 e7       	ldi	r17, 0x75	; 117
    d8ea:	c0 e0       	ldi	r28, 0x00	; 0
    d8ec:	d0 e0       	ldi	r29, 0x00	; 0
  int16 axis;
  
	for(axis=0; axis < DOF; axis++) 
	{  
		printf("Print_Handlesinfo=> El Index del vector es %d \n",axis );
    d8ee:	e6 ee       	ldi	r30, 0xE6	; 230
    d8f0:	8e 2e       	mov	r8, r30
    d8f2:	ea e5       	ldi	r30, 0x5A	; 90
    d8f4:	9e 2e       	mov	r9, r30
		printf("Print_Handlesinfo=> hAxis[%d].axis es igual a  %d  \n",axis,hAxis[axis].axis);
    d8f6:	76 e1       	ldi	r23, 0x16	; 22
    d8f8:	a7 2e       	mov	r10, r23
    d8fa:	7b e5       	ldi	r23, 0x5B	; 91
    d8fc:	b7 2e       	mov	r11, r23
		printf("Print_Handlesinfo=> Corresponde a %s \n",AxisName(axis));
    d8fe:	6b e4       	ldi	r22, 0x4B	; 75
    d900:	c6 2e       	mov	r12, r22
    d902:	6b e5       	ldi	r22, 0x5B	; 91
    d904:	d6 2e       	mov	r13, r22
		printf("Print_Handlesinfo=> Es manejado por el chipset %d  \n",hAxis[axis].chipset);
    d906:	52 e7       	ldi	r21, 0x72	; 114
    d908:	e5 2e       	mov	r14, r21
    d90a:	5b e5       	ldi	r21, 0x5B	; 91
    d90c:	f5 2e       	mov	r15, r21
{
  int16 axis;
  
	for(axis=0; axis < DOF; axis++) 
	{  
		printf("Print_Handlesinfo=> El Index del vector es %d \n",axis );
    d90e:	00 d0       	rcall	.+0      	; 0xd910 <Print_Handlesinfo+0x42>
    d910:	00 d0       	rcall	.+0      	; 0xd912 <Print_Handlesinfo+0x44>
    d912:	ad b7       	in	r26, 0x3d	; 61
    d914:	be b7       	in	r27, 0x3e	; 62
    d916:	12 96       	adiw	r26, 0x02	; 2
    d918:	9c 92       	st	X, r9
    d91a:	8e 92       	st	-X, r8
    d91c:	11 97       	sbiw	r26, 0x01	; 1
    d91e:	14 96       	adiw	r26, 0x04	; 4
    d920:	dc 93       	st	X, r29
    d922:	ce 93       	st	-X, r28
    d924:	13 97       	sbiw	r26, 0x03	; 3
    d926:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("Print_Handlesinfo=> hAxis[%d].axis es igual a  %d  \n",axis,hAxis[axis].axis);
    d92a:	00 d0       	rcall	.+0      	; 0xd92c <Print_Handlesinfo+0x5e>
    d92c:	ed b7       	in	r30, 0x3d	; 61
    d92e:	fe b7       	in	r31, 0x3e	; 62
    d930:	31 96       	adiw	r30, 0x01	; 1
    d932:	ad b7       	in	r26, 0x3d	; 61
    d934:	be b7       	in	r27, 0x3e	; 62
    d936:	12 96       	adiw	r26, 0x02	; 2
    d938:	bc 92       	st	X, r11
    d93a:	ae 92       	st	-X, r10
    d93c:	11 97       	sbiw	r26, 0x01	; 1
    d93e:	d3 83       	std	Z+3, r29	; 0x03
    d940:	c2 83       	std	Z+2, r28	; 0x02
    d942:	d8 01       	movw	r26, r16
    d944:	12 96       	adiw	r26, 0x02	; 2
    d946:	8d 91       	ld	r24, X+
    d948:	9c 91       	ld	r25, X
    d94a:	13 97       	sbiw	r26, 0x03	; 3
    d94c:	95 83       	std	Z+5, r25	; 0x05
    d94e:	84 83       	std	Z+4, r24	; 0x04
    d950:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("Print_Handlesinfo=> Corresponde a %s \n",AxisName(axis));
    d954:	ed b7       	in	r30, 0x3d	; 61
    d956:	fe b7       	in	r31, 0x3e	; 62
    d958:	36 96       	adiw	r30, 0x06	; 6
    d95a:	0f b6       	in	r0, 0x3f	; 63
    d95c:	f8 94       	cli
    d95e:	fe bf       	out	0x3e, r31	; 62
    d960:	0f be       	out	0x3f, r0	; 63
    d962:	ed bf       	out	0x3d, r30	; 61
    d964:	ce 01       	movw	r24, r28
    d966:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    d96a:	00 d0       	rcall	.+0      	; 0xd96c <Print_Handlesinfo+0x9e>
    d96c:	00 d0       	rcall	.+0      	; 0xd96e <Print_Handlesinfo+0xa0>
    d96e:	ad b7       	in	r26, 0x3d	; 61
    d970:	be b7       	in	r27, 0x3e	; 62
    d972:	12 96       	adiw	r26, 0x02	; 2
    d974:	dc 92       	st	X, r13
    d976:	ce 92       	st	-X, r12
    d978:	11 97       	sbiw	r26, 0x01	; 1
    d97a:	14 96       	adiw	r26, 0x04	; 4
    d97c:	9c 93       	st	X, r25
    d97e:	8e 93       	st	-X, r24
    d980:	13 97       	sbiw	r26, 0x03	; 3
    d982:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		printf("Print_Handlesinfo=> Es manejado por el chipset %d  \n",hAxis[axis].chipset);
    d986:	ed b7       	in	r30, 0x3d	; 61
    d988:	fe b7       	in	r31, 0x3e	; 62
    d98a:	f2 82       	std	Z+2, r15	; 0x02
    d98c:	e1 82       	std	Z+1, r14	; 0x01
    d98e:	d8 01       	movw	r26, r16
    d990:	8d 91       	ld	r24, X+
    d992:	9c 91       	ld	r25, X
    d994:	94 83       	std	Z+4, r25	; 0x04
    d996:	83 83       	std	Z+3, r24	; 0x03
    d998:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>

void Print_Handlesinfo(void)
{
  int16 axis;
  
	for(axis=0; axis < DOF; axis++) 
    d99c:	21 96       	adiw	r28, 0x01	; 1
    d99e:	00 5a       	subi	r16, 0xA0	; 160
    d9a0:	1f 4f       	sbci	r17, 0xFF	; 255
    d9a2:	0f 90       	pop	r0
    d9a4:	0f 90       	pop	r0
    d9a6:	0f 90       	pop	r0
    d9a8:	0f 90       	pop	r0
    d9aa:	c5 30       	cpi	r28, 0x05	; 5
    d9ac:	d1 05       	cpc	r29, r1
    d9ae:	09 f0       	breq	.+2      	; 0xd9b2 <Print_Handlesinfo+0xe4>
    d9b0:	ae cf       	rjmp	.-164    	; 0xd90e <Print_Handlesinfo+0x40>
		printf("Print_Handlesinfo=> hAxis[%d].axis es igual a  %d  \n",axis,hAxis[axis].axis);
		printf("Print_Handlesinfo=> Corresponde a %s \n",AxisName(axis));
		printf("Print_Handlesinfo=> Es manejado por el chipset %d  \n",hAxis[axis].chipset);
	}
	
}
    d9b2:	df 91       	pop	r29
    d9b4:	cf 91       	pop	r28
    d9b6:	1f 91       	pop	r17
    d9b8:	0f 91       	pop	r16
    d9ba:	ff 90       	pop	r15
    d9bc:	ef 90       	pop	r14
    d9be:	df 90       	pop	r13
    d9c0:	cf 90       	pop	r12
    d9c2:	bf 90       	pop	r11
    d9c4:	af 90       	pop	r10
    d9c6:	9f 90       	pop	r9
    d9c8:	8f 90       	pop	r8
    d9ca:	08 95       	ret

0000d9cc <getErrorHost>:
/**********************************************************************************************************************/
PMDuint16 getErrorHost(int16 axis)
{
    d9cc:	df 93       	push	r29
    d9ce:	cf 93       	push	r28
    d9d0:	00 d0       	rcall	.+0      	; 0xd9d2 <getErrorHost+0x6>
    d9d2:	cd b7       	in	r28, 0x3d	; 61
    d9d4:	de b7       	in	r29, 0x3e	; 62
    PMDuint16 ErrorPMD=0;
    d9d6:	1a 82       	std	Y+2, r1	; 0x02
    d9d8:	19 82       	std	Y+1, r1	; 0x01
	 
	PMDGetHostIOError(&hAxis[axis],&ErrorPMD);
    d9da:	20 e6       	ldi	r18, 0x60	; 96
    d9dc:	30 e0       	ldi	r19, 0x00	; 0
    d9de:	ac 01       	movw	r20, r24
    d9e0:	42 9f       	mul	r20, r18
    d9e2:	c0 01       	movw	r24, r0
    d9e4:	43 9f       	mul	r20, r19
    d9e6:	90 0d       	add	r25, r0
    d9e8:	52 9f       	mul	r21, r18
    d9ea:	90 0d       	add	r25, r0
    d9ec:	11 24       	eor	r1, r1
    d9ee:	87 5e       	subi	r24, 0xE7	; 231
    d9f0:	9a 48       	sbci	r25, 0x8A	; 138
    d9f2:	be 01       	movw	r22, r28
    d9f4:	6f 5f       	subi	r22, 0xFF	; 255
    d9f6:	7f 4f       	sbci	r23, 0xFF	; 255
    d9f8:	0e 94 d7 76 	call	0xedae	; 0xedae <PMDGetHostIOError>
	
	return ErrorPMD;
}
    d9fc:	89 81       	ldd	r24, Y+1	; 0x01
    d9fe:	9a 81       	ldd	r25, Y+2	; 0x02
    da00:	0f 90       	pop	r0
    da02:	0f 90       	pop	r0
    da04:	cf 91       	pop	r28
    da06:	df 91       	pop	r29
    da08:	08 95       	ret

0000da0a <infomov>:
}
/**********************************************************************************************************************/
void infomov(int16 Axis, PMDint32* position, PMDint32* velocity, PMDuint32* acceleration, PMDuint32* deceleration,
			PMDint32* commandedposition,PMDint32* commandedvelocity, PMDint32* commandedacceleration,
			PMDint32* readencoder1, PMDint32* readerror,PMDuint16* encoderCounts, PMDuint16* steps)
{
    da0a:	2f 92       	push	r2
    da0c:	3f 92       	push	r3
    da0e:	4f 92       	push	r4
    da10:	5f 92       	push	r5
    da12:	6f 92       	push	r6
    da14:	7f 92       	push	r7
    da16:	8f 92       	push	r8
    da18:	9f 92       	push	r9
    da1a:	af 92       	push	r10
    da1c:	bf 92       	push	r11
    da1e:	cf 92       	push	r12
    da20:	df 92       	push	r13
    da22:	ef 92       	push	r14
    da24:	ff 92       	push	r15
    da26:	0f 93       	push	r16
    da28:	1f 93       	push	r17
    da2a:	df 93       	push	r29
    da2c:	cf 93       	push	r28
    da2e:	00 d0       	rcall	.+0      	; 0xda30 <infomov+0x26>
    da30:	00 d0       	rcall	.+0      	; 0xda32 <infomov+0x28>
    da32:	cd b7       	in	r28, 0x3d	; 61
    da34:	de b7       	in	r29, 0x3e	; 62
    da36:	3c 01       	movw	r6, r24
    da38:	2b 01       	movw	r4, r22
    da3a:	1a 01       	movw	r2, r20
    da3c:	3a 83       	std	Y+2, r19	; 0x02
    da3e:	29 83       	std	Y+1, r18	; 0x01
    da40:	1c 83       	std	Y+4, r17	; 0x04
    da42:	0b 83       	std	Y+3, r16	; 0x03
	
	PMDGetPosition(&hAxis[Axis],position);
    da44:	80 e6       	ldi	r24, 0x60	; 96
    da46:	90 e0       	ldi	r25, 0x00	; 0
    da48:	68 9e       	mul	r6, r24
    da4a:	80 01       	movw	r16, r0
    da4c:	69 9e       	mul	r6, r25
    da4e:	10 0d       	add	r17, r0
    da50:	78 9e       	mul	r7, r24
    da52:	10 0d       	add	r17, r0
    da54:	11 24       	eor	r1, r1
    da56:	07 5e       	subi	r16, 0xE7	; 231
    da58:	1a 48       	sbci	r17, 0x8A	; 138
    da5a:	c8 01       	movw	r24, r16
    da5c:	0e 94 84 7b 	call	0xf708	; 0xf708 <PMDGetPosition>
	PMDGetVelocity(&hAxis[Axis],velocity);
    da60:	c8 01       	movw	r24, r16
    da62:	b1 01       	movw	r22, r2
    da64:	0e 94 7e 7b 	call	0xf6fc	; 0xf6fc <PMDGetVelocity>
	PMDGetAcceleration(&hAxis[Axis],acceleration);
    da68:	c8 01       	movw	r24, r16
    da6a:	69 81       	ldd	r22, Y+1	; 0x01
    da6c:	7a 81       	ldd	r23, Y+2	; 0x02
    da6e:	0e 94 72 7b 	call	0xf6e4	; 0xf6e4 <PMDGetAcceleration>
	PMDGetDeceleration(&hAxis[Axis],deceleration);
    da72:	c8 01       	movw	r24, r16
    da74:	6b 81       	ldd	r22, Y+3	; 0x03
    da76:	7c 81       	ldd	r23, Y+4	; 0x04
    da78:	0e 94 6c 7b 	call	0xf6d8	; 0xf6d8 <PMDGetDeceleration>
	
	PMDGetCommandedPosition(&hAxis[Axis],commandedposition);
    da7c:	c8 01       	movw	r24, r16
    da7e:	b7 01       	movw	r22, r14
    da80:	0e 94 5a 7b 	call	0xf6b4	; 0xf6b4 <PMDGetCommandedPosition>
	PMDGetCommandedVelocity(&hAxis[Axis],commandedvelocity);
    da84:	c8 01       	movw	r24, r16
    da86:	b6 01       	movw	r22, r12
    da88:	0e 94 54 7b 	call	0xf6a8	; 0xf6a8 <PMDGetCommandedVelocity>
	PMDGetCommandedAcceleration(&hAxis[Axis],commandedacceleration);
    da8c:	c8 01       	movw	r24, r16
    da8e:	b5 01       	movw	r22, r10
    da90:	0e 94 4e 7b 	call	0xf69c	; 0xf69c <PMDGetCommandedAcceleration>
	
	
	//Funciones que hacen uso del Encoder
	PMDGetActualPosition(&hAxis[Axis],readencoder1);
    da94:	c8 01       	movw	r24, r16
    da96:	b4 01       	movw	r22, r8
    da98:	0e 94 30 7b 	call	0xf660	; 0xf660 <PMDGetActualPosition>
	PMDGetPositionError(&hAxis[Axis], readerror);	
    da9c:	c8 01       	movw	r24, r16
    da9e:	69 8d       	ldd	r22, Y+25	; 0x19
    daa0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    daa2:	0e 94 36 7b 	call	0xf66c	; 0xf66c <PMDGetPositionError>
	PMDGetEncoderToStepRatio(&hAxis[Axis], encoderCounts,steps);
    daa6:	c8 01       	movw	r24, r16
    daa8:	6b 8d       	ldd	r22, Y+27	; 0x1b
    daaa:	7c 8d       	ldd	r23, Y+28	; 0x1c
    daac:	4d 8d       	ldd	r20, Y+29	; 0x1d
    daae:	5e 8d       	ldd	r21, Y+30	; 0x1e
    dab0:	0e 94 ff 7b 	call	0xf7fe	; 0xf7fe <PMDGetEncoderToStepRatio>
	
	printf("infomov=> La informacion correspondiente del movimiento del eje %s es :\n",AxisName(Axis));
    dab4:	c3 01       	movw	r24, r6
    dab6:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    daba:	00 d0       	rcall	.+0      	; 0xdabc <infomov+0xb2>
    dabc:	00 d0       	rcall	.+0      	; 0xdabe <infomov+0xb4>
    dabe:	27 ea       	ldi	r18, 0xA7	; 167
    dac0:	3b e5       	ldi	r19, 0x5B	; 91
    dac2:	ed b7       	in	r30, 0x3d	; 61
    dac4:	fe b7       	in	r31, 0x3e	; 62
    dac6:	32 83       	std	Z+2, r19	; 0x02
    dac8:	21 83       	std	Z+1, r18	; 0x01
    daca:	94 83       	std	Z+4, r25	; 0x04
    dacc:	83 83       	std	Z+3, r24	; 0x03
    dace:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("infomov=> posicion=	%08ld\n",*position);
    dad2:	00 d0       	rcall	.+0      	; 0xdad4 <infomov+0xca>
    dad4:	80 ef       	ldi	r24, 0xF0	; 240
    dad6:	9b e5       	ldi	r25, 0x5B	; 91
    dad8:	ed b7       	in	r30, 0x3d	; 61
    dada:	fe b7       	in	r31, 0x3e	; 62
    dadc:	92 83       	std	Z+2, r25	; 0x02
    dade:	81 83       	std	Z+1, r24	; 0x01
    dae0:	f2 01       	movw	r30, r4
    dae2:	80 81       	ld	r24, Z
    dae4:	91 81       	ldd	r25, Z+1	; 0x01
    dae6:	a2 81       	ldd	r26, Z+2	; 0x02
    dae8:	b3 81       	ldd	r27, Z+3	; 0x03
    daea:	ed b7       	in	r30, 0x3d	; 61
    daec:	fe b7       	in	r31, 0x3e	; 62
    daee:	83 83       	std	Z+3, r24	; 0x03
    daf0:	94 83       	std	Z+4, r25	; 0x04
    daf2:	a5 83       	std	Z+5, r26	; 0x05
    daf4:	b6 83       	std	Z+6, r27	; 0x06
    daf6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("infomov=> velodidad	= 	%08ld\n",*velocity);
    dafa:	8b e0       	ldi	r24, 0x0B	; 11
    dafc:	9c e5       	ldi	r25, 0x5C	; 92
    dafe:	ed b7       	in	r30, 0x3d	; 61
    db00:	fe b7       	in	r31, 0x3e	; 62
    db02:	92 83       	std	Z+2, r25	; 0x02
    db04:	81 83       	std	Z+1, r24	; 0x01
    db06:	f1 01       	movw	r30, r2
    db08:	80 81       	ld	r24, Z
    db0a:	91 81       	ldd	r25, Z+1	; 0x01
    db0c:	a2 81       	ldd	r26, Z+2	; 0x02
    db0e:	b3 81       	ldd	r27, Z+3	; 0x03
    db10:	ed b7       	in	r30, 0x3d	; 61
    db12:	fe b7       	in	r31, 0x3e	; 62
    db14:	83 83       	std	Z+3, r24	; 0x03
    db16:	94 83       	std	Z+4, r25	; 0x04
    db18:	a5 83       	std	Z+5, r26	; 0x05
    db1a:	b6 83       	std	Z+6, r27	; 0x06
    db1c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("infomov=> aceleracion=	%08ld\n",*acceleration);
    db20:	89 e2       	ldi	r24, 0x29	; 41
    db22:	9c e5       	ldi	r25, 0x5C	; 92
    db24:	ed b7       	in	r30, 0x3d	; 61
    db26:	fe b7       	in	r31, 0x3e	; 62
    db28:	92 83       	std	Z+2, r25	; 0x02
    db2a:	81 83       	std	Z+1, r24	; 0x01
    db2c:	e9 81       	ldd	r30, Y+1	; 0x01
    db2e:	fa 81       	ldd	r31, Y+2	; 0x02
    db30:	80 81       	ld	r24, Z
    db32:	91 81       	ldd	r25, Z+1	; 0x01
    db34:	a2 81       	ldd	r26, Z+2	; 0x02
    db36:	b3 81       	ldd	r27, Z+3	; 0x03
    db38:	ed b7       	in	r30, 0x3d	; 61
    db3a:	fe b7       	in	r31, 0x3e	; 62
    db3c:	83 83       	std	Z+3, r24	; 0x03
    db3e:	94 83       	std	Z+4, r25	; 0x04
    db40:	a5 83       	std	Z+5, r26	; 0x05
    db42:	b6 83       	std	Z+6, r27	; 0x06
    db44:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("infomov=> desaceleracion=	%08ld\n",*deceleration);
    db48:	87 e4       	ldi	r24, 0x47	; 71
    db4a:	9c e5       	ldi	r25, 0x5C	; 92
    db4c:	ed b7       	in	r30, 0x3d	; 61
    db4e:	fe b7       	in	r31, 0x3e	; 62
    db50:	92 83       	std	Z+2, r25	; 0x02
    db52:	81 83       	std	Z+1, r24	; 0x01
    db54:	eb 81       	ldd	r30, Y+3	; 0x03
    db56:	fc 81       	ldd	r31, Y+4	; 0x04
    db58:	80 81       	ld	r24, Z
    db5a:	91 81       	ldd	r25, Z+1	; 0x01
    db5c:	a2 81       	ldd	r26, Z+2	; 0x02
    db5e:	b3 81       	ldd	r27, Z+3	; 0x03
    db60:	ed b7       	in	r30, 0x3d	; 61
    db62:	fe b7       	in	r31, 0x3e	; 62
    db64:	83 83       	std	Z+3, r24	; 0x03
    db66:	94 83       	std	Z+4, r25	; 0x04
    db68:	a5 83       	std	Z+5, r26	; 0x05
    db6a:	b6 83       	std	Z+6, r27	; 0x06
    db6c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("infomov=> posicion instantanea=	%08ld\n",*commandedposition);
    db70:	88 e6       	ldi	r24, 0x68	; 104
    db72:	9c e5       	ldi	r25, 0x5C	; 92
    db74:	ed b7       	in	r30, 0x3d	; 61
    db76:	fe b7       	in	r31, 0x3e	; 62
    db78:	92 83       	std	Z+2, r25	; 0x02
    db7a:	81 83       	std	Z+1, r24	; 0x01
    db7c:	f7 01       	movw	r30, r14
    db7e:	80 81       	ld	r24, Z
    db80:	91 81       	ldd	r25, Z+1	; 0x01
    db82:	a2 81       	ldd	r26, Z+2	; 0x02
    db84:	b3 81       	ldd	r27, Z+3	; 0x03
    db86:	ed b7       	in	r30, 0x3d	; 61
    db88:	fe b7       	in	r31, 0x3e	; 62
    db8a:	83 83       	std	Z+3, r24	; 0x03
    db8c:	94 83       	std	Z+4, r25	; 0x04
    db8e:	a5 83       	std	Z+5, r26	; 0x05
    db90:	b6 83       	std	Z+6, r27	; 0x06
    db92:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("infomov=> velocidad instantanea=	%08ld\n",*commandedvelocity);
    db96:	8f e8       	ldi	r24, 0x8F	; 143
    db98:	9c e5       	ldi	r25, 0x5C	; 92
    db9a:	ed b7       	in	r30, 0x3d	; 61
    db9c:	fe b7       	in	r31, 0x3e	; 62
    db9e:	92 83       	std	Z+2, r25	; 0x02
    dba0:	81 83       	std	Z+1, r24	; 0x01
    dba2:	f6 01       	movw	r30, r12
    dba4:	80 81       	ld	r24, Z
    dba6:	91 81       	ldd	r25, Z+1	; 0x01
    dba8:	a2 81       	ldd	r26, Z+2	; 0x02
    dbaa:	b3 81       	ldd	r27, Z+3	; 0x03
    dbac:	ed b7       	in	r30, 0x3d	; 61
    dbae:	fe b7       	in	r31, 0x3e	; 62
    dbb0:	83 83       	std	Z+3, r24	; 0x03
    dbb2:	94 83       	std	Z+4, r25	; 0x04
    dbb4:	a5 83       	std	Z+5, r26	; 0x05
    dbb6:	b6 83       	std	Z+6, r27	; 0x06
    dbb8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("infomov=> aceleracion instantanea=	%08ld\n",*commandedacceleration);
    dbbc:	87 eb       	ldi	r24, 0xB7	; 183
    dbbe:	9c e5       	ldi	r25, 0x5C	; 92
    dbc0:	ed b7       	in	r30, 0x3d	; 61
    dbc2:	fe b7       	in	r31, 0x3e	; 62
    dbc4:	92 83       	std	Z+2, r25	; 0x02
    dbc6:	81 83       	std	Z+1, r24	; 0x01
    dbc8:	f5 01       	movw	r30, r10
    dbca:	80 81       	ld	r24, Z
    dbcc:	91 81       	ldd	r25, Z+1	; 0x01
    dbce:	a2 81       	ldd	r26, Z+2	; 0x02
    dbd0:	b3 81       	ldd	r27, Z+3	; 0x03
    dbd2:	ed b7       	in	r30, 0x3d	; 61
    dbd4:	fe b7       	in	r31, 0x3e	; 62
    dbd6:	83 83       	std	Z+3, r24	; 0x03
    dbd8:	94 83       	std	Z+4, r25	; 0x04
    dbda:	a5 83       	std	Z+5, r26	; 0x05
    dbdc:	b6 83       	std	Z+6, r27	; 0x06
    dbde:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("infomov=> Lectura Encoder=	%08ld\n",*readencoder1);
    dbe2:	81 ee       	ldi	r24, 0xE1	; 225
    dbe4:	9c e5       	ldi	r25, 0x5C	; 92
    dbe6:	ed b7       	in	r30, 0x3d	; 61
    dbe8:	fe b7       	in	r31, 0x3e	; 62
    dbea:	92 83       	std	Z+2, r25	; 0x02
    dbec:	81 83       	std	Z+1, r24	; 0x01
    dbee:	f4 01       	movw	r30, r8
    dbf0:	80 81       	ld	r24, Z
    dbf2:	91 81       	ldd	r25, Z+1	; 0x01
    dbf4:	a2 81       	ldd	r26, Z+2	; 0x02
    dbf6:	b3 81       	ldd	r27, Z+3	; 0x03
    dbf8:	ed b7       	in	r30, 0x3d	; 61
    dbfa:	fe b7       	in	r31, 0x3e	; 62
    dbfc:	83 83       	std	Z+3, r24	; 0x03
    dbfe:	94 83       	std	Z+4, r25	; 0x04
    dc00:	a5 83       	std	Z+5, r26	; 0x05
    dc02:	b6 83       	std	Z+6, r27	; 0x06
    dc04:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("infomov=> Error Posicion=	%08ld\n",*readerror);	
    dc08:	83 e0       	ldi	r24, 0x03	; 3
    dc0a:	9d e5       	ldi	r25, 0x5D	; 93
    dc0c:	ed b7       	in	r30, 0x3d	; 61
    dc0e:	fe b7       	in	r31, 0x3e	; 62
    dc10:	92 83       	std	Z+2, r25	; 0x02
    dc12:	81 83       	std	Z+1, r24	; 0x01
    dc14:	e9 8d       	ldd	r30, Y+25	; 0x19
    dc16:	fa 8d       	ldd	r31, Y+26	; 0x1a
    dc18:	80 81       	ld	r24, Z
    dc1a:	91 81       	ldd	r25, Z+1	; 0x01
    dc1c:	a2 81       	ldd	r26, Z+2	; 0x02
    dc1e:	b3 81       	ldd	r27, Z+3	; 0x03
    dc20:	ed b7       	in	r30, 0x3d	; 61
    dc22:	fe b7       	in	r31, 0x3e	; 62
    dc24:	83 83       	std	Z+3, r24	; 0x03
    dc26:	94 83       	std	Z+4, r25	; 0x04
    dc28:	a5 83       	std	Z+5, r26	; 0x05
    dc2a:	b6 83       	std	Z+6, r27	; 0x06
    dc2c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    dc30:	8d b7       	in	r24, 0x3d	; 61
    dc32:	9e b7       	in	r25, 0x3e	; 62
    dc34:	06 96       	adiw	r24, 0x06	; 6
    dc36:	0f b6       	in	r0, 0x3f	; 63
    dc38:	f8 94       	cli
    dc3a:	9e bf       	out	0x3e, r25	; 62
    dc3c:	0f be       	out	0x3f, r0	; 63
    dc3e:	8d bf       	out	0x3d, r24	; 61
	//printf("infomov=> Cuentas de Encoder= %08d \n",*cuentas_encoder);
	//printf("infomov=> No. uPasos por vuelta= %08d \n",*steps);		

	
}
    dc40:	0f 90       	pop	r0
    dc42:	0f 90       	pop	r0
    dc44:	0f 90       	pop	r0
    dc46:	0f 90       	pop	r0
    dc48:	cf 91       	pop	r28
    dc4a:	df 91       	pop	r29
    dc4c:	1f 91       	pop	r17
    dc4e:	0f 91       	pop	r16
    dc50:	ff 90       	pop	r15
    dc52:	ef 90       	pop	r14
    dc54:	df 90       	pop	r13
    dc56:	cf 90       	pop	r12
    dc58:	bf 90       	pop	r11
    dc5a:	af 90       	pop	r10
    dc5c:	9f 90       	pop	r9
    dc5e:	8f 90       	pop	r8
    dc60:	7f 90       	pop	r7
    dc62:	6f 90       	pop	r6
    dc64:	5f 90       	pop	r5
    dc66:	4f 90       	pop	r4
    dc68:	3f 90       	pop	r3
    dc6a:	2f 90       	pop	r2
    dc6c:	08 95       	ret

0000dc6e <PMDCheckSignalStatus>:
//Si hay un 1 en la maskara SetSignalSense devuelve el invertido del valor electrico
//Si hay un 1 en la maskara el PMD interpreta que (0V SW oprimido) significa limite
//Si hay un 0 en la maskara SetSignalSense devuelve el el valor electrico
//Si hay un 0 en la maskara el PMD interpreta que (5V SW sin oprimir) significa limite
PMDresult PMDCheckSignalStatus(int16 Axis, PMDint16 print)
{
    dc6e:	af 92       	push	r10
    dc70:	bf 92       	push	r11
    dc72:	cf 92       	push	r12
    dc74:	df 92       	push	r13
    dc76:	ef 92       	push	r14
    dc78:	ff 92       	push	r15
    dc7a:	0f 93       	push	r16
    dc7c:	1f 93       	push	r17
    dc7e:	df 93       	push	r29
    dc80:	cf 93       	push	r28
    dc82:	cd b7       	in	r28, 0x3d	; 61
    dc84:	de b7       	in	r29, 0x3e	; 62
    dc86:	68 97       	sbiw	r28, 0x18	; 24
    dc88:	0f b6       	in	r0, 0x3f	; 63
    dc8a:	f8 94       	cli
    dc8c:	de bf       	out	0x3e, r29	; 62
    dc8e:	0f be       	out	0x3f, r0	; 63
    dc90:	cd bf       	out	0x3d, r28	; 61
    dc92:	5c 01       	movw	r10, r24
    dc94:	7b 01       	movw	r14, r22

	PMDuint16 status,mask,status_char;
	char binario[20]="0";
    dc96:	80 e3       	ldi	r24, 0x30	; 48
    dc98:	90 e0       	ldi	r25, 0x00	; 0
    dc9a:	a0 e0       	ldi	r26, 0x00	; 0
    dc9c:	b0 e0       	ldi	r27, 0x00	; 0
    dc9e:	8d 83       	std	Y+5, r24	; 0x05
    dca0:	9e 83       	std	Y+6, r25	; 0x06
    dca2:	af 83       	std	Y+7, r26	; 0x07
    dca4:	b8 87       	std	Y+8, r27	; 0x08
    dca6:	fe 01       	movw	r30, r28
    dca8:	39 96       	adiw	r30, 0x09	; 9
    dcaa:	80 e1       	ldi	r24, 0x10	; 16
    dcac:	df 01       	movw	r26, r30
    dcae:	1d 92       	st	X+, r1
    dcb0:	8a 95       	dec	r24
    dcb2:	e9 f7       	brne	.-6      	; 0xdcae <PMDCheckSignalStatus+0x40>
	
	
	PMDGetSignalStatus(&hAxis[Axis],&status);
    dcb4:	80 e6       	ldi	r24, 0x60	; 96
    dcb6:	90 e0       	ldi	r25, 0x00	; 0
    dcb8:	a8 9e       	mul	r10, r24
    dcba:	60 01       	movw	r12, r0
    dcbc:	a9 9e       	mul	r10, r25
    dcbe:	d0 0c       	add	r13, r0
    dcc0:	b8 9e       	mul	r11, r24
    dcc2:	d0 0c       	add	r13, r0
    dcc4:	11 24       	eor	r1, r1
    dcc6:	e9 e1       	ldi	r30, 0x19	; 25
    dcc8:	f5 e7       	ldi	r31, 0x75	; 117
    dcca:	ce 0e       	add	r12, r30
    dccc:	df 1e       	adc	r13, r31
    dcce:	c6 01       	movw	r24, r12
    dcd0:	be 01       	movw	r22, r28
    dcd2:	6f 5f       	subi	r22, 0xFF	; 255
    dcd4:	7f 4f       	sbci	r23, 0xFF	; 255
    dcd6:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
	//printf("El Signal status register del eje %s es %X \n",AxisName(Axis),status);
	
	status_char=status;
    dcda:	89 81       	ldd	r24, Y+1	; 0x01
    dcdc:	9a 81       	ldd	r25, Y+2	; 0x02
	status_char= status_char >> 3;
	
	itoa(status_char,binario,2);	
    dcde:	8e 01       	movw	r16, r28
    dce0:	0b 5f       	subi	r16, 0xFB	; 251
    dce2:	1f 4f       	sbci	r17, 0xFF	; 255
    dce4:	f3 e0       	ldi	r31, 0x03	; 3
    dce6:	96 95       	lsr	r25
    dce8:	87 95       	ror	r24
    dcea:	fa 95       	dec	r31
    dcec:	e1 f7       	brne	.-8      	; 0xdce6 <PMDCheckSignalStatus+0x78>
    dcee:	b8 01       	movw	r22, r16
    dcf0:	42 e0       	ldi	r20, 0x02	; 2
    dcf2:	50 e0       	ldi	r21, 0x00	; 0
    dcf4:	0e 94 e0 9e 	call	0x13dc0	; 0x13dc0 <itoa>
	
	printf("PMDCheckSignalStatus=> signal status = %s  \n",binario);
    dcf8:	00 d0       	rcall	.+0      	; 0xdcfa <PMDCheckSignalStatus+0x8c>
    dcfa:	00 d0       	rcall	.+0      	; 0xdcfc <PMDCheckSignalStatus+0x8e>
    dcfc:	84 e2       	ldi	r24, 0x24	; 36
    dcfe:	9d e5       	ldi	r25, 0x5D	; 93
    dd00:	ad b7       	in	r26, 0x3d	; 61
    dd02:	be b7       	in	r27, 0x3e	; 62
    dd04:	12 96       	adiw	r26, 0x02	; 2
    dd06:	9c 93       	st	X, r25
    dd08:	8e 93       	st	-X, r24
    dd0a:	11 97       	sbiw	r26, 0x01	; 1
    dd0c:	14 96       	adiw	r26, 0x04	; 4
    dd0e:	1c 93       	st	X, r17
    dd10:	0e 93       	st	-X, r16
    dd12:	13 97       	sbiw	r26, 0x03	; 3
    dd14:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	
	
	if(print==imprimir)
    dd18:	0f 90       	pop	r0
    dd1a:	0f 90       	pop	r0
    dd1c:	0f 90       	pop	r0
    dd1e:	0f 90       	pop	r0
    dd20:	be ee       	ldi	r27, 0xEE	; 238
    dd22:	eb 16       	cp	r14, r27
    dd24:	bf ef       	ldi	r27, 0xFF	; 255
    dd26:	fb 06       	cpc	r15, r27
    dd28:	09 f0       	breq	.+2      	; 0xdd2c <PMDCheckSignalStatus+0xbe>
    dd2a:	bb c0       	rjmp	.+374    	; 0xdea2 <PMDCheckSignalStatus+0x234>
	{
		PMDGetSignalSense(&hAxis[Axis],& mask);
    dd2c:	c6 01       	movw	r24, r12
    dd2e:	be 01       	movw	r22, r28
    dd30:	6d 5f       	subi	r22, 0xFD	; 253
    dd32:	7f 4f       	sbci	r23, 0xFF	; 255
    dd34:	0e 94 69 78 	call	0xf0d2	; 0xf0d2 <PMDGetSignalSense>
		printf("PMDCheckSignalStatus=> La mascara de Signal sense del eje %s es %X \n",AxisName(Axis),mask);
    dd38:	c5 01       	movw	r24, r10
    dd3a:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    dd3e:	00 d0       	rcall	.+0      	; 0xdd40 <PMDCheckSignalStatus+0xd2>
    dd40:	00 d0       	rcall	.+0      	; 0xdd42 <PMDCheckSignalStatus+0xd4>
    dd42:	00 d0       	rcall	.+0      	; 0xdd44 <PMDCheckSignalStatus+0xd6>
    dd44:	ed b7       	in	r30, 0x3d	; 61
    dd46:	fe b7       	in	r31, 0x3e	; 62
    dd48:	31 96       	adiw	r30, 0x01	; 1
    dd4a:	21 e5       	ldi	r18, 0x51	; 81
    dd4c:	3d e5       	ldi	r19, 0x5D	; 93
    dd4e:	ad b7       	in	r26, 0x3d	; 61
    dd50:	be b7       	in	r27, 0x3e	; 62
    dd52:	12 96       	adiw	r26, 0x02	; 2
    dd54:	3c 93       	st	X, r19
    dd56:	2e 93       	st	-X, r18
    dd58:	11 97       	sbiw	r26, 0x01	; 1
    dd5a:	93 83       	std	Z+3, r25	; 0x03
    dd5c:	82 83       	std	Z+2, r24	; 0x02
    dd5e:	8b 81       	ldd	r24, Y+3	; 0x03
    dd60:	9c 81       	ldd	r25, Y+4	; 0x04
    dd62:	95 83       	std	Z+5, r25	; 0x05
    dd64:	84 83       	std	Z+4, r24	; 0x04
    dd66:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	
		if ((status & PMDSignalEncoderAMask) !=0)
    dd6a:	89 81       	ldd	r24, Y+1	; 0x01
    dd6c:	ed b7       	in	r30, 0x3d	; 61
    dd6e:	fe b7       	in	r31, 0x3e	; 62
    dd70:	36 96       	adiw	r30, 0x06	; 6
    dd72:	0f b6       	in	r0, 0x3f	; 63
    dd74:	f8 94       	cli
    dd76:	fe bf       	out	0x3e, r31	; 62
    dd78:	0f be       	out	0x3f, r0	; 63
    dd7a:	ed bf       	out	0x3d, r30	; 61
    dd7c:	9b 81       	ldd	r25, Y+3	; 0x03
    dd7e:	80 ff       	sbrs	r24, 0
    dd80:	08 c0       	rjmp	.+16     	; 0xdd92 <PMDCheckSignalStatus+0x124>
		{
			if((mask & PMDSignalEncoderAMask)!=0)  //el bit vale 1 en el signal sense
    dd82:	90 ff       	sbrs	r25, 0
    dd84:	03 c0       	rjmp	.+6      	; 0xdd8c <PMDCheckSignalStatus+0x11e>
			
			printf("PMDCheckSignalStatus=> El canal A = Real (0V) Valor  registro (5V) \n");		
    dd86:	86 e9       	ldi	r24, 0x96	; 150
    dd88:	9d e5       	ldi	r25, 0x5D	; 93
    dd8a:	0a c0       	rjmp	.+20     	; 0xdda0 <PMDCheckSignalStatus+0x132>
		    else
			printf("PMDCheckSignalStatus=> El canal A = (5V) Valor Electrico Real =registro \n");
    dd8c:	8a ed       	ldi	r24, 0xDA	; 218
    dd8e:	9d e5       	ldi	r25, 0x5D	; 93
    dd90:	07 c0       	rjmp	.+14     	; 0xdda0 <PMDCheckSignalStatus+0x132>
		}
		else
		{
			if((mask & PMDSignalEncoderAMask)!=0)  //el bit vale 1 en el signal sense
    dd92:	90 ff       	sbrs	r25, 0
    dd94:	03 c0       	rjmp	.+6      	; 0xdd9c <PMDCheckSignalStatus+0x12e>
			printf("PMDCheckSignalStatus=> El canal A = Real (5V) Valor  Registro (0V) \n");
    dd96:	83 e2       	ldi	r24, 0x23	; 35
    dd98:	9e e5       	ldi	r25, 0x5E	; 94
    dd9a:	02 c0       	rjmp	.+4      	; 0xdda0 <PMDCheckSignalStatus+0x132>
				
		    else
			printf("PMDCheckSignalStatus=> El canal A = (0V) Valor Electrico Real = Registro \n");	
    dd9c:	87 e6       	ldi	r24, 0x67	; 103
    dd9e:	9e e5       	ldi	r25, 0x5E	; 94
    dda0:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
		}
		
		//--------------------------------------------------------------------------------//
		if ((status & PMDSignalEncoderBMask) !=0)
    dda4:	89 81       	ldd	r24, Y+1	; 0x01
    dda6:	9b 81       	ldd	r25, Y+3	; 0x03
    dda8:	81 ff       	sbrs	r24, 1
    ddaa:	08 c0       	rjmp	.+16     	; 0xddbc <PMDCheckSignalStatus+0x14e>
		{
			if((mask & PMDSignalEncoderBMask)!=0)  //el bit vale 1 en el signal sense
    ddac:	91 ff       	sbrs	r25, 1
    ddae:	03 c0       	rjmp	.+6      	; 0xddb6 <PMDCheckSignalStatus+0x148>
			
			printf("PMDCheckSignalStatus=> El canal B = Real (0V) Valor registro (5V) \n");		
    ddb0:	81 eb       	ldi	r24, 0xB1	; 177
    ddb2:	9e e5       	ldi	r25, 0x5E	; 94
    ddb4:	0a c0       	rjmp	.+20     	; 0xddca <PMDCheckSignalStatus+0x15c>
		    else
			printf("PMDCheckSignalStatus=> El canal B = (5V) Valor Electrico Real =registro \n");
    ddb6:	84 ef       	ldi	r24, 0xF4	; 244
    ddb8:	9e e5       	ldi	r25, 0x5E	; 94
    ddba:	07 c0       	rjmp	.+14     	; 0xddca <PMDCheckSignalStatus+0x15c>
		}
		else
		{
			if((mask & PMDSignalEncoderBMask)!=0)  //el bit vale 1 en el signal sense
    ddbc:	91 ff       	sbrs	r25, 1
    ddbe:	03 c0       	rjmp	.+6      	; 0xddc6 <PMDCheckSignalStatus+0x158>
			printf("PMDCheckSignalStatus=> El canal B = Real (5V) Valor Registro (0V) \n");
    ddc0:	8d e3       	ldi	r24, 0x3D	; 61
    ddc2:	9f e5       	ldi	r25, 0x5F	; 95
    ddc4:	02 c0       	rjmp	.+4      	; 0xddca <PMDCheckSignalStatus+0x15c>
				
		    else
			printf("PMDCheckSignalStatus=> El canal B = (0V) Valor Electrico Real= Registro \n");	
    ddc6:	80 e8       	ldi	r24, 0x80	; 128
    ddc8:	9f e5       	ldi	r25, 0x5F	; 95
    ddca:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
		}
		//--------------------------------------------------------------------------------//
		
		if ((status & PMDSignalEncoderIndexMask) !=0)
    ddce:	89 81       	ldd	r24, Y+1	; 0x01
    ddd0:	9b 81       	ldd	r25, Y+3	; 0x03
    ddd2:	82 ff       	sbrs	r24, 2
    ddd4:	08 c0       	rjmp	.+16     	; 0xdde6 <PMDCheckSignalStatus+0x178>
		{
			if((mask & PMDSignalEncoderIndexMask)!=0)  //el bit vale 1 en el signal sense
    ddd6:	92 ff       	sbrs	r25, 2
    ddd8:	03 c0       	rjmp	.+6      	; 0xdde0 <PMDCheckSignalStatus+0x172>
			
			printf("PMDCheckSignalStatus=> Index = Real (0V) Valor registro (5V) \n");		
    ddda:	89 ec       	ldi	r24, 0xC9	; 201
    dddc:	9f e5       	ldi	r25, 0x5F	; 95
    ddde:	0a c0       	rjmp	.+20     	; 0xddf4 <PMDCheckSignalStatus+0x186>
		    else
			printf("PMDCheckSignalStatus=> Index = (5V) Valor Electrico Real = registro \n");
    dde0:	87 e0       	ldi	r24, 0x07	; 7
    dde2:	90 e6       	ldi	r25, 0x60	; 96
    dde4:	07 c0       	rjmp	.+14     	; 0xddf4 <PMDCheckSignalStatus+0x186>
		}
		else
		{
			if((mask & PMDSignalEncoderIndexMask)!=0)  //el bit vale 1 en el signal sense
    dde6:	92 ff       	sbrs	r25, 2
    dde8:	03 c0       	rjmp	.+6      	; 0xddf0 <PMDCheckSignalStatus+0x182>
			printf("PMDCheckSignalStatus=> Index = Real (5V) Valor Registro (0V) \n");
    ddea:	8c e4       	ldi	r24, 0x4C	; 76
    ddec:	90 e6       	ldi	r25, 0x60	; 96
    ddee:	02 c0       	rjmp	.+4      	; 0xddf4 <PMDCheckSignalStatus+0x186>
				
		    else
			printf("PMDCheckSignalStatus=> Index = (0V) Valor Electrico Real= Registro \n");	
    ddf0:	8a e8       	ldi	r24, 0x8A	; 138
    ddf2:	90 e6       	ldi	r25, 0x60	; 96
    ddf4:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
		}
		
		
		//--------------------------------------------------------------------------------//
		
		if ((status & PMDSignalEncoderHomeMask) !=0)
    ddf8:	89 81       	ldd	r24, Y+1	; 0x01
    ddfa:	9b 81       	ldd	r25, Y+3	; 0x03
    ddfc:	83 ff       	sbrs	r24, 3
    ddfe:	08 c0       	rjmp	.+16     	; 0xde10 <PMDCheckSignalStatus+0x1a2>
		{
			if((mask & PMDSignalEncoderHomeMask)!=0)  //el bit vale 1 en el signal sense
    de00:	93 ff       	sbrs	r25, 3
    de02:	03 c0       	rjmp	.+6      	; 0xde0a <PMDCheckSignalStatus+0x19c>
			
			printf("PMDCheckSignalStatus=> Home = Real (0V) Valor registro (5V) Captura Low to High \n");		
    de04:	8e ec       	ldi	r24, 0xCE	; 206
    de06:	90 e6       	ldi	r25, 0x60	; 96
    de08:	0a c0       	rjmp	.+20     	; 0xde1e <PMDCheckSignalStatus+0x1b0>
		    else
			printf("PMDCheckSignalStatus=> Home = (5V) Valor Electrico Real = registro Captura de High To Low \n");
    de0a:	8f e1       	ldi	r24, 0x1F	; 31
    de0c:	91 e6       	ldi	r25, 0x61	; 97
    de0e:	07 c0       	rjmp	.+14     	; 0xde1e <PMDCheckSignalStatus+0x1b0>
		}
		else
		{
			if((mask & PMDSignalEncoderHomeMask)!=0)  //el bit vale 1 en el signal sense
    de10:	93 ff       	sbrs	r25, 3
    de12:	03 c0       	rjmp	.+6      	; 0xde1a <PMDCheckSignalStatus+0x1ac>
			printf("PMDCheckSignalStatus=> Home = Real (5V) Valor Registro (0V) Captura Low to High \n");
    de14:	8a e7       	ldi	r24, 0x7A	; 122
    de16:	91 e6       	ldi	r25, 0x61	; 97
    de18:	02 c0       	rjmp	.+4      	; 0xde1e <PMDCheckSignalStatus+0x1b0>
				
		    else
			printf("PMDCheckSignalStatus=> Home = (0V) Valor Electrico Real = Registro  Captura de High To Low \n");	
    de1a:	8b ec       	ldi	r24, 0xCB	; 203
    de1c:	91 e6       	ldi	r25, 0x61	; 97
    de1e:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
		}
		
		//--------------------------------------------------------------------------------//
		if ((status & PMDSignalPositiveLimitMask) !=0)
    de22:	89 81       	ldd	r24, Y+1	; 0x01
    de24:	9b 81       	ldd	r25, Y+3	; 0x03
    de26:	84 ff       	sbrs	r24, 4
    de28:	08 c0       	rjmp	.+16     	; 0xde3a <PMDCheckSignalStatus+0x1cc>
		{
			if((mask & PMDSignalPositiveLimitMask)!=0)  //el bit vale 1 en el signal sense
    de2a:	94 ff       	sbrs	r25, 4
    de2c:	03 c0       	rjmp	.+6      	; 0xde34 <PMDCheckSignalStatus+0x1c6>
			
			printf("PMDCheckSignalStatus=> Limite Positivo = Real (0V) Valor registro (5V)  No hay Evento de Limite \n");		
    de2e:	87 e2       	ldi	r24, 0x27	; 39
    de30:	92 e6       	ldi	r25, 0x62	; 98
    de32:	0a c0       	rjmp	.+20     	; 0xde48 <PMDCheckSignalStatus+0x1da>
		    else
			printf("PMDCheckSignalStatus=> Limite Positivo = (5V) Valor Electrico Real = registro No hay Evento de Limite \n");
    de34:	88 e8       	ldi	r24, 0x88	; 136
    de36:	92 e6       	ldi	r25, 0x62	; 98
    de38:	07 c0       	rjmp	.+14     	; 0xde48 <PMDCheckSignalStatus+0x1da>
		}
		else
		{
			if((mask & PMDSignalPositiveLimitMask)!=0)  //el bit vale 1 en el signal sense
    de3a:	94 ff       	sbrs	r25, 4
    de3c:	03 c0       	rjmp	.+6      	; 0xde44 <PMDCheckSignalStatus+0x1d6>
			
			printf("PMDCheckSignalStatus=> Limite Positivo = Real (5V) Valor Registro (0V) Hay Evento de Limite\n");
    de3e:	8f ee       	ldi	r24, 0xEF	; 239
    de40:	92 e6       	ldi	r25, 0x62	; 98
    de42:	02 c0       	rjmp	.+4      	; 0xde48 <PMDCheckSignalStatus+0x1da>
			else
			printf("PMDCheckSignalStatus=> Limite Positivo = (0V) Valor Electrico Real = Registro hay Evento de Limite \n");	
    de44:	8b e4       	ldi	r24, 0x4B	; 75
    de46:	93 e6       	ldi	r25, 0x63	; 99
    de48:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
		}
		//--------------------------------------------------------------------------------//
		if ((status & PMDSignalNegativeLimitMask) !=0)
    de4c:	89 81       	ldd	r24, Y+1	; 0x01
    de4e:	9b 81       	ldd	r25, Y+3	; 0x03
    de50:	85 ff       	sbrs	r24, 5
    de52:	08 c0       	rjmp	.+16     	; 0xde64 <PMDCheckSignalStatus+0x1f6>
		{
			if((mask & PMDSignalNegativeLimitMask)!=0)  //el bit vale 1 en el signal sense
    de54:	95 ff       	sbrs	r25, 5
    de56:	03 c0       	rjmp	.+6      	; 0xde5e <PMDCheckSignalStatus+0x1f0>
			
			printf("PMDCheckSignalStatus=> Limite Negativo = Real (0V) Valor registro (5V) No hay Evento de Limite \n");		
    de58:	8f ea       	ldi	r24, 0xAF	; 175
    de5a:	93 e6       	ldi	r25, 0x63	; 99
    de5c:	0a c0       	rjmp	.+20     	; 0xde72 <PMDCheckSignalStatus+0x204>
		    else
			printf("PMDCheckSignalStatus=> Limite Negativo = (5V) Valor Electrico Real= registro No hay Evento de Limite \n");
    de5e:	8f e0       	ldi	r24, 0x0F	; 15
    de60:	94 e6       	ldi	r25, 0x64	; 100
    de62:	07 c0       	rjmp	.+14     	; 0xde72 <PMDCheckSignalStatus+0x204>
		}
		else
		{
			if((mask & PMDSignalNegativeLimitMask)!=0)  //el bit vale 1 en el signal sense
    de64:	95 ff       	sbrs	r25, 5
    de66:	03 c0       	rjmp	.+6      	; 0xde6e <PMDCheckSignalStatus+0x200>
			printf("PMDCheckSignalStatus=> Limite Negativo = Real (5V) Valor Registro (0V) Hay Evento de Limite\n");
    de68:	85 e7       	ldi	r24, 0x75	; 117
    de6a:	94 e6       	ldi	r25, 0x64	; 100
    de6c:	02 c0       	rjmp	.+4      	; 0xde72 <PMDCheckSignalStatus+0x204>
			else
			printf("PMDCheckSignalStatus=> Limite Negativo = (0V) Valor Electrico Real = Registro hay Evento de Limite \n");	
    de6e:	81 ed       	ldi	r24, 0xD1	; 209
    de70:	94 e6       	ldi	r25, 0x64	; 100
    de72:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
		}
		
		//--------------------------------------------------------------------------------//
		
		if ((status & PMDSignalStepOutputInvertMask) !=0) 
    de76:	89 81       	ldd	r24, Y+1	; 0x01
    de78:	9a 81       	ldd	r25, Y+2	; 0x02
    de7a:	93 ff       	sbrs	r25, 3
    de7c:	03 c0       	rjmp	.+6      	; 0xde84 <PMDCheckSignalStatus+0x216>
			printf("PMDCheckSignalStatus=> Step Output invert = + positivo\n");
    de7e:	85 e3       	ldi	r24, 0x35	; 53
    de80:	95 e6       	ldi	r25, 0x65	; 101
    de82:	02 c0       	rjmp	.+4      	; 0xde88 <PMDCheckSignalStatus+0x21a>
		else
			printf("PMDCheckSignalStatus=> Step Output invert = - negativo\n");
    de84:	8c e6       	ldi	r24, 0x6C	; 108
    de86:	95 e6       	ldi	r25, 0x65	; 101
    de88:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
		//--------------------------------------------------------------------------------//
		
		if ((status & PMDSignalMotorOutputInvertMask) !=0) 
    de8c:	89 81       	ldd	r24, Y+1	; 0x01
    de8e:	9a 81       	ldd	r25, Y+2	; 0x02
    de90:	94 ff       	sbrs	r25, 4
    de92:	03 c0       	rjmp	.+6      	; 0xde9a <PMDCheckSignalStatus+0x22c>
			printf("PMDCheckSignalStatus=> Motor Output invert = + positivo\n");
    de94:	83 ea       	ldi	r24, 0xA3	; 163
    de96:	95 e6       	ldi	r25, 0x65	; 101
    de98:	02 c0       	rjmp	.+4      	; 0xde9e <PMDCheckSignalStatus+0x230>
		else
			printf("PMDCheckSignalStatus=> Motor Output invert = - negativo\n");
    de9a:	8b ed       	ldi	r24, 0xDB	; 219
    de9c:	95 e6       	ldi	r25, 0x65	; 101
    de9e:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
		//--------------------------------------------------------------------------------//
	}
	
	return status;

}
    dea2:	89 81       	ldd	r24, Y+1	; 0x01
    dea4:	9a 81       	ldd	r25, Y+2	; 0x02
    dea6:	68 96       	adiw	r28, 0x18	; 24
    dea8:	0f b6       	in	r0, 0x3f	; 63
    deaa:	f8 94       	cli
    deac:	de bf       	out	0x3e, r29	; 62
    deae:	0f be       	out	0x3f, r0	; 63
    deb0:	cd bf       	out	0x3d, r28	; 61
    deb2:	cf 91       	pop	r28
    deb4:	df 91       	pop	r29
    deb6:	1f 91       	pop	r17
    deb8:	0f 91       	pop	r16
    deba:	ff 90       	pop	r15
    debc:	ef 90       	pop	r14
    debe:	df 90       	pop	r13
    dec0:	cf 90       	pop	r12
    dec2:	bf 90       	pop	r11
    dec4:	af 90       	pop	r10
    dec6:	08 95       	ret

0000dec8 <PMDCheckActivityStatus>:
}


/*****************************************************************************************/
PMDresult PMDCheckActivityStatus(int16 Axis, PMDint16 print)
{ 
    dec8:	ef 92       	push	r14
    deca:	ff 92       	push	r15
    decc:	0f 93       	push	r16
    dece:	1f 93       	push	r17
    ded0:	df 93       	push	r29
    ded2:	cf 93       	push	r28
    ded4:	00 d0       	rcall	.+0      	; 0xded6 <PMDCheckActivityStatus+0xe>
    ded6:	cd b7       	in	r28, 0x3d	; 61
    ded8:	de b7       	in	r29, 0x3e	; 62
    deda:	7c 01       	movw	r14, r24
    dedc:	8b 01       	movw	r16, r22
	PMDuint16 status,profile;	
	
	PMDGetActivityStatus(&hAxis[Axis],&status);
    dede:	80 e6       	ldi	r24, 0x60	; 96
    dee0:	90 e0       	ldi	r25, 0x00	; 0
    dee2:	9c 01       	movw	r18, r24
    dee4:	e2 9e       	mul	r14, r18
    dee6:	c0 01       	movw	r24, r0
    dee8:	e3 9e       	mul	r14, r19
    deea:	90 0d       	add	r25, r0
    deec:	f2 9e       	mul	r15, r18
    deee:	90 0d       	add	r25, r0
    def0:	11 24       	eor	r1, r1
    def2:	87 5e       	subi	r24, 0xE7	; 231
    def4:	9a 48       	sbci	r25, 0x8A	; 138
    def6:	be 01       	movw	r22, r28
    def8:	6f 5f       	subi	r22, 0xFF	; 255
    defa:	7f 4f       	sbci	r23, 0xFF	; 255
    defc:	0e 94 6f 78 	call	0xf0de	; 0xf0de <PMDGetActivityStatus>
	printf("PMDCheckActivityStatus=> El Activity status del eje %s es %X \n",AxisName(Axis),status);
    df00:	c7 01       	movw	r24, r14
    df02:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    df06:	00 d0       	rcall	.+0      	; 0xdf08 <PMDCheckActivityStatus+0x40>
    df08:	00 d0       	rcall	.+0      	; 0xdf0a <PMDCheckActivityStatus+0x42>
    df0a:	00 d0       	rcall	.+0      	; 0xdf0c <PMDCheckActivityStatus+0x44>
    df0c:	ed b7       	in	r30, 0x3d	; 61
    df0e:	fe b7       	in	r31, 0x3e	; 62
    df10:	31 96       	adiw	r30, 0x01	; 1
    df12:	23 e1       	ldi	r18, 0x13	; 19
    df14:	36 e6       	ldi	r19, 0x66	; 102
    df16:	ad b7       	in	r26, 0x3d	; 61
    df18:	be b7       	in	r27, 0x3e	; 62
    df1a:	12 96       	adiw	r26, 0x02	; 2
    df1c:	3c 93       	st	X, r19
    df1e:	2e 93       	st	-X, r18
    df20:	11 97       	sbiw	r26, 0x01	; 1
    df22:	93 83       	std	Z+3, r25	; 0x03
    df24:	82 83       	std	Z+2, r24	; 0x02
    df26:	89 81       	ldd	r24, Y+1	; 0x01
    df28:	9a 81       	ldd	r25, Y+2	; 0x02
    df2a:	95 83       	std	Z+5, r25	; 0x05
    df2c:	84 83       	std	Z+4, r24	; 0x04
    df2e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	
	if(print==imprimir)
    df32:	ed b7       	in	r30, 0x3d	; 61
    df34:	fe b7       	in	r31, 0x3e	; 62
    df36:	36 96       	adiw	r30, 0x06	; 6
    df38:	0f b6       	in	r0, 0x3f	; 63
    df3a:	f8 94       	cli
    df3c:	fe bf       	out	0x3e, r31	; 62
    df3e:	0f be       	out	0x3f, r0	; 63
    df40:	ed bf       	out	0x3d, r30	; 61
    df42:	0e 5e       	subi	r16, 0xEE	; 238
    df44:	1f 4f       	sbci	r17, 0xFF	; 255
    df46:	09 f0       	breq	.+2      	; 0xdf4a <PMDCheckActivityStatus+0x82>
    df48:	0f c1       	rjmp	.+542    	; 0xe168 <PMDCheckActivityStatus+0x2a0>
	{
		if ((status & PMDActivityAtMaximumVelocityMask) !=0 ) 
    df4a:	89 81       	ldd	r24, Y+1	; 0x01
    df4c:	81 ff       	sbrs	r24, 1
    df4e:	17 c0       	rjmp	.+46     	; 0xdf7e <PMDCheckActivityStatus+0xb6>
			printf("PMDCheckActivityStatus=> El eje %s esta A la maxima Velocidad  \n",AxisName(Axis));
    df50:	c7 01       	movw	r24, r14
    df52:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    df56:	00 d0       	rcall	.+0      	; 0xdf58 <PMDCheckActivityStatus+0x90>
    df58:	00 d0       	rcall	.+0      	; 0xdf5a <PMDCheckActivityStatus+0x92>
    df5a:	22 e5       	ldi	r18, 0x52	; 82
    df5c:	36 e6       	ldi	r19, 0x66	; 102
    df5e:	ad b7       	in	r26, 0x3d	; 61
    df60:	be b7       	in	r27, 0x3e	; 62
    df62:	12 96       	adiw	r26, 0x02	; 2
    df64:	3c 93       	st	X, r19
    df66:	2e 93       	st	-X, r18
    df68:	11 97       	sbiw	r26, 0x01	; 1
    df6a:	14 96       	adiw	r26, 0x04	; 4
    df6c:	9c 93       	st	X, r25
    df6e:	8e 93       	st	-X, r24
    df70:	13 97       	sbiw	r26, 0x03	; 3
    df72:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    df76:	0f 90       	pop	r0
    df78:	0f 90       	pop	r0
    df7a:	0f 90       	pop	r0
    df7c:	0f 90       	pop	r0
		
		if ((status & PMDActivityTrackingMask) !=0) 
    df7e:	89 81       	ldd	r24, Y+1	; 0x01
    df80:	82 ff       	sbrs	r24, 2
    df82:	13 c0       	rjmp	.+38     	; 0xdfaa <PMDCheckActivityStatus+0xe2>
			printf("PMDCheckActivityStatus=> El eje %s esta dentro del tracking window  \n",AxisName(Axis));
    df84:	c7 01       	movw	r24, r14
    df86:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    df8a:	00 d0       	rcall	.+0      	; 0xdf8c <PMDCheckActivityStatus+0xc4>
    df8c:	00 d0       	rcall	.+0      	; 0xdf8e <PMDCheckActivityStatus+0xc6>
    df8e:	23 e9       	ldi	r18, 0x93	; 147
    df90:	36 e6       	ldi	r19, 0x66	; 102
    df92:	ed b7       	in	r30, 0x3d	; 61
    df94:	fe b7       	in	r31, 0x3e	; 62
    df96:	32 83       	std	Z+2, r19	; 0x02
    df98:	21 83       	std	Z+1, r18	; 0x01
    df9a:	94 83       	std	Z+4, r25	; 0x04
    df9c:	83 83       	std	Z+3, r24	; 0x03
    df9e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    dfa2:	0f 90       	pop	r0
    dfa4:	0f 90       	pop	r0
    dfa6:	0f 90       	pop	r0
    dfa8:	0f 90       	pop	r0
		
		profile=(status & PMDActivityProfileModeMask) >> 3;
		switch (profile)
    dfaa:	89 81       	ldd	r24, Y+1	; 0x01
    dfac:	9a 81       	ldd	r25, Y+2	; 0x02
    dfae:	88 73       	andi	r24, 0x38	; 56
    dfb0:	90 70       	andi	r25, 0x00	; 0
    dfb2:	a3 e0       	ldi	r26, 0x03	; 3
    dfb4:	96 95       	lsr	r25
    dfb6:	87 95       	ror	r24
    dfb8:	aa 95       	dec	r26
    dfba:	e1 f7       	brne	.-8      	; 0xdfb4 <PMDCheckActivityStatus+0xec>
    dfbc:	81 30       	cpi	r24, 0x01	; 1
    dfbe:	91 05       	cpc	r25, r1
    dfc0:	89 f0       	breq	.+34     	; 0xdfe4 <PMDCheckActivityStatus+0x11c>
    dfc2:	81 30       	cpi	r24, 0x01	; 1
    dfc4:	91 05       	cpc	r25, r1
    dfc6:	30 f0       	brcs	.+12     	; 0xdfd4 <PMDCheckActivityStatus+0x10c>
    dfc8:	82 30       	cpi	r24, 0x02	; 2
    dfca:	91 05       	cpc	r25, r1
    dfcc:	99 f0       	breq	.+38     	; 0xdff4 <PMDCheckActivityStatus+0x12c>
    dfce:	03 97       	sbiw	r24, 0x03	; 3
    dfd0:	b1 f5       	brne	.+108    	; 0xe03e <PMDCheckActivityStatus+0x176>
    dfd2:	22 c0       	rjmp	.+68     	; 0xe018 <PMDCheckActivityStatus+0x150>
		{
			case (0):
			printf("PMDCheckActivityStatus=> El eje  %s tiene perfil TRAPEZOIDAL \n",AxisName(Axis));
    dfd4:	c7 01       	movw	r24, r14
    dfd6:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    dfda:	00 d0       	rcall	.+0      	; 0xdfdc <PMDCheckActivityStatus+0x114>
    dfdc:	00 d0       	rcall	.+0      	; 0xdfde <PMDCheckActivityStatus+0x116>
    dfde:	29 ed       	ldi	r18, 0xD9	; 217
    dfe0:	36 e6       	ldi	r19, 0x66	; 102
    dfe2:	0f c0       	rjmp	.+30     	; 0xe002 <PMDCheckActivityStatus+0x13a>
			break;
			
			case (1):
			printf("PMDCheckActivityStatus=> El eje  %s tiene perfil de VELOCIDAD \n",AxisName(Axis));
    dfe4:	c7 01       	movw	r24, r14
    dfe6:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    dfea:	00 d0       	rcall	.+0      	; 0xdfec <PMDCheckActivityStatus+0x124>
    dfec:	00 d0       	rcall	.+0      	; 0xdfee <PMDCheckActivityStatus+0x126>
    dfee:	28 e1       	ldi	r18, 0x18	; 24
    dff0:	37 e6       	ldi	r19, 0x67	; 103
    dff2:	19 c0       	rjmp	.+50     	; 0xe026 <PMDCheckActivityStatus+0x15e>
			break;
			
			case (2):
			printf("PMDCheckActivityStatus=> El eje  %s tiene perfil CURVA-S \n",AxisName(Axis));
    dff4:	c7 01       	movw	r24, r14
    dff6:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    dffa:	00 d0       	rcall	.+0      	; 0xdffc <PMDCheckActivityStatus+0x134>
    dffc:	00 d0       	rcall	.+0      	; 0xdffe <PMDCheckActivityStatus+0x136>
    dffe:	28 e5       	ldi	r18, 0x58	; 88
    e000:	37 e6       	ldi	r19, 0x67	; 103
    e002:	ad b7       	in	r26, 0x3d	; 61
    e004:	be b7       	in	r27, 0x3e	; 62
    e006:	12 96       	adiw	r26, 0x02	; 2
    e008:	3c 93       	st	X, r19
    e00a:	2e 93       	st	-X, r18
    e00c:	11 97       	sbiw	r26, 0x01	; 1
    e00e:	14 96       	adiw	r26, 0x04	; 4
    e010:	9c 93       	st	X, r25
    e012:	8e 93       	st	-X, r24
    e014:	13 97       	sbiw	r26, 0x03	; 3
    e016:	0d c0       	rjmp	.+26     	; 0xe032 <PMDCheckActivityStatus+0x16a>
			break;
			
			case (3):
			printf("PMDCheckActivityStatus=> El eje  %s tiene perfil ELECTRONIC GEAR \n",AxisName(Axis));
    e018:	c7 01       	movw	r24, r14
    e01a:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e01e:	00 d0       	rcall	.+0      	; 0xe020 <PMDCheckActivityStatus+0x158>
    e020:	00 d0       	rcall	.+0      	; 0xe022 <PMDCheckActivityStatus+0x15a>
    e022:	23 e9       	ldi	r18, 0x93	; 147
    e024:	37 e6       	ldi	r19, 0x67	; 103
    e026:	ed b7       	in	r30, 0x3d	; 61
    e028:	fe b7       	in	r31, 0x3e	; 62
    e02a:	32 83       	std	Z+2, r19	; 0x02
    e02c:	21 83       	std	Z+1, r18	; 0x01
    e02e:	94 83       	std	Z+4, r25	; 0x04
    e030:	83 83       	std	Z+3, r24	; 0x03
    e032:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e036:	0f 90       	pop	r0
    e038:	0f 90       	pop	r0
    e03a:	0f 90       	pop	r0
    e03c:	0f 90       	pop	r0
			break;
		}
		
		if ((status & PMDActivityAxisSettledMask)!=0) 
    e03e:	89 81       	ldd	r24, Y+1	; 0x01
    e040:	87 ff       	sbrs	r24, 7
    e042:	17 c0       	rjmp	.+46     	; 0xe072 <PMDCheckActivityStatus+0x1aa>
			printf("PMDCheckActivityStatus=> El eje %s ha permanecido en el Settle Window por un periodo de tiempo N \n",AxisName(Axis));
    e044:	c7 01       	movw	r24, r14
    e046:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e04a:	00 d0       	rcall	.+0      	; 0xe04c <PMDCheckActivityStatus+0x184>
    e04c:	00 d0       	rcall	.+0      	; 0xe04e <PMDCheckActivityStatus+0x186>
    e04e:	26 ed       	ldi	r18, 0xD6	; 214
    e050:	37 e6       	ldi	r19, 0x67	; 103
    e052:	ad b7       	in	r26, 0x3d	; 61
    e054:	be b7       	in	r27, 0x3e	; 62
    e056:	12 96       	adiw	r26, 0x02	; 2
    e058:	3c 93       	st	X, r19
    e05a:	2e 93       	st	-X, r18
    e05c:	11 97       	sbiw	r26, 0x01	; 1
    e05e:	14 96       	adiw	r26, 0x04	; 4
    e060:	9c 93       	st	X, r25
    e062:	8e 93       	st	-X, r24
    e064:	13 97       	sbiw	r26, 0x03	; 3
    e066:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e06a:	0f 90       	pop	r0
    e06c:	0f 90       	pop	r0
    e06e:	0f 90       	pop	r0
    e070:	0f 90       	pop	r0
		if ((status &  PMDActivityMotorOnMask) !=0) 
    e072:	89 81       	ldd	r24, Y+1	; 0x01
    e074:	9a 81       	ldd	r25, Y+2	; 0x02
    e076:	90 ff       	sbrs	r25, 0
    e078:	13 c0       	rjmp	.+38     	; 0xe0a0 <PMDCheckActivityStatus+0x1d8>
			printf("PMDCheckActivityStatus=> El eje %s esta en MOTOR MODE ON \n",AxisName(Axis));		
    e07a:	c7 01       	movw	r24, r14
    e07c:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e080:	00 d0       	rcall	.+0      	; 0xe082 <PMDCheckActivityStatus+0x1ba>
    e082:	00 d0       	rcall	.+0      	; 0xe084 <PMDCheckActivityStatus+0x1bc>
    e084:	29 e3       	ldi	r18, 0x39	; 57
    e086:	38 e6       	ldi	r19, 0x68	; 104
    e088:	ed b7       	in	r30, 0x3d	; 61
    e08a:	fe b7       	in	r31, 0x3e	; 62
    e08c:	32 83       	std	Z+2, r19	; 0x02
    e08e:	21 83       	std	Z+1, r18	; 0x01
    e090:	94 83       	std	Z+4, r25	; 0x04
    e092:	83 83       	std	Z+3, r24	; 0x03
    e094:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e098:	0f 90       	pop	r0
    e09a:	0f 90       	pop	r0
    e09c:	0f 90       	pop	r0
    e09e:	0f 90       	pop	r0
		if ((status & PMDActivityPositionCaptureMask) !=0 ) 
    e0a0:	89 81       	ldd	r24, Y+1	; 0x01
    e0a2:	9a 81       	ldd	r25, Y+2	; 0x02
    e0a4:	91 ff       	sbrs	r25, 1
    e0a6:	17 c0       	rjmp	.+46     	; 0xe0d6 <PMDCheckActivityStatus+0x20e>
			printf("PMDCheckActivityStatus=> El eje %s tiene un nuevo valor de posicion disponible para leer \n",AxisName(Axis));		
    e0a8:	c7 01       	movw	r24, r14
    e0aa:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e0ae:	00 d0       	rcall	.+0      	; 0xe0b0 <PMDCheckActivityStatus+0x1e8>
    e0b0:	00 d0       	rcall	.+0      	; 0xe0b2 <PMDCheckActivityStatus+0x1ea>
    e0b2:	24 e7       	ldi	r18, 0x74	; 116
    e0b4:	38 e6       	ldi	r19, 0x68	; 104
    e0b6:	ad b7       	in	r26, 0x3d	; 61
    e0b8:	be b7       	in	r27, 0x3e	; 62
    e0ba:	12 96       	adiw	r26, 0x02	; 2
    e0bc:	3c 93       	st	X, r19
    e0be:	2e 93       	st	-X, r18
    e0c0:	11 97       	sbiw	r26, 0x01	; 1
    e0c2:	14 96       	adiw	r26, 0x04	; 4
    e0c4:	9c 93       	st	X, r25
    e0c6:	8e 93       	st	-X, r24
    e0c8:	13 97       	sbiw	r26, 0x03	; 3
    e0ca:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e0ce:	0f 90       	pop	r0
    e0d0:	0f 90       	pop	r0
    e0d2:	0f 90       	pop	r0
    e0d4:	0f 90       	pop	r0
		if ((status & PMDActivityInMotionMask) !=0) 
    e0d6:	89 81       	ldd	r24, Y+1	; 0x01
    e0d8:	9a 81       	ldd	r25, Y+2	; 0x02
    e0da:	92 ff       	sbrs	r25, 2
    e0dc:	13 c0       	rjmp	.+38     	; 0xe104 <PMDCheckActivityStatus+0x23c>
			printf("PMDCheckActivityStatus=> La posicion comandada esta cambiando en el eje %s\n",AxisName(Axis));		
    e0de:	c7 01       	movw	r24, r14
    e0e0:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e0e4:	00 d0       	rcall	.+0      	; 0xe0e6 <PMDCheckActivityStatus+0x21e>
    e0e6:	00 d0       	rcall	.+0      	; 0xe0e8 <PMDCheckActivityStatus+0x220>
    e0e8:	2f ec       	ldi	r18, 0xCF	; 207
    e0ea:	38 e6       	ldi	r19, 0x68	; 104
    e0ec:	ed b7       	in	r30, 0x3d	; 61
    e0ee:	fe b7       	in	r31, 0x3e	; 62
    e0f0:	32 83       	std	Z+2, r19	; 0x02
    e0f2:	21 83       	std	Z+1, r18	; 0x01
    e0f4:	94 83       	std	Z+4, r25	; 0x04
    e0f6:	83 83       	std	Z+3, r24	; 0x03
    e0f8:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e0fc:	0f 90       	pop	r0
    e0fe:	0f 90       	pop	r0
    e100:	0f 90       	pop	r0
    e102:	0f 90       	pop	r0
		if ((status & PMDActivityInPositiveLimitMask) !=0) 
    e104:	89 81       	ldd	r24, Y+1	; 0x01
    e106:	9a 81       	ldd	r25, Y+2	; 0x02
    e108:	93 ff       	sbrs	r25, 3
    e10a:	17 c0       	rjmp	.+46     	; 0xe13a <PMDCheckActivityStatus+0x272>
			printf("PMDCheckActivityStatus=> El eje %s  esta en el Limite Positivo \n",AxisName(Axis));		
    e10c:	c7 01       	movw	r24, r14
    e10e:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e112:	00 d0       	rcall	.+0      	; 0xe114 <PMDCheckActivityStatus+0x24c>
    e114:	00 d0       	rcall	.+0      	; 0xe116 <PMDCheckActivityStatus+0x24e>
    e116:	2b e1       	ldi	r18, 0x1B	; 27
    e118:	39 e6       	ldi	r19, 0x69	; 105
    e11a:	ad b7       	in	r26, 0x3d	; 61
    e11c:	be b7       	in	r27, 0x3e	; 62
    e11e:	12 96       	adiw	r26, 0x02	; 2
    e120:	3c 93       	st	X, r19
    e122:	2e 93       	st	-X, r18
    e124:	11 97       	sbiw	r26, 0x01	; 1
    e126:	14 96       	adiw	r26, 0x04	; 4
    e128:	9c 93       	st	X, r25
    e12a:	8e 93       	st	-X, r24
    e12c:	13 97       	sbiw	r26, 0x03	; 3
    e12e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e132:	0f 90       	pop	r0
    e134:	0f 90       	pop	r0
    e136:	0f 90       	pop	r0
    e138:	0f 90       	pop	r0
		if ((status &  PMDActivityInNegativeLimitMask) !=0) 
    e13a:	89 81       	ldd	r24, Y+1	; 0x01
    e13c:	9a 81       	ldd	r25, Y+2	; 0x02
    e13e:	94 ff       	sbrs	r25, 4
    e140:	13 c0       	rjmp	.+38     	; 0xe168 <PMDCheckActivityStatus+0x2a0>
			printf("PMDCheckActivityStatus=> El eje %s  esta en el Limite Negativo \n",AxisName(Axis));
    e142:	c7 01       	movw	r24, r14
    e144:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e148:	00 d0       	rcall	.+0      	; 0xe14a <PMDCheckActivityStatus+0x282>
    e14a:	00 d0       	rcall	.+0      	; 0xe14c <PMDCheckActivityStatus+0x284>
    e14c:	2c e5       	ldi	r18, 0x5C	; 92
    e14e:	39 e6       	ldi	r19, 0x69	; 105
    e150:	ed b7       	in	r30, 0x3d	; 61
    e152:	fe b7       	in	r31, 0x3e	; 62
    e154:	32 83       	std	Z+2, r19	; 0x02
    e156:	21 83       	std	Z+1, r18	; 0x01
    e158:	94 83       	std	Z+4, r25	; 0x04
    e15a:	83 83       	std	Z+3, r24	; 0x03
    e15c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e160:	0f 90       	pop	r0
    e162:	0f 90       	pop	r0
    e164:	0f 90       	pop	r0
    e166:	0f 90       	pop	r0
	}

	return status;
}
    e168:	89 81       	ldd	r24, Y+1	; 0x01
    e16a:	9a 81       	ldd	r25, Y+2	; 0x02
    e16c:	0f 90       	pop	r0
    e16e:	0f 90       	pop	r0
    e170:	cf 91       	pop	r28
    e172:	df 91       	pop	r29
    e174:	1f 91       	pop	r17
    e176:	0f 91       	pop	r16
    e178:	ff 90       	pop	r15
    e17a:	ef 90       	pop	r14
    e17c:	08 95       	ret

0000e17e <PMDCheckEventStatus>:
extern PMDAxisHandle hAxis[DOF]; 

//**********************************************************************************************

PMDresult PMDCheckEventStatus(int16 Axis, PMDint16 print)  
{
    e17e:	cf 92       	push	r12
    e180:	df 92       	push	r13
    e182:	ef 92       	push	r14
    e184:	ff 92       	push	r15
    e186:	0f 93       	push	r16
    e188:	1f 93       	push	r17
    e18a:	df 93       	push	r29
    e18c:	cf 93       	push	r28
    e18e:	00 d0       	rcall	.+0      	; 0xe190 <PMDCheckEventStatus+0x12>
    e190:	cd b7       	in	r28, 0x3d	; 61
    e192:	de b7       	in	r29, 0x3e	; 62
    e194:	6c 01       	movw	r12, r24
    e196:	7b 01       	movw	r14, r22
	PMDuint16 status;	
	
	PMDGetEventStatus(&hAxis[Axis],&status);
    e198:	80 e6       	ldi	r24, 0x60	; 96
    e19a:	90 e0       	ldi	r25, 0x00	; 0
    e19c:	c8 9e       	mul	r12, r24
    e19e:	80 01       	movw	r16, r0
    e1a0:	c9 9e       	mul	r12, r25
    e1a2:	10 0d       	add	r17, r0
    e1a4:	d8 9e       	mul	r13, r24
    e1a6:	10 0d       	add	r17, r0
    e1a8:	11 24       	eor	r1, r1
    e1aa:	07 5e       	subi	r16, 0xE7	; 231
    e1ac:	1a 48       	sbci	r17, 0x8A	; 138
    e1ae:	c8 01       	movw	r24, r16
    e1b0:	be 01       	movw	r22, r28
    e1b2:	6f 5f       	subi	r22, 0xFF	; 255
    e1b4:	7f 4f       	sbci	r23, 0xFF	; 255
    e1b6:	0e 94 75 78 	call	0xf0ea	; 0xf0ea <PMDGetEventStatus>
	//Se limpia el Event Status Register
	PMDResetEventStatus(&hAxis[Axis],~PMDEventStatusMask);
    e1ba:	c8 01       	movw	r24, r16
    e1bc:	60 e0       	ldi	r22, 0x00	; 0
    e1be:	77 eb       	ldi	r23, 0xB7	; 183
    e1c0:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
		
	printf("PMDCheckEventStatus=> El Event Status del eje %s es %X \n",AxisName(Axis),status);
    e1c4:	c6 01       	movw	r24, r12
    e1c6:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e1ca:	00 d0       	rcall	.+0      	; 0xe1cc <PMDCheckEventStatus+0x4e>
    e1cc:	00 d0       	rcall	.+0      	; 0xe1ce <PMDCheckEventStatus+0x50>
    e1ce:	00 d0       	rcall	.+0      	; 0xe1d0 <PMDCheckEventStatus+0x52>
    e1d0:	ed b7       	in	r30, 0x3d	; 61
    e1d2:	fe b7       	in	r31, 0x3e	; 62
    e1d4:	31 96       	adiw	r30, 0x01	; 1
    e1d6:	2d e9       	ldi	r18, 0x9D	; 157
    e1d8:	39 e6       	ldi	r19, 0x69	; 105
    e1da:	ad b7       	in	r26, 0x3d	; 61
    e1dc:	be b7       	in	r27, 0x3e	; 62
    e1de:	12 96       	adiw	r26, 0x02	; 2
    e1e0:	3c 93       	st	X, r19
    e1e2:	2e 93       	st	-X, r18
    e1e4:	11 97       	sbiw	r26, 0x01	; 1
    e1e6:	93 83       	std	Z+3, r25	; 0x03
    e1e8:	82 83       	std	Z+2, r24	; 0x02
    e1ea:	89 81       	ldd	r24, Y+1	; 0x01
    e1ec:	9a 81       	ldd	r25, Y+2	; 0x02
    e1ee:	95 83       	std	Z+5, r25	; 0x05
    e1f0:	84 83       	std	Z+4, r24	; 0x04
    e1f2:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	
	if(print==imprimir)
    e1f6:	ed b7       	in	r30, 0x3d	; 61
    e1f8:	fe b7       	in	r31, 0x3e	; 62
    e1fa:	36 96       	adiw	r30, 0x06	; 6
    e1fc:	0f b6       	in	r0, 0x3f	; 63
    e1fe:	f8 94       	cli
    e200:	fe bf       	out	0x3e, r31	; 62
    e202:	0f be       	out	0x3f, r0	; 63
    e204:	ed bf       	out	0x3d, r30	; 61
    e206:	fe ee       	ldi	r31, 0xEE	; 238
    e208:	ef 16       	cp	r14, r31
    e20a:	ff ef       	ldi	r31, 0xFF	; 255
    e20c:	ff 06       	cpc	r15, r31
    e20e:	09 f0       	breq	.+2      	; 0xe212 <PMDCheckEventStatus+0x94>
    e210:	f2 c0       	rjmp	.+484    	; 0xe3f6 <PMDCheckEventStatus+0x278>
	{
    
		
		if ((status & PMDEventMotionCompleteMask) !=0) //Este eje est en movimiento		
    e212:	89 81       	ldd	r24, Y+1	; 0x01
    e214:	80 ff       	sbrs	r24, 0
    e216:	17 c0       	rjmp	.+46     	; 0xe246 <PMDCheckEventStatus+0xc8>
			printf("PMDCheckEventStatus=> El movimiento  en el eje %s ha sido completado\n",AxisName(Axis));
    e218:	c6 01       	movw	r24, r12
    e21a:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e21e:	00 d0       	rcall	.+0      	; 0xe220 <PMDCheckEventStatus+0xa2>
    e220:	00 d0       	rcall	.+0      	; 0xe222 <PMDCheckEventStatus+0xa4>
    e222:	26 ed       	ldi	r18, 0xD6	; 214
    e224:	39 e6       	ldi	r19, 0x69	; 105
    e226:	ad b7       	in	r26, 0x3d	; 61
    e228:	be b7       	in	r27, 0x3e	; 62
    e22a:	12 96       	adiw	r26, 0x02	; 2
    e22c:	3c 93       	st	X, r19
    e22e:	2e 93       	st	-X, r18
    e230:	11 97       	sbiw	r26, 0x01	; 1
    e232:	14 96       	adiw	r26, 0x04	; 4
    e234:	9c 93       	st	X, r25
    e236:	8e 93       	st	-X, r24
    e238:	13 97       	sbiw	r26, 0x03	; 3
    e23a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e23e:	0f 90       	pop	r0
    e240:	0f 90       	pop	r0
    e242:	0f 90       	pop	r0
    e244:	0f 90       	pop	r0
		
		
		if ((status & PMDEventWrapAroundMask) !=0 ) 
    e246:	89 81       	ldd	r24, Y+1	; 0x01
    e248:	81 ff       	sbrs	r24, 1
    e24a:	13 c0       	rjmp	.+38     	; 0xe272 <PMDCheckEventStatus+0xf4>
			printf("PMDCheckEventStatus=> Desborde en la posicion actual del motor 7FFFFFFF O 80000000 eje %s \n",AxisName(Axis));
    e24c:	c6 01       	movw	r24, r12
    e24e:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e252:	00 d0       	rcall	.+0      	; 0xe254 <PMDCheckEventStatus+0xd6>
    e254:	00 d0       	rcall	.+0      	; 0xe256 <PMDCheckEventStatus+0xd8>
    e256:	2c e1       	ldi	r18, 0x1C	; 28
    e258:	3a e6       	ldi	r19, 0x6A	; 106
    e25a:	ed b7       	in	r30, 0x3d	; 61
    e25c:	fe b7       	in	r31, 0x3e	; 62
    e25e:	32 83       	std	Z+2, r19	; 0x02
    e260:	21 83       	std	Z+1, r18	; 0x01
    e262:	94 83       	std	Z+4, r25	; 0x04
    e264:	83 83       	std	Z+3, r24	; 0x03
    e266:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e26a:	0f 90       	pop	r0
    e26c:	0f 90       	pop	r0
    e26e:	0f 90       	pop	r0
    e270:	0f 90       	pop	r0
	 
		//Se ha activado el Breakpoint 1
		if ((status & PMDEventBreakpoint1Mask) !=0) 
    e272:	89 81       	ldd	r24, Y+1	; 0x01
    e274:	82 ff       	sbrs	r24, 2
    e276:	17 c0       	rjmp	.+46     	; 0xe2a6 <PMDCheckEventStatus+0x128>
			printf("PMDCheckEventStatus=> Se ha activado el Breakpoint 1 en el eje %s \n",AxisName(Axis));
    e278:	c6 01       	movw	r24, r12
    e27a:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e27e:	00 d0       	rcall	.+0      	; 0xe280 <PMDCheckEventStatus+0x102>
    e280:	00 d0       	rcall	.+0      	; 0xe282 <PMDCheckEventStatus+0x104>
    e282:	28 e7       	ldi	r18, 0x78	; 120
    e284:	3a e6       	ldi	r19, 0x6A	; 106
    e286:	ad b7       	in	r26, 0x3d	; 61
    e288:	be b7       	in	r27, 0x3e	; 62
    e28a:	12 96       	adiw	r26, 0x02	; 2
    e28c:	3c 93       	st	X, r19
    e28e:	2e 93       	st	-X, r18
    e290:	11 97       	sbiw	r26, 0x01	; 1
    e292:	14 96       	adiw	r26, 0x04	; 4
    e294:	9c 93       	st	X, r25
    e296:	8e 93       	st	-X, r24
    e298:	13 97       	sbiw	r26, 0x03	; 3
    e29a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e29e:	0f 90       	pop	r0
    e2a0:	0f 90       	pop	r0
    e2a2:	0f 90       	pop	r0
    e2a4:	0f 90       	pop	r0
		
		//Se activa cuando el hardware de alta velocidad actura un nuevo dato de posicion
		if ((status & PMDEventCaptureReceivedMask) !=0) 
    e2a6:	89 81       	ldd	r24, Y+1	; 0x01
    e2a8:	83 ff       	sbrs	r24, 3
    e2aa:	13 c0       	rjmp	.+38     	; 0xe2d2 <PMDCheckEventStatus+0x154>
			printf("PMDCheckEventStatus=> El Hardware de alta velocidad ha capturado una nueva posicion del eje %s \n",AxisName(Axis));
    e2ac:	c6 01       	movw	r24, r12
    e2ae:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e2b2:	00 d0       	rcall	.+0      	; 0xe2b4 <PMDCheckEventStatus+0x136>
    e2b4:	00 d0       	rcall	.+0      	; 0xe2b6 <PMDCheckEventStatus+0x138>
    e2b6:	2c eb       	ldi	r18, 0xBC	; 188
    e2b8:	3a e6       	ldi	r19, 0x6A	; 106
    e2ba:	ed b7       	in	r30, 0x3d	; 61
    e2bc:	fe b7       	in	r31, 0x3e	; 62
    e2be:	32 83       	std	Z+2, r19	; 0x02
    e2c0:	21 83       	std	Z+1, r18	; 0x01
    e2c2:	94 83       	std	Z+4, r25	; 0x04
    e2c4:	83 83       	std	Z+3, r24	; 0x03
    e2c6:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e2ca:	0f 90       	pop	r0
    e2cc:	0f 90       	pop	r0
    e2ce:	0f 90       	pop	r0
    e2d0:	0f 90       	pop	r0
			
		//Cuando la posicion Actual difiere de la posicion commandada por una cantidad mayor 
		//que la expecificada por el maximo error de posicion
		if ((status & PMDEventMotionErrorMask)!=0) 
    e2d2:	89 81       	ldd	r24, Y+1	; 0x01
    e2d4:	84 ff       	sbrs	r24, 4
    e2d6:	17 c0       	rjmp	.+46     	; 0xe306 <PMDCheckEventStatus+0x188>
			printf("PMDCheckEventStatus=> El error del movimiento excede el limite maximo de error para el eje %s \n",AxisName(Axis));
    e2d8:	c6 01       	movw	r24, r12
    e2da:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e2de:	00 d0       	rcall	.+0      	; 0xe2e0 <PMDCheckEventStatus+0x162>
    e2e0:	00 d0       	rcall	.+0      	; 0xe2e2 <PMDCheckEventStatus+0x164>
    e2e2:	2d e1       	ldi	r18, 0x1D	; 29
    e2e4:	3b e6       	ldi	r19, 0x6B	; 107
    e2e6:	ad b7       	in	r26, 0x3d	; 61
    e2e8:	be b7       	in	r27, 0x3e	; 62
    e2ea:	12 96       	adiw	r26, 0x02	; 2
    e2ec:	3c 93       	st	X, r19
    e2ee:	2e 93       	st	-X, r18
    e2f0:	11 97       	sbiw	r26, 0x01	; 1
    e2f2:	14 96       	adiw	r26, 0x04	; 4
    e2f4:	9c 93       	st	X, r25
    e2f6:	8e 93       	st	-X, r24
    e2f8:	13 97       	sbiw	r26, 0x03	; 3
    e2fa:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e2fe:	0f 90       	pop	r0
    e300:	0f 90       	pop	r0
    e302:	0f 90       	pop	r0
    e304:	0f 90       	pop	r0
		
		//Se llego al limite positivo
		if ((status & PMDEventInPositiveLimitMask) !=0) 
    e306:	89 81       	ldd	r24, Y+1	; 0x01
    e308:	85 ff       	sbrs	r24, 5
    e30a:	13 c0       	rjmp	.+38     	; 0xe332 <PMDCheckEventStatus+0x1b4>
			printf("PMDCheckEventStatus=> Se ha llegado al limite Positivo en el eje %s\n",AxisName(Axis));
    e30c:	c6 01       	movw	r24, r12
    e30e:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e312:	00 d0       	rcall	.+0      	; 0xe314 <PMDCheckEventStatus+0x196>
    e314:	00 d0       	rcall	.+0      	; 0xe316 <PMDCheckEventStatus+0x198>
    e316:	2d e7       	ldi	r18, 0x7D	; 125
    e318:	3b e6       	ldi	r19, 0x6B	; 107
    e31a:	ed b7       	in	r30, 0x3d	; 61
    e31c:	fe b7       	in	r31, 0x3e	; 62
    e31e:	32 83       	std	Z+2, r19	; 0x02
    e320:	21 83       	std	Z+1, r18	; 0x01
    e322:	94 83       	std	Z+4, r25	; 0x04
    e324:	83 83       	std	Z+3, r24	; 0x03
    e326:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e32a:	0f 90       	pop	r0
    e32c:	0f 90       	pop	r0
    e32e:	0f 90       	pop	r0
    e330:	0f 90       	pop	r0
		
		//Se llego al limite negativo
		if ((status & PMDEventInNegativeLimitMask) !=0 ) 
    e332:	89 81       	ldd	r24, Y+1	; 0x01
    e334:	86 ff       	sbrs	r24, 6
    e336:	17 c0       	rjmp	.+46     	; 0xe366 <PMDCheckEventStatus+0x1e8>
			printf("PMDCheckEventStatus=> Se ha llegado al limite negativo en el eje %s\n",AxisName(Axis));
    e338:	c6 01       	movw	r24, r12
    e33a:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e33e:	00 d0       	rcall	.+0      	; 0xe340 <PMDCheckEventStatus+0x1c2>
    e340:	00 d0       	rcall	.+0      	; 0xe342 <PMDCheckEventStatus+0x1c4>
    e342:	22 ec       	ldi	r18, 0xC2	; 194
    e344:	3b e6       	ldi	r19, 0x6B	; 107
    e346:	ad b7       	in	r26, 0x3d	; 61
    e348:	be b7       	in	r27, 0x3e	; 62
    e34a:	12 96       	adiw	r26, 0x02	; 2
    e34c:	3c 93       	st	X, r19
    e34e:	2e 93       	st	-X, r18
    e350:	11 97       	sbiw	r26, 0x01	; 1
    e352:	14 96       	adiw	r26, 0x04	; 4
    e354:	9c 93       	st	X, r25
    e356:	8e 93       	st	-X, r24
    e358:	13 97       	sbiw	r26, 0x03	; 3
    e35a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e35e:	0f 90       	pop	r0
    e360:	0f 90       	pop	r0
    e362:	0f 90       	pop	r0
    e364:	0f 90       	pop	r0
			
		//Error de instruccion
		if ((status & PMDEventInstructionErrorMask) !=0) 
    e366:	89 81       	ldd	r24, Y+1	; 0x01
    e368:	87 ff       	sbrs	r24, 7
    e36a:	13 c0       	rjmp	.+38     	; 0xe392 <PMDCheckEventStatus+0x214>
			printf("PMDCheckEventStatus=> Ha ocurrido un error de Instruccion en el eje %s \n",AxisName(Axis));
    e36c:	c6 01       	movw	r24, r12
    e36e:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e372:	00 d0       	rcall	.+0      	; 0xe374 <PMDCheckEventStatus+0x1f6>
    e374:	00 d0       	rcall	.+0      	; 0xe376 <PMDCheckEventStatus+0x1f8>
    e376:	27 e0       	ldi	r18, 0x07	; 7
    e378:	3c e6       	ldi	r19, 0x6C	; 108
    e37a:	ed b7       	in	r30, 0x3d	; 61
    e37c:	fe b7       	in	r31, 0x3e	; 62
    e37e:	32 83       	std	Z+2, r19	; 0x02
    e380:	21 83       	std	Z+1, r18	; 0x01
    e382:	94 83       	std	Z+4, r25	; 0x04
    e384:	83 83       	std	Z+3, r24	; 0x03
    e386:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e38a:	0f 90       	pop	r0
    e38c:	0f 90       	pop	r0
    e38e:	0f 90       	pop	r0
    e390:	0f 90       	pop	r0
		
		//Error de la comunicacion solo para (MC2300)
		if ((status & PMDEventCommutationErrorMask) !=0) 
    e392:	89 81       	ldd	r24, Y+1	; 0x01
    e394:	9a 81       	ldd	r25, Y+2	; 0x02
    e396:	93 ff       	sbrs	r25, 3
    e398:	17 c0       	rjmp	.+46     	; 0xe3c8 <PMDCheckEventStatus+0x24a>
			printf("PMDCheckEventStatus=> Error de comunicacion solo para MC2300 en el eje %s \n",AxisName(Axis));
    e39a:	c6 01       	movw	r24, r12
    e39c:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e3a0:	00 d0       	rcall	.+0      	; 0xe3a2 <PMDCheckEventStatus+0x224>
    e3a2:	00 d0       	rcall	.+0      	; 0xe3a4 <PMDCheckEventStatus+0x226>
    e3a4:	20 e5       	ldi	r18, 0x50	; 80
    e3a6:	3c e6       	ldi	r19, 0x6C	; 108
    e3a8:	ad b7       	in	r26, 0x3d	; 61
    e3aa:	be b7       	in	r27, 0x3e	; 62
    e3ac:	12 96       	adiw	r26, 0x02	; 2
    e3ae:	3c 93       	st	X, r19
    e3b0:	2e 93       	st	-X, r18
    e3b2:	11 97       	sbiw	r26, 0x01	; 1
    e3b4:	14 96       	adiw	r26, 0x04	; 4
    e3b6:	9c 93       	st	X, r25
    e3b8:	8e 93       	st	-X, r24
    e3ba:	13 97       	sbiw	r26, 0x03	; 3
    e3bc:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e3c0:	0f 90       	pop	r0
    e3c2:	0f 90       	pop	r0
    e3c4:	0f 90       	pop	r0
    e3c6:	0f 90       	pop	r0
		
		//Se ha activado el Breakpoint 2
		if ((status & PMDEventBreakpoint2Mask) !=0) 
    e3c8:	89 81       	ldd	r24, Y+1	; 0x01
    e3ca:	9a 81       	ldd	r25, Y+2	; 0x02
    e3cc:	96 ff       	sbrs	r25, 6
    e3ce:	13 c0       	rjmp	.+38     	; 0xe3f6 <PMDCheckEventStatus+0x278>
			printf("PMDCheckEventStatus=> Se ha activado del Breakpoint2 en el eje %s \n",AxisName(Axis));
    e3d0:	c6 01       	movw	r24, r12
    e3d2:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e3d6:	00 d0       	rcall	.+0      	; 0xe3d8 <PMDCheckEventStatus+0x25a>
    e3d8:	00 d0       	rcall	.+0      	; 0xe3da <PMDCheckEventStatus+0x25c>
    e3da:	2c e9       	ldi	r18, 0x9C	; 156
    e3dc:	3c e6       	ldi	r19, 0x6C	; 108
    e3de:	ed b7       	in	r30, 0x3d	; 61
    e3e0:	fe b7       	in	r31, 0x3e	; 62
    e3e2:	32 83       	std	Z+2, r19	; 0x02
    e3e4:	21 83       	std	Z+1, r18	; 0x01
    e3e6:	94 83       	std	Z+4, r25	; 0x04
    e3e8:	83 83       	std	Z+3, r24	; 0x03
    e3ea:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
    e3ee:	0f 90       	pop	r0
    e3f0:	0f 90       	pop	r0
    e3f2:	0f 90       	pop	r0
    e3f4:	0f 90       	pop	r0
	}	
	
	return status;
  
}
    e3f6:	89 81       	ldd	r24, Y+1	; 0x01
    e3f8:	9a 81       	ldd	r25, Y+2	; 0x02
    e3fa:	0f 90       	pop	r0
    e3fc:	0f 90       	pop	r0
    e3fe:	cf 91       	pop	r28
    e400:	df 91       	pop	r29
    e402:	1f 91       	pop	r17
    e404:	0f 91       	pop	r16
    e406:	ff 90       	pop	r15
    e408:	ef 90       	pop	r14
    e40a:	df 90       	pop	r13
    e40c:	cf 90       	pop	r12
    e40e:	08 95       	ret

0000e410 <InstructionErrorhandling>:
	
}

/*****************************************************************************************/
void InstructionErrorhandling(tAxis Axis)
{
    e410:	0f 93       	push	r16
    e412:	1f 93       	push	r17
    e414:	8c 01       	movw	r16, r24
	
	
	/* Imprimir mensajes de Error*/	
	printf("Negativehandling=> El eje de %s Produjo un Error de Instruccion \n", AxisName(Axis));
    e416:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e41a:	00 d0       	rcall	.+0      	; 0xe41c <InstructionErrorhandling+0xc>
    e41c:	00 d0       	rcall	.+0      	; 0xe41e <InstructionErrorhandling+0xe>
    e41e:	20 ee       	ldi	r18, 0xE0	; 224
    e420:	3c e6       	ldi	r19, 0x6C	; 108
    e422:	ed b7       	in	r30, 0x3d	; 61
    e424:	fe b7       	in	r31, 0x3e	; 62
    e426:	32 83       	std	Z+2, r19	; 0x02
    e428:	21 83       	std	Z+1, r18	; 0x01
    e42a:	94 83       	std	Z+4, r25	; 0x04
    e42c:	83 83       	std	Z+3, r24	; 0x03
    e42e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	fprintf_P(stderr,PSTR("Error de Instruccion \n"));
    e432:	80 91 d2 79 	lds	r24, 0x79D2
    e436:	90 91 d3 79 	lds	r25, 0x79D3
    e43a:	ed b7       	in	r30, 0x3d	; 61
    e43c:	fe b7       	in	r31, 0x3e	; 62
    e43e:	92 83       	std	Z+2, r25	; 0x02
    e440:	81 83       	std	Z+1, r24	; 0x01
    e442:	87 e3       	ldi	r24, 0x37	; 55
    e444:	98 e1       	ldi	r25, 0x18	; 24
    e446:	94 83       	std	Z+4, r25	; 0x04
    e448:	83 83       	std	Z+3, r24	; 0x03
    e44a:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
	/* se enciende el LED Rojo*/
	Led_on(Rojo);
    e44e:	0f 90       	pop	r0
    e450:	0f 90       	pop	r0
    e452:	0f 90       	pop	r0
    e454:	0f 90       	pop	r0
    e456:	81 e0       	ldi	r24, 0x01	; 1
    e458:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
	
	
	
	/*Se limpia el Event Status Register, borrando la interrupcion 	*/	
	PMDResetEventStatus(&hAxis[Axis],~PMDEventInstructionErrorMask);
    e45c:	80 e6       	ldi	r24, 0x60	; 96
    e45e:	90 e0       	ldi	r25, 0x00	; 0
    e460:	9c 01       	movw	r18, r24
    e462:	02 9f       	mul	r16, r18
    e464:	c0 01       	movw	r24, r0
    e466:	03 9f       	mul	r16, r19
    e468:	90 0d       	add	r25, r0
    e46a:	12 9f       	mul	r17, r18
    e46c:	90 0d       	add	r25, r0
    e46e:	11 24       	eor	r1, r1
    e470:	87 5e       	subi	r24, 0xE7	; 231
    e472:	9a 48       	sbci	r25, 0x8A	; 138
    e474:	6f e7       	ldi	r22, 0x7F	; 127
    e476:	7f ef       	ldi	r23, 0xFF	; 255
    e478:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
	
	
	
}
    e47c:	1f 91       	pop	r17
    e47e:	0f 91       	pop	r16
    e480:	08 95       	ret

0000e482 <MotionCompletehandling>:
}

/*****************************************************************************************/
//Funcion NO UTILIZADA
void MotionCompletehandling(tAxis Axis)
{
    e482:	cf 93       	push	r28
    e484:	df 93       	push	r29
    e486:	ec 01       	movw	r28, r24
	printf("MotionCompletehandling=> El eje de %s ha completado el Movimiento \n", AxisName(Axis));
	#endif
	/*Se limpia el Event Status Register, borrando la interrupcion
	should clear the motion complete bit, enabling the bit to indicate 
	the end of motion for the next move*/	
	PMDResetEventStatus(&hAxis[Axis],~PMDEventMotionCompleteMask);
    e488:	80 e6       	ldi	r24, 0x60	; 96
    e48a:	90 e0       	ldi	r25, 0x00	; 0
    e48c:	9c 01       	movw	r18, r24
    e48e:	c2 9f       	mul	r28, r18
    e490:	c0 01       	movw	r24, r0
    e492:	c3 9f       	mul	r28, r19
    e494:	90 0d       	add	r25, r0
    e496:	d2 9f       	mul	r29, r18
    e498:	90 0d       	add	r25, r0
    e49a:	11 24       	eor	r1, r1
    e49c:	87 5e       	subi	r24, 0xE7	; 231
    e49e:	9a 48       	sbci	r25, 0x8A	; 138
    e4a0:	6e ef       	ldi	r22, 0xFE	; 254
    e4a2:	7f ef       	ldi	r23, 0xFF	; 255
    e4a4:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
	
	if(Axis==AxisPitch)
    e4a8:	c3 30       	cpi	r28, 0x03	; 3
    e4aa:	d1 05       	cpc	r29, r1
    e4ac:	19 f4       	brne	.+6      	; 0xe4b4 <MotionCompletehandling+0x32>
	{	
		PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventMotionCompleteMask);		
    e4ae:	89 e9       	ldi	r24, 0x99	; 153
    e4b0:	96 e7       	ldi	r25, 0x76	; 118
    e4b2:	04 c0       	rjmp	.+8      	; 0xe4bc <MotionCompletehandling+0x3a>
	}
	
	if(Axis==AxisRoll)
    e4b4:	24 97       	sbiw	r28, 0x04	; 4
    e4b6:	31 f4       	brne	.+12     	; 0xe4c4 <MotionCompletehandling+0x42>
	{	
		PMDResetEventStatus(&hAxis[AxisPitch],~PMDEventMotionCompleteMask);		
    e4b8:	89 e3       	ldi	r24, 0x39	; 57
    e4ba:	96 e7       	ldi	r25, 0x76	; 118
    e4bc:	6e ef       	ldi	r22, 0xFE	; 254
    e4be:	7f ef       	ldi	r23, 0xFF	; 255
    e4c0:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
	}
	
}
    e4c4:	df 91       	pop	r29
    e4c6:	cf 91       	pop	r28
    e4c8:	08 95       	ret

0000e4ca <Negativehandling>:
	
}

/*****************************************************************************************/
void Negativehandling(tAxis Axis)
{
    e4ca:	6f 92       	push	r6
    e4cc:	7f 92       	push	r7
    e4ce:	8f 92       	push	r8
    e4d0:	9f 92       	push	r9
    e4d2:	af 92       	push	r10
    e4d4:	bf 92       	push	r11
    e4d6:	cf 92       	push	r12
    e4d8:	df 92       	push	r13
    e4da:	ef 92       	push	r14
    e4dc:	ff 92       	push	r15
    e4de:	0f 93       	push	r16
    e4e0:	1f 93       	push	r17
    e4e2:	df 93       	push	r29
    e4e4:	cf 93       	push	r28
    e4e6:	00 d0       	rcall	.+0      	; 0xe4e8 <Negativehandling+0x1e>
    e4e8:	00 d0       	rcall	.+0      	; 0xe4ea <Negativehandling+0x20>
    e4ea:	00 d0       	rcall	.+0      	; 0xe4ec <Negativehandling+0x22>
    e4ec:	cd b7       	in	r28, 0x3d	; 61
    e4ee:	de b7       	in	r29, 0x3e	; 62
    e4f0:	3c 01       	movw	r6, r24
	PMDuint16  signal_status, Profile, Profile_roll, mask; 
	
	/* Imprimir mensajes de Error*/
	//#ifdef DEBUGINTERRUPT
	printf("Negativehandling=> El eje de %s ha llegado al Limite Negativo \n", AxisName(Axis));
    e4f2:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e4f6:	00 d0       	rcall	.+0      	; 0xe4f8 <Negativehandling+0x2e>
    e4f8:	00 d0       	rcall	.+0      	; 0xe4fa <Negativehandling+0x30>
    e4fa:	22 e2       	ldi	r18, 0x22	; 34
    e4fc:	3d e6       	ldi	r19, 0x6D	; 109
    e4fe:	ad b7       	in	r26, 0x3d	; 61
    e500:	be b7       	in	r27, 0x3e	; 62
    e502:	12 96       	adiw	r26, 0x02	; 2
    e504:	3c 93       	st	X, r19
    e506:	2e 93       	st	-X, r18
    e508:	11 97       	sbiw	r26, 0x01	; 1
    e50a:	14 96       	adiw	r26, 0x04	; 4
    e50c:	9c 93       	st	X, r25
    e50e:	8e 93       	st	-X, r24
    e510:	13 97       	sbiw	r26, 0x03	; 3
    e512:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	//#endif
	//fprintf_P(stderr,PSTR("Se produjo un Evento de Limite Negativo \n"));


	/*Salvar el Perfil de Velocidad para no alterarlo.*/
	PMDGetProfileMode(&hAxis[Axis],&Profile);
    e516:	80 e6       	ldi	r24, 0x60	; 96
    e518:	90 e0       	ldi	r25, 0x00	; 0
    e51a:	68 9e       	mul	r6, r24
    e51c:	40 01       	movw	r8, r0
    e51e:	69 9e       	mul	r6, r25
    e520:	90 0c       	add	r9, r0
    e522:	78 9e       	mul	r7, r24
    e524:	90 0c       	add	r9, r0
    e526:	11 24       	eor	r1, r1
    e528:	e9 e1       	ldi	r30, 0x19	; 25
    e52a:	f5 e7       	ldi	r31, 0x75	; 117
    e52c:	8e 0e       	add	r8, r30
    e52e:	9f 1e       	adc	r9, r31
    e530:	0f 90       	pop	r0
    e532:	0f 90       	pop	r0
    e534:	0f 90       	pop	r0
    e536:	0f 90       	pop	r0
    e538:	c4 01       	movw	r24, r8
    e53a:	be 01       	movw	r22, r28
    e53c:	6d 5f       	subi	r22, 0xFD	; 253
    e53e:	7f 4f       	sbci	r23, 0xFF	; 255
    e540:	0e 94 19 79 	call	0xf232	; 0xf232 <PMDGetProfileMode>
	The limit switch bit(s) in the event status register should be cleared
	by issuing the ResetEventStatus command. No motion is possible in any 
	direction while either of the limit switch bits in the event status register
	is set.*/
	
	PMDResetEventStatus(&hAxis[Axis],~PMDEventInNegativeLimitMask);		
    e544:	c4 01       	movw	r24, r8
    e546:	6f eb       	ldi	r22, 0xBF	; 191
    e548:	7f ef       	ldi	r23, 0xFF	; 255
    e54a:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
		
	//-----Mover el eje en la direccion opuesta del Lmite Negativo.
		
	switch (Axis)
    e54e:	f3 e0       	ldi	r31, 0x03	; 3
    e550:	6f 16       	cp	r6, r31
    e552:	71 04       	cpc	r7, r1
    e554:	31 f0       	breq	.+12     	; 0xe562 <Negativehandling+0x98>
    e556:	24 e0       	ldi	r18, 0x04	; 4
    e558:	62 16       	cp	r6, r18
    e55a:	71 04       	cpc	r7, r1
    e55c:	09 f0       	breq	.+2      	; 0xe560 <Negativehandling+0x96>
    e55e:	42 c0       	rjmp	.+132    	; 0xe5e4 <Negativehandling+0x11a>
    e560:	64 c0       	rjmp	.+200    	; 0xe62a <Negativehandling+0x160>
	{
		case (AxisPitch):
				
			/*Si se produce un evento de limite negativo en el eje de pitch
			entonces el eje roll producira un evento de Limite Positivo.*/				
			PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventInPositiveLimitMask);	
    e562:	89 e9       	ldi	r24, 0x99	; 153
    e564:	96 e7       	ldi	r25, 0x76	; 118
    e566:	6f ed       	ldi	r22, 0xDF	; 223
    e568:	7f ef       	ldi	r23, 0xFF	; 255
    e56a:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
				
			/*Se realiza un movimiento de pitch en la direccion positiva*/			
			PMDGetProfileMode(&hAxis[AxisRoll],&Profile_roll);
    e56e:	89 e9       	ldi	r24, 0x99	; 153
    e570:	96 e7       	ldi	r25, 0x76	; 118
    e572:	be 01       	movw	r22, r28
    e574:	6b 5f       	subi	r22, 0xFB	; 251
    e576:	7f 4f       	sbci	r23, 0xFF	; 255
    e578:	0e 94 19 79 	call	0xf232	; 0xf232 <PMDGetProfileMode>
			PMDSetProfileMode(&hAxis[Axis],  PMDVelocityContouringProfile ); 
    e57c:	c4 01       	movw	r24, r8
    e57e:	61 e0       	ldi	r22, 0x01	; 1
    e580:	70 e0       	ldi	r23, 0x00	; 0
    e582:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
			PMDSetProfileMode(&hAxis[AxisRoll],  PMDVelocityContouringProfile ); 
    e586:	89 e9       	ldi	r24, 0x99	; 153
    e588:	96 e7       	ldi	r25, 0x76	; 118
    e58a:	61 e0       	ldi	r22, 0x01	; 1
    e58c:	70 e0       	ldi	r23, 0x00	; 0
    e58e:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
			PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  	
    e592:	c4 01       	movw	r24, r8
    e594:	61 e0       	ldi	r22, 0x01	; 1
    e596:	70 e0       	ldi	r23, 0x00	; 0
    e598:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 
    e59c:	89 e9       	ldi	r24, 0x99	; 153
    e59e:	96 e7       	ldi	r25, 0x76	; 118
    e5a0:	61 e0       	ldi	r22, 0x01	; 1
    e5a2:	70 e0       	ldi	r23, 0x00	; 0
    e5a4:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
			pitch(none,hAxis[Axis].axisSettings.homeVelocity,
    e5a8:	20 91 79 76 	lds	r18, 0x7679
    e5ac:	30 91 7a 76 	lds	r19, 0x767A
    e5b0:	40 91 7b 76 	lds	r20, 0x767B
    e5b4:	50 91 7c 76 	lds	r21, 0x767C
    e5b8:	e0 90 7d 76 	lds	r14, 0x767D
    e5bc:	f0 90 7e 76 	lds	r15, 0x767E
    e5c0:	00 91 7f 76 	lds	r16, 0x767F
    e5c4:	10 91 80 76 	lds	r17, 0x7680
    e5c8:	61 ef       	ldi	r22, 0xF1	; 241
    e5ca:	7f ef       	ldi	r23, 0xFF	; 255
    e5cc:	8f ef       	ldi	r24, 0xFF	; 255
    e5ce:	9f ef       	ldi	r25, 0xFF	; 255
    e5d0:	a0 ef       	ldi	r26, 0xF0	; 240
    e5d2:	ca 2e       	mov	r12, r26
    e5d4:	af ef       	ldi	r26, 0xFF	; 255
    e5d6:	da 2e       	mov	r13, r26
    e5d8:	f1 e0       	ldi	r31, 0x01	; 1
    e5da:	af 2e       	mov	r10, r31
    e5dc:	b1 2c       	mov	r11, r1
    e5de:	0e 94 78 52 	call	0xa4f0	; 0xa4f0 <pitch>
    e5e2:	23 c0       	rjmp	.+70     	; 0xe62a <Negativehandling+0x160>
		break;
		case (AxisRoll):		
		break;
			
		default:
			PMDSetProfileMode(&hAxis[Axis],  PMDVelocityContouringProfile ); 
    e5e4:	c4 01       	movw	r24, r8
    e5e6:	61 e0       	ldi	r22, 0x01	; 1
    e5e8:	70 e0       	ldi	r23, 0x00	; 0
    e5ea:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
			PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  				
    e5ee:	c4 01       	movw	r24, r8
    e5f0:	61 e0       	ldi	r22, 0x01	; 1
    e5f2:	70 e0       	ldi	r23, 0x00	; 0
    e5f4:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
			mov_axis(Axis,none,hAxis[Axis].axisSettings.homeVelocity,
    e5f8:	f4 01       	movw	r30, r8
    e5fa:	e0 5c       	subi	r30, 0xC0	; 192
    e5fc:	ff 4f       	sbci	r31, 0xFF	; 255
    e5fe:	00 81       	ld	r16, Z
    e600:	11 81       	ldd	r17, Z+1	; 0x01
    e602:	22 81       	ldd	r18, Z+2	; 0x02
    e604:	33 81       	ldd	r19, Z+3	; 0x03
    e606:	f4 01       	movw	r30, r8
    e608:	ec 5b       	subi	r30, 0xBC	; 188
    e60a:	ff 4f       	sbci	r31, 0xFF	; 255
    e60c:	c0 80       	ld	r12, Z
    e60e:	d1 80       	ldd	r13, Z+1	; 0x01
    e610:	e2 80       	ldd	r14, Z+2	; 0x02
    e612:	f3 80       	ldd	r15, Z+3	; 0x03
    e614:	c3 01       	movw	r24, r6
    e616:	41 ef       	ldi	r20, 0xF1	; 241
    e618:	5f ef       	ldi	r21, 0xFF	; 255
    e61a:	6f ef       	ldi	r22, 0xFF	; 255
    e61c:	7f ef       	ldi	r23, 0xFF	; 255
    e61e:	e0 ef       	ldi	r30, 0xF0	; 240
    e620:	ae 2e       	mov	r10, r30
    e622:	ef ef       	ldi	r30, 0xFF	; 255
    e624:	be 2e       	mov	r11, r30
    e626:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
				hAxis[Axis].axisSettings.homeAcceleration, update);	
		break;
	}		

	
	PMDGetSignalStatus(&hAxis[Axis], &signal_status);
    e62a:	c4 01       	movw	r24, r8
    e62c:	8e 01       	movw	r16, r28
    e62e:	0f 5f       	subi	r16, 0xFF	; 255
    e630:	1f 4f       	sbci	r17, 0xFF	; 255
    e632:	b8 01       	movw	r22, r16
    e634:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
	
	do 
	{
		PMDGetSignalStatus(&hAxis[Axis], &signal_status);
    e638:	68 01       	movw	r12, r16
		mask=signal_status& PMDSignalNegativeLimitMask;
		//#ifdef DEBUGINTERRUPT
			printf("Negativehandling=> El Estado de la senal del Switch Negativo del eje %s es : %#X \n ",
    e63a:	82 e6       	ldi	r24, 0x62	; 98
    e63c:	e8 2e       	mov	r14, r24
    e63e:	8d e6       	ldi	r24, 0x6D	; 109
    e640:	f8 2e       	mov	r15, r24
	
	PMDGetSignalStatus(&hAxis[Axis], &signal_status);
	
	do 
	{
		PMDGetSignalStatus(&hAxis[Axis], &signal_status);
    e642:	c4 01       	movw	r24, r8
    e644:	b6 01       	movw	r22, r12
    e646:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
		mask=signal_status& PMDSignalNegativeLimitMask;
    e64a:	09 81       	ldd	r16, Y+1	; 0x01
    e64c:	1a 81       	ldd	r17, Y+2	; 0x02
    e64e:	00 72       	andi	r16, 0x20	; 32
    e650:	10 70       	andi	r17, 0x00	; 0
		//#ifdef DEBUGINTERRUPT
			printf("Negativehandling=> El Estado de la senal del Switch Negativo del eje %s es : %#X \n ",
    e652:	c3 01       	movw	r24, r6
    e654:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e658:	00 d0       	rcall	.+0      	; 0xe65a <Negativehandling+0x190>
    e65a:	00 d0       	rcall	.+0      	; 0xe65c <Negativehandling+0x192>
    e65c:	00 d0       	rcall	.+0      	; 0xe65e <Negativehandling+0x194>
    e65e:	ed b7       	in	r30, 0x3d	; 61
    e660:	fe b7       	in	r31, 0x3e	; 62
    e662:	31 96       	adiw	r30, 0x01	; 1
    e664:	ad b7       	in	r26, 0x3d	; 61
    e666:	be b7       	in	r27, 0x3e	; 62
    e668:	12 96       	adiw	r26, 0x02	; 2
    e66a:	fc 92       	st	X, r15
    e66c:	ee 92       	st	-X, r14
    e66e:	11 97       	sbiw	r26, 0x01	; 1
    e670:	93 83       	std	Z+3, r25	; 0x03
    e672:	82 83       	std	Z+2, r24	; 0x02
    e674:	15 83       	std	Z+5, r17	; 0x05
    e676:	04 83       	std	Z+4, r16	; 0x04
    e678:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
					AxisName(Axis),mask);
		//#endif
	} 
	while ((signal_status & PMDSignalNegativeLimitMask)==0);
    e67c:	89 81       	ldd	r24, Y+1	; 0x01
    e67e:	ed b7       	in	r30, 0x3d	; 61
    e680:	fe b7       	in	r31, 0x3e	; 62
    e682:	36 96       	adiw	r30, 0x06	; 6
    e684:	0f b6       	in	r0, 0x3f	; 63
    e686:	f8 94       	cli
    e688:	fe bf       	out	0x3e, r31	; 62
    e68a:	0f be       	out	0x3f, r0	; 63
    e68c:	ed bf       	out	0x3d, r30	; 61
    e68e:	85 ff       	sbrs	r24, 5
    e690:	d8 cf       	rjmp	.-80     	; 0xe642 <Negativehandling+0x178>



	//---------------- Detener suavemente el movimiento.------------------------------	
	
	PMDSetStopMode(&hAxis[Axis], PMDSmoothStopMode ); 
    e692:	c4 01       	movw	r24, r8
    e694:	62 e0       	ldi	r22, 0x02	; 2
    e696:	70 e0       	ldi	r23, 0x00	; 0
    e698:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
	PMDUpdate(&hAxis[Axis]);
    e69c:	c4 01       	movw	r24, r8
    e69e:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
	
	if(Axis==AxisPitch)
    e6a2:	f3 e0       	ldi	r31, 0x03	; 3
    e6a4:	6f 16       	cp	r6, r31
    e6a6:	71 04       	cpc	r7, r1
    e6a8:	a1 f4       	brne	.+40     	; 0xe6d2 <Negativehandling+0x208>
	{
		PMDSetStopMode(&hAxis[AxisRoll], PMDSmoothStopMode ); 	//detiene el Motor de Roll
    e6aa:	89 e9       	ldi	r24, 0x99	; 153
    e6ac:	96 e7       	ldi	r25, 0x76	; 118
    e6ae:	62 e0       	ldi	r22, 0x02	; 2
    e6b0:	70 e0       	ldi	r23, 0x00	; 0
    e6b2:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
		PMDUpdate(&hAxis[AxisRoll]);
    e6b6:	89 e9       	ldi	r24, 0x99	; 153
    e6b8:	96 e7       	ldi	r25, 0x76	; 118
    e6ba:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
		PMDSetProfileMode(&hAxis[AxisRoll],Profile_roll);			//restaura el perfil de moviemiento de Roll
    e6be:	6d 81       	ldd	r22, Y+5	; 0x05
    e6c0:	7e 81       	ldd	r23, Y+6	; 0x06
    e6c2:	89 e9       	ldi	r24, 0x99	; 153
    e6c4:	96 e7       	ldi	r25, 0x76	; 118
    e6c6:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
		PMDUpdate(&hAxis[AxisRoll]);
    e6ca:	89 e9       	ldi	r24, 0x99	; 153
    e6cc:	96 e7       	ldi	r25, 0x76	; 118
    e6ce:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
		
	}

	//Se restaura el Valor inicial del Perfil de la trayectoria.
	PMDSetProfileMode(&hAxis[Axis],Profile);
    e6d2:	6b 81       	ldd	r22, Y+3	; 0x03
    e6d4:	7c 81       	ldd	r23, Y+4	; 0x04
    e6d6:	c4 01       	movw	r24, r8
    e6d8:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
	PMDUpdate(&hAxis[Axis]);	
    e6dc:	c4 01       	movw	r24, r8
    e6de:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
	
}
    e6e2:	26 96       	adiw	r28, 0x06	; 6
    e6e4:	0f b6       	in	r0, 0x3f	; 63
    e6e6:	f8 94       	cli
    e6e8:	de bf       	out	0x3e, r29	; 62
    e6ea:	0f be       	out	0x3f, r0	; 63
    e6ec:	cd bf       	out	0x3d, r28	; 61
    e6ee:	cf 91       	pop	r28
    e6f0:	df 91       	pop	r29
    e6f2:	1f 91       	pop	r17
    e6f4:	0f 91       	pop	r16
    e6f6:	ff 90       	pop	r15
    e6f8:	ef 90       	pop	r14
    e6fa:	df 90       	pop	r13
    e6fc:	cf 90       	pop	r12
    e6fe:	bf 90       	pop	r11
    e700:	af 90       	pop	r10
    e702:	9f 90       	pop	r9
    e704:	8f 90       	pop	r8
    e706:	7f 90       	pop	r7
    e708:	6f 90       	pop	r6
    e70a:	08 95       	ret

0000e70c <Positivehandling>:
	
}

/*****************************************************************************************/
void Positivehandling(tAxis Axis)
{
    e70c:	6f 92       	push	r6
    e70e:	7f 92       	push	r7
    e710:	8f 92       	push	r8
    e712:	9f 92       	push	r9
    e714:	af 92       	push	r10
    e716:	bf 92       	push	r11
    e718:	cf 92       	push	r12
    e71a:	df 92       	push	r13
    e71c:	ef 92       	push	r14
    e71e:	ff 92       	push	r15
    e720:	0f 93       	push	r16
    e722:	1f 93       	push	r17
    e724:	df 93       	push	r29
    e726:	cf 93       	push	r28
    e728:	00 d0       	rcall	.+0      	; 0xe72a <Positivehandling+0x1e>
    e72a:	00 d0       	rcall	.+0      	; 0xe72c <Positivehandling+0x20>
    e72c:	00 d0       	rcall	.+0      	; 0xe72e <Positivehandling+0x22>
    e72e:	cd b7       	in	r28, 0x3d	; 61
    e730:	de b7       	in	r29, 0x3e	; 62
    e732:	3c 01       	movw	r6, r24
	#endif
	
	//fprintf_P(stderr,PSTR("Se produjo un Evento de Limite Positivo \n"));
	
	/*Salvar el Perfil de Velocidad para no alterarlo.*/
	PMDGetProfileMode(&hAxis[Axis],&Profile);	
    e734:	80 e6       	ldi	r24, 0x60	; 96
    e736:	90 e0       	ldi	r25, 0x00	; 0
    e738:	68 9e       	mul	r6, r24
    e73a:	40 01       	movw	r8, r0
    e73c:	69 9e       	mul	r6, r25
    e73e:	90 0c       	add	r9, r0
    e740:	78 9e       	mul	r7, r24
    e742:	90 0c       	add	r9, r0
    e744:	11 24       	eor	r1, r1
    e746:	89 e1       	ldi	r24, 0x19	; 25
    e748:	95 e7       	ldi	r25, 0x75	; 117
    e74a:	88 0e       	add	r8, r24
    e74c:	99 1e       	adc	r9, r25
    e74e:	c4 01       	movw	r24, r8
    e750:	be 01       	movw	r22, r28
    e752:	6d 5f       	subi	r22, 0xFD	; 253
    e754:	7f 4f       	sbci	r23, 0xFF	; 255
    e756:	0e 94 19 79 	call	0xf232	; 0xf232 <PMDGetProfileMode>
	The limit switch bit(s) in the event status register should be cleared
	by issuing the ResetEventStatus command. No motion is possible in any 
	direction while either of the limit switch bits in the event status register
	is set.*/
	
	PMDResetEventStatus(&hAxis[Axis],~PMDEventInPositiveLimitMask);		
    e75a:	c4 01       	movw	r24, r8
    e75c:	6f ed       	ldi	r22, 0xDF	; 223
    e75e:	7f ef       	ldi	r23, 0xFF	; 255
    e760:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
		
	// Mover el eje en la direccion opuesta del Lmite Positivo.
		
	switch (Axis)
    e764:	93 e0       	ldi	r25, 0x03	; 3
    e766:	69 16       	cp	r6, r25
    e768:	71 04       	cpc	r7, r1
    e76a:	31 f0       	breq	.+12     	; 0xe778 <Positivehandling+0x6c>
    e76c:	84 e0       	ldi	r24, 0x04	; 4
    e76e:	68 16       	cp	r6, r24
    e770:	71 04       	cpc	r7, r1
    e772:	09 f0       	breq	.+2      	; 0xe776 <Positivehandling+0x6a>
    e774:	49 c0       	rjmp	.+146    	; 0xe808 <Positivehandling+0xfc>
    e776:	72 c0       	rjmp	.+228    	; 0xe85c <Positivehandling+0x150>
	{
		case (AxisPitch):
		
			/*Si se produce un evento de limite positivo en el eje de pitch
			entonces el eje roll producira un evento de Limite Negativo.*/
			PMDResetEventStatus(&hAxis[AxisRoll],~PMDEventInNegativeLimitMask);	
    e778:	89 e9       	ldi	r24, 0x99	; 153
    e77a:	96 e7       	ldi	r25, 0x76	; 118
    e77c:	6f eb       	ldi	r22, 0xBF	; 191
    e77e:	7f ef       	ldi	r23, 0xFF	; 255
    e780:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
				
			/*Se realiza un movimiento de pitch en la direccion negativa*/
			PMDGetProfileMode(&hAxis[AxisRoll],&Profile_roll);
    e784:	89 e9       	ldi	r24, 0x99	; 153
    e786:	96 e7       	ldi	r25, 0x76	; 118
    e788:	be 01       	movw	r22, r28
    e78a:	6b 5f       	subi	r22, 0xFB	; 251
    e78c:	7f 4f       	sbci	r23, 0xFF	; 255
    e78e:	0e 94 19 79 	call	0xf232	; 0xf232 <PMDGetProfileMode>
			PMDSetProfileMode(&hAxis[Axis],  PMDVelocityContouringProfile ); 
    e792:	c4 01       	movw	r24, r8
    e794:	61 e0       	ldi	r22, 0x01	; 1
    e796:	70 e0       	ldi	r23, 0x00	; 0
    e798:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
			PMDSetProfileMode(&hAxis[AxisRoll],  PMDVelocityContouringProfile ); 
    e79c:	89 e9       	ldi	r24, 0x99	; 153
    e79e:	96 e7       	ldi	r25, 0x76	; 118
    e7a0:	61 e0       	ldi	r22, 0x01	; 1
    e7a2:	70 e0       	ldi	r23, 0x00	; 0
    e7a4:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
			PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  	
    e7a8:	c4 01       	movw	r24, r8
    e7aa:	61 e0       	ldi	r22, 0x01	; 1
    e7ac:	70 e0       	ldi	r23, 0x00	; 0
    e7ae:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 
    e7b2:	89 e9       	ldi	r24, 0x99	; 153
    e7b4:	96 e7       	ldi	r25, 0x76	; 118
    e7b6:	61 e0       	ldi	r22, 0x01	; 1
    e7b8:	70 e0       	ldi	r23, 0x00	; 0
    e7ba:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
			pitch(none,-hAxis[Axis].axisSettings.homeVelocity,
    e7be:	20 91 79 76 	lds	r18, 0x7679
    e7c2:	30 91 7a 76 	lds	r19, 0x767A
    e7c6:	40 91 7b 76 	lds	r20, 0x767B
    e7ca:	50 91 7c 76 	lds	r21, 0x767C
    e7ce:	50 95       	com	r21
    e7d0:	40 95       	com	r20
    e7d2:	30 95       	com	r19
    e7d4:	21 95       	neg	r18
    e7d6:	3f 4f       	sbci	r19, 0xFF	; 255
    e7d8:	4f 4f       	sbci	r20, 0xFF	; 255
    e7da:	5f 4f       	sbci	r21, 0xFF	; 255
    e7dc:	e0 90 7d 76 	lds	r14, 0x767D
    e7e0:	f0 90 7e 76 	lds	r15, 0x767E
    e7e4:	00 91 7f 76 	lds	r16, 0x767F
    e7e8:	10 91 80 76 	lds	r17, 0x7680
    e7ec:	61 ef       	ldi	r22, 0xF1	; 241
    e7ee:	7f ef       	ldi	r23, 0xFF	; 255
    e7f0:	8f ef       	ldi	r24, 0xFF	; 255
    e7f2:	9f ef       	ldi	r25, 0xFF	; 255
    e7f4:	f0 ef       	ldi	r31, 0xF0	; 240
    e7f6:	cf 2e       	mov	r12, r31
    e7f8:	ff ef       	ldi	r31, 0xFF	; 255
    e7fa:	df 2e       	mov	r13, r31
    e7fc:	e1 e0       	ldi	r30, 0x01	; 1
    e7fe:	ae 2e       	mov	r10, r30
    e800:	b1 2c       	mov	r11, r1
    e802:	0e 94 78 52 	call	0xa4f0	; 0xa4f0 <pitch>
    e806:	2a c0       	rjmp	.+84     	; 0xe85c <Positivehandling+0x150>
		
		case (AxisRoll):
		break;
			
		default:				
			PMDSetProfileMode(&hAxis[Axis],  PMDVelocityContouringProfile ); 
    e808:	c4 01       	movw	r24, r8
    e80a:	61 e0       	ldi	r22, 0x01	; 1
    e80c:	70 e0       	ldi	r23, 0x00	; 0
    e80e:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
			PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);  				
    e812:	c4 01       	movw	r24, r8
    e814:	61 e0       	ldi	r22, 0x01	; 1
    e816:	70 e0       	ldi	r23, 0x00	; 0
    e818:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
			mov_axis(Axis,none, -hAxis[Axis].axisSettings.homeVelocity,
    e81c:	f4 01       	movw	r30, r8
    e81e:	e0 5c       	subi	r30, 0xC0	; 192
    e820:	ff 4f       	sbci	r31, 0xFF	; 255
    e822:	00 81       	ld	r16, Z
    e824:	11 81       	ldd	r17, Z+1	; 0x01
    e826:	22 81       	ldd	r18, Z+2	; 0x02
    e828:	33 81       	ldd	r19, Z+3	; 0x03
    e82a:	30 95       	com	r19
    e82c:	20 95       	com	r18
    e82e:	10 95       	com	r17
    e830:	01 95       	neg	r16
    e832:	1f 4f       	sbci	r17, 0xFF	; 255
    e834:	2f 4f       	sbci	r18, 0xFF	; 255
    e836:	3f 4f       	sbci	r19, 0xFF	; 255
    e838:	f4 01       	movw	r30, r8
    e83a:	ec 5b       	subi	r30, 0xBC	; 188
    e83c:	ff 4f       	sbci	r31, 0xFF	; 255
    e83e:	c0 80       	ld	r12, Z
    e840:	d1 80       	ldd	r13, Z+1	; 0x01
    e842:	e2 80       	ldd	r14, Z+2	; 0x02
    e844:	f3 80       	ldd	r15, Z+3	; 0x03
    e846:	c3 01       	movw	r24, r6
    e848:	41 ef       	ldi	r20, 0xF1	; 241
    e84a:	5f ef       	ldi	r21, 0xFF	; 255
    e84c:	6f ef       	ldi	r22, 0xFF	; 255
    e84e:	7f ef       	ldi	r23, 0xFF	; 255
    e850:	b0 ef       	ldi	r27, 0xF0	; 240
    e852:	ab 2e       	mov	r10, r27
    e854:	bf ef       	ldi	r27, 0xFF	; 255
    e856:	bb 2e       	mov	r11, r27
    e858:	0e 94 73 4e 	call	0x9ce6	; 0x9ce6 <mov_axis>
				hAxis[Axis].axisSettings.homeAcceleration, update);		
		break;
	}		
		
	PMDGetSignalStatus(&hAxis[Axis], &signal_status);
    e85c:	c4 01       	movw	r24, r8
    e85e:	8e 01       	movw	r16, r28
    e860:	0f 5f       	subi	r16, 0xFF	; 255
    e862:	1f 4f       	sbci	r17, 0xFF	; 255
    e864:	b8 01       	movw	r22, r16
    e866:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
		
	do 
	{
		PMDGetSignalStatus(&hAxis[Axis], &signal_status);
    e86a:	f0 2e       	mov	r15, r16
    e86c:	01 2f       	mov	r16, r17
    e86e:	c4 01       	movw	r24, r8
    e870:	6f 2d       	mov	r22, r15
    e872:	70 2f       	mov	r23, r16
    e874:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <PMDGetSignalStatus>
			printf("Positivehandling=> El Estado de la senal del Switch Positivo del eje %s es : %#X \n ",
					AxisName(Axis),mask);
		#endif
			
	} 
	while ((signal_status & PMDSignalPositiveLimitMask)==0);
    e878:	89 81       	ldd	r24, Y+1	; 0x01
    e87a:	84 ff       	sbrs	r24, 4
    e87c:	f8 cf       	rjmp	.-16     	; 0xe86e <Positivehandling+0x162>
	

	//---------------- Detener suavemente el movimiento.	
	
	PMDSetStopMode(&hAxis[Axis], PMDSmoothStopMode ); 
    e87e:	c4 01       	movw	r24, r8
    e880:	62 e0       	ldi	r22, 0x02	; 2
    e882:	70 e0       	ldi	r23, 0x00	; 0
    e884:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
	PMDUpdate(&hAxis[Axis]);
    e888:	c4 01       	movw	r24, r8
    e88a:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
	
	if(Axis==AxisPitch)
    e88e:	93 e0       	ldi	r25, 0x03	; 3
    e890:	69 16       	cp	r6, r25
    e892:	71 04       	cpc	r7, r1
    e894:	a1 f4       	brne	.+40     	; 0xe8be <Positivehandling+0x1b2>
	{
		PMDSetStopMode(&hAxis[AxisRoll], PMDSmoothStopMode ); 
    e896:	89 e9       	ldi	r24, 0x99	; 153
    e898:	96 e7       	ldi	r25, 0x76	; 118
    e89a:	62 e0       	ldi	r22, 0x02	; 2
    e89c:	70 e0       	ldi	r23, 0x00	; 0
    e89e:	0e 94 e7 7a 	call	0xf5ce	; 0xf5ce <PMDSetStopMode>
		PMDUpdate(&hAxis[AxisRoll]);
    e8a2:	89 e9       	ldi	r24, 0x99	; 153
    e8a4:	96 e7       	ldi	r25, 0x76	; 118
    e8a6:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
		PMDSetProfileMode(&hAxis[AxisRoll],Profile_roll);
    e8aa:	6d 81       	ldd	r22, Y+5	; 0x05
    e8ac:	7e 81       	ldd	r23, Y+6	; 0x06
    e8ae:	89 e9       	ldi	r24, 0x99	; 153
    e8b0:	96 e7       	ldi	r25, 0x76	; 118
    e8b2:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
		PMDUpdate(&hAxis[AxisRoll]);
    e8b6:	89 e9       	ldi	r24, 0x99	; 153
    e8b8:	96 e7       	ldi	r25, 0x76	; 118
    e8ba:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
		
	}	
	
	//Se restaura el Valor inicial del Perfil de la trayectoria.
	PMDSetProfileMode(&hAxis[Axis],Profile);
    e8be:	6b 81       	ldd	r22, Y+3	; 0x03
    e8c0:	7c 81       	ldd	r23, Y+4	; 0x04
    e8c2:	c4 01       	movw	r24, r8
    e8c4:	0e 94 fb 7a 	call	0xf5f6	; 0xf5f6 <PMDSetProfileMode>
	PMDUpdate(&hAxis[Axis]);	
    e8c8:	c4 01       	movw	r24, r8
    e8ca:	0e 94 3d 7c 	call	0xf87a	; 0xf87a <PMDUpdate>
	
}
    e8ce:	26 96       	adiw	r28, 0x06	; 6
    e8d0:	0f b6       	in	r0, 0x3f	; 63
    e8d2:	f8 94       	cli
    e8d4:	de bf       	out	0x3e, r29	; 62
    e8d6:	0f be       	out	0x3f, r0	; 63
    e8d8:	cd bf       	out	0x3d, r28	; 61
    e8da:	cf 91       	pop	r28
    e8dc:	df 91       	pop	r29
    e8de:	1f 91       	pop	r17
    e8e0:	0f 91       	pop	r16
    e8e2:	ff 90       	pop	r15
    e8e4:	ef 90       	pop	r14
    e8e6:	df 90       	pop	r13
    e8e8:	cf 90       	pop	r12
    e8ea:	bf 90       	pop	r11
    e8ec:	af 90       	pop	r10
    e8ee:	9f 90       	pop	r9
    e8f0:	8f 90       	pop	r8
    e8f2:	7f 90       	pop	r7
    e8f4:	6f 90       	pop	r6
    e8f6:	08 95       	ret

0000e8f8 <MotionErrorhandling>:
	
}

/*****************************************************************************************/
void MotionErrorhandling(tAxis Axis)
{
    e8f8:	ef 92       	push	r14
    e8fa:	ff 92       	push	r15
    e8fc:	0f 93       	push	r16
    e8fe:	1f 93       	push	r17
    e900:	df 93       	push	r29
    e902:	cf 93       	push	r28
    e904:	00 d0       	rcall	.+0      	; 0xe906 <MotionErrorhandling+0xe>
    e906:	cd b7       	in	r28, 0x3d	; 61
    e908:	de b7       	in	r29, 0x3e	; 62
    e90a:	7c 01       	movw	r14, r24
	PMDuint16 mode;
	
	/* Imprimir mensajes de Error*/	
	printf("MotionErrorhandling=> El eje de %s Produjo un Error de Movimiento \n", AxisName(Axis));
    e90c:	0e 94 9d 36 	call	0x6d3a	; 0x6d3a <AxisName>
    e910:	00 d0       	rcall	.+0      	; 0xe912 <MotionErrorhandling+0x1a>
    e912:	00 d0       	rcall	.+0      	; 0xe914 <MotionErrorhandling+0x1c>
    e914:	26 eb       	ldi	r18, 0xB6	; 182
    e916:	3d e6       	ldi	r19, 0x6D	; 109
    e918:	ed b7       	in	r30, 0x3d	; 61
    e91a:	fe b7       	in	r31, 0x3e	; 62
    e91c:	32 83       	std	Z+2, r19	; 0x02
    e91e:	21 83       	std	Z+1, r18	; 0x01
    e920:	94 83       	std	Z+4, r25	; 0x04
    e922:	83 83       	std	Z+3, r24	; 0x03
    e924:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	fprintf_P(stderr,PSTR(" Error de Movimiento \n"));
    e928:	80 91 d2 79 	lds	r24, 0x79D2
    e92c:	90 91 d3 79 	lds	r25, 0x79D3
    e930:	ed b7       	in	r30, 0x3d	; 61
    e932:	fe b7       	in	r31, 0x3e	; 62
    e934:	92 83       	std	Z+2, r25	; 0x02
    e936:	81 83       	std	Z+1, r24	; 0x01
    e938:	8e e4       	ldi	r24, 0x4E	; 78
    e93a:	98 e1       	ldi	r25, 0x18	; 24
    e93c:	94 83       	std	Z+4, r25	; 0x04
    e93e:	83 83       	std	Z+3, r24	; 0x03
    e940:	0e 94 54 9f 	call	0x13ea8	; 0x13ea8 <fprintf_P>
	/* se enciende el LED Rojo*/
	Led_on(Rojo);
    e944:	0f 90       	pop	r0
    e946:	0f 90       	pop	r0
    e948:	0f 90       	pop	r0
    e94a:	0f 90       	pop	r0
    e94c:	81 e0       	ldi	r24, 0x01	; 1
    e94e:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
	
	
	/*Se limpia el Event Status Register, borrando la interrupcion 	*/	
	PMDResetEventStatus(&hAxis[Axis],~PMDEventMotionErrorMask);
    e952:	80 e6       	ldi	r24, 0x60	; 96
    e954:	90 e0       	ldi	r25, 0x00	; 0
    e956:	e8 9e       	mul	r14, r24
    e958:	80 01       	movw	r16, r0
    e95a:	e9 9e       	mul	r14, r25
    e95c:	10 0d       	add	r17, r0
    e95e:	f8 9e       	mul	r15, r24
    e960:	10 0d       	add	r17, r0
    e962:	11 24       	eor	r1, r1
    e964:	07 5e       	subi	r16, 0xE7	; 231
    e966:	1a 48       	sbci	r17, 0x8A	; 138
    e968:	c8 01       	movw	r24, r16
    e96a:	6f ee       	ldi	r22, 0xEF	; 239
    e96c:	7f ef       	ldi	r23, 0xFF	; 255
    e96e:	0e 94 75 7a 	call	0xf4ea	; 0xf4ea <PMDResetEventStatus>
	
	// reactivar el movimiento dependiendo de si existe parada automatica
	PMDGetAutoStopMode(&hAxis[Axis], &mode);
    e972:	c8 01       	movw	r24, r16
    e974:	be 01       	movw	r22, r28
    e976:	6f 5f       	subi	r22, 0xFF	; 255
    e978:	7f 4f       	sbci	r23, 0xFF	; 255
    e97a:	0e 94 b1 78 	call	0xf162	; 0xf162 <PMDGetAutoStopMode>
			
	if (mode==PMDEnable)
    e97e:	89 81       	ldd	r24, Y+1	; 0x01
    e980:	9a 81       	ldd	r25, Y+2	; 0x02
    e982:	01 97       	sbiw	r24, 0x01	; 1
    e984:	79 f4       	brne	.+30     	; 0xe9a4 <MotionErrorhandling+0xac>
	{
		PMDSetMotorMode(&hAxis[Axis],PMDMotorOn);
    e986:	c8 01       	movw	r24, r16
    e988:	61 e0       	ldi	r22, 0x01	; 1
    e98a:	70 e0       	ldi	r23, 0x00	; 0
    e98c:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
		if(Axis==AxisPitch)
    e990:	f3 e0       	ldi	r31, 0x03	; 3
    e992:	ef 16       	cp	r14, r31
    e994:	f1 04       	cpc	r15, r1
    e996:	31 f4       	brne	.+12     	; 0xe9a4 <MotionErrorhandling+0xac>
		{				
			PMDSetMotorMode(&hAxis[AxisRoll],PMDMotorOn); 		
    e998:	89 e9       	ldi	r24, 0x99	; 153
    e99a:	96 e7       	ldi	r25, 0x76	; 118
    e99c:	61 e0       	ldi	r22, 0x01	; 1
    e99e:	70 e0       	ldi	r23, 0x00	; 0
    e9a0:	0e 94 4b 7a 	call	0xf496	; 0xf496 <PMDSetMotorMode>
		}		
	}
	
}
    e9a4:	0f 90       	pop	r0
    e9a6:	0f 90       	pop	r0
    e9a8:	cf 91       	pop	r28
    e9aa:	df 91       	pop	r29
    e9ac:	1f 91       	pop	r17
    e9ae:	0f 91       	pop	r16
    e9b0:	ff 90       	pop	r15
    e9b2:	ef 90       	pop	r14
    e9b4:	08 95       	ret

0000e9b6 <interruptAxisHandling>:
	
}

/*****************************************************************************************/
void interruptAxisHandling(tAxis Axis)
{
    e9b6:	0f 93       	push	r16
    e9b8:	1f 93       	push	r17
    e9ba:	df 93       	push	r29
    e9bc:	cf 93       	push	r28
    e9be:	00 d0       	rcall	.+0      	; 0xe9c0 <interruptAxisHandling+0xa>
    e9c0:	cd b7       	in	r28, 0x3d	; 61
    e9c2:	de b7       	in	r29, 0x3e	; 62
    e9c4:	8c 01       	movw	r16, r24
	PMDuint16 status;
	
	
	/* ----Verificar La causa de la Interrupcion a traves de Event Status REgister*/
	
	PMDGetEventStatus(&hAxis[Axis],&status);
    e9c6:	80 e6       	ldi	r24, 0x60	; 96
    e9c8:	90 e0       	ldi	r25, 0x00	; 0
    e9ca:	9c 01       	movw	r18, r24
    e9cc:	02 9f       	mul	r16, r18
    e9ce:	c0 01       	movw	r24, r0
    e9d0:	03 9f       	mul	r16, r19
    e9d2:	90 0d       	add	r25, r0
    e9d4:	12 9f       	mul	r17, r18
    e9d6:	90 0d       	add	r25, r0
    e9d8:	11 24       	eor	r1, r1
    e9da:	87 5e       	subi	r24, 0xE7	; 231
    e9dc:	9a 48       	sbci	r25, 0x8A	; 138
    e9de:	be 01       	movw	r22, r28
    e9e0:	6f 5f       	subi	r22, 0xFF	; 255
    e9e2:	7f 4f       	sbci	r23, 0xFF	; 255
    e9e4:	0e 94 75 78 	call	0xf0ea	; 0xf0ea <PMDGetEventStatus>
	#endif	
	
	
	/*--------La causa de la Interrupcion es un Error de Movimiento */
	
	if((status & PMDEventMotionErrorMask)!=0)
    e9e8:	89 81       	ldd	r24, Y+1	; 0x01
    e9ea:	84 ff       	sbrs	r24, 4
    e9ec:	09 c0       	rjmp	.+18     	; 0xea00 <interruptAxisHandling+0x4a>
	{
		buzzer_ms(500);
    e9ee:	64 ef       	ldi	r22, 0xF4	; 244
    e9f0:	71 e0       	ldi	r23, 0x01	; 1
    e9f2:	80 e0       	ldi	r24, 0x00	; 0
    e9f4:	90 e0       	ldi	r25, 0x00	; 0
    e9f6:	0e 94 56 8d 	call	0x11aac	; 0x11aac <buzzer_ms>
		MotionErrorhandling(Axis);		
    e9fa:	c8 01       	movw	r24, r16
    e9fc:	0e 94 7c 74 	call	0xe8f8	; 0xe8f8 <MotionErrorhandling>
	}	
	
	/*--------La causa de la Interrupcion es el Evento de Limite Positivo */
	
	if((status & PMDEventInPositiveLimitMask)!=0)
    ea00:	89 81       	ldd	r24, Y+1	; 0x01
    ea02:	85 ff       	sbrs	r24, 5
    ea04:	09 c0       	rjmp	.+18     	; 0xea18 <interruptAxisHandling+0x62>
	{
		buzzer_ms(100);
    ea06:	64 e6       	ldi	r22, 0x64	; 100
    ea08:	70 e0       	ldi	r23, 0x00	; 0
    ea0a:	80 e0       	ldi	r24, 0x00	; 0
    ea0c:	90 e0       	ldi	r25, 0x00	; 0
    ea0e:	0e 94 56 8d 	call	0x11aac	; 0x11aac <buzzer_ms>
		Positivehandling(Axis);		
    ea12:	c8 01       	movw	r24, r16
    ea14:	0e 94 86 73 	call	0xe70c	; 0xe70c <Positivehandling>
	}		
	
	/*--------La causa de la Interrupcion es el Evento de Limite Negativo */
	
	if((status & PMDEventInNegativeLimitMask)!=0)
    ea18:	89 81       	ldd	r24, Y+1	; 0x01
    ea1a:	86 ff       	sbrs	r24, 6
    ea1c:	09 c0       	rjmp	.+18     	; 0xea30 <interruptAxisHandling+0x7a>
	{
		buzzer_ms(100);
    ea1e:	64 e6       	ldi	r22, 0x64	; 100
    ea20:	70 e0       	ldi	r23, 0x00	; 0
    ea22:	80 e0       	ldi	r24, 0x00	; 0
    ea24:	90 e0       	ldi	r25, 0x00	; 0
    ea26:	0e 94 56 8d 	call	0x11aac	; 0x11aac <buzzer_ms>
		Negativehandling(Axis);		
    ea2a:	c8 01       	movw	r24, r16
    ea2c:	0e 94 65 72 	call	0xe4ca	; 0xe4ca <Negativehandling>
	
	
	
	/*--------La causa de la Interrupcion es un Error de Instruccion */
	
	if((status & PMDEventInstructionErrorMask)!=0)
    ea30:	89 81       	ldd	r24, Y+1	; 0x01
    ea32:	87 ff       	sbrs	r24, 7
    ea34:	09 c0       	rjmp	.+18     	; 0xea48 <interruptAxisHandling+0x92>
	{
		buzzer_ms(500);
    ea36:	64 ef       	ldi	r22, 0xF4	; 244
    ea38:	71 e0       	ldi	r23, 0x01	; 1
    ea3a:	80 e0       	ldi	r24, 0x00	; 0
    ea3c:	90 e0       	ldi	r25, 0x00	; 0
    ea3e:	0e 94 56 8d 	call	0x11aac	; 0x11aac <buzzer_ms>
		InstructionErrorhandling(Axis);		
    ea42:	c8 01       	movw	r24, r16
    ea44:	0e 94 08 72 	call	0xe410	; 0xe410 <InstructionErrorhandling>
	}	


	
}
    ea48:	0f 90       	pop	r0
    ea4a:	0f 90       	pop	r0
    ea4c:	cf 91       	pop	r28
    ea4e:	df 91       	pop	r29
    ea50:	1f 91       	pop	r17
    ea52:	0f 91       	pop	r16
    ea54:	08 95       	ret

0000ea56 <InterruptHandling_chipset2>:
}
	

/*****************************************************************************************/
void InterruptHandling_chipset2(void)
{
    ea56:	0f 93       	push	r16
    ea58:	1f 93       	push	r17
    ea5a:	df 93       	push	r29
    ea5c:	cf 93       	push	r28
    ea5e:	00 d0       	rcall	.+0      	; 0xea60 <InterruptHandling_chipset2+0xa>
    ea60:	cd b7       	in	r28, 0x3d	; 61
    ea62:	de b7       	in	r29, 0x3e	; 62
	PMDuint16 interruptingAxisMask2;
	PMDresult rc;
	
	interruptingAxisMask2=0;
    ea64:	1a 82       	std	Y+2, r1	; 0x02
    ea66:	19 82       	std	Y+1, r1	; 0x01
	
	//Verificar que eje produjo la Interrupcion	
	do
	{
		rc=PMDGetInterruptAxis(&hAxis[AxisRoll],  &interruptingAxisMask2);
    ea68:	8e 01       	movw	r16, r28
    ea6a:	0f 5f       	subi	r16, 0xFF	; 255
    ea6c:	1f 4f       	sbci	r17, 0xFF	; 255
    ea6e:	89 e9       	ldi	r24, 0x99	; 153
    ea70:	96 e7       	ldi	r25, 0x76	; 118
    ea72:	b8 01       	movw	r22, r16
    ea74:	0e 94 7b 78 	call	0xf0f6	; 0xf0f6 <PMDGetInterruptAxis>
	}
	while (rc!=PMD_ERR_OK);			
    ea78:	89 2b       	or	r24, r25
    ea7a:	c9 f7       	brne	.-14     	; 0xea6e <InterruptHandling_chipset2+0x18>
	#ifdef DEBUGINTERRUPT
		printf("InterruptHandling_chipset2=> La mascara 2 de interrupcion es %X \n",interruptingAxisMask2 );
	#endif
	
	
	if ((interruptingAxisMask2 & PMDAxis1Mask)!=0)					//Eje de Roll Causo la Interrupcion?
    ea7c:	89 81       	ldd	r24, Y+1	; 0x01
    ea7e:	80 ff       	sbrs	r24, 0
    ea80:	10 c0       	rjmp	.+32     	; 0xeaa2 <InterruptHandling_chipset2+0x4c>
	{
		interruptAxisHandling(AxisRoll);
    ea82:	84 e0       	ldi	r24, 0x04	; 4
    ea84:	90 e0       	ldi	r25, 0x00	; 0
    ea86:	0e 94 db 74 	call	0xe9b6	; 0xe9b6 <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask2 = interruptingAxisMask2 & ~(PMDAxis1Mask);
    ea8a:	89 81       	ldd	r24, Y+1	; 0x01
    ea8c:	9a 81       	ldd	r25, Y+2	; 0x02
    ea8e:	8e 7f       	andi	r24, 0xFE	; 254
    ea90:	9a 83       	std	Y+2, r25	; 0x02
    ea92:	89 83       	std	Y+1, r24	; 0x01
		#endif	
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisRoll]);	
    ea94:	89 e9       	ldi	r24, 0x99	; 153
    ea96:	96 e7       	ldi	r25, 0x76	; 118
    ea98:	0e 94 27 7c 	call	0xf84e	; 0xf84e <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    ea9c:	89 2b       	or	r24, r25
    ea9e:	d1 f7       	brne	.-12     	; 0xea94 <InterruptHandling_chipset2+0x3e>
    eaa0:	35 c0       	rjmp	.+106    	; 0xeb0c <InterruptHandling_chipset2+0xb6>
		
		return;
	}
		
	if ((interruptingAxisMask2 & PMDAxis2Mask)!=0)					//Eje Aux1 Causo la Interrupcion?
    eaa2:	81 ff       	sbrs	r24, 1
    eaa4:	10 c0       	rjmp	.+32     	; 0xeac6 <InterruptHandling_chipset2+0x70>
	{
		interruptAxisHandling(AxisAux1);
    eaa6:	85 e0       	ldi	r24, 0x05	; 5
    eaa8:	90 e0       	ldi	r25, 0x00	; 0
    eaaa:	0e 94 db 74 	call	0xe9b6	; 0xe9b6 <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask2 = interruptingAxisMask2 & ~(PMDAxis2Mask);
    eaae:	89 81       	ldd	r24, Y+1	; 0x01
    eab0:	9a 81       	ldd	r25, Y+2	; 0x02
    eab2:	8d 7f       	andi	r24, 0xFD	; 253
    eab4:	9a 83       	std	Y+2, r25	; 0x02
    eab6:	89 83       	std	Y+1, r24	; 0x01
		#endif	
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisAux1]);	
    eab8:	89 ef       	ldi	r24, 0xF9	; 249
    eaba:	96 e7       	ldi	r25, 0x76	; 118
    eabc:	0e 94 27 7c 	call	0xf84e	; 0xf84e <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);		
    eac0:	89 2b       	or	r24, r25
    eac2:	d1 f7       	brne	.-12     	; 0xeab8 <InterruptHandling_chipset2+0x62>
    eac4:	23 c0       	rjmp	.+70     	; 0xeb0c <InterruptHandling_chipset2+0xb6>
		
		return;
	}
		
	if ((interruptingAxisMask2 & PMDAxis3Mask)!=0)					//Eje Aux2 Causo la Interrupcion?
    eac6:	82 ff       	sbrs	r24, 2
    eac8:	10 c0       	rjmp	.+32     	; 0xeaea <InterruptHandling_chipset2+0x94>
	{
		interruptAxisHandling(AxisAux2);
    eaca:	86 e0       	ldi	r24, 0x06	; 6
    eacc:	90 e0       	ldi	r25, 0x00	; 0
    eace:	0e 94 db 74 	call	0xe9b6	; 0xe9b6 <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask2 = interruptingAxisMask2 & ~(PMDAxis3Mask);
    ead2:	89 81       	ldd	r24, Y+1	; 0x01
    ead4:	9a 81       	ldd	r25, Y+2	; 0x02
    ead6:	8b 7f       	andi	r24, 0xFB	; 251
    ead8:	9a 83       	std	Y+2, r25	; 0x02
    eada:	89 83       	std	Y+1, r24	; 0x01
		#endif	
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisAux2]);	
    eadc:	89 e5       	ldi	r24, 0x59	; 89
    eade:	97 e7       	ldi	r25, 0x77	; 119
    eae0:	0e 94 27 7c 	call	0xf84e	; 0xf84e <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    eae4:	89 2b       	or	r24, r25
    eae6:	d1 f7       	brne	.-12     	; 0xeadc <InterruptHandling_chipset2+0x86>
    eae8:	11 c0       	rjmp	.+34     	; 0xeb0c <InterruptHandling_chipset2+0xb6>
		
		return;
	}
		
	if ((interruptingAxisMask2 & PMDAxis4Mask)!=0)					//Eje Aux3 Causo la Interrupcion?
    eaea:	83 ff       	sbrs	r24, 3
    eaec:	0f c0       	rjmp	.+30     	; 0xeb0c <InterruptHandling_chipset2+0xb6>
	{
		interruptAxisHandling(AxisAux3);
    eaee:	87 e0       	ldi	r24, 0x07	; 7
    eaf0:	90 e0       	ldi	r25, 0x00	; 0
    eaf2:	0e 94 db 74 	call	0xe9b6	; 0xe9b6 <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask2 = interruptingAxisMask2 & ~(PMDAxis4Mask);
    eaf6:	89 81       	ldd	r24, Y+1	; 0x01
    eaf8:	9a 81       	ldd	r25, Y+2	; 0x02
    eafa:	87 7f       	andi	r24, 0xF7	; 247
    eafc:	9a 83       	std	Y+2, r25	; 0x02
    eafe:	89 83       	std	Y+1, r24	; 0x01
		#endif	
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisAux3]);	
    eb00:	89 eb       	ldi	r24, 0xB9	; 185
    eb02:	97 e7       	ldi	r25, 0x77	; 119
    eb04:	0e 94 27 7c 	call	0xf84e	; 0xf84e <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    eb08:	89 2b       	or	r24, r25
    eb0a:	d1 f7       	brne	.-12     	; 0xeb00 <InterruptHandling_chipset2+0xaa>
		
		return;
	}
	
	
    eb0c:	0f 90       	pop	r0
    eb0e:	0f 90       	pop	r0
    eb10:	cf 91       	pop	r28
    eb12:	df 91       	pop	r29
    eb14:	1f 91       	pop	r17
    eb16:	0f 91       	pop	r16
    eb18:	08 95       	ret

0000eb1a <InterruptHandling_chipset1>:
	
}

/*****************************************************************************************/
void InterruptHandling_chipset1(void)
{
    eb1a:	0f 93       	push	r16
    eb1c:	1f 93       	push	r17
    eb1e:	df 93       	push	r29
    eb20:	cf 93       	push	r28
    eb22:	00 d0       	rcall	.+0      	; 0xeb24 <InterruptHandling_chipset1+0xa>
    eb24:	cd b7       	in	r28, 0x3d	; 61
    eb26:	de b7       	in	r29, 0x3e	; 62
	PMDuint16 interruptingAxisMask1;
	PMDresult rc;	
	interruptingAxisMask1=0;
    eb28:	1a 82       	std	Y+2, r1	; 0x02
    eb2a:	19 82       	std	Y+1, r1	; 0x01
	
	//Verificar que eje produjo la Interrupcion

	do
	{
		rc=PMDGetInterruptAxis(&hAxis[AxisWaist],  &interruptingAxisMask1);
    eb2c:	8e 01       	movw	r16, r28
    eb2e:	0f 5f       	subi	r16, 0xFF	; 255
    eb30:	1f 4f       	sbci	r17, 0xFF	; 255
    eb32:	89 e1       	ldi	r24, 0x19	; 25
    eb34:	95 e7       	ldi	r25, 0x75	; 117
    eb36:	b8 01       	movw	r22, r16
    eb38:	0e 94 7b 78 	call	0xf0f6	; 0xf0f6 <PMDGetInterruptAxis>
	}
	while (rc!=PMD_ERR_OK);		
    eb3c:	89 2b       	or	r24, r25
    eb3e:	c9 f7       	brne	.-14     	; 0xeb32 <InterruptHandling_chipset1+0x18>
		printf("InterruptHandling_chipset1=> La mascara 1 de interrupcion es %X \n",interruptingAxisMask1 );
	#endif
	
	
	
	if ((interruptingAxisMask1 & PMDAxis1Mask)!=0)					//Eje de cintura Causo la Interrupcion?
    eb40:	89 81       	ldd	r24, Y+1	; 0x01
    eb42:	80 ff       	sbrs	r24, 0
    eb44:	10 c0       	rjmp	.+32     	; 0xeb66 <InterruptHandling_chipset1+0x4c>
	{
		interruptAxisHandling(AxisWaist);
    eb46:	80 e0       	ldi	r24, 0x00	; 0
    eb48:	90 e0       	ldi	r25, 0x00	; 0
    eb4a:	0e 94 db 74 	call	0xe9b6	; 0xe9b6 <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask1 = interruptingAxisMask1 & ~(PMDAxis1Mask);
    eb4e:	89 81       	ldd	r24, Y+1	; 0x01
    eb50:	9a 81       	ldd	r25, Y+2	; 0x02
    eb52:	8e 7f       	andi	r24, 0xFE	; 254
    eb54:	9a 83       	std	Y+2, r25	; 0x02
    eb56:	89 83       	std	Y+1, r24	; 0x01
		#endif
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisWaist]);	
    eb58:	89 e1       	ldi	r24, 0x19	; 25
    eb5a:	95 e7       	ldi	r25, 0x75	; 117
    eb5c:	0e 94 27 7c 	call	0xf84e	; 0xf84e <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);			
    eb60:	89 2b       	or	r24, r25
    eb62:	d1 f7       	brne	.-12     	; 0xeb58 <InterruptHandling_chipset1+0x3e>
    eb64:	35 c0       	rjmp	.+106    	; 0xebd0 <InterruptHandling_chipset1+0xb6>
		
		return;
	}
	
	
	if ((interruptingAxisMask1 & PMDAxis2Mask)!=0)					//Eje de HOmbro Causo la Interrupcion?
    eb66:	81 ff       	sbrs	r24, 1
    eb68:	10 c0       	rjmp	.+32     	; 0xeb8a <InterruptHandling_chipset1+0x70>
	{
		interruptAxisHandling(AxisShoulder);
    eb6a:	81 e0       	ldi	r24, 0x01	; 1
    eb6c:	90 e0       	ldi	r25, 0x00	; 0
    eb6e:	0e 94 db 74 	call	0xe9b6	; 0xe9b6 <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask1 = interruptingAxisMask1 & ~(PMDAxis2Mask);
    eb72:	89 81       	ldd	r24, Y+1	; 0x01
    eb74:	9a 81       	ldd	r25, Y+2	; 0x02
    eb76:	8d 7f       	andi	r24, 0xFD	; 253
    eb78:	9a 83       	std	Y+2, r25	; 0x02
    eb7a:	89 83       	std	Y+1, r24	; 0x01
		#endif
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisShoulder]);	
    eb7c:	89 e7       	ldi	r24, 0x79	; 121
    eb7e:	95 e7       	ldi	r25, 0x75	; 117
    eb80:	0e 94 27 7c 	call	0xf84e	; 0xf84e <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    eb84:	89 2b       	or	r24, r25
    eb86:	d1 f7       	brne	.-12     	; 0xeb7c <InterruptHandling_chipset1+0x62>
    eb88:	23 c0       	rjmp	.+70     	; 0xebd0 <InterruptHandling_chipset1+0xb6>
		
		return;
	}

	if ((interruptingAxisMask1 & PMDAxis3Mask)!=0)					//Eje de Codo Causo la Interrupcion?
    eb8a:	82 ff       	sbrs	r24, 2
    eb8c:	10 c0       	rjmp	.+32     	; 0xebae <InterruptHandling_chipset1+0x94>
	{
		interruptAxisHandling(AxisElbow);
    eb8e:	82 e0       	ldi	r24, 0x02	; 2
    eb90:	90 e0       	ldi	r25, 0x00	; 0
    eb92:	0e 94 db 74 	call	0xe9b6	; 0xe9b6 <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask1 = interruptingAxisMask1 & ~(PMDAxis3Mask);
    eb96:	89 81       	ldd	r24, Y+1	; 0x01
    eb98:	9a 81       	ldd	r25, Y+2	; 0x02
    eb9a:	8b 7f       	andi	r24, 0xFB	; 251
    eb9c:	9a 83       	std	Y+2, r25	; 0x02
    eb9e:	89 83       	std	Y+1, r24	; 0x01
		#endif
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisElbow]);	
    eba0:	89 ed       	ldi	r24, 0xD9	; 217
    eba2:	95 e7       	ldi	r25, 0x75	; 117
    eba4:	0e 94 27 7c 	call	0xf84e	; 0xf84e <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    eba8:	89 2b       	or	r24, r25
    ebaa:	d1 f7       	brne	.-12     	; 0xeba0 <InterruptHandling_chipset1+0x86>
    ebac:	11 c0       	rjmp	.+34     	; 0xebd0 <InterruptHandling_chipset1+0xb6>
		
		return;
	}

	if ((interruptingAxisMask1 & PMDAxis4Mask)!=0)					//Eje de Pitch Causo la Interrupcion?
    ebae:	83 ff       	sbrs	r24, 3
    ebb0:	0f c0       	rjmp	.+30     	; 0xebd0 <InterruptHandling_chipset1+0xb6>
	{
		interruptAxisHandling(AxisPitch);
    ebb2:	83 e0       	ldi	r24, 0x03	; 3
    ebb4:	90 e0       	ldi	r25, 0x00	; 0
    ebb6:	0e 94 db 74 	call	0xe9b6	; 0xe9b6 <interruptAxisHandling>
		//Limpio el bit correspondiente con el eje
		interruptingAxisMask1 = interruptingAxisMask1 & ~(PMDAxis4Mask);
    ebba:	89 81       	ldd	r24, Y+1	; 0x01
    ebbc:	9a 81       	ldd	r25, Y+2	; 0x02
    ebbe:	87 7f       	andi	r24, 0xF7	; 247
    ebc0:	9a 83       	std	Y+2, r25	; 0x02
    ebc2:	89 83       	std	Y+1, r24	; 0x01
		#endif
		
		/* resets the HostInterrupt signal to its inactive state*/	 
		do
		{
			rc=PMDClearInterrupt(&hAxis[AxisPitch]);	
    ebc4:	89 e3       	ldi	r24, 0x39	; 57
    ebc6:	96 e7       	ldi	r25, 0x76	; 118
    ebc8:	0e 94 27 7c 	call	0xf84e	; 0xf84e <PMDClearInterrupt>
		}
		while (rc!=PMD_ERR_OK);	
    ebcc:	89 2b       	or	r24, r25
    ebce:	d1 f7       	brne	.-12     	; 0xebc4 <InterruptHandling_chipset1+0xaa>
		
		return;
	}
	
}
    ebd0:	0f 90       	pop	r0
    ebd2:	0f 90       	pop	r0
    ebd4:	cf 91       	pop	r28
    ebd6:	df 91       	pop	r29
    ebd8:	1f 91       	pop	r17
    ebda:	0f 91       	pop	r16
    ebdc:	08 95       	ret

0000ebde <HostInterruptEnable>:
		}
	}
} 
/*****************************************************************************************/
void HostInterruptEnable(void)
{
    ebde:	cf 93       	push	r28
    ebe0:	df 93       	push	r29
    ebe2:	c9 e1       	ldi	r28, 0x19	; 25
    ebe4:	d5 e7       	ldi	r29, 0x75	; 117
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE) &&
    ebe6:	8c 81       	ldd	r24, Y+4	; 0x04
    ebe8:	81 30       	cpi	r24, 0x01	; 1
    ebea:	41 f4       	brne	.+16     	; 0xebfc <HostInterruptEnable+0x1e>
    ebec:	8d 81       	ldd	r24, Y+5	; 0x05
    ebee:	81 30       	cpi	r24, 0x01	; 1
    ebf0:	29 f4       	brne	.+10     	; 0xebfc <HostInterruptEnable+0x1e>
			(hAxis[axis].axisSettings.interruptEnable==TRUE))
		{
			PMDSetInterruptMask(&hAxis[axis],	PMDEventMotionErrorMask		|
    ebf2:	ce 01       	movw	r24, r28
    ebf4:	60 ef       	ldi	r22, 0xF0	; 240
    ebf6:	70 e0       	ldi	r23, 0x00	; 0
    ebf8:	0e 94 7b 7a 	call	0xf4f6	; 0xf4f6 <PMDSetInterruptMask>
    ebfc:	c0 5a       	subi	r28, 0xA0	; 160
    ebfe:	df 4f       	sbci	r29, 0xFF	; 255
/*****************************************************************************************/
void HostInterruptEnable(void)
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
    ec00:	86 e7       	ldi	r24, 0x76	; 118
    ec02:	c9 3f       	cpi	r28, 0xF9	; 249
    ec04:	d8 07       	cpc	r29, r24
    ec06:	79 f7       	brne	.-34     	; 0xebe6 <HostInterruptEnable+0x8>
												PMDEventInPositiveLimitMask | 
												PMDEventInNegativeLimitMask	|
												PMDEventInstructionErrorMask);
		}
	}
}
    ec08:	df 91       	pop	r29
    ec0a:	cf 91       	pop	r28
    ec0c:	08 95       	ret

0000ec0e <HostInterruptDisable>:



/*******************************************************************************************/
void HostInterruptDisable(void)
{
    ec0e:	cf 93       	push	r28
    ec10:	df 93       	push	r29
    ec12:	c9 e1       	ldi	r28, 0x19	; 25
    ec14:	d5 e7       	ldi	r29, 0x75	; 117
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
	{
		if((hAxis[axis].axisSettings.axisEnabled == TRUE) &&
    ec16:	8c 81       	ldd	r24, Y+4	; 0x04
    ec18:	81 30       	cpi	r24, 0x01	; 1
    ec1a:	41 f4       	brne	.+16     	; 0xec2c <HostInterruptDisable+0x1e>
    ec1c:	8d 81       	ldd	r24, Y+5	; 0x05
    ec1e:	81 30       	cpi	r24, 0x01	; 1
    ec20:	29 f4       	brne	.+10     	; 0xec2c <HostInterruptDisable+0x1e>
			(hAxis[axis].axisSettings.interruptEnable==TRUE))
		{
			PMDSetInterruptMask(&hAxis[axis],0);
    ec22:	ce 01       	movw	r24, r28
    ec24:	60 e0       	ldi	r22, 0x00	; 0
    ec26:	70 e0       	ldi	r23, 0x00	; 0
    ec28:	0e 94 7b 7a 	call	0xf4f6	; 0xf4f6 <PMDSetInterruptMask>
    ec2c:	c0 5a       	subi	r28, 0xA0	; 160
    ec2e:	df 4f       	sbci	r29, 0xFF	; 255
/*******************************************************************************************/
void HostInterruptDisable(void)
{
	int16 axis;
	
	for(axis=0; axis < DOF; axis++)
    ec30:	86 e7       	ldi	r24, 0x76	; 118
    ec32:	c9 3f       	cpi	r28, 0xF9	; 249
    ec34:	d8 07       	cpc	r29, r24
    ec36:	79 f7       	brne	.-34     	; 0xec16 <HostInterruptDisable+0x8>
			(hAxis[axis].axisSettings.interruptEnable==TRUE))
		{
			PMDSetInterruptMask(&hAxis[axis],0);
		}
	}
} 
    ec38:	df 91       	pop	r29
    ec3a:	cf 91       	pop	r28
    ec3c:	08 95       	ret

0000ec3e <PMDGetStatus>:


// C-Motion provided functions

PMDresult PMDGetStatus(PMDAxisHandle* axis_handle)
{
    ec3e:	fc 01       	movw	r30, r24
	return axis_handle->transport.GetStatus(axis_handle->transport_data);
    ec40:	dc 01       	movw	r26, r24
    ec42:	a2 5a       	subi	r26, 0xA2	; 162
    ec44:	bf 4f       	sbci	r27, 0xFF	; 255
    ec46:	ec 5a       	subi	r30, 0xAC	; 172
    ec48:	ff 4f       	sbci	r31, 0xFF	; 255
    ec4a:	01 90       	ld	r0, Z+
    ec4c:	f0 81       	ld	r31, Z
    ec4e:	e0 2d       	mov	r30, r0
    ec50:	8d 91       	ld	r24, X+
    ec52:	9c 91       	ld	r25, X
    ec54:	09 95       	icall
}
    ec56:	08 95       	ret

0000ec58 <PMDHasError>:

PMDresult PMDHasError(PMDAxisHandle* axis_handle)
{
    ec58:	fc 01       	movw	r30, r24
	return axis_handle->transport.HasError(axis_handle->transport_data);
    ec5a:	dc 01       	movw	r26, r24
    ec5c:	a2 5a       	subi	r26, 0xA2	; 162
    ec5e:	bf 4f       	sbci	r27, 0xFF	; 255
    ec60:	e6 5a       	subi	r30, 0xA6	; 166
    ec62:	ff 4f       	sbci	r31, 0xFF	; 255
    ec64:	01 90       	ld	r0, Z+
    ec66:	f0 81       	ld	r31, Z
    ec68:	e0 2d       	mov	r30, r0
    ec6a:	8d 91       	ld	r24, X+
    ec6c:	9c 91       	ld	r25, X
    ec6e:	09 95       	icall
}
    ec70:	08 95       	ret

0000ec72 <PMDIsReady>:

PMDresult PMDIsReady(PMDAxisHandle* axis_handle)
{
    ec72:	fc 01       	movw	r30, r24
	return axis_handle->transport.IsReady(axis_handle->transport_data);
    ec74:	dc 01       	movw	r26, r24
    ec76:	a2 5a       	subi	r26, 0xA2	; 162
    ec78:	bf 4f       	sbci	r27, 0xFF	; 255
    ec7a:	ea 5a       	subi	r30, 0xAA	; 170
    ec7c:	ff 4f       	sbci	r31, 0xFF	; 255
    ec7e:	01 90       	ld	r0, Z+
    ec80:	f0 81       	ld	r31, Z
    ec82:	e0 2d       	mov	r30, r0
    ec84:	8d 91       	ld	r24, X+
    ec86:	9c 91       	ld	r25, X
    ec88:	09 95       	icall
}
    ec8a:	08 95       	ret

0000ec8c <PMDHasInterrupt>:

PMDresult PMDHasInterrupt(PMDAxisHandle* axis_handle)
{
    ec8c:	fc 01       	movw	r30, r24
	return axis_handle->transport.HasInterrupt(axis_handle->transport_data);
    ec8e:	dc 01       	movw	r26, r24
    ec90:	a2 5a       	subi	r26, 0xA2	; 162
    ec92:	bf 4f       	sbci	r27, 0xFF	; 255
    ec94:	e8 5a       	subi	r30, 0xA8	; 168
    ec96:	ff 4f       	sbci	r31, 0xFF	; 255
    ec98:	01 90       	ld	r0, Z+
    ec9a:	f0 81       	ld	r31, Z
    ec9c:	e0 2d       	mov	r30, r0
    ec9e:	8d 91       	ld	r24, X+
    eca0:	9c 91       	ld	r25, X
    eca2:	09 95       	icall
}
    eca4:	08 95       	ret

0000eca6 <PMDHardReset>:

PMDresult PMDHardReset(PMDAxisHandle* axis_handle)
{  //Se invoca la funcion asociada a axis_handle->transport.HardReset
    eca6:	fc 01       	movw	r30, r24
   //luego esta funcion toma transport_data y ejecuta una de las funciones asocioadas
   //mediante PIOtransport_data->Hard();
   //que si se ha sido corretamente inicializada sera OutP8BitHard(void)
   //esta llama writePMDreset() en basicio.c
   //la cual finalmente hace el reset por hardaware y mana comandos de reset sin esperar PMDready.
	return axis_handle->transport.HardReset(axis_handle->transport_data);
    eca8:	dc 01       	movw	r26, r24
    ecaa:	a2 5a       	subi	r26, 0xA2	; 162
    ecac:	bf 4f       	sbci	r27, 0xFF	; 255
    ecae:	e4 5a       	subi	r30, 0xA4	; 164
    ecb0:	ff 4f       	sbci	r31, 0xFF	; 255
    ecb2:	01 90       	ld	r0, Z+
    ecb4:	f0 81       	ld	r31, Z
    ecb6:	e0 2d       	mov	r30, r0
    ecb8:	8d 91       	ld	r24, X+
    ecba:	9c 91       	ld	r25, X
    ecbc:	09 95       	icall
}
    ecbe:	08 95       	ret

0000ecc0 <PMDCloseAxisInterface>:

void PMDCloseAxisInterface(PMDAxisHandle* axis_handle)
{
    ecc0:	fc 01       	movw	r30, r24
	axis_handle->transport.Close(axis_handle->transport_data);
    ecc2:	dc 01       	movw	r26, r24
    ecc4:	a2 5a       	subi	r26, 0xA2	; 162
    ecc6:	bf 4f       	sbci	r27, 0xFF	; 255
    ecc8:	ee 5a       	subi	r30, 0xAE	; 174
    ecca:	ff 4f       	sbci	r31, 0xFF	; 255
    eccc:	01 90       	ld	r0, Z+
    ecce:	f0 81       	ld	r31, Z
    ecd0:	e0 2d       	mov	r30, r0
    ecd2:	8d 91       	ld	r24, X+
    ecd4:	9c 91       	ld	r25, X
    ecd6:	09 95       	icall
}
    ecd8:	08 95       	ret

0000ecda <PMDGetCMotionVersion>:

void PMDGetCMotionVersion(PMDuint8* MajorVersion, PMDuint8* MinorVersion)
{
    ecda:	fc 01       	movw	r30, r24
    ecdc:	db 01       	movw	r26, r22
	*MajorVersion = CMOTION_MAJOR_VERSION;
    ecde:	81 e0       	ldi	r24, 0x01	; 1
    ece0:	80 83       	st	Z, r24
	*MinorVersion = CMOTION_MINOR_VERSION;
    ece2:	85 e0       	ldi	r24, 0x05	; 5
    ece4:	8c 93       	st	X, r24
}
    ece6:	08 95       	ret

0000ece8 <PMDGetSynchronizationMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetSynchronizationMode, mode);
}

PMDresult PMDGetSynchronizationMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    ece8:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSynchronizationMode, mode);
    ecea:	63 ef       	ldi	r22, 0xF3	; 243
    ecec:	70 e0       	ldi	r23, 0x00	; 0
    ecee:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    ecf2:	08 95       	ret

0000ecf4 <PMDGetStepRange>:
{
	return SendCommandWord(axis_handle, PMDOPSetStepRange, range);
}

PMDresult PMDGetStepRange(PMDAxisHandle* axis_handle, PMDuint16* range)
{
    ecf4:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetStepRange, range);
    ecf6:	6e ec       	ldi	r22, 0xCE	; 206
    ecf8:	70 e0       	ldi	r23, 0x00	; 0
    ecfa:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    ecfe:	08 95       	ret

0000ed00 <PMDGetDiagnosticPortMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetDiagnosticPortMode, mode);
}

PMDresult PMDGetDiagnosticPortMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    ed00:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetDiagnosticPortMode, mode);
    ed02:	6a e8       	ldi	r22, 0x8A	; 138
    ed04:	70 e0       	ldi	r23, 0x00	; 0
    ed06:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    ed0a:	08 95       	ret

0000ed0c <PMDGetSerialPortMode>:
	return SendCommandWord(axis_handle, PMDOPSetSerialPortMode, serialData);
}

PMDresult PMDGetSerialPortMode(PMDAxisHandle* axis_handle, PMDuint8* baud, PMDuint8* parity, 
					PMDuint8* stopBits, PMDuint8* protocol, PMDuint8* multiDropID)
{
    ed0c:	8f 92       	push	r8
    ed0e:	9f 92       	push	r9
    ed10:	af 92       	push	r10
    ed12:	bf 92       	push	r11
    ed14:	cf 92       	push	r12
    ed16:	df 92       	push	r13
    ed18:	ef 92       	push	r14
    ed1a:	ff 92       	push	r15
    ed1c:	0f 93       	push	r16
    ed1e:	1f 93       	push	r17
    ed20:	df 93       	push	r29
    ed22:	cf 93       	push	r28
    ed24:	00 d0       	rcall	.+0      	; 0xed26 <PMDGetSerialPortMode+0x1a>
    ed26:	cd b7       	in	r28, 0x3d	; 61
    ed28:	de b7       	in	r29, 0x3e	; 62
    ed2a:	6b 01       	movw	r12, r22
    ed2c:	5a 01       	movw	r10, r20
    ed2e:	49 01       	movw	r8, r18
	PMDuint16 serialData;
	PMDuint16 result;

	result = SendCommandGetWord(axis_handle, PMDOPGetSerialPortMode, &serialData);
    ed30:	6c e8       	ldi	r22, 0x8C	; 140
    ed32:	70 e0       	ldi	r23, 0x00	; 0
    ed34:	ae 01       	movw	r20, r28
    ed36:	4f 5f       	subi	r20, 0xFF	; 255
    ed38:	5f 4f       	sbci	r21, 0xFF	; 255
    ed3a:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>

	*baud = (PMDuint8)(serialData & 0x000F);
    ed3e:	29 81       	ldd	r18, Y+1	; 0x01
    ed40:	2f 70       	andi	r18, 0x0F	; 15
    ed42:	f6 01       	movw	r30, r12
    ed44:	20 83       	st	Z, r18
	*parity = (PMDuint8)((serialData & 0x0030) >> 4);
    ed46:	49 81       	ldd	r20, Y+1	; 0x01
    ed48:	5a 81       	ldd	r21, Y+2	; 0x02
    ed4a:	9a 01       	movw	r18, r20
    ed4c:	20 73       	andi	r18, 0x30	; 48
    ed4e:	30 70       	andi	r19, 0x00	; 0
    ed50:	74 e0       	ldi	r23, 0x04	; 4
    ed52:	36 95       	lsr	r19
    ed54:	27 95       	ror	r18
    ed56:	7a 95       	dec	r23
    ed58:	e1 f7       	brne	.-8      	; 0xed52 <PMDGetSerialPortMode+0x46>
    ed5a:	f5 01       	movw	r30, r10
    ed5c:	20 83       	st	Z, r18
	*stopBits = (PMDuint8)((serialData & 0x0040) >> 6);
    ed5e:	9a 01       	movw	r18, r20
    ed60:	20 74       	andi	r18, 0x40	; 64
    ed62:	30 70       	andi	r19, 0x00	; 0
    ed64:	66 e0       	ldi	r22, 0x06	; 6
    ed66:	36 95       	lsr	r19
    ed68:	27 95       	ror	r18
    ed6a:	6a 95       	dec	r22
    ed6c:	e1 f7       	brne	.-8      	; 0xed66 <PMDGetSerialPortMode+0x5a>
    ed6e:	f4 01       	movw	r30, r8
    ed70:	20 83       	st	Z, r18
	*protocol = (PMDuint8)((serialData & 0x0180) >> 7);
    ed72:	40 78       	andi	r20, 0x80	; 128
    ed74:	51 70       	andi	r21, 0x01	; 1
    ed76:	44 0f       	add	r20, r20
    ed78:	45 2f       	mov	r20, r21
    ed7a:	44 1f       	adc	r20, r20
    ed7c:	55 0b       	sbc	r21, r21
    ed7e:	51 95       	neg	r21
    ed80:	f8 01       	movw	r30, r16
    ed82:	40 83       	st	Z, r20
	*multiDropID = (PMDuint8)((serialData & 0xF800) >> 11);
    ed84:	2a 81       	ldd	r18, Y+2	; 0x02
    ed86:	26 95       	lsr	r18
    ed88:	26 95       	lsr	r18
    ed8a:	26 95       	lsr	r18
    ed8c:	f7 01       	movw	r30, r14
    ed8e:	20 83       	st	Z, r18

	return result;
}
    ed90:	0f 90       	pop	r0
    ed92:	0f 90       	pop	r0
    ed94:	cf 91       	pop	r28
    ed96:	df 91       	pop	r29
    ed98:	1f 91       	pop	r17
    ed9a:	0f 91       	pop	r16
    ed9c:	ff 90       	pop	r15
    ed9e:	ef 90       	pop	r14
    eda0:	df 90       	pop	r13
    eda2:	cf 90       	pop	r12
    eda4:	bf 90       	pop	r11
    eda6:	af 90       	pop	r10
    eda8:	9f 90       	pop	r9
    edaa:	8f 90       	pop	r8
    edac:	08 95       	ret

0000edae <PMDGetHostIOError>:

	return result;
}

PMDresult PMDGetHostIOError(PMDAxisHandle* axis_handle, PMDuint16 *hostIOError)
{
    edae:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetHostIOError, hostIOError);
    edb0:	65 ea       	ldi	r22, 0xA5	; 165
    edb2:	70 e0       	ldi	r23, 0x00	; 0
    edb4:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    edb8:	08 95       	ret

0000edba <PMDGetAxisOutSource>:
		
	return SendCommandWord(axis_handle, PMDOPSetAxisOutSource, value);
}

PMDresult PMDGetAxisOutSource(PMDAxisHandle* axis_handle, PMDAxis* sourceAxis, PMDuint8* bit, PMDuint8* sourceRegister)
{
    edba:	cf 92       	push	r12
    edbc:	df 92       	push	r13
    edbe:	ef 92       	push	r14
    edc0:	ff 92       	push	r15
    edc2:	0f 93       	push	r16
    edc4:	1f 93       	push	r17
    edc6:	df 93       	push	r29
    edc8:	cf 93       	push	r28
    edca:	00 d0       	rcall	.+0      	; 0xedcc <PMDGetAxisOutSource+0x12>
    edcc:	cd b7       	in	r28, 0x3d	; 61
    edce:	de b7       	in	r29, 0x3e	; 62
    edd0:	8b 01       	movw	r16, r22
    edd2:	7a 01       	movw	r14, r20
    edd4:	69 01       	movw	r12, r18
	PMDuint16 result;
	PMDuint16 value;

	result = SendCommandGetWord(axis_handle, PMDOPGetAxisOutSource, &value);
    edd6:	6e ee       	ldi	r22, 0xEE	; 238
    edd8:	70 e0       	ldi	r23, 0x00	; 0
    edda:	ae 01       	movw	r20, r28
    eddc:	4f 5f       	subi	r20, 0xFF	; 255
    edde:	5f 4f       	sbci	r21, 0xFF	; 255
    ede0:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>

	*sourceAxis = (PMDAxis)(value & nibbleMask);
    ede4:	29 81       	ldd	r18, Y+1	; 0x01
    ede6:	3a 81       	ldd	r19, Y+2	; 0x02
    ede8:	a9 01       	movw	r20, r18
    edea:	4f 70       	andi	r20, 0x0F	; 15
    edec:	50 70       	andi	r21, 0x00	; 0
    edee:	f8 01       	movw	r30, r16
    edf0:	51 83       	std	Z+1, r21	; 0x01
    edf2:	40 83       	st	Z, r20

	value = (PMDuint16)(value >> 4);
    edf4:	f4 e0       	ldi	r31, 0x04	; 4
    edf6:	36 95       	lsr	r19
    edf8:	27 95       	ror	r18
    edfa:	fa 95       	dec	r31
    edfc:	e1 f7       	brne	.-8      	; 0xedf6 <PMDGetAxisOutSource+0x3c>
	*bit = (PMDuint8)(value & nibbleMask);
    edfe:	42 2f       	mov	r20, r18
    ee00:	4f 70       	andi	r20, 0x0F	; 15
    ee02:	f7 01       	movw	r30, r14
    ee04:	40 83       	st	Z, r20

	value = (PMDuint16)(value >> 4);
    ee06:	e4 e0       	ldi	r30, 0x04	; 4
    ee08:	36 95       	lsr	r19
    ee0a:	27 95       	ror	r18
    ee0c:	ea 95       	dec	r30
    ee0e:	e1 f7       	brne	.-8      	; 0xee08 <PMDGetAxisOutSource+0x4e>
	*sourceRegister = (PMDuint8)(value & nibbleMask);
    ee10:	2f 70       	andi	r18, 0x0F	; 15
    ee12:	f6 01       	movw	r30, r12
    ee14:	20 83       	st	Z, r18

	return result;
}
    ee16:	0f 90       	pop	r0
    ee18:	0f 90       	pop	r0
    ee1a:	cf 91       	pop	r28
    ee1c:	df 91       	pop	r29
    ee1e:	1f 91       	pop	r17
    ee20:	0f 91       	pop	r16
    ee22:	ff 90       	pop	r15
    ee24:	ef 90       	pop	r14
    ee26:	df 90       	pop	r13
    ee28:	cf 90       	pop	r12
    ee2a:	08 95       	ret

0000ee2c <PMDGetAxisMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetAxisMode, mode);
}

PMDresult PMDGetAxisMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    ee2c:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetAxisMode, mode);
    ee2e:	68 e8       	ldi	r22, 0x88	; 136
    ee30:	70 e0       	ldi	r23, 0x00	; 0
    ee32:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    ee36:	08 95       	ret

0000ee38 <PMDGetTraceStatus>:
	return result;
}


PMDresult PMDGetTraceStatus(PMDAxisHandle* axis_handle, PMDuint16* status)
{
    ee38:	ef 92       	push	r14
    ee3a:	ff 92       	push	r15
    ee3c:	0f 93       	push	r16
    ee3e:	1f 93       	push	r17
    ee40:	8c 01       	movw	r16, r24
    ee42:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    ee44:	fc 01       	movw	r30, r24
    ee46:	e2 80       	ldd	r14, Z+2	; 0x02
    ee48:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    ee4a:	13 82       	std	Z+3, r1	; 0x03
    ee4c:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetWord(axis_handle, PMDOPGetTraceStatus, status);
    ee4e:	6a eb       	ldi	r22, 0xBA	; 186
    ee50:	70 e0       	ldi	r23, 0x00	; 0
    ee52:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>

	axis_handle->axis = axis;
    ee56:	f8 01       	movw	r30, r16
    ee58:	f3 82       	std	Z+3, r15	; 0x03
    ee5a:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    ee5c:	1f 91       	pop	r17
    ee5e:	0f 91       	pop	r16
    ee60:	ff 90       	pop	r15
    ee62:	ef 90       	pop	r14
    ee64:	08 95       	ret

0000ee66 <PMDGetTraceStop>:

	return result;
}

PMDresult PMDGetTraceStop(PMDAxisHandle* axis_handle, PMDAxis *traceAxis, PMDuint8* condition, PMDuint8* bit, PMDuint8* state)
{
    ee66:	6f 92       	push	r6
    ee68:	7f 92       	push	r7
    ee6a:	8f 92       	push	r8
    ee6c:	9f 92       	push	r9
    ee6e:	af 92       	push	r10
    ee70:	bf 92       	push	r11
    ee72:	cf 92       	push	r12
    ee74:	df 92       	push	r13
    ee76:	ef 92       	push	r14
    ee78:	ff 92       	push	r15
    ee7a:	0f 93       	push	r16
    ee7c:	1f 93       	push	r17
    ee7e:	df 93       	push	r29
    ee80:	cf 93       	push	r28
    ee82:	00 d0       	rcall	.+0      	; 0xee84 <PMDGetTraceStop+0x1e>
    ee84:	cd b7       	in	r28, 0x3d	; 61
    ee86:	de b7       	in	r29, 0x3e	; 62
    ee88:	7c 01       	movw	r14, r24
    ee8a:	6b 01       	movw	r12, r22
    ee8c:	5a 01       	movw	r10, r20
    ee8e:	49 01       	movw	r8, r18
	PMDuint16 result;
	PMDuint16 value;
	PMDAxis axis = axis_handle->axis;
    ee90:	fc 01       	movw	r30, r24
    ee92:	62 80       	ldd	r6, Z+2	; 0x02
    ee94:	73 80       	ldd	r7, Z+3	; 0x03

	// set the axis number to zero
	axis_handle->axis = 0;
    ee96:	13 82       	std	Z+3, r1	; 0x03
    ee98:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetWord(axis_handle, PMDOPGetTraceStop, &value);
    ee9a:	65 eb       	ldi	r22, 0xB5	; 181
    ee9c:	70 e0       	ldi	r23, 0x00	; 0
    ee9e:	ae 01       	movw	r20, r28
    eea0:	4f 5f       	subi	r20, 0xFF	; 255
    eea2:	5f 4f       	sbci	r21, 0xFF	; 255
    eea4:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
	*traceAxis = (PMDAxis)((value & nibbleMask));
    eea8:	29 81       	ldd	r18, Y+1	; 0x01
    eeaa:	3a 81       	ldd	r19, Y+2	; 0x02
    eeac:	a9 01       	movw	r20, r18
    eeae:	4f 70       	andi	r20, 0x0F	; 15
    eeb0:	50 70       	andi	r21, 0x00	; 0
    eeb2:	f6 01       	movw	r30, r12
    eeb4:	51 83       	std	Z+1, r21	; 0x01
    eeb6:	40 83       	st	Z, r20
	*condition = (PMDuint8)((value >> 4) & nibbleMask);
    eeb8:	a4 e0       	ldi	r26, 0x04	; 4
    eeba:	36 95       	lsr	r19
    eebc:	27 95       	ror	r18
    eebe:	aa 95       	dec	r26
    eec0:	e1 f7       	brne	.-8      	; 0xeeba <PMDGetTraceStop+0x54>
    eec2:	2f 70       	andi	r18, 0x0F	; 15
    eec4:	f5 01       	movw	r30, r10
    eec6:	20 83       	st	Z, r18
	*bit = (PMDuint8)((value >> 8) & nibbleMask);
    eec8:	2a 81       	ldd	r18, Y+2	; 0x02
    eeca:	32 2f       	mov	r19, r18
    eecc:	3f 70       	andi	r19, 0x0F	; 15
    eece:	f4 01       	movw	r30, r8
    eed0:	30 83       	st	Z, r19
	*state = (PMDuint8)((value >> 12) & nibbleMask);
    eed2:	22 95       	swap	r18
    eed4:	2f 70       	andi	r18, 0x0F	; 15
    eed6:	f8 01       	movw	r30, r16
    eed8:	20 83       	st	Z, r18

	axis_handle->axis = axis;
    eeda:	f7 01       	movw	r30, r14
    eedc:	73 82       	std	Z+3, r7	; 0x03
    eede:	62 82       	std	Z+2, r6	; 0x02

	return result;
}
    eee0:	0f 90       	pop	r0
    eee2:	0f 90       	pop	r0
    eee4:	cf 91       	pop	r28
    eee6:	df 91       	pop	r29
    eee8:	1f 91       	pop	r17
    eeea:	0f 91       	pop	r16
    eeec:	ff 90       	pop	r15
    eeee:	ef 90       	pop	r14
    eef0:	df 90       	pop	r13
    eef2:	cf 90       	pop	r12
    eef4:	bf 90       	pop	r11
    eef6:	af 90       	pop	r10
    eef8:	9f 90       	pop	r9
    eefa:	8f 90       	pop	r8
    eefc:	7f 90       	pop	r7
    eefe:	6f 90       	pop	r6
    ef00:	08 95       	ret

0000ef02 <PMDGetTraceStart>:

	return result;
}

PMDresult PMDGetTraceStart(PMDAxisHandle* axis_handle, PMDAxis *traceAxis, PMDuint8* condition, PMDuint8* bit, PMDuint8* state)
{
    ef02:	6f 92       	push	r6
    ef04:	7f 92       	push	r7
    ef06:	8f 92       	push	r8
    ef08:	9f 92       	push	r9
    ef0a:	af 92       	push	r10
    ef0c:	bf 92       	push	r11
    ef0e:	cf 92       	push	r12
    ef10:	df 92       	push	r13
    ef12:	ef 92       	push	r14
    ef14:	ff 92       	push	r15
    ef16:	0f 93       	push	r16
    ef18:	1f 93       	push	r17
    ef1a:	df 93       	push	r29
    ef1c:	cf 93       	push	r28
    ef1e:	00 d0       	rcall	.+0      	; 0xef20 <PMDGetTraceStart+0x1e>
    ef20:	cd b7       	in	r28, 0x3d	; 61
    ef22:	de b7       	in	r29, 0x3e	; 62
    ef24:	7c 01       	movw	r14, r24
    ef26:	6b 01       	movw	r12, r22
    ef28:	5a 01       	movw	r10, r20
    ef2a:	49 01       	movw	r8, r18
	PMDuint16 result;
	PMDuint16 value;
	PMDAxis axis = axis_handle->axis;
    ef2c:	fc 01       	movw	r30, r24
    ef2e:	62 80       	ldd	r6, Z+2	; 0x02
    ef30:	73 80       	ldd	r7, Z+3	; 0x03

	// set the axis number to zero
	axis_handle->axis = 0;
    ef32:	13 82       	std	Z+3, r1	; 0x03
    ef34:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetWord(axis_handle, PMDOPGetTraceStart, &value);
    ef36:	63 eb       	ldi	r22, 0xB3	; 179
    ef38:	70 e0       	ldi	r23, 0x00	; 0
    ef3a:	ae 01       	movw	r20, r28
    ef3c:	4f 5f       	subi	r20, 0xFF	; 255
    ef3e:	5f 4f       	sbci	r21, 0xFF	; 255
    ef40:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
	*traceAxis = (PMDAxis)((value & nibbleMask));
    ef44:	29 81       	ldd	r18, Y+1	; 0x01
    ef46:	3a 81       	ldd	r19, Y+2	; 0x02
    ef48:	a9 01       	movw	r20, r18
    ef4a:	4f 70       	andi	r20, 0x0F	; 15
    ef4c:	50 70       	andi	r21, 0x00	; 0
    ef4e:	f6 01       	movw	r30, r12
    ef50:	51 83       	std	Z+1, r21	; 0x01
    ef52:	40 83       	st	Z, r20
	*condition = (PMDuint8)((value >> 4) & nibbleMask);
    ef54:	b4 e0       	ldi	r27, 0x04	; 4
    ef56:	36 95       	lsr	r19
    ef58:	27 95       	ror	r18
    ef5a:	ba 95       	dec	r27
    ef5c:	e1 f7       	brne	.-8      	; 0xef56 <PMDGetTraceStart+0x54>
    ef5e:	2f 70       	andi	r18, 0x0F	; 15
    ef60:	f5 01       	movw	r30, r10
    ef62:	20 83       	st	Z, r18
	*bit = (PMDuint8)((value >> 8) & nibbleMask);
    ef64:	2a 81       	ldd	r18, Y+2	; 0x02
    ef66:	32 2f       	mov	r19, r18
    ef68:	3f 70       	andi	r19, 0x0F	; 15
    ef6a:	f4 01       	movw	r30, r8
    ef6c:	30 83       	st	Z, r19
	*state = (PMDuint8)((value >> 12) & nibbleMask);
    ef6e:	22 95       	swap	r18
    ef70:	2f 70       	andi	r18, 0x0F	; 15
    ef72:	f8 01       	movw	r30, r16
    ef74:	20 83       	st	Z, r18

	axis_handle->axis = axis;
    ef76:	f7 01       	movw	r30, r14
    ef78:	73 82       	std	Z+3, r7	; 0x03
    ef7a:	62 82       	std	Z+2, r6	; 0x02

	return result;
}
    ef7c:	0f 90       	pop	r0
    ef7e:	0f 90       	pop	r0
    ef80:	cf 91       	pop	r28
    ef82:	df 91       	pop	r29
    ef84:	1f 91       	pop	r17
    ef86:	0f 91       	pop	r16
    ef88:	ff 90       	pop	r15
    ef8a:	ef 90       	pop	r14
    ef8c:	df 90       	pop	r13
    ef8e:	cf 90       	pop	r12
    ef90:	bf 90       	pop	r11
    ef92:	af 90       	pop	r10
    ef94:	9f 90       	pop	r9
    ef96:	8f 90       	pop	r8
    ef98:	7f 90       	pop	r7
    ef9a:	6f 90       	pop	r6
    ef9c:	08 95       	ret

0000ef9e <PMDGetTracePeriod>:

	return result;
}

PMDresult PMDGetTracePeriod(PMDAxisHandle* axis_handle, PMDuint16* tracePeriod)
{
    ef9e:	ef 92       	push	r14
    efa0:	ff 92       	push	r15
    efa2:	0f 93       	push	r16
    efa4:	1f 93       	push	r17
    efa6:	8c 01       	movw	r16, r24
    efa8:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    efaa:	fc 01       	movw	r30, r24
    efac:	e2 80       	ldd	r14, Z+2	; 0x02
    efae:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    efb0:	13 82       	std	Z+3, r1	; 0x03
    efb2:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetWord(axis_handle, PMDOPGetTracePeriod, tracePeriod);
    efb4:	69 eb       	ldi	r22, 0xB9	; 185
    efb6:	70 e0       	ldi	r23, 0x00	; 0
    efb8:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>

	axis_handle->axis = axis;
    efbc:	f8 01       	movw	r30, r16
    efbe:	f3 82       	std	Z+3, r15	; 0x03
    efc0:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    efc2:	1f 91       	pop	r17
    efc4:	0f 91       	pop	r16
    efc6:	ff 90       	pop	r15
    efc8:	ef 90       	pop	r14
    efca:	08 95       	ret

0000efcc <PMDGetTraceMode>:

	return result;
}

PMDresult PMDGetTraceMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    efcc:	ef 92       	push	r14
    efce:	ff 92       	push	r15
    efd0:	0f 93       	push	r16
    efd2:	1f 93       	push	r17
    efd4:	8c 01       	movw	r16, r24
    efd6:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    efd8:	fc 01       	movw	r30, r24
    efda:	e2 80       	ldd	r14, Z+2	; 0x02
    efdc:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    efde:	13 82       	std	Z+3, r1	; 0x03
    efe0:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetWord(axis_handle, PMDOPGetTraceMode, mode);
    efe2:	61 eb       	ldi	r22, 0xB1	; 177
    efe4:	70 e0       	ldi	r23, 0x00	; 0
    efe6:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>

	axis_handle->axis = axis;
    efea:	f8 01       	movw	r30, r16
    efec:	f3 82       	std	Z+3, r15	; 0x03
    efee:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    eff0:	1f 91       	pop	r17
    eff2:	0f 91       	pop	r16
    eff4:	ff 90       	pop	r15
    eff6:	ef 90       	pop	r14
    eff8:	08 95       	ret

0000effa <PMDGetPhaseCorrectionMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseCorrectionMode, mode);
}

PMDresult PMDGetPhaseCorrectionMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    effa:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseCorrectionMode, mode);
    effc:	69 ee       	ldi	r22, 0xE9	; 233
    effe:	70 e0       	ldi	r23, 0x00	; 0
    f000:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f004:	08 95       	ret

0000f006 <PMDGetPhaseAngle>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseAngle, phaseAngle);
}

PMDresult PMDGetPhaseAngle(PMDAxisHandle* axis_handle, PMDuint16* phaseAngle)
{
    f006:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseAngle, phaseAngle);
    f008:	6c e2       	ldi	r22, 0x2C	; 44
    f00a:	70 e0       	ldi	r23, 0x00	; 0
    f00c:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f010:	08 95       	ret

0000f012 <PMDGetPhaseOffset>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseOffset, phaseOffset);
}

PMDresult PMDGetPhaseOffset(PMDAxisHandle* axis_handle, PMDuint16* phaseOffset)
{
    f012:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseOffset, phaseOffset);
    f014:	6b e7       	ldi	r22, 0x7B	; 123
    f016:	70 e0       	ldi	r23, 0x00	; 0
    f018:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f01c:	08 95       	ret

0000f01e <PMDGetPhaseInitializeTime>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseInitializeTime, phaseInitTime);
}

PMDresult PMDGetPhaseInitializeTime(PMDAxisHandle* axis_handle, PMDuint16* phaseInitTime)
{
    f01e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseInitializeTime, phaseInitTime);
    f020:	6c e7       	ldi	r22, 0x7C	; 124
    f022:	70 e0       	ldi	r23, 0x00	; 0
    f024:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f028:	08 95       	ret

0000f02a <PMDGetPhaseCounts>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseCounts, phaseCounts);
}

PMDresult PMDGetPhaseCounts(PMDAxisHandle* axis_handle, PMDuint16* phaseCounts)
{
    f02a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseCounts, phaseCounts);
    f02c:	6d e7       	ldi	r22, 0x7D	; 125
    f02e:	70 e0       	ldi	r23, 0x00	; 0
    f030:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f034:	08 95       	ret

0000f036 <PMDGetPhasePrescale>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhasePrescale, phasePrescale);
}

PMDresult PMDGetPhasePrescale(PMDAxisHandle* axis_handle, PMDuint16* phasePrescale)
{
    f036:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhasePrescale, phasePrescale);
    f038:	67 ee       	ldi	r22, 0xE7	; 231
    f03a:	70 e0       	ldi	r23, 0x00	; 0
    f03c:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f040:	08 95       	ret

0000f042 <PMDGetPhaseInitializeMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetPhaseInitializeMode, mode);
}

PMDresult PMDGetPhaseInitializeMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    f042:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseInitializeMode, mode);
    f044:	65 ee       	ldi	r22, 0xE5	; 229
    f046:	70 e0       	ldi	r23, 0x00	; 0
    f048:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f04c:	08 95       	ret

0000f04e <PMDGetNumberPhases>:
{
	return SendCommandWord(axis_handle, PMDOPSetNumberPhases, numberPhases);
}

PMDresult PMDGetNumberPhases(PMDAxisHandle* axis_handle, PMDuint16* numberPhases)
{
    f04e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetNumberPhases, numberPhases);
    f050:	66 e8       	ldi	r22, 0x86	; 134
    f052:	70 e0       	ldi	r23, 0x00	; 0
    f054:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f058:	08 95       	ret

0000f05a <PMDGetCommutationMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetCommutationMode, mode);
}

PMDresult PMDGetCommutationMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    f05a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetCommutationMode, mode);
    f05c:	63 ee       	ldi	r22, 0xE3	; 227
    f05e:	70 e0       	ldi	r23, 0x00	; 0
    f060:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f064:	08 95       	ret

0000f066 <PMDGetCurrentMotorCommand>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetMotorCommand, (PMDuint16*)motorCommand);
}

PMDresult PMDGetCurrentMotorCommand(PMDAxisHandle* axis_handle, PMDint16* motorCommand)
{
    f066:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetCurrentMotorCommand, (PMDuint16*)motorCommand);
    f068:	6a e3       	ldi	r22, 0x3A	; 58
    f06a:	70 e0       	ldi	r23, 0x00	; 0
    f06c:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f070:	08 95       	ret

0000f072 <PMDGetMotorCommand>:
{
	return SendCommandWord(axis_handle, PMDOPSetMotorCommand, (PMDuint16)motorCommand);
}

PMDresult PMDGetMotorCommand(PMDAxisHandle* axis_handle, PMDint16* motorCommand)
{
    f072:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetMotorCommand, (PMDuint16*)motorCommand);
    f074:	69 e6       	ldi	r22, 0x69	; 105
    f076:	70 e0       	ldi	r23, 0x00	; 0
    f078:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f07c:	08 95       	ret

0000f07e <PMDGetMotorMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetMotorMode, mode);
}

PMDresult PMDGetMotorMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    f07e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetMotorMode, mode);
    f080:	6d ed       	ldi	r22, 0xDD	; 221
    f082:	70 e0       	ldi	r23, 0x00	; 0
    f084:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f088:	08 95       	ret

0000f08a <PMDGetOutputMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetOutputMode, mode);
}

PMDresult PMDGetOutputMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    f08a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetOutputMode, mode);
    f08c:	6e e6       	ldi	r22, 0x6E	; 110
    f08e:	70 e0       	ldi	r23, 0x00	; 0
    f090:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f094:	08 95       	ret

0000f096 <PMDGetEncoderModulus>:
{
	return SendCommandWord(axis_handle, PMDOPSetEncoderModulus, modulus);
}

PMDresult PMDGetEncoderModulus(PMDAxisHandle* axis_handle, PMDuint16* modulus)
{
    f096:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetEncoderModulus, modulus);
    f098:	6e e8       	ldi	r22, 0x8E	; 142
    f09a:	70 e0       	ldi	r23, 0x00	; 0
    f09c:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f0a0:	08 95       	ret

0000f0a2 <PMDGetEncoderSource>:
{
	return SendCommandWord(axis_handle, PMDOPSetEncoderSource, encoderSource);
}

PMDresult PMDGetEncoderSource(PMDAxisHandle* axis_handle, PMDuint16* encoderSource)
{
    f0a2:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetEncoderSource, encoderSource);
    f0a4:	6b ed       	ldi	r22, 0xDB	; 219
    f0a6:	70 e0       	ldi	r23, 0x00	; 0
    f0a8:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f0ac:	08 95       	ret

0000f0ae <PMDGetCaptureSource>:
{
	return SendCommandWord(axis_handle, PMDOPSetCaptureSource, captureSource);
}

PMDresult PMDGetCaptureSource(PMDAxisHandle* axis_handle, PMDuint16* captureSource)
{
    f0ae:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetCaptureSource, captureSource);
    f0b0:	69 ed       	ldi	r22, 0xD9	; 217
    f0b2:	70 e0       	ldi	r23, 0x00	; 0
    f0b4:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f0b8:	08 95       	ret

0000f0ba <PMDGetActualPositionUnits>:
{
	return SendCommandWord(axis_handle, PMDOPSetActualPositionUnits, mode);
}

PMDresult PMDGetActualPositionUnits(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    f0ba:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetActualPositionUnits, mode);
    f0bc:	6f eb       	ldi	r22, 0xBF	; 191
    f0be:	70 e0       	ldi	r23, 0x00	; 0
    f0c0:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f0c4:	08 95       	ret

0000f0c6 <PMDGetSignalStatus>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetSignalSense, mask);
}

PMDresult PMDGetSignalStatus(PMDAxisHandle* axis_handle, PMDuint16* signalStatus)
{
    f0c6:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSignalStatus, signalStatus);
    f0c8:	64 ea       	ldi	r22, 0xA4	; 164
    f0ca:	70 e0       	ldi	r23, 0x00	; 0
    f0cc:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f0d0:	08 95       	ret

0000f0d2 <PMDGetSignalSense>:
{
	return SendCommandWord(axis_handle, PMDOPSetSignalSense, mask);
}

PMDresult PMDGetSignalSense(PMDAxisHandle* axis_handle, PMDuint16* mask)
{
    f0d2:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSignalSense, mask);
    f0d4:	63 ea       	ldi	r22, 0xA3	; 163
    f0d6:	70 e0       	ldi	r23, 0x00	; 0
    f0d8:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f0dc:	08 95       	ret

0000f0de <PMDGetActivityStatus>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetEventStatus, eventStatus);
}

PMDresult PMDGetActivityStatus(PMDAxisHandle* axis_handle, PMDuint16* activityStatus)
{
    f0de:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetActivityStatus, activityStatus);
    f0e0:	66 ea       	ldi	r22, 0xA6	; 166
    f0e2:	70 e0       	ldi	r23, 0x00	; 0
    f0e4:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f0e8:	08 95       	ret

0000f0ea <PMDGetEventStatus>:
{
	return SendCommandWord(axis_handle, PMDOPResetEventStatus, eventStatus);
}

PMDresult PMDGetEventStatus(PMDAxisHandle* axis_handle, PMDuint16* eventStatus)
{
    f0ea:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetEventStatus, eventStatus);
    f0ec:	61 e3       	ldi	r22, 0x31	; 49
    f0ee:	70 e0       	ldi	r23, 0x00	; 0
    f0f0:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f0f4:	08 95       	ret

0000f0f6 <PMDGetInterruptAxis>:

	return result;
}

PMDresult PMDGetInterruptAxis(PMDAxisHandle* axis_handle, PMDuint16* interruptingAxisMask)
{
    f0f6:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetInterruptAxis, interruptingAxisMask);
    f0f8:	61 ee       	ldi	r22, 0xE1	; 225
    f0fa:	70 e0       	ldi	r23, 0x00	; 0
    f0fc:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f100:	08 95       	ret

0000f102 <PMDGetInterruptMask>:
{
	return SendCommandWord(axis_handle, PMDOPSetInterruptMask, interruptMask);
}

PMDresult PMDGetInterruptMask(PMDAxisHandle* axis_handle, PMDuint16* interruptMask)
{
    f102:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetInterruptMask, interruptMask);
    f104:	66 e5       	ldi	r22, 0x56	; 86
    f106:	70 e0       	ldi	r23, 0x00	; 0
    f108:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f10c:	08 95       	ret

0000f10e <PMDGetSampleTime>:
{
	return SendCommandWord(axis_handle, PMDOPSetSampleTime, sampleTime);
}

PMDresult PMDGetSampleTime(PMDAxisHandle* axis_handle, PMDuint16* sampleTime)
{
    f10e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSampleTime, sampleTime);
    f110:	61 e6       	ldi	r22, 0x61	; 97
    f112:	70 e0       	ldi	r23, 0x00	; 0
    f114:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f118:	08 95       	ret

0000f11a <PMDGetDerivative>:
{
	return SendCommand(axis_handle, PMDOPClearPositionError);
}

PMDresult PMDGetDerivative(PMDAxisHandle* axis_handle, PMDint16* derivative)
{
    f11a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetDerivative, (PMDuint16*)derivative);
    f11c:	6b e9       	ldi	r22, 0x9B	; 155
    f11e:	70 e0       	ldi	r23, 0x00	; 0
    f120:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f124:	08 95       	ret

0000f126 <PMDGetMotionCompleteMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetMotionCompleteMode, mode);
}

PMDresult PMDGetMotionCompleteMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    f126:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetMotionCompleteMode, mode);
    f128:	6c ee       	ldi	r22, 0xEC	; 236
    f12a:	70 e0       	ldi	r23, 0x00	; 0
    f12c:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f130:	08 95       	ret

0000f132 <PMDGetTrackingWindow>:
{
	return SendCommandWord(axis_handle, PMDOPSetTrackingWindow, trackingWindow);
}

PMDresult PMDGetTrackingWindow(PMDAxisHandle* axis_handle, PMDuint16* trackingWindow)
{
    f132:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetTrackingWindow, trackingWindow);
    f134:	69 ea       	ldi	r22, 0xA9	; 169
    f136:	70 e0       	ldi	r23, 0x00	; 0
    f138:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f13c:	08 95       	ret

0000f13e <PMDGetSettleWindow>:
{
	return SendCommandWord(axis_handle, PMDOPSetSettleWindow, settleWindow);
}

PMDresult PMDGetSettleWindow(PMDAxisHandle* axis_handle, PMDuint16* settleWindow)
{
    f13e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSettleWindow, settleWindow);
    f140:	6d eb       	ldi	r22, 0xBD	; 189
    f142:	70 e0       	ldi	r23, 0x00	; 0
    f144:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f148:	08 95       	ret

0000f14a <PMDGetSettleTime>:
{
	return SendCommandWord(axis_handle, PMDOPSetSettleTime, settleTime);
}

PMDresult PMDGetSettleTime(PMDAxisHandle* axis_handle, PMDuint16* settleTime)
{
    f14a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetSettleTime, settleTime);
    f14c:	6b ea       	ldi	r22, 0xAB	; 171
    f14e:	70 e0       	ldi	r23, 0x00	; 0
    f150:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f154:	08 95       	ret

0000f156 <PMDGetDerivativeTime>:
{
	return SendCommandWord(axis_handle, PMDOPSetDerivativeTime, derivativeTime);
}

PMDresult PMDGetDerivativeTime(PMDAxisHandle* axis_handle, PMDuint16* derivativeTime)
{
    f156:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetDerivativeTime, derivativeTime);
    f158:	6d e9       	ldi	r22, 0x9D	; 157
    f15a:	70 e0       	ldi	r23, 0x00	; 0
    f15c:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f160:	08 95       	ret

0000f162 <PMDGetAutoStopMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetAutoStopMode, mode);
}

PMDresult PMDGetAutoStopMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    f162:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetAutoStopMode, mode);
    f164:	63 ed       	ldi	r22, 0xD3	; 211
    f166:	70 e0       	ldi	r23, 0x00	; 0
    f168:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f16c:	08 95       	ret

0000f16e <PMDGetMotorBias>:
{
	return SendCommandWord(axis_handle, PMDOPSetMotorBias, (PMDuint16)bias);
}

PMDresult PMDGetMotorBias(PMDAxisHandle* axis_handle, PMDint16* bias)
{
    f16e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetMotorBias, (PMDuint16*)bias);
    f170:	6d e2       	ldi	r22, 0x2D	; 45
    f172:	70 e0       	ldi	r23, 0x00	; 0
    f174:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f178:	08 95       	ret

0000f17a <PMDGetMotorLimit>:
{
	return SendCommandWord(axis_handle, PMDOPSetMotorLimit, limit);
}

PMDresult PMDGetMotorLimit(PMDAxisHandle* axis_handle, PMDuint16* limit)
{
    f17a:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetMotorLimit, limit);
    f17c:	67 e0       	ldi	r22, 0x07	; 7
    f17e:	70 e0       	ldi	r23, 0x00	; 0
    f180:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f184:	08 95       	ret

0000f186 <PMDGetLimitSwitchMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetLimitSwitchMode, mode);
}

PMDresult PMDGetLimitSwitchMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    f186:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetLimitSwitchMode, mode);
    f188:	61 e8       	ldi	r22, 0x81	; 129
    f18a:	70 e0       	ldi	r23, 0x00	; 0
    f18c:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f190:	08 95       	ret

0000f192 <PMDGetKout>:
{
	return SendCommandWord(axis_handle, PMDOPSetKout, kout);
}

PMDresult PMDGetKout(PMDAxisHandle* axis_handle, PMDuint16* kout)
{
    f192:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKout, kout);
    f194:	6f e9       	ldi	r22, 0x9F	; 159
    f196:	70 e0       	ldi	r23, 0x00	; 0
    f198:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f19c:	08 95       	ret

0000f19e <PMDGetKaff>:
{
	return SendCommandWord(axis_handle, PMDOPSetKaff, kaff);
}

PMDresult PMDGetKaff(PMDAxisHandle* axis_handle, PMDuint16* kaff)
{
    f19e:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKaff, kaff);
    f1a0:	64 e9       	ldi	r22, 0x94	; 148
    f1a2:	70 e0       	ldi	r23, 0x00	; 0
    f1a4:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f1a8:	08 95       	ret

0000f1aa <PMDGetKvff>:
{
	return SendCommandWord(axis_handle, PMDOPSetKvff, kvff);
}

PMDresult PMDGetKvff(PMDAxisHandle* axis_handle, PMDuint16* kvff)
{
    f1aa:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKvff, kvff);
    f1ac:	64 e5       	ldi	r22, 0x54	; 84
    f1ae:	70 e0       	ldi	r23, 0x00	; 0
    f1b0:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f1b4:	08 95       	ret

0000f1b6 <PMDGetKi>:
{
	return SendCommandWord(axis_handle, PMDOPSetKi, ki);
}

PMDresult PMDGetKi(PMDAxisHandle* axis_handle, PMDuint16* ki)
{
    f1b6:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKi, ki);
    f1b8:	61 e5       	ldi	r22, 0x51	; 81
    f1ba:	70 e0       	ldi	r23, 0x00	; 0
    f1bc:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f1c0:	08 95       	ret

0000f1c2 <PMDGetKd>:
{
	return SendCommandWord(axis_handle, PMDOPSetKd, kd);
}

PMDresult PMDGetKd(PMDAxisHandle* axis_handle, PMDuint16* kd)
{
    f1c2:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKd, kd);
    f1c4:	62 e5       	ldi	r22, 0x52	; 82
    f1c6:	70 e0       	ldi	r23, 0x00	; 0
    f1c8:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f1cc:	08 95       	ret

0000f1ce <PMDGetKp>:
{
	return SendCommandWord(axis_handle, PMDOPSetKp, kp);
}

PMDresult PMDGetKp(PMDAxisHandle* axis_handle, PMDuint16* kp)
{
    f1ce:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetKp, kp);
    f1d0:	60 e5       	ldi	r22, 0x50	; 80
    f1d2:	70 e0       	ldi	r23, 0x00	; 0
    f1d4:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f1d8:	08 95       	ret

0000f1da <PMDGetStopMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetStopMode, mode);
}

PMDresult PMDGetStopMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    f1da:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetStopMode, mode);
    f1dc:	61 ed       	ldi	r22, 0xD1	; 209
    f1de:	70 e0       	ldi	r23, 0x00	; 0
    f1e0:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f1e4:	08 95       	ret

0000f1e6 <PMDGetGearMaster>:
	PMDuint16 value = (PMDuint16)((masterAxis & nibbleMask) | ((source & nibbleMask) << 8));
	return SendCommandWord(axis_handle, PMDOPSetGearMaster, value);
}

PMDresult PMDGetGearMaster(PMDAxisHandle* axis_handle, PMDAxis* masterAxis, PMDuint8* source)
{
    f1e6:	ef 92       	push	r14
    f1e8:	ff 92       	push	r15
    f1ea:	0f 93       	push	r16
    f1ec:	1f 93       	push	r17
    f1ee:	df 93       	push	r29
    f1f0:	cf 93       	push	r28
    f1f2:	00 d0       	rcall	.+0      	; 0xf1f4 <PMDGetGearMaster+0xe>
    f1f4:	cd b7       	in	r28, 0x3d	; 61
    f1f6:	de b7       	in	r29, 0x3e	; 62
    f1f8:	8b 01       	movw	r16, r22
    f1fa:	7a 01       	movw	r14, r20
	PMDuint16 result;
	PMDuint16 value;

	result = SendCommandGetWord(axis_handle, PMDOPGetGearMaster, &value);
    f1fc:	6f ea       	ldi	r22, 0xAF	; 175
    f1fe:	70 e0       	ldi	r23, 0x00	; 0
    f200:	ae 01       	movw	r20, r28
    f202:	4f 5f       	subi	r20, 0xFF	; 255
    f204:	5f 4f       	sbci	r21, 0xFF	; 255
    f206:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
	*masterAxis = (PMDAxis)(value & nibbleMask);
    f20a:	29 81       	ldd	r18, Y+1	; 0x01
    f20c:	3a 81       	ldd	r19, Y+2	; 0x02
    f20e:	2f 70       	andi	r18, 0x0F	; 15
    f210:	30 70       	andi	r19, 0x00	; 0
    f212:	f8 01       	movw	r30, r16
    f214:	31 83       	std	Z+1, r19	; 0x01
    f216:	20 83       	st	Z, r18
	*source = (PMDuint8)((value >> 8) & nibbleMask);
    f218:	2a 81       	ldd	r18, Y+2	; 0x02
    f21a:	2f 70       	andi	r18, 0x0F	; 15
    f21c:	f7 01       	movw	r30, r14
    f21e:	20 83       	st	Z, r18

	return result;
}
    f220:	0f 90       	pop	r0
    f222:	0f 90       	pop	r0
    f224:	cf 91       	pop	r28
    f226:	df 91       	pop	r29
    f228:	1f 91       	pop	r17
    f22a:	0f 91       	pop	r16
    f22c:	ff 90       	pop	r15
    f22e:	ef 90       	pop	r14
    f230:	08 95       	ret

0000f232 <PMDGetProfileMode>:
{
	return SendCommandWord(axis_handle, PMDOPSetProfileMode, mode);
}

PMDresult PMDGetProfileMode(PMDAxisHandle* axis_handle, PMDuint16* mode)
{
    f232:	ab 01       	movw	r20, r22
	return SendCommandGetWord(axis_handle, PMDOPGetProfileMode, mode);
    f234:	61 ea       	ldi	r22, 0xA1	; 161
    f236:	70 e0       	ldi	r23, 0x00	; 0
    f238:	0e 94 29 83 	call	0x10652	; 0x10652 <SendCommandGetWord>
}
    f23c:	08 95       	ret

0000f23e <PMDSetSynchronizationMode>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetStepRange, range);
}

PMDresult PMDSetSynchronizationMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f23e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetSynchronizationMode, mode);
    f240:	62 ef       	ldi	r22, 0xF2	; 242
    f242:	70 e0       	ldi	r23, 0x00	; 0
    f244:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f248:	08 95       	ret

0000f24a <PMDSetStepRange>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetChecksum, checksum);
}

PMDresult PMDSetStepRange(PMDAxisHandle* axis_handle, PMDuint16 range)
{
    f24a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetStepRange, range);
    f24c:	6f ec       	ldi	r22, 0xCF	; 207
    f24e:	70 e0       	ldi	r23, 0x00	; 0
    f250:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f254:	08 95       	ret

0000f256 <PMDSetDiagnosticPortMode>:

	return result;
}

PMDresult PMDSetDiagnosticPortMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f256:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetDiagnosticPortMode, mode);
    f258:	69 e8       	ldi	r22, 0x89	; 137
    f25a:	70 e0       	ldi	r23, 0x00	; 0
    f25c:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f260:	08 95       	ret

0000f262 <PMDSetSerialPortMode>:
	return SendCommandGetWord(axis_handle, PMDOPGetHostIOError, hostIOError);
}

PMDresult PMDSetSerialPortMode(PMDAxisHandle* axis_handle, PMDuint8 baud, PMDuint8 parity, 
					PMDuint8 stopBits, PMDuint8 protocol, PMDuint8 multiDropID)
{
    f262:	ef 92       	push	r14
    f264:	0f 93       	push	r16
    f266:	1f 93       	push	r17

	serialData = (PMDuint16)(baud | (parity << 4) | (stopBits << 6) | 
		(protocol << 7) | 
		// bits 9 and 10 are resereved for future use
		(multiDropID << 11));
	return SendCommandWord(axis_handle, PMDOPSetSerialPortMode, serialData);
    f268:	50 e0       	ldi	r21, 0x00	; 0
    f26a:	74 e0       	ldi	r23, 0x04	; 4
    f26c:	44 0f       	add	r20, r20
    f26e:	55 1f       	adc	r21, r21
    f270:	7a 95       	dec	r23
    f272:	e1 f7       	brne	.-8      	; 0xf26c <PMDSetSerialPortMode+0xa>
    f274:	70 e0       	ldi	r23, 0x00	; 0
    f276:	46 2b       	or	r20, r22
    f278:	57 2b       	or	r21, r23
    f27a:	30 e0       	ldi	r19, 0x00	; 0
    f27c:	66 e0       	ldi	r22, 0x06	; 6
    f27e:	22 0f       	add	r18, r18
    f280:	33 1f       	adc	r19, r19
    f282:	6a 95       	dec	r22
    f284:	e1 f7       	brne	.-8      	; 0xf27e <PMDSetSerialPortMode+0x1c>
    f286:	42 2b       	or	r20, r18
    f288:	53 2b       	or	r21, r19
    f28a:	10 e0       	ldi	r17, 0x00	; 0
    f28c:	16 95       	lsr	r17
    f28e:	10 2f       	mov	r17, r16
    f290:	00 27       	eor	r16, r16
    f292:	17 95       	ror	r17
    f294:	07 95       	ror	r16
    f296:	40 2b       	or	r20, r16
    f298:	51 2b       	or	r21, r17
    f29a:	3e 2d       	mov	r19, r14
    f29c:	33 0f       	add	r19, r19
    f29e:	33 0f       	add	r19, r19
    f2a0:	33 0f       	add	r19, r19
    f2a2:	20 e0       	ldi	r18, 0x00	; 0
    f2a4:	42 2b       	or	r20, r18
    f2a6:	53 2b       	or	r21, r19
    f2a8:	6b e8       	ldi	r22, 0x8B	; 139
    f2aa:	70 e0       	ldi	r23, 0x00	; 0
    f2ac:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f2b0:	1f 91       	pop	r17
    f2b2:	0f 91       	pop	r16
    f2b4:	ef 90       	pop	r14
    f2b6:	08 95       	ret

0000f2b8 <PMDSetAxisOutSource>:
PMDresult PMDSetAxisOutSource(PMDAxisHandle* axis_handle, PMDAxis sourceAxis, PMDuint8 bit, PMDuint8 sourceRegister)
{
	PMDuint16 value = (PMDuint16)((sourceAxis & nibbleMask) | ((bit & nibbleMask) << 4) 
		| ((sourceRegister & nibbleMask) << 8));
		
	return SendCommandWord(axis_handle, PMDOPSetAxisOutSource, value);
    f2b8:	50 e0       	ldi	r21, 0x00	; 0
    f2ba:	f4 e0       	ldi	r31, 0x04	; 4
    f2bc:	44 0f       	add	r20, r20
    f2be:	55 1f       	adc	r21, r21
    f2c0:	fa 95       	dec	r31
    f2c2:	e1 f7       	brne	.-8      	; 0xf2bc <PMDSetAxisOutSource+0x4>
    f2c4:	50 70       	andi	r21, 0x00	; 0
    f2c6:	6f 70       	andi	r22, 0x0F	; 15
    f2c8:	70 70       	andi	r23, 0x00	; 0
    f2ca:	46 2b       	or	r20, r22
    f2cc:	57 2b       	or	r21, r23
    f2ce:	30 e0       	ldi	r19, 0x00	; 0
    f2d0:	2f 70       	andi	r18, 0x0F	; 15
    f2d2:	30 70       	andi	r19, 0x00	; 0
    f2d4:	32 2f       	mov	r19, r18
    f2d6:	22 27       	eor	r18, r18
    f2d8:	42 2b       	or	r20, r18
    f2da:	53 2b       	or	r21, r19
    f2dc:	6d ee       	ldi	r22, 0xED	; 237
    f2de:	70 e0       	ldi	r23, 0x00	; 0
    f2e0:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f2e4:	08 95       	ret

0000f2e6 <PMDSetAxisMode>:
}


// Miscellaneous
PMDresult PMDSetAxisMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f2e6:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetAxisMode, mode);
    f2e8:	67 e8       	ldi	r22, 0x87	; 135
    f2ea:	70 e0       	ldi	r23, 0x00	; 0
    f2ec:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f2f0:	08 95       	ret

0000f2f2 <PMDSetTraceStop>:

	return result;
}

PMDresult PMDSetTraceStop(PMDAxisHandle* axis_handle, PMDAxis traceAxis, PMDuint8 condition, PMDuint8 bit, PMDuint8 state)
{
    f2f2:	0f 93       	push	r16
    f2f4:	1f 93       	push	r17
    f2f6:	cf 93       	push	r28
    f2f8:	df 93       	push	r29
    f2fa:	ec 01       	movw	r28, r24
    f2fc:	82 2f       	mov	r24, r18
    f2fe:	50 2f       	mov	r21, r16
	PMDuint16 value = (PMDuint16)((traceAxis & nibbleMask) | ((condition & nibbleMask) << 4));
    f300:	e4 2f       	mov	r30, r20
    f302:	f0 e0       	ldi	r31, 0x00	; 0
    f304:	b4 e0       	ldi	r27, 0x04	; 4
    f306:	ee 0f       	add	r30, r30
    f308:	ff 1f       	adc	r31, r31
    f30a:	ba 95       	dec	r27
    f30c:	e1 f7       	brne	.-8      	; 0xf306 <PMDSetTraceStop+0x14>
    f30e:	f0 70       	andi	r31, 0x00	; 0
    f310:	6f 70       	andi	r22, 0x0F	; 15
    f312:	70 70       	andi	r23, 0x00	; 0
    f314:	e6 2b       	or	r30, r22
    f316:	f7 2b       	or	r31, r23
	PMDAxis axis = axis_handle->axis;
    f318:	0a 81       	ldd	r16, Y+2	; 0x02
    f31a:	1b 81       	ldd	r17, Y+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    f31c:	1b 82       	std	Y+3, r1	; 0x03
    f31e:	1a 82       	std	Y+2, r1	; 0x02
	
	switch(condition)
    f320:	42 50       	subi	r20, 0x02	; 2
    f322:	43 30       	cpi	r20, 0x03	; 3
    f324:	68 f4       	brcc	.+26     	; 0xf340 <PMDSetTraceStop+0x4e>
	{
	case PMDTraceConditionEventStatus:
	case PMDTraceConditionActivityStatus:
	case PMDTraceConditionSignalStatus:
		value |= ((bit & nibbleMask) << 8) | ((state & nibbleMask) << 12);
    f326:	35 2f       	mov	r19, r21
    f328:	32 95       	swap	r19
    f32a:	30 7f       	andi	r19, 0xF0	; 240
    f32c:	20 e0       	ldi	r18, 0x00	; 0
    f32e:	90 e0       	ldi	r25, 0x00	; 0
    f330:	8f 70       	andi	r24, 0x0F	; 15
    f332:	90 70       	andi	r25, 0x00	; 0
    f334:	98 2f       	mov	r25, r24
    f336:	88 27       	eor	r24, r24
    f338:	28 2b       	or	r18, r24
    f33a:	39 2b       	or	r19, r25
    f33c:	e2 2b       	or	r30, r18
    f33e:	f3 2b       	or	r31, r19
		break;
	default:
		break;
	}
	result = SendCommandWord(axis_handle, PMDOPSetTraceStop, value);
    f340:	ce 01       	movw	r24, r28
    f342:	64 eb       	ldi	r22, 0xB4	; 180
    f344:	70 e0       	ldi	r23, 0x00	; 0
    f346:	af 01       	movw	r20, r30
    f348:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>

	axis_handle->axis = axis;
    f34c:	1b 83       	std	Y+3, r17	; 0x03
    f34e:	0a 83       	std	Y+2, r16	; 0x02

	return result;
}
    f350:	df 91       	pop	r29
    f352:	cf 91       	pop	r28
    f354:	1f 91       	pop	r17
    f356:	0f 91       	pop	r16
    f358:	08 95       	ret

0000f35a <PMDSetTraceStart>:

	return result;
}

PMDresult PMDSetTraceStart(PMDAxisHandle* axis_handle, PMDAxis traceAxis, PMDuint8 condition, PMDuint8 bit, PMDuint8 state)
{
    f35a:	0f 93       	push	r16
    f35c:	1f 93       	push	r17
    f35e:	cf 93       	push	r28
    f360:	df 93       	push	r29
    f362:	ec 01       	movw	r28, r24
    f364:	82 2f       	mov	r24, r18
    f366:	50 2f       	mov	r21, r16
	PMDuint16 value = (PMDuint16)((traceAxis & nibbleMask) | ((condition & nibbleMask) << 4));
    f368:	e4 2f       	mov	r30, r20
    f36a:	f0 e0       	ldi	r31, 0x00	; 0
    f36c:	a4 e0       	ldi	r26, 0x04	; 4
    f36e:	ee 0f       	add	r30, r30
    f370:	ff 1f       	adc	r31, r31
    f372:	aa 95       	dec	r26
    f374:	e1 f7       	brne	.-8      	; 0xf36e <PMDSetTraceStart+0x14>
    f376:	f0 70       	andi	r31, 0x00	; 0
    f378:	6f 70       	andi	r22, 0x0F	; 15
    f37a:	70 70       	andi	r23, 0x00	; 0
    f37c:	e6 2b       	or	r30, r22
    f37e:	f7 2b       	or	r31, r23
	PMDAxis axis = axis_handle->axis;
    f380:	0a 81       	ldd	r16, Y+2	; 0x02
    f382:	1b 81       	ldd	r17, Y+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    f384:	1b 82       	std	Y+3, r1	; 0x03
    f386:	1a 82       	std	Y+2, r1	; 0x02
	
	switch(condition)
    f388:	42 50       	subi	r20, 0x02	; 2
    f38a:	43 30       	cpi	r20, 0x03	; 3
    f38c:	68 f4       	brcc	.+26     	; 0xf3a8 <PMDSetTraceStart+0x4e>
	{
	case PMDTraceConditionEventStatus:
	case PMDTraceConditionActivityStatus:
	case PMDTraceConditionSignalStatus:
		value |= ((bit & nibbleMask) << 8) | ((state & nibbleMask) << 12);
    f38e:	35 2f       	mov	r19, r21
    f390:	32 95       	swap	r19
    f392:	30 7f       	andi	r19, 0xF0	; 240
    f394:	20 e0       	ldi	r18, 0x00	; 0
    f396:	90 e0       	ldi	r25, 0x00	; 0
    f398:	8f 70       	andi	r24, 0x0F	; 15
    f39a:	90 70       	andi	r25, 0x00	; 0
    f39c:	98 2f       	mov	r25, r24
    f39e:	88 27       	eor	r24, r24
    f3a0:	28 2b       	or	r18, r24
    f3a2:	39 2b       	or	r19, r25
    f3a4:	e2 2b       	or	r30, r18
    f3a6:	f3 2b       	or	r31, r19
		break;
	default:
		break;
	}
	result = SendCommandWord(axis_handle, PMDOPSetTraceStart, value);
    f3a8:	ce 01       	movw	r24, r28
    f3aa:	62 eb       	ldi	r22, 0xB2	; 178
    f3ac:	70 e0       	ldi	r23, 0x00	; 0
    f3ae:	af 01       	movw	r20, r30
    f3b0:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>

	axis_handle->axis = axis;
    f3b4:	1b 83       	std	Y+3, r17	; 0x03
    f3b6:	0a 83       	std	Y+2, r16	; 0x02

	return result;
}
    f3b8:	df 91       	pop	r29
    f3ba:	cf 91       	pop	r28
    f3bc:	1f 91       	pop	r17
    f3be:	0f 91       	pop	r16
    f3c0:	08 95       	ret

0000f3c2 <PMDSetTracePeriod>:

	return result;
}

PMDresult PMDSetTracePeriod(PMDAxisHandle* axis_handle, PMDuint16 tracePeriod)
{
    f3c2:	ef 92       	push	r14
    f3c4:	ff 92       	push	r15
    f3c6:	0f 93       	push	r16
    f3c8:	1f 93       	push	r17
    f3ca:	8c 01       	movw	r16, r24
    f3cc:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    f3ce:	fc 01       	movw	r30, r24
    f3d0:	e2 80       	ldd	r14, Z+2	; 0x02
    f3d2:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    f3d4:	13 82       	std	Z+3, r1	; 0x03
    f3d6:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandWord(axis_handle, PMDOPSetTracePeriod, tracePeriod);
    f3d8:	68 eb       	ldi	r22, 0xB8	; 184
    f3da:	70 e0       	ldi	r23, 0x00	; 0
    f3dc:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>

	axis_handle->axis = axis;
    f3e0:	f8 01       	movw	r30, r16
    f3e2:	f3 82       	std	Z+3, r15	; 0x03
    f3e4:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    f3e6:	1f 91       	pop	r17
    f3e8:	0f 91       	pop	r16
    f3ea:	ff 90       	pop	r15
    f3ec:	ef 90       	pop	r14
    f3ee:	08 95       	ret

0000f3f0 <PMDSetTraceMode>:
}


// Trace Operations
PMDresult PMDSetTraceMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f3f0:	ef 92       	push	r14
    f3f2:	ff 92       	push	r15
    f3f4:	0f 93       	push	r16
    f3f6:	1f 93       	push	r17
    f3f8:	8c 01       	movw	r16, r24
    f3fa:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    f3fc:	fc 01       	movw	r30, r24
    f3fe:	e2 80       	ldd	r14, Z+2	; 0x02
    f400:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    f402:	13 82       	std	Z+3, r1	; 0x03
    f404:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandWord(axis_handle, PMDOPSetTraceMode, mode);
    f406:	60 eb       	ldi	r22, 0xB0	; 176
    f408:	70 e0       	ldi	r23, 0x00	; 0
    f40a:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>

	axis_handle->axis = axis;
    f40e:	f8 01       	movw	r30, r16
    f410:	f3 82       	std	Z+3, r15	; 0x03
    f412:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    f414:	1f 91       	pop	r17
    f416:	0f 91       	pop	r16
    f418:	ff 90       	pop	r15
    f41a:	ef 90       	pop	r14
    f41c:	08 95       	ret

0000f41e <PMDSetPhaseCorrectionMode>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseAngle, phaseAngle);
}

PMDresult PMDSetPhaseCorrectionMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f41e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseCorrectionMode, mode);
    f420:	68 ee       	ldi	r22, 0xE8	; 232
    f422:	70 e0       	ldi	r23, 0x00	; 0
    f424:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f428:	08 95       	ret

0000f42a <PMDSetPhaseAngle>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseOffset, phaseOffset);
}

PMDresult PMDSetPhaseAngle(PMDAxisHandle* axis_handle, PMDuint16 phaseAngle)
{
    f42a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseAngle, phaseAngle);
    f42c:	64 e8       	ldi	r22, 0x84	; 132
    f42e:	70 e0       	ldi	r23, 0x00	; 0
    f430:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f434:	08 95       	ret

0000f436 <PMDSetPhaseOffset>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseInitializeTime, phaseInitTime);
}

PMDresult PMDSetPhaseOffset(PMDAxisHandle* axis_handle, PMDuint16 phaseOffset)
{
    f436:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseOffset, phaseOffset);
    f438:	66 e7       	ldi	r22, 0x76	; 118
    f43a:	70 e0       	ldi	r23, 0x00	; 0
    f43c:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f440:	08 95       	ret

0000f442 <PMDSetPhaseInitializeTime>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseCounts, phaseCounts);
}

PMDresult PMDSetPhaseInitializeTime(PMDAxisHandle* axis_handle, PMDuint16 phaseInitTime)
{
    f442:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseInitializeTime, phaseInitTime);
    f444:	62 e7       	ldi	r22, 0x72	; 114
    f446:	70 e0       	ldi	r23, 0x00	; 0
    f448:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f44c:	08 95       	ret

0000f44e <PMDSetPhaseCounts>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhasePrescale, phasePrescale);
}

PMDresult PMDSetPhaseCounts(PMDAxisHandle* axis_handle, PMDuint16 phaseCounts)
{
    f44e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseCounts, phaseCounts);
    f450:	65 e7       	ldi	r22, 0x75	; 117
    f452:	70 e0       	ldi	r23, 0x00	; 0
    f454:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f458:	08 95       	ret

0000f45a <PMDSetPhasePrescale>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseInitializeMode, mode);
}

PMDresult PMDSetPhasePrescale(PMDAxisHandle* axis_handle, PMDuint16 phasePrescale)
{
    f45a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhasePrescale, phasePrescale);
    f45c:	66 ee       	ldi	r22, 0xE6	; 230
    f45e:	70 e0       	ldi	r23, 0x00	; 0
    f460:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f464:	08 95       	ret

0000f466 <PMDSetPhaseInitializeMode>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetNumberPhases, numberPhases);
}

PMDresult PMDSetPhaseInitializeMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f466:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetPhaseInitializeMode, mode);
    f468:	64 ee       	ldi	r22, 0xE4	; 228
    f46a:	70 e0       	ldi	r23, 0x00	; 0
    f46c:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f470:	08 95       	ret

0000f472 <PMDSetNumberPhases>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetCommutationMode, mode);
}

PMDresult PMDSetNumberPhases(PMDAxisHandle* axis_handle, PMDuint16 numberPhases)
{
    f472:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetNumberPhases, numberPhases);
    f474:	65 e8       	ldi	r22, 0x85	; 133
    f476:	70 e0       	ldi	r23, 0x00	; 0
    f478:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f47c:	08 95       	ret

0000f47e <PMDSetCommutationMode>:
}


// Commutation
PMDresult PMDSetCommutationMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f47e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetCommutationMode, mode);
    f480:	62 ee       	ldi	r22, 0xE2	; 226
    f482:	70 e0       	ldi	r23, 0x00	; 0
    f484:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f488:	08 95       	ret

0000f48a <PMDSetMotorCommand>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetMotorMode, mode);
}

PMDresult PMDSetMotorCommand(PMDAxisHandle* axis_handle, PMDint16 motorCommand)
{
    f48a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetMotorCommand, (PMDuint16)motorCommand);
    f48c:	67 e7       	ldi	r22, 0x77	; 119
    f48e:	70 e0       	ldi	r23, 0x00	; 0
    f490:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f494:	08 95       	ret

0000f496 <PMDSetMotorMode>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetOutputMode, mode);
}

PMDresult PMDSetMotorMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f496:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetMotorMode, mode);
    f498:	6c ed       	ldi	r22, 0xDC	; 220
    f49a:	70 e0       	ldi	r23, 0x00	; 0
    f49c:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f4a0:	08 95       	ret

0000f4a2 <PMDSetOutputMode>:
}


// Motor
PMDresult PMDSetOutputMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f4a2:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetOutputMode, mode);
    f4a4:	60 ee       	ldi	r22, 0xE0	; 224
    f4a6:	70 e0       	ldi	r23, 0x00	; 0
    f4a8:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f4ac:	08 95       	ret

0000f4ae <PMDSetEncoderModulus>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetEncoderSource, encoderSource);
}

PMDresult PMDSetEncoderModulus(PMDAxisHandle* axis_handle, PMDuint16 modulus)
{
    f4ae:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetEncoderModulus, modulus);
    f4b0:	6d e8       	ldi	r22, 0x8D	; 141
    f4b2:	70 e0       	ldi	r23, 0x00	; 0
    f4b4:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f4b8:	08 95       	ret

0000f4ba <PMDSetEncoderSource>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetCaptureSource, captureSource);
}

PMDresult PMDSetEncoderSource(PMDAxisHandle* axis_handle, PMDuint16 encoderSource)
{
    f4ba:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetEncoderSource, encoderSource);
    f4bc:	6a ed       	ldi	r22, 0xDA	; 218
    f4be:	70 e0       	ldi	r23, 0x00	; 0
    f4c0:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f4c4:	08 95       	ret

0000f4c6 <PMDSetCaptureSource>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetActualPositionUnits, mode);
}

PMDresult PMDSetCaptureSource(PMDAxisHandle* axis_handle, PMDuint16 captureSource)
{
    f4c6:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetCaptureSource, captureSource);
    f4c8:	68 ed       	ldi	r22, 0xD8	; 216
    f4ca:	70 e0       	ldi	r23, 0x00	; 0
    f4cc:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f4d0:	08 95       	ret

0000f4d2 <PMDSetActualPositionUnits>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetActualPosition, (PMDuint32*)position);
}

PMDresult PMDSetActualPositionUnits(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f4d2:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetActualPositionUnits, mode);
    f4d4:	6e eb       	ldi	r22, 0xBE	; 190
    f4d6:	70 e0       	ldi	r23, 0x00	; 0
    f4d8:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f4dc:	08 95       	ret

0000f4de <PMDSetSignalSense>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetActivityStatus, activityStatus);
}

PMDresult PMDSetSignalSense(PMDAxisHandle* axis_handle, PMDuint16 mask)
{
    f4de:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetSignalSense, mask);
    f4e0:	62 ea       	ldi	r22, 0xA2	; 162
    f4e2:	70 e0       	ldi	r23, 0x00	; 0
    f4e4:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f4e8:	08 95       	ret

0000f4ea <PMDResetEventStatus>:
}


// Status Register Control
PMDresult PMDResetEventStatus(PMDAxisHandle* axis_handle, PMDuint16 eventStatus)
{
    f4ea:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPResetEventStatus, eventStatus);
    f4ec:	64 e3       	ldi	r22, 0x34	; 52
    f4ee:	70 e0       	ldi	r23, 0x00	; 0
    f4f0:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f4f4:	08 95       	ret

0000f4f6 <PMDSetInterruptMask>:
}


// Interrupt Processing
PMDresult PMDSetInterruptMask(PMDAxisHandle* axis_handle, PMDuint16 interruptMask)
{
    f4f6:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetInterruptMask, interruptMask);
    f4f8:	6f e2       	ldi	r22, 0x2F	; 47
    f4fa:	70 e0       	ldi	r23, 0x00	; 0
    f4fc:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f500:	08 95       	ret

0000f502 <PMDMultiUpdate>:
{
	return SendCommand(axis_handle, PMDOPUpdate);
}

PMDresult PMDMultiUpdate(PMDAxisHandle* axis_handle, PMDuint16 axisMask)
{
    f502:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPMultiUpdate, axisMask);
    f504:	6b e5       	ldi	r22, 0x5B	; 91
    f506:	70 e0       	ldi	r23, 0x00	; 0
    f508:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f50c:	08 95       	ret

0000f50e <PMDSetSampleTime>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetPositionError, (PMDuint32*)error);
}

PMDresult PMDSetSampleTime(PMDAxisHandle* axis_handle, PMDuint16 sampleTime)
{
    f50e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetSampleTime, sampleTime);
    f510:	68 e3       	ldi	r22, 0x38	; 56
    f512:	70 e0       	ldi	r23, 0x00	; 0
    f514:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f518:	08 95       	ret

0000f51a <PMDSetMotionCompleteMode>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetTrackingWindow, trackingWindow);
}

PMDresult PMDSetMotionCompleteMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f51a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetMotionCompleteMode, mode);
    f51c:	6b ee       	ldi	r22, 0xEB	; 235
    f51e:	70 e0       	ldi	r23, 0x00	; 0
    f520:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f524:	08 95       	ret

0000f526 <PMDSetTrackingWindow>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetSettleWindow, settleWindow);
}

PMDresult PMDSetTrackingWindow(PMDAxisHandle* axis_handle, PMDuint16 trackingWindow)
{
    f526:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetTrackingWindow, trackingWindow);
    f528:	68 ea       	ldi	r22, 0xA8	; 168
    f52a:	70 e0       	ldi	r23, 0x00	; 0
    f52c:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f530:	08 95       	ret

0000f532 <PMDSetSettleWindow>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetSettleTime, settleTime);
}

PMDresult PMDSetSettleWindow(PMDAxisHandle* axis_handle, PMDuint16 settleWindow)
{
    f532:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetSettleWindow, settleWindow);
    f534:	6c eb       	ldi	r22, 0xBC	; 188
    f536:	70 e0       	ldi	r23, 0x00	; 0
    f538:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f53c:	08 95       	ret

0000f53e <PMDSetSettleTime>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetDerivativeTime, derivativeTime);
}

PMDresult PMDSetSettleTime(PMDAxisHandle* axis_handle, PMDuint16 settleTime)
{
    f53e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetSettleTime, settleTime);
    f540:	6a ea       	ldi	r22, 0xAA	; 170
    f542:	70 e0       	ldi	r23, 0x00	; 0
    f544:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f548:	08 95       	ret

0000f54a <PMDSetDerivativeTime>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetAutoStopMode, mode);
}

PMDresult PMDSetDerivativeTime(PMDAxisHandle* axis_handle, PMDuint16 derivativeTime)
{
    f54a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetDerivativeTime, derivativeTime);
    f54c:	6c e9       	ldi	r22, 0x9C	; 156
    f54e:	70 e0       	ldi	r23, 0x00	; 0
    f550:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f554:	08 95       	ret

0000f556 <PMDSetAutoStopMode>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetPositionErrorLimit, limit);
}

PMDresult PMDSetAutoStopMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f556:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetAutoStopMode, mode);
    f558:	62 ed       	ldi	r22, 0xD2	; 210
    f55a:	70 e0       	ldi	r23, 0x00	; 0
    f55c:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f560:	08 95       	ret

0000f562 <PMDSetMotorBias>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetMotorLimit, limit);
}

PMDresult PMDSetMotorBias(PMDAxisHandle* axis_handle, PMDint16 bias)
{
    f562:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetMotorBias, (PMDuint16)bias);
    f564:	6f e0       	ldi	r22, 0x0F	; 15
    f566:	70 e0       	ldi	r23, 0x00	; 0
    f568:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f56c:	08 95       	ret

0000f56e <PMDSetMotorLimit>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetLimitSwitchMode, mode);
}

PMDresult PMDSetMotorLimit(PMDAxisHandle* axis_handle, PMDuint16 limit)
{
    f56e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetMotorLimit, limit);
    f570:	66 e0       	ldi	r22, 0x06	; 6
    f572:	70 e0       	ldi	r23, 0x00	; 0
    f574:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f578:	08 95       	ret

0000f57a <PMDSetLimitSwitchMode>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetIntegrationLimit, limit);
}

PMDresult PMDSetLimitSwitchMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f57a:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetLimitSwitchMode, mode);
    f57c:	60 e8       	ldi	r22, 0x80	; 128
    f57e:	70 e0       	ldi	r23, 0x00	; 0
    f580:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f584:	08 95       	ret

0000f586 <PMDSetKout>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKaff, kaff);
}

PMDresult PMDSetKout(PMDAxisHandle* axis_handle, PMDuint16 kout)
{
    f586:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKout, kout);
    f588:	6e e9       	ldi	r22, 0x9E	; 158
    f58a:	70 e0       	ldi	r23, 0x00	; 0
    f58c:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f590:	08 95       	ret

0000f592 <PMDSetKaff>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKvff, kvff);
}

PMDresult PMDSetKaff(PMDAxisHandle* axis_handle, PMDuint16 kaff)
{
    f592:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKaff, kaff);
    f594:	63 e9       	ldi	r22, 0x93	; 147
    f596:	70 e0       	ldi	r23, 0x00	; 0
    f598:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f59c:	08 95       	ret

0000f59e <PMDSetKvff>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKi, ki);
}

PMDresult PMDSetKvff(PMDAxisHandle* axis_handle, PMDuint16 kvff)
{
    f59e:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKvff, kvff);
    f5a0:	6b e2       	ldi	r22, 0x2B	; 43
    f5a2:	70 e0       	ldi	r23, 0x00	; 0
    f5a4:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f5a8:	08 95       	ret

0000f5aa <PMDSetKi>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKd, kd);
}

PMDresult PMDSetKi(PMDAxisHandle* axis_handle, PMDuint16 ki)
{
    f5aa:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKi, ki);
    f5ac:	66 e2       	ldi	r22, 0x26	; 38
    f5ae:	70 e0       	ldi	r23, 0x00	; 0
    f5b0:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f5b4:	08 95       	ret

0000f5b6 <PMDSetKd>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKp, kp);
}

PMDresult PMDSetKd(PMDAxisHandle* axis_handle, PMDuint16 kd)
{
    f5b6:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKd, kd);
    f5b8:	67 e2       	ldi	r22, 0x27	; 39
    f5ba:	70 e0       	ldi	r23, 0x00	; 0
    f5bc:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f5c0:	08 95       	ret

0000f5c2 <PMDSetKp>:
}


// Servo Filter
PMDresult PMDSetKp(PMDAxisHandle* axis_handle, PMDuint16 kp)
{
    f5c2:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetKp, kp);
    f5c4:	65 e2       	ldi	r22, 0x25	; 37
    f5c6:	70 e0       	ldi	r23, 0x00	; 0
    f5c8:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f5cc:	08 95       	ret

0000f5ce <PMDSetStopMode>:

	return result;
}

PMDresult PMDSetStopMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f5ce:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetStopMode, mode);
    f5d0:	60 ed       	ldi	r22, 0xD0	; 208
    f5d2:	70 e0       	ldi	r23, 0x00	; 0
    f5d4:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f5d8:	08 95       	ret

0000f5da <PMDSetGearMaster>:
}

PMDresult PMDSetGearMaster(PMDAxisHandle* axis_handle, PMDAxis masterAxis, PMDuint8 source)
{
	PMDuint16 value = (PMDuint16)((masterAxis & nibbleMask) | ((source & nibbleMask) << 8));
	return SendCommandWord(axis_handle, PMDOPSetGearMaster, value);
    f5da:	50 e0       	ldi	r21, 0x00	; 0
    f5dc:	4f 70       	andi	r20, 0x0F	; 15
    f5de:	50 70       	andi	r21, 0x00	; 0
    f5e0:	54 2f       	mov	r21, r20
    f5e2:	44 27       	eor	r20, r20
    f5e4:	6f 70       	andi	r22, 0x0F	; 15
    f5e6:	70 70       	andi	r23, 0x00	; 0
    f5e8:	46 2b       	or	r20, r22
    f5ea:	57 2b       	or	r21, r23
    f5ec:	6e ea       	ldi	r22, 0xAE	; 174
    f5ee:	70 e0       	ldi	r23, 0x00	; 0
    f5f0:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f5f4:	08 95       	ret

0000f5f6 <PMDSetProfileMode>:



// Profile Generation
PMDresult PMDSetProfileMode(PMDAxisHandle* axis_handle, PMDuint16 mode)
{
    f5f6:	ab 01       	movw	r20, r22
	return SendCommandWord(axis_handle, PMDOPSetProfileMode, mode);
    f5f8:	60 ea       	ldi	r22, 0xA0	; 160
    f5fa:	70 e0       	ldi	r23, 0x00	; 0
    f5fc:	0e 94 52 82 	call	0x104a4	; 0x104a4 <SendCommandWord>
}
    f600:	08 95       	ret

0000f602 <PMDGetChecksum>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetTime, numberChipCycles);
}

PMDresult PMDGetChecksum(PMDAxisHandle* axis_handle, PMDuint32* checksum)
{
    f602:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetChecksum, checksum);
    f604:	68 ef       	ldi	r22, 0xF8	; 248
    f606:	70 e0       	ldi	r23, 0x00	; 0
    f608:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f60c:	08 95       	ret

0000f60e <PMDGetTime>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetDiagnosticPortMode, mode);
}

PMDresult PMDGetTime(PMDAxisHandle* axis_handle, PMDuint32* numberChipCycles)
{
    f60e:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetTime, numberChipCycles);
    f610:	6e e3       	ldi	r22, 0x3E	; 62
    f612:	70 e0       	ldi	r23, 0x00	; 0
    f614:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f618:	08 95       	ret

0000f61a <PMDGetTraceCount>:

	return result;
}

PMDresult PMDGetTraceCount(PMDAxisHandle* axis_handle, PMDuint32* count)
{
    f61a:	ef 92       	push	r14
    f61c:	ff 92       	push	r15
    f61e:	0f 93       	push	r16
    f620:	1f 93       	push	r17
    f622:	8c 01       	movw	r16, r24
    f624:	ab 01       	movw	r20, r22
	PMDAxis axis = axis_handle->axis;
    f626:	fc 01       	movw	r30, r24
    f628:	e2 80       	ldd	r14, Z+2	; 0x02
    f62a:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    f62c:	13 82       	std	Z+3, r1	; 0x03
    f62e:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommandGetLong(axis_handle, PMDOPGetTraceCount, count);
    f630:	6b eb       	ldi	r22, 0xBB	; 187
    f632:	70 e0       	ldi	r23, 0x00	; 0
    f634:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>

	axis_handle->axis = axis;
    f638:	f8 01       	movw	r30, r16
    f63a:	f3 82       	std	Z+3, r15	; 0x03
    f63c:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    f63e:	1f 91       	pop	r17
    f640:	0f 91       	pop	r16
    f642:	ff 90       	pop	r15
    f644:	ef 90       	pop	r14
    f646:	08 95       	ret

0000f648 <PMDGetCaptureValue>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetActualVelocity, (PMDuint32*)actualValue);
}

PMDresult PMDGetCaptureValue(PMDAxisHandle* axis_handle, PMDint32* captureValue)
{
    f648:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetCaptureValue, (PMDuint32*)captureValue);
    f64a:	66 e3       	ldi	r22, 0x36	; 54
    f64c:	70 e0       	ldi	r23, 0x00	; 0
    f64e:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f652:	08 95       	ret

0000f654 <PMDGetActualVelocity>:
{
	return SendCommandGetWordWord(axis_handle, PMDOPGetEncoderToStepRatio, encoderCounts, steps);
}

PMDresult PMDGetActualVelocity(PMDAxisHandle* axis_handle, PMDint32* actualValue)
{
    f654:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetActualVelocity, (PMDuint32*)actualValue);
    f656:	6d ea       	ldi	r22, 0xAD	; 173
    f658:	70 e0       	ldi	r23, 0x00	; 0
    f65a:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f65e:	08 95       	ret

0000f660 <PMDGetActualPosition>:
{
	return SendCommandLong(axis_handle, PMDOPSetActualPosition, (PMDuint32)position);
}

PMDresult PMDGetActualPosition(PMDAxisHandle* axis_handle, PMDint32* position)
{
    f660:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetActualPosition, (PMDuint32*)position);
    f662:	67 e3       	ldi	r22, 0x37	; 55
    f664:	70 e0       	ldi	r23, 0x00	; 0
    f666:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f66a:	08 95       	ret

0000f66c <PMDGetPositionError>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetIntegral, (PMDuint32*)integral);
}

PMDresult PMDGetPositionError(PMDAxisHandle* axis_handle, PMDint32* error)
{
    f66c:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetPositionError, (PMDuint32*)error);
    f66e:	69 e9       	ldi	r22, 0x99	; 153
    f670:	70 e0       	ldi	r23, 0x00	; 0
    f672:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f676:	08 95       	ret

0000f678 <PMDGetIntegral>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetDerivative, (PMDuint16*)derivative);
}

PMDresult PMDGetIntegral(PMDAxisHandle* axis_handle, PMDint32* integral)
{
    f678:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetIntegral, (PMDuint32*)integral);
    f67a:	6a e9       	ldi	r22, 0x9A	; 154
    f67c:	70 e0       	ldi	r23, 0x00	; 0
    f67e:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f682:	08 95       	ret

0000f684 <PMDGetPositionErrorLimit>:
{
	return SendCommandLong(axis_handle, PMDOPSetPositionErrorLimit, limit);
}

PMDresult PMDGetPositionErrorLimit(PMDAxisHandle* axis_handle, PMDuint32* limit)
{
    f684:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetPositionErrorLimit, limit);
    f686:	68 e9       	ldi	r22, 0x98	; 152
    f688:	70 e0       	ldi	r23, 0x00	; 0
    f68a:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f68e:	08 95       	ret

0000f690 <PMDGetIntegrationLimit>:
{
	return SendCommandLong(axis_handle, PMDOPSetIntegrationLimit, limit);
}

PMDresult PMDGetIntegrationLimit(PMDAxisHandle* axis_handle, PMDuint32* limit)
{
    f690:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetIntegrationLimit, limit);
    f692:	66 e9       	ldi	r22, 0x96	; 150
    f694:	70 e0       	ldi	r23, 0x00	; 0
    f696:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f69a:	08 95       	ret

0000f69c <PMDGetCommandedAcceleration>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetCommandedVelocity, (PMDuint32*)velocity);
}

PMDresult PMDGetCommandedAcceleration(PMDAxisHandle* axis_handle, PMDint32 *acceleration)
{
    f69c:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetCommandedAcceleration, (PMDuint32*)acceleration);
    f69e:	67 ea       	ldi	r22, 0xA7	; 167
    f6a0:	70 e0       	ldi	r23, 0x00	; 0
    f6a2:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f6a6:	08 95       	ret

0000f6a8 <PMDGetCommandedVelocity>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetCommandedPosition, (PMDuint32*)position);
}

PMDresult PMDGetCommandedVelocity(PMDAxisHandle* axis_handle, PMDint32* velocity)
{
    f6a8:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetCommandedVelocity, (PMDuint32*)velocity);
    f6aa:	6e e1       	ldi	r22, 0x1E	; 30
    f6ac:	70 e0       	ldi	r23, 0x00	; 0
    f6ae:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f6b2:	08 95       	ret

0000f6b4 <PMDGetCommandedPosition>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetStopMode, mode);
}

PMDresult PMDGetCommandedPosition(PMDAxisHandle* axis_handle, PMDint32* position)
{
    f6b4:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetCommandedPosition, (PMDuint32*)position);
    f6b6:	6d e1       	ldi	r22, 0x1D	; 29
    f6b8:	70 e0       	ldi	r23, 0x00	; 0
    f6ba:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f6be:	08 95       	ret

0000f6c0 <PMDGetGearRatio>:
{
	return SendCommandLong(axis_handle, PMDOPSetGearRatio, (PMDuint32)ratio);
}

PMDresult PMDGetGearRatio(PMDAxisHandle* axis_handle, PMDint32* ratio)
{
    f6c0:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetGearRatio, (PMDuint32*)ratio);
    f6c2:	69 e5       	ldi	r22, 0x59	; 89
    f6c4:	70 e0       	ldi	r23, 0x00	; 0
    f6c6:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f6ca:	08 95       	ret

0000f6cc <PMDGetJerk>:
{
	return SendCommandLong(axis_handle, PMDOPSetJerk, jerk);
}

PMDresult PMDGetJerk(PMDAxisHandle* axis_handle, PMDuint32* jerk)
{
    f6cc:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetJerk, jerk);
    f6ce:	68 e5       	ldi	r22, 0x58	; 88
    f6d0:	70 e0       	ldi	r23, 0x00	; 0
    f6d2:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f6d6:	08 95       	ret

0000f6d8 <PMDGetDeceleration>:
{
	return SendCommandLong(axis_handle, PMDOPSetDeceleration, deceleration);
}

PMDresult PMDGetDeceleration(PMDAxisHandle* axis_handle, PMDuint32* deceleration)
{
    f6d8:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetDeceleration, deceleration);
    f6da:	62 e9       	ldi	r22, 0x92	; 146
    f6dc:	70 e0       	ldi	r23, 0x00	; 0
    f6de:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f6e2:	08 95       	ret

0000f6e4 <PMDGetAcceleration>:
{
	return SendCommandLong(axis_handle, PMDOPSetAcceleration, acceleration);
}

PMDresult PMDGetAcceleration(PMDAxisHandle* axis_handle, PMDuint32* acceleration)
{
    f6e4:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetAcceleration, acceleration);
    f6e6:	6c e4       	ldi	r22, 0x4C	; 76
    f6e8:	70 e0       	ldi	r23, 0x00	; 0
    f6ea:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f6ee:	08 95       	ret

0000f6f0 <PMDGetStartVelocity>:
{
	return SendCommandLong(axis_handle, PMDOPSetStartVelocity, velocity);
}

PMDresult PMDGetStartVelocity(PMDAxisHandle* axis_handle, PMDuint32* velocity)
{
    f6f0:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetStartVelocity, velocity);
    f6f2:	6b e6       	ldi	r22, 0x6B	; 107
    f6f4:	70 e0       	ldi	r23, 0x00	; 0
    f6f6:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f6fa:	08 95       	ret

0000f6fc <PMDGetVelocity>:
{
	return SendCommandLong(axis_handle, PMDOPSetVelocity, velocity);
}

PMDresult PMDGetVelocity(PMDAxisHandle* axis_handle, PMDint32* velocity)
{
    f6fc:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetVelocity, (PMDuint32*)velocity);
    f6fe:	6b e4       	ldi	r22, 0x4B	; 75
    f700:	70 e0       	ldi	r23, 0x00	; 0
    f702:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f706:	08 95       	ret

0000f708 <PMDGetPosition>:
{
	return SendCommandLong(axis_handle, PMDOPSetPosition, position);
}

PMDresult PMDGetPosition(PMDAxisHandle* axis_handle, PMDint32* position)
{
    f708:	ab 01       	movw	r20, r22
	return SendCommandGetLong(axis_handle, PMDOPGetPosition, (PMDuint32*)position);
    f70a:	6a e4       	ldi	r22, 0x4A	; 74
    f70c:	70 e0       	ldi	r23, 0x00	; 0
    f70e:	0e 94 a0 83 	call	0x10740	; 0x10740 <SendCommandGetLong>
}
    f712:	08 95       	ret

0000f714 <PMDGetVersion>:
}

PMDresult PMDGetVersion(PMDAxisHandle* axis_handle, PMDuint16 *generation, PMDuint16 *motorType, 
						PMDuint16 *numberAxes, PMDuint16 *special,
						PMDuint16 *custom, PMDuint16 *major, PMDuint16 *minor)
{
    f714:	2f 92       	push	r2
    f716:	3f 92       	push	r3
    f718:	4f 92       	push	r4
    f71a:	5f 92       	push	r5
    f71c:	6f 92       	push	r6
    f71e:	7f 92       	push	r7
    f720:	8f 92       	push	r8
    f722:	9f 92       	push	r9
    f724:	af 92       	push	r10
    f726:	bf 92       	push	r11
    f728:	cf 92       	push	r12
    f72a:	df 92       	push	r13
    f72c:	ef 92       	push	r14
    f72e:	ff 92       	push	r15
    f730:	0f 93       	push	r16
    f732:	1f 93       	push	r17
    f734:	df 93       	push	r29
    f736:	cf 93       	push	r28
    f738:	00 d0       	rcall	.+0      	; 0xf73a <PMDGetVersion+0x26>
    f73a:	00 d0       	rcall	.+0      	; 0xf73c <PMDGetVersion+0x28>
    f73c:	cd b7       	in	r28, 0x3d	; 61
    f73e:	de b7       	in	r29, 0x3e	; 62
    f740:	4b 01       	movw	r8, r22
    f742:	3a 01       	movw	r6, r20
    f744:	29 01       	movw	r4, r18
    f746:	18 01       	movw	r2, r16
    f748:	87 01       	movw	r16, r14
    f74a:	76 01       	movw	r14, r12
	PMDuint16 chip = 0, software = 0;
    f74c:	1a 82       	std	Y+2, r1	; 0x02
    f74e:	19 82       	std	Y+1, r1	; 0x01
    f750:	1c 82       	std	Y+4, r1	; 0x04
    f752:	1b 82       	std	Y+3, r1	; 0x03
	PMDuint16 result;

	result = SendCommandGetWordWord(axis_handle, PMDOPGetVersion, &chip, &software);
    f754:	6f e8       	ldi	r22, 0x8F	; 143
    f756:	70 e0       	ldi	r23, 0x00	; 0
    f758:	ae 01       	movw	r20, r28
    f75a:	4f 5f       	subi	r20, 0xFF	; 255
    f75c:	5f 4f       	sbci	r21, 0xFF	; 255
    f75e:	9e 01       	movw	r18, r28
    f760:	2d 5f       	subi	r18, 0xFD	; 253
    f762:	3f 4f       	sbci	r19, 0xFF	; 255
    f764:	0e 94 5e 83 	call	0x106bc	; 0x106bc <SendCommandGetWordWord>

	*generation = (PMDuint16)((chip & 0xF000) >> 12);
    f768:	2a 81       	ldd	r18, Y+2	; 0x02
    f76a:	22 95       	swap	r18
    f76c:	2f 70       	andi	r18, 0x0F	; 15
    f76e:	f4 01       	movw	r30, r8
    f770:	20 83       	st	Z, r18
    f772:	11 82       	std	Z+1, r1	; 0x01
	*motorType = (PMDuint16)((chip & 0x0F00) >> 8);
    f774:	49 81       	ldd	r20, Y+1	; 0x01
    f776:	5a 81       	ldd	r21, Y+2	; 0x02
    f778:	9a 01       	movw	r18, r20
    f77a:	20 70       	andi	r18, 0x00	; 0
    f77c:	3f 70       	andi	r19, 0x0F	; 15
    f77e:	f3 01       	movw	r30, r6
    f780:	30 83       	st	Z, r19
    f782:	11 82       	std	Z+1, r1	; 0x01
	*numberAxes = (PMDuint16)((chip & 0x00F0) >> 4);
    f784:	9a 01       	movw	r18, r20
    f786:	20 7f       	andi	r18, 0xF0	; 240
    f788:	30 70       	andi	r19, 0x00	; 0
    f78a:	64 e0       	ldi	r22, 0x04	; 4
    f78c:	36 95       	lsr	r19
    f78e:	27 95       	ror	r18
    f790:	6a 95       	dec	r22
    f792:	e1 f7       	brne	.-8      	; 0xf78c <PMDGetVersion+0x78>
    f794:	f2 01       	movw	r30, r4
    f796:	31 83       	std	Z+1, r19	; 0x01
    f798:	20 83       	st	Z, r18
	*special = (PMDuint16)(chip & 0x000F);
    f79a:	4f 70       	andi	r20, 0x0F	; 15
    f79c:	50 70       	andi	r21, 0x00	; 0
    f79e:	f1 01       	movw	r30, r2
    f7a0:	51 83       	std	Z+1, r21	; 0x01
    f7a2:	40 83       	st	Z, r20

	*custom = (PMDuint16)((software & 0xFF00) >> 8);
    f7a4:	2c 81       	ldd	r18, Y+4	; 0x04
    f7a6:	f8 01       	movw	r30, r16
    f7a8:	20 83       	st	Z, r18
    f7aa:	11 82       	std	Z+1, r1	; 0x01
	*major = (PMDuint16)((software & 0x00F0) >> 4);
    f7ac:	4b 81       	ldd	r20, Y+3	; 0x03
    f7ae:	5c 81       	ldd	r21, Y+4	; 0x04
    f7b0:	9a 01       	movw	r18, r20
    f7b2:	20 7f       	andi	r18, 0xF0	; 240
    f7b4:	30 70       	andi	r19, 0x00	; 0
    f7b6:	14 e0       	ldi	r17, 0x04	; 4
    f7b8:	36 95       	lsr	r19
    f7ba:	27 95       	ror	r18
    f7bc:	1a 95       	dec	r17
    f7be:	e1 f7       	brne	.-8      	; 0xf7b8 <PMDGetVersion+0xa4>
    f7c0:	f7 01       	movw	r30, r14
    f7c2:	31 83       	std	Z+1, r19	; 0x01
    f7c4:	20 83       	st	Z, r18
	*minor = (PMDuint16)(software & 0x000F);
    f7c6:	4f 70       	andi	r20, 0x0F	; 15
    f7c8:	50 70       	andi	r21, 0x00	; 0
    f7ca:	f5 01       	movw	r30, r10
    f7cc:	51 83       	std	Z+1, r21	; 0x01
    f7ce:	40 83       	st	Z, r20

	return result;
}
    f7d0:	0f 90       	pop	r0
    f7d2:	0f 90       	pop	r0
    f7d4:	0f 90       	pop	r0
    f7d6:	0f 90       	pop	r0
    f7d8:	cf 91       	pop	r28
    f7da:	df 91       	pop	r29
    f7dc:	1f 91       	pop	r17
    f7de:	0f 91       	pop	r16
    f7e0:	ff 90       	pop	r15
    f7e2:	ef 90       	pop	r14
    f7e4:	df 90       	pop	r13
    f7e6:	cf 90       	pop	r12
    f7e8:	bf 90       	pop	r11
    f7ea:	af 90       	pop	r10
    f7ec:	9f 90       	pop	r9
    f7ee:	8f 90       	pop	r8
    f7f0:	7f 90       	pop	r7
    f7f2:	6f 90       	pop	r6
    f7f4:	5f 90       	pop	r5
    f7f6:	4f 90       	pop	r4
    f7f8:	3f 90       	pop	r3
    f7fa:	2f 90       	pop	r2
    f7fc:	08 95       	ret

0000f7fe <PMDGetEncoderToStepRatio>:
{
	return SendCommandWordWord(axis_handle, PMDOPSetEncoderToStepRatio, encoderCounts, steps);
}

PMDresult PMDGetEncoderToStepRatio(PMDAxisHandle* axis_handle, PMDuint16* encoderCounts, PMDuint16* steps)
{
    f7fe:	fb 01       	movw	r30, r22
    f800:	9a 01       	movw	r18, r20
	return SendCommandGetWordWord(axis_handle, PMDOPGetEncoderToStepRatio, encoderCounts, steps);
    f802:	6f ed       	ldi	r22, 0xDF	; 223
    f804:	70 e0       	ldi	r23, 0x00	; 0
    f806:	af 01       	movw	r20, r30
    f808:	0e 94 5e 83 	call	0x106bc	; 0x106bc <SendCommandGetWordWord>
}
    f80c:	08 95       	ret

0000f80e <PMDNoOperation>:
	
}

PMDresult PMDNoOperation(PMDAxisHandle* axis_handle)
{
	return SendCommand(axis_handle, PMDOPNoOperation);
    f80e:	60 e0       	ldi	r22, 0x00	; 0
    f810:	70 e0       	ldi	r23, 0x00	; 0
    f812:	0e 94 2b 82 	call	0x10456	; 0x10456 <SendCommand>
}
    f816:	08 95       	ret

0000f818 <PMDReset>:
{
	return SendCommandWordGetWord(axis_handle, PMDOPReadAnalog, analogID, data);
}

PMDresult PMDReset(PMDAxisHandle* axis_handle)
{
    f818:	ef 92       	push	r14
    f81a:	ff 92       	push	r15
    f81c:	0f 93       	push	r16
    f81e:	1f 93       	push	r17
    f820:	8c 01       	movw	r16, r24
    PMDAxis	axis = axis_handle->axis;
    f822:	fc 01       	movw	r30, r24
    f824:	e2 80       	ldd	r14, Z+2	; 0x02
    f826:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// for the reset command, the axis number MUST be zero
	axis_handle->axis = 0;
    f828:	13 82       	std	Z+3, r1	; 0x03
    f82a:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommand(axis_handle, PMDOPReset);
    f82c:	69 e3       	ldi	r22, 0x39	; 57
    f82e:	70 e0       	ldi	r23, 0x00	; 0
    f830:	0e 94 2b 82 	call	0x10456	; 0x10456 <SendCommand>

	axis_handle->axis = axis;
    f834:	f8 01       	movw	r30, r16
    f836:	f3 82       	std	Z+3, r15	; 0x03
    f838:	e2 82       	std	Z+2, r14	; 0x02

	return result;
	
}
    f83a:	1f 91       	pop	r17
    f83c:	0f 91       	pop	r16
    f83e:	ff 90       	pop	r15
    f840:	ef 90       	pop	r14
    f842:	08 95       	ret

0000f844 <PMDInitializePhase>:
	return SendCommandGetWord(axis_handle, PMDOPGetPhaseCorrectionMode, mode);
}

PMDresult PMDInitializePhase(PMDAxisHandle* axis_handle)
{
	return SendCommand(axis_handle, PMDOPInitializePhase);
    f844:	6a e7       	ldi	r22, 0x7A	; 122
    f846:	70 e0       	ldi	r23, 0x00	; 0
    f848:	0e 94 2b 82 	call	0x10456	; 0x10456 <SendCommand>
}
    f84c:	08 95       	ret

0000f84e <PMDClearInterrupt>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetInterruptMask, interruptMask);
}

PMDresult PMDClearInterrupt(PMDAxisHandle* axis_handle)
{
    f84e:	ef 92       	push	r14
    f850:	ff 92       	push	r15
    f852:	0f 93       	push	r16
    f854:	1f 93       	push	r17
    f856:	8c 01       	movw	r16, r24
	PMDAxis axis = axis_handle->axis;
    f858:	fc 01       	movw	r30, r24
    f85a:	e2 80       	ldd	r14, Z+2	; 0x02
    f85c:	f3 80       	ldd	r15, Z+3	; 0x03
	PMDuint16 result;

	// for the ClearInterrupt command, the axis number MUST be zero
	axis_handle->axis = 0;
    f85e:	13 82       	std	Z+3, r1	; 0x03
    f860:	12 82       	std	Z+2, r1	; 0x02

	result = SendCommand(axis_handle, PMDOPClearInterrupt);
    f862:	6c ea       	ldi	r22, 0xAC	; 172
    f864:	70 e0       	ldi	r23, 0x00	; 0
    f866:	0e 94 2b 82 	call	0x10456	; 0x10456 <SendCommand>

	axis_handle->axis = axis;
    f86a:	f8 01       	movw	r30, r16
    f86c:	f3 82       	std	Z+3, r15	; 0x03
    f86e:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    f870:	1f 91       	pop	r17
    f872:	0f 91       	pop	r16
    f874:	ff 90       	pop	r15
    f876:	ef 90       	pop	r14
    f878:	08 95       	ret

0000f87a <PMDUpdate>:
	return SendCommandWordGetLong(axis_handle, PMDOPGetBreakpointValue, breakpointID, (PMDuint32*)breakpointValue);
}

PMDresult PMDUpdate(PMDAxisHandle* axis_handle)
{
	return SendCommand(axis_handle, PMDOPUpdate);
    f87a:	6a e1       	ldi	r22, 0x1A	; 26
    f87c:	70 e0       	ldi	r23, 0x00	; 0
    f87e:	0e 94 2b 82 	call	0x10456	; 0x10456 <SendCommand>
}
    f882:	08 95       	ret

0000f884 <PMDClearPositionError>:
	return SendCommandGetWord(axis_handle, PMDOPGetMotionCompleteMode, mode);
}

PMDresult PMDClearPositionError(PMDAxisHandle* axis_handle)
{
	return SendCommand(axis_handle, PMDOPClearPositionError);
    f884:	67 e4       	ldi	r22, 0x47	; 71
    f886:	70 e0       	ldi	r23, 0x00	; 0
    f888:	0e 94 2b 82 	call	0x10456	; 0x10456 <SendCommand>
}
    f88c:	08 95       	ret

0000f88e <PMDReadAnalog>:
{
	return SendCommandWordGetWord(axis_handle, PMDOPReadIO, address, data);
}

PMDresult PMDReadAnalog(PMDAxisHandle* axis_handle, PMDuint16 analogID, PMDuint16* data)
{
    f88e:	fb 01       	movw	r30, r22
    f890:	9a 01       	movw	r18, r20
	return SendCommandWordGetWord(axis_handle, PMDOPReadAnalog, analogID, data);
    f892:	6f ee       	ldi	r22, 0xEF	; 239
    f894:	70 e0       	ldi	r23, 0x00	; 0
    f896:	af 01       	movw	r20, r30
    f898:	0e 94 eb 83 	call	0x107d6	; 0x107d6 <SendCommandWordGetWord>
}
    f89c:	08 95       	ret

0000f89e <PMDReadIO>:
{
	return SendCommandWordWord(axis_handle, PMDOPWriteIO, address, data);
}

PMDresult PMDReadIO(PMDAxisHandle* axis_handle, PMDuint16 address, PMDuint16* data)
{
    f89e:	fb 01       	movw	r30, r22
    f8a0:	9a 01       	movw	r18, r20
	return SendCommandWordGetWord(axis_handle, PMDOPReadIO, address, data);
    f8a2:	63 e8       	ldi	r22, 0x83	; 131
    f8a4:	70 e0       	ldi	r23, 0x00	; 0
    f8a6:	af 01       	movw	r20, r30
    f8a8:	0e 94 eb 83 	call	0x107d6	; 0x107d6 <SendCommandWordGetWord>
}
    f8ac:	08 95       	ret

0000f8ae <PMDGetTraceVariable>:

	return result;
}

PMDresult PMDGetTraceVariable(PMDAxisHandle* axis_handle, PMDuint16 traceID, PMDAxis *traceAxis, PMDuint8* variable)
{
    f8ae:	af 92       	push	r10
    f8b0:	bf 92       	push	r11
    f8b2:	cf 92       	push	r12
    f8b4:	df 92       	push	r13
    f8b6:	ef 92       	push	r14
    f8b8:	ff 92       	push	r15
    f8ba:	0f 93       	push	r16
    f8bc:	1f 93       	push	r17
    f8be:	df 93       	push	r29
    f8c0:	cf 93       	push	r28
    f8c2:	00 d0       	rcall	.+0      	; 0xf8c4 <PMDGetTraceVariable+0x16>
    f8c4:	cd b7       	in	r28, 0x3d	; 61
    f8c6:	de b7       	in	r29, 0x3e	; 62
    f8c8:	8c 01       	movw	r16, r24
    f8ca:	fb 01       	movw	r30, r22
    f8cc:	7a 01       	movw	r14, r20
    f8ce:	69 01       	movw	r12, r18
	PMDAxis axis = axis_handle->axis;
    f8d0:	dc 01       	movw	r26, r24
    f8d2:	12 96       	adiw	r26, 0x02	; 2
    f8d4:	ad 90       	ld	r10, X+
    f8d6:	bc 90       	ld	r11, X
    f8d8:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;
	PMDuint16 value;

	// set the axis number to zero
	axis_handle->axis = 0;
    f8da:	13 96       	adiw	r26, 0x03	; 3
    f8dc:	1c 92       	st	X, r1
    f8de:	1e 92       	st	-X, r1
    f8e0:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetWord(axis_handle, PMDOPGetTraceVariable, traceID, &value);
    f8e2:	67 eb       	ldi	r22, 0xB7	; 183
    f8e4:	70 e0       	ldi	r23, 0x00	; 0
    f8e6:	af 01       	movw	r20, r30
    f8e8:	9e 01       	movw	r18, r28
    f8ea:	2f 5f       	subi	r18, 0xFF	; 255
    f8ec:	3f 4f       	sbci	r19, 0xFF	; 255
    f8ee:	0e 94 eb 83 	call	0x107d6	; 0x107d6 <SendCommandWordGetWord>
	*traceAxis = (PMDAxis)(value & nibbleMask);
    f8f2:	29 81       	ldd	r18, Y+1	; 0x01
    f8f4:	3a 81       	ldd	r19, Y+2	; 0x02
    f8f6:	2f 70       	andi	r18, 0x0F	; 15
    f8f8:	30 70       	andi	r19, 0x00	; 0
    f8fa:	f7 01       	movw	r30, r14
    f8fc:	31 83       	std	Z+1, r19	; 0x01
    f8fe:	20 83       	st	Z, r18
	*variable = (PMDuint8)((value >> 8) & byteMask);
    f900:	2a 81       	ldd	r18, Y+2	; 0x02
    f902:	d6 01       	movw	r26, r12
    f904:	2c 93       	st	X, r18

	axis_handle->axis = axis;
    f906:	f8 01       	movw	r30, r16
    f908:	b3 82       	std	Z+3, r11	; 0x03
    f90a:	a2 82       	std	Z+2, r10	; 0x02

	return result;
}
    f90c:	0f 90       	pop	r0
    f90e:	0f 90       	pop	r0
    f910:	cf 91       	pop	r28
    f912:	df 91       	pop	r29
    f914:	1f 91       	pop	r17
    f916:	0f 91       	pop	r16
    f918:	ff 90       	pop	r15
    f91a:	ef 90       	pop	r14
    f91c:	df 90       	pop	r13
    f91e:	cf 90       	pop	r12
    f920:	bf 90       	pop	r11
    f922:	af 90       	pop	r10
    f924:	08 95       	ret

0000f926 <PMDGetBufferFunction>:
{
	return SendCommandWordWord(axis_handle, PMDOPSetBufferFunction, function, (PMDuint16)bufferID);
}

PMDresult PMDGetBufferFunction(PMDAxisHandle* axis_handle, PMDuint16 function, PMDint16* bufferID)
{
    f926:	fb 01       	movw	r30, r22
    f928:	9a 01       	movw	r18, r20
	return SendCommandWordGetWord(axis_handle, PMDOPGetBufferFunction, function, (PMDuint16*)bufferID);
    f92a:	6b ec       	ldi	r22, 0xCB	; 203
    f92c:	70 e0       	ldi	r23, 0x00	; 0
    f92e:	af 01       	movw	r20, r30
    f930:	0e 94 eb 83 	call	0x107d6	; 0x107d6 <SendCommandWordGetWord>
}
    f934:	08 95       	ret

0000f936 <PMDGetPhaseCommand>:
{
	return SendCommand(axis_handle, PMDOPInitializePhase);
}

PMDresult PMDGetPhaseCommand(PMDAxisHandle* axis_handle, PMDuint16 phase, PMDint16* command)
{
    f936:	fb 01       	movw	r30, r22
    f938:	9a 01       	movw	r18, r20
	return SendCommandWordGetWord(axis_handle, PMDOPGetPhaseCommand, phase, (PMDuint16*)command);
    f93a:	6a ee       	ldi	r22, 0xEA	; 234
    f93c:	70 e0       	ldi	r23, 0x00	; 0
    f93e:	af 01       	movw	r20, r30
    f940:	0e 94 eb 83 	call	0x107d6	; 0x107d6 <SendCommandWordGetWord>
}
    f944:	08 95       	ret

0000f946 <PMDGetBreakpoint>:
	return SendCommandWordWord(axis_handle, PMDOPSetBreakpoint, breakpointID, value);
}

PMDresult PMDGetBreakpoint(PMDAxisHandle* axis_handle, PMDuint16 breakpointID, 
						   PMDAxis* breakAxis, PMDuint8* action, PMDuint8* trigger)
{
    f946:	cf 92       	push	r12
    f948:	df 92       	push	r13
    f94a:	ef 92       	push	r14
    f94c:	ff 92       	push	r15
    f94e:	0f 93       	push	r16
    f950:	1f 93       	push	r17
    f952:	df 93       	push	r29
    f954:	cf 93       	push	r28
    f956:	00 d0       	rcall	.+0      	; 0xf958 <PMDGetBreakpoint+0x12>
    f958:	cd b7       	in	r28, 0x3d	; 61
    f95a:	de b7       	in	r29, 0x3e	; 62
    f95c:	fb 01       	movw	r30, r22
    f95e:	7a 01       	movw	r14, r20
    f960:	69 01       	movw	r12, r18
	PMDuint16 result;
	PMDuint16 value;

	result = SendCommandWordGetWord(axis_handle, PMDOPGetBreakpoint, breakpointID, &value);
    f962:	65 ed       	ldi	r22, 0xD5	; 213
    f964:	70 e0       	ldi	r23, 0x00	; 0
    f966:	af 01       	movw	r20, r30
    f968:	9e 01       	movw	r18, r28
    f96a:	2f 5f       	subi	r18, 0xFF	; 255
    f96c:	3f 4f       	sbci	r19, 0xFF	; 255
    f96e:	0e 94 eb 83 	call	0x107d6	; 0x107d6 <SendCommandWordGetWord>

	*breakAxis = (PMDAxis)(value & nibbleMask);
    f972:	29 81       	ldd	r18, Y+1	; 0x01
    f974:	3a 81       	ldd	r19, Y+2	; 0x02
    f976:	a9 01       	movw	r20, r18
    f978:	4f 70       	andi	r20, 0x0F	; 15
    f97a:	50 70       	andi	r21, 0x00	; 0
    f97c:	f7 01       	movw	r30, r14
    f97e:	51 83       	std	Z+1, r21	; 0x01
    f980:	40 83       	st	Z, r20
	*action = (PMDuint8)((value >> 4) & nibbleMask);
    f982:	74 e0       	ldi	r23, 0x04	; 4
    f984:	36 95       	lsr	r19
    f986:	27 95       	ror	r18
    f988:	7a 95       	dec	r23
    f98a:	e1 f7       	brne	.-8      	; 0xf984 <PMDGetBreakpoint+0x3e>
    f98c:	2f 70       	andi	r18, 0x0F	; 15
    f98e:	f6 01       	movw	r30, r12
    f990:	20 83       	st	Z, r18
	*trigger = (PMDuint8)((value >> 8) & byteMask);
    f992:	2a 81       	ldd	r18, Y+2	; 0x02
    f994:	f8 01       	movw	r30, r16
    f996:	20 83       	st	Z, r18

	return result;
}
    f998:	0f 90       	pop	r0
    f99a:	0f 90       	pop	r0
    f99c:	cf 91       	pop	r28
    f99e:	df 91       	pop	r29
    f9a0:	1f 91       	pop	r17
    f9a2:	0f 91       	pop	r16
    f9a4:	ff 90       	pop	r15
    f9a6:	ef 90       	pop	r14
    f9a8:	df 90       	pop	r13
    f9aa:	cf 90       	pop	r12
    f9ac:	08 95       	ret

0000f9ae <PMDWriteIO>:

	return result;
}

PMDresult PMDWriteIO(PMDAxisHandle* axis_handle, PMDuint16 address, PMDuint16 data)
{
    f9ae:	fb 01       	movw	r30, r22
    f9b0:	9a 01       	movw	r18, r20
	return SendCommandWordWord(axis_handle, PMDOPWriteIO, address, data);
    f9b2:	62 e8       	ldi	r22, 0x82	; 130
    f9b4:	70 e0       	ldi	r23, 0x00	; 0
    f9b6:	af 01       	movw	r20, r30
    f9b8:	0e 94 7e 82 	call	0x104fc	; 0x104fc <SendCommandWordWord>
}
    f9bc:	08 95       	ret

0000f9be <PMDSetTraceVariable>:

	return result;
}

PMDresult PMDSetTraceVariable(PMDAxisHandle* axis_handle, PMDuint16 traceID, PMDAxis traceAxis, PMDuint8 variable)
{
    f9be:	ef 92       	push	r14
    f9c0:	ff 92       	push	r15
    f9c2:	0f 93       	push	r16
    f9c4:	1f 93       	push	r17
    f9c6:	8c 01       	movw	r16, r24
    f9c8:	fb 01       	movw	r30, r22
    f9ca:	82 2f       	mov	r24, r18
	PMDAxis axis = axis_handle->axis;
    f9cc:	d8 01       	movw	r26, r16
    f9ce:	12 96       	adiw	r26, 0x02	; 2
    f9d0:	ed 90       	ld	r14, X+
    f9d2:	fc 90       	ld	r15, X
    f9d4:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;
	PMDuint16 value;

	// set the axis number to zero
	axis_handle->axis = 0;
    f9d6:	13 96       	adiw	r26, 0x03	; 3
    f9d8:	1c 92       	st	X, r1
    f9da:	1e 92       	st	-X, r1
    f9dc:	12 97       	sbiw	r26, 0x02	; 2

	value = (PMDuint16)((traceAxis & nibbleMask) | ((variable & byteMask) << 8));
	result = SendCommandWordWord(axis_handle, PMDOPSetTraceVariable, traceID, value);
    f9de:	38 2f       	mov	r19, r24
    f9e0:	20 e0       	ldi	r18, 0x00	; 0
    f9e2:	4f 70       	andi	r20, 0x0F	; 15
    f9e4:	50 70       	andi	r21, 0x00	; 0
    f9e6:	24 2b       	or	r18, r20
    f9e8:	35 2b       	or	r19, r21
    f9ea:	c8 01       	movw	r24, r16
    f9ec:	66 eb       	ldi	r22, 0xB6	; 182
    f9ee:	70 e0       	ldi	r23, 0x00	; 0
    f9f0:	af 01       	movw	r20, r30
    f9f2:	0e 94 7e 82 	call	0x104fc	; 0x104fc <SendCommandWordWord>

	axis_handle->axis = axis;
    f9f6:	f8 01       	movw	r30, r16
    f9f8:	f3 82       	std	Z+3, r15	; 0x03
    f9fa:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    f9fc:	1f 91       	pop	r17
    f9fe:	0f 91       	pop	r16
    fa00:	ff 90       	pop	r15
    fa02:	ef 90       	pop	r14
    fa04:	08 95       	ret

0000fa06 <PMDSetBufferFunction>:

	return result;
}

PMDresult PMDSetBufferFunction(PMDAxisHandle* axis_handle, PMDuint16 function, PMDint16 bufferID)
{
    fa06:	fb 01       	movw	r30, r22
    fa08:	9a 01       	movw	r18, r20
	return SendCommandWordWord(axis_handle, PMDOPSetBufferFunction, function, (PMDuint16)bufferID);
    fa0a:	6a ec       	ldi	r22, 0xCA	; 202
    fa0c:	70 e0       	ldi	r23, 0x00	; 0
    fa0e:	af 01       	movw	r20, r30
    fa10:	0e 94 7e 82 	call	0x104fc	; 0x104fc <SendCommandWordWord>
}
    fa14:	08 95       	ret

0000fa16 <PMDSetEncoderToStepRatio>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetEncoderModulus, modulus);
}

PMDresult PMDSetEncoderToStepRatio(PMDAxisHandle* axis_handle, PMDuint16 encoderCounts, PMDuint16 steps)
{
    fa16:	fb 01       	movw	r30, r22
    fa18:	9a 01       	movw	r18, r20
	return SendCommandWordWord(axis_handle, PMDOPSetEncoderToStepRatio, encoderCounts, steps);
    fa1a:	6e ed       	ldi	r22, 0xDE	; 222
    fa1c:	70 e0       	ldi	r23, 0x00	; 0
    fa1e:	af 01       	movw	r20, r30
    fa20:	0e 94 7e 82 	call	0x104fc	; 0x104fc <SendCommandWordWord>
}
    fa24:	08 95       	ret

0000fa26 <PMDSetBreakpoint>:


// Parameter Update & Breakpoints
PMDresult PMDSetBreakpoint(PMDAxisHandle* axis_handle, PMDuint16 breakpointID, 
						   PMDAxis breakAxis, PMDuint8 action, PMDuint8 trigger)
{
    fa26:	0f 93       	push	r16
    fa28:	fb 01       	movw	r30, r22
	PMDuint16 value = (PMDuint16)((breakAxis & nibbleMask) | 
		((action & nibbleMask) << 4) | ((trigger & byteMask) << 8));
	return SendCommandWordWord(axis_handle, PMDOPSetBreakpoint, breakpointID, value);
    fa2a:	30 e0       	ldi	r19, 0x00	; 0
    fa2c:	a4 e0       	ldi	r26, 0x04	; 4
    fa2e:	22 0f       	add	r18, r18
    fa30:	33 1f       	adc	r19, r19
    fa32:	aa 95       	dec	r26
    fa34:	e1 f7       	brne	.-8      	; 0xfa2e <PMDSetBreakpoint+0x8>
    fa36:	30 70       	andi	r19, 0x00	; 0
    fa38:	70 2f       	mov	r23, r16
    fa3a:	60 e0       	ldi	r22, 0x00	; 0
    fa3c:	26 2b       	or	r18, r22
    fa3e:	37 2b       	or	r19, r23
    fa40:	4f 70       	andi	r20, 0x0F	; 15
    fa42:	50 70       	andi	r21, 0x00	; 0
    fa44:	24 2b       	or	r18, r20
    fa46:	35 2b       	or	r19, r21
    fa48:	64 ed       	ldi	r22, 0xD4	; 212
    fa4a:	70 e0       	ldi	r23, 0x00	; 0
    fa4c:	af 01       	movw	r20, r30
    fa4e:	0e 94 7e 82 	call	0x104fc	; 0x104fc <SendCommandWordWord>
}
    fa52:	0f 91       	pop	r16
    fa54:	08 95       	ret

0000fa56 <PMDGetBufferReadIndex>:

	return result;
}

PMDresult PMDGetBufferReadIndex(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32* readIndex)
{
    fa56:	ef 92       	push	r14
    fa58:	ff 92       	push	r15
    fa5a:	0f 93       	push	r16
    fa5c:	1f 93       	push	r17
    fa5e:	8c 01       	movw	r16, r24
    fa60:	fb 01       	movw	r30, r22
    fa62:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    fa64:	dc 01       	movw	r26, r24
    fa66:	12 96       	adiw	r26, 0x02	; 2
    fa68:	ed 90       	ld	r14, X+
    fa6a:	fc 90       	ld	r15, X
    fa6c:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    fa6e:	13 96       	adiw	r26, 0x03	; 3
    fa70:	1c 92       	st	X, r1
    fa72:	1e 92       	st	-X, r1
    fa74:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetLong(axis_handle, PMDOPGetBufferReadIndex, bufferID, readIndex);
    fa76:	67 ec       	ldi	r22, 0xC7	; 199
    fa78:	70 e0       	ldi	r23, 0x00	; 0
    fa7a:	af 01       	movw	r20, r30
    fa7c:	0e 94 25 84 	call	0x1084a	; 0x1084a <SendCommandWordGetLong>

	axis_handle->axis = axis;
    fa80:	f8 01       	movw	r30, r16
    fa82:	f3 82       	std	Z+3, r15	; 0x03
    fa84:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    fa86:	1f 91       	pop	r17
    fa88:	0f 91       	pop	r16
    fa8a:	ff 90       	pop	r15
    fa8c:	ef 90       	pop	r14
    fa8e:	08 95       	ret

0000fa90 <PMDGetBufferWriteIndex>:

	return result;
}

PMDresult PMDGetBufferWriteIndex(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32* writeIndex)
{
    fa90:	ef 92       	push	r14
    fa92:	ff 92       	push	r15
    fa94:	0f 93       	push	r16
    fa96:	1f 93       	push	r17
    fa98:	8c 01       	movw	r16, r24
    fa9a:	fb 01       	movw	r30, r22
    fa9c:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    fa9e:	dc 01       	movw	r26, r24
    faa0:	12 96       	adiw	r26, 0x02	; 2
    faa2:	ed 90       	ld	r14, X+
    faa4:	fc 90       	ld	r15, X
    faa6:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    faa8:	13 96       	adiw	r26, 0x03	; 3
    faaa:	1c 92       	st	X, r1
    faac:	1e 92       	st	-X, r1
    faae:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetLong(axis_handle, PMDOPGetBufferWriteIndex, bufferID, writeIndex);
    fab0:	65 ec       	ldi	r22, 0xC5	; 197
    fab2:	70 e0       	ldi	r23, 0x00	; 0
    fab4:	af 01       	movw	r20, r30
    fab6:	0e 94 25 84 	call	0x1084a	; 0x1084a <SendCommandWordGetLong>

	axis_handle->axis = axis;
    faba:	f8 01       	movw	r30, r16
    fabc:	f3 82       	std	Z+3, r15	; 0x03
    fabe:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    fac0:	1f 91       	pop	r17
    fac2:	0f 91       	pop	r16
    fac4:	ff 90       	pop	r15
    fac6:	ef 90       	pop	r14
    fac8:	08 95       	ret

0000faca <PMDReadBuffer>:

	return result;
}

PMDresult PMDReadBuffer(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDint32* data)
{
    faca:	ef 92       	push	r14
    facc:	ff 92       	push	r15
    face:	0f 93       	push	r16
    fad0:	1f 93       	push	r17
    fad2:	8c 01       	movw	r16, r24
    fad4:	fb 01       	movw	r30, r22
    fad6:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    fad8:	dc 01       	movw	r26, r24
    fada:	12 96       	adiw	r26, 0x02	; 2
    fadc:	ed 90       	ld	r14, X+
    fade:	fc 90       	ld	r15, X
    fae0:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    fae2:	13 96       	adiw	r26, 0x03	; 3
    fae4:	1c 92       	st	X, r1
    fae6:	1e 92       	st	-X, r1
    fae8:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetLong(axis_handle, PMDOPReadBuffer, bufferID, (PMDuint32*)data);
    faea:	69 ec       	ldi	r22, 0xC9	; 201
    faec:	70 e0       	ldi	r23, 0x00	; 0
    faee:	af 01       	movw	r20, r30
    faf0:	0e 94 25 84 	call	0x1084a	; 0x1084a <SendCommandWordGetLong>

	axis_handle->axis = axis;
    faf4:	f8 01       	movw	r30, r16
    faf6:	f3 82       	std	Z+3, r15	; 0x03
    faf8:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    fafa:	1f 91       	pop	r17
    fafc:	0f 91       	pop	r16
    fafe:	ff 90       	pop	r15
    fb00:	ef 90       	pop	r14
    fb02:	08 95       	ret

0000fb04 <PMDGetBufferLength>:

	return result;
}

PMDresult PMDGetBufferLength(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32* bufferLength)
{
    fb04:	ef 92       	push	r14
    fb06:	ff 92       	push	r15
    fb08:	0f 93       	push	r16
    fb0a:	1f 93       	push	r17
    fb0c:	8c 01       	movw	r16, r24
    fb0e:	fb 01       	movw	r30, r22
    fb10:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    fb12:	dc 01       	movw	r26, r24
    fb14:	12 96       	adiw	r26, 0x02	; 2
    fb16:	ed 90       	ld	r14, X+
    fb18:	fc 90       	ld	r15, X
    fb1a:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    fb1c:	13 96       	adiw	r26, 0x03	; 3
    fb1e:	1c 92       	st	X, r1
    fb20:	1e 92       	st	-X, r1
    fb22:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetLong(axis_handle, PMDOPGetBufferLength, bufferID, bufferLength);
    fb24:	63 ec       	ldi	r22, 0xC3	; 195
    fb26:	70 e0       	ldi	r23, 0x00	; 0
    fb28:	af 01       	movw	r20, r30
    fb2a:	0e 94 25 84 	call	0x1084a	; 0x1084a <SendCommandWordGetLong>

	axis_handle->axis = axis;
    fb2e:	f8 01       	movw	r30, r16
    fb30:	f3 82       	std	Z+3, r15	; 0x03
    fb32:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    fb34:	1f 91       	pop	r17
    fb36:	0f 91       	pop	r16
    fb38:	ff 90       	pop	r15
    fb3a:	ef 90       	pop	r14
    fb3c:	08 95       	ret

0000fb3e <PMDGetBufferStart>:

	return result;
}

PMDresult PMDGetBufferStart(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32* bufferStart)
{
    fb3e:	ef 92       	push	r14
    fb40:	ff 92       	push	r15
    fb42:	0f 93       	push	r16
    fb44:	1f 93       	push	r17
    fb46:	8c 01       	movw	r16, r24
    fb48:	fb 01       	movw	r30, r22
    fb4a:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    fb4c:	dc 01       	movw	r26, r24
    fb4e:	12 96       	adiw	r26, 0x02	; 2
    fb50:	ed 90       	ld	r14, X+
    fb52:	fc 90       	ld	r15, X
    fb54:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    fb56:	13 96       	adiw	r26, 0x03	; 3
    fb58:	1c 92       	st	X, r1
    fb5a:	1e 92       	st	-X, r1
    fb5c:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordGetLong(axis_handle, PMDOPGetBufferStart, bufferID, bufferStart);
    fb5e:	61 ec       	ldi	r22, 0xC1	; 193
    fb60:	70 e0       	ldi	r23, 0x00	; 0
    fb62:	af 01       	movw	r20, r30
    fb64:	0e 94 25 84 	call	0x1084a	; 0x1084a <SendCommandWordGetLong>

	axis_handle->axis = axis;
    fb68:	f8 01       	movw	r30, r16
    fb6a:	f3 82       	std	Z+3, r15	; 0x03
    fb6c:	e2 82       	std	Z+2, r14	; 0x02

	return result;
}
    fb6e:	1f 91       	pop	r17
    fb70:	0f 91       	pop	r16
    fb72:	ff 90       	pop	r15
    fb74:	ef 90       	pop	r14
    fb76:	08 95       	ret

0000fb78 <PMDGetBreakpointValue>:
{
	return SendCommandWordLong(axis_handle, PMDOPSetBreakpointValue, breakpointID, (PMDuint32)breakpointValue);
}

PMDresult PMDGetBreakpointValue(PMDAxisHandle* axis_handle, PMDuint16 breakpointID, PMDint32* breakpointValue)
{
    fb78:	fb 01       	movw	r30, r22
    fb7a:	9a 01       	movw	r18, r20
	return SendCommandWordGetLong(axis_handle, PMDOPGetBreakpointValue, breakpointID, (PMDuint32*)breakpointValue);
    fb7c:	67 ed       	ldi	r22, 0xD7	; 215
    fb7e:	70 e0       	ldi	r23, 0x00	; 0
    fb80:	af 01       	movw	r20, r30
    fb82:	0e 94 25 84 	call	0x1084a	; 0x1084a <SendCommandWordGetLong>
}
    fb86:	08 95       	ret

0000fb88 <PMDSetBufferReadIndex>:

	return result;
}

PMDresult PMDSetBufferReadIndex(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32 readIndex)
{
    fb88:	cf 92       	push	r12
    fb8a:	df 92       	push	r13
    fb8c:	ef 92       	push	r14
    fb8e:	ff 92       	push	r15
    fb90:	0f 93       	push	r16
    fb92:	1f 93       	push	r17
    fb94:	7c 01       	movw	r14, r24
    fb96:	fb 01       	movw	r30, r22
    fb98:	89 01       	movw	r16, r18
    fb9a:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    fb9c:	dc 01       	movw	r26, r24
    fb9e:	12 96       	adiw	r26, 0x02	; 2
    fba0:	cd 90       	ld	r12, X+
    fba2:	dc 90       	ld	r13, X
    fba4:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    fba6:	13 96       	adiw	r26, 0x03	; 3
    fba8:	1c 92       	st	X, r1
    fbaa:	1e 92       	st	-X, r1
    fbac:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordLong(axis_handle, PMDOPSetBufferReadIndex, bufferID, readIndex);
    fbae:	66 ec       	ldi	r22, 0xC6	; 198
    fbb0:	70 e0       	ldi	r23, 0x00	; 0
    fbb2:	af 01       	movw	r20, r30
    fbb4:	0e 94 eb 82 	call	0x105d6	; 0x105d6 <SendCommandWordLong>

	axis_handle->axis = axis;
    fbb8:	f7 01       	movw	r30, r14
    fbba:	d3 82       	std	Z+3, r13	; 0x03
    fbbc:	c2 82       	std	Z+2, r12	; 0x02

	return result;
}
    fbbe:	1f 91       	pop	r17
    fbc0:	0f 91       	pop	r16
    fbc2:	ff 90       	pop	r15
    fbc4:	ef 90       	pop	r14
    fbc6:	df 90       	pop	r13
    fbc8:	cf 90       	pop	r12
    fbca:	08 95       	ret

0000fbcc <PMDSetBufferWriteIndex>:

	return result;
}

PMDresult PMDSetBufferWriteIndex(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32 writeIndex)
{
    fbcc:	cf 92       	push	r12
    fbce:	df 92       	push	r13
    fbd0:	ef 92       	push	r14
    fbd2:	ff 92       	push	r15
    fbd4:	0f 93       	push	r16
    fbd6:	1f 93       	push	r17
    fbd8:	7c 01       	movw	r14, r24
    fbda:	fb 01       	movw	r30, r22
    fbdc:	89 01       	movw	r16, r18
    fbde:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    fbe0:	dc 01       	movw	r26, r24
    fbe2:	12 96       	adiw	r26, 0x02	; 2
    fbe4:	cd 90       	ld	r12, X+
    fbe6:	dc 90       	ld	r13, X
    fbe8:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    fbea:	13 96       	adiw	r26, 0x03	; 3
    fbec:	1c 92       	st	X, r1
    fbee:	1e 92       	st	-X, r1
    fbf0:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordLong(axis_handle, PMDOPSetBufferWriteIndex, bufferID, writeIndex);
    fbf2:	64 ec       	ldi	r22, 0xC4	; 196
    fbf4:	70 e0       	ldi	r23, 0x00	; 0
    fbf6:	af 01       	movw	r20, r30
    fbf8:	0e 94 eb 82 	call	0x105d6	; 0x105d6 <SendCommandWordLong>

	axis_handle->axis = axis;
    fbfc:	f7 01       	movw	r30, r14
    fbfe:	d3 82       	std	Z+3, r13	; 0x03
    fc00:	c2 82       	std	Z+2, r12	; 0x02

	return result;
}
    fc02:	1f 91       	pop	r17
    fc04:	0f 91       	pop	r16
    fc06:	ff 90       	pop	r15
    fc08:	ef 90       	pop	r14
    fc0a:	df 90       	pop	r13
    fc0c:	cf 90       	pop	r12
    fc0e:	08 95       	ret

0000fc10 <PMDWriteBuffer>:
{
	return SendCommandWordGetWord(axis_handle, PMDOPGetBufferFunction, function, (PMDuint16*)bufferID);
}

PMDresult PMDWriteBuffer(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDint32 data)
{
    fc10:	cf 92       	push	r12
    fc12:	df 92       	push	r13
    fc14:	ef 92       	push	r14
    fc16:	ff 92       	push	r15
    fc18:	0f 93       	push	r16
    fc1a:	1f 93       	push	r17
    fc1c:	7c 01       	movw	r14, r24
    fc1e:	fb 01       	movw	r30, r22
    fc20:	89 01       	movw	r16, r18
    fc22:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    fc24:	dc 01       	movw	r26, r24
    fc26:	12 96       	adiw	r26, 0x02	; 2
    fc28:	cd 90       	ld	r12, X+
    fc2a:	dc 90       	ld	r13, X
    fc2c:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    fc2e:	13 96       	adiw	r26, 0x03	; 3
    fc30:	1c 92       	st	X, r1
    fc32:	1e 92       	st	-X, r1
    fc34:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordLong(axis_handle, PMDOPWriteBuffer, bufferID, (PMDuint32)data);
    fc36:	68 ec       	ldi	r22, 0xC8	; 200
    fc38:	70 e0       	ldi	r23, 0x00	; 0
    fc3a:	af 01       	movw	r20, r30
    fc3c:	0e 94 eb 82 	call	0x105d6	; 0x105d6 <SendCommandWordLong>

	axis_handle->axis = axis;
    fc40:	f7 01       	movw	r30, r14
    fc42:	d3 82       	std	Z+3, r13	; 0x03
    fc44:	c2 82       	std	Z+2, r12	; 0x02

	return result;
}
    fc46:	1f 91       	pop	r17
    fc48:	0f 91       	pop	r16
    fc4a:	ff 90       	pop	r15
    fc4c:	ef 90       	pop	r14
    fc4e:	df 90       	pop	r13
    fc50:	cf 90       	pop	r12
    fc52:	08 95       	ret

0000fc54 <PMDSetBufferLength>:

	return result;
}

PMDresult PMDSetBufferLength(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32 bufferLength)
{
    fc54:	cf 92       	push	r12
    fc56:	df 92       	push	r13
    fc58:	ef 92       	push	r14
    fc5a:	ff 92       	push	r15
    fc5c:	0f 93       	push	r16
    fc5e:	1f 93       	push	r17
    fc60:	7c 01       	movw	r14, r24
    fc62:	fb 01       	movw	r30, r22
    fc64:	89 01       	movw	r16, r18
    fc66:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    fc68:	dc 01       	movw	r26, r24
    fc6a:	12 96       	adiw	r26, 0x02	; 2
    fc6c:	cd 90       	ld	r12, X+
    fc6e:	dc 90       	ld	r13, X
    fc70:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    fc72:	13 96       	adiw	r26, 0x03	; 3
    fc74:	1c 92       	st	X, r1
    fc76:	1e 92       	st	-X, r1
    fc78:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordLong(axis_handle, PMDOPSetBufferLength, bufferID, bufferLength);
    fc7a:	62 ec       	ldi	r22, 0xC2	; 194
    fc7c:	70 e0       	ldi	r23, 0x00	; 0
    fc7e:	af 01       	movw	r20, r30
    fc80:	0e 94 eb 82 	call	0x105d6	; 0x105d6 <SendCommandWordLong>

	axis_handle->axis = axis;
    fc84:	f7 01       	movw	r30, r14
    fc86:	d3 82       	std	Z+3, r13	; 0x03
    fc88:	c2 82       	std	Z+2, r12	; 0x02

	return result;
}
    fc8a:	1f 91       	pop	r17
    fc8c:	0f 91       	pop	r16
    fc8e:	ff 90       	pop	r15
    fc90:	ef 90       	pop	r14
    fc92:	df 90       	pop	r13
    fc94:	cf 90       	pop	r12
    fc96:	08 95       	ret

0000fc98 <PMDSetBufferStart>:
}


// External Memory
PMDresult PMDSetBufferStart(PMDAxisHandle* axis_handle, PMDuint16 bufferID, PMDuint32 bufferStart)
{
    fc98:	cf 92       	push	r12
    fc9a:	df 92       	push	r13
    fc9c:	ef 92       	push	r14
    fc9e:	ff 92       	push	r15
    fca0:	0f 93       	push	r16
    fca2:	1f 93       	push	r17
    fca4:	7c 01       	movw	r14, r24
    fca6:	fb 01       	movw	r30, r22
    fca8:	89 01       	movw	r16, r18
    fcaa:	9a 01       	movw	r18, r20
	PMDAxis axis = axis_handle->axis;
    fcac:	dc 01       	movw	r26, r24
    fcae:	12 96       	adiw	r26, 0x02	; 2
    fcb0:	cd 90       	ld	r12, X+
    fcb2:	dc 90       	ld	r13, X
    fcb4:	13 97       	sbiw	r26, 0x03	; 3
	PMDuint16 result;

	// set the axis number to zero
	axis_handle->axis = 0;
    fcb6:	13 96       	adiw	r26, 0x03	; 3
    fcb8:	1c 92       	st	X, r1
    fcba:	1e 92       	st	-X, r1
    fcbc:	12 97       	sbiw	r26, 0x02	; 2

	result = SendCommandWordLong(axis_handle, PMDOPSetBufferStart, bufferID, bufferStart);
    fcbe:	60 ec       	ldi	r22, 0xC0	; 192
    fcc0:	70 e0       	ldi	r23, 0x00	; 0
    fcc2:	af 01       	movw	r20, r30
    fcc4:	0e 94 eb 82 	call	0x105d6	; 0x105d6 <SendCommandWordLong>

	axis_handle->axis = axis;
    fcc8:	f7 01       	movw	r30, r14
    fcca:	d3 82       	std	Z+3, r13	; 0x03
    fccc:	c2 82       	std	Z+2, r12	; 0x02

	return result;
}
    fcce:	1f 91       	pop	r17
    fcd0:	0f 91       	pop	r16
    fcd2:	ff 90       	pop	r15
    fcd4:	ef 90       	pop	r14
    fcd6:	df 90       	pop	r13
    fcd8:	cf 90       	pop	r12
    fcda:	08 95       	ret

0000fcdc <PMDSetBreakpointValue>:

	return result;
}

PMDresult PMDSetBreakpointValue(PMDAxisHandle* axis_handle, PMDuint16 breakpointID, PMDint32 breakpointValue)
{
    fcdc:	0f 93       	push	r16
    fcde:	1f 93       	push	r17
    fce0:	fb 01       	movw	r30, r22
    fce2:	89 01       	movw	r16, r18
    fce4:	9a 01       	movw	r18, r20
	return SendCommandWordLong(axis_handle, PMDOPSetBreakpointValue, breakpointID, (PMDuint32)breakpointValue);
    fce6:	66 ed       	ldi	r22, 0xD6	; 214
    fce8:	70 e0       	ldi	r23, 0x00	; 0
    fcea:	af 01       	movw	r20, r30
    fcec:	0e 94 eb 82 	call	0x105d6	; 0x105d6 <SendCommandWordLong>
}
    fcf0:	1f 91       	pop	r17
    fcf2:	0f 91       	pop	r16
    fcf4:	08 95       	ret

0000fcf6 <PMDSetActualPosition>:
{
	return SendCommandLong(axis_handle, PMDOPAdjustActualPosition, (PMDuint32)position);
}

PMDresult PMDSetActualPosition(PMDAxisHandle* axis_handle, PMDint32 position)
{
    fcf6:	9a 01       	movw	r18, r20
    fcf8:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetActualPosition, (PMDuint32)position);
    fcfa:	6d e4       	ldi	r22, 0x4D	; 77
    fcfc:	70 e0       	ldi	r23, 0x00	; 0
    fcfe:	0e 94 af 82 	call	0x1055e	; 0x1055e <SendCommandLong>
}
    fd02:	08 95       	ret

0000fd04 <PMDAdjustActualPosition>:
}


// Encoder
PMDresult PMDAdjustActualPosition(PMDAxisHandle* axis_handle, PMDint32 position)
{
    fd04:	9a 01       	movw	r18, r20
    fd06:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPAdjustActualPosition, (PMDuint32)position);
    fd08:	65 ef       	ldi	r22, 0xF5	; 245
    fd0a:	70 e0       	ldi	r23, 0x00	; 0
    fd0c:	0e 94 af 82 	call	0x1055e	; 0x1055e <SendCommandLong>
}
    fd10:	08 95       	ret

0000fd12 <PMDSetPositionErrorLimit>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetMotorBias, (PMDuint16*)bias);
}

PMDresult PMDSetPositionErrorLimit(PMDAxisHandle* axis_handle, PMDuint32 limit)
{
    fd12:	9a 01       	movw	r18, r20
    fd14:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetPositionErrorLimit, limit);
    fd16:	67 e9       	ldi	r22, 0x97	; 151
    fd18:	70 e0       	ldi	r23, 0x00	; 0
    fd1a:	0e 94 af 82 	call	0x1055e	; 0x1055e <SendCommandLong>
}
    fd1e:	08 95       	ret

0000fd20 <PMDSetIntegrationLimit>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetKout, kout);
}

PMDresult PMDSetIntegrationLimit(PMDAxisHandle* axis_handle, PMDuint32 limit)
{
    fd20:	9a 01       	movw	r18, r20
    fd22:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetIntegrationLimit, limit);
    fd24:	65 e9       	ldi	r22, 0x95	; 149
    fd26:	70 e0       	ldi	r23, 0x00	; 0
    fd28:	0e 94 af 82 	call	0x1055e	; 0x1055e <SendCommandLong>
}
    fd2c:	08 95       	ret

0000fd2e <PMDSetGearRatio>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetJerk, jerk);
}

PMDresult PMDSetGearRatio(PMDAxisHandle* axis_handle, PMDint32 ratio)
{
    fd2e:	9a 01       	movw	r18, r20
    fd30:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetGearRatio, (PMDuint32)ratio);
    fd32:	64 e1       	ldi	r22, 0x14	; 20
    fd34:	70 e0       	ldi	r23, 0x00	; 0
    fd36:	0e 94 af 82 	call	0x1055e	; 0x1055e <SendCommandLong>
}
    fd3a:	08 95       	ret

0000fd3c <PMDSetJerk>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetDeceleration, deceleration);
}

PMDresult PMDSetJerk(PMDAxisHandle* axis_handle, PMDuint32 jerk)
{
    fd3c:	9a 01       	movw	r18, r20
    fd3e:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetJerk, jerk);
    fd40:	63 e1       	ldi	r22, 0x13	; 19
    fd42:	70 e0       	ldi	r23, 0x00	; 0
    fd44:	0e 94 af 82 	call	0x1055e	; 0x1055e <SendCommandLong>
}
    fd48:	08 95       	ret

0000fd4a <PMDSetDeceleration>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetAcceleration, acceleration);
}

PMDresult PMDSetDeceleration(PMDAxisHandle* axis_handle, PMDuint32 deceleration)
{
    fd4a:	9a 01       	movw	r18, r20
    fd4c:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetDeceleration, deceleration);
    fd4e:	61 e9       	ldi	r22, 0x91	; 145
    fd50:	70 e0       	ldi	r23, 0x00	; 0
    fd52:	0e 94 af 82 	call	0x1055e	; 0x1055e <SendCommandLong>
}
    fd56:	08 95       	ret

0000fd58 <PMDSetAcceleration>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetStartVelocity, velocity);
}

PMDresult PMDSetAcceleration(PMDAxisHandle* axis_handle, PMDuint32 acceleration)
{
    fd58:	9a 01       	movw	r18, r20
    fd5a:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetAcceleration, acceleration);
    fd5c:	60 e9       	ldi	r22, 0x90	; 144
    fd5e:	70 e0       	ldi	r23, 0x00	; 0
    fd60:	0e 94 af 82 	call	0x1055e	; 0x1055e <SendCommandLong>
}
    fd64:	08 95       	ret

0000fd66 <PMDSetStartVelocity>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetVelocity, (PMDuint32*)velocity);
}

PMDresult PMDSetStartVelocity(PMDAxisHandle* axis_handle, PMDuint32 velocity)
{
    fd66:	9a 01       	movw	r18, r20
    fd68:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetStartVelocity, velocity);
    fd6a:	6a e6       	ldi	r22, 0x6A	; 106
    fd6c:	70 e0       	ldi	r23, 0x00	; 0
    fd6e:	0e 94 af 82 	call	0x1055e	; 0x1055e <SendCommandLong>
}
    fd72:	08 95       	ret

0000fd74 <PMDSetVelocity>:
{
	return SendCommandGetLong(axis_handle, PMDOPGetPosition, (PMDuint32*)position);
}

PMDresult PMDSetVelocity(PMDAxisHandle* axis_handle, PMDint32 velocity)
{
    fd74:	9a 01       	movw	r18, r20
    fd76:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetVelocity, velocity);
    fd78:	61 e1       	ldi	r22, 0x11	; 17
    fd7a:	70 e0       	ldi	r23, 0x00	; 0
    fd7c:	0e 94 af 82 	call	0x1055e	; 0x1055e <SendCommandLong>
}
    fd80:	08 95       	ret

0000fd82 <PMDSetPosition>:
{
	return SendCommandGetWord(axis_handle, PMDOPGetProfileMode, mode);
}

PMDresult PMDSetPosition(PMDAxisHandle* axis_handle, PMDint32 position)
{
    fd82:	9a 01       	movw	r18, r20
    fd84:	ab 01       	movw	r20, r22
	return SendCommandLong(axis_handle, PMDOPSetPosition, position);
    fd86:	60 e1       	ldi	r22, 0x10	; 16
    fd88:	70 e0       	ldi	r23, 0x00	; 0
    fd8a:	0e 94 af 82 	call	0x1055e	; 0x1055e <SendCommandLong>
}
    fd8e:	08 95       	ret

0000fd90 <Axis2PMDChipset>:


//**********************************************************************************************
int16 Axis2PMDChipset(tAxis Axis) 
{
	switch(Axis) 
    fd90:	84 30       	cpi	r24, 0x04	; 4
    fd92:	91 05       	cpc	r25, r1
    fd94:	4c f0       	brlt	.+18     	; 0xfda8 <Axis2PMDChipset+0x18>
    fd96:	88 30       	cpi	r24, 0x08	; 8
    fd98:	91 05       	cpc	r25, r1
    fd9a:	1c f0       	brlt	.+6      	; 0xfda2 <Axis2PMDChipset+0x12>
    fd9c:	0c 97       	sbiw	r24, 0x0c	; 12
    fd9e:	24 f4       	brge	.+8      	; 0xfda8 <Axis2PMDChipset+0x18>
    fda0:	06 c0       	rjmp	.+12     	; 0xfdae <Axis2PMDChipset+0x1e>
    fda2:	21 e0       	ldi	r18, 0x01	; 1
    fda4:	30 e0       	ldi	r19, 0x00	; 0
    fda6:	05 c0       	rjmp	.+10     	; 0xfdb2 <Axis2PMDChipset+0x22>
    fda8:	20 e0       	ldi	r18, 0x00	; 0
    fdaa:	30 e0       	ldi	r19, 0x00	; 0
    fdac:	02 c0       	rjmp	.+4      	; 0xfdb2 <Axis2PMDChipset+0x22>
    fdae:	22 e0       	ldi	r18, 0x02	; 2
    fdb0:	30 e0       	ldi	r19, 0x00	; 0
		case AxisAux7 			: 	return PMDChipSet3;       	// aux7
		
		default 					: 	return PMDChipSet1;
	}
  return PMDChipSet1;  // we must return something to avoid compiler warning
} // Axis2PMDChipset
    fdb2:	c9 01       	movw	r24, r18
    fdb4:	08 95       	ret

0000fdb6 <Axis2PMDAxis>:
//**********************************************************************************************
// mapping which (logical) axis is to find on which chipset axis:

int16 Axis2PMDAxis(tAxis Axis) 
{
	switch(Axis) 
    fdb6:	86 30       	cpi	r24, 0x06	; 6
    fdb8:	91 05       	cpc	r25, r1
    fdba:	39 f1       	breq	.+78     	; 0xfe0a <Axis2PMDAxis+0x54>
    fdbc:	87 30       	cpi	r24, 0x07	; 7
    fdbe:	91 05       	cpc	r25, r1
    fdc0:	7c f4       	brge	.+30     	; 0xfde0 <Axis2PMDAxis+0x2a>
    fdc2:	82 30       	cpi	r24, 0x02	; 2
    fdc4:	91 05       	cpc	r25, r1
    fdc6:	09 f1       	breq	.+66     	; 0xfe0a <Axis2PMDAxis+0x54>
    fdc8:	83 30       	cpi	r24, 0x03	; 3
    fdca:	91 05       	cpc	r25, r1
    fdcc:	1c f4       	brge	.+6      	; 0xfdd4 <Axis2PMDAxis+0x1e>
    fdce:	01 97       	sbiw	r24, 0x01	; 1
    fdd0:	c9 f4       	brne	.+50     	; 0xfe04 <Axis2PMDAxis+0x4e>
    fdd2:	15 c0       	rjmp	.+42     	; 0xfdfe <Axis2PMDAxis+0x48>
    fdd4:	83 30       	cpi	r24, 0x03	; 3
    fdd6:	91 05       	cpc	r25, r1
    fdd8:	d9 f0       	breq	.+54     	; 0xfe10 <Axis2PMDAxis+0x5a>
    fdda:	05 97       	sbiw	r24, 0x05	; 5
    fddc:	99 f4       	brne	.+38     	; 0xfe04 <Axis2PMDAxis+0x4e>
    fdde:	0f c0       	rjmp	.+30     	; 0xfdfe <Axis2PMDAxis+0x48>
    fde0:	89 30       	cpi	r24, 0x09	; 9
    fde2:	91 05       	cpc	r25, r1
    fde4:	61 f0       	breq	.+24     	; 0xfdfe <Axis2PMDAxis+0x48>
    fde6:	8a 30       	cpi	r24, 0x0A	; 10
    fde8:	91 05       	cpc	r25, r1
    fdea:	1c f4       	brge	.+6      	; 0xfdf2 <Axis2PMDAxis+0x3c>
    fdec:	07 97       	sbiw	r24, 0x07	; 7
    fdee:	51 f4       	brne	.+20     	; 0xfe04 <Axis2PMDAxis+0x4e>
    fdf0:	0f c0       	rjmp	.+30     	; 0xfe10 <Axis2PMDAxis+0x5a>
    fdf2:	8a 30       	cpi	r24, 0x0A	; 10
    fdf4:	91 05       	cpc	r25, r1
    fdf6:	49 f0       	breq	.+18     	; 0xfe0a <Axis2PMDAxis+0x54>
    fdf8:	0b 97       	sbiw	r24, 0x0b	; 11
    fdfa:	21 f4       	brne	.+8      	; 0xfe04 <Axis2PMDAxis+0x4e>
    fdfc:	09 c0       	rjmp	.+18     	; 0xfe10 <Axis2PMDAxis+0x5a>
    fdfe:	21 e0       	ldi	r18, 0x01	; 1
    fe00:	30 e0       	ldi	r19, 0x00	; 0
    fe02:	08 c0       	rjmp	.+16     	; 0xfe14 <Axis2PMDAxis+0x5e>
    fe04:	20 e0       	ldi	r18, 0x00	; 0
    fe06:	30 e0       	ldi	r19, 0x00	; 0
    fe08:	05 c0       	rjmp	.+10     	; 0xfe14 <Axis2PMDAxis+0x5e>
    fe0a:	22 e0       	ldi	r18, 0x02	; 2
    fe0c:	30 e0       	ldi	r19, 0x00	; 0
    fe0e:	02 c0       	rjmp	.+4      	; 0xfe14 <Axis2PMDAxis+0x5e>
    fe10:	23 e0       	ldi	r18, 0x03	; 3
    fe12:	30 e0       	ldi	r19, 0x00	; 0
		case AxisAux6 		: 	return PMDAxis3;       
		case AxisAux7 		: 	return PMDAxis4;      	
		default 			:   return PMDAxis1;
	}
  return PMDAxis1;  // we must return something
} // Axis2PMDAxis
    fe14:	c9 01       	movw	r24, r18
    fe16:	08 95       	ret

0000fe18 <PMDParallel_GetStatus>:
//********************************************************************************************************************


PMDuint16 PMDParallel_GetStatus(void* transport_data)
{
	PMDParallelIOTransportData* PIOtransport_data = (PMDParallelIOTransportData*)transport_data;
    fe18:	fc 01       	movw	r30, r24

	return PIOtransport_data->InPStatus(PIOtransport_data->dcs_Port);
    fe1a:	22 8d       	ldd	r18, Z+26	; 0x1a
    fe1c:	33 8d       	ldd	r19, Z+27	; 0x1b
    fe1e:	80 81       	ld	r24, Z
    fe20:	91 81       	ldd	r25, Z+1	; 0x01
    fe22:	f9 01       	movw	r30, r18
    fe24:	09 95       	icall
}
    fe26:	08 95       	ret

0000fe28 <PMDParallel_IsReady>:
	
//********************************************************************************************************************
PMDuint16 PMDParallel_IsReady(void* transport_data)
{
    fe28:	0f 93       	push	r16
    fe2a:	1f 93       	push	r17
	PMDParallelIOTransportData* PIOtransport_data = (PMDParallelIOTransportData*)transport_data;
    fe2c:	8c 01       	movw	r16, r24

	return ((PIOtransport_data->InPStatus(PIOtransport_data->dcs_Port)
    fe2e:	dc 01       	movw	r26, r24
    fe30:	5a 96       	adiw	r26, 0x1a	; 26
    fe32:	ed 91       	ld	r30, X+
    fe34:	fc 91       	ld	r31, X
    fe36:	5b 97       	sbiw	r26, 0x1b	; 27
    fe38:	8d 91       	ld	r24, X+
    fe3a:	9c 91       	ld	r25, X
    fe3c:	09 95       	icall
    fe3e:	40 e0       	ldi	r20, 0x00	; 0
    fe40:	50 e0       	ldi	r21, 0x00	; 0
    fe42:	f8 01       	movw	r30, r16
    fe44:	22 81       	ldd	r18, Z+2	; 0x02
    fe46:	33 81       	ldd	r19, Z+3	; 0x03
    fe48:	28 23       	and	r18, r24
    fe4a:	39 23       	and	r19, r25
    fe4c:	84 81       	ldd	r24, Z+4	; 0x04
    fe4e:	95 81       	ldd	r25, Z+5	; 0x05
    fe50:	28 17       	cp	r18, r24
    fe52:	39 07       	cpc	r19, r25
    fe54:	11 f4       	brne	.+4      	; 0xfe5a <PMDParallel_IsReady+0x32>
    fe56:	41 e0       	ldi	r20, 0x01	; 1
    fe58:	50 e0       	ldi	r21, 0x00	; 0
		& PIOtransport_data->readyMask) == PIOtransport_data->readyValue);
}
    fe5a:	ca 01       	movw	r24, r20
    fe5c:	1f 91       	pop	r17
    fe5e:	0f 91       	pop	r16
    fe60:	08 95       	ret

0000fe62 <PMDParallel_HasInterrupt>:

//********************************************************************************************************************				 
PMDuint16 PMDParallel_HasInterrupt(void* transport_data)
{
    fe62:	0f 93       	push	r16
    fe64:	1f 93       	push	r17
	PMDParallelIOTransportData* PIOtransport_data = (PMDParallelIOTransportData*)transport_data;
    fe66:	8c 01       	movw	r16, r24

	return ((PIOtransport_data->InPStatus(PIOtransport_data->dcs_Port) 
    fe68:	dc 01       	movw	r26, r24
    fe6a:	5a 96       	adiw	r26, 0x1a	; 26
    fe6c:	ed 91       	ld	r30, X+
    fe6e:	fc 91       	ld	r31, X
    fe70:	5b 97       	sbiw	r26, 0x1b	; 27
    fe72:	8d 91       	ld	r24, X+
    fe74:	9c 91       	ld	r25, X
    fe76:	09 95       	icall
    fe78:	40 e0       	ldi	r20, 0x00	; 0
    fe7a:	50 e0       	ldi	r21, 0x00	; 0
    fe7c:	f8 01       	movw	r30, r16
    fe7e:	26 81       	ldd	r18, Z+6	; 0x06
    fe80:	37 81       	ldd	r19, Z+7	; 0x07
    fe82:	28 23       	and	r18, r24
    fe84:	39 23       	and	r19, r25
    fe86:	80 85       	ldd	r24, Z+8	; 0x08
    fe88:	91 85       	ldd	r25, Z+9	; 0x09
    fe8a:	28 17       	cp	r18, r24
    fe8c:	39 07       	cpc	r19, r25
    fe8e:	11 f4       	brne	.+4      	; 0xfe94 <PMDParallel_HasInterrupt+0x32>
    fe90:	41 e0       	ldi	r20, 0x01	; 1
    fe92:	50 e0       	ldi	r21, 0x00	; 0
		& PIOtransport_data->hostInterruptMask) == PIOtransport_data->hostInterruptValue);
}
    fe94:	ca 01       	movw	r24, r20
    fe96:	1f 91       	pop	r17
    fe98:	0f 91       	pop	r16
    fe9a:	08 95       	ret

0000fe9c <PMDParallel_HasError>:
		
//********************************************************************************************************************
PMDuint16 PMDParallel_HasError(void* transport_data)
{
    fe9c:	0f 93       	push	r16
    fe9e:	1f 93       	push	r17
	PMDParallelIOTransportData* PIOtransport_data = (PMDParallelIOTransportData*)transport_data;
    fea0:	8c 01       	movw	r16, r24

	return ((PIOtransport_data->InPStatus(PIOtransport_data->dcs_Port) 
    fea2:	dc 01       	movw	r26, r24
    fea4:	5a 96       	adiw	r26, 0x1a	; 26
    fea6:	ed 91       	ld	r30, X+
    fea8:	fc 91       	ld	r31, X
    feaa:	5b 97       	sbiw	r26, 0x1b	; 27
    feac:	8d 91       	ld	r24, X+
    feae:	9c 91       	ld	r25, X
    feb0:	09 95       	icall
    feb2:	40 e0       	ldi	r20, 0x00	; 0
    feb4:	50 e0       	ldi	r21, 0x00	; 0
    feb6:	f8 01       	movw	r30, r16
    feb8:	22 85       	ldd	r18, Z+10	; 0x0a
    feba:	33 85       	ldd	r19, Z+11	; 0x0b
    febc:	28 23       	and	r18, r24
    febe:	39 23       	and	r19, r25
    fec0:	84 85       	ldd	r24, Z+12	; 0x0c
    fec2:	95 85       	ldd	r25, Z+13	; 0x0d
    fec4:	28 17       	cp	r18, r24
    fec6:	39 07       	cpc	r19, r25
    fec8:	11 f4       	brne	.+4      	; 0xfece <PMDParallel_HasError+0x32>
    feca:	41 e0       	ldi	r20, 0x01	; 1
    fecc:	50 e0       	ldi	r21, 0x00	; 0
		& PIOtransport_data->commandStatusMask) == PIOtransport_data->commandStatusValue);
}
    fece:	ca 01       	movw	r24, r20
    fed0:	1f 91       	pop	r17
    fed2:	0f 91       	pop	r16
    fed4:	08 95       	ret

0000fed6 <PMDParallel_HardReset>:
{

    PMDParallelIOTransportData* PIOtransport_data = (PMDParallelIOTransportData*)transport_data;
	//le debe de entar transport_data por que proviene 
	//de una axis ya inicualizada correctamente
	PIOtransport_data->Hard();
    fed6:	dc 01       	movw	r26, r24
    fed8:	56 96       	adiw	r26, 0x16	; 22
    feda:	ed 91       	ld	r30, X+
    fedc:	fc 91       	ld	r31, X
    fede:	57 97       	sbiw	r26, 0x17	; 23
    fee0:	09 95       	icall
 
    return PMD_NOERROR;
    
}
    fee2:	80 e0       	ldi	r24, 0x00	; 0
    fee4:	90 e0       	ldi	r25, 0x00	; 0
    fee6:	08 95       	ret

0000fee8 <PMDParallel_InitData>:
{
    free(transport_data);
}	
//********************************************************************************************************************				 	 
void PMDParallel_InitData(PMDParallelIOTransportData* transport_data, int16 IOMode)
{
    fee8:	fc 01       	movw	r30, r24
	// assign default values


	transport_data->readyMask = 0x8000;
    feea:	80 e0       	ldi	r24, 0x00	; 0
    feec:	90 e8       	ldi	r25, 0x80	; 128
    feee:	93 83       	std	Z+3, r25	; 0x03
    fef0:	82 83       	std	Z+2, r24	; 0x02
	transport_data->readyValue = 0x8000;
    fef2:	95 83       	std	Z+5, r25	; 0x05
    fef4:	84 83       	std	Z+4, r24	; 0x04
	transport_data->hostInterruptMask = 0x4000;
    fef6:	80 e0       	ldi	r24, 0x00	; 0
    fef8:	90 e4       	ldi	r25, 0x40	; 64
    fefa:	97 83       	std	Z+7, r25	; 0x07
    fefc:	86 83       	std	Z+6, r24	; 0x06
	transport_data->hostInterruptValue = 0x4000;
    fefe:	91 87       	std	Z+9, r25	; 0x09
    ff00:	80 87       	std	Z+8, r24	; 0x08
	transport_data->commandStatusMask = 0x2000;
    ff02:	80 e0       	ldi	r24, 0x00	; 0
    ff04:	90 e2       	ldi	r25, 0x20	; 32
    ff06:	93 87       	std	Z+11, r25	; 0x0b
    ff08:	82 87       	std	Z+10, r24	; 0x0a
	transport_data->commandStatusValue = 0x2000;
    ff0a:	95 87       	std	Z+13, r25	; 0x0d
    ff0c:	84 87       	std	Z+12, r24	; 0x0c

	// by default always verify the checksum
	transport_data->bVerifyChecksum = 1;
    ff0e:	81 e0       	ldi	r24, 0x01	; 1
    ff10:	90 e0       	ldi	r25, 0x00	; 0
    ff12:	97 87       	std	Z+15, r25	; 0x0f
    ff14:	86 87       	std	Z+14, r24	; 0x0e
	// by default disable diagnostics
	// Modificado por David
	// Activo los diagnosticos
	transport_data->bDiagnostics = 1;
    ff16:	91 8b       	std	Z+17, r25	; 0x11
    ff18:	80 8b       	std	Z+16, r24	; 0x10

	// assign default handlers/masks according to IO mode
	switch (IOMode)
    ff1a:	61 30       	cpi	r22, 0x01	; 1
    ff1c:	71 05       	cpc	r23, r1
    ff1e:	a1 f4       	brne	.+40     	; 0xff48 <PMDParallel_InitData+0x60>
	{
	case PMDParallelIOMode_8_16:
		transport_data->OutPData = OutP8Bit ;
    ff20:	82 e2       	ldi	r24, 0x22	; 34
    ff22:	92 e8       	ldi	r25, 0x82	; 130
    ff24:	93 8b       	std	Z+19, r25	; 0x13
    ff26:	82 8b       	std	Z+18, r24	; 0x12
		transport_data->OutPCmd = OutP8BitCmd;
    ff28:	8f e1       	ldi	r24, 0x1F	; 31
    ff2a:	92 e8       	ldi	r25, 0x82	; 130
    ff2c:	95 8b       	std	Z+21, r25	; 0x15
    ff2e:	84 8b       	std	Z+20, r24	; 0x14
		transport_data->InPData = InP8Bit;
    ff30:	8c e1       	ldi	r24, 0x1C	; 28
    ff32:	92 e8       	ldi	r25, 0x82	; 130
    ff34:	91 8f       	std	Z+25, r25	; 0x19
    ff36:	80 8f       	std	Z+24, r24	; 0x18
		transport_data->InPStatus = InP8BitStatus;
    ff38:	89 e1       	ldi	r24, 0x19	; 25
    ff3a:	92 e8       	ldi	r25, 0x82	; 130
    ff3c:	93 8f       	std	Z+27, r25	; 0x1b
    ff3e:	82 8f       	std	Z+26, r24	; 0x1a
		transport_data->Hard = OutP8BitHard;
    ff40:	86 e1       	ldi	r24, 0x16	; 22
    ff42:	92 e8       	ldi	r25, 0x82	; 130
    ff44:	97 8b       	std	Z+23, r25	; 0x17
    ff46:	86 8b       	std	Z+22, r24	; 0x16
    ff48:	08 95       	ret

0000ff4a <PMDParallel_Init>:
}


//********************************************************************************************************************				 	 
void PMDParallel_Init(PMDIOTransport* transport)
{
    ff4a:	fc 01       	movw	r30, r24
	// setup function pointers
	transport->SendCommand = PMDParallel_Send;
    ff4c:	8d e5       	ldi	r24, 0x5D	; 93
    ff4e:	90 e8       	ldi	r25, 0x80	; 128
    ff50:	91 83       	std	Z+1, r25	; 0x01
    ff52:	80 83       	st	Z, r24
	transport->GetStatus = PMDParallel_GetStatus;
    ff54:	8c e0       	ldi	r24, 0x0C	; 12
    ff56:	9f e7       	ldi	r25, 0x7F	; 127
    ff58:	95 83       	std	Z+5, r25	; 0x05
    ff5a:	84 83       	std	Z+4, r24	; 0x04
	transport->IsReady = PMDParallel_IsReady;
    ff5c:	84 e1       	ldi	r24, 0x14	; 20
    ff5e:	9f e7       	ldi	r25, 0x7F	; 127
    ff60:	97 83       	std	Z+7, r25	; 0x07
    ff62:	86 83       	std	Z+6, r24	; 0x06
	transport->HasInterrupt = PMDParallel_HasInterrupt;
    ff64:	81 e3       	ldi	r24, 0x31	; 49
    ff66:	9f e7       	ldi	r25, 0x7F	; 127
    ff68:	91 87       	std	Z+9, r25	; 0x09
    ff6a:	80 87       	std	Z+8, r24	; 0x08
	transport->HasError = PMDParallel_HasError;
    ff6c:	8e e4       	ldi	r24, 0x4E	; 78
    ff6e:	9f e7       	ldi	r25, 0x7F	; 127
    ff70:	93 87       	std	Z+11, r25	; 0x0b
    ff72:	82 87       	std	Z+10, r24	; 0x0a
  	transport->HardReset = PMDParallel_HardReset;
    ff74:	8b e6       	ldi	r24, 0x6B	; 107
    ff76:	9f e7       	ldi	r25, 0x7F	; 127
    ff78:	95 87       	std	Z+13, r25	; 0x0d
    ff7a:	84 87       	std	Z+12, r24	; 0x0c

	transport->Close = PMDParallel_Close;
    ff7c:	8e ef       	ldi	r24, 0xFE	; 254
    ff7e:	9f e7       	ldi	r25, 0x7F	; 127
    ff80:	93 83       	std	Z+3, r25	; 0x03
    ff82:	82 83       	std	Z+2, r24	; 0x02
} 
    ff84:	08 95       	ret

0000ff86 <PMDSetupAxisInterface_Parallel>:

//********************************************************************************************************************	

PMDuint16 PMDSetupAxisInterface_Parallel(PMDAxisHandle* axis_handle, PMDAxis axis_number, PMDuint16 PMDChipSet)
{
    ff86:	cf 92       	push	r12
    ff88:	df 92       	push	r13
    ff8a:	ef 92       	push	r14
    ff8c:	ff 92       	push	r15
    ff8e:	0f 93       	push	r16
    ff90:	1f 93       	push	r17
    ff92:	cf 93       	push	r28
    ff94:	df 93       	push	r29
    ff96:	8c 01       	movw	r16, r24
    ff98:	6b 01       	movw	r12, r22
    ff9a:	7a 01       	movw	r14, r20
	PMDParallelIOTransportData* transport_data;
	
	
	transport_data = (PMDParallelIOTransportData*) malloc( sizeof( PMDParallelIOTransportData ) );
    ff9c:	8c e1       	ldi	r24, 0x1C	; 28
    ff9e:	90 e0       	ldi	r25, 0x00	; 0
    ffa0:	0e 94 cb 9c 	call	0x13996	; 0x13996 <malloc>
    ffa4:	ec 01       	movw	r28, r24
	memset(transport_data, 0, sizeof(PMDParallelIOTransportData));
    ffa6:	8c e1       	ldi	r24, 0x1C	; 28
    ffa8:	fe 01       	movw	r30, r28
    ffaa:	11 92       	st	Z+, r1
    ffac:	8a 95       	dec	r24
    ffae:	e9 f7       	brne	.-6      	; 0xffaa <PMDSetupAxisInterface_Parallel+0x24>
    
	if(transport_data == 0) return rcNoMemory;  // check if operation succeeded
    ffb0:	20 97       	sbiw	r28, 0x00	; 0
    ffb2:	19 f4       	brne	.+6      	; 0xffba <PMDSetupAxisInterface_Parallel+0x34>
    ffb4:	28 e0       	ldi	r18, 0x08	; 8
    ffb6:	30 e0       	ldi	r19, 0x00	; 0
    ffb8:	17 c0       	rjmp	.+46     	; 0xffe8 <PMDSetupAxisInterface_Parallel+0x62>

	// set the axis we are talking to with this handle
	axis_handle->axis = axis_number;
    ffba:	f8 01       	movw	r30, r16
    ffbc:	d3 82       	std	Z+3, r13	; 0x03
    ffbe:	c2 82       	std	Z+2, r12	; 0x02
	

	// if required the transport data defaults can be changed here
	// e.g. board IO address (dataPort,commandPort,statusPort)
	//transport_data->dataPort = board_address;
	transport_data->dcs_Port = PMDChipSet;  // actual port is treated in low-level function in basicIO.h
    ffc0:	f9 82       	std	Y+1, r15	; 0x01
    ffc2:	e8 82       	st	Y, r14
	axis_handle->chipset=PMDChipSet;
    ffc4:	f1 82       	std	Z+1, r15	; 0x01
    ffc6:	e0 82       	st	Z, r14

	// the transport data is initialized first to setup the defaults
	// make sure the IO mode is set correctly
	PMDParallel_InitData(transport_data, PMDParallelIOMode_8_16);
    ffc8:	ce 01       	movw	r24, r28
    ffca:	61 e0       	ldi	r22, 0x01	; 1
    ffcc:	70 e0       	ldi	r23, 0x00	; 0
    ffce:	0e 94 74 7f 	call	0xfee8	; 0xfee8 <PMDParallel_InitData>

	axis_handle->transport_data = (void*) transport_data;
    ffd2:	02 5a       	subi	r16, 0xA2	; 162
    ffd4:	1f 4f       	sbci	r17, 0xFF	; 255
    ffd6:	f8 01       	movw	r30, r16
    ffd8:	d1 83       	std	Z+1, r29	; 0x01
    ffda:	c0 83       	st	Z, r28

	// initialize the transport (inits function pointers)
	PMDParallel_Init(&axis_handle->transport);
    ffdc:	c8 01       	movw	r24, r16
    ffde:	0e 97       	sbiw	r24, 0x0e	; 14
    ffe0:	0e 94 a5 7f 	call	0xff4a	; 0xff4a <PMDParallel_Init>
    ffe4:	20 e0       	ldi	r18, 0x00	; 0
    ffe6:	30 e0       	ldi	r19, 0x00	; 0

 return rcOK;
}
    ffe8:	c9 01       	movw	r24, r18
    ffea:	df 91       	pop	r29
    ffec:	cf 91       	pop	r28
    ffee:	1f 91       	pop	r17
    fff0:	0f 91       	pop	r16
    fff2:	ff 90       	pop	r15
    fff4:	ef 90       	pop	r14
    fff6:	df 90       	pop	r13
    fff8:	cf 90       	pop	r12
    fffa:	08 95       	ret

0000fffc <PMDParallel_Close>:


//********************************************************************************************************************				 	 
void PMDParallel_Close(void* transport_data)
{
    free(transport_data);
    fffc:	0e 94 78 9d 	call	0x13af0	; 0x13af0 <free>
}	
   10000:	08 95       	ret

00010002 <PMDParallel_WaitForReady>:
//********************************************************************************************************************				 	
//Esta Funcion Verifica que el Dato retornado por la Funcion Read_Status_Register contenga en el Bit 15 
//(HostRdy signal) un Valor igual a 1, indicando al HOST que El PMD esta Listo para Operaciones.

PMDuint16 PMDParallel_WaitForReady(PMDParallelIOTransportData* transport_data)
{
   10002:	0f 93       	push	r16
   10004:	1f 93       	push	r17
   10006:	cf 93       	push	r28
   10008:	df 93       	push	r29
   1000a:	ec 01       	movw	r28, r24
   1000c:	00 ee       	ldi	r16, 0xE0	; 224
   1000e:	1e e2       	ldi	r17, 0x2E	; 46
  		timer 		= 12000; 																      
		
		for(;;) 
		{
			// poll ready port, if not ready, loop
    		in_val = transport_data->InPStatus(transport_data->dcs_Port);
   10010:	ea 8d       	ldd	r30, Y+26	; 0x1a
   10012:	fb 8d       	ldd	r31, Y+27	; 0x1b
   10014:	88 81       	ld	r24, Y
   10016:	99 81       	ldd	r25, Y+1	; 0x01
   10018:	09 95       	icall
   1001a:	9c 01       	movw	r18, r24
    		if ((in_val != 0xFFFF) && ((in_val & transport_data->readyMask) == transport_data->readyValue))
   1001c:	8f ef       	ldi	r24, 0xFF	; 255
   1001e:	2f 3f       	cpi	r18, 0xFF	; 255
   10020:	38 07       	cpc	r19, r24
   10022:	61 f0       	breq	.+24     	; 0x1003c <PMDParallel_WaitForReady+0x3a>
   10024:	8a 81       	ldd	r24, Y+2	; 0x02
   10026:	9b 81       	ldd	r25, Y+3	; 0x03
   10028:	82 23       	and	r24, r18
   1002a:	93 23       	and	r25, r19
   1002c:	2c 81       	ldd	r18, Y+4	; 0x04
   1002e:	3d 81       	ldd	r19, Y+5	; 0x05
   10030:	82 17       	cp	r24, r18
   10032:	93 07       	cpc	r25, r19
   10034:	19 f4       	brne	.+6      	; 0x1003c <PMDParallel_WaitForReady+0x3a>
   10036:	20 e0       	ldi	r18, 0x00	; 0
   10038:	30 e0       	ldi	r19, 0x00	; 0
   1003a:	0c c0       	rjmp	.+24     	; 0x10054 <PMDParallel_WaitForReady+0x52>
				return PMD_ERR_OK;
			else// not ready 
			{ 
				timer--;
   1003c:	01 50       	subi	r16, 0x01	; 1
   1003e:	10 40       	sbci	r17, 0x00	; 0
				if(timer == 0) 
   10040:	39 f7       	brne	.-50     	; 0x10010 <PMDParallel_WaitForReady+0xe>
				{
					/* se enciende el LED Rojo*/
					Led_on(Rojo);
   10042:	81 e0       	ldi	r24, 0x01	; 1
   10044:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
					printf("PMDParallel_WaitForReady=> 40ms Timeout Error\n");
   10048:	8a ef       	ldi	r24, 0xFA	; 250
   1004a:	9d e6       	ldi	r25, 0x6D	; 109
   1004c:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
   10050:	2d ef       	ldi	r18, 0xFD	; 253
   10052:	3f e7       	ldi	r19, 0x7F	; 127
        if ((in_val != 0xFFFF) 
			&& ((in_val & transport_data->readyMask) == transport_data->readyValue))
                return PMD_ERR_OK;
    }
#endif
} 
   10054:	c9 01       	movw	r24, r18
   10056:	df 91       	pop	r29
   10058:	cf 91       	pop	r28
   1005a:	1f 91       	pop	r17
   1005c:	0f 91       	pop	r16
   1005e:	08 95       	ret

00010060 <PMDParallel_GetCommandStatus>:
//********************************************************************************************************************				 	
// wait for the PMDs to be ready for the next command
PMDuint16 PMDParallel_GetCommandStatus(PMDParallelIOTransportData* transport_data)
{
   10060:	0f 93       	push	r16
   10062:	1f 93       	push	r17
   10064:	cf 93       	push	r28
   10066:	df 93       	push	r29
   10068:	ec 01       	movw	r28, r24
	PMDuint16 result;
	int16     in_val;

	if((result = PMDParallel_WaitForReady(transport_data)) != PMD_ERR_OK)
   1006a:	0e 94 01 80 	call	0x10002	; 0x10002 <PMDParallel_WaitForReady>
   1006e:	8c 01       	movw	r16, r24
   10070:	00 97       	sbiw	r24, 0x00	; 0
   10072:	29 f0       	breq	.+10     	; 0x1007e <PMDParallel_GetCommandStatus+0x1e>
	{
	    printf("PMDParallel_GetCommandStatus=> Wait Status Register Timeout \n");    
   10074:	88 e2       	ldi	r24, 0x28	; 40
   10076:	9e e6       	ldi	r25, 0x6E	; 110
   10078:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
   1007c:	18 c0       	rjmp	.+48     	; 0x100ae <PMDParallel_GetCommandStatus+0x4e>

	//En este punto Verifica que el Dato retornado por la Funcion Read_Status_Register contenga en el Bit 13 
	//(HostIOError signal) un Valor igual a 1, indicando  que El PMD contiene un HOST I/O Error (ver seccion 
	//10.3.3 del Manual de Usuario). 
	
	in_val = transport_data->InPStatus(transport_data->dcs_Port);
   1007e:	ea 8d       	ldd	r30, Y+26	; 0x1a
   10080:	fb 8d       	ldd	r31, Y+27	; 0x1b
   10082:	88 81       	ld	r24, Y
   10084:	99 81       	ldd	r25, Y+1	; 0x01
   10086:	09 95       	icall
	if ((in_val & transport_data->commandStatusMask) == transport_data->commandStatusValue)
   10088:	2a 85       	ldd	r18, Y+10	; 0x0a
   1008a:	3b 85       	ldd	r19, Y+11	; 0x0b
   1008c:	28 23       	and	r18, r24
   1008e:	39 23       	and	r19, r25
   10090:	8c 85       	ldd	r24, Y+12	; 0x0c
   10092:	9d 85       	ldd	r25, Y+13	; 0x0d
   10094:	28 17       	cp	r18, r24
   10096:	39 07       	cpc	r19, r25
   10098:	51 f4       	brne	.+20     	; 0x100ae <PMDParallel_GetCommandStatus+0x4e>
	{
		if (transport_data->bDiagnostics)
   1009a:	88 89       	ldd	r24, Y+16	; 0x10
   1009c:	99 89       	ldd	r25, Y+17	; 0x11
   1009e:	89 2b       	or	r24, r25
   100a0:	21 f0       	breq	.+8      	; 0x100aa <PMDParallel_GetCommandStatus+0x4a>
				printf("PMDParallel_GetCommandStatus=> C-Motion: Command Error bit set.\n");
   100a2:	85 e6       	ldi	r24, 0x65	; 101
   100a4:	9e e6       	ldi	r25, 0x6E	; 110
   100a6:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
   100aa:	0f ef       	ldi	r16, 0xFF	; 255
   100ac:	1f e7       	ldi	r17, 0x7F	; 127
		return PMD_ERR_CommandError;
	}
	return PMD_ERR_OK;
} 
   100ae:	c8 01       	movw	r24, r16
   100b0:	df 91       	pop	r29
   100b2:	cf 91       	pop	r28
   100b4:	1f 91       	pop	r17
   100b6:	0f 91       	pop	r16
   100b8:	08 95       	ret

000100ba <PMDParallel_Send>:

//result=MD_ERR_CommTimeoutError o  PMD_ERR_OK

PMDuint16 PMDParallel_Send(PMDParallelIOTransportData* transport_data, 
							  PMDuint8 xCt, PMDuint16* xDat, PMDuint8 rCt, PMDuint16* rDat)
{
   100ba:	2f 92       	push	r2
   100bc:	3f 92       	push	r3
   100be:	4f 92       	push	r4
   100c0:	5f 92       	push	r5
   100c2:	6f 92       	push	r6
   100c4:	7f 92       	push	r7
   100c6:	8f 92       	push	r8
   100c8:	9f 92       	push	r9
   100ca:	af 92       	push	r10
   100cc:	bf 92       	push	r11
   100ce:	cf 92       	push	r12
   100d0:	df 92       	push	r13
   100d2:	ef 92       	push	r14
   100d4:	ff 92       	push	r15
   100d6:	0f 93       	push	r16
   100d8:	1f 93       	push	r17
   100da:	df 93       	push	r29
   100dc:	cf 93       	push	r28
   100de:	cd b7       	in	r28, 0x3d	; 61
   100e0:	de b7       	in	r29, 0x3e	; 62
   100e2:	27 97       	sbiw	r28, 0x07	; 7
   100e4:	0f b6       	in	r0, 0x3f	; 63
   100e6:	f8 94       	cli
   100e8:	de bf       	out	0x3e, r29	; 62
   100ea:	0f be       	out	0x3f, r0	; 63
   100ec:	cd bf       	out	0x3d, r28	; 61
   100ee:	6c 01       	movw	r12, r24
   100f0:	6d 83       	std	Y+5, r22	; 0x05
   100f2:	2a 01       	movw	r4, r20
   100f4:	32 2e       	mov	r3, r18
   100f6:	70 2e       	mov	r7, r16
   100f8:	61 2e       	mov	r6, r17

    PMDuint16 result;
	PMDuint16 commandstatus = PMD_ERR_OK;
    PMDuint16 index;
    long messageChecksum=0;
    PMDuint16 chipsetChecksum=0;
   100fa:	1a 82       	std	Y+2, r1	; 0x02
   100fc:	19 82       	std	Y+1, r1	; 0x01

	result=PMD_ERR_PMDNotInitialized;
///////////////////////////////ESCRIBE UN COMANDO/////////////////////////////////////////  
    if((result = PMDParallel_WaitForReady(transport_data)) == PMD_ERR_OK) //Esta readey
   100fe:	0e 94 01 80 	call	0x10002	; 0x10002 <PMDParallel_WaitForReady>
   10102:	5c 01       	movw	r10, r24
   10104:	00 97       	sbiw	r24, 0x00	; 0
   10106:	91 f5       	brne	.+100    	; 0x1016c <PMDParallel_Send+0xb2>
    {  
		// put the command into the PMD1/PMD2/PMD3
		transport_data->OutPCmd(transport_data->dcs_Port, xDat[0]);
   10108:	d2 01       	movw	r26, r4
   1010a:	6d 91       	ld	r22, X+
   1010c:	7c 91       	ld	r23, X
   1010e:	d6 01       	movw	r26, r12
   10110:	54 96       	adiw	r26, 0x14	; 20
   10112:	ed 91       	ld	r30, X+
   10114:	fc 91       	ld	r31, X
   10116:	55 97       	sbiw	r26, 0x15	; 21
   10118:	8d 91       	ld	r24, X+
   1011a:	9c 91       	ld	r25, X
   1011c:	09 95       	icall
   1011e:	72 01       	movw	r14, r4
   10120:	01 e0       	ldi	r16, 0x01	; 1
   10122:	10 e0       	ldi	r17, 0x00	; 0
		
		// put the data into the PMD1/PMD2/PMD3
		// one word at a time
        for(index=1; index<xCt; index++)
   10124:	bd 81       	ldd	r27, Y+5	; 0x05
   10126:	8b 2e       	mov	r8, r27
   10128:	99 24       	eor	r9, r9
   1012a:	18 c0       	rjmp	.+48     	; 0x1015c <PMDParallel_Send+0xa2>
        {
			if((result = PMDParallel_WaitForReady(transport_data)) != PMD_ERR_OK)
   1012c:	c6 01       	movw	r24, r12
   1012e:	0e 94 01 80 	call	0x10002	; 0x10002 <PMDParallel_WaitForReady>
   10132:	e2 e0       	ldi	r30, 0x02	; 2
   10134:	f0 e0       	ldi	r31, 0x00	; 0
   10136:	ee 0e       	add	r14, r30
   10138:	ff 1e       	adc	r15, r31
   1013a:	00 97       	sbiw	r24, 0x00	; 0
   1013c:	11 f0       	breq	.+4      	; 0x10142 <PMDParallel_Send+0x88>
   1013e:	5c 01       	movw	r10, r24
   10140:	19 c0       	rjmp	.+50     	; 0x10174 <PMDParallel_Send+0xba>
				break;
			
			transport_data->OutPData(transport_data->dcs_Port,xDat[index]);
   10142:	d7 01       	movw	r26, r14
   10144:	6d 91       	ld	r22, X+
   10146:	7c 91       	ld	r23, X
   10148:	d6 01       	movw	r26, r12
   1014a:	52 96       	adiw	r26, 0x12	; 18
   1014c:	ed 91       	ld	r30, X+
   1014e:	fc 91       	ld	r31, X
   10150:	53 97       	sbiw	r26, 0x13	; 19
   10152:	8d 91       	ld	r24, X+
   10154:	9c 91       	ld	r25, X
   10156:	09 95       	icall
		// put the command into the PMD1/PMD2/PMD3
		transport_data->OutPCmd(transport_data->dcs_Port, xDat[0]);
		
		// put the data into the PMD1/PMD2/PMD3
		// one word at a time
        for(index=1; index<xCt; index++)
   10158:	0f 5f       	subi	r16, 0xFF	; 255
   1015a:	1f 4f       	sbci	r17, 0xFF	; 255
   1015c:	08 15       	cp	r16, r8
   1015e:	19 05       	cpc	r17, r9
   10160:	28 f3       	brcs	.-54     	; 0x1012c <PMDParallel_Send+0x72>
			
			transport_data->OutPData(transport_data->dcs_Port,xDat[index]);
        }
		
		if(result == PMD_ERR_OK)
			commandstatus = PMDParallel_GetCommandStatus(transport_data);
   10162:	c6 01       	movw	r24, r12
   10164:	0e 94 30 80 	call	0x10060	; 0x10060 <PMDParallel_GetCommandStatus>
   10168:	4c 01       	movw	r8, r24
   1016a:	06 c0       	rjmp	.+12     	; 0x10178 <PMDParallel_Send+0xbe>
		
		
    }
	else
	   printf("PMDParallel_Send=> Error Envio Datos o Comando \n");    
   1016c:	85 ea       	ldi	r24, 0xA5	; 165
   1016e:	9e e6       	ldi	r25, 0x6E	; 110
   10170:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
   10174:	88 24       	eor	r8, r8
   10176:	99 24       	eor	r9, r9
   10178:	87 2d       	mov	r24, r7
   1017a:	96 2d       	mov	r25, r6
   1017c:	9c 01       	movw	r18, r24
   1017e:	39 01       	movw	r6, r18
   10180:	79 01       	movw	r14, r18
   10182:	00 e0       	ldi	r16, 0x00	; 0
   10184:	10 e0       	ldi	r17, 0x00	; 0
	//no tiene sentido que halla error seguido de un reset.
	
	
	/////////////////////////////LEE DATOS //////////////////////////////
    // get the data from the DK2000
    for(index=0; index<rCt; index++)
   10186:	23 2c       	mov	r2, r3
   10188:	33 24       	eor	r3, r3
   1018a:	19 c0       	rjmp	.+50     	; 0x101be <PMDParallel_Send+0x104>
    {
        if((result = PMDParallel_WaitForReady(transport_data)) != PMD_ERR_OK)
   1018c:	c6 01       	movw	r24, r12
   1018e:	0e 94 01 80 	call	0x10002	; 0x10002 <PMDParallel_WaitForReady>
   10192:	5c 01       	movw	r10, r24
   10194:	00 97       	sbiw	r24, 0x00	; 0
   10196:	29 f0       	breq	.+10     	; 0x101a2 <PMDParallel_Send+0xe8>
	    {
	       printf("PMDParallel_Send=> Error datos recibidos\n");    
   10198:	85 ed       	ldi	r24, 0xD5	; 213
   1019a:	9e e6       	ldi	r25, 0x6E	; 110
   1019c:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
   101a0:	11 c0       	rjmp	.+34     	; 0x101c4 <PMDParallel_Send+0x10a>
          break;
		} 
        
		rDat[index] = transport_data->InPData(transport_data->dcs_Port);
   101a2:	d6 01       	movw	r26, r12
   101a4:	58 96       	adiw	r26, 0x18	; 24
   101a6:	ed 91       	ld	r30, X+
   101a8:	fc 91       	ld	r31, X
   101aa:	59 97       	sbiw	r26, 0x19	; 25
   101ac:	8d 91       	ld	r24, X+
   101ae:	9c 91       	ld	r25, X
   101b0:	09 95       	icall
   101b2:	f7 01       	movw	r30, r14
   101b4:	81 93       	st	Z+, r24
   101b6:	91 93       	st	Z+, r25
   101b8:	7f 01       	movw	r14, r30
	//no tiene sentido que halla error seguido de un reset.
	
	
	/////////////////////////////LEE DATOS //////////////////////////////
    // get the data from the DK2000
    for(index=0; index<rCt; index++)
   101ba:	0f 5f       	subi	r16, 0xFF	; 255
   101bc:	1f 4f       	sbci	r17, 0xFF	; 255
   101be:	02 15       	cp	r16, r2
   101c0:	13 05       	cpc	r17, r3
   101c2:	20 f3       	brcs	.-56     	; 0x1018c <PMDParallel_Send+0xd2>
		} 
        
		rDat[index] = transport_data->InPData(transport_data->dcs_Port);
    }
///////////////////////////VERIFICACIONES/////////////////////////////////    
    if(transport_data->bVerifyChecksum)
   101c4:	d6 01       	movw	r26, r12
   101c6:	1e 96       	adiw	r26, 0x0e	; 14
   101c8:	8d 91       	ld	r24, X+
   101ca:	9c 91       	ld	r25, X
   101cc:	1f 97       	sbiw	r26, 0x0f	; 15
   101ce:	89 2b       	or	r24, r25
   101d0:	09 f4       	brne	.+2      	; 0x101d4 <PMDParallel_Send+0x11a>
   101d2:	c2 c0       	rjmp	.+388    	; 0x10358 <PMDParallel_Send+0x29e>
   101d4:	5c 82       	std	Y+4, r5	; 0x04
   101d6:	4b 82       	std	Y+3, r4	; 0x03
   101d8:	f2 01       	movw	r30, r4
   101da:	20 e0       	ldi	r18, 0x00	; 0
   101dc:	30 e0       	ldi	r19, 0x00	; 0
   101de:	ee 24       	eor	r14, r14
   101e0:	ff 24       	eor	r15, r15
   101e2:	87 01       	movw	r16, r14
	{
		for(index=0; index<xCt; index++)
   101e4:	9d 81       	ldd	r25, Y+5	; 0x05
   101e6:	89 2f       	mov	r24, r25
   101e8:	90 e0       	ldi	r25, 0x00	; 0
   101ea:	9f 83       	std	Y+7, r25	; 0x07
   101ec:	8e 83       	std	Y+6, r24	; 0x06
   101ee:	0a c0       	rjmp	.+20     	; 0x10204 <PMDParallel_Send+0x14a>
			messageChecksum += xDat[index];
   101f0:	81 91       	ld	r24, Z+
   101f2:	91 91       	ld	r25, Z+
   101f4:	a0 e0       	ldi	r26, 0x00	; 0
   101f6:	b0 e0       	ldi	r27, 0x00	; 0
   101f8:	e8 0e       	add	r14, r24
   101fa:	f9 1e       	adc	r15, r25
   101fc:	0a 1f       	adc	r16, r26
   101fe:	1b 1f       	adc	r17, r27
		rDat[index] = transport_data->InPData(transport_data->dcs_Port);
    }
///////////////////////////VERIFICACIONES/////////////////////////////////    
    if(transport_data->bVerifyChecksum)
	{
		for(index=0; index<xCt; index++)
   10200:	2f 5f       	subi	r18, 0xFF	; 255
   10202:	3f 4f       	sbci	r19, 0xFF	; 255
   10204:	ae 81       	ldd	r26, Y+6	; 0x06
   10206:	bf 81       	ldd	r27, Y+7	; 0x07
   10208:	2a 17       	cp	r18, r26
   1020a:	3b 07       	cpc	r19, r27
   1020c:	88 f3       	brcs	.-30     	; 0x101f0 <PMDParallel_Send+0x136>
   1020e:	20 e0       	ldi	r18, 0x00	; 0
   10210:	30 e0       	ldi	r19, 0x00	; 0
   10212:	0c c0       	rjmp	.+24     	; 0x1022c <PMDParallel_Send+0x172>
			messageChecksum += xDat[index];
		  
		for(index=0; index<rCt; index++)
			messageChecksum += rDat[index];
   10214:	f3 01       	movw	r30, r6
   10216:	81 91       	ld	r24, Z+
   10218:	91 91       	ld	r25, Z+
   1021a:	3f 01       	movw	r6, r30
   1021c:	a0 e0       	ldi	r26, 0x00	; 0
   1021e:	b0 e0       	ldi	r27, 0x00	; 0
   10220:	e8 0e       	add	r14, r24
   10222:	f9 1e       	adc	r15, r25
   10224:	0a 1f       	adc	r16, r26
   10226:	1b 1f       	adc	r17, r27
    if(transport_data->bVerifyChecksum)
	{
		for(index=0; index<xCt; index++)
			messageChecksum += xDat[index];
		  
		for(index=0; index<rCt; index++)
   10228:	2f 5f       	subi	r18, 0xFF	; 255
   1022a:	3f 4f       	sbci	r19, 0xFF	; 255
   1022c:	22 15       	cp	r18, r2
   1022e:	33 05       	cpc	r19, r3
   10230:	88 f3       	brcs	.-30     	; 0x10214 <PMDParallel_Send+0x15a>
       result = PMD_ERR_PMDNotInitialized;

        // get the data from the jarboter Controller
        for(index=0; index<length; index++)
        {
            if((result = PMDParallel_WaitForReady(transport_data)) != PMD_ERR_OK)
   10232:	c6 01       	movw	r24, r12
   10234:	0e 94 01 80 	call	0x10002	; 0x10002 <PMDParallel_WaitForReady>
   10238:	5c 01       	movw	r10, r24
   1023a:	00 97       	sbiw	r24, 0x00	; 0
   1023c:	29 f0       	breq	.+10     	; 0x10248 <PMDParallel_Send+0x18e>
			{
			    printf("PMDParallel_ReceiveResponse=> wait for Cheksum timeout \n");		
   1023e:	8e ef       	ldi	r24, 0xFE	; 254
   10240:	9e e6       	ldi	r25, 0x6E	; 110
   10242:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
   10246:	88 c0       	rjmp	.+272    	; 0x10358 <PMDParallel_Send+0x29e>
			messageChecksum += xDat[index];
		  
		for(index=0; index<rCt; index++)
			messageChecksum += rDat[index];
		 
		messageChecksum = messageChecksum & 0xFFFF;
   10248:	8f ef       	ldi	r24, 0xFF	; 255
   1024a:	9f ef       	ldi	r25, 0xFF	; 255
   1024c:	a0 e0       	ldi	r26, 0x00	; 0
   1024e:	b0 e0       	ldi	r27, 0x00	; 0
   10250:	e8 22       	and	r14, r24
   10252:	f9 22       	and	r15, r25
   10254:	0a 23       	and	r16, r26
   10256:	1b 23       	and	r17, r27
			{
			    printf("PMDParallel_ReceiveResponse=> wait for Cheksum timeout \n");		
                break;
			}
            
			buffer[index] = transport_data->InPData(transport_data->dcs_Port);
   10258:	d6 01       	movw	r26, r12
   1025a:	58 96       	adiw	r26, 0x18	; 24
   1025c:	ed 91       	ld	r30, X+
   1025e:	fc 91       	ld	r31, X
   10260:	59 97       	sbiw	r26, 0x19	; 25
   10262:	8d 91       	ld	r24, X+
   10264:	9c 91       	ld	r25, X
   10266:	09 95       	icall
   10268:	9c 01       	movw	r18, r24
   1026a:	9a 83       	std	Y+2, r25	; 0x02
   1026c:	89 83       	std	Y+1, r24	; 0x01
			messageChecksum += rDat[index];
		 
		messageChecksum = messageChecksum & 0xFFFF;
		
		result = PMDParallel_ReceiveResponse(transport_data, 1, &chipsetChecksum);
		if ( result == PMD_ERR_OK && messageChecksum != chipsetChecksum )
   1026e:	a0 e0       	ldi	r26, 0x00	; 0
   10270:	b0 e0       	ldi	r27, 0x00	; 0
   10272:	e8 16       	cp	r14, r24
   10274:	f9 06       	cpc	r15, r25
   10276:	0a 07       	cpc	r16, r26
   10278:	1b 07       	cpc	r17, r27
   1027a:	09 f4       	brne	.+2      	; 0x1027e <PMDParallel_Send+0x1c4>
   1027c:	6d c0       	rjmp	.+218    	; 0x10358 <PMDParallel_Send+0x29e>
		{			
			if (transport_data->bDiagnostics)
   1027e:	f6 01       	movw	r30, r12
   10280:	80 89       	ldd	r24, Z+16	; 0x10
   10282:	91 89       	ldd	r25, Z+17	; 0x11
   10284:	89 2b       	or	r24, r25
   10286:	09 f4       	brne	.+2      	; 0x1028a <PMDParallel_Send+0x1d0>
   10288:	62 c0       	rjmp	.+196    	; 0x1034e <PMDParallel_Send+0x294>
			{	
				printf("PMDParallel_Send=> Checksum failure.  expected: %ld  got: %x\n",messageChecksum,chipsetChecksum);
   1028a:	8d b7       	in	r24, 0x3d	; 61
   1028c:	9e b7       	in	r25, 0x3e	; 62
   1028e:	08 97       	sbiw	r24, 0x08	; 8
   10290:	0f b6       	in	r0, 0x3f	; 63
   10292:	f8 94       	cli
   10294:	9e bf       	out	0x3e, r25	; 62
   10296:	0f be       	out	0x3f, r0	; 63
   10298:	8d bf       	out	0x3d, r24	; 61
   1029a:	ed b7       	in	r30, 0x3d	; 61
   1029c:	fe b7       	in	r31, 0x3e	; 62
   1029e:	31 96       	adiw	r30, 0x01	; 1
   102a0:	86 e3       	ldi	r24, 0x36	; 54
   102a2:	9f e6       	ldi	r25, 0x6F	; 111
   102a4:	ad b7       	in	r26, 0x3d	; 61
   102a6:	be b7       	in	r27, 0x3e	; 62
   102a8:	12 96       	adiw	r26, 0x02	; 2
   102aa:	9c 93       	st	X, r25
   102ac:	8e 93       	st	-X, r24
   102ae:	11 97       	sbiw	r26, 0x01	; 1
   102b0:	e2 82       	std	Z+2, r14	; 0x02
   102b2:	f3 82       	std	Z+3, r15	; 0x03
   102b4:	04 83       	std	Z+4, r16	; 0x04
   102b6:	15 83       	std	Z+5, r17	; 0x05
   102b8:	37 83       	std	Z+7, r19	; 0x07
   102ba:	26 83       	std	Z+6, r18	; 0x06
   102bc:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
				
				printf("PMDParallel_Send=> C-Motion: %s ",PMDGetOpcodeText(xDat[0]));
   102c0:	ed b7       	in	r30, 0x3d	; 61
   102c2:	fe b7       	in	r31, 0x3e	; 62
   102c4:	38 96       	adiw	r30, 0x08	; 8
   102c6:	0f b6       	in	r0, 0x3f	; 63
   102c8:	f8 94       	cli
   102ca:	fe bf       	out	0x3e, r31	; 62
   102cc:	0f be       	out	0x3f, r0	; 63
   102ce:	ed bf       	out	0x3d, r30	; 61
   102d0:	d2 01       	movw	r26, r4
   102d2:	8d 91       	ld	r24, X+
   102d4:	9c 91       	ld	r25, X
   102d6:	0e 94 4a 38 	call	0x7094	; 0x7094 <PMDGetOpcodeText>
   102da:	00 d0       	rcall	.+0      	; 0x102dc <PMDParallel_Send+0x222>
   102dc:	00 d0       	rcall	.+0      	; 0x102de <PMDParallel_Send+0x224>
   102de:	24 e7       	ldi	r18, 0x74	; 116
   102e0:	3f e6       	ldi	r19, 0x6F	; 111
   102e2:	ed b7       	in	r30, 0x3d	; 61
   102e4:	fe b7       	in	r31, 0x3e	; 62
   102e6:	32 83       	std	Z+2, r19	; 0x02
   102e8:	21 83       	std	Z+1, r18	; 0x01
   102ea:	94 83       	std	Z+4, r25	; 0x04
   102ec:	83 83       	std	Z+3, r24	; 0x03
   102ee:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
   102f2:	00 e0       	ldi	r16, 0x00	; 0
   102f4:	10 e0       	ldi	r17, 0x00	; 0
   102f6:	0f 90       	pop	r0
   102f8:	0f 90       	pop	r0
   102fa:	0f 90       	pop	r0
   102fc:	0f 90       	pop	r0
				
				for(index=0; index<xCt; index++)
					printf("%X ",xDat[index]);
   102fe:	25 e9       	ldi	r18, 0x95	; 149
   10300:	e2 2e       	mov	r14, r18
   10302:	2f e6       	ldi	r18, 0x6F	; 111
   10304:	f2 2e       	mov	r15, r18
   10306:	1a c0       	rjmp	.+52     	; 0x1033c <PMDParallel_Send+0x282>
   10308:	00 d0       	rcall	.+0      	; 0x1030a <PMDParallel_Send+0x250>
   1030a:	00 d0       	rcall	.+0      	; 0x1030c <PMDParallel_Send+0x252>
   1030c:	ad b7       	in	r26, 0x3d	; 61
   1030e:	be b7       	in	r27, 0x3e	; 62
   10310:	12 96       	adiw	r26, 0x02	; 2
   10312:	fc 92       	st	X, r15
   10314:	ee 92       	st	-X, r14
   10316:	11 97       	sbiw	r26, 0x01	; 1
   10318:	eb 81       	ldd	r30, Y+3	; 0x03
   1031a:	fc 81       	ldd	r31, Y+4	; 0x04
   1031c:	81 91       	ld	r24, Z+
   1031e:	91 91       	ld	r25, Z+
   10320:	fc 83       	std	Y+4, r31	; 0x04
   10322:	eb 83       	std	Y+3, r30	; 0x03
   10324:	14 96       	adiw	r26, 0x04	; 4
   10326:	9c 93       	st	X, r25
   10328:	8e 93       	st	-X, r24
   1032a:	13 97       	sbiw	r26, 0x03	; 3
   1032c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
			{	
				printf("PMDParallel_Send=> Checksum failure.  expected: %ld  got: %x\n",messageChecksum,chipsetChecksum);
				
				printf("PMDParallel_Send=> C-Motion: %s ",PMDGetOpcodeText(xDat[0]));
				
				for(index=0; index<xCt; index++)
   10330:	0f 5f       	subi	r16, 0xFF	; 255
   10332:	1f 4f       	sbci	r17, 0xFF	; 255
   10334:	0f 90       	pop	r0
   10336:	0f 90       	pop	r0
   10338:	0f 90       	pop	r0
   1033a:	0f 90       	pop	r0
   1033c:	2e 81       	ldd	r18, Y+6	; 0x06
   1033e:	3f 81       	ldd	r19, Y+7	; 0x07
   10340:	02 17       	cp	r16, r18
   10342:	13 07       	cpc	r17, r19
   10344:	08 f3       	brcs	.-62     	; 0x10308 <PMDParallel_Send+0x24e>
					printf("%X ",xDat[index]);
				
				printf("\n");
   10346:	8a e0       	ldi	r24, 0x0A	; 10
   10348:	90 e0       	ldi	r25, 0x00	; 0
   1034a:	0e 94 db 9f 	call	0x13fb6	; 0x13fb6 <putchar>
   1034e:	9e ef       	ldi	r25, 0xFE	; 254
   10350:	89 2e       	mov	r8, r25
   10352:	9f e7       	ldi	r25, 0x7F	; 127
   10354:	99 2e       	mov	r9, r25
   10356:	50 c0       	rjmp	.+160    	; 0x103f8 <PMDParallel_Send+0x33e>
		    }  
			return PMD_ERR_ChecksumError;
		}
	}
	
	if (commandstatus!=PMD_ERR_OK)
   10358:	81 14       	cp	r8, r1
   1035a:	91 04       	cpc	r9, r1
   1035c:	11 f4       	brne	.+4      	; 0x10362 <PMDParallel_Send+0x2a8>
   1035e:	45 01       	movw	r8, r10
   10360:	4b c0       	rjmp	.+150    	; 0x103f8 <PMDParallel_Send+0x33e>
	{
		if (transport_data->bDiagnostics)
   10362:	d6 01       	movw	r26, r12
   10364:	50 96       	adiw	r26, 0x10	; 16
   10366:	8d 91       	ld	r24, X+
   10368:	9c 91       	ld	r25, X
   1036a:	51 97       	sbiw	r26, 0x11	; 17
   1036c:	89 2b       	or	r24, r25
   1036e:	09 f4       	brne	.+2      	; 0x10372 <PMDParallel_Send+0x2b8>
   10370:	43 c0       	rjmp	.+134    	; 0x103f8 <PMDParallel_Send+0x33e>
		{
			printf("PMDParallel_Send=> Host I/O Error \n");
   10372:	89 e9       	ldi	r24, 0x99	; 153
   10374:	9f e6       	ldi	r25, 0x6F	; 111
   10376:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
			printf("PMDParallel_Send=> C-Motion: %s ",PMDGetOpcodeText(xDat[0]));
   1037a:	f2 01       	movw	r30, r4
   1037c:	80 81       	ld	r24, Z
   1037e:	91 81       	ldd	r25, Z+1	; 0x01
   10380:	0e 94 4a 38 	call	0x7094	; 0x7094 <PMDGetOpcodeText>
   10384:	00 d0       	rcall	.+0      	; 0x10386 <PMDParallel_Send+0x2cc>
   10386:	00 d0       	rcall	.+0      	; 0x10388 <PMDParallel_Send+0x2ce>
   10388:	24 e7       	ldi	r18, 0x74	; 116
   1038a:	3f e6       	ldi	r19, 0x6F	; 111
   1038c:	ad b7       	in	r26, 0x3d	; 61
   1038e:	be b7       	in	r27, 0x3e	; 62
   10390:	12 96       	adiw	r26, 0x02	; 2
   10392:	3c 93       	st	X, r19
   10394:	2e 93       	st	-X, r18
   10396:	11 97       	sbiw	r26, 0x01	; 1
   10398:	14 96       	adiw	r26, 0x04	; 4
   1039a:	9c 93       	st	X, r25
   1039c:	8e 93       	st	-X, r24
   1039e:	13 97       	sbiw	r26, 0x03	; 3
   103a0:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
   103a4:	72 01       	movw	r14, r4
   103a6:	00 e0       	ldi	r16, 0x00	; 0
   103a8:	10 e0       	ldi	r17, 0x00	; 0
   103aa:	0f 90       	pop	r0
   103ac:	0f 90       	pop	r0
   103ae:	0f 90       	pop	r0
   103b0:	0f 90       	pop	r0
			
			for(index=0; index<xCt; index++)
   103b2:	bd 81       	ldd	r27, Y+5	; 0x05
   103b4:	cb 2e       	mov	r12, r27
   103b6:	dd 24       	eor	r13, r13
				printf("%X ",xDat[index]);
   103b8:	85 e9       	ldi	r24, 0x95	; 149
   103ba:	a8 2e       	mov	r10, r24
   103bc:	8f e6       	ldi	r24, 0x6F	; 111
   103be:	b8 2e       	mov	r11, r24
   103c0:	14 c0       	rjmp	.+40     	; 0x103ea <PMDParallel_Send+0x330>
   103c2:	00 d0       	rcall	.+0      	; 0x103c4 <PMDParallel_Send+0x30a>
   103c4:	00 d0       	rcall	.+0      	; 0x103c6 <PMDParallel_Send+0x30c>
   103c6:	ed b7       	in	r30, 0x3d	; 61
   103c8:	fe b7       	in	r31, 0x3e	; 62
   103ca:	b2 82       	std	Z+2, r11	; 0x02
   103cc:	a1 82       	std	Z+1, r10	; 0x01
   103ce:	d7 01       	movw	r26, r14
   103d0:	8d 91       	ld	r24, X+
   103d2:	9d 91       	ld	r25, X+
   103d4:	7d 01       	movw	r14, r26
   103d6:	94 83       	std	Z+4, r25	; 0x04
   103d8:	83 83       	std	Z+3, r24	; 0x03
   103da:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
		if (transport_data->bDiagnostics)
		{
			printf("PMDParallel_Send=> Host I/O Error \n");
			printf("PMDParallel_Send=> C-Motion: %s ",PMDGetOpcodeText(xDat[0]));
			
			for(index=0; index<xCt; index++)
   103de:	0f 5f       	subi	r16, 0xFF	; 255
   103e0:	1f 4f       	sbci	r17, 0xFF	; 255
   103e2:	0f 90       	pop	r0
   103e4:	0f 90       	pop	r0
   103e6:	0f 90       	pop	r0
   103e8:	0f 90       	pop	r0
   103ea:	0c 15       	cp	r16, r12
   103ec:	1d 05       	cpc	r17, r13
   103ee:	48 f3       	brcs	.-46     	; 0x103c2 <PMDParallel_Send+0x308>
				printf("%X ",xDat[index]);
			
			printf("\n");
   103f0:	8a e0       	ldi	r24, 0x0A	; 10
   103f2:	90 e0       	ldi	r25, 0x00	; 0
   103f4:	0e 94 db 9f 	call	0x13fb6	; 0x13fb6 <putchar>
		}
		return commandstatus;
	}
	
	return result;
}
   103f8:	c4 01       	movw	r24, r8
   103fa:	27 96       	adiw	r28, 0x07	; 7
   103fc:	0f b6       	in	r0, 0x3f	; 63
   103fe:	f8 94       	cli
   10400:	de bf       	out	0x3e, r29	; 62
   10402:	0f be       	out	0x3f, r0	; 63
   10404:	cd bf       	out	0x3d, r28	; 61
   10406:	cf 91       	pop	r28
   10408:	df 91       	pop	r29
   1040a:	1f 91       	pop	r17
   1040c:	0f 91       	pop	r16
   1040e:	ff 90       	pop	r15
   10410:	ef 90       	pop	r14
   10412:	df 90       	pop	r13
   10414:	cf 90       	pop	r12
   10416:	bf 90       	pop	r11
   10418:	af 90       	pop	r10
   1041a:	9f 90       	pop	r9
   1041c:	8f 90       	pop	r8
   1041e:	7f 90       	pop	r7
   10420:	6f 90       	pop	r6
   10422:	5f 90       	pop	r5
   10424:	4f 90       	pop	r4
   10426:	3f 90       	pop	r3
   10428:	2f 90       	pop	r2
   1042a:	08 95       	ret

0001042c <OutP8BitHard>:
}

//******************************************************************************************************************** 
void OutP8BitHard(void) 
{
  writePMDreset(); 
   1042c:	0e 94 99 3d 	call	0x7b32	; 0x7b32 <writePMDreset>
}
   10430:	08 95       	ret

00010432 <InP8BitStatus>:
  return readPMDdata(PMDChipSet);
}
//********************************************************************************************************************
PMDuint16 InP8BitStatus(PMDuint16 PMDChipSet) 
{
  return readPMDstatus(PMDChipSet);
   10432:	0e 94 1e 3d 	call	0x7a3c	; 0x7a3c <readPMDstatus>
}
   10436:	08 95       	ret

00010438 <InP8Bit>:
}

//********************************************************************************************************************
PMDuint16 InP8Bit(PMDuint16 PMDChipSet) 
{
  return readPMDdata(PMDChipSet);
   10438:	0e 94 a3 3c 	call	0x7946	; 0x7946 <readPMDdata>
}
   1043c:	08 95       	ret

0001043e <OutP8BitCmd>:


//********************************************************************************************************************
void OutP8BitCmd(PMDuint16 PMDChipSet, PMDuint16 dataword) 
{
  writePMDcommand(PMDChipSet,dataword);   // low-level function, provided by basicIO.h
   1043e:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <writePMDcommand>
}
   10442:	08 95       	ret

00010444 <OutP8Bit>:
 
 
 //********************************************************************************************************************
void OutP8Bit(PMDuint16 PMDChipSet, PMDuint16 dataword) 
{
  writePMDdata(PMDChipSet,dataword);
   10444:	0e 94 4b 3c 	call	0x7896	; 0x7896 <writePMDdata>
}
   10448:	08 95       	ret

0001044a <BuildCommand>:
#include <avr/io.h>
#include "PMDtrans.h"


PMDuint16 BuildCommand(PMDuint16 OPCode, PMDAxis axis)
{
   1044a:	36 2f       	mov	r19, r22
   1044c:	20 e0       	ldi	r18, 0x00	; 0
   1044e:	28 2b       	or	r18, r24
   10450:	39 2b       	or	r19, r25
	return ((PMDuint16)((PMDuint32)OPCode | ((PMDuint32)axis << 8)));
}
   10452:	c9 01       	movw	r24, r18
   10454:	08 95       	ret

00010456 <SendCommand>:




PMDuint16 SendCommand(PMDAxisHandle* axis_handle, PMDuint16 OPCode)
{
   10456:	0f 93       	push	r16
   10458:	1f 93       	push	r17
   1045a:	df 93       	push	r29
   1045c:	cf 93       	push	r28
   1045e:	00 d0       	rcall	.+0      	; 0x10460 <SendCommand+0xa>
   10460:	cd b7       	in	r28, 0x3d	; 61
   10462:	de b7       	in	r29, 0x3e	; 62
   10464:	fc 01       	movw	r30, r24
        PMDuint16 buffer[1];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
   10466:	92 81       	ldd	r25, Z+2	; 0x02
   10468:	80 e0       	ldi	r24, 0x00	; 0
   1046a:	86 2b       	or	r24, r22
   1046c:	97 2b       	or	r25, r23
   1046e:	9a 83       	std	Y+2, r25	; 0x02
   10470:	89 83       	std	Y+1, r24	; 0x01

        return axis_handle->transport.SendCommand(axis_handle->transport_data, 1, buffer, 0, PMDnull);
   10472:	df 01       	movw	r26, r30
   10474:	a2 5a       	subi	r26, 0xA2	; 162
   10476:	bf 4f       	sbci	r27, 0xFF	; 255
   10478:	e0 5b       	subi	r30, 0xB0	; 176
   1047a:	ff 4f       	sbci	r31, 0xFF	; 255
   1047c:	01 90       	ld	r0, Z+
   1047e:	f0 81       	ld	r31, Z
   10480:	e0 2d       	mov	r30, r0
   10482:	8d 91       	ld	r24, X+
   10484:	9c 91       	ld	r25, X
   10486:	61 e0       	ldi	r22, 0x01	; 1
   10488:	ae 01       	movw	r20, r28
   1048a:	4f 5f       	subi	r20, 0xFF	; 255
   1048c:	5f 4f       	sbci	r21, 0xFF	; 255
   1048e:	20 e0       	ldi	r18, 0x00	; 0
   10490:	00 e0       	ldi	r16, 0x00	; 0
   10492:	10 e0       	ldi	r17, 0x00	; 0
   10494:	09 95       	icall
}
   10496:	0f 90       	pop	r0
   10498:	0f 90       	pop	r0
   1049a:	cf 91       	pop	r28
   1049c:	df 91       	pop	r29
   1049e:	1f 91       	pop	r17
   104a0:	0f 91       	pop	r16
   104a2:	08 95       	ret

000104a4 <SendCommandWord>:


PMDuint16 SendCommandWord(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 data1)
{
   104a4:	0f 93       	push	r16
   104a6:	1f 93       	push	r17
   104a8:	df 93       	push	r29
   104aa:	cf 93       	push	r28
   104ac:	00 d0       	rcall	.+0      	; 0x104ae <SendCommandWord+0xa>
   104ae:	00 d0       	rcall	.+0      	; 0x104b0 <SendCommandWord+0xc>
   104b0:	cd b7       	in	r28, 0x3d	; 61
   104b2:	de b7       	in	r29, 0x3e	; 62
   104b4:	fc 01       	movw	r30, r24
        PMDuint16 buffer[2];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
   104b6:	92 81       	ldd	r25, Z+2	; 0x02
   104b8:	80 e0       	ldi	r24, 0x00	; 0
   104ba:	86 2b       	or	r24, r22
   104bc:	97 2b       	or	r25, r23
   104be:	9a 83       	std	Y+2, r25	; 0x02
   104c0:	89 83       	std	Y+1, r24	; 0x01
        buffer[1] = (PMDuint16)data1;
   104c2:	5c 83       	std	Y+4, r21	; 0x04
   104c4:	4b 83       	std	Y+3, r20	; 0x03

        return axis_handle->transport.SendCommand(axis_handle->transport_data, 2, buffer, 0, PMDnull);
   104c6:	df 01       	movw	r26, r30
   104c8:	a2 5a       	subi	r26, 0xA2	; 162
   104ca:	bf 4f       	sbci	r27, 0xFF	; 255
   104cc:	e0 5b       	subi	r30, 0xB0	; 176
   104ce:	ff 4f       	sbci	r31, 0xFF	; 255
   104d0:	01 90       	ld	r0, Z+
   104d2:	f0 81       	ld	r31, Z
   104d4:	e0 2d       	mov	r30, r0
   104d6:	8d 91       	ld	r24, X+
   104d8:	9c 91       	ld	r25, X
   104da:	62 e0       	ldi	r22, 0x02	; 2
   104dc:	ae 01       	movw	r20, r28
   104de:	4f 5f       	subi	r20, 0xFF	; 255
   104e0:	5f 4f       	sbci	r21, 0xFF	; 255
   104e2:	20 e0       	ldi	r18, 0x00	; 0
   104e4:	00 e0       	ldi	r16, 0x00	; 0
   104e6:	10 e0       	ldi	r17, 0x00	; 0
   104e8:	09 95       	icall
}
   104ea:	0f 90       	pop	r0
   104ec:	0f 90       	pop	r0
   104ee:	0f 90       	pop	r0
   104f0:	0f 90       	pop	r0
   104f2:	cf 91       	pop	r28
   104f4:	df 91       	pop	r29
   104f6:	1f 91       	pop	r17
   104f8:	0f 91       	pop	r16
   104fa:	08 95       	ret

000104fc <SendCommandWordWord>:


PMDuint16 SendCommandWordWord(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 data1, PMDuint16 data2)
{
   104fc:	0f 93       	push	r16
   104fe:	1f 93       	push	r17
   10500:	df 93       	push	r29
   10502:	cf 93       	push	r28
   10504:	00 d0       	rcall	.+0      	; 0x10506 <SendCommandWordWord+0xa>
   10506:	00 d0       	rcall	.+0      	; 0x10508 <SendCommandWordWord+0xc>
   10508:	00 d0       	rcall	.+0      	; 0x1050a <SendCommandWordWord+0xe>
   1050a:	cd b7       	in	r28, 0x3d	; 61
   1050c:	de b7       	in	r29, 0x3e	; 62
   1050e:	fc 01       	movw	r30, r24
        PMDuint16 buffer[3];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
   10510:	92 81       	ldd	r25, Z+2	; 0x02
   10512:	80 e0       	ldi	r24, 0x00	; 0
   10514:	86 2b       	or	r24, r22
   10516:	97 2b       	or	r25, r23
   10518:	9a 83       	std	Y+2, r25	; 0x02
   1051a:	89 83       	std	Y+1, r24	; 0x01
        buffer[1] = (PMDuint16)data1;
   1051c:	5c 83       	std	Y+4, r21	; 0x04
   1051e:	4b 83       	std	Y+3, r20	; 0x03
        buffer[2] = (PMDuint16)data2;
   10520:	3e 83       	std	Y+6, r19	; 0x06
   10522:	2d 83       	std	Y+5, r18	; 0x05

        return axis_handle->transport.SendCommand(axis_handle->transport_data, 3, buffer, 0, PMDnull);
   10524:	df 01       	movw	r26, r30
   10526:	a2 5a       	subi	r26, 0xA2	; 162
   10528:	bf 4f       	sbci	r27, 0xFF	; 255
   1052a:	e0 5b       	subi	r30, 0xB0	; 176
   1052c:	ff 4f       	sbci	r31, 0xFF	; 255
   1052e:	01 90       	ld	r0, Z+
   10530:	f0 81       	ld	r31, Z
   10532:	e0 2d       	mov	r30, r0
   10534:	8d 91       	ld	r24, X+
   10536:	9c 91       	ld	r25, X
   10538:	63 e0       	ldi	r22, 0x03	; 3
   1053a:	ae 01       	movw	r20, r28
   1053c:	4f 5f       	subi	r20, 0xFF	; 255
   1053e:	5f 4f       	sbci	r21, 0xFF	; 255
   10540:	20 e0       	ldi	r18, 0x00	; 0
   10542:	00 e0       	ldi	r16, 0x00	; 0
   10544:	10 e0       	ldi	r17, 0x00	; 0
   10546:	09 95       	icall
}
   10548:	26 96       	adiw	r28, 0x06	; 6
   1054a:	0f b6       	in	r0, 0x3f	; 63
   1054c:	f8 94       	cli
   1054e:	de bf       	out	0x3e, r29	; 62
   10550:	0f be       	out	0x3f, r0	; 63
   10552:	cd bf       	out	0x3d, r28	; 61
   10554:	cf 91       	pop	r28
   10556:	df 91       	pop	r29
   10558:	1f 91       	pop	r17
   1055a:	0f 91       	pop	r16
   1055c:	08 95       	ret

0001055e <SendCommandLong>:


PMDuint16 SendCommandLong(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint32 data1)
{
   1055e:	0f 93       	push	r16
   10560:	1f 93       	push	r17
   10562:	df 93       	push	r29
   10564:	cf 93       	push	r28
   10566:	cd b7       	in	r28, 0x3d	; 61
   10568:	de b7       	in	r29, 0x3e	; 62
   1056a:	2a 97       	sbiw	r28, 0x0a	; 10
   1056c:	0f b6       	in	r0, 0x3f	; 63
   1056e:	f8 94       	cli
   10570:	de bf       	out	0x3e, r29	; 62
   10572:	0f be       	out	0x3f, r0	; 63
   10574:	cd bf       	out	0x3d, r28	; 61
   10576:	fc 01       	movw	r30, r24
   10578:	2f 83       	std	Y+7, r18	; 0x07
   1057a:	38 87       	std	Y+8, r19	; 0x08
   1057c:	49 87       	std	Y+9, r20	; 0x09
   1057e:	5a 87       	std	Y+10, r21	; 0x0a
        PMDuint16 buffer[3];
        PMDuint16* ptr;
		PMDuint32* temp;

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
   10580:	92 81       	ldd	r25, Z+2	; 0x02
   10582:	80 e0       	ldi	r24, 0x00	; 0
   10584:	86 2b       	or	r24, r22
   10586:	97 2b       	or	r25, r23
   10588:	9a 83       	std	Y+2, r25	; 0x02
   1058a:	89 83       	std	Y+1, r24	; 0x01
		temp=&data1;
        ptr = (PMDuint16 *)temp;
        buffer[1]=*(ptr+1); //Write MSW first
   1058c:	89 85       	ldd	r24, Y+9	; 0x09
   1058e:	9a 85       	ldd	r25, Y+10	; 0x0a
   10590:	9c 83       	std	Y+4, r25	; 0x04
   10592:	8b 83       	std	Y+3, r24	; 0x03
        buffer[2]=*ptr;
   10594:	8f 81       	ldd	r24, Y+7	; 0x07
   10596:	98 85       	ldd	r25, Y+8	; 0x08
   10598:	9e 83       	std	Y+6, r25	; 0x06
   1059a:	8d 83       	std	Y+5, r24	; 0x05

        return axis_handle->transport.SendCommand(axis_handle->transport_data, 3, buffer, 0, PMDnull);
   1059c:	df 01       	movw	r26, r30
   1059e:	a2 5a       	subi	r26, 0xA2	; 162
   105a0:	bf 4f       	sbci	r27, 0xFF	; 255
   105a2:	e0 5b       	subi	r30, 0xB0	; 176
   105a4:	ff 4f       	sbci	r31, 0xFF	; 255
   105a6:	01 90       	ld	r0, Z+
   105a8:	f0 81       	ld	r31, Z
   105aa:	e0 2d       	mov	r30, r0
   105ac:	8d 91       	ld	r24, X+
   105ae:	9c 91       	ld	r25, X
   105b0:	63 e0       	ldi	r22, 0x03	; 3
   105b2:	ae 01       	movw	r20, r28
   105b4:	4f 5f       	subi	r20, 0xFF	; 255
   105b6:	5f 4f       	sbci	r21, 0xFF	; 255
   105b8:	20 e0       	ldi	r18, 0x00	; 0
   105ba:	00 e0       	ldi	r16, 0x00	; 0
   105bc:	10 e0       	ldi	r17, 0x00	; 0
   105be:	09 95       	icall
}
   105c0:	2a 96       	adiw	r28, 0x0a	; 10
   105c2:	0f b6       	in	r0, 0x3f	; 63
   105c4:	f8 94       	cli
   105c6:	de bf       	out	0x3e, r29	; 62
   105c8:	0f be       	out	0x3f, r0	; 63
   105ca:	cd bf       	out	0x3d, r28	; 61
   105cc:	cf 91       	pop	r28
   105ce:	df 91       	pop	r29
   105d0:	1f 91       	pop	r17
   105d2:	0f 91       	pop	r16
   105d4:	08 95       	ret

000105d6 <SendCommandWordLong>:


PMDuint16 SendCommandWordLong(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 data1, PMDuint32 data2)
{
   105d6:	0f 93       	push	r16
   105d8:	1f 93       	push	r17
   105da:	df 93       	push	r29
   105dc:	cf 93       	push	r28
   105de:	cd b7       	in	r28, 0x3d	; 61
   105e0:	de b7       	in	r29, 0x3e	; 62
   105e2:	2c 97       	sbiw	r28, 0x0c	; 12
   105e4:	0f b6       	in	r0, 0x3f	; 63
   105e6:	f8 94       	cli
   105e8:	de bf       	out	0x3e, r29	; 62
   105ea:	0f be       	out	0x3f, r0	; 63
   105ec:	cd bf       	out	0x3d, r28	; 61
   105ee:	fc 01       	movw	r30, r24
   105f0:	09 87       	std	Y+9, r16	; 0x09
   105f2:	1a 87       	std	Y+10, r17	; 0x0a
   105f4:	2b 87       	std	Y+11, r18	; 0x0b
   105f6:	3c 87       	std	Y+12, r19	; 0x0c
        PMDuint16 buffer[4];
        PMDuint16 *ptr;
		PMDuint32 *temp;

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
   105f8:	92 81       	ldd	r25, Z+2	; 0x02
   105fa:	80 e0       	ldi	r24, 0x00	; 0
   105fc:	86 2b       	or	r24, r22
   105fe:	97 2b       	or	r25, r23
   10600:	9a 83       	std	Y+2, r25	; 0x02
   10602:	89 83       	std	Y+1, r24	; 0x01
        buffer[1] = data1;
   10604:	5c 83       	std	Y+4, r21	; 0x04
   10606:	4b 83       	std	Y+3, r20	; 0x03
		temp=&data2;
        ptr = (PMDuint16 *)temp;
        buffer[2]=*(ptr+1); //Write MSW first
   10608:	8b 85       	ldd	r24, Y+11	; 0x0b
   1060a:	9c 85       	ldd	r25, Y+12	; 0x0c
   1060c:	9e 83       	std	Y+6, r25	; 0x06
   1060e:	8d 83       	std	Y+5, r24	; 0x05
        buffer[3]=*ptr;
   10610:	89 85       	ldd	r24, Y+9	; 0x09
   10612:	9a 85       	ldd	r25, Y+10	; 0x0a
   10614:	98 87       	std	Y+8, r25	; 0x08
   10616:	8f 83       	std	Y+7, r24	; 0x07

        return axis_handle->transport.SendCommand(axis_handle->transport_data, 4, buffer, 0, PMDnull);
   10618:	df 01       	movw	r26, r30
   1061a:	a2 5a       	subi	r26, 0xA2	; 162
   1061c:	bf 4f       	sbci	r27, 0xFF	; 255
   1061e:	e0 5b       	subi	r30, 0xB0	; 176
   10620:	ff 4f       	sbci	r31, 0xFF	; 255
   10622:	01 90       	ld	r0, Z+
   10624:	f0 81       	ld	r31, Z
   10626:	e0 2d       	mov	r30, r0
   10628:	8d 91       	ld	r24, X+
   1062a:	9c 91       	ld	r25, X
   1062c:	64 e0       	ldi	r22, 0x04	; 4
   1062e:	ae 01       	movw	r20, r28
   10630:	4f 5f       	subi	r20, 0xFF	; 255
   10632:	5f 4f       	sbci	r21, 0xFF	; 255
   10634:	20 e0       	ldi	r18, 0x00	; 0
   10636:	00 e0       	ldi	r16, 0x00	; 0
   10638:	10 e0       	ldi	r17, 0x00	; 0
   1063a:	09 95       	icall
}
   1063c:	2c 96       	adiw	r28, 0x0c	; 12
   1063e:	0f b6       	in	r0, 0x3f	; 63
   10640:	f8 94       	cli
   10642:	de bf       	out	0x3e, r29	; 62
   10644:	0f be       	out	0x3f, r0	; 63
   10646:	cd bf       	out	0x3d, r28	; 61
   10648:	cf 91       	pop	r28
   1064a:	df 91       	pop	r29
   1064c:	1f 91       	pop	r17
   1064e:	0f 91       	pop	r16
   10650:	08 95       	ret

00010652 <SendCommandGetWord>:


PMDuint16 SendCommandGetWord(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 *data1)
{
   10652:	ef 92       	push	r14
   10654:	ff 92       	push	r15
   10656:	0f 93       	push	r16
   10658:	1f 93       	push	r17
   1065a:	df 93       	push	r29
   1065c:	cf 93       	push	r28
   1065e:	00 d0       	rcall	.+0      	; 0x10660 <SendCommandGetWord+0xe>
   10660:	00 d0       	rcall	.+0      	; 0x10662 <SendCommandGetWord+0x10>
   10662:	cd b7       	in	r28, 0x3d	; 61
   10664:	de b7       	in	r29, 0x3e	; 62
   10666:	fc 01       	movw	r30, r24
   10668:	7a 01       	movw	r14, r20
        PMDuint16 result = PMD_ERR_OK;
        PMDuint16 buffer[2];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
   1066a:	92 81       	ldd	r25, Z+2	; 0x02
   1066c:	80 e0       	ldi	r24, 0x00	; 0
   1066e:	86 2b       	or	r24, r22
   10670:	97 2b       	or	r25, r23
   10672:	9a 83       	std	Y+2, r25	; 0x02
   10674:	89 83       	std	Y+1, r24	; 0x01

        result = axis_handle->transport.SendCommand(axis_handle->transport_data, 1, buffer, 1, buffer+1);
   10676:	df 01       	movw	r26, r30
   10678:	a2 5a       	subi	r26, 0xA2	; 162
   1067a:	bf 4f       	sbci	r27, 0xFF	; 255
   1067c:	e0 5b       	subi	r30, 0xB0	; 176
   1067e:	ff 4f       	sbci	r31, 0xFF	; 255
   10680:	01 90       	ld	r0, Z+
   10682:	f0 81       	ld	r31, Z
   10684:	e0 2d       	mov	r30, r0
   10686:	8d 91       	ld	r24, X+
   10688:	9c 91       	ld	r25, X
   1068a:	61 e0       	ldi	r22, 0x01	; 1
   1068c:	ae 01       	movw	r20, r28
   1068e:	4f 5f       	subi	r20, 0xFF	; 255
   10690:	5f 4f       	sbci	r21, 0xFF	; 255
   10692:	21 e0       	ldi	r18, 0x01	; 1
   10694:	8e 01       	movw	r16, r28
   10696:	0d 5f       	subi	r16, 0xFD	; 253
   10698:	1f 4f       	sbci	r17, 0xFF	; 255
   1069a:	09 95       	icall

        *data1 = (PMDuint16)buffer[1];
   1069c:	2b 81       	ldd	r18, Y+3	; 0x03
   1069e:	3c 81       	ldd	r19, Y+4	; 0x04
   106a0:	f7 01       	movw	r30, r14
   106a2:	31 83       	std	Z+1, r19	; 0x01
   106a4:	20 83       	st	Z, r18

        return result;
}
   106a6:	0f 90       	pop	r0
   106a8:	0f 90       	pop	r0
   106aa:	0f 90       	pop	r0
   106ac:	0f 90       	pop	r0
   106ae:	cf 91       	pop	r28
   106b0:	df 91       	pop	r29
   106b2:	1f 91       	pop	r17
   106b4:	0f 91       	pop	r16
   106b6:	ff 90       	pop	r15
   106b8:	ef 90       	pop	r14
   106ba:	08 95       	ret

000106bc <SendCommandGetWordWord>:

PMDuint16 SendCommandGetWordWord(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 *data1, PMDuint16 *data2)
{
   106bc:	cf 92       	push	r12
   106be:	df 92       	push	r13
   106c0:	ef 92       	push	r14
   106c2:	ff 92       	push	r15
   106c4:	0f 93       	push	r16
   106c6:	1f 93       	push	r17
   106c8:	df 93       	push	r29
   106ca:	cf 93       	push	r28
   106cc:	00 d0       	rcall	.+0      	; 0x106ce <SendCommandGetWordWord+0x12>
   106ce:	00 d0       	rcall	.+0      	; 0x106d0 <SendCommandGetWordWord+0x14>
   106d0:	00 d0       	rcall	.+0      	; 0x106d2 <SendCommandGetWordWord+0x16>
   106d2:	cd b7       	in	r28, 0x3d	; 61
   106d4:	de b7       	in	r29, 0x3e	; 62
   106d6:	fc 01       	movw	r30, r24
   106d8:	7a 01       	movw	r14, r20
   106da:	69 01       	movw	r12, r18
        PMDuint16 result = PMD_ERR_OK;
        PMDuint16 buffer[3];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
   106dc:	92 81       	ldd	r25, Z+2	; 0x02
   106de:	80 e0       	ldi	r24, 0x00	; 0
   106e0:	86 2b       	or	r24, r22
   106e2:	97 2b       	or	r25, r23
   106e4:	9a 83       	std	Y+2, r25	; 0x02
   106e6:	89 83       	std	Y+1, r24	; 0x01

        result = axis_handle->transport.SendCommand(axis_handle->transport_data, 1, buffer, 2, buffer+1);
   106e8:	df 01       	movw	r26, r30
   106ea:	a2 5a       	subi	r26, 0xA2	; 162
   106ec:	bf 4f       	sbci	r27, 0xFF	; 255
   106ee:	e0 5b       	subi	r30, 0xB0	; 176
   106f0:	ff 4f       	sbci	r31, 0xFF	; 255
   106f2:	01 90       	ld	r0, Z+
   106f4:	f0 81       	ld	r31, Z
   106f6:	e0 2d       	mov	r30, r0
   106f8:	8d 91       	ld	r24, X+
   106fa:	9c 91       	ld	r25, X
   106fc:	61 e0       	ldi	r22, 0x01	; 1
   106fe:	ae 01       	movw	r20, r28
   10700:	4f 5f       	subi	r20, 0xFF	; 255
   10702:	5f 4f       	sbci	r21, 0xFF	; 255
   10704:	22 e0       	ldi	r18, 0x02	; 2
   10706:	8e 01       	movw	r16, r28
   10708:	0d 5f       	subi	r16, 0xFD	; 253
   1070a:	1f 4f       	sbci	r17, 0xFF	; 255
   1070c:	09 95       	icall

        *data1 = (PMDuint16)buffer[1];
   1070e:	2b 81       	ldd	r18, Y+3	; 0x03
   10710:	3c 81       	ldd	r19, Y+4	; 0x04
   10712:	f7 01       	movw	r30, r14
   10714:	31 83       	std	Z+1, r19	; 0x01
   10716:	20 83       	st	Z, r18
        *data2 = (PMDuint16)buffer[2];
   10718:	2d 81       	ldd	r18, Y+5	; 0x05
   1071a:	3e 81       	ldd	r19, Y+6	; 0x06
   1071c:	f6 01       	movw	r30, r12
   1071e:	31 83       	std	Z+1, r19	; 0x01
   10720:	20 83       	st	Z, r18

        return result;
}
   10722:	26 96       	adiw	r28, 0x06	; 6
   10724:	0f b6       	in	r0, 0x3f	; 63
   10726:	f8 94       	cli
   10728:	de bf       	out	0x3e, r29	; 62
   1072a:	0f be       	out	0x3f, r0	; 63
   1072c:	cd bf       	out	0x3d, r28	; 61
   1072e:	cf 91       	pop	r28
   10730:	df 91       	pop	r29
   10732:	1f 91       	pop	r17
   10734:	0f 91       	pop	r16
   10736:	ff 90       	pop	r15
   10738:	ef 90       	pop	r14
   1073a:	df 90       	pop	r13
   1073c:	cf 90       	pop	r12
   1073e:	08 95       	ret

00010740 <SendCommandGetLong>:


PMDuint16 SendCommandGetLong(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint32 *data1)
{
   10740:	cf 92       	push	r12
   10742:	df 92       	push	r13
   10744:	ef 92       	push	r14
   10746:	ff 92       	push	r15
   10748:	0f 93       	push	r16
   1074a:	1f 93       	push	r17
   1074c:	df 93       	push	r29
   1074e:	cf 93       	push	r28
   10750:	00 d0       	rcall	.+0      	; 0x10752 <SendCommandGetLong+0x12>
   10752:	00 d0       	rcall	.+0      	; 0x10754 <SendCommandGetLong+0x14>
   10754:	00 d0       	rcall	.+0      	; 0x10756 <SendCommandGetLong+0x16>
   10756:	cd b7       	in	r28, 0x3d	; 61
   10758:	de b7       	in	r29, 0x3e	; 62
   1075a:	fc 01       	movw	r30, r24
   1075c:	6a 01       	movw	r12, r20
        PMDuint16 result = PMD_ERR_OK;
        PMDuint16 buffer[3];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
   1075e:	92 81       	ldd	r25, Z+2	; 0x02
   10760:	80 e0       	ldi	r24, 0x00	; 0
   10762:	86 2b       	or	r24, r22
   10764:	97 2b       	or	r25, r23
   10766:	9a 83       	std	Y+2, r25	; 0x02
   10768:	89 83       	std	Y+1, r24	; 0x01

        result = axis_handle->transport.SendCommand(axis_handle->transport_data, 1, buffer, 2, buffer+1);
   1076a:	df 01       	movw	r26, r30
   1076c:	a2 5a       	subi	r26, 0xA2	; 162
   1076e:	bf 4f       	sbci	r27, 0xFF	; 255
   10770:	e0 5b       	subi	r30, 0xB0	; 176
   10772:	ff 4f       	sbci	r31, 0xFF	; 255
   10774:	01 90       	ld	r0, Z+
   10776:	f0 81       	ld	r31, Z
   10778:	e0 2d       	mov	r30, r0
   1077a:	8d 91       	ld	r24, X+
   1077c:	9c 91       	ld	r25, X
   1077e:	61 e0       	ldi	r22, 0x01	; 1
   10780:	ae 01       	movw	r20, r28
   10782:	4f 5f       	subi	r20, 0xFF	; 255
   10784:	5f 4f       	sbci	r21, 0xFF	; 255
   10786:	22 e0       	ldi	r18, 0x02	; 2
   10788:	8e 01       	movw	r16, r28
   1078a:	0d 5f       	subi	r16, 0xFD	; 253
   1078c:	1f 4f       	sbci	r17, 0xFF	; 255
   1078e:	09 95       	icall

        *data1 = ((PMDuint32)buffer[1])<<16 | ((PMDuint32)buffer[2]);
   10790:	2b 81       	ldd	r18, Y+3	; 0x03
   10792:	3c 81       	ldd	r19, Y+4	; 0x04
   10794:	40 e0       	ldi	r20, 0x00	; 0
   10796:	50 e0       	ldi	r21, 0x00	; 0
   10798:	a9 01       	movw	r20, r18
   1079a:	33 27       	eor	r19, r19
   1079c:	22 27       	eor	r18, r18
   1079e:	ed 80       	ldd	r14, Y+5	; 0x05
   107a0:	fe 80       	ldd	r15, Y+6	; 0x06
   107a2:	00 e0       	ldi	r16, 0x00	; 0
   107a4:	10 e0       	ldi	r17, 0x00	; 0
   107a6:	2e 29       	or	r18, r14
   107a8:	3f 29       	or	r19, r15
   107aa:	40 2b       	or	r20, r16
   107ac:	51 2b       	or	r21, r17
   107ae:	f6 01       	movw	r30, r12
   107b0:	20 83       	st	Z, r18
   107b2:	31 83       	std	Z+1, r19	; 0x01
   107b4:	42 83       	std	Z+2, r20	; 0x02
   107b6:	53 83       	std	Z+3, r21	; 0x03

        return result;
}
   107b8:	26 96       	adiw	r28, 0x06	; 6
   107ba:	0f b6       	in	r0, 0x3f	; 63
   107bc:	f8 94       	cli
   107be:	de bf       	out	0x3e, r29	; 62
   107c0:	0f be       	out	0x3f, r0	; 63
   107c2:	cd bf       	out	0x3d, r28	; 61
   107c4:	cf 91       	pop	r28
   107c6:	df 91       	pop	r29
   107c8:	1f 91       	pop	r17
   107ca:	0f 91       	pop	r16
   107cc:	ff 90       	pop	r15
   107ce:	ef 90       	pop	r14
   107d0:	df 90       	pop	r13
   107d2:	cf 90       	pop	r12
   107d4:	08 95       	ret

000107d6 <SendCommandWordGetWord>:

PMDuint16 SendCommandWordGetWord(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 data1, PMDuint16 *data2)
{
   107d6:	ef 92       	push	r14
   107d8:	ff 92       	push	r15
   107da:	0f 93       	push	r16
   107dc:	1f 93       	push	r17
   107de:	df 93       	push	r29
   107e0:	cf 93       	push	r28
   107e2:	00 d0       	rcall	.+0      	; 0x107e4 <SendCommandWordGetWord+0xe>
   107e4:	00 d0       	rcall	.+0      	; 0x107e6 <SendCommandWordGetWord+0x10>
   107e6:	00 d0       	rcall	.+0      	; 0x107e8 <SendCommandWordGetWord+0x12>
   107e8:	cd b7       	in	r28, 0x3d	; 61
   107ea:	de b7       	in	r29, 0x3e	; 62
   107ec:	fc 01       	movw	r30, r24
   107ee:	79 01       	movw	r14, r18
        PMDuint16 result = PMD_ERR_OK;
        PMDuint16 buffer[3];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
   107f0:	92 81       	ldd	r25, Z+2	; 0x02
   107f2:	80 e0       	ldi	r24, 0x00	; 0
   107f4:	86 2b       	or	r24, r22
   107f6:	97 2b       	or	r25, r23
   107f8:	9a 83       	std	Y+2, r25	; 0x02
   107fa:	89 83       	std	Y+1, r24	; 0x01
        buffer[1] = (PMDuint16)data1;
   107fc:	5c 83       	std	Y+4, r21	; 0x04
   107fe:	4b 83       	std	Y+3, r20	; 0x03

        result = axis_handle->transport.SendCommand(axis_handle->transport_data, 2, buffer, 1, buffer+2);
   10800:	df 01       	movw	r26, r30
   10802:	a2 5a       	subi	r26, 0xA2	; 162
   10804:	bf 4f       	sbci	r27, 0xFF	; 255
   10806:	e0 5b       	subi	r30, 0xB0	; 176
   10808:	ff 4f       	sbci	r31, 0xFF	; 255
   1080a:	01 90       	ld	r0, Z+
   1080c:	f0 81       	ld	r31, Z
   1080e:	e0 2d       	mov	r30, r0
   10810:	8d 91       	ld	r24, X+
   10812:	9c 91       	ld	r25, X
   10814:	62 e0       	ldi	r22, 0x02	; 2
   10816:	ae 01       	movw	r20, r28
   10818:	4f 5f       	subi	r20, 0xFF	; 255
   1081a:	5f 4f       	sbci	r21, 0xFF	; 255
   1081c:	21 e0       	ldi	r18, 0x01	; 1
   1081e:	8e 01       	movw	r16, r28
   10820:	0b 5f       	subi	r16, 0xFB	; 251
   10822:	1f 4f       	sbci	r17, 0xFF	; 255
   10824:	09 95       	icall

        *data2 = (PMDuint16)buffer[2];
   10826:	2d 81       	ldd	r18, Y+5	; 0x05
   10828:	3e 81       	ldd	r19, Y+6	; 0x06
   1082a:	f7 01       	movw	r30, r14
   1082c:	31 83       	std	Z+1, r19	; 0x01
   1082e:	20 83       	st	Z, r18

        return result;
}
   10830:	26 96       	adiw	r28, 0x06	; 6
   10832:	0f b6       	in	r0, 0x3f	; 63
   10834:	f8 94       	cli
   10836:	de bf       	out	0x3e, r29	; 62
   10838:	0f be       	out	0x3f, r0	; 63
   1083a:	cd bf       	out	0x3d, r28	; 61
   1083c:	cf 91       	pop	r28
   1083e:	df 91       	pop	r29
   10840:	1f 91       	pop	r17
   10842:	0f 91       	pop	r16
   10844:	ff 90       	pop	r15
   10846:	ef 90       	pop	r14
   10848:	08 95       	ret

0001084a <SendCommandWordGetLong>:

PMDuint16 SendCommandWordGetLong(PMDAxisHandle* axis_handle, PMDuint16 OPCode, PMDuint16 data1, PMDuint32 *data2)
{
   1084a:	cf 92       	push	r12
   1084c:	df 92       	push	r13
   1084e:	ef 92       	push	r14
   10850:	ff 92       	push	r15
   10852:	0f 93       	push	r16
   10854:	1f 93       	push	r17
   10856:	df 93       	push	r29
   10858:	cf 93       	push	r28
   1085a:	cd b7       	in	r28, 0x3d	; 61
   1085c:	de b7       	in	r29, 0x3e	; 62
   1085e:	28 97       	sbiw	r28, 0x08	; 8
   10860:	0f b6       	in	r0, 0x3f	; 63
   10862:	f8 94       	cli
   10864:	de bf       	out	0x3e, r29	; 62
   10866:	0f be       	out	0x3f, r0	; 63
   10868:	cd bf       	out	0x3d, r28	; 61
   1086a:	fc 01       	movw	r30, r24
   1086c:	69 01       	movw	r12, r18
        PMDuint16 result = PMD_ERR_OK;
        PMDuint16 buffer[4];

        buffer[0] = BuildCommand(OPCode,axis_handle->axis);
   1086e:	92 81       	ldd	r25, Z+2	; 0x02
   10870:	80 e0       	ldi	r24, 0x00	; 0
   10872:	86 2b       	or	r24, r22
   10874:	97 2b       	or	r25, r23
   10876:	9a 83       	std	Y+2, r25	; 0x02
   10878:	89 83       	std	Y+1, r24	; 0x01
        buffer[1] = (PMDuint16)data1;
   1087a:	5c 83       	std	Y+4, r21	; 0x04
   1087c:	4b 83       	std	Y+3, r20	; 0x03

        result = axis_handle->transport.SendCommand(axis_handle->transport_data, 2, buffer, 2, buffer+2);
   1087e:	df 01       	movw	r26, r30
   10880:	a2 5a       	subi	r26, 0xA2	; 162
   10882:	bf 4f       	sbci	r27, 0xFF	; 255
   10884:	e0 5b       	subi	r30, 0xB0	; 176
   10886:	ff 4f       	sbci	r31, 0xFF	; 255
   10888:	01 90       	ld	r0, Z+
   1088a:	f0 81       	ld	r31, Z
   1088c:	e0 2d       	mov	r30, r0
   1088e:	8d 91       	ld	r24, X+
   10890:	9c 91       	ld	r25, X
   10892:	62 e0       	ldi	r22, 0x02	; 2
   10894:	ae 01       	movw	r20, r28
   10896:	4f 5f       	subi	r20, 0xFF	; 255
   10898:	5f 4f       	sbci	r21, 0xFF	; 255
   1089a:	22 e0       	ldi	r18, 0x02	; 2
   1089c:	8e 01       	movw	r16, r28
   1089e:	0b 5f       	subi	r16, 0xFB	; 251
   108a0:	1f 4f       	sbci	r17, 0xFF	; 255
   108a2:	09 95       	icall

        *data2 = ((PMDuint32)buffer[2])<<16 | ((PMDuint32)buffer[3]);
   108a4:	2d 81       	ldd	r18, Y+5	; 0x05
   108a6:	3e 81       	ldd	r19, Y+6	; 0x06
   108a8:	40 e0       	ldi	r20, 0x00	; 0
   108aa:	50 e0       	ldi	r21, 0x00	; 0
   108ac:	a9 01       	movw	r20, r18
   108ae:	33 27       	eor	r19, r19
   108b0:	22 27       	eor	r18, r18
   108b2:	ef 80       	ldd	r14, Y+7	; 0x07
   108b4:	f8 84       	ldd	r15, Y+8	; 0x08
   108b6:	00 e0       	ldi	r16, 0x00	; 0
   108b8:	10 e0       	ldi	r17, 0x00	; 0
   108ba:	2e 29       	or	r18, r14
   108bc:	3f 29       	or	r19, r15
   108be:	40 2b       	or	r20, r16
   108c0:	51 2b       	or	r21, r17
   108c2:	f6 01       	movw	r30, r12
   108c4:	20 83       	st	Z, r18
   108c6:	31 83       	std	Z+1, r19	; 0x01
   108c8:	42 83       	std	Z+2, r20	; 0x02
   108ca:	53 83       	std	Z+3, r21	; 0x03

        return result;
}
   108cc:	28 96       	adiw	r28, 0x08	; 8
   108ce:	0f b6       	in	r0, 0x3f	; 63
   108d0:	f8 94       	cli
   108d2:	de bf       	out	0x3e, r29	; 62
   108d4:	0f be       	out	0x3f, r0	; 63
   108d6:	cd bf       	out	0x3d, r28	; 61
   108d8:	cf 91       	pop	r28
   108da:	df 91       	pop	r29
   108dc:	1f 91       	pop	r17
   108de:	0f 91       	pop	r16
   108e0:	ff 90       	pop	r15
   108e2:	ef 90       	pop	r14
   108e4:	df 90       	pop	r13
   108e6:	cf 90       	pop	r12
   108e8:	08 95       	ret

000108ea <uart_init>:
{
#if F_CPU < 2000000UL && defined(U2X)
  UCSRA = _BV(U2X);             /* improve baud rate error by using 2x clk */
  UBRRL = (F_CPU / (8UL * UART_BAUD)) - 1;
#else
  UBRRL = (F_CPU / (16UL * UART_BAUD)) - 1;
   108ea:	83 e3       	ldi	r24, 0x33	; 51
   108ec:	80 93 d4 00 	sts	0x00D4, r24
#endif
  UCSRB = _BV(TXEN) | _BV(RXEN); /* tx/rx enable */
   108f0:	88 e1       	ldi	r24, 0x18	; 24
   108f2:	80 93 d1 00 	sts	0x00D1, r24
}
   108f6:	08 95       	ret

000108f8 <uart_putchar>:
 * Send character c down the UART Tx, wait until tx holding register
 * is empty.
 */
int
uart_putchar(char c, FILE *stream)
{
   108f8:	1f 93       	push	r17
   108fa:	18 2f       	mov	r17, r24

  if (c == '\n')
   108fc:	8a 30       	cpi	r24, 0x0A	; 10
   108fe:	19 f4       	brne	.+6      	; 0x10906 <uart_putchar+0xe>
    uart_putchar('\r', stream);
   10900:	8d e0       	ldi	r24, 0x0D	; 13
   10902:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
  loop_until_bit_is_set(UCSRA, UDRE);
   10906:	80 91 d0 00 	lds	r24, 0x00D0
   1090a:	85 ff       	sbrs	r24, 5
   1090c:	fc cf       	rjmp	.-8      	; 0x10906 <uart_putchar+0xe>
  UDR = c;
   1090e:	10 93 d6 00 	sts	0x00D6, r17

  return 0;
}
   10912:	80 e0       	ldi	r24, 0x00	; 0
   10914:	90 e0       	ldi	r25, 0x00	; 0
   10916:	1f 91       	pop	r17
   10918:	08 95       	ret

0001091a <uart_getchar>:
 * Successive calls to uart_getchar() will be satisfied from the
 * internal buffer until that buffer is emptied again.
 */
int
uart_getchar(FILE *stream)
{
   1091a:	ef 92       	push	r14
   1091c:	ff 92       	push	r15
   1091e:	0f 93       	push	r16
   10920:	1f 93       	push	r17
   10922:	cf 93       	push	r28
   10924:	df 93       	push	r29
   10926:	7c 01       	movw	r14, r24
  uint8_t c;
  char *cp, *cp2;
  static char b[RX_BUFSIZE];
  static char *rxp;

  if (rxp == 0)
   10928:	80 91 b9 74 	lds	r24, 0x74B9
   1092c:	90 91 ba 74 	lds	r25, 0x74BA
   10930:	89 2b       	or	r24, r25
   10932:	09 f0       	breq	.+2      	; 0x10936 <uart_getchar+0x1c>
   10934:	9f c0       	rjmp	.+318    	; 0x10a74 <uart_getchar+0x15a>
   10936:	0b eb       	ldi	r16, 0xBB	; 187
   10938:	14 e7       	ldi	r17, 0x74	; 116
    for (cp = b;;)
      {
	loop_until_bit_is_set(UCSRA, RXC);
   1093a:	80 91 d0 00 	lds	r24, 0x00D0
   1093e:	87 ff       	sbrs	r24, 7
   10940:	fc cf       	rjmp	.-8      	; 0x1093a <uart_getchar+0x20>
	if (UCSRA & _BV(FE))
   10942:	80 91 d0 00 	lds	r24, 0x00D0
   10946:	84 ff       	sbrs	r24, 4
   10948:	03 c0       	rjmp	.+6      	; 0x10950 <uart_getchar+0x36>
   1094a:	2e ef       	ldi	r18, 0xFE	; 254
   1094c:	3f ef       	ldi	r19, 0xFF	; 255
   1094e:	a6 c0       	rjmp	.+332    	; 0x10a9c <uart_getchar+0x182>
	  return _FDEV_EOF;
	if (UCSRA & _BV(DOR))
   10950:	80 91 d0 00 	lds	r24, 0x00D0
   10954:	83 fd       	sbrc	r24, 3
   10956:	a0 c0       	rjmp	.+320    	; 0x10a98 <uart_getchar+0x17e>
	  return _FDEV_ERR;
	c = UDR;
   10958:	90 91 d6 00 	lds	r25, 0x00D6
	/* behaviour similar to Unix stty ICRNL */
	if (c == '\r')
   1095c:	9d 30       	cpi	r25, 0x0D	; 13
   1095e:	11 f0       	breq	.+4      	; 0x10964 <uart_getchar+0x4a>
	  c = '\n';
	if (c == '\n')
   10960:	9a 30       	cpi	r25, 0x0A	; 10
   10962:	69 f4       	brne	.+26     	; 0x1097e <uart_getchar+0x64>
	  {
	    *cp = c;
   10964:	8a e0       	ldi	r24, 0x0A	; 10
   10966:	f8 01       	movw	r30, r16
   10968:	80 83       	st	Z, r24
	    uart_putchar(c, stream);
   1096a:	b7 01       	movw	r22, r14
   1096c:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
	    rxp = b;
   10970:	8b eb       	ldi	r24, 0xBB	; 187
   10972:	94 e7       	ldi	r25, 0x74	; 116
   10974:	90 93 ba 74 	sts	0x74BA, r25
   10978:	80 93 b9 74 	sts	0x74B9, r24
   1097c:	7b c0       	rjmp	.+246    	; 0x10a74 <uart_getchar+0x15a>
	    break;
	  }
	else if (c == '\t')
   1097e:	99 30       	cpi	r25, 0x09	; 9
   10980:	09 f4       	brne	.+2      	; 0x10984 <uart_getchar+0x6a>
   10982:	90 e2       	ldi	r25, 0x20	; 32
	  c = ' ';

	if ((c >= (uint8_t)' ' && c <= (uint8_t)'\x7e') ||
   10984:	89 2f       	mov	r24, r25
   10986:	80 52       	subi	r24, 0x20	; 32
   10988:	8f 35       	cpi	r24, 0x5F	; 95
   1098a:	10 f0       	brcs	.+4      	; 0x10990 <uart_getchar+0x76>
   1098c:	90 3a       	cpi	r25, 0xA0	; 160
   1098e:	70 f0       	brcs	.+28     	; 0x109ac <uart_getchar+0x92>
	    c >= (uint8_t)'\xa0')
	  {
	    if (cp == b + RX_BUFSIZE - 1)
   10990:	f5 e7       	ldi	r31, 0x75	; 117
   10992:	0a 30       	cpi	r16, 0x0A	; 10
   10994:	1f 07       	cpc	r17, r31
   10996:	11 f4       	brne	.+4      	; 0x1099c <uart_getchar+0x82>
	      uart_putchar('\a', stream);
   10998:	87 e0       	ldi	r24, 0x07	; 7
   1099a:	04 c0       	rjmp	.+8      	; 0x109a4 <uart_getchar+0x8a>
	    else
	      {
		*cp++ = c;
   1099c:	f8 01       	movw	r30, r16
   1099e:	91 93       	st	Z+, r25
   109a0:	8f 01       	movw	r16, r30
		uart_putchar(c, stream);
   109a2:	89 2f       	mov	r24, r25
   109a4:	b7 01       	movw	r22, r14
   109a6:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
   109aa:	c7 cf       	rjmp	.-114    	; 0x1093a <uart_getchar+0x20>
	      }
	    continue;
	  }

	switch (c)
   109ac:	92 31       	cpi	r25, 0x12	; 18
   109ae:	39 f1       	breq	.+78     	; 0x109fe <uart_getchar+0xe4>
   109b0:	93 31       	cpi	r25, 0x13	; 19
   109b2:	38 f4       	brcc	.+14     	; 0x109c2 <uart_getchar+0xa8>
   109b4:	93 30       	cpi	r25, 0x03	; 3
   109b6:	09 f4       	brne	.+2      	; 0x109ba <uart_getchar+0xa0>
   109b8:	6f c0       	rjmp	.+222    	; 0x10a98 <uart_getchar+0x17e>
   109ba:	98 30       	cpi	r25, 0x08	; 8
   109bc:	09 f0       	breq	.+2      	; 0x109c0 <uart_getchar+0xa6>
   109be:	bd cf       	rjmp	.-134    	; 0x1093a <uart_getchar+0x20>
   109c0:	09 c0       	rjmp	.+18     	; 0x109d4 <uart_getchar+0xba>
   109c2:	97 31       	cpi	r25, 0x17	; 23
   109c4:	09 f4       	brne	.+2      	; 0x109c8 <uart_getchar+0xae>
   109c6:	4b c0       	rjmp	.+150    	; 0x10a5e <uart_getchar+0x144>
   109c8:	9f 37       	cpi	r25, 0x7F	; 127
   109ca:	21 f0       	breq	.+8      	; 0x109d4 <uart_getchar+0xba>
   109cc:	95 31       	cpi	r25, 0x15	; 21
   109ce:	09 f0       	breq	.+2      	; 0x109d2 <uart_getchar+0xb8>
   109d0:	b4 cf       	rjmp	.-152    	; 0x1093a <uart_getchar+0x20>
   109d2:	32 c0       	rjmp	.+100    	; 0x10a38 <uart_getchar+0x11e>
	  case 'c' & 0x1f:
	    return -1;

	  case '\b':
	  case '\x7f':
	    if (cp > b)
   109d4:	f4 e7       	ldi	r31, 0x74	; 116
   109d6:	0b 3b       	cpi	r16, 0xBB	; 187
   109d8:	1f 07       	cpc	r17, r31
   109da:	09 f0       	breq	.+2      	; 0x109de <uart_getchar+0xc4>
   109dc:	08 f4       	brcc	.+2      	; 0x109e0 <uart_getchar+0xc6>
   109de:	ad cf       	rjmp	.-166    	; 0x1093a <uart_getchar+0x20>
	      {
		uart_putchar('\b', stream);
   109e0:	88 e0       	ldi	r24, 0x08	; 8
   109e2:	b7 01       	movw	r22, r14
   109e4:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
		uart_putchar(' ', stream);
   109e8:	80 e2       	ldi	r24, 0x20	; 32
   109ea:	b7 01       	movw	r22, r14
   109ec:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
		uart_putchar('\b', stream);
   109f0:	88 e0       	ldi	r24, 0x08	; 8
   109f2:	b7 01       	movw	r22, r14
   109f4:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
		cp--;
   109f8:	01 50       	subi	r16, 0x01	; 1
   109fa:	10 40       	sbci	r17, 0x00	; 0
   109fc:	9e cf       	rjmp	.-196    	; 0x1093a <uart_getchar+0x20>
	      }
	    break;

	  case 'r' & 0x1f:
	    uart_putchar('\r', stream);
   109fe:	8d e0       	ldi	r24, 0x0D	; 13
   10a00:	b7 01       	movw	r22, r14
   10a02:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
   10a06:	cb eb       	ldi	r28, 0xBB	; 187
   10a08:	d4 e7       	ldi	r29, 0x74	; 116
   10a0a:	04 c0       	rjmp	.+8      	; 0x10a14 <uart_getchar+0xfa>
	    for (cp2 = b; cp2 < cp; cp2++)
	      uart_putchar(*cp2, stream);
   10a0c:	89 91       	ld	r24, Y+
   10a0e:	b7 01       	movw	r22, r14
   10a10:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
	      }
	    break;

	  case 'r' & 0x1f:
	    uart_putchar('\r', stream);
	    for (cp2 = b; cp2 < cp; cp2++)
   10a14:	c0 17       	cp	r28, r16
   10a16:	d1 07       	cpc	r29, r17
   10a18:	c8 f3       	brcs	.-14     	; 0x10a0c <uart_getchar+0xf2>
   10a1a:	8f cf       	rjmp	.-226    	; 0x1093a <uart_getchar+0x20>
	    break;

	  case 'u' & 0x1f:
	    while (cp > b)
	      {
		uart_putchar('\b', stream);
   10a1c:	88 e0       	ldi	r24, 0x08	; 8
   10a1e:	b7 01       	movw	r22, r14
   10a20:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
		uart_putchar(' ', stream);
   10a24:	80 e2       	ldi	r24, 0x20	; 32
   10a26:	b7 01       	movw	r22, r14
   10a28:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
		uart_putchar('\b', stream);
   10a2c:	88 e0       	ldi	r24, 0x08	; 8
   10a2e:	b7 01       	movw	r22, r14
   10a30:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
		cp--;
   10a34:	01 50       	subi	r16, 0x01	; 1
   10a36:	10 40       	sbci	r17, 0x00	; 0
	    for (cp2 = b; cp2 < cp; cp2++)
	      uart_putchar(*cp2, stream);
	    break;

	  case 'u' & 0x1f:
	    while (cp > b)
   10a38:	84 e7       	ldi	r24, 0x74	; 116
   10a3a:	0b 3b       	cpi	r16, 0xBB	; 187
   10a3c:	18 07       	cpc	r17, r24
   10a3e:	09 f0       	breq	.+2      	; 0x10a42 <uart_getchar+0x128>
   10a40:	68 f7       	brcc	.-38     	; 0x10a1c <uart_getchar+0x102>
   10a42:	7b cf       	rjmp	.-266    	; 0x1093a <uart_getchar+0x20>
	    break;

	  case 'w' & 0x1f:
	    while (cp > b && cp[-1] != ' ')
	      {
		uart_putchar('\b', stream);
   10a44:	88 e0       	ldi	r24, 0x08	; 8
   10a46:	b7 01       	movw	r22, r14
   10a48:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
		uart_putchar(' ', stream);
   10a4c:	80 e2       	ldi	r24, 0x20	; 32
   10a4e:	b7 01       	movw	r22, r14
   10a50:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
		uart_putchar('\b', stream);
   10a54:	88 e0       	ldi	r24, 0x08	; 8
   10a56:	b7 01       	movw	r22, r14
   10a58:	0e 94 7c 84 	call	0x108f8	; 0x108f8 <uart_putchar>
   10a5c:	8e 01       	movw	r16, r28
		cp--;
	      }
	    break;

	  case 'w' & 0x1f:
	    while (cp > b && cp[-1] != ' ')
   10a5e:	e4 e7       	ldi	r30, 0x74	; 116
   10a60:	0b 3b       	cpi	r16, 0xBB	; 187
   10a62:	1e 07       	cpc	r17, r30
   10a64:	09 f0       	breq	.+2      	; 0x10a68 <uart_getchar+0x14e>
   10a66:	08 f4       	brcc	.+2      	; 0x10a6a <uart_getchar+0x150>
   10a68:	68 cf       	rjmp	.-304    	; 0x1093a <uart_getchar+0x20>
   10a6a:	e8 01       	movw	r28, r16
   10a6c:	8a 91       	ld	r24, -Y
   10a6e:	80 32       	cpi	r24, 0x20	; 32
   10a70:	49 f7       	brne	.-46     	; 0x10a44 <uart_getchar+0x12a>
   10a72:	63 cf       	rjmp	.-314    	; 0x1093a <uart_getchar+0x20>
	      }
	    break;
	  }
      }

  c = *rxp++;
   10a74:	e0 91 b9 74 	lds	r30, 0x74B9
   10a78:	f0 91 ba 74 	lds	r31, 0x74BA
   10a7c:	81 91       	ld	r24, Z+
   10a7e:	f0 93 ba 74 	sts	0x74BA, r31
   10a82:	e0 93 b9 74 	sts	0x74B9, r30
  if (c == '\n')
   10a86:	8a 30       	cpi	r24, 0x0A	; 10
   10a88:	21 f4       	brne	.+8      	; 0x10a92 <uart_getchar+0x178>
    rxp = 0;
   10a8a:	10 92 ba 74 	sts	0x74BA, r1
   10a8e:	10 92 b9 74 	sts	0x74B9, r1

  return c;
   10a92:	28 2f       	mov	r18, r24
   10a94:	30 e0       	ldi	r19, 0x00	; 0
   10a96:	02 c0       	rjmp	.+4      	; 0x10a9c <uart_getchar+0x182>
   10a98:	2f ef       	ldi	r18, 0xFF	; 255
   10a9a:	3f ef       	ldi	r19, 0xFF	; 255
}
   10a9c:	c9 01       	movw	r24, r18
   10a9e:	df 91       	pop	r29
   10aa0:	cf 91       	pop	r28
   10aa2:	1f 91       	pop	r17
   10aa4:	0f 91       	pop	r16
   10aa6:	ff 90       	pop	r15
   10aa8:	ef 90       	pop	r14
   10aaa:	08 95       	ret

00010aac <hd44780_outnibble>:
/*
 * Send one nibble out to the LCD controller.
 */
static void
hd44780_outnibble(uint8_t n, uint8_t rs)
{
   10aac:	98 2f       	mov	r25, r24
	uint8_t x;

	HD44780_PORTOUT &= ~_BV(HD44780_RW);
   10aae:	2c 98       	cbi	0x05, 4	; 5
	if (rs)
   10ab0:	66 23       	and	r22, r22
   10ab2:	11 f0       	breq	.+4      	; 0x10ab8 <hd44780_outnibble+0xc>
		HD44780_PORTOUT |= _BV(HD44780_RS);
   10ab4:	2e 9a       	sbi	0x05, 6	; 5
   10ab6:	01 c0       	rjmp	.+2      	; 0x10aba <hd44780_outnibble+0xe>
	else
		HD44780_PORTOUT &= ~_BV(HD44780_RS);
   10ab8:	2e 98       	cbi	0x05, 6	; 5
  
	x = (HD44780_PORTOUT & ~HD44780_DATABITS) | ((n << HD44780_D4) & HD44780_DATABITS);
   10aba:	85 b1       	in	r24, 0x05	; 5
   10abc:	9f 70       	andi	r25, 0x0F	; 15
   10abe:	80 7f       	andi	r24, 0xF0	; 240
   10ac0:	89 2b       	or	r24, r25
	HD44780_PORTOUT = x;
   10ac2:	85 b9       	out	0x05, r24	; 5
static inline uint8_t
hd44780_pulse_e(bool readback)
{
	uint8_t x;

	HD44780_PORTOUT |= _BV(HD44780_E);
   10ac4:	2d 9a       	sbi	0x05, 5	; 5
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
   10ac6:	81 e0       	ldi	r24, 0x01	; 1
   10ac8:	8a 95       	dec	r24
   10aca:	f1 f7       	brne	.-4      	; 0x10ac8 <hd44780_outnibble+0x1c>
	#endif
	if (readback)
		x = HD44780_PORTIN & HD44780_DATABITS;
	else
		x = 0;
	HD44780_PORTOUT &= ~_BV(HD44780_E);
   10acc:	2d 98       	cbi	0x05, 5	; 5
		HD44780_PORTOUT &= ~_BV(HD44780_RS);
  
	x = (HD44780_PORTOUT & ~HD44780_DATABITS) | ((n << HD44780_D4) & HD44780_DATABITS);
	HD44780_PORTOUT = x;
	(void)hd44780_pulse_e(false);
}
   10ace:	08 95       	ret

00010ad0 <hd44780_outbyte>:
/*
 * Send one byte to the LCD controller.  As we are in 4-bit mode, we
 * have to send two nibbles.
 */
void hd44780_outbyte(uint8_t b, uint8_t rs)
{
   10ad0:	0f 93       	push	r16
   10ad2:	1f 93       	push	r17
   10ad4:	18 2f       	mov	r17, r24
   10ad6:	06 2f       	mov	r16, r22
	hd44780_outnibble(b >> 4, rs);
   10ad8:	82 95       	swap	r24
   10ada:	8f 70       	andi	r24, 0x0F	; 15
   10adc:	0e 94 56 85 	call	0x10aac	; 0x10aac <hd44780_outnibble>
	hd44780_outnibble(b & 0xf, rs);
   10ae0:	81 2f       	mov	r24, r17
   10ae2:	8f 70       	andi	r24, 0x0F	; 15
   10ae4:	60 2f       	mov	r22, r16
   10ae6:	0e 94 56 85 	call	0x10aac	; 0x10aac <hd44780_outnibble>
}
   10aea:	1f 91       	pop	r17
   10aec:	0f 91       	pop	r16
   10aee:	08 95       	ret

00010af0 <hd44780_innibble>:
 */
static uint8_t hd44780_innibble(uint8_t rs)
{
	uint8_t x;

	HD44780_PORTOUT |= _BV(HD44780_RW);
   10af0:	2c 9a       	sbi	0x05, 4	; 5
	HD44780_DDR &= ~HD44780_DATABITS;
   10af2:	94 b1       	in	r25, 0x04	; 4
   10af4:	90 7f       	andi	r25, 0xF0	; 240
   10af6:	94 b9       	out	0x04, r25	; 4
	if (rs)
   10af8:	88 23       	and	r24, r24
   10afa:	11 f0       	breq	.+4      	; 0x10b00 <hd44780_innibble+0x10>
		HD44780_PORTOUT |= _BV(HD44780_RS);
   10afc:	2e 9a       	sbi	0x05, 6	; 5
   10afe:	01 c0       	rjmp	.+2      	; 0x10b02 <hd44780_innibble+0x12>
	else
		HD44780_PORTOUT &= ~_BV(HD44780_RS);
   10b00:	2e 98       	cbi	0x05, 6	; 5
static inline uint8_t
hd44780_pulse_e(bool readback)
{
	uint8_t x;

	HD44780_PORTOUT |= _BV(HD44780_E);
   10b02:	2d 9a       	sbi	0x05, 5	; 5
   10b04:	81 e0       	ldi	r24, 0x01	; 1
   10b06:	8a 95       	dec	r24
   10b08:	f1 f7       	brne	.-4      	; 0x10b06 <hd44780_innibble+0x16>
					__asm__ volatile("nop");
				#    endif /* F_CPU > 2000000UL */
			#  endif /* F_CPU > 1000000UL */
	#endif
	if (readback)
		x = HD44780_PORTIN & HD44780_DATABITS;
   10b0a:	83 b1       	in	r24, 0x03	; 3
	else
		x = 0;
	HD44780_PORTOUT &= ~_BV(HD44780_E);
   10b0c:	2d 98       	cbi	0x05, 5	; 5
		HD44780_PORTOUT |= _BV(HD44780_RS);
	else
		HD44780_PORTOUT &= ~_BV(HD44780_RS);
  
	x = hd44780_pulse_e(true);
	HD44780_DDR |= HD44780_DATABITS;
   10b0e:	94 b1       	in	r25, 0x04	; 4
   10b10:	9f 60       	ori	r25, 0x0F	; 15
   10b12:	94 b9       	out	0x04, r25	; 4
	HD44780_PORTOUT &= ~_BV(HD44780_RW);
   10b14:	2c 98       	cbi	0x05, 4	; 5

	return (x & HD44780_DATABITS) >> HD44780_D4;
}
   10b16:	8f 70       	andi	r24, 0x0F	; 15
   10b18:	08 95       	ret

00010b1a <hd44780_inbyte>:
/*
 * Read one byte (i.e. two nibbles) from the LCD controller.
 */
uint8_t
hd44780_inbyte(uint8_t rs)
{
   10b1a:	0f 93       	push	r16
   10b1c:	1f 93       	push	r17
   10b1e:	18 2f       	mov	r17, r24
  uint8_t x;

  x = hd44780_innibble(rs) << 4;
   10b20:	0e 94 78 85 	call	0x10af0	; 0x10af0 <hd44780_innibble>
   10b24:	08 2f       	mov	r16, r24
   10b26:	02 95       	swap	r16
   10b28:	00 7f       	andi	r16, 0xF0	; 240
  x |= hd44780_innibble(rs);
   10b2a:	81 2f       	mov	r24, r17
   10b2c:	0e 94 78 85 	call	0x10af0	; 0x10af0 <hd44780_innibble>

  return x;
}
   10b30:	80 2b       	or	r24, r16
   10b32:	1f 91       	pop	r17
   10b34:	0f 91       	pop	r16
   10b36:	08 95       	ret

00010b38 <hd44780_wait_ready>:
 * Wait until the busy flag is cleared.
 */
void
hd44780_wait_ready(void)
{
  while (hd44780_incmd() & HD44780_BUSYFLAG) ;
   10b38:	80 e0       	ldi	r24, 0x00	; 0
   10b3a:	0e 94 8d 85 	call	0x10b1a	; 0x10b1a <hd44780_inbyte>
   10b3e:	87 fd       	sbrc	r24, 7
   10b40:	fb cf       	rjmp	.-10     	; 0x10b38 <hd44780_wait_ready>
}
   10b42:	08 95       	ret

00010b44 <hd44780_init>:
 */
void
hd44780_init(void)
{

	HD44780_DDR = _BV(HD44780_RS) | _BV(HD44780_RW) | _BV(HD44780_E) | HD44780_DATABITS;
   10b44:	8f e7       	ldi	r24, 0x7F	; 127
   10b46:	84 b9       	out	0x04, r24	; 4
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
   10b48:	80 e3       	ldi	r24, 0x30	; 48
   10b4a:	95 e7       	ldi	r25, 0x75	; 117
   10b4c:	01 97       	sbiw	r24, 0x01	; 1
   10b4e:	f1 f7       	brne	.-4      	; 0x10b4c <hd44780_init+0x8>
	_delay_ms(15);		/* 40 ms needed for Vcc = 2.7 V */
	hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
   10b50:	83 e0       	ldi	r24, 0x03	; 3
   10b52:	60 e0       	ldi	r22, 0x00	; 0
   10b54:	0e 94 56 85 	call	0x10aac	; 0x10aac <hd44780_outnibble>
   10b58:	88 e0       	ldi	r24, 0x08	; 8
   10b5a:	90 e2       	ldi	r25, 0x20	; 32
   10b5c:	01 97       	sbiw	r24, 0x01	; 1
   10b5e:	f1 f7       	brne	.-4      	; 0x10b5c <hd44780_init+0x18>
	_delay_ms(4.1);
	hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
   10b60:	83 e0       	ldi	r24, 0x03	; 3
   10b62:	60 e0       	ldi	r22, 0x00	; 0
   10b64:	0e 94 56 85 	call	0x10aac	; 0x10aac <hd44780_outnibble>
   10b68:	88 ec       	ldi	r24, 0xC8	; 200
   10b6a:	90 e0       	ldi	r25, 0x00	; 0
   10b6c:	01 97       	sbiw	r24, 0x01	; 1
   10b6e:	f1 f7       	brne	.-4      	; 0x10b6c <hd44780_init+0x28>
	_delay_ms(0.1);
	hd44780_outnibble(HD44780_FNSET(1, 0, 0) >> 4, 0);
   10b70:	83 e0       	ldi	r24, 0x03	; 3
   10b72:	60 e0       	ldi	r22, 0x00	; 0
   10b74:	0e 94 56 85 	call	0x10aac	; 0x10aac <hd44780_outnibble>

	hd44780_outnibble(HD44780_FNSET(0, 1, 0) >> 4, 0);
   10b78:	82 e0       	ldi	r24, 0x02	; 2
   10b7a:	60 e0       	ldi	r22, 0x00	; 0
   10b7c:	0e 94 56 85 	call	0x10aac	; 0x10aac <hd44780_outnibble>
	hd44780_wait_ready();
   10b80:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>
	hd44780_outcmd(HD44780_FNSET(0, 1, 0));
   10b84:	88 e2       	ldi	r24, 0x28	; 40
   10b86:	60 e0       	ldi	r22, 0x00	; 0
   10b88:	0e 94 68 85 	call	0x10ad0	; 0x10ad0 <hd44780_outbyte>
	hd44780_wait_ready();
   10b8c:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>
	hd44780_outcmd(HD44780_DISPCTL(0, 0, 0));
   10b90:	88 e0       	ldi	r24, 0x08	; 8
   10b92:	60 e0       	ldi	r22, 0x00	; 0
   10b94:	0e 94 68 85 	call	0x10ad0	; 0x10ad0 <hd44780_outbyte>
	hd44780_wait_ready();
   10b98:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>
}
   10b9c:	08 95       	ret

00010b9e <lcd_putchar>:
 */


int
lcd_putchar(char c, FILE *unused)
{
   10b9e:	1f 93       	push	r17
   10ba0:	18 2f       	mov	r17, r24
	static bool nl_seen;
	
	uint8 addr;

	if (nl_seen && c != '\n')
   10ba2:	80 91 0b 75 	lds	r24, 0x750B
   10ba6:	88 23       	and	r24, r24
   10ba8:	b9 f0       	breq	.+46     	; 0x10bd8 <lcd_putchar+0x3a>
   10baa:	1a 30       	cpi	r17, 0x0A	; 10
   10bac:	b9 f0       	breq	.+46     	; 0x10bdc <lcd_putchar+0x3e>
	{
		
		// First character after newline, clear display and home cursor.
		
		hd44780_wait_ready();
   10bae:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>
		hd44780_outcmd(HD44780_CLR);
   10bb2:	81 e0       	ldi	r24, 0x01	; 1
   10bb4:	60 e0       	ldi	r22, 0x00	; 0
   10bb6:	0e 94 68 85 	call	0x10ad0	; 0x10ad0 <hd44780_outbyte>
		hd44780_wait_ready();
   10bba:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>
		hd44780_outcmd(HD44780_HOME);
   10bbe:	82 e0       	ldi	r24, 0x02	; 2
   10bc0:	60 e0       	ldi	r22, 0x00	; 0
   10bc2:	0e 94 68 85 	call	0x10ad0	; 0x10ad0 <hd44780_outbyte>
		hd44780_wait_ready();
   10bc6:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>
		hd44780_outcmd(HD44780_DDADDR(0));
   10bca:	80 e8       	ldi	r24, 0x80	; 128
   10bcc:	60 e0       	ldi	r22, 0x00	; 0
   10bce:	0e 94 68 85 	call	0x10ad0	; 0x10ad0 <hd44780_outbyte>
		
		nl_seen = false;
   10bd2:	10 92 0b 75 	sts	0x750B, r1
   10bd6:	06 c0       	rjmp	.+12     	; 0x10be4 <lcd_putchar+0x46>
	}
	if (c == '\n')
   10bd8:	1a 30       	cpi	r17, 0x0A	; 10
   10bda:	21 f4       	brne	.+8      	; 0x10be4 <lcd_putchar+0x46>
    {
		nl_seen = true;
   10bdc:	81 e0       	ldi	r24, 0x01	; 1
   10bde:	80 93 0b 75 	sts	0x750B, r24
   10be2:	23 c0       	rjmp	.+70     	; 0x10c2a <lcd_putchar+0x8c>
    }
	else
    {
		
		hd44780_wait_ready();
   10be4:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>
		/* Leo el Address Counter */
		addr = hd44780_incmd();
   10be8:	80 e0       	ldi	r24, 0x00	; 0
   10bea:	0e 94 8d 85 	call	0x10b1a	; 0x10b1a <hd44780_inbyte>
		/* Obtengo solo el Address counter */
		addr = addr & (0x7F);
   10bee:	8f 77       	andi	r24, 0x7F	; 127
		
		/* Comparo si el address counter llego a la ultima columna de la primera linea del display*/
		if (addr == 0x0F)
   10bf0:	8f 30       	cpi	r24, 0x0F	; 15
   10bf2:	21 f4       	brne	.+8      	; 0x10bfc <lcd_putchar+0x5e>
		{
			hd44780_wait_ready();
   10bf4:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>
			/* Envio el address counter a la primera columna de la segunda linea del display*/
			hd44780_outcmd(HD44780_DDADDR(0x40));
   10bf8:	80 ec       	ldi	r24, 0xC0	; 192
   10bfa:	05 c0       	rjmp	.+10     	; 0x10c06 <lcd_putchar+0x68>
			
		}
		
		/* Comparo si el address counter llego a la ultima columna de la segunda linea del display*/
		if (addr == 0x4F)
   10bfc:	8f 34       	cpi	r24, 0x4F	; 79
   10bfe:	31 f4       	brne	.+12     	; 0x10c0c <lcd_putchar+0x6e>
		{
			hd44780_wait_ready();
   10c00:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>
			/* Limpio el display y posiciono el cursor en la primera columna de la primera linea. */
			hd44780_outcmd(HD44780_CLR);
   10c04:	81 e0       	ldi	r24, 0x01	; 1
   10c06:	60 e0       	ldi	r22, 0x00	; 0
   10c08:	0e 94 68 85 	call	0x10ad0	; 0x10ad0 <hd44780_outbyte>
			
		}
		
		
		hd44780_wait_ready();
   10c0c:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>
		hd44780_outdata(c);
   10c10:	81 2f       	mov	r24, r17
   10c12:	61 e0       	ldi	r22, 0x01	; 1
   10c14:	0e 94 68 85 	call	0x10ad0	; 0x10ad0 <hd44780_outbyte>
   10c18:	88 ee       	ldi	r24, 0xE8	; 232
   10c1a:	93 e0       	ldi	r25, 0x03	; 3
   10c1c:	28 ec       	ldi	r18, 0xC8	; 200
   10c1e:	30 e0       	ldi	r19, 0x00	; 0
   10c20:	f9 01       	movw	r30, r18
   10c22:	31 97       	sbiw	r30, 0x01	; 1
   10c24:	f1 f7       	brne	.-4      	; 0x10c22 <lcd_putchar+0x84>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   10c26:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   10c28:	d9 f7       	brne	.-10     	; 0x10c20 <lcd_putchar+0x82>
		_delay_ms(100);
	}

	return 0;
}
   10c2a:	80 e0       	ldi	r24, 0x00	; 0
   10c2c:	90 e0       	ldi	r25, 0x00	; 0
   10c2e:	1f 91       	pop	r17
   10c30:	08 95       	ret

00010c32 <lcd_init>:
 */
void
lcd_init(void)
{

  hd44780_init();
   10c32:	0e 94 a2 85 	call	0x10b44	; 0x10b44 <hd44780_init>

  /*
   * Clear the display.
   */
  hd44780_outcmd(HD44780_CLR);
   10c36:	81 e0       	ldi	r24, 0x01	; 1
   10c38:	60 e0       	ldi	r22, 0x00	; 0
   10c3a:	0e 94 68 85 	call	0x10ad0	; 0x10ad0 <hd44780_outbyte>
  hd44780_wait_ready();
   10c3e:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>

  /*
   * Entry mode: auto-increment address counter, no display shift in
   * effect.
   */
  hd44780_outcmd(HD44780_ENTMODE(1, 0));
   10c42:	86 e0       	ldi	r24, 0x06	; 6
   10c44:	60 e0       	ldi	r22, 0x00	; 0
   10c46:	0e 94 68 85 	call	0x10ad0	; 0x10ad0 <hd44780_outbyte>
  hd44780_wait_ready();
   10c4a:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>

  /*
   * Enable display, activate non-blinking cursor.
   */
  hd44780_outcmd(HD44780_DISPCTL(1, 1, 0));
   10c4e:	8e e0       	ldi	r24, 0x0E	; 14
   10c50:	60 e0       	ldi	r22, 0x00	; 0
   10c52:	0e 94 68 85 	call	0x10ad0	; 0x10ad0 <hd44780_outbyte>
  hd44780_wait_ready();
   10c56:	0e 94 9c 85 	call	0x10b38	; 0x10b38 <hd44780_wait_ready>
}
   10c5a:	08 95       	ret

00010c5c <TWI_init>:
{

  /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
#if defined(TWPS0)
  /* has prescaler (mega128 & newer) */
  TWSR = 0;
   10c5c:	10 92 b9 00 	sts	0x00B9, r1
#endif

#if F_CPU < 3600000UL
  TWBR = 10;			/* smallest TWBR value*/
#else
  TWBR = (F_CPU / 400000UL - 16) / 2;
   10c60:	82 e0       	ldi	r24, 0x02	; 2
   10c62:	80 93 b8 00 	sts	0x00B8, r24
#endif
}
   10c66:	08 95       	ret

00010c68 <read_bytes_I2C>:

/*****************************************************************************************************/
int16 read_bytes_I2C(uint8 sla, uint32 eeaddr, int16 len, uint8 *buf)
{
   10c68:	0f 93       	push	r16
   10c6a:	1f 93       	push	r17
   10c6c:	cf 93       	push	r28
   10c6e:	df 93       	push	r29
   10c70:	f8 2f       	mov	r31, r24
   10c72:	e8 01       	movw	r28, r16
				goto error;								/* must send stop condition */
		}
		
		
		#ifdef TWI_ADDRH
			TWDR =(uint8)((eeaddr>>8)&0xFF);			/* high 8 bits of addr if define TWI_ADDRH*/
   10c74:	bb 27       	eor	r27, r27
   10c76:	a7 2f       	mov	r26, r23
   10c78:	96 2f       	mov	r25, r22
   10c7a:	85 2f       	mov	r24, r21
   10c7c:	98 2f       	mov	r25, r24
		if (n++ >= MAX_ITER)
			return -1;
	begin:
		
		/* send start condition TWCR = Registro que controla el TWI*/
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); 
   10c7e:	a4 ea       	ldi	r26, 0xA4	; 164
		}	
		
		
		/**< send SLA+W */
		TWDR = sla | TW_WRITE; 							/* LO coloca para lectura*/
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
   10c80:	e4 e8       	ldi	r30, 0x84	; 132
			default:
				goto error;
		}
		
		/* send SLA+R */
		TWDR = sla | TW_READ;
   10c82:	1f 2f       	mov	r17, r31
   10c84:	11 60       	ori	r17, 0x01	; 1
		if (n++ >= MAX_ITER)
			return -1;
	begin:
		
		/* send start condition TWCR = Registro que controla el TWI*/
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); 
   10c86:	a0 93 bc 00 	sts	0x00BC, r26
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
   10c8a:	80 91 bc 00 	lds	r24, 0x00BC
   10c8e:	87 ff       	sbrs	r24, 7
   10c90:	fc cf       	rjmp	.-8      	; 0x10c8a <read_bytes_I2C+0x22>
		switch ((twst = TW_STATUS))
   10c92:	80 91 b9 00 	lds	r24, 0x00B9
   10c96:	88 7f       	andi	r24, 0xF8	; 248
   10c98:	80 31       	cpi	r24, 0x10	; 16
   10c9a:	49 f0       	breq	.+18     	; 0x10cae <read_bytes_I2C+0x46>
   10c9c:	88 33       	cpi	r24, 0x38	; 56
   10c9e:	99 f3       	breq	.-26     	; 0x10c86 <read_bytes_I2C+0x1e>
   10ca0:	88 30       	cpi	r24, 0x08	; 8
   10ca2:	29 f0       	breq	.+10     	; 0x10cae <read_bytes_I2C+0x46>
   10ca4:	80 93 bb 79 	sts	0x79BB, r24
   10ca8:	4f ef       	ldi	r20, 0xFF	; 255
   10caa:	5f ef       	ldi	r21, 0xFF	; 255
   10cac:	8a c0       	rjmp	.+276    	; 0x10dc2 <read_bytes_I2C+0x15a>
														/* NB: do /not/ send stop condition */
		}	
		
		
		/**< send SLA+W */
		TWDR = sla | TW_WRITE; 							/* LO coloca para lectura*/
   10cae:	f0 93 bb 00 	sts	0x00BB, r31
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
   10cb2:	e0 93 bc 00 	sts	0x00BC, r30
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
   10cb6:	80 91 bc 00 	lds	r24, 0x00BC
   10cba:	87 ff       	sbrs	r24, 7
   10cbc:	fc cf       	rjmp	.-8      	; 0x10cb6 <read_bytes_I2C+0x4e>
		switch ((twst = TW_STATUS))
   10cbe:	80 91 b9 00 	lds	r24, 0x00B9
   10cc2:	88 7f       	andi	r24, 0xF8	; 248
   10cc4:	80 32       	cpi	r24, 0x20	; 32
   10cc6:	f9 f2       	breq	.-66     	; 0x10c86 <read_bytes_I2C+0x1e>
   10cc8:	88 33       	cpi	r24, 0x38	; 56
   10cca:	e9 f2       	breq	.-70     	; 0x10c86 <read_bytes_I2C+0x1e>
   10ccc:	88 31       	cpi	r24, 0x18	; 24
   10cce:	09 f0       	breq	.+2      	; 0x10cd2 <read_bytes_I2C+0x6a>
   10cd0:	4a c0       	rjmp	.+148    	; 0x10d66 <read_bytes_I2C+0xfe>
				goto error;								/* must send stop condition */
		}
		
		
		#ifdef TWI_ADDRH
			TWDR =(uint8)((eeaddr>>8)&0xFF);			/* high 8 bits of addr if define TWI_ADDRH*/
   10cd2:	90 93 bb 00 	sts	0x00BB, r25
			TWCR = _BV(TWINT) | _BV(TWEN); 			/* clear interrupt to start transmission */
   10cd6:	e0 93 bc 00 	sts	0x00BC, r30
			while ((TWCR & _BV(TWINT)) == 0) ; 		/* wait for transmission */
   10cda:	80 91 bc 00 	lds	r24, 0x00BC
   10cde:	87 ff       	sbrs	r24, 7
   10ce0:	fc cf       	rjmp	.-8      	; 0x10cda <read_bytes_I2C+0x72>
			switch ((twst = TW_STATUS))
   10ce2:	80 91 b9 00 	lds	r24, 0x00B9
   10ce6:	88 7f       	andi	r24, 0xF8	; 248
   10ce8:	80 33       	cpi	r24, 0x30	; 48
   10cea:	c1 f1       	breq	.+112    	; 0x10d5c <read_bytes_I2C+0xf4>
   10cec:	88 33       	cpi	r24, 0x38	; 56
   10cee:	59 f2       	breq	.-106    	; 0x10c86 <read_bytes_I2C+0x1e>
   10cf0:	88 32       	cpi	r24, 0x28	; 40
   10cf2:	c9 f5       	brne	.+114    	; 0x10d66 <read_bytes_I2C+0xfe>
			}			
		#endif
		
		
     
		TWDR = (uint8)(eeaddr&0xFF);      				/* low 8 bits of addr */
   10cf4:	40 93 bb 00 	sts	0x00BB, r20
		TWCR = _BV(TWINT) | _BV(TWEN);     			/* clear interrupt to start transmission */
   10cf8:	e0 93 bc 00 	sts	0x00BC, r30
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
   10cfc:	80 91 bc 00 	lds	r24, 0x00BC
   10d00:	87 ff       	sbrs	r24, 7
   10d02:	fc cf       	rjmp	.-8      	; 0x10cfc <read_bytes_I2C+0x94>
		switch ((twst = TW_STATUS))
   10d04:	80 91 b9 00 	lds	r24, 0x00B9
   10d08:	88 7f       	andi	r24, 0xF8	; 248
   10d0a:	80 33       	cpi	r24, 0x30	; 48
   10d0c:	39 f1       	breq	.+78     	; 0x10d5c <read_bytes_I2C+0xf4>
   10d0e:	88 33       	cpi	r24, 0x38	; 56
   10d10:	09 f4       	brne	.+2      	; 0x10d14 <read_bytes_I2C+0xac>
   10d12:	b9 cf       	rjmp	.-142    	; 0x10c86 <read_bytes_I2C+0x1e>
   10d14:	88 32       	cpi	r24, 0x28	; 40
   10d16:	39 f5       	brne	.+78     	; 0x10d66 <read_bytes_I2C+0xfe>
		}
		
		
		/* 2. Next cycle(s): master receiver mode*/
		
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); 	/* send (rep.) start condition */
   10d18:	a0 93 bc 00 	sts	0x00BC, r26
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
   10d1c:	80 91 bc 00 	lds	r24, 0x00BC
   10d20:	87 ff       	sbrs	r24, 7
   10d22:	fc cf       	rjmp	.-8      	; 0x10d1c <read_bytes_I2C+0xb4>
		switch ((twst = TW_STATUS))
   10d24:	80 91 b9 00 	lds	r24, 0x00B9
   10d28:	88 7f       	andi	r24, 0xF8	; 248
   10d2a:	80 31       	cpi	r24, 0x10	; 16
   10d2c:	29 f0       	breq	.+10     	; 0x10d38 <read_bytes_I2C+0xd0>
   10d2e:	88 33       	cpi	r24, 0x38	; 56
   10d30:	09 f4       	brne	.+2      	; 0x10d34 <read_bytes_I2C+0xcc>
   10d32:	a9 cf       	rjmp	.-174    	; 0x10c86 <read_bytes_I2C+0x1e>
   10d34:	88 30       	cpi	r24, 0x08	; 8
   10d36:	b9 f4       	brne	.+46     	; 0x10d66 <read_bytes_I2C+0xfe>
			default:
				goto error;
		}
		
		/* send SLA+R */
		TWDR = sla | TW_READ;
   10d38:	10 93 bb 00 	sts	0x00BB, r17
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
   10d3c:	e0 93 bc 00 	sts	0x00BC, r30
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
   10d40:	80 91 bc 00 	lds	r24, 0x00BC
   10d44:	87 ff       	sbrs	r24, 7
   10d46:	fc cf       	rjmp	.-8      	; 0x10d40 <read_bytes_I2C+0xd8>
		switch ((twst = TW_STATUS))
   10d48:	80 91 b9 00 	lds	r24, 0x00B9
   10d4c:	88 7f       	andi	r24, 0xF8	; 248
   10d4e:	80 34       	cpi	r24, 0x40	; 64
   10d50:	69 f0       	breq	.+26     	; 0x10d6c <read_bytes_I2C+0x104>
   10d52:	88 34       	cpi	r24, 0x48	; 72
   10d54:	19 f0       	breq	.+6      	; 0x10d5c <read_bytes_I2C+0xf4>
   10d56:	88 33       	cpi	r24, 0x38	; 56
   10d58:	31 f4       	brne	.+12     	; 0x10d66 <read_bytes_I2C+0xfe>
   10d5a:	95 cf       	rjmp	.-214    	; 0x10c86 <read_bytes_I2C+0x1e>
   10d5c:	80 93 bb 79 	sts	0x79BB, r24
   10d60:	40 e0       	ldi	r20, 0x00	; 0
   10d62:	50 e0       	ldi	r21, 0x00	; 0
   10d64:	2b c0       	rjmp	.+86     	; 0x10dbc <read_bytes_I2C+0x154>
   10d66:	80 93 bb 79 	sts	0x79BB, r24
   10d6a:	19 c0       	rjmp	.+50     	; 0x10d9e <read_bytes_I2C+0x136>
   10d6c:	80 93 bb 79 	sts	0x79BB, r24
   10d70:	94 ec       	ldi	r25, 0xC4	; 196
   10d72:	40 e0       	ldi	r20, 0x00	; 0
   10d74:	50 e0       	ldi	r21, 0x00	; 0
   10d76:	1f c0       	rjmp	.+62     	; 0x10db6 <read_bytes_I2C+0x14e>
				goto error;
		}		
		
		for (twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);len > 0;len--)
		{
			if (len == 1)
   10d78:	21 30       	cpi	r18, 0x01	; 1
   10d7a:	31 05       	cpc	r19, r1
   10d7c:	09 f4       	brne	.+2      	; 0x10d80 <read_bytes_I2C+0x118>
   10d7e:	94 e8       	ldi	r25, 0x84	; 132
				twcr = _BV(TWINT) | _BV(TWEN); 		/* send NAK this time */
			
			TWCR = twcr;								/* clear int to start transmission */
   10d80:	90 93 bc 00 	sts	0x00BC, r25
			while ((TWCR & _BV(TWINT)) == 0) ; 		/* wait for transmission */
   10d84:	80 91 bc 00 	lds	r24, 0x00BC
   10d88:	87 ff       	sbrs	r24, 7
   10d8a:	fc cf       	rjmp	.-8      	; 0x10d84 <read_bytes_I2C+0x11c>
			switch ((twst = TW_STATUS))
   10d8c:	80 91 b9 00 	lds	r24, 0x00B9
   10d90:	88 7f       	andi	r24, 0xF8	; 248
   10d92:	80 93 bb 79 	sts	0x79BB, r24
   10d96:	80 35       	cpi	r24, 0x50	; 80
   10d98:	39 f0       	breq	.+14     	; 0x10da8 <read_bytes_I2C+0x140>
   10d9a:	88 35       	cpi	r24, 0x58	; 88
   10d9c:	19 f0       	breq	.+6      	; 0x10da4 <read_bytes_I2C+0x13c>
   10d9e:	4f ef       	ldi	r20, 0xFF	; 255
   10da0:	5f ef       	ldi	r21, 0xFF	; 255
   10da2:	0c c0       	rjmp	.+24     	; 0x10dbc <read_bytes_I2C+0x154>
   10da4:	20 e0       	ldi	r18, 0x00	; 0
   10da6:	30 e0       	ldi	r19, 0x00	; 0
			{
				case TW_MR_DATA_NACK:
					len = 0;							/* force end of loop */
				/* FALLTHROUGH */
				case TW_MR_DATA_ACK:
					*buf++ = TWDR;
   10da8:	80 91 bb 00 	lds	r24, 0x00BB
   10dac:	89 93       	st	Y+, r24
					rv++;
   10dae:	4f 5f       	subi	r20, 0xFF	; 255
   10db0:	5f 4f       	sbci	r21, 0xFF	; 255
				
			default:
				goto error;
		}		
		
		for (twcr = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);len > 0;len--)
   10db2:	21 50       	subi	r18, 0x01	; 1
   10db4:	30 40       	sbci	r19, 0x00	; 0
   10db6:	12 16       	cp	r1, r18
   10db8:	13 06       	cpc	r1, r19
   10dba:	f4 f2       	brlt	.-68     	; 0x10d78 <read_bytes_I2C+0x110>
		}
		
		
	quit:
		
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN); /* send stop condition */
   10dbc:	84 e9       	ldi	r24, 0x94	; 148
   10dbe:	80 93 bc 00 	sts	0x00BC, r24
		return rv;
		
	error:
		rv = -1;
		goto quit;
}
   10dc2:	ca 01       	movw	r24, r20
   10dc4:	df 91       	pop	r29
   10dc6:	cf 91       	pop	r28
   10dc8:	1f 91       	pop	r17
   10dca:	0f 91       	pop	r16
   10dcc:	08 95       	ret

00010dce <write_page_I2C>:

/*****************************************************************************************************/
int16 write_page_I2C(uint8 PAGE_SIZE,uint8 sla, uint32 eeaddr, int16 len, uint8 *buf)
{
   10dce:	af 92       	push	r10
   10dd0:	bf 92       	push	r11
   10dd2:	cf 92       	push	r12
   10dd4:	df 92       	push	r13
   10dd6:	ef 92       	push	r14
   10dd8:	ff 92       	push	r15
   10dda:	0f 93       	push	r16
   10ddc:	1f 93       	push	r17
   10dde:	cf 93       	push	r28
   10de0:	df 93       	push	r29
   10de2:	59 01       	movw	r10, r18
   10de4:	6a 01       	movw	r12, r20
   10de6:	f8 01       	movw	r30, r16
   10de8:	e7 01       	movw	r28, r14
	uint8  n = 0;
	int16 rv = 0;
	uint16 endaddr;

	/* si la direccion mas la cantidad de datos en menor a  el tamao de pagina*/
	if (eeaddr + len <  (eeaddr | (PAGE_SIZE - 1)) )  
   10dea:	08 2f       	mov	r16, r24
   10dec:	10 e0       	ldi	r17, 0x00	; 0
   10dee:	01 50       	subi	r16, 0x01	; 1
   10df0:	10 40       	sbci	r17, 0x00	; 0
   10df2:	9f 01       	movw	r18, r30
   10df4:	44 27       	eor	r20, r20
   10df6:	37 fd       	sbrc	r19, 7
   10df8:	40 95       	com	r20
   10dfa:	54 2f       	mov	r21, r20
   10dfc:	2a 0d       	add	r18, r10
   10dfe:	3b 1d       	adc	r19, r11
   10e00:	4c 1d       	adc	r20, r12
   10e02:	5d 1d       	adc	r21, r13
   10e04:	c8 01       	movw	r24, r16
   10e06:	aa 27       	eor	r26, r26
   10e08:	97 fd       	sbrc	r25, 7
   10e0a:	a0 95       	com	r26
   10e0c:	ba 2f       	mov	r27, r26
   10e0e:	8a 29       	or	r24, r10
   10e10:	9b 29       	or	r25, r11
   10e12:	ac 29       	or	r26, r12
   10e14:	bd 29       	or	r27, r13
   10e16:	28 17       	cp	r18, r24
   10e18:	39 07       	cpc	r19, r25
   10e1a:	4a 07       	cpc	r20, r26
   10e1c:	5b 07       	cpc	r21, r27
   10e1e:	20 f4       	brcc	.+8      	; 0x10e28 <write_page_I2C+0x5a>
		endaddr = eeaddr + len;
   10e20:	8f 01       	movw	r16, r30
   10e22:	0a 0d       	add	r16, r10
   10e24:	1b 1d       	adc	r17, r11
   10e26:	04 c0       	rjmp	.+8      	; 0x10e30 <write_page_I2C+0x62>
	else
		/* Entonces colocar el final hasta el fin de pagina*/
		endaddr = (eeaddr | (PAGE_SIZE - 1)) + 1;  
   10e28:	0a 29       	or	r16, r10
   10e2a:	1b 29       	or	r17, r11
   10e2c:	0f 5f       	subi	r16, 0xFF	; 255
   10e2e:	1f 4f       	sbci	r17, 0xFF	; 255
			default:
				goto error;								/* must send stop condition */
		}	
			
		#ifdef TWI_ADDRH
			TWDR =(uint8)((eeaddr>>8)&0xFF);			/* high 8 bits of addr if define TWI_ADDRH*/
   10e30:	bb 27       	eor	r27, r27
   10e32:	ad 2d       	mov	r26, r13
   10e34:	9c 2d       	mov	r25, r12
   10e36:	8b 2d       	mov	r24, r11
   10e38:	98 2f       	mov	r25, r24
		if (n++ >= MAX_ITER)
			return -1;
	begin:
		
		
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); 	/* send start condition */
   10e3a:	34 ea       	ldi	r19, 0xA4	; 164
														/* NB: do /not/ send stop condition */
		}
		
		/* send SLA+W */
		TWDR = sla | TW_WRITE;
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
   10e3c:	24 e8       	ldi	r18, 0x84	; 132
		if (n++ >= MAX_ITER)
			return -1;
	begin:
		
		
		TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN); 	/* send start condition */
   10e3e:	30 93 bc 00 	sts	0x00BC, r19
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
   10e42:	80 91 bc 00 	lds	r24, 0x00BC
   10e46:	87 ff       	sbrs	r24, 7
   10e48:	fc cf       	rjmp	.-8      	; 0x10e42 <write_page_I2C+0x74>
		twst = TW_STATUS;
   10e4a:	80 91 b9 00 	lds	r24, 0x00B9
   10e4e:	88 7f       	andi	r24, 0xF8	; 248
		
		switch (twst)
   10e50:	80 31       	cpi	r24, 0x10	; 16
   10e52:	49 f0       	breq	.+18     	; 0x10e66 <write_page_I2C+0x98>
   10e54:	88 33       	cpi	r24, 0x38	; 56
   10e56:	99 f3       	breq	.-26     	; 0x10e3e <write_page_I2C+0x70>
   10e58:	88 30       	cpi	r24, 0x08	; 8
   10e5a:	29 f0       	breq	.+10     	; 0x10e66 <write_page_I2C+0x98>
   10e5c:	80 93 bb 79 	sts	0x79BB, r24
   10e60:	6f ef       	ldi	r22, 0xFF	; 255
   10e62:	7f ef       	ldi	r23, 0xFF	; 255
   10e64:	64 c0       	rjmp	.+200    	; 0x10f2e <write_page_I2C+0x160>
				return -1;								/* error: not in start condition */
														/* NB: do /not/ send stop condition */
		}
		
		/* send SLA+W */
		TWDR = sla | TW_WRITE;
   10e66:	60 93 bb 00 	sts	0x00BB, r22
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
   10e6a:	20 93 bc 00 	sts	0x00BC, r18
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
   10e6e:	80 91 bc 00 	lds	r24, 0x00BC
   10e72:	87 ff       	sbrs	r24, 7
   10e74:	fc cf       	rjmp	.-8      	; 0x10e6e <write_page_I2C+0xa0>
		twst = TW_STATUS;
   10e76:	80 91 b9 00 	lds	r24, 0x00B9
   10e7a:	88 7f       	andi	r24, 0xF8	; 248
		
		switch (twst)
   10e7c:	80 32       	cpi	r24, 0x20	; 32
   10e7e:	f9 f2       	breq	.-66     	; 0x10e3e <write_page_I2C+0x70>
   10e80:	88 33       	cpi	r24, 0x38	; 56
   10e82:	e9 f2       	breq	.-70     	; 0x10e3e <write_page_I2C+0x70>
   10e84:	88 31       	cpi	r24, 0x18	; 24
   10e86:	49 f5       	brne	.+82     	; 0x10eda <write_page_I2C+0x10c>
			default:
				goto error;								/* must send stop condition */
		}	
			
		#ifdef TWI_ADDRH
			TWDR =(uint8)((eeaddr>>8)&0xFF);			/* high 8 bits of addr if define TWI_ADDRH*/
   10e88:	90 93 bb 00 	sts	0x00BB, r25
			TWCR = _BV(TWINT) | _BV(TWEN); 			/* clear interrupt to start transmission */
   10e8c:	20 93 bc 00 	sts	0x00BC, r18
			while ((TWCR & _BV(TWINT)) == 0) ; 		/* wait for transmission */
   10e90:	80 91 bc 00 	lds	r24, 0x00BC
   10e94:	87 ff       	sbrs	r24, 7
   10e96:	fc cf       	rjmp	.-8      	; 0x10e90 <write_page_I2C+0xc2>
			twst = TW_STATUS;
   10e98:	80 91 b9 00 	lds	r24, 0x00B9
   10e9c:	88 7f       	andi	r24, 0xF8	; 248
			
			switch (twst)
   10e9e:	80 33       	cpi	r24, 0x30	; 48
   10ea0:	b9 f0       	breq	.+46     	; 0x10ed0 <write_page_I2C+0x102>
   10ea2:	88 33       	cpi	r24, 0x38	; 56
   10ea4:	61 f2       	breq	.-104    	; 0x10e3e <write_page_I2C+0x70>
   10ea6:	88 32       	cpi	r24, 0x28	; 40
   10ea8:	c1 f4       	brne	.+48     	; 0x10eda <write_page_I2C+0x10c>
				default:
					goto error;							/* must send stop condition */
			}
		#endif
		
		TWDR = (uint8)(eeaddr&0xFF);					/* low 8 bits of addr */
   10eaa:	a0 92 bb 00 	sts	0x00BB, r10
		TWCR = _BV(TWINT) | _BV(TWEN); 				/* clear interrupt to start transmission */
   10eae:	20 93 bc 00 	sts	0x00BC, r18
		while ((TWCR & _BV(TWINT)) == 0) ; 			/* wait for transmission */
   10eb2:	80 91 bc 00 	lds	r24, 0x00BC
   10eb6:	87 ff       	sbrs	r24, 7
   10eb8:	fc cf       	rjmp	.-8      	; 0x10eb2 <write_page_I2C+0xe4>
		twst = TW_STATUS;
   10eba:	80 91 b9 00 	lds	r24, 0x00B9
   10ebe:	88 7f       	andi	r24, 0xF8	; 248
		
		switch (twst)
   10ec0:	80 33       	cpi	r24, 0x30	; 48
   10ec2:	31 f0       	breq	.+12     	; 0x10ed0 <write_page_I2C+0x102>
   10ec4:	88 33       	cpi	r24, 0x38	; 56
   10ec6:	09 f4       	brne	.+2      	; 0x10eca <write_page_I2C+0xfc>
   10ec8:	ba cf       	rjmp	.-140    	; 0x10e3e <write_page_I2C+0x70>
   10eca:	88 32       	cpi	r24, 0x28	; 40
   10ecc:	31 f4       	brne	.+12     	; 0x10eda <write_page_I2C+0x10c>
   10ece:	08 c0       	rjmp	.+16     	; 0x10ee0 <write_page_I2C+0x112>
   10ed0:	80 93 bb 79 	sts	0x79BB, r24
   10ed4:	60 e0       	ldi	r22, 0x00	; 0
   10ed6:	70 e0       	ldi	r23, 0x00	; 0
   10ed8:	27 c0       	rjmp	.+78     	; 0x10f28 <write_page_I2C+0x15a>
   10eda:	80 93 bb 79 	sts	0x79BB, r24
   10ede:	18 c0       	rjmp	.+48     	; 0x10f10 <write_page_I2C+0x142>
   10ee0:	80 93 bb 79 	sts	0x79BB, r24
		endaddr = eeaddr + len;
	else
		/* Entonces colocar el final hasta el fin de pagina*/
		endaddr = (eeaddr | (PAGE_SIZE - 1)) + 1;  
	
	len = endaddr - eeaddr;
   10ee4:	0a 19       	sub	r16, r10
   10ee6:	1b 09       	sbc	r17, r11
   10ee8:	60 e0       	ldi	r22, 0x00	; 0
   10eea:	70 e0       	ldi	r23, 0x00	; 0
		}
		
		for (; len > 0; len--)
		{
			TWDR = *buf++;
			TWCR = _BV(TWINT) | _BV(TWEN); 			/* start transmission */
   10eec:	24 e8       	ldi	r18, 0x84	; 132
   10eee:	16 c0       	rjmp	.+44     	; 0x10f1c <write_page_I2C+0x14e>
				goto error;								/* must send stop condition */
		}
		
		for (; len > 0; len--)
		{
			TWDR = *buf++;
   10ef0:	88 81       	ld	r24, Y
   10ef2:	80 93 bb 00 	sts	0x00BB, r24
			TWCR = _BV(TWINT) | _BV(TWEN); 			/* start transmission */
   10ef6:	20 93 bc 00 	sts	0x00BC, r18
			while ((TWCR & _BV(TWINT)) == 0) ; 		/* wait for transmission */
   10efa:	80 91 bc 00 	lds	r24, 0x00BC
   10efe:	87 ff       	sbrs	r24, 7
   10f00:	fc cf       	rjmp	.-8      	; 0x10efa <write_page_I2C+0x12c>
			switch ((twst = TW_STATUS))
   10f02:	80 91 b9 00 	lds	r24, 0x00B9
   10f06:	88 7f       	andi	r24, 0xF8	; 248
   10f08:	80 93 bb 79 	sts	0x79BB, r24
   10f0c:	88 32       	cpi	r24, 0x28	; 40
   10f0e:	19 f0       	breq	.+6      	; 0x10f16 <write_page_I2C+0x148>
   10f10:	6f ef       	ldi	r22, 0xFF	; 255
   10f12:	7f ef       	ldi	r23, 0xFF	; 255
   10f14:	09 c0       	rjmp	.+18     	; 0x10f28 <write_page_I2C+0x15a>
				goto error;								/* must send stop condition */
		}
		
		for (; len > 0; len--)
		{
			TWDR = *buf++;
   10f16:	21 96       	adiw	r28, 0x01	; 1
			{
				case TW_MT_DATA_NACK:
					goto error;							/* device write protected -- Note [16] */
					
				case TW_MT_DATA_ACK:
					rv++;
   10f18:	6f 5f       	subi	r22, 0xFF	; 255
   10f1a:	7f 4f       	sbci	r23, 0xFF	; 255
				
			default:
				goto error;								/* must send stop condition */
		}
		
		for (; len > 0; len--)
   10f1c:	c8 01       	movw	r24, r16
   10f1e:	86 1b       	sub	r24, r22
   10f20:	97 0b       	sbc	r25, r23
   10f22:	18 16       	cp	r1, r24
   10f24:	19 06       	cpc	r1, r25
   10f26:	24 f3       	brlt	.-56     	; 0x10ef0 <write_page_I2C+0x122>
				default:
					goto error;
			}
		}
	quit:
		TWCR = _BV(TWINT) | _BV(TWSTO) | _BV(TWEN); 	/* send stop condition */
   10f28:	84 e9       	ldi	r24, 0x94	; 148
   10f2a:	80 93 bc 00 	sts	0x00BC, r24
			return rv;
		
	error:
		rv = -1;
		goto quit;
}
   10f2e:	cb 01       	movw	r24, r22
   10f30:	df 91       	pop	r29
   10f32:	cf 91       	pop	r28
   10f34:	1f 91       	pop	r17
   10f36:	0f 91       	pop	r16
   10f38:	ff 90       	pop	r15
   10f3a:	ef 90       	pop	r14
   10f3c:	df 90       	pop	r13
   10f3e:	cf 90       	pop	r12
   10f40:	bf 90       	pop	r11
   10f42:	af 90       	pop	r10
   10f44:	08 95       	ret

00010f46 <error>:
}
/*****************************************************************************************************/
void error(void)
{

  printf("error=> TWI status %#x\n", twst);
   10f46:	00 d0       	rcall	.+0      	; 0x10f48 <error+0x2>
   10f48:	00 d0       	rcall	.+0      	; 0x10f4a <error+0x4>
   10f4a:	ed b7       	in	r30, 0x3d	; 61
   10f4c:	fe b7       	in	r31, 0x3e	; 62
   10f4e:	31 96       	adiw	r30, 0x01	; 1
   10f50:	8c eb       	ldi	r24, 0xBC	; 188
   10f52:	9f e6       	ldi	r25, 0x6F	; 111
   10f54:	ad b7       	in	r26, 0x3d	; 61
   10f56:	be b7       	in	r27, 0x3e	; 62
   10f58:	12 96       	adiw	r26, 0x02	; 2
   10f5a:	9c 93       	st	X, r25
   10f5c:	8e 93       	st	-X, r24
   10f5e:	11 97       	sbiw	r26, 0x01	; 1
   10f60:	80 91 bb 79 	lds	r24, 0x79BB
   10f64:	82 83       	std	Z+2, r24	; 0x02
   10f66:	13 82       	std	Z+3, r1	; 0x03
   10f68:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
  exit(0);
   10f6c:	0f 90       	pop	r0
   10f6e:	0f 90       	pop	r0
   10f70:	0f 90       	pop	r0
   10f72:	0f 90       	pop	r0
   10f74:	80 e0       	ldi	r24, 0x00	; 0
   10f76:	90 e0       	ldi	r25, 0x00	; 0
   10f78:	0e 94 dc a0 	call	0x141b8	; 0x141b8 <_exit>

00010f7c <write_bytes_I2C>:
		rv = -1;
		goto quit;
}
/*****************************************************************************************************/
int16 write_bytes_I2C(uint8 PAGE_SIZE,uint8 sla, uint32 eeaddr, int16 len, uint8 *buf)
{
   10f7c:	4f 92       	push	r4
   10f7e:	5f 92       	push	r5
   10f80:	6f 92       	push	r6
   10f82:	7f 92       	push	r7
   10f84:	8f 92       	push	r8
   10f86:	9f 92       	push	r9
   10f88:	af 92       	push	r10
   10f8a:	bf 92       	push	r11
   10f8c:	cf 92       	push	r12
   10f8e:	df 92       	push	r13
   10f90:	ef 92       	push	r14
   10f92:	ff 92       	push	r15
   10f94:	0f 93       	push	r16
   10f96:	1f 93       	push	r17
   10f98:	cf 93       	push	r28
   10f9a:	df 93       	push	r29
   10f9c:	48 2e       	mov	r4, r24
   10f9e:	56 2e       	mov	r5, r22
   10fa0:	59 01       	movw	r10, r18
   10fa2:	6a 01       	movw	r12, r20
   10fa4:	48 01       	movw	r8, r16
   10fa6:	37 01       	movw	r6, r14
   10fa8:	c0 e0       	ldi	r28, 0x00	; 0
   10faa:	d0 e0       	ldi	r29, 0x00	; 0
	total = 0;
  
	do
    {
		
		rv = write_page_I2C(PAGE_SIZE,sla, eeaddr, len, buf);
   10fac:	84 2d       	mov	r24, r4
   10fae:	65 2d       	mov	r22, r5
   10fb0:	a6 01       	movw	r20, r12
   10fb2:	95 01       	movw	r18, r10
   10fb4:	84 01       	movw	r16, r8
   10fb6:	73 01       	movw	r14, r6
   10fb8:	0e 94 e7 86 	call	0x10dce	; 0x10dce <write_page_I2C>
   10fbc:	9c 01       	movw	r18, r24
		if (rv == -1)
   10fbe:	8f ef       	ldi	r24, 0xFF	; 255
   10fc0:	2f 3f       	cpi	r18, 0xFF	; 255
   10fc2:	38 07       	cpc	r19, r24
   10fc4:	29 f4       	brne	.+10     	; 0x10fd0 <write_bytes_I2C+0x54>
		{
			error();
   10fc6:	0e 94 a3 87 	call	0x10f46	; 0x10f46 <error>
   10fca:	cf ef       	ldi	r28, 0xFF	; 255
   10fcc:	df ef       	ldi	r29, 0xFF	; 255
   10fce:	13 c0       	rjmp	.+38     	; 0x10ff6 <write_bytes_I2C+0x7a>
			return -1;
		}
	  
		eeaddr += rv;
		len -= rv;
   10fd0:	82 1a       	sub	r8, r18
   10fd2:	93 0a       	sbc	r9, r19
		buf += rv;
		total += rv;
   10fd4:	c2 0f       	add	r28, r18
   10fd6:	d3 1f       	adc	r29, r19
    }
  while (len > 0);
   10fd8:	18 14       	cp	r1, r8
   10fda:	19 04       	cpc	r1, r9
   10fdc:	64 f4       	brge	.+24     	; 0x10ff6 <write_bytes_I2C+0x7a>
		{
			error();
			return -1;
		}
	  
		eeaddr += rv;
   10fde:	c9 01       	movw	r24, r18
   10fe0:	aa 27       	eor	r26, r26
   10fe2:	97 fd       	sbrc	r25, 7
   10fe4:	a0 95       	com	r26
   10fe6:	ba 2f       	mov	r27, r26
   10fe8:	a8 0e       	add	r10, r24
   10fea:	b9 1e       	adc	r11, r25
   10fec:	ca 1e       	adc	r12, r26
   10fee:	db 1e       	adc	r13, r27
		len -= rv;
		buf += rv;
   10ff0:	62 0e       	add	r6, r18
   10ff2:	73 1e       	adc	r7, r19
   10ff4:	db cf       	rjmp	.-74     	; 0x10fac <write_bytes_I2C+0x30>
		total += rv;
    }
  while (len > 0);

  return total;
}
   10ff6:	ce 01       	movw	r24, r28
   10ff8:	df 91       	pop	r29
   10ffa:	cf 91       	pop	r28
   10ffc:	1f 91       	pop	r17
   10ffe:	0f 91       	pop	r16
   11000:	ff 90       	pop	r15
   11002:	ef 90       	pop	r14
   11004:	df 90       	pop	r13
   11006:	cf 90       	pop	r12
   11008:	bf 90       	pop	r11
   1100a:	af 90       	pop	r10
   1100c:	9f 90       	pop	r9
   1100e:	8f 90       	pop	r8
   11010:	7f 90       	pop	r7
   11012:	6f 90       	pop	r6
   11014:	5f 90       	pop	r5
   11016:	4f 90       	pop	r4
   11018:	08 95       	ret

0001101a <ee24xx_write_bytes>:
 
	return rv;
}
/*****************************************************************************************************/
int16 ee24xx_write_bytes(uint32 eeaddr, int16 len, uint8 *buf)	
{
   1101a:	af 92       	push	r10
   1101c:	bf 92       	push	r11
   1101e:	cf 92       	push	r12
   11020:	df 92       	push	r13
   11022:	ef 92       	push	r14
   11024:	ff 92       	push	r15
   11026:	0f 93       	push	r16
   11028:	1f 93       	push	r17
   1102a:	5b 01       	movw	r10, r22
   1102c:	6c 01       	movw	r12, r24
   1102e:	8a 01       	movw	r16, r20
   11030:	79 01       	movw	r14, r18
	sla = TWI_SLA_24LC1025 | (((eeaddr >> 16) & 0x01) << 3); 
	
	/* the 24LC1025 EEPROM permits a 128-byte writes in a page  */
	PAGE_SIZE=128;
	
	rv= write_bytes_I2C(PAGE_SIZE,sla, eeaddr, len, buf);
   11032:	96 01       	movw	r18, r12
   11034:	44 27       	eor	r20, r20
   11036:	55 27       	eor	r21, r21
   11038:	21 70       	andi	r18, 0x01	; 1
   1103a:	22 0f       	add	r18, r18
   1103c:	22 0f       	add	r18, r18
   1103e:	22 0f       	add	r18, r18
   11040:	20 6a       	ori	r18, 0xA0	; 160
   11042:	80 e8       	ldi	r24, 0x80	; 128
   11044:	62 2f       	mov	r22, r18
   11046:	a6 01       	movw	r20, r12
   11048:	95 01       	movw	r18, r10
   1104a:	0e 94 be 87 	call	0x10f7c	; 0x10f7c <write_bytes_I2C>
   1104e:	8c 01       	movw	r16, r24
	
	if (rv == -1)
   11050:	8f ef       	ldi	r24, 0xFF	; 255
   11052:	0f 3f       	cpi	r16, 0xFF	; 255
   11054:	18 07       	cpc	r17, r24
   11056:	11 f4       	brne	.+4      	; 0x1105c <ee24xx_write_bytes+0x42>
	{
		error();
   11058:	0e 94 a3 87 	call	0x10f46	; 0x10f46 <error>
		return -1;
	}
 
	return rv;	
   1105c:	c8 01       	movw	r24, r16
   1105e:	1f 91       	pop	r17
   11060:	0f 91       	pop	r16
   11062:	ff 90       	pop	r15
   11064:	ef 90       	pop	r14
   11066:	df 90       	pop	r13
   11068:	cf 90       	pop	r12
   1106a:	bf 90       	pop	r11
   1106c:	af 90       	pop	r10
   1106e:	08 95       	ret

00011070 <ee24xx_read_bytes>:
#include "types.h"
#include "tw_eeprom.h"

/*****************************************************************************************************/
int16 ee24xx_read_bytes(uint32 eeaddr, int16 len, uint8 *buf)
{
   11070:	cf 92       	push	r12
   11072:	df 92       	push	r13
   11074:	ef 92       	push	r14
   11076:	ff 92       	push	r15
   11078:	0f 93       	push	r16
   1107a:	1f 93       	push	r17
   1107c:	6b 01       	movw	r12, r22
   1107e:	7c 01       	movw	r14, r24
   11080:	fa 01       	movw	r30, r20
   11082:	89 01       	movw	r16, r18
	
	/* patch high bits of EEPROM address into SLA 
		 Acomodo a B0*/
	sla = TWI_SLA_24LC1025 | (((eeaddr >> 16) & 0x01) << 3); 
	
	rv=	read_bytes_I2C(sla,eeaddr,len,buf);	
   11084:	c7 01       	movw	r24, r14
   11086:	aa 27       	eor	r26, r26
   11088:	bb 27       	eor	r27, r27
   1108a:	81 70       	andi	r24, 0x01	; 1
   1108c:	88 0f       	add	r24, r24
   1108e:	88 0f       	add	r24, r24
   11090:	88 0f       	add	r24, r24
   11092:	80 6a       	ori	r24, 0xA0	; 160
   11094:	b7 01       	movw	r22, r14
   11096:	a6 01       	movw	r20, r12
   11098:	9f 01       	movw	r18, r30
   1109a:	0e 94 34 86 	call	0x10c68	; 0x10c68 <read_bytes_I2C>
   1109e:	8c 01       	movw	r16, r24
	
	if (rv == -1)
   110a0:	8f ef       	ldi	r24, 0xFF	; 255
   110a2:	0f 3f       	cpi	r16, 0xFF	; 255
   110a4:	18 07       	cpc	r17, r24
   110a6:	11 f4       	brne	.+4      	; 0x110ac <ee24xx_read_bytes+0x3c>
	{
		error();
   110a8:	0e 94 a3 87 	call	0x10f46	; 0x10f46 <error>
		return -1;
	}
 
	return rv;
}
   110ac:	c8 01       	movw	r24, r16
   110ae:	1f 91       	pop	r17
   110b0:	0f 91       	pop	r16
   110b2:	ff 90       	pop	r15
   110b4:	ef 90       	pop	r14
   110b6:	df 90       	pop	r13
   110b8:	cf 90       	pop	r12
   110ba:	08 95       	ret

000110bc <RCT_task>:
	int maxdata;
	#ifdef DEBUG_TAREAS_PROG
	int i;
	#endif
  
	switch (TASK)
   110bc:	81 30       	cpi	r24, 0x01	; 1
   110be:	41 f0       	breq	.+16     	; 0x110d0 <RCT_task+0x14>
   110c0:	81 30       	cpi	r24, 0x01	; 1
   110c2:	18 f0       	brcs	.+6      	; 0x110ca <RCT_task+0xe>
   110c4:	82 30       	cpi	r24, 0x02	; 2
   110c6:	11 f5       	brne	.+68     	; 0x1110c <RCT_task+0x50>
   110c8:	06 c0       	rjmp	.+12     	; 0x110d6 <RCT_task+0x1a>
	{
		case (TAST_Opengripper):
			openGripper();  
   110ca:	0e 94 60 91 	call	0x122c0	; 0x122c0 <openGripper>
   110ce:	08 95       	ret
		break;
		
		case (TAST_Closegripper):
			closeGripper();
   110d0:	0e 94 91 91 	call	0x12322	; 0x12322 <closeGripper>
   110d4:	08 95       	ret
		
		case (TAST_IDVectorTrajectory):
			#ifdef DEBUG_TAREAS_PROG
			printf("RCT_task=> FlagrxVectorok %d\n",FlagrxVectorok);
			#endif
			if(FlagrxVectorok)
   110d6:	80 91 b0 74 	lds	r24, 0x74B0
   110da:	90 91 b1 74 	lds	r25, 0x74B1
   110de:	89 2b       	or	r24, r25
   110e0:	89 f0       	breq	.+34     	; 0x11104 <RCT_task+0x48>
				printf("RCT_task=>  maxdata= %d\n",maxdata);
				for(i=0;i<maxdata;i++)
				
					printf("RCT_task=> rxvector[%d]= %d\n",i,rxvector[i]);
				#endif
				printf("RCT_task=> Ejecutando TAST_IDVectorTrajectory\n");
   110e2:	84 ed       	ldi	r24, 0xD4	; 212
   110e4:	9f e6       	ldi	r25, 0x6F	; 111
   110e6:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
				
				/*Copiar el rxvector que se mando en la ultima transferencia
				utilizando los datos de la eeprom*/
				Vector2Trajectory(rxvector);
   110ea:	80 91 71 78 	lds	r24, 0x7871
   110ee:	90 91 72 78 	lds	r25, 0x7872
   110f2:	0e 94 21 8c 	call	0x11842	; 0x11842 <Vector2Trajectory>
				
				/*utilizo esos datos para ejecutar la trajectoria*/
				PMDprocessTrajectory(&Trajectoryvector,0);
   110f6:	84 ec       	ldi	r24, 0xC4	; 196
   110f8:	99 e7       	ldi	r25, 0x79	; 121
   110fa:	60 e0       	ldi	r22, 0x00	; 0
   110fc:	70 e0       	ldi	r23, 0x00	; 0
   110fe:	0e 94 2b 6b 	call	0xd656	; 0xd656 <PMDprocessTrajectory>
   11102:	08 95       	ret
			}
			else 
				printf("RCT_task=> No hay una trajectoryVector Valido\n");
   11104:	82 e0       	ldi	r24, 0x02	; 2
   11106:	90 e7       	ldi	r25, 0x70	; 112
   11108:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
   1110c:	08 95       	ret

0001110e <read_alarm>:

	return rv;
}
/*****************************************************************************************************/
int16 read_alarm(tAlarm *alarma)
{
   1110e:	0f 93       	push	r16
   11110:	1f 93       	push	r17
   11112:	8c 01       	movw	r16, r24
	
	sla= TWI_SLA_RTC;
	buffersizertc=sizeof(tAlarm)-sizeof(uint8)-sizeof(uint8);								/* Direccion del Dispositivo Esclavo*/

	/* 0x00 es el comienzo de la direccion en donde estasn los Registros de configuracion de Alarma*/
	rv= read_bytes_I2C(sla, 0x00, buffersizertc, (uint8 *)alarma);
   11114:	8e ed       	ldi	r24, 0xDE	; 222
   11116:	40 e0       	ldi	r20, 0x00	; 0
   11118:	50 e0       	ldi	r21, 0x00	; 0
   1111a:	60 e0       	ldi	r22, 0x00	; 0
   1111c:	70 e0       	ldi	r23, 0x00	; 0
   1111e:	25 e0       	ldi	r18, 0x05	; 5
   11120:	30 e0       	ldi	r19, 0x00	; 0
   11122:	0e 94 34 86 	call	0x10c68	; 0x10c68 <read_bytes_I2C>
	
	return rv;
}
   11126:	1f 91       	pop	r17
   11128:	0f 91       	pop	r16
   1112a:	08 95       	ret

0001112c <read_control>:

	return rv;
}
/*****************************************************************************************************/
int16 read_control(tcontrol_RTC *ctr)
{
   1112c:	0f 93       	push	r16
   1112e:	1f 93       	push	r17
   11130:	8c 01       	movw	r16, r24
	int16 rv;
	
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/

	/* 0x10 es el comienzo de la direccion en donde estasn los Registros de control del RTC*/
	rv= read_bytes_I2C(sla, 0x10, sizeof(tcontrol_RTC), (uint8 *)ctr);
   11132:	8e ed       	ldi	r24, 0xDE	; 222
   11134:	40 e1       	ldi	r20, 0x10	; 16
   11136:	50 e0       	ldi	r21, 0x00	; 0
   11138:	60 e0       	ldi	r22, 0x00	; 0
   1113a:	70 e0       	ldi	r23, 0x00	; 0
   1113c:	25 e0       	ldi	r18, 0x05	; 5
   1113e:	30 e0       	ldi	r19, 0x00	; 0
   11140:	0e 94 34 86 	call	0x10c68	; 0x10c68 <read_bytes_I2C>
	
	return rv;
}
   11144:	1f 91       	pop	r17
   11146:	0f 91       	pop	r16
   11148:	08 95       	ret

0001114a <Read_SR>:
	return rv;
}

/*****************************************************************************************************/
int16 Read_SR(uint8* SR)
{
   1114a:	0f 93       	push	r16
   1114c:	1f 93       	push	r17
   1114e:	8c 01       	movw	r16, r24
	uint8 sla;
	int16 rv;
	
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/

	rv= read_bytes_I2C(sla, SR_CCR, sizeof(uint8), (uint8 *)SR);
   11150:	8e ed       	ldi	r24, 0xDE	; 222
   11152:	4f e3       	ldi	r20, 0x3F	; 63
   11154:	50 e0       	ldi	r21, 0x00	; 0
   11156:	60 e0       	ldi	r22, 0x00	; 0
   11158:	70 e0       	ldi	r23, 0x00	; 0
   1115a:	21 e0       	ldi	r18, 0x01	; 1
   1115c:	30 e0       	ldi	r19, 0x00	; 0
   1115e:	0e 94 34 86 	call	0x10c68	; 0x10c68 <read_bytes_I2C>
	
	return rv;
}
   11162:	1f 91       	pop	r17
   11164:	0f 91       	pop	r16
   11166:	08 95       	ret

00011168 <Read_Fecha>:

	return rv;
}
/*****************************************************************************************************/
int16 Read_Fecha(tFecha *Fecha)
{
   11168:	0f 93       	push	r16
   1116a:	1f 93       	push	r17
   1116c:	8c 01       	movw	r16, r24
	int16 rv;
	
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/
	
	/* 0x30 es el comienzo de la direccion en donde estasn los Registros del RTC*/
	rv= read_bytes_I2C(sla, 0x30, sizeof(tFecha), (uint8 *)Fecha);
   1116e:	8e ed       	ldi	r24, 0xDE	; 222
   11170:	40 e3       	ldi	r20, 0x30	; 48
   11172:	50 e0       	ldi	r21, 0x00	; 0
   11174:	60 e0       	ldi	r22, 0x00	; 0
   11176:	70 e0       	ldi	r23, 0x00	; 0
   11178:	28 e0       	ldi	r18, 0x08	; 8
   1117a:	30 e0       	ldi	r19, 0x00	; 0
   1117c:	0e 94 34 86 	call	0x10c68	; 0x10c68 <read_bytes_I2C>
	
	return rv;
}
   11180:	1f 91       	pop	r17
   11182:	0f 91       	pop	r16
   11184:	08 95       	ret

00011186 <isl1207_write_Conf_SR>:
	uint8 Conf_SR[2]={0x02,0x06};


/*****************************************************************************************************/
int16 isl1207_write_Conf_SR(void)
{
   11186:	ef 92       	push	r14
   11188:	ff 92       	push	r15
   1118a:	0f 93       	push	r16
   1118c:	1f 93       	push	r17
	PAGE_SIZE=8;									/* El tamano de Pagina en los registros de Control*/
													/* CCR es de 8 bytes*/
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/
	
	/* Escribir 02h al Status Register */
	rv= write_bytes_I2C(PAGE_SIZE,sla, SR_CCR, 1, pWSR);
   1118e:	88 e0       	ldi	r24, 0x08	; 8
   11190:	6e ed       	ldi	r22, 0xDE	; 222
   11192:	2f e3       	ldi	r18, 0x3F	; 63
   11194:	30 e0       	ldi	r19, 0x00	; 0
   11196:	40 e0       	ldi	r20, 0x00	; 0
   11198:	50 e0       	ldi	r21, 0x00	; 0
   1119a:	01 e0       	ldi	r16, 0x01	; 1
   1119c:	10 e0       	ldi	r17, 0x00	; 0
   1119e:	70 e3       	ldi	r23, 0x30	; 48
   111a0:	e7 2e       	mov	r14, r23
   111a2:	70 e7       	ldi	r23, 0x70	; 112
   111a4:	f7 2e       	mov	r15, r23
   111a6:	0e 94 be 87 	call	0x10f7c	; 0x10f7c <write_bytes_I2C>
   111aa:	9c 01       	movw	r18, r24
	
	if(rv)
   111ac:	00 97       	sbiw	r24, 0x00	; 0
   111ae:	69 f0       	breq	.+26     	; 0x111ca <isl1207_write_Conf_SR+0x44>
	{
		/* Escribir 06h al Status Register */
		pWSR++;
		rv=write_bytes_I2C(PAGE_SIZE,sla, SR_CCR, 1, pWSR);
   111b0:	88 e0       	ldi	r24, 0x08	; 8
   111b2:	6e ed       	ldi	r22, 0xDE	; 222
   111b4:	2f e3       	ldi	r18, 0x3F	; 63
   111b6:	30 e0       	ldi	r19, 0x00	; 0
   111b8:	40 e0       	ldi	r20, 0x00	; 0
   111ba:	50 e0       	ldi	r21, 0x00	; 0
   111bc:	91 e3       	ldi	r25, 0x31	; 49
   111be:	e9 2e       	mov	r14, r25
   111c0:	90 e7       	ldi	r25, 0x70	; 112
   111c2:	f9 2e       	mov	r15, r25
   111c4:	0e 94 be 87 	call	0x10f7c	; 0x10f7c <write_bytes_I2C>
   111c8:	9c 01       	movw	r18, r24
	}

	return rv;
}
   111ca:	c9 01       	movw	r24, r18
   111cc:	1f 91       	pop	r17
   111ce:	0f 91       	pop	r16
   111d0:	ff 90       	pop	r15
   111d2:	ef 90       	pop	r14
   111d4:	08 95       	ret

000111d6 <write_alarm>:
	
	return rv;
}
/*****************************************************************************************************/
int16 write_alarm(tAlarm alarma)
{
   111d6:	ef 92       	push	r14
   111d8:	ff 92       	push	r15
   111da:	0f 93       	push	r16
   111dc:	1f 93       	push	r17
   111de:	df 93       	push	r29
   111e0:	cf 93       	push	r28
   111e2:	cd b7       	in	r28, 0x3d	; 61
   111e4:	de b7       	in	r29, 0x3e	; 62
   111e6:	27 97       	sbiw	r28, 0x07	; 7
   111e8:	0f b6       	in	r0, 0x3f	; 63
   111ea:	f8 94       	cli
   111ec:	de bf       	out	0x3e, r29	; 62
   111ee:	0f be       	out	0x3f, r0	; 63
   111f0:	cd bf       	out	0x3d, r28	; 61
   111f2:	29 83       	std	Y+1, r18	; 0x01
   111f4:	3a 83       	std	Y+2, r19	; 0x02
   111f6:	4b 83       	std	Y+3, r20	; 0x03
   111f8:	5c 83       	std	Y+4, r21	; 0x04
   111fa:	6d 83       	std	Y+5, r22	; 0x05
   111fc:	7e 83       	std	Y+6, r23	; 0x06
   111fe:	8f 83       	std	Y+7, r24	; 0x07
	
	PAGE_SIZE=16;									/* El tamano de Pagina en los registros de Alarma*/
													/* es de 16 bytes*/
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/
	
	rv=isl1207_write_Conf_SR();
   11200:	0e 94 c3 88 	call	0x11186	; 0x11186 <isl1207_write_Conf_SR>
   11204:	9c 01       	movw	r18, r24
/*Esto es  para guardar solo hasta el campo uint8 MOA0;*/
	buffersizertc=sizeof(tAlarm)-sizeof(uint8)-sizeof(uint8);
	
	if(rv)
   11206:	00 97       	sbiw	r24, 0x00	; 0
   11208:	79 f0       	breq	.+30     	; 0x11228 <write_alarm+0x52>
	{
		/* 0x00 es el comienzo de la direccion en donde estan los Registros de configuracion de Alarma*/
		rv= write_bytes_I2C(PAGE_SIZE,sla, 0x00, buffersizertc,(uint8 *)&alarma);
   1120a:	80 e1       	ldi	r24, 0x10	; 16
   1120c:	6e ed       	ldi	r22, 0xDE	; 222
   1120e:	20 e0       	ldi	r18, 0x00	; 0
   11210:	30 e0       	ldi	r19, 0x00	; 0
   11212:	40 e0       	ldi	r20, 0x00	; 0
   11214:	50 e0       	ldi	r21, 0x00	; 0
   11216:	05 e0       	ldi	r16, 0x05	; 5
   11218:	10 e0       	ldi	r17, 0x00	; 0
   1121a:	7e 01       	movw	r14, r28
   1121c:	08 94       	sec
   1121e:	e1 1c       	adc	r14, r1
   11220:	f1 1c       	adc	r15, r1
   11222:	0e 94 be 87 	call	0x10f7c	; 0x10f7c <write_bytes_I2C>
   11226:	9c 01       	movw	r18, r24
	}

	return rv;
}
   11228:	c9 01       	movw	r24, r18
   1122a:	27 96       	adiw	r28, 0x07	; 7
   1122c:	0f b6       	in	r0, 0x3f	; 63
   1122e:	f8 94       	cli
   11230:	de bf       	out	0x3e, r29	; 62
   11232:	0f be       	out	0x3f, r0	; 63
   11234:	cd bf       	out	0x3d, r28	; 61
   11236:	cf 91       	pop	r28
   11238:	df 91       	pop	r29
   1123a:	1f 91       	pop	r17
   1123c:	0f 91       	pop	r16
   1123e:	ff 90       	pop	r15
   11240:	ef 90       	pop	r14
   11242:	08 95       	ret

00011244 <write_control>:
	
	return rv;
}
/*****************************************************************************************************/
int16 write_control(tcontrol_RTC ctr)
{
   11244:	ef 92       	push	r14
   11246:	ff 92       	push	r15
   11248:	0f 93       	push	r16
   1124a:	1f 93       	push	r17
   1124c:	df 93       	push	r29
   1124e:	cf 93       	push	r28
   11250:	00 d0       	rcall	.+0      	; 0x11252 <write_control+0xe>
   11252:	00 d0       	rcall	.+0      	; 0x11254 <write_control+0x10>
   11254:	0f 92       	push	r0
   11256:	cd b7       	in	r28, 0x3d	; 61
   11258:	de b7       	in	r29, 0x3e	; 62
   1125a:	49 83       	std	Y+1, r20	; 0x01
   1125c:	5a 83       	std	Y+2, r21	; 0x02
   1125e:	6b 83       	std	Y+3, r22	; 0x03
   11260:	7c 83       	std	Y+4, r23	; 0x04
   11262:	8d 83       	std	Y+5, r24	; 0x05
	
	PAGE_SIZE=8;									/* El tamano de Pagina en los registros de Control*/
													/* CCR es de 8 bytes*/
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/
	
	rv=isl1207_write_Conf_SR();
   11264:	0e 94 c3 88 	call	0x11186	; 0x11186 <isl1207_write_Conf_SR>
   11268:	9c 01       	movw	r18, r24
	
	if(rv)
   1126a:	00 97       	sbiw	r24, 0x00	; 0
   1126c:	79 f0       	breq	.+30     	; 0x1128c <write_control+0x48>
	{
		/* 0x10 es el comienzo de la direccion en donde estasn los Registros de control del RTC*/
		rv= write_bytes_I2C(PAGE_SIZE,sla, 0x10, sizeof(tcontrol_RTC),(uint8 *)&ctr);
   1126e:	88 e0       	ldi	r24, 0x08	; 8
   11270:	6e ed       	ldi	r22, 0xDE	; 222
   11272:	20 e1       	ldi	r18, 0x10	; 16
   11274:	30 e0       	ldi	r19, 0x00	; 0
   11276:	40 e0       	ldi	r20, 0x00	; 0
   11278:	50 e0       	ldi	r21, 0x00	; 0
   1127a:	05 e0       	ldi	r16, 0x05	; 5
   1127c:	10 e0       	ldi	r17, 0x00	; 0
   1127e:	7e 01       	movw	r14, r28
   11280:	08 94       	sec
   11282:	e1 1c       	adc	r14, r1
   11284:	f1 1c       	adc	r15, r1
   11286:	0e 94 be 87 	call	0x10f7c	; 0x10f7c <write_bytes_I2C>
   1128a:	9c 01       	movw	r18, r24
	}

	return rv;
}
   1128c:	c9 01       	movw	r24, r18
   1128e:	0f 90       	pop	r0
   11290:	0f 90       	pop	r0
   11292:	0f 90       	pop	r0
   11294:	0f 90       	pop	r0
   11296:	0f 90       	pop	r0
   11298:	cf 91       	pop	r28
   1129a:	df 91       	pop	r29
   1129c:	1f 91       	pop	r17
   1129e:	0f 91       	pop	r16
   112a0:	ff 90       	pop	r15
   112a2:	ef 90       	pop	r14
   112a4:	08 95       	ret

000112a6 <rtc_init>:
	return rv;
}

/*****************************************************************************************************/
void rtc_init(void)
{
   112a6:	df 93       	push	r29
   112a8:	cf 93       	push	r28
   112aa:	00 d0       	rcall	.+0      	; 0x112ac <rtc_init+0x6>
   112ac:	00 d0       	rcall	.+0      	; 0x112ae <rtc_init+0x8>
   112ae:	0f 92       	push	r0
   112b0:	cd b7       	in	r28, 0x3d	; 61
   112b2:	de b7       	in	r29, 0x3e	; 62
	tcontrol_RTC ctr;
	
	ctr.PWR=RTC_PWR(1,1);
   112b4:	80 ec       	ldi	r24, 0xC0	; 192
   112b6:	8d 83       	std	Y+5, r24	; 0x05
	ctr.DTR=0;
   112b8:	1c 82       	std	Y+4, r1	; 0x04
	ctr.ATR=0;
   112ba:	1b 82       	std	Y+3, r1	; 0x03
	ctr.INT=RTC_INT(0,0);
   112bc:	1a 82       	std	Y+2, r1	; 0x02
	ctr.BL =0x18;
   112be:	88 e1       	ldi	r24, 0x18	; 24
   112c0:	89 83       	std	Y+1, r24	; 0x01
	write_control(ctr);
   112c2:	48 e1       	ldi	r20, 0x18	; 24
   112c4:	50 e0       	ldi	r21, 0x00	; 0
   112c6:	60 e0       	ldi	r22, 0x00	; 0
   112c8:	70 e0       	ldi	r23, 0x00	; 0
   112ca:	80 ec       	ldi	r24, 0xC0	; 192
   112cc:	0e 94 22 89 	call	0x11244	; 0x11244 <write_control>
	
}
   112d0:	0f 90       	pop	r0
   112d2:	0f 90       	pop	r0
   112d4:	0f 90       	pop	r0
   112d6:	0f 90       	pop	r0
   112d8:	0f 90       	pop	r0
   112da:	cf 91       	pop	r28
   112dc:	df 91       	pop	r29
   112de:	08 95       	ret

000112e0 <write_Fecha>:
	return rv;
}

/*****************************************************************************************************/
int16 write_Fecha(tFecha Fecha)
{
   112e0:	ef 92       	push	r14
   112e2:	ff 92       	push	r15
   112e4:	0f 93       	push	r16
   112e6:	1f 93       	push	r17
   112e8:	df 93       	push	r29
   112ea:	cf 93       	push	r28
   112ec:	cd b7       	in	r28, 0x3d	; 61
   112ee:	de b7       	in	r29, 0x3e	; 62
   112f0:	28 97       	sbiw	r28, 0x08	; 8
   112f2:	0f b6       	in	r0, 0x3f	; 63
   112f4:	f8 94       	cli
   112f6:	de bf       	out	0x3e, r29	; 62
   112f8:	0f be       	out	0x3f, r0	; 63
   112fa:	cd bf       	out	0x3d, r28	; 61
   112fc:	29 83       	std	Y+1, r18	; 0x01
   112fe:	3a 83       	std	Y+2, r19	; 0x02
   11300:	4b 83       	std	Y+3, r20	; 0x03
   11302:	5c 83       	std	Y+4, r21	; 0x04
   11304:	6d 83       	std	Y+5, r22	; 0x05
   11306:	7e 83       	std	Y+6, r23	; 0x06
   11308:	8f 83       	std	Y+7, r24	; 0x07
   1130a:	98 87       	std	Y+8, r25	; 0x08
	
	PAGE_SIZE=8;									/* El tamano de Pagina en los registros de Control*/
													/* CCR es de 8 bytes*/
	sla= TWI_SLA_RTC;								/* Direccion del Dispositivo Esclavo*/
	
	rv=isl1207_write_Conf_SR();
   1130c:	0e 94 c3 88 	call	0x11186	; 0x11186 <isl1207_write_Conf_SR>
   11310:	9c 01       	movw	r18, r24
	
	if(rv)
   11312:	00 97       	sbiw	r24, 0x00	; 0
   11314:	79 f0       	breq	.+30     	; 0x11334 <write_Fecha+0x54>
	{
		/* 0x30 es el comienzo de la direccion en donde estasn los Registros del RTC*/
		rv= write_bytes_I2C(PAGE_SIZE,sla, 0x30, sizeof(tFecha),(uint8 *)&Fecha);
   11316:	88 e0       	ldi	r24, 0x08	; 8
   11318:	6e ed       	ldi	r22, 0xDE	; 222
   1131a:	20 e3       	ldi	r18, 0x30	; 48
   1131c:	30 e0       	ldi	r19, 0x00	; 0
   1131e:	40 e0       	ldi	r20, 0x00	; 0
   11320:	50 e0       	ldi	r21, 0x00	; 0
   11322:	08 e0       	ldi	r16, 0x08	; 8
   11324:	10 e0       	ldi	r17, 0x00	; 0
   11326:	7e 01       	movw	r14, r28
   11328:	08 94       	sec
   1132a:	e1 1c       	adc	r14, r1
   1132c:	f1 1c       	adc	r15, r1
   1132e:	0e 94 be 87 	call	0x10f7c	; 0x10f7c <write_bytes_I2C>
   11332:	9c 01       	movw	r18, r24
	}

	return rv;
}
   11334:	c9 01       	movw	r24, r18
   11336:	28 96       	adiw	r28, 0x08	; 8
   11338:	0f b6       	in	r0, 0x3f	; 63
   1133a:	f8 94       	cli
   1133c:	de bf       	out	0x3e, r29	; 62
   1133e:	0f be       	out	0x3f, r0	; 63
   11340:	cd bf       	out	0x3d, r28	; 61
   11342:	cf 91       	pop	r28
   11344:	df 91       	pop	r29
   11346:	1f 91       	pop	r17
   11348:	0f 91       	pop	r16
   1134a:	ff 90       	pop	r15
   1134c:	ef 90       	pop	r14
   1134e:	08 95       	ret

00011350 <Pose2rxTrayectoria>:
}

/*****************************************************************************************************/
/*Llena una trayectoria de un punto, para luego poder ejecutarla con teach_pendant_point() */
void Pose2rxTrayectoria(PoseRobot* EEpromPose)
{
   11350:	cf 93       	push	r28
   11352:	df 93       	push	r29
   11354:	ec 01       	movw	r28, r24

	
	if(FlagTrayecPuntook)
   11356:	80 91 0c 75 	lds	r24, 0x750C
   1135a:	90 91 0d 75 	lds	r25, 0x750D
   1135e:	89 2b       	or	r24, r25
   11360:	31 f0       	breq	.+12     	; 0x1136e <Pose2rxTrayectoria+0x1e>
		free(Trajectoryvectorpunto.point);
   11362:	80 91 c0 79 	lds	r24, 0x79C0
   11366:	90 91 c1 79 	lds	r25, 0x79C1
   1136a:	0e 94 78 9d 	call	0x13af0	; 0x13af0 <free>
	
	Trajectoryvectorpunto.point=(tpoint*)declarar(sizeof(tpoint));
   1136e:	8d e3       	ldi	r24, 0x3D	; 61
   11370:	90 e0       	ldi	r25, 0x00	; 0
   11372:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
   11376:	fc 01       	movw	r30, r24
   11378:	90 93 c1 79 	sts	0x79C1, r25
   1137c:	80 93 c0 79 	sts	0x79C0, r24
	Trajectoryvectorpunto.size=1;
   11380:	21 e0       	ldi	r18, 0x01	; 1
   11382:	30 e0       	ldi	r19, 0x00	; 0
   11384:	30 93 bd 79 	sts	0x79BD, r19
   11388:	20 93 bc 79 	sts	0x79BC, r18
	/* se habilitan todos los ejes para el movimiento*/
	Trajectoryvectorpunto.invalidmask=0x1F; 
   1138c:	8f e1       	ldi	r24, 0x1F	; 31
   1138e:	90 e0       	ldi	r25, 0x00	; 0
   11390:	90 93 bf 79 	sts	0x79BF, r25
   11394:	80 93 be 79 	sts	0x79BE, r24
	
	/*Velocidades tomadas de homeVelocity, no se modifico tAxisSettings
		para evitar problemas con la memoria.*/
	Trajectoryvectorpunto.point[0].axis[AxisWaist].position=EEpromPose->Pos_Waist;	
   11398:	8a 81       	ldd	r24, Y+2	; 0x02
   1139a:	9b 81       	ldd	r25, Y+3	; 0x03
   1139c:	ac 81       	ldd	r26, Y+4	; 0x04
   1139e:	bd 81       	ldd	r27, Y+5	; 0x05
   113a0:	80 83       	st	Z, r24
   113a2:	91 83       	std	Z+1, r25	; 0x01
   113a4:	a2 83       	std	Z+2, r26	; 0x02
   113a6:	b3 83       	std	Z+3, r27	; 0x03
	Trajectoryvectorpunto.point[0].axis[AxisWaist].velocity=//155945;//70/seg;
   113a8:	80 91 59 75 	lds	r24, 0x7559
   113ac:	90 91 5a 75 	lds	r25, 0x755A
   113b0:	a0 91 5b 75 	lds	r26, 0x755B
   113b4:	b0 91 5c 75 	lds	r27, 0x755C
   113b8:	84 83       	std	Z+4, r24	; 0x04
   113ba:	95 83       	std	Z+5, r25	; 0x05
   113bc:	a6 83       	std	Z+6, r26	; 0x06
   113be:	b7 83       	std	Z+7, r27	; 0x07
	hAxis[AxisWaist].axisSettings.homeVelocity;
	Trajectoryvectorpunto.point[0].axis[AxisWaist].acceleration=//80;//60
   113c0:	80 91 5d 75 	lds	r24, 0x755D
   113c4:	90 91 5e 75 	lds	r25, 0x755E
   113c8:	a0 91 5f 75 	lds	r26, 0x755F
   113cc:	b0 91 60 75 	lds	r27, 0x7560
   113d0:	80 87       	std	Z+8, r24	; 0x08
   113d2:	91 87       	std	Z+9, r25	; 0x09
   113d4:	a2 87       	std	Z+10, r26	; 0x0a
   113d6:	b3 87       	std	Z+11, r27	; 0x0b
	hAxis[AxisWaist].axisSettings.homeAcceleration;
	
	Trajectoryvectorpunto.point[0].axis[AxisShoulder].position=EEpromPose->Pos_Shoulder;
   113d8:	8e 81       	ldd	r24, Y+6	; 0x06
   113da:	9f 81       	ldd	r25, Y+7	; 0x07
   113dc:	a8 85       	ldd	r26, Y+8	; 0x08
   113de:	b9 85       	ldd	r27, Y+9	; 0x09
   113e0:	84 87       	std	Z+12, r24	; 0x0c
   113e2:	95 87       	std	Z+13, r25	; 0x0d
   113e4:	a6 87       	std	Z+14, r26	; 0x0e
   113e6:	b7 87       	std	Z+15, r27	; 0x0f
	Trajectoryvectorpunto.point[0].axis[AxisShoulder].velocity=//1151798; //7/seg
   113e8:	80 91 b9 75 	lds	r24, 0x75B9
   113ec:	90 91 ba 75 	lds	r25, 0x75BA
   113f0:	a0 91 bb 75 	lds	r26, 0x75BB
   113f4:	b0 91 bc 75 	lds	r27, 0x75BC
   113f8:	80 8b       	std	Z+16, r24	; 0x10
   113fa:	91 8b       	std	Z+17, r25	; 0x11
   113fc:	a2 8b       	std	Z+18, r26	; 0x12
   113fe:	b3 8b       	std	Z+19, r27	; 0x13
	hAxis[AxisShoulder].axisSettings.homeVelocity;
	Trajectoryvectorpunto.point[0].axis[AxisShoulder].acceleration=//395; //4
   11400:	80 91 bd 75 	lds	r24, 0x75BD
   11404:	90 91 be 75 	lds	r25, 0x75BE
   11408:	a0 91 bf 75 	lds	r26, 0x75BF
   1140c:	b0 91 c0 75 	lds	r27, 0x75C0
   11410:	84 8b       	std	Z+20, r24	; 0x14
   11412:	95 8b       	std	Z+21, r25	; 0x15
   11414:	a6 8b       	std	Z+22, r26	; 0x16
   11416:	b7 8b       	std	Z+23, r27	; 0x17
	hAxis[AxisShoulder].axisSettings.homeAcceleration;
	
	Trajectoryvectorpunto.point[0].axis[AxisElbow].position=EEpromPose->Pos_Elbow;
   11418:	8a 85       	ldd	r24, Y+10	; 0x0a
   1141a:	9b 85       	ldd	r25, Y+11	; 0x0b
   1141c:	ac 85       	ldd	r26, Y+12	; 0x0c
   1141e:	bd 85       	ldd	r27, Y+13	; 0x0d
   11420:	80 8f       	std	Z+24, r24	; 0x18
   11422:	91 8f       	std	Z+25, r25	; 0x19
   11424:	a2 8f       	std	Z+26, r26	; 0x1a
   11426:	b3 8f       	std	Z+27, r27	; 0x1b
	Trajectoryvectorpunto.point[0].axis[AxisElbow].velocity=//1151798;
   11428:	80 91 19 76 	lds	r24, 0x7619
   1142c:	90 91 1a 76 	lds	r25, 0x761A
   11430:	a0 91 1b 76 	lds	r26, 0x761B
   11434:	b0 91 1c 76 	lds	r27, 0x761C
   11438:	84 8f       	std	Z+28, r24	; 0x1c
   1143a:	95 8f       	std	Z+29, r25	; 0x1d
   1143c:	a6 8f       	std	Z+30, r26	; 0x1e
   1143e:	b7 8f       	std	Z+31, r27	; 0x1f
	hAxis[AxisElbow].axisSettings.homeVelocity;
	Trajectoryvectorpunto.point[0].axis[AxisElbow].acceleration=//395;
   11440:	80 91 1d 76 	lds	r24, 0x761D
   11444:	90 91 1e 76 	lds	r25, 0x761E
   11448:	a0 91 1f 76 	lds	r26, 0x761F
   1144c:	b0 91 20 76 	lds	r27, 0x7620
   11450:	80 a3       	std	Z+32, r24	; 0x20
   11452:	91 a3       	std	Z+33, r25	; 0x21
   11454:	a2 a3       	std	Z+34, r26	; 0x22
   11456:	b3 a3       	std	Z+35, r27	; 0x23
	hAxis[AxisElbow].axisSettings.homeAcceleration;
	
	Trajectoryvectorpunto.point[0].axis[AxisPitch].position=EEpromPose->Pos_Pitch;
   11458:	8e 85       	ldd	r24, Y+14	; 0x0e
   1145a:	9f 85       	ldd	r25, Y+15	; 0x0f
   1145c:	a8 89       	ldd	r26, Y+16	; 0x10
   1145e:	b9 89       	ldd	r27, Y+17	; 0x11
   11460:	84 a3       	std	Z+36, r24	; 0x24
   11462:	95 a3       	std	Z+37, r25	; 0x25
   11464:	a6 a3       	std	Z+38, r26	; 0x26
   11466:	b7 a3       	std	Z+39, r27	; 0x27
	Trajectoryvectorpunto.point[0].axis[AxisPitch].velocity=//108158;
   11468:	80 91 59 75 	lds	r24, 0x7559
   1146c:	90 91 5a 75 	lds	r25, 0x755A
   11470:	a0 91 5b 75 	lds	r26, 0x755B
   11474:	b0 91 5c 75 	lds	r27, 0x755C
   11478:	80 a7       	std	Z+40, r24	; 0x28
   1147a:	91 a7       	std	Z+41, r25	; 0x29
   1147c:	a2 a7       	std	Z+42, r26	; 0x2a
   1147e:	b3 a7       	std	Z+43, r27	; 0x2b
	hAxis[AxisWaist].axisSettings.homeVelocity;
	Trajectoryvectorpunto.point[0].axis[AxisPitch].acceleration=//49;
   11480:	80 91 5d 75 	lds	r24, 0x755D
   11484:	90 91 5e 75 	lds	r25, 0x755E
   11488:	a0 91 5f 75 	lds	r26, 0x755F
   1148c:	b0 91 60 75 	lds	r27, 0x7560
   11490:	84 a7       	std	Z+44, r24	; 0x2c
   11492:	95 a7       	std	Z+45, r25	; 0x2d
   11494:	a6 a7       	std	Z+46, r26	; 0x2e
   11496:	b7 a7       	std	Z+47, r27	; 0x2f
	hAxis[AxisWaist].axisSettings.homeAcceleration;
	
	Trajectoryvectorpunto.point[0].axis[AxisRoll].position=EEpromPose->Pos_Roll;
   11498:	8a 89       	ldd	r24, Y+18	; 0x12
   1149a:	9b 89       	ldd	r25, Y+19	; 0x13
   1149c:	ac 89       	ldd	r26, Y+20	; 0x14
   1149e:	bd 89       	ldd	r27, Y+21	; 0x15
   114a0:	80 ab       	std	Z+48, r24	; 0x30
   114a2:	91 ab       	std	Z+49, r25	; 0x31
   114a4:	a2 ab       	std	Z+50, r26	; 0x32
   114a6:	b3 ab       	std	Z+51, r27	; 0x33
	Trajectoryvectorpunto.point[0].axis[AxisRoll].velocity=//111316;   // 150000
   114a8:	80 91 d9 76 	lds	r24, 0x76D9
   114ac:	90 91 da 76 	lds	r25, 0x76DA
   114b0:	a0 91 db 76 	lds	r26, 0x76DB
   114b4:	b0 91 dc 76 	lds	r27, 0x76DC
   114b8:	84 ab       	std	Z+52, r24	; 0x34
   114ba:	95 ab       	std	Z+53, r25	; 0x35
   114bc:	a6 ab       	std	Z+54, r26	; 0x36
   114be:	b7 ab       	std	Z+55, r27	; 0x37
	hAxis[AxisRoll].axisSettings.homeVelocity;
	Trajectoryvectorpunto.point[0].axis[AxisRoll].acceleration=//33;  // 100
   114c0:	80 91 dd 76 	lds	r24, 0x76DD
   114c4:	90 91 de 76 	lds	r25, 0x76DE
   114c8:	a0 91 df 76 	lds	r26, 0x76DF
   114cc:	b0 91 e0 76 	lds	r27, 0x76E0
   114d0:	80 af       	std	Z+56, r24	; 0x38
   114d2:	91 af       	std	Z+57, r25	; 0x39
   114d4:	a2 af       	std	Z+58, r26	; 0x3a
   114d6:	b3 af       	std	Z+59, r27	; 0x3b
	hAxis[AxisRoll].axisSettings.homeAcceleration;
	
	FlagTrayecPuntook=1;
   114d8:	30 93 0d 75 	sts	0x750D, r19
   114dc:	20 93 0c 75 	sts	0x750C, r18
	
}
   114e0:	df 91       	pop	r29
   114e2:	cf 91       	pop	r28
   114e4:	08 95       	ret

000114e6 <BorrarEEPROM>:
	return 1;	
}

/*****************************************************************************************************/
int16 BorrarEEPROM(void)
{
   114e6:	df 93       	push	r29
   114e8:	cf 93       	push	r28
   114ea:	00 d0       	rcall	.+0      	; 0x114ec <BorrarEEPROM+0x6>
   114ec:	cd b7       	in	r28, 0x3d	; 61
   114ee:	de b7       	in	r29, 0x3e	; 62
	uint16 Num_Poses;
	int16 rv;
   
	Num_Poses=0;
   114f0:	1a 82       	std	Y+2, r1	; 0x02
   114f2:	19 82       	std	Y+1, r1	; 0x01
	
	/* actualizo Num_Poses */
	rv=ee24xx_write_bytes(0,sizeof(uint16),(uint8 *)&Num_Poses);	
   114f4:	60 e0       	ldi	r22, 0x00	; 0
   114f6:	70 e0       	ldi	r23, 0x00	; 0
   114f8:	80 e0       	ldi	r24, 0x00	; 0
   114fa:	90 e0       	ldi	r25, 0x00	; 0
   114fc:	42 e0       	ldi	r20, 0x02	; 2
   114fe:	50 e0       	ldi	r21, 0x00	; 0
   11500:	9e 01       	movw	r18, r28
   11502:	2f 5f       	subi	r18, 0xFF	; 255
   11504:	3f 4f       	sbci	r19, 0xFF	; 255
   11506:	0e 94 0d 88 	call	0x1101a	; 0x1101a <ee24xx_write_bytes>
		printf("BorrarEEPROM=> Numero de BYTES ledos corectamente en BorrarEErom => %d\n",rv);
		printf("BorrarEEPROM=> Num_Poses = %x\n",Num_Poses);
   #endif

return rv;
}
   1150a:	0f 90       	pop	r0
   1150c:	0f 90       	pop	r0
   1150e:	cf 91       	pop	r28
   11510:	df 91       	pop	r29
   11512:	08 95       	ret

00011514 <Get_Num_Poses>:
	/*Utilizada para acceder a la informacion de moviento velocidades y aceleraciones max */
	extern PMDAxisHandle hAxis[DOF]; 

/*****************************************************************************************************/
int16 Get_Num_Poses(void)
{
   11514:	df 93       	push	r29
   11516:	cf 93       	push	r28
   11518:	00 d0       	rcall	.+0      	; 0x1151a <Get_Num_Poses+0x6>
   1151a:	cd b7       	in	r28, 0x3d	; 61
   1151c:	de b7       	in	r29, 0x3e	; 62
	int16 Cpuntos=-1;
   1151e:	8f ef       	ldi	r24, 0xFF	; 255
   11520:	9f ef       	ldi	r25, 0xFF	; 255
   11522:	9a 83       	std	Y+2, r25	; 0x02
   11524:	89 83       	std	Y+1, r24	; 0x01
	int16 rv=-1;
   
	rv=ee24xx_read_bytes(0,sizeof(int16),(uint8 *)&Cpuntos);
   11526:	60 e0       	ldi	r22, 0x00	; 0
   11528:	70 e0       	ldi	r23, 0x00	; 0
   1152a:	80 e0       	ldi	r24, 0x00	; 0
   1152c:	90 e0       	ldi	r25, 0x00	; 0
   1152e:	42 e0       	ldi	r20, 0x02	; 2
   11530:	50 e0       	ldi	r21, 0x00	; 0
   11532:	9e 01       	movw	r18, r28
   11534:	2f 5f       	subi	r18, 0xFF	; 255
   11536:	3f 4f       	sbci	r19, 0xFF	; 255
   11538:	0e 94 38 88 	call	0x11070	; 0x11070 <ee24xx_read_bytes>
   1153c:	9c 01       	movw	r18, r24
	
	if(rv)
   1153e:	00 97       	sbiw	r24, 0x00	; 0
   11540:	39 f0       	breq	.+14     	; 0x11550 <Get_Num_Poses+0x3c>
	{
		#ifdef DEBUGTWI
			printf("Get_Num_Poses=> Cpuntos= %d\n",Cpuntos);
		#endif
		if(Cpuntos< MAX_POSES)
   11542:	89 81       	ldd	r24, Y+1	; 0x01
   11544:	9a 81       	ldd	r25, Y+2	; 0x02
   11546:	46 e1       	ldi	r20, 0x16	; 22
   11548:	80 34       	cpi	r24, 0x40	; 64
   1154a:	94 07       	cpc	r25, r20
   1154c:	0c f4       	brge	.+2      	; 0x11550 <Get_Num_Poses+0x3c>
   1154e:	9c 01       	movw	r18, r24
			return Cpuntos;
	}

	return rv;
}
   11550:	c9 01       	movw	r24, r18
   11552:	0f 90       	pop	r0
   11554:	0f 90       	pop	r0
   11556:	cf 91       	pop	r28
   11558:	df 91       	pop	r29
   1155a:	08 95       	ret

0001155c <Adicionar_PoseTWI>:
	return -1;	
	
}
/*****************************************************************************************************/
int16 Adicionar_PoseTWI(PoseRobot Pose)
{
   1155c:	0f 93       	push	r16
   1155e:	1f 93       	push	r17
   11560:	df 93       	push	r29
   11562:	cf 93       	push	r28
   11564:	00 d0       	rcall	.+0      	; 0x11566 <Adicionar_PoseTWI+0xa>
   11566:	cd b7       	in	r28, 0x3d	; 61
   11568:	de b7       	in	r29, 0x3e	; 62
	int16 Num_Poses;
	
	
	
    /*Se obtiene el numero total de poses que hay en la memoria EEPROM*/
	Num_Poses=Get_Num_Poses();
   1156a:	0e 94 8a 8a 	call	0x11514	; 0x11514 <Get_Num_Poses>
   1156e:	8c 01       	movw	r16, r24
	#ifdef DEBUGTWI
		printf("Adicionar_PoseTWI=> Numero Poses grabadas Adicionar_PoseTWI => %x\n",Num_Poses);
	#endif

	if(Num_Poses!=-1)
   11570:	8f ef       	ldi	r24, 0xFF	; 255
   11572:	0f 3f       	cpi	r16, 0xFF	; 255
   11574:	18 07       	cpc	r17, r24
   11576:	19 f4       	brne	.+6      	; 0x1157e <Adicionar_PoseTWI+0x22>
   11578:	2f ef       	ldi	r18, 0xFF	; 255
   1157a:	3f ef       	ldi	r19, 0xFF	; 255
   1157c:	38 c0       	rjmp	.+112    	; 0x115ee <Adicionar_PoseTWI+0x92>
	{   
		/* Num_Poses Es el numero de Poses. Cada Pose Empieza en 1 hasta MAX_Poses*/
		/*La addr no depende del ID*/
		addr=(int32)(Num_Poses)*sizeof(PoseRobot)+sizeof(int16); 
   1157e:	b8 01       	movw	r22, r16
   11580:	88 27       	eor	r24, r24
   11582:	77 fd       	sbrc	r23, 7
   11584:	80 95       	com	r24
   11586:	98 2f       	mov	r25, r24
   11588:	27 e1       	ldi	r18, 0x17	; 23
   1158a:	30 e0       	ldi	r19, 0x00	; 0
   1158c:	40 e0       	ldi	r20, 0x00	; 0
   1158e:	50 e0       	ldi	r21, 0x00	; 0
   11590:	0e 94 3c 9c 	call	0x13878	; 0x13878 <__mulsi3>
   11594:	9b 01       	movw	r18, r22
   11596:	ac 01       	movw	r20, r24
   11598:	6e 5f       	subi	r22, 0xFE	; 254
   1159a:	7f 4f       	sbci	r23, 0xFF	; 255
   1159c:	8f 4f       	sbci	r24, 0xFF	; 255
   1159e:	9f 4f       	sbci	r25, 0xFF	; 255
		#ifdef DEBUGTWI
			printf("Adicionar_PoseTWI=> direccion actual en donde grabo la Pose => %lx\n",addr);
		#endif
			
		/*Pasar al Segundo Banco de Memoria */
		if(Num_Poses > (MAX_POSES/2))
   115a0:	eb e0       	ldi	r30, 0x0B	; 11
   115a2:	01 32       	cpi	r16, 0x21	; 33
   115a4:	1e 07       	cpc	r17, r30
   115a6:	34 f0       	brlt	.+12     	; 0x115b4 <Adicionar_PoseTWI+0x58>
			addr=addr+ADD_NUM;
   115a8:	ca 01       	movw	r24, r20
   115aa:	b9 01       	movw	r22, r18
   115ac:	67 5f       	subi	r22, 0xF7	; 247
   115ae:	7f 4f       	sbci	r23, 0xFF	; 255
   115b0:	8f 4f       	sbci	r24, 0xFF	; 255
   115b2:	9f 4f       	sbci	r25, 0xFF	; 255
	int16 Num_Poses;
	
	
	
    /*Se obtiene el numero total de poses que hay en la memoria EEPROM*/
	Num_Poses=Get_Num_Poses();
   115b4:	1a 83       	std	Y+2, r17	; 0x02
   115b6:	09 83       	std	Y+1, r16	; 0x01
		/*Pasar al Segundo Banco de Memoria */
		if(Num_Poses > (MAX_POSES/2))
			addr=addr+ADD_NUM;
		
		/* grabando pose*/
		rv=ee24xx_write_bytes(addr,sizeof(PoseRobot),(uint8 *)&Pose);	
   115b8:	47 e1       	ldi	r20, 0x17	; 23
   115ba:	50 e0       	ldi	r21, 0x00	; 0
   115bc:	9e 01       	movw	r18, r28
   115be:	27 5f       	subi	r18, 0xF7	; 247
   115c0:	3f 4f       	sbci	r19, 0xFF	; 255
   115c2:	0e 94 0d 88 	call	0x1101a	; 0x1101a <ee24xx_write_bytes>
   115c6:	9c 01       	movw	r18, r24
		#ifdef DEBUGTWI
			printf("Adicionar_PoseTWI=> Numero de datos grabados corectamente al grabar Pose => %d\n",rv);
		#endif
		
		if(rv)
   115c8:	00 97       	sbiw	r24, 0x00	; 0
   115ca:	89 f0       	breq	.+34     	; 0x115ee <Adicionar_PoseTWI+0x92>
		{
			Num_Poses++;
   115cc:	89 81       	ldd	r24, Y+1	; 0x01
   115ce:	9a 81       	ldd	r25, Y+2	; 0x02
   115d0:	01 96       	adiw	r24, 0x01	; 1
   115d2:	9a 83       	std	Y+2, r25	; 0x02
   115d4:	89 83       	std	Y+1, r24	; 0x01
			
			/*Se Actualiza el Numero de Poses Escritas en EEPROM*/
			rv=ee24xx_write_bytes(0,sizeof(int16),(uint8 *)&Num_Poses);	
   115d6:	60 e0       	ldi	r22, 0x00	; 0
   115d8:	70 e0       	ldi	r23, 0x00	; 0
   115da:	80 e0       	ldi	r24, 0x00	; 0
   115dc:	90 e0       	ldi	r25, 0x00	; 0
   115de:	42 e0       	ldi	r20, 0x02	; 2
   115e0:	50 e0       	ldi	r21, 0x00	; 0
   115e2:	9e 01       	movw	r18, r28
   115e4:	2f 5f       	subi	r18, 0xFF	; 255
   115e6:	3f 4f       	sbci	r19, 0xFF	; 255
   115e8:	0e 94 0d 88 	call	0x1101a	; 0x1101a <ee24xx_write_bytes>
   115ec:	9c 01       	movw	r18, r24
			#endif		
		}		
	}
	
	return rv;
}
   115ee:	c9 01       	movw	r24, r18
   115f0:	0f 90       	pop	r0
   115f2:	0f 90       	pop	r0
   115f4:	cf 91       	pop	r28
   115f6:	df 91       	pop	r29
   115f8:	1f 91       	pop	r17
   115fa:	0f 91       	pop	r16
   115fc:	08 95       	ret

000115fe <return_id_vector>:

}

/*****************************************************************************************************/
int16 return_id_vector(void)
{
   115fe:	8f 92       	push	r8
   11600:	9f 92       	push	r9
   11602:	af 92       	push	r10
   11604:	bf 92       	push	r11
   11606:	cf 92       	push	r12
   11608:	df 92       	push	r13
   1160a:	ef 92       	push	r14
   1160c:	ff 92       	push	r15
   1160e:	0f 93       	push	r16
   11610:	1f 93       	push	r17
   11612:	df 93       	push	r29
   11614:	cf 93       	push	r28
   11616:	00 d0       	rcall	.+0      	; 0x11618 <return_id_vector+0x1a>
   11618:	cd b7       	in	r28, 0x3d	; 61
   1161a:	de b7       	in	r29, 0x3e	; 62
	int16 Num_Poses;
	int16 id_actual=-1;
   1161c:	0f ef       	ldi	r16, 0xFF	; 255
   1161e:	1f ef       	ldi	r17, 0xFF	; 255
   11620:	1a 83       	std	Y+2, r17	; 0x02
   11622:	09 83       	std	Y+1, r16	; 0x01
	int32 addr; 	
	int16 i,rv=-1;
  
	/*Se Determina la cantidad de Poses en EEPROM*/	
	Num_Poses = Get_Num_Poses();
   11624:	0e 94 8a 8a 	call	0x11514	; 0x11514 <Get_Num_Poses>
   11628:	5c 01       	movw	r10, r24
	
	if (Num_Poses >=1)
   1162a:	18 16       	cp	r1, r24
   1162c:	19 06       	cpc	r1, r25
   1162e:	0c f0       	brlt	.+2      	; 0x11632 <return_id_vector+0x34>
   11630:	48 c0       	rjmp	.+144    	; 0x116c2 <return_id_vector+0xc4>
	{	
		id_vector = declarar(sizeof(uint16)*(Num_Poses+1));
   11632:	8c 01       	movw	r16, r24
   11634:	0f 5f       	subi	r16, 0xFF	; 255
   11636:	1f 4f       	sbci	r17, 0xFF	; 255
   11638:	c8 01       	movw	r24, r16
   1163a:	88 0f       	add	r24, r24
   1163c:	99 1f       	adc	r25, r25
   1163e:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
   11642:	fc 01       	movw	r30, r24
   11644:	90 93 c3 79 	sts	0x79C3, r25
   11648:	80 93 c2 79 	sts	0x79C2, r24
		id_vector[0]=Num_Poses+1;
   1164c:	11 83       	std	Z+1, r17	; 0x01
   1164e:	00 83       	st	Z, r16
   11650:	00 e0       	ldi	r16, 0x00	; 0
   11652:	10 e0       	ldi	r17, 0x00	; 0
   11654:	92 e0       	ldi	r25, 0x02	; 2
   11656:	c9 2e       	mov	r12, r25
   11658:	d1 2c       	mov	r13, r1
   1165a:	82 e0       	ldi	r24, 0x02	; 2
   1165c:	e8 2e       	mov	r14, r24
   1165e:	f1 2c       	mov	r15, r1
			
			/*Pasar al Segundo Banco de Memoria */
			if(i > (MAX_POSES/2))
				addr=addr+ ADD_NUM;
		 
			rv=ee24xx_read_bytes(addr,sizeof(uint16),(uint8*) &id_actual);			
   11660:	4e 01       	movw	r8, r28
   11662:	08 94       	sec
   11664:	81 1c       	adc	r8, r1
   11666:	91 1c       	adc	r9, r1
		
		for (i=0;i<Num_Poses;i++)
		{
			
			/*Direccion de Comienzo de cada Pose*/
			addr= (int32) ((i)*sizeof(PoseRobot)+sizeof(int16)); 
   11668:	b6 01       	movw	r22, r12
   1166a:	80 e0       	ldi	r24, 0x00	; 0
   1166c:	90 e0       	ldi	r25, 0x00	; 0
			
			/*Pasar al Segundo Banco de Memoria */
			if(i > (MAX_POSES/2))
   1166e:	2b e0       	ldi	r18, 0x0B	; 11
   11670:	01 32       	cpi	r16, 0x21	; 33
   11672:	12 07       	cpc	r17, r18
   11674:	24 f0       	brlt	.+8      	; 0x1167e <return_id_vector+0x80>
				addr=addr+ ADD_NUM;
   11676:	69 5f       	subi	r22, 0xF9	; 249
   11678:	7f 4f       	sbci	r23, 0xFF	; 255
   1167a:	8f 4f       	sbci	r24, 0xFF	; 255
   1167c:	9f 4f       	sbci	r25, 0xFF	; 255
		 
			rv=ee24xx_read_bytes(addr,sizeof(uint16),(uint8*) &id_actual);			
   1167e:	42 e0       	ldi	r20, 0x02	; 2
   11680:	50 e0       	ldi	r21, 0x00	; 0
   11682:	94 01       	movw	r18, r8
   11684:	0e 94 38 88 	call	0x11070	; 0x11070 <ee24xx_read_bytes>
   11688:	9c 01       	movw	r18, r24
			
			if(rv)
   1168a:	00 97       	sbiw	r24, 0x00	; 0
   1168c:	59 f1       	breq	.+86     	; 0x116e4 <return_id_vector+0xe6>
			{
				id_vector[i+1]=id_actual;
   1168e:	e0 91 c2 79 	lds	r30, 0x79C2
   11692:	f0 91 c3 79 	lds	r31, 0x79C3
   11696:	ee 0d       	add	r30, r14
   11698:	ff 1d       	adc	r31, r15
   1169a:	89 81       	ldd	r24, Y+1	; 0x01
   1169c:	9a 81       	ldd	r25, Y+2	; 0x02
   1169e:	91 83       	std	Z+1, r25	; 0x01
   116a0:	80 83       	st	Z, r24
	if (Num_Poses >=1)
	{	
		id_vector = declarar(sizeof(uint16)*(Num_Poses+1));
		id_vector[0]=Num_Poses+1;
		
		for (i=0;i<Num_Poses;i++)
   116a2:	0f 5f       	subi	r16, 0xFF	; 255
   116a4:	1f 4f       	sbci	r17, 0xFF	; 255
   116a6:	87 e1       	ldi	r24, 0x17	; 23
   116a8:	90 e0       	ldi	r25, 0x00	; 0
   116aa:	c8 0e       	add	r12, r24
   116ac:	d9 1e       	adc	r13, r25
   116ae:	82 e0       	ldi	r24, 0x02	; 2
   116b0:	90 e0       	ldi	r25, 0x00	; 0
   116b2:	e8 0e       	add	r14, r24
   116b4:	f9 1e       	adc	r15, r25
   116b6:	0a 15       	cp	r16, r10
   116b8:	1b 05       	cpc	r17, r11
   116ba:	b4 f2       	brlt	.-84     	; 0x11668 <return_id_vector+0x6a>
   116bc:	21 e0       	ldi	r18, 0x01	; 1
   116be:	30 e0       	ldi	r19, 0x00	; 0
   116c0:	11 c0       	rjmp	.+34     	; 0x116e4 <return_id_vector+0xe6>
				return rv; 								/* Error en la Lectura*/
		}
	}
	else
	{
		id_vector = declarar(sizeof(uint16)*(2));
   116c2:	84 e0       	ldi	r24, 0x04	; 4
   116c4:	90 e0       	ldi	r25, 0x00	; 0
   116c6:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
   116ca:	fc 01       	movw	r30, r24
   116cc:	90 93 c3 79 	sts	0x79C3, r25
   116d0:	80 93 c2 79 	sts	0x79C2, r24
		id_vector[0]=2;
   116d4:	82 e0       	ldi	r24, 0x02	; 2
   116d6:	90 e0       	ldi	r25, 0x00	; 0
   116d8:	91 83       	std	Z+1, r25	; 0x01
   116da:	80 83       	st	Z, r24
		id_vector[1]=-1;
   116dc:	13 83       	std	Z+3, r17	; 0x03
   116de:	02 83       	std	Z+2, r16	; 0x02
   116e0:	20 e0       	ldi	r18, 0x00	; 0
   116e2:	30 e0       	ldi	r19, 0x00	; 0
		return 0;										/* No hay Poses*/
	}

	return 1;	
}
   116e4:	c9 01       	movw	r24, r18
   116e6:	0f 90       	pop	r0
   116e8:	0f 90       	pop	r0
   116ea:	cf 91       	pop	r28
   116ec:	df 91       	pop	r29
   116ee:	1f 91       	pop	r17
   116f0:	0f 91       	pop	r16
   116f2:	ff 90       	pop	r15
   116f4:	ef 90       	pop	r14
   116f6:	df 90       	pop	r13
   116f8:	cf 90       	pop	r12
   116fa:	bf 90       	pop	r11
   116fc:	af 90       	pop	r10
   116fe:	9f 90       	pop	r9
   11700:	8f 90       	pop	r8
   11702:	08 95       	ret

00011704 <Found_Id>:

	return rv;
}
/*****************************************************************************************************/
int32 Found_Id(uint16 id)
{
   11704:	4f 92       	push	r4
   11706:	5f 92       	push	r5
   11708:	6f 92       	push	r6
   1170a:	7f 92       	push	r7
   1170c:	8f 92       	push	r8
   1170e:	9f 92       	push	r9
   11710:	af 92       	push	r10
   11712:	bf 92       	push	r11
   11714:	cf 92       	push	r12
   11716:	df 92       	push	r13
   11718:	ef 92       	push	r14
   1171a:	ff 92       	push	r15
   1171c:	0f 93       	push	r16
   1171e:	1f 93       	push	r17
   11720:	df 93       	push	r29
   11722:	cf 93       	push	r28
   11724:	00 d0       	rcall	.+0      	; 0x11726 <Found_Id+0x22>
   11726:	cd b7       	in	r28, 0x3d	; 61
   11728:	de b7       	in	r29, 0x3e	; 62
   1172a:	3c 01       	movw	r6, r24
	int16 id_actual=-1;
   1172c:	8f ef       	ldi	r24, 0xFF	; 255
   1172e:	9f ef       	ldi	r25, 0xFF	; 255
   11730:	9a 83       	std	Y+2, r25	; 0x02
   11732:	89 83       	std	Y+1, r24	; 0x01
	
	
	
	/*Se Determina la cantidad de Poses en EEPROM*/
	
	Num_Poses = Get_Num_Poses();
   11734:	0e 94 8a 8a 	call	0x11514	; 0x11514 <Get_Num_Poses>
   11738:	4c 01       	movw	r8, r24
	
	if(Num_Poses >= 1)
   1173a:	18 16       	cp	r1, r24
   1173c:	19 06       	cpc	r1, r25
   1173e:	ac f5       	brge	.+106    	; 0x117aa <Found_Id+0xa6>
   11740:	cc 24       	eor	r12, r12
   11742:	dd 24       	eor	r13, r13
   11744:	32 e0       	ldi	r19, 0x02	; 2
   11746:	a3 2e       	mov	r10, r19
   11748:	b1 2c       	mov	r11, r1
			addr= (int32) ((i)*sizeof(PoseRobot)+sizeof(int16)); 
			
			if(i > (MAX_POSES/2))
				addr=addr+ ADD_NUM;
		 
			rv=ee24xx_read_bytes(addr,sizeof(uint16),(uint8*) &id_actual);
   1174a:	2e 01       	movw	r4, r28
   1174c:	08 94       	sec
   1174e:	41 1c       	adc	r4, r1
   11750:	51 1c       	adc	r5, r1
	if(Num_Poses >= 1)
	{
		for (i=0;i< Num_Poses ;i++)
	    {
			/*Direccion de Comienzo de cada Pose*/
			addr= (int32) ((i)*sizeof(PoseRobot)+sizeof(int16)); 
   11752:	75 01       	movw	r14, r10
   11754:	00 e0       	ldi	r16, 0x00	; 0
   11756:	10 e0       	ldi	r17, 0x00	; 0
			
			if(i > (MAX_POSES/2))
   11758:	21 e2       	ldi	r18, 0x21	; 33
   1175a:	c2 16       	cp	r12, r18
   1175c:	2b e0       	ldi	r18, 0x0B	; 11
   1175e:	d2 06       	cpc	r13, r18
   11760:	44 f0       	brlt	.+16     	; 0x11772 <Found_Id+0x6e>
				addr=addr+ ADD_NUM;
   11762:	87 e0       	ldi	r24, 0x07	; 7
   11764:	90 e0       	ldi	r25, 0x00	; 0
   11766:	a0 e0       	ldi	r26, 0x00	; 0
   11768:	b0 e0       	ldi	r27, 0x00	; 0
   1176a:	e8 0e       	add	r14, r24
   1176c:	f9 1e       	adc	r15, r25
   1176e:	0a 1f       	adc	r16, r26
   11770:	1b 1f       	adc	r17, r27
		 
			rv=ee24xx_read_bytes(addr,sizeof(uint16),(uint8*) &id_actual);
   11772:	c8 01       	movw	r24, r16
   11774:	b7 01       	movw	r22, r14
   11776:	42 e0       	ldi	r20, 0x02	; 2
   11778:	50 e0       	ldi	r21, 0x00	; 0
   1177a:	92 01       	movw	r18, r4
   1177c:	0e 94 38 88 	call	0x11070	; 0x11070 <ee24xx_read_bytes>
				printf("Found_Id=> i=%d \n",i);
				printf("Found_Id=> addr=%ld \n",addr);
				printf("Found_Id=> id_actual=%d \n",id_actual);
			#endif
			
			if(rv == -1)
   11780:	8f 5f       	subi	r24, 0xFF	; 255
   11782:	9f 4f       	sbci	r25, 0xFF	; 255
   11784:	91 f0       	breq	.+36     	; 0x117aa <Found_Id+0xa6>
				return rv;								/* Se Produce un Error*/
			
			if(id==id_actual)			
   11786:	89 81       	ldd	r24, Y+1	; 0x01
   11788:	9a 81       	ldd	r25, Y+2	; 0x02
   1178a:	68 16       	cp	r6, r24
   1178c:	79 06       	cpc	r7, r25
   1178e:	19 f4       	brne	.+6      	; 0x11796 <Found_Id+0x92>
   11790:	a8 01       	movw	r20, r16
   11792:	97 01       	movw	r18, r14
   11794:	0e c0       	rjmp	.+28     	; 0x117b2 <Found_Id+0xae>
	
	Num_Poses = Get_Num_Poses();
	
	if(Num_Poses >= 1)
	{
		for (i=0;i< Num_Poses ;i++)
   11796:	08 94       	sec
   11798:	c1 1c       	adc	r12, r1
   1179a:	d1 1c       	adc	r13, r1
   1179c:	87 e1       	ldi	r24, 0x17	; 23
   1179e:	90 e0       	ldi	r25, 0x00	; 0
   117a0:	a8 0e       	add	r10, r24
   117a2:	b9 1e       	adc	r11, r25
   117a4:	c8 14       	cp	r12, r8
   117a6:	d9 04       	cpc	r13, r9
   117a8:	a4 f2       	brlt	.-88     	; 0x11752 <Found_Id+0x4e>
   117aa:	2f ef       	ldi	r18, 0xFF	; 255
   117ac:	3f ef       	ldi	r19, 0xFF	; 255
   117ae:	4f ef       	ldi	r20, 0xFF	; 255
   117b0:	5f ef       	ldi	r21, 0xFF	; 255
				return addr;  							/* Encontro  la pose deseada*/
		}
	}
	return -1;	
	
}
   117b2:	b9 01       	movw	r22, r18
   117b4:	ca 01       	movw	r24, r20
   117b6:	0f 90       	pop	r0
   117b8:	0f 90       	pop	r0
   117ba:	cf 91       	pop	r28
   117bc:	df 91       	pop	r29
   117be:	1f 91       	pop	r17
   117c0:	0f 91       	pop	r16
   117c2:	ff 90       	pop	r15
   117c4:	ef 90       	pop	r14
   117c6:	df 90       	pop	r13
   117c8:	cf 90       	pop	r12
   117ca:	bf 90       	pop	r11
   117cc:	af 90       	pop	r10
   117ce:	9f 90       	pop	r9
   117d0:	8f 90       	pop	r8
   117d2:	7f 90       	pop	r7
   117d4:	6f 90       	pop	r6
   117d6:	5f 90       	pop	r5
   117d8:	4f 90       	pop	r4
   117da:	08 95       	ret

000117dc <SobreEscribir_Pose>:
	
	return rv;
}
/*****************************************************************************************************/
int16 SobreEscribir_Pose(PoseRobot Pose)
{
   117dc:	df 93       	push	r29
   117de:	cf 93       	push	r28
   117e0:	cd b7       	in	r28, 0x3d	; 61
   117e2:	de b7       	in	r29, 0x3e	; 62
	int32 addr; 	
	
	
    
	/* Se busca la direccion en donde se encuentra la Pose*/	
	addr=Found_Id(Pose.id);
   117e4:	8d 81       	ldd	r24, Y+5	; 0x05
   117e6:	9e 81       	ldd	r25, Y+6	; 0x06
   117e8:	0e 94 82 8b 	call	0x11704	; 0x11704 <Found_Id>
	#ifdef DEBUGTWI
		printf("SobreEscribir_Pose=> addr en SobreEscribir_Pose => %ld \n",addr);
	#endif	
	
	/* Las direcciones validas de las poses empiezan a partir de 2*/
	if(addr >= 2)									
   117ec:	62 30       	cpi	r22, 0x02	; 2
   117ee:	71 05       	cpc	r23, r1
   117f0:	81 05       	cpc	r24, r1
   117f2:	91 05       	cpc	r25, r1
   117f4:	1c f4       	brge	.+6      	; 0x117fc <SobreEscribir_Pose+0x20>
   117f6:	2f ef       	ldi	r18, 0xFF	; 255
   117f8:	3f ef       	ldi	r19, 0xFF	; 255
   117fa:	08 c0       	rjmp	.+16     	; 0x1180c <SobreEscribir_Pose+0x30>
	{
		rv=ee24xx_write_bytes(addr,sizeof(PoseRobot),(uint8*) &Pose);
   117fc:	47 e1       	ldi	r20, 0x17	; 23
   117fe:	50 e0       	ldi	r21, 0x00	; 0
   11800:	9e 01       	movw	r18, r28
   11802:	2b 5f       	subi	r18, 0xFB	; 251
   11804:	3f 4f       	sbci	r19, 0xFF	; 255
   11806:	0e 94 0d 88 	call	0x1101a	; 0x1101a <ee24xx_write_bytes>
   1180a:	9c 01       	movw	r18, r24
		#endif	
	}	
	
	return rv;

}
   1180c:	c9 01       	movw	r24, r18
   1180e:	cf 91       	pop	r28
   11810:	df 91       	pop	r29
   11812:	08 95       	ret

00011814 <Leer_PoseTWI>:
	return rv;
}

/*****************************************************************************************************/
int16 Leer_PoseTWI(uint16 id, PoseRobot *Pose)
{
   11814:	cf 93       	push	r28
   11816:	df 93       	push	r29
   11818:	eb 01       	movw	r28, r22
	int32 addr; 	
	
	
    
	/* Se busca la direccion en donde se encuentra la Pose */	
	addr=Found_Id(id);
   1181a:	0e 94 82 8b 	call	0x11704	; 0x11704 <Found_Id>
	#ifdef DEBUGTWI
		printf("Leer_PoseTWI=> addr en Leer_PoseTWI => %ld \n",addr);
	#endif	
	
	/* Las direcciones validas de las poses empiezan a partir de 2*/
	if(addr >= 2)									
   1181e:	62 30       	cpi	r22, 0x02	; 2
   11820:	71 05       	cpc	r23, r1
   11822:	81 05       	cpc	r24, r1
   11824:	91 05       	cpc	r25, r1
   11826:	1c f4       	brge	.+6      	; 0x1182e <Leer_PoseTWI+0x1a>
   11828:	2f ef       	ldi	r18, 0xFF	; 255
   1182a:	3f ef       	ldi	r19, 0xFF	; 255
   1182c:	06 c0       	rjmp	.+12     	; 0x1183a <Leer_PoseTWI+0x26>
	{
		rv=ee24xx_read_bytes(addr,sizeof(PoseRobot),(uint8*) Pose);
   1182e:	47 e1       	ldi	r20, 0x17	; 23
   11830:	50 e0       	ldi	r21, 0x00	; 0
   11832:	9e 01       	movw	r18, r28
   11834:	0e 94 38 88 	call	0x11070	; 0x11070 <ee24xx_read_bytes>
   11838:	9c 01       	movw	r18, r24
	}	
	
	
	
	return rv;
}
   1183a:	c9 01       	movw	r24, r18
   1183c:	df 91       	pop	r29
   1183e:	cf 91       	pop	r28
   11840:	08 95       	ret

00011842 <Vector2Trajectory>:
/*****************************************************************************************************/
/*-----------------------------------------------------------------------------------------*/
/*No podemos Usa rxTrajectory */
/*Crea un trayectory utilizando las posiciones del Vector de Ids*/
int16  Vector2Trajectory(uint16 *vector)
{	
   11842:	2f 92       	push	r2
   11844:	3f 92       	push	r3
   11846:	4f 92       	push	r4
   11848:	5f 92       	push	r5
   1184a:	6f 92       	push	r6
   1184c:	7f 92       	push	r7
   1184e:	8f 92       	push	r8
   11850:	9f 92       	push	r9
   11852:	af 92       	push	r10
   11854:	bf 92       	push	r11
   11856:	cf 92       	push	r12
   11858:	df 92       	push	r13
   1185a:	ef 92       	push	r14
   1185c:	ff 92       	push	r15
   1185e:	0f 93       	push	r16
   11860:	1f 93       	push	r17
   11862:	df 93       	push	r29
   11864:	cf 93       	push	r28
   11866:	cd b7       	in	r28, 0x3d	; 61
   11868:	de b7       	in	r29, 0x3e	; 62
   1186a:	67 97       	sbiw	r28, 0x17	; 23
   1186c:	0f b6       	in	r0, 0x3f	; 63
   1186e:	f8 94       	cli
   11870:	de bf       	out	0x3e, r29	; 62
   11872:	0f be       	out	0x3f, r0	; 63
   11874:	cd bf       	out	0x3d, r28	; 61
   11876:	8c 01       	movw	r16, r24
	int16 num_datos,i,rv, axis;
	uint16 id_pose;
	PoseRobot Pose;	
	extern int16 FlagrxVectorok;
	
	num_datos=vector[0];								//numero de datos del vector
   11878:	dc 01       	movw	r26, r24
   1187a:	8d 90       	ld	r8, X+
   1187c:	9c 90       	ld	r9, X
	if(FlagrxVectorok)	
   1187e:	80 91 b0 74 	lds	r24, 0x74B0
   11882:	90 91 b1 74 	lds	r25, 0x74B1
   11886:	89 2b       	or	r24, r25
   11888:	31 f0       	breq	.+12     	; 0x11896 <Vector2Trajectory+0x54>
		free(Trajectoryvector.point);
   1188a:	80 91 c8 79 	lds	r24, 0x79C8
   1188e:	90 91 c9 79 	lds	r25, 0x79C9
   11892:	0e 94 78 9d 	call	0x13af0	; 0x13af0 <free>
		
	Trajectoryvector.point= declarar(sizeof(tpoint)*num_datos);//asigno memoria a los puntos
   11896:	8d e3       	ldi	r24, 0x3D	; 61
   11898:	90 e0       	ldi	r25, 0x00	; 0
   1189a:	fc 01       	movw	r30, r24
   1189c:	8e 9e       	mul	r8, r30
   1189e:	c0 01       	movw	r24, r0
   118a0:	8f 9e       	mul	r8, r31
   118a2:	90 0d       	add	r25, r0
   118a4:	9e 9e       	mul	r9, r30
   118a6:	90 0d       	add	r25, r0
   118a8:	11 24       	eor	r1, r1
   118aa:	0e 94 81 36 	call	0x6d02	; 0x6d02 <declarar>
   118ae:	90 93 c9 79 	sts	0x79C9, r25
   118b2:	80 93 c8 79 	sts	0x79C8, r24
	
	
	//lleno los campos de la trayectoria como size e invalid mask
	Trajectoryvector.size=	num_datos-1;
   118b6:	94 01       	movw	r18, r8
   118b8:	21 50       	subi	r18, 0x01	; 1
   118ba:	30 40       	sbci	r19, 0x00	; 0
   118bc:	30 93 c5 79 	sts	0x79C5, r19
   118c0:	20 93 c4 79 	sts	0x79C4, r18
	Trajectoryvector.invalidmask= (WaistMask |ShoulderMask | ElbowMask | PitchMask| RollMask);
   118c4:	8f e1       	ldi	r24, 0x1F	; 31
   118c6:	90 e0       	ldi	r25, 0x00	; 0
   118c8:	90 93 c7 79 	sts	0x79C7, r25
   118cc:	80 93 c6 79 	sts	0x79C6, r24
	
	printf("Vector2Trajectory=> Trajectoryvector.size= %d\n",Trajectoryvector.size);
   118d0:	00 d0       	rcall	.+0      	; 0x118d2 <Vector2Trajectory+0x90>
   118d2:	00 d0       	rcall	.+0      	; 0x118d4 <Vector2Trajectory+0x92>
   118d4:	82 e3       	ldi	r24, 0x32	; 50
   118d6:	90 e7       	ldi	r25, 0x70	; 112
   118d8:	ad b7       	in	r26, 0x3d	; 61
   118da:	be b7       	in	r27, 0x3e	; 62
   118dc:	12 96       	adiw	r26, 0x02	; 2
   118de:	9c 93       	st	X, r25
   118e0:	8e 93       	st	-X, r24
   118e2:	11 97       	sbiw	r26, 0x01	; 1
   118e4:	14 96       	adiw	r26, 0x04	; 4
   118e6:	3c 93       	st	X, r19
   118e8:	2e 93       	st	-X, r18
   118ea:	13 97       	sbiw	r26, 0x03	; 3
   118ec:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Vector2Trajectory=> Trajectoryvector.invalidmask= = %d\n",Trajectoryvector.invalidmask);
   118f0:	81 e6       	ldi	r24, 0x61	; 97
   118f2:	90 e7       	ldi	r25, 0x70	; 112
   118f4:	ed b7       	in	r30, 0x3d	; 61
   118f6:	fe b7       	in	r31, 0x3e	; 62
   118f8:	92 83       	std	Z+2, r25	; 0x02
   118fa:	81 83       	std	Z+1, r24	; 0x01
   118fc:	80 91 c6 79 	lds	r24, 0x79C6
   11900:	90 91 c7 79 	lds	r25, 0x79C7
   11904:	94 83       	std	Z+4, r25	; 0x04
   11906:	83 83       	std	Z+3, r24	; 0x03
   11908:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
   1190c:	58 01       	movw	r10, r16
   1190e:	11 e0       	ldi	r17, 0x01	; 1
   11910:	c1 2e       	mov	r12, r17
   11912:	d1 2c       	mov	r13, r1
   11914:	ee 24       	eor	r14, r14
   11916:	ff 24       	eor	r15, r15
   11918:	0f 90       	pop	r0
   1191a:	0f 90       	pop	r0
   1191c:	0f 90       	pop	r0
   1191e:	0f 90       	pop	r0
	for (i=1;i<num_datos;i++)
	{
		id_pose= vector[i];								//Obtengo el Id de la Pose		
		rv=	Leer_PoseTWI(id_pose, &Pose);				//obtener la Pose del Robot almacenada en EEPROM
   11920:	3e 01       	movw	r6, r28
   11922:	08 94       	sec
   11924:	61 1c       	adc	r6, r1
   11926:	71 1c       	adc	r7, r1
   11928:	82 c0       	rjmp	.+260    	; 0x11a2e <Vector2Trajectory+0x1ec>
   1192a:	d5 01       	movw	r26, r10
   1192c:	12 96       	adiw	r26, 0x02	; 2
   1192e:	8d 91       	ld	r24, X+
   11930:	9c 91       	ld	r25, X
   11932:	13 97       	sbiw	r26, 0x03	; 3
   11934:	b3 01       	movw	r22, r6
   11936:	0e 94 0a 8c 	call	0x11814	; 0x11814 <Leer_PoseTWI>
		printf("Vector2Trajectory=> Pose.Pos_Elbow = %ld\n",Pose.Pos_Elbow);
		printf("Vector2Trajectory=> Pose.Pos_Pitch = %ld\n",Pose.Pos_Pitch);
		printf("Vector2Trajectory=> Pose.Pos_Roll = %ld\n",Pose.Pos_Roll);
		printf("Vector2Trajectory=> Pose.id = %d\n",Pose.id);
		#endif
		if(rv>0)
   1193a:	18 16       	cp	r1, r24
   1193c:	19 06       	cpc	r1, r25
   1193e:	1c f0       	brlt	.+6      	; 0x11946 <Vector2Trajectory+0x104>
   11940:	2f ef       	ldi	r18, 0xFF	; 255
   11942:	3f ef       	ldi	r19, 0xFF	; 255
   11944:	7a c0       	rjmp	.+244    	; 0x11a3a <Vector2Trajectory+0x1f8>
		{
			//LLeno el Campo de Posicion de la Trayectoria
			Trajectoryvector.point[(i-1)].axis[AxisWaist].position=Pose.Pos_Waist;
   11946:	e0 91 c8 79 	lds	r30, 0x79C8
   1194a:	f0 91 c9 79 	lds	r31, 0x79C9
   1194e:	ee 0d       	add	r30, r14
   11950:	ff 1d       	adc	r31, r15
   11952:	8b 81       	ldd	r24, Y+3	; 0x03
   11954:	9c 81       	ldd	r25, Y+4	; 0x04
   11956:	ad 81       	ldd	r26, Y+5	; 0x05
   11958:	be 81       	ldd	r27, Y+6	; 0x06
   1195a:	80 83       	st	Z, r24
   1195c:	91 83       	std	Z+1, r25	; 0x01
   1195e:	a2 83       	std	Z+2, r26	; 0x02
   11960:	b3 83       	std	Z+3, r27	; 0x03
			Trajectoryvector.point[(i-1)].axis[AxisShoulder].position=Pose.Pos_Shoulder;
   11962:	8f 81       	ldd	r24, Y+7	; 0x07
   11964:	98 85       	ldd	r25, Y+8	; 0x08
   11966:	a9 85       	ldd	r26, Y+9	; 0x09
   11968:	ba 85       	ldd	r27, Y+10	; 0x0a
   1196a:	84 87       	std	Z+12, r24	; 0x0c
   1196c:	95 87       	std	Z+13, r25	; 0x0d
   1196e:	a6 87       	std	Z+14, r26	; 0x0e
   11970:	b7 87       	std	Z+15, r27	; 0x0f
			Trajectoryvector.point[(i-1)].axis[AxisElbow].position=Pose.Pos_Elbow;
   11972:	8b 85       	ldd	r24, Y+11	; 0x0b
   11974:	9c 85       	ldd	r25, Y+12	; 0x0c
   11976:	ad 85       	ldd	r26, Y+13	; 0x0d
   11978:	be 85       	ldd	r27, Y+14	; 0x0e
   1197a:	80 8f       	std	Z+24, r24	; 0x18
   1197c:	91 8f       	std	Z+25, r25	; 0x19
   1197e:	a2 8f       	std	Z+26, r26	; 0x1a
   11980:	b3 8f       	std	Z+27, r27	; 0x1b
			Trajectoryvector.point[(i-1)].axis[AxisPitch].position=Pose.Pos_Pitch;
   11982:	8f 85       	ldd	r24, Y+15	; 0x0f
   11984:	98 89       	ldd	r25, Y+16	; 0x10
   11986:	a9 89       	ldd	r26, Y+17	; 0x11
   11988:	ba 89       	ldd	r27, Y+18	; 0x12
   1198a:	84 a3       	std	Z+36, r24	; 0x24
   1198c:	95 a3       	std	Z+37, r25	; 0x25
   1198e:	a6 a3       	std	Z+38, r26	; 0x26
   11990:	b7 a3       	std	Z+39, r27	; 0x27
			Trajectoryvector.point[(i-1)].axis[AxisRoll].position=Pose.Pos_Roll;
   11992:	8b 89       	ldd	r24, Y+19	; 0x13
   11994:	9c 89       	ldd	r25, Y+20	; 0x14
   11996:	ad 89       	ldd	r26, Y+21	; 0x15
   11998:	be 89       	ldd	r27, Y+22	; 0x16
   1199a:	80 ab       	std	Z+48, r24	; 0x30
   1199c:	91 ab       	std	Z+49, r25	; 0x31
   1199e:	a2 ab       	std	Z+50, r26	; 0x32
   119a0:	b3 ab       	std	Z+51, r27	; 0x33
			Trajectoryvector.point[(i-1)].Gripper_Status=Pose.Gripper_Status;
   119a2:	8f 89       	ldd	r24, Y+23	; 0x17
   119a4:	84 af       	std	Z+60, r24	; 0x3c
   119a6:	09 e5       	ldi	r16, 0x59	; 89
   119a8:	15 e7       	ldi	r17, 0x75	; 117
   119aa:	60 e0       	ldi	r22, 0x00	; 0
   119ac:	70 e0       	ldi	r23, 0x00	; 0
			
			#endif
			//LLeno los demas Campos de la Trayectoria. Velocidad y Aceleracion maximos
			for(axis=0; axis < DOF; axis++) 
			{
				Trajectoryvector.point[(i-1)].axis[axis].velocity=hAxis[axis].axisSettings.homeVelocity;
   119ae:	40 91 c8 79 	lds	r20, 0x79C8
   119b2:	50 91 c9 79 	lds	r21, 0x79C9
   119b6:	4e 0d       	add	r20, r14
   119b8:	5f 1d       	adc	r21, r15
   119ba:	9b 01       	movw	r18, r22
   119bc:	22 0f       	add	r18, r18
   119be:	33 1f       	adc	r19, r19
   119c0:	26 0f       	add	r18, r22
   119c2:	37 1f       	adc	r19, r23
   119c4:	f9 01       	movw	r30, r18
   119c6:	31 96       	adiw	r30, 0x01	; 1
   119c8:	ee 0f       	add	r30, r30
   119ca:	ff 1f       	adc	r31, r31
   119cc:	ee 0f       	add	r30, r30
   119ce:	ff 1f       	adc	r31, r31
   119d0:	e4 0f       	add	r30, r20
   119d2:	f5 1f       	adc	r31, r21
   119d4:	d8 01       	movw	r26, r16
   119d6:	2d 90       	ld	r2, X+
   119d8:	3d 90       	ld	r3, X+
   119da:	4d 90       	ld	r4, X+
   119dc:	5c 90       	ld	r5, X
   119de:	13 97       	sbiw	r26, 0x03	; 3
   119e0:	20 82       	st	Z, r2
   119e2:	31 82       	std	Z+1, r3	; 0x01
   119e4:	42 82       	std	Z+2, r4	; 0x02
   119e6:	53 82       	std	Z+3, r5	; 0x03
				Trajectoryvector.point[(i-1)].axis[axis].acceleration=hAxis[axis].axisSettings.homeAcceleration;
   119e8:	22 0f       	add	r18, r18
   119ea:	33 1f       	adc	r19, r19
   119ec:	22 0f       	add	r18, r18
   119ee:	33 1f       	adc	r19, r19
   119f0:	42 0f       	add	r20, r18
   119f2:	53 1f       	adc	r21, r19
   119f4:	14 96       	adiw	r26, 0x04	; 4
   119f6:	8d 91       	ld	r24, X+
   119f8:	9d 91       	ld	r25, X+
   119fa:	0d 90       	ld	r0, X+
   119fc:	bc 91       	ld	r27, X
   119fe:	a0 2d       	mov	r26, r0
   11a00:	fa 01       	movw	r30, r20
   11a02:	80 87       	std	Z+8, r24	; 0x08
   11a04:	91 87       	std	Z+9, r25	; 0x09
   11a06:	a2 87       	std	Z+10, r26	; 0x0a
   11a08:	b3 87       	std	Z+11, r27	; 0x0b
			printf("Vector2Trajectory=> La posicion de %s es en packetIO.c => %ld\n",AxisName(AxisRoll),
				   Trajectoryvector->point[(i-1)].axis[AxisRoll].position);
			
			#endif
			//LLeno los demas Campos de la Trayectoria. Velocidad y Aceleracion maximos
			for(axis=0; axis < DOF; axis++) 
   11a0a:	6f 5f       	subi	r22, 0xFF	; 255
   11a0c:	7f 4f       	sbci	r23, 0xFF	; 255
   11a0e:	00 5a       	subi	r16, 0xA0	; 160
   11a10:	1f 4f       	sbci	r17, 0xFF	; 255
   11a12:	65 30       	cpi	r22, 0x05	; 5
   11a14:	71 05       	cpc	r23, r1
   11a16:	59 f6       	brne	.-106    	; 0x119ae <Vector2Trajectory+0x16c>
	Trajectoryvector.size=	num_datos-1;
	Trajectoryvector.invalidmask= (WaistMask |ShoulderMask | ElbowMask | PitchMask| RollMask);
	
	printf("Vector2Trajectory=> Trajectoryvector.size= %d\n",Trajectoryvector.size);
	printf("Vector2Trajectory=> Trajectoryvector.invalidmask= = %d\n",Trajectoryvector.invalidmask);
	for (i=1;i<num_datos;i++)
   11a18:	08 94       	sec
   11a1a:	c1 1c       	adc	r12, r1
   11a1c:	d1 1c       	adc	r13, r1
   11a1e:	2d e3       	ldi	r18, 0x3D	; 61
   11a20:	30 e0       	ldi	r19, 0x00	; 0
   11a22:	e2 0e       	add	r14, r18
   11a24:	f3 1e       	adc	r15, r19
   11a26:	82 e0       	ldi	r24, 0x02	; 2
   11a28:	90 e0       	ldi	r25, 0x00	; 0
   11a2a:	a8 0e       	add	r10, r24
   11a2c:	b9 1e       	adc	r11, r25
   11a2e:	c8 14       	cp	r12, r8
   11a30:	d9 04       	cpc	r13, r9
   11a32:	0c f4       	brge	.+2      	; 0x11a36 <Vector2Trajectory+0x1f4>
   11a34:	7a cf       	rjmp	.-268    	; 0x1192a <Vector2Trajectory+0xe8>
   11a36:	20 e0       	ldi	r18, 0x00	; 0
   11a38:	30 e0       	ldi	r19, 0x00	; 0
				break;
			}
		}
	}*/
	return 0;
}
   11a3a:	c9 01       	movw	r24, r18
   11a3c:	67 96       	adiw	r28, 0x17	; 23
   11a3e:	0f b6       	in	r0, 0x3f	; 63
   11a40:	f8 94       	cli
   11a42:	de bf       	out	0x3e, r29	; 62
   11a44:	0f be       	out	0x3f, r0	; 63
   11a46:	cd bf       	out	0x3d, r28	; 61
   11a48:	cf 91       	pop	r28
   11a4a:	df 91       	pop	r29
   11a4c:	1f 91       	pop	r17
   11a4e:	0f 91       	pop	r16
   11a50:	ff 90       	pop	r15
   11a52:	ef 90       	pop	r14
   11a54:	df 90       	pop	r13
   11a56:	cf 90       	pop	r12
   11a58:	bf 90       	pop	r11
   11a5a:	af 90       	pop	r10
   11a5c:	9f 90       	pop	r9
   11a5e:	8f 90       	pop	r8
   11a60:	7f 90       	pop	r7
   11a62:	6f 90       	pop	r6
   11a64:	5f 90       	pop	r5
   11a66:	4f 90       	pop	r4
   11a68:	3f 90       	pop	r3
   11a6a:	2f 90       	pop	r2
   11a6c:	08 95       	ret

00011a6e <delay_1s>:

PMDint32 EEMEM ATmegaEEPROM_var=0;

/****************************************************************************************/  
void delay_1s(void)
{
   11a6e:	20 e0       	ldi	r18, 0x00	; 0
   11a70:	40 e2       	ldi	r20, 0x20	; 32
   11a72:	5e e4       	ldi	r21, 0x4E	; 78
   11a74:	ca 01       	movw	r24, r20
   11a76:	01 97       	sbiw	r24, 0x01	; 1
   11a78:	f1 f7       	brne	.-4      	; 0x11a76 <delay_1s+0x8>
  uint8 i;

  for (i = 0; i < 100; i++)   
   11a7a:	2f 5f       	subi	r18, 0xFF	; 255
   11a7c:	24 36       	cpi	r18, 0x64	; 100
   11a7e:	d1 f7       	brne	.-12     	; 0x11a74 <delay_1s+0x6>
    _delay_ms(10);
}
   11a80:	08 95       	ret

00011a82 <buzzer>:

/****************************************************************************************/ 
void buzzer(uint16 valor_s)
{
   11a82:	ac 01       	movw	r20, r24
	uint8 i;	
	
	PORTD 	|= 	_BV(Alarma);
   11a84:	5f 9a       	sbi	0x0b, 7	; 11
   11a86:	30 e0       	ldi	r19, 0x00	; 0
   11a88:	60 e2       	ldi	r22, 0x20	; 32
   11a8a:	7e e4       	ldi	r23, 0x4E	; 78
   11a8c:	08 c0       	rjmp	.+16     	; 0x11a9e <buzzer+0x1c>
	
	for(i = 0; i < valor_s; i++)
   11a8e:	20 e0       	ldi	r18, 0x00	; 0
   11a90:	cb 01       	movw	r24, r22
   11a92:	01 97       	sbiw	r24, 0x01	; 1
   11a94:	f1 f7       	brne	.-4      	; 0x11a92 <buzzer+0x10>
/****************************************************************************************/  
void delay_1s(void)
{
  uint8 i;

  for (i = 0; i < 100; i++)   
   11a96:	2f 5f       	subi	r18, 0xFF	; 255
   11a98:	24 36       	cpi	r18, 0x64	; 100
   11a9a:	d1 f7       	brne	.-12     	; 0x11a90 <buzzer+0xe>
{
	uint8 i;	
	
	PORTD 	|= 	_BV(Alarma);
	
	for(i = 0; i < valor_s; i++)
   11a9c:	3f 5f       	subi	r19, 0xFF	; 255
   11a9e:	83 2f       	mov	r24, r19
   11aa0:	90 e0       	ldi	r25, 0x00	; 0
   11aa2:	84 17       	cp	r24, r20
   11aa4:	95 07       	cpc	r25, r21
   11aa6:	98 f3       	brcs	.-26     	; 0x11a8e <buzzer+0xc>
	{
		delay_1s();
	}
	
	PORTD 	&= 	~(_BV(Alarma));
   11aa8:	5f 98       	cbi	0x0b, 7	; 11
}
   11aaa:	08 95       	ret

00011aac <buzzer_ms>:
/****************************************************************************************/ 
void buzzer_ms(uint32 valor_ms)
{
   11aac:	af 92       	push	r10
   11aae:	bf 92       	push	r11
   11ab0:	cf 92       	push	r12
   11ab2:	df 92       	push	r13
   11ab4:	ef 92       	push	r14
   11ab6:	ff 92       	push	r15
   11ab8:	0f 93       	push	r16
   11aba:	1f 93       	push	r17
	
	
	PORTD 	|= 	_BV(Alarma);
   11abc:	5f 9a       	sbi	0x0b, 7	; 11
	
	_delay_ms((double)valor_ms);
   11abe:	0e 94 d0 9a 	call	0x135a0	; 0x135a0 <__floatunsisf>
   11ac2:	5b 01       	movw	r10, r22
   11ac4:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
   11ac6:	20 e0       	ldi	r18, 0x00	; 0
   11ac8:	30 e0       	ldi	r19, 0x00	; 0
   11aca:	4a ef       	ldi	r20, 0xFA	; 250
   11acc:	54 e4       	ldi	r21, 0x44	; 68
   11ace:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
   11ad2:	7b 01       	movw	r14, r22
   11ad4:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
   11ad6:	20 e0       	ldi	r18, 0x00	; 0
   11ad8:	30 e0       	ldi	r19, 0x00	; 0
   11ada:	40 e8       	ldi	r20, 0x80	; 128
   11adc:	5f e3       	ldi	r21, 0x3F	; 63
   11ade:	0e 94 33 9a 	call	0x13466	; 0x13466 <__cmpsf2>
   11ae2:	88 23       	and	r24, r24
   11ae4:	1c f4       	brge	.+6      	; 0x11aec <buzzer_ms+0x40>
   11ae6:	61 e0       	ldi	r22, 0x01	; 1
   11ae8:	70 e0       	ldi	r23, 0x00	; 0
   11aea:	24 c0       	rjmp	.+72     	; 0x11b34 <buzzer_ms+0x88>
		__ticks = 1;
	else if (__tmp > 65535)
   11aec:	c8 01       	movw	r24, r16
   11aee:	b7 01       	movw	r22, r14
   11af0:	20 e0       	ldi	r18, 0x00	; 0
   11af2:	3f ef       	ldi	r19, 0xFF	; 255
   11af4:	4f e7       	ldi	r20, 0x7F	; 127
   11af6:	57 e4       	ldi	r21, 0x47	; 71
   11af8:	0e 94 d5 9b 	call	0x137aa	; 0x137aa <__gesf2>
   11afc:	18 16       	cp	r1, r24
   11afe:	b4 f4       	brge	.+44     	; 0x11b2c <buzzer_ms+0x80>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
   11b00:	c6 01       	movw	r24, r12
   11b02:	b5 01       	movw	r22, r10
   11b04:	20 e0       	ldi	r18, 0x00	; 0
   11b06:	30 e0       	ldi	r19, 0x00	; 0
   11b08:	40 e2       	ldi	r20, 0x20	; 32
   11b0a:	51 e4       	ldi	r21, 0x41	; 65
   11b0c:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
   11b10:	0e 94 a4 9a 	call	0x13548	; 0x13548 <__fixunssfsi>
   11b14:	88 ec       	ldi	r24, 0xC8	; 200
   11b16:	90 e0       	ldi	r25, 0x00	; 0
   11b18:	05 c0       	rjmp	.+10     	; 0x11b24 <buzzer_ms+0x78>
   11b1a:	fc 01       	movw	r30, r24
   11b1c:	31 97       	sbiw	r30, 0x01	; 1
   11b1e:	f1 f7       	brne	.-4      	; 0x11b1c <buzzer_ms+0x70>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   11b20:	61 50       	subi	r22, 0x01	; 1
   11b22:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   11b24:	61 15       	cp	r22, r1
   11b26:	71 05       	cpc	r23, r1
   11b28:	c1 f7       	brne	.-16     	; 0x11b1a <buzzer_ms+0x6e>
   11b2a:	07 c0       	rjmp	.+14     	; 0x11b3a <buzzer_ms+0x8e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
   11b2c:	c8 01       	movw	r24, r16
   11b2e:	b7 01       	movw	r22, r14
   11b30:	0e 94 a4 9a 	call	0x13548	; 0x13548 <__fixunssfsi>
   11b34:	cb 01       	movw	r24, r22
   11b36:	01 97       	sbiw	r24, 0x01	; 1
   11b38:	f1 f7       	brne	.-4      	; 0x11b36 <buzzer_ms+0x8a>
	
	PORTD 	&= 	~(_BV(Alarma));
   11b3a:	5f 98       	cbi	0x0b, 7	; 11
}
   11b3c:	1f 91       	pop	r17
   11b3e:	0f 91       	pop	r16
   11b40:	ff 90       	pop	r15
   11b42:	ef 90       	pop	r14
   11b44:	df 90       	pop	r13
   11b46:	cf 90       	pop	r12
   11b48:	bf 90       	pop	r11
   11b4a:	af 90       	pop	r10
   11b4c:	08 95       	ret

00011b4e <Led_on>:
/****************************************************************************************/  
void Led_on (tLeds color)
{
	
	/* Se Coloca el Bit LED0 del Puerto B en Modo de Salida y se le da un valor de 1*/	
	DDRB		|=	_BV(LED0);
   11b4e:	27 9a       	sbi	0x04, 7	; 4
	PORTB		|=	_BV(LED0);							
   11b50:	2f 9a       	sbi	0x05, 7	; 5

	switch (color)
   11b52:	81 30       	cpi	r24, 0x01	; 1
   11b54:	41 f0       	breq	.+16     	; 0x11b66 <Led_on+0x18>
   11b56:	81 30       	cpi	r24, 0x01	; 1
   11b58:	20 f0       	brcs	.+8      	; 0x11b62 <Led_on+0x14>
   11b5a:	82 30       	cpi	r24, 0x02	; 2
   11b5c:	31 f4       	brne	.+12     	; 0x11b6a <Led_on+0x1c>
	{
		case (Amarillo):
			PORTE		&= 	~(_BV(AMARILLOe)); 
   11b5e:	77 98       	cbi	0x0e, 7	; 14
   11b60:	08 95       	ret
		break;
			
		case (Verde):
			PORTE		&= 	~(_BV(VERDEe)); 
   11b62:	72 98       	cbi	0x0e, 2	; 14
   11b64:	08 95       	ret
		break;
			
		case (Rojo):
			PORTB		&= 	~(_BV(ROJOb));
   11b66:	2f 98       	cbi	0x05, 7	; 5
   11b68:	08 95       	ret
		break;
			
		default:
			PORTE		|=  _BV(AMARILLOe);
   11b6a:	77 9a       	sbi	0x0e, 7	; 14
			PORTE		|=  _BV(VERDEe);
   11b6c:	72 9a       	sbi	0x0e, 2	; 14
			PORTB		|=  _BV(ROJOb);
   11b6e:	2f 9a       	sbi	0x05, 7	; 5
   11b70:	08 95       	ret

00011b72 <Led_off>:

/****************************************************************************************/  
void Led_off (int16 color)
{
	/* Se Coloca el Bit LED0 del Puerto B en Modo de Salida y se le da un valor de 1*/	
	DDRB		|=	_BV(LED0);
   11b72:	27 9a       	sbi	0x04, 7	; 4
	PORTB		|=	_BV(LED0);							
   11b74:	2f 9a       	sbi	0x05, 7	; 5
 
	switch (color)
   11b76:	81 30       	cpi	r24, 0x01	; 1
   11b78:	91 05       	cpc	r25, r1
   11b7a:	61 f0       	breq	.+24     	; 0x11b94 <Led_off+0x22>
   11b7c:	82 30       	cpi	r24, 0x02	; 2
   11b7e:	91 05       	cpc	r25, r1
   11b80:	19 f0       	breq	.+6      	; 0x11b88 <Led_off+0x16>
   11b82:	89 2b       	or	r24, r25
   11b84:	19 f0       	breq	.+6      	; 0x11b8c <Led_off+0x1a>
   11b86:	04 c0       	rjmp	.+8      	; 0x11b90 <Led_off+0x1e>
	{
		case (Amarillo):
			PORTE		|= 	_BV(AMARILLOe); 
   11b88:	77 9a       	sbi	0x0e, 7	; 14
   11b8a:	08 95       	ret
		break;
			
		case (Verde):
			PORTE		|= 	_BV(VERDEe); 
   11b8c:	72 9a       	sbi	0x0e, 2	; 14
   11b8e:	08 95       	ret
		case (Rojo):
			PORTB		|= 	_BV(ROJOb);
		break;
			
		default:
			PORTE		|=  _BV(AMARILLOe);
   11b90:	77 9a       	sbi	0x0e, 7	; 14
			PORTE		|=  _BV(VERDEe);
   11b92:	72 9a       	sbi	0x0e, 2	; 14
			PORTB		|=  _BV(ROJOb);
   11b94:	2f 9a       	sbi	0x05, 7	; 5
   11b96:	08 95       	ret

00011b98 <Test_perifericos>:
	}
}


void Test_perifericos(void)
{
   11b98:	8f 92       	push	r8
   11b9a:	9f 92       	push	r9
   11b9c:	af 92       	push	r10
   11b9e:	bf 92       	push	r11
   11ba0:	cf 92       	push	r12
   11ba2:	df 92       	push	r13
   11ba4:	ef 92       	push	r14
   11ba6:	ff 92       	push	r15
   11ba8:	0f 93       	push	r16
   11baa:	1f 93       	push	r17
   11bac:	df 93       	push	r29
   11bae:	cf 93       	push	r28
   11bb0:	cd b7       	in	r28, 0x3d	; 61
   11bb2:	de b7       	in	r29, 0x3e	; 62
   11bb4:	a4 97       	sbiw	r28, 0x24	; 36
   11bb6:	0f b6       	in	r0, 0x3f	; 63
   11bb8:	f8 94       	cli
   11bba:	de bf       	out	0x3e, r29	; 62
   11bbc:	0f be       	out	0x3f, r0	; 63
   11bbe:	cd bf       	out	0x3d, r28	; 61
	int rv;
	char pause;
	tFecha Test_Fecha;
	
	
	printf("Iniciando secuencia de pruebas perifericos...\n");
   11bc0:	89 e9       	ldi	r24, 0x99	; 153
   11bc2:	90 e7       	ldi	r25, 0x70	; 112
   11bc4:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	//Prueba LCD y LED...
	printf("Mensaje prueba LCD y LED ...\n");
   11bc8:	87 ec       	ldi	r24, 0xC7	; 199
   11bca:	90 e7       	ldi	r25, 0x70	; 112
   11bcc:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	fprintf(stderr, "T E S T   L C D.\n");
   11bd0:	60 91 d2 79 	lds	r22, 0x79D2
   11bd4:	70 91 d3 79 	lds	r23, 0x79D3
   11bd8:	84 ee       	ldi	r24, 0xE4	; 228
   11bda:	90 e7       	ldi	r25, 0x70	; 112
   11bdc:	0e 94 9e 9f 	call	0x13f3c	; 0x13f3c <fputs>
	Led_on(Amarillo);
   11be0:	82 e0       	ldi	r24, 0x02	; 2
   11be2:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
   11be6:	20 e0       	ldi	r18, 0x00	; 0
   11be8:	40 e2       	ldi	r20, 0x20	; 32
   11bea:	5e e4       	ldi	r21, 0x4E	; 78
   11bec:	ca 01       	movw	r24, r20
   11bee:	01 97       	sbiw	r24, 0x01	; 1
   11bf0:	f1 f7       	brne	.-4      	; 0x11bee <Test_perifericos+0x56>
/****************************************************************************************/  
void delay_1s(void)
{
  uint8 i;

  for (i = 0; i < 100; i++)   
   11bf2:	2f 5f       	subi	r18, 0xFF	; 255
   11bf4:	24 36       	cpi	r18, 0x64	; 100
   11bf6:	d1 f7       	brne	.-12     	; 0x11bec <Test_perifericos+0x54>
	//Prueba LCD y LED...
	printf("Mensaje prueba LCD y LED ...\n");
	fprintf(stderr, "T E S T   L C D.\n");
	Led_on(Amarillo);
	delay_1s();	
	Led_on(Verde);	
   11bf8:	80 e0       	ldi	r24, 0x00	; 0
   11bfa:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
   11bfe:	20 e0       	ldi	r18, 0x00	; 0
   11c00:	40 e2       	ldi	r20, 0x20	; 32
   11c02:	5e e4       	ldi	r21, 0x4E	; 78
   11c04:	ca 01       	movw	r24, r20
   11c06:	01 97       	sbiw	r24, 0x01	; 1
   11c08:	f1 f7       	brne	.-4      	; 0x11c06 <Test_perifericos+0x6e>
/****************************************************************************************/  
void delay_1s(void)
{
  uint8 i;

  for (i = 0; i < 100; i++)   
   11c0a:	2f 5f       	subi	r18, 0xFF	; 255
   11c0c:	24 36       	cpi	r18, 0x64	; 100
   11c0e:	d1 f7       	brne	.-12     	; 0x11c04 <Test_perifericos+0x6c>
	fprintf(stderr, "T E S T   L C D.\n");
	Led_on(Amarillo);
	delay_1s();	
	Led_on(Verde);	
	delay_1s();	
	Led_on(Rojo);	
   11c10:	81 e0       	ldi	r24, 0x01	; 1
   11c12:	0e 94 a7 8d 	call	0x11b4e	; 0x11b4e <Led_on>
   11c16:	20 e0       	ldi	r18, 0x00	; 0
   11c18:	40 e2       	ldi	r20, 0x20	; 32
   11c1a:	5e e4       	ldi	r21, 0x4E	; 78
   11c1c:	ca 01       	movw	r24, r20
   11c1e:	01 97       	sbiw	r24, 0x01	; 1
   11c20:	f1 f7       	brne	.-4      	; 0x11c1e <Test_perifericos+0x86>
/****************************************************************************************/  
void delay_1s(void)
{
  uint8 i;

  for (i = 0; i < 100; i++)   
   11c22:	2f 5f       	subi	r18, 0xFF	; 255
   11c24:	24 36       	cpi	r18, 0x64	; 100
   11c26:	d1 f7       	brne	.-12     	; 0x11c1c <Test_perifericos+0x84>
	delay_1s();	
	Led_on(Verde);	
	delay_1s();	
	Led_on(Rojo);	
	delay_1s();	
	Led_off(Rojo);
   11c28:	81 e0       	ldi	r24, 0x01	; 1
   11c2a:	90 e0       	ldi	r25, 0x00	; 0
   11c2c:	0e 94 b9 8d 	call	0x11b72	; 0x11b72 <Led_off>
	Led_off(Verde);
   11c30:	80 e0       	ldi	r24, 0x00	; 0
   11c32:	90 e0       	ldi	r25, 0x00	; 0
   11c34:	0e 94 b9 8d 	call	0x11b72	; 0x11b72 <Led_off>
	Led_off(Amarillo);
   11c38:	82 e0       	ldi	r24, 0x02	; 2
   11c3a:	90 e0       	ldi	r25, 0x00	; 0
   11c3c:	0e 94 b9 8d 	call	0x11b72	; 0x11b72 <Led_off>
	printf("Resultado corecto Y/N\n");
   11c40:	86 ef       	ldi	r24, 0xF6	; 246
   11c42:	90 e7       	ldi	r25, 0x70	; 112
   11c44:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	scanf("%s",&pause);
   11c48:	00 d0       	rcall	.+0      	; 0x11c4a <Test_perifericos+0xb2>
   11c4a:	00 d0       	rcall	.+0      	; 0x11c4c <Test_perifericos+0xb4>
   11c4c:	3c e0       	ldi	r19, 0x0C	; 12
   11c4e:	c3 2e       	mov	r12, r19
   11c50:	31 e7       	ldi	r19, 0x71	; 113
   11c52:	d3 2e       	mov	r13, r19
   11c54:	ad b7       	in	r26, 0x3d	; 61
   11c56:	be b7       	in	r27, 0x3e	; 62
   11c58:	12 96       	adiw	r26, 0x02	; 2
   11c5a:	dc 92       	st	X, r13
   11c5c:	ce 92       	st	-X, r12
   11c5e:	11 97       	sbiw	r26, 0x01	; 1
   11c60:	7e 01       	movw	r14, r28
   11c62:	08 94       	sec
   11c64:	e1 1c       	adc	r14, r1
   11c66:	f1 1c       	adc	r15, r1
   11c68:	14 96       	adiw	r26, 0x04	; 4
   11c6a:	fc 92       	st	X, r15
   11c6c:	ee 92       	st	-X, r14
   11c6e:	13 97       	sbiw	r26, 0x03	; 3
   11c70:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>

	
	//Prueba EEPROM Y RAM ATME1280	
	printf("Prueba de EEPROM interna del Atmega1280...\n");
   11c74:	0f 90       	pop	r0
   11c76:	0f 90       	pop	r0
   11c78:	0f 90       	pop	r0
   11c7a:	0f 90       	pop	r0
   11c7c:	8f e0       	ldi	r24, 0x0F	; 15
   11c7e:	91 e7       	ldi	r25, 0x71	; 113
   11c80:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	eeprom_read_block((void*)&RAM_var,(const void*)&ATmegaEEPROM_var,sizeof(PMDint32));
   11c84:	8e 01       	movw	r16, r28
   11c86:	0e 5f       	subi	r16, 0xFE	; 254
   11c88:	1f 4f       	sbci	r17, 0xFF	; 255
   11c8a:	c8 01       	movw	r24, r16
   11c8c:	6e e5       	ldi	r22, 0x5E	; 94
   11c8e:	71 e0       	ldi	r23, 0x01	; 1
   11c90:	44 e0       	ldi	r20, 0x04	; 4
   11c92:	50 e0       	ldi	r21, 0x00	; 0
   11c94:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
	printf("Leyando ATmegaEEPROM_var = %ld\n",RAM_var);
   11c98:	00 d0       	rcall	.+0      	; 0x11c9a <Test_perifericos+0x102>
   11c9a:	00 d0       	rcall	.+0      	; 0x11c9c <Test_perifericos+0x104>
   11c9c:	00 d0       	rcall	.+0      	; 0x11c9e <Test_perifericos+0x106>
   11c9e:	8a e3       	ldi	r24, 0x3A	; 58
   11ca0:	91 e7       	ldi	r25, 0x71	; 113
   11ca2:	ed b7       	in	r30, 0x3d	; 61
   11ca4:	fe b7       	in	r31, 0x3e	; 62
   11ca6:	92 83       	std	Z+2, r25	; 0x02
   11ca8:	81 83       	std	Z+1, r24	; 0x01
   11caa:	8a 81       	ldd	r24, Y+2	; 0x02
   11cac:	9b 81       	ldd	r25, Y+3	; 0x03
   11cae:	ac 81       	ldd	r26, Y+4	; 0x04
   11cb0:	bd 81       	ldd	r27, Y+5	; 0x05
   11cb2:	83 83       	std	Z+3, r24	; 0x03
   11cb4:	94 83       	std	Z+4, r25	; 0x04
   11cb6:	a5 83       	std	Z+5, r26	; 0x05
   11cb8:	b6 83       	std	Z+6, r27	; 0x06
   11cba:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Actualizando a 3032 ...\n");
   11cbe:	2d b7       	in	r18, 0x3d	; 61
   11cc0:	3e b7       	in	r19, 0x3e	; 62
   11cc2:	2a 5f       	subi	r18, 0xFA	; 250
   11cc4:	3f 4f       	sbci	r19, 0xFF	; 255
   11cc6:	0f b6       	in	r0, 0x3f	; 63
   11cc8:	f8 94       	cli
   11cca:	3e bf       	out	0x3e, r19	; 62
   11ccc:	0f be       	out	0x3f, r0	; 63
   11cce:	2d bf       	out	0x3d, r18	; 61
   11cd0:	8a e5       	ldi	r24, 0x5A	; 90
   11cd2:	91 e7       	ldi	r25, 0x71	; 113
   11cd4:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	RAM_var=3032;
   11cd8:	88 ed       	ldi	r24, 0xD8	; 216
   11cda:	9b e0       	ldi	r25, 0x0B	; 11
   11cdc:	a0 e0       	ldi	r26, 0x00	; 0
   11cde:	b0 e0       	ldi	r27, 0x00	; 0
   11ce0:	8a 83       	std	Y+2, r24	; 0x02
   11ce2:	9b 83       	std	Y+3, r25	; 0x03
   11ce4:	ac 83       	std	Y+4, r26	; 0x04
   11ce6:	bd 83       	std	Y+5, r27	; 0x05
	eeprom_write_block((const void*)&RAM_var,(void*)&ATmegaEEPROM_var,sizeof(PMDint32));
   11ce8:	c8 01       	movw	r24, r16
   11cea:	6e e5       	ldi	r22, 0x5E	; 94
   11cec:	71 e0       	ldi	r23, 0x01	; 1
   11cee:	44 e0       	ldi	r20, 0x04	; 4
   11cf0:	50 e0       	ldi	r21, 0x00	; 0
   11cf2:	0e 94 b1 a0 	call	0x14162	; 0x14162 <__eewr_block_m1280>
	eeprom_read_block((void*)&RAM_var,(const void*)&ATmegaEEPROM_var,sizeof(PMDint32));
   11cf6:	c8 01       	movw	r24, r16
   11cf8:	6e e5       	ldi	r22, 0x5E	; 94
   11cfa:	71 e0       	ldi	r23, 0x01	; 1
   11cfc:	44 e0       	ldi	r20, 0x04	; 4
   11cfe:	50 e0       	ldi	r21, 0x00	; 0
   11d00:	0e 94 a1 a0 	call	0x14142	; 0x14142 <__eerd_block_m1280>
	printf("Comprobando, ATmegaEEPROM_var = %ld\n",RAM_var);
   11d04:	00 d0       	rcall	.+0      	; 0x11d06 <Test_perifericos+0x16e>
   11d06:	00 d0       	rcall	.+0      	; 0x11d08 <Test_perifericos+0x170>
   11d08:	00 d0       	rcall	.+0      	; 0x11d0a <Test_perifericos+0x172>
   11d0a:	82 e7       	ldi	r24, 0x72	; 114
   11d0c:	91 e7       	ldi	r25, 0x71	; 113
   11d0e:	ad b7       	in	r26, 0x3d	; 61
   11d10:	be b7       	in	r27, 0x3e	; 62
   11d12:	12 96       	adiw	r26, 0x02	; 2
   11d14:	9c 93       	st	X, r25
   11d16:	8e 93       	st	-X, r24
   11d18:	11 97       	sbiw	r26, 0x01	; 1
   11d1a:	8a 81       	ldd	r24, Y+2	; 0x02
   11d1c:	9b 81       	ldd	r25, Y+3	; 0x03
   11d1e:	ac 81       	ldd	r26, Y+4	; 0x04
   11d20:	bd 81       	ldd	r27, Y+5	; 0x05
   11d22:	ed b7       	in	r30, 0x3d	; 61
   11d24:	fe b7       	in	r31, 0x3e	; 62
   11d26:	83 83       	std	Z+3, r24	; 0x03
   11d28:	94 83       	std	Z+4, r25	; 0x04
   11d2a:	a5 83       	std	Z+5, r26	; 0x05
   11d2c:	b6 83       	std	Z+6, r27	; 0x06
   11d2e:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	//Reiniciando..
	RAM_var=0;
   11d32:	1a 82       	std	Y+2, r1	; 0x02
   11d34:	1b 82       	std	Y+3, r1	; 0x03
   11d36:	1c 82       	std	Y+4, r1	; 0x04
   11d38:	1d 82       	std	Y+5, r1	; 0x05
	eeprom_write_block((const void*)&RAM_var,(void*)&ATmegaEEPROM_var,sizeof(PMDint32));
   11d3a:	2d b7       	in	r18, 0x3d	; 61
   11d3c:	3e b7       	in	r19, 0x3e	; 62
   11d3e:	2a 5f       	subi	r18, 0xFA	; 250
   11d40:	3f 4f       	sbci	r19, 0xFF	; 255
   11d42:	0f b6       	in	r0, 0x3f	; 63
   11d44:	f8 94       	cli
   11d46:	3e bf       	out	0x3e, r19	; 62
   11d48:	0f be       	out	0x3f, r0	; 63
   11d4a:	2d bf       	out	0x3d, r18	; 61
   11d4c:	c8 01       	movw	r24, r16
   11d4e:	6e e5       	ldi	r22, 0x5E	; 94
   11d50:	71 e0       	ldi	r23, 0x01	; 1
   11d52:	44 e0       	ldi	r20, 0x04	; 4
   11d54:	50 e0       	ldi	r21, 0x00	; 0
   11d56:	0e 94 b1 a0 	call	0x14162	; 0x14162 <__eewr_block_m1280>
	printf("Resultado corecto Y/N\n");
   11d5a:	86 ef       	ldi	r24, 0xF6	; 246
   11d5c:	90 e7       	ldi	r25, 0x70	; 112
   11d5e:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	scanf("%s",&pause);
   11d62:	00 d0       	rcall	.+0      	; 0x11d64 <Test_perifericos+0x1cc>
   11d64:	00 d0       	rcall	.+0      	; 0x11d66 <Test_perifericos+0x1ce>
   11d66:	ad b7       	in	r26, 0x3d	; 61
   11d68:	be b7       	in	r27, 0x3e	; 62
   11d6a:	12 96       	adiw	r26, 0x02	; 2
   11d6c:	dc 92       	st	X, r13
   11d6e:	ce 92       	st	-X, r12
   11d70:	11 97       	sbiw	r26, 0x01	; 1
   11d72:	14 96       	adiw	r26, 0x04	; 4
   11d74:	fc 92       	st	X, r15
   11d76:	ee 92       	st	-X, r14
   11d78:	13 97       	sbiw	r26, 0x03	; 3
   11d7a:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>

	//Prueba EEPROM Externa y Pose
	/*Obtengo las Poses de la eeprom, no se desea sobreescribir alguna poses existente*/
	Num_Poses=Get_Num_Poses();
   11d7e:	0f 90       	pop	r0
   11d80:	0f 90       	pop	r0
   11d82:	0f 90       	pop	r0
   11d84:	0f 90       	pop	r0
   11d86:	0e 94 8a 8a 	call	0x11514	; 0x11514 <Get_Num_Poses>
   11d8a:	8c 01       	movw	r16, r24
	addr=(int32)(Num_Poses)*sizeof(PoseRobot)+sizeof(int16); 
   11d8c:	b8 01       	movw	r22, r16
   11d8e:	88 27       	eor	r24, r24
   11d90:	77 fd       	sbrc	r23, 7
   11d92:	80 95       	com	r24
   11d94:	98 2f       	mov	r25, r24
   11d96:	27 e1       	ldi	r18, 0x17	; 23
   11d98:	30 e0       	ldi	r19, 0x00	; 0
   11d9a:	40 e0       	ldi	r20, 0x00	; 0
   11d9c:	50 e0       	ldi	r21, 0x00	; 0
   11d9e:	0e 94 3c 9c 	call	0x13878	; 0x13878 <__mulsi3>
   11da2:	22 e0       	ldi	r18, 0x02	; 2
   11da4:	c2 2e       	mov	r12, r18
   11da6:	d1 2c       	mov	r13, r1
   11da8:	e1 2c       	mov	r14, r1
   11daa:	f1 2c       	mov	r15, r1
   11dac:	c6 0e       	add	r12, r22
   11dae:	d7 1e       	adc	r13, r23
   11db0:	e8 1e       	adc	r14, r24
   11db2:	f9 1e       	adc	r15, r25
	/*Pasar al Segundo Banco de Memoria */
	if(Num_Poses > (5696/2))
   11db4:	01 52       	subi	r16, 0x21	; 33
   11db6:	1b 40       	sbci	r17, 0x0B	; 11
   11db8:	54 f0       	brlt	.+20     	; 0x11dce <Test_perifericos+0x236>
		addr=addr+7;
   11dba:	6b 01       	movw	r12, r22
   11dbc:	7c 01       	movw	r14, r24
   11dbe:	89 e0       	ldi	r24, 0x09	; 9
   11dc0:	90 e0       	ldi	r25, 0x00	; 0
   11dc2:	a0 e0       	ldi	r26, 0x00	; 0
   11dc4:	b0 e0       	ldi	r27, 0x00	; 0
   11dc6:	c8 0e       	add	r12, r24
   11dc8:	d9 1e       	adc	r13, r25
   11dca:	ea 1e       	adc	r14, r26
   11dcc:	fb 1e       	adc	r15, r27
	
	printf("Prueba de EEPROM externa, Leyendo Pose en la direccion %ld...\n",addr);
   11dce:	00 d0       	rcall	.+0      	; 0x11dd0 <Test_perifericos+0x238>
   11dd0:	00 d0       	rcall	.+0      	; 0x11dd2 <Test_perifericos+0x23a>
   11dd2:	00 d0       	rcall	.+0      	; 0x11dd4 <Test_perifericos+0x23c>
   11dd4:	87 e9       	ldi	r24, 0x97	; 151
   11dd6:	91 e7       	ldi	r25, 0x71	; 113
   11dd8:	ad b7       	in	r26, 0x3d	; 61
   11dda:	be b7       	in	r27, 0x3e	; 62
   11ddc:	12 96       	adiw	r26, 0x02	; 2
   11dde:	9c 93       	st	X, r25
   11de0:	8e 93       	st	-X, r24
   11de2:	11 97       	sbiw	r26, 0x01	; 1
   11de4:	ed b7       	in	r30, 0x3d	; 61
   11de6:	fe b7       	in	r31, 0x3e	; 62
   11de8:	c3 82       	std	Z+3, r12	; 0x03
   11dea:	d4 82       	std	Z+4, r13	; 0x04
   11dec:	e5 82       	std	Z+5, r14	; 0x05
   11dee:	f6 82       	std	Z+6, r15	; 0x06
   11df0:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	rv=ee24xx_read_bytes(addr,sizeof(PoseRobot),(uint8*)&Pose_test);
   11df4:	bc 2c       	mov	r11, r12
   11df6:	ad 2c       	mov	r10, r13
   11df8:	9e 2c       	mov	r9, r14
   11dfa:	8f 2c       	mov	r8, r15
   11dfc:	8e 01       	movw	r16, r28
   11dfe:	02 5f       	subi	r16, 0xF2	; 242
   11e00:	1f 4f       	sbci	r17, 0xFF	; 255
   11e02:	2d b7       	in	r18, 0x3d	; 61
   11e04:	3e b7       	in	r19, 0x3e	; 62
   11e06:	2a 5f       	subi	r18, 0xFA	; 250
   11e08:	3f 4f       	sbci	r19, 0xFF	; 255
   11e0a:	0f b6       	in	r0, 0x3f	; 63
   11e0c:	f8 94       	cli
   11e0e:	3e bf       	out	0x3e, r19	; 62
   11e10:	0f be       	out	0x3f, r0	; 63
   11e12:	2d bf       	out	0x3d, r18	; 61
   11e14:	b6 01       	movw	r22, r12
   11e16:	c7 01       	movw	r24, r14
   11e18:	47 e1       	ldi	r20, 0x17	; 23
   11e1a:	50 e0       	ldi	r21, 0x00	; 0
   11e1c:	98 01       	movw	r18, r16
   11e1e:	0e 94 38 88 	call	0x11070	; 0x11070 <ee24xx_read_bytes>
    printf("Pose_test->Pos_num = %d   \n",Pose_test.id);	
   11e22:	00 d0       	rcall	.+0      	; 0x11e24 <Test_perifericos+0x28c>
   11e24:	00 d0       	rcall	.+0      	; 0x11e26 <Test_perifericos+0x28e>
   11e26:	86 ed       	ldi	r24, 0xD6	; 214
   11e28:	91 e7       	ldi	r25, 0x71	; 113
   11e2a:	ad b7       	in	r26, 0x3d	; 61
   11e2c:	be b7       	in	r27, 0x3e	; 62
   11e2e:	12 96       	adiw	r26, 0x02	; 2
   11e30:	9c 93       	st	X, r25
   11e32:	8e 93       	st	-X, r24
   11e34:	11 97       	sbiw	r26, 0x01	; 1
   11e36:	8e 85       	ldd	r24, Y+14	; 0x0e
   11e38:	9f 85       	ldd	r25, Y+15	; 0x0f
   11e3a:	14 96       	adiw	r26, 0x04	; 4
   11e3c:	9c 93       	st	X, r25
   11e3e:	8e 93       	st	-X, r24
   11e40:	13 97       	sbiw	r26, 0x03	; 3
   11e42:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Waist = %ld  \n ",Pose_test.Pos_Waist);	
   11e46:	00 d0       	rcall	.+0      	; 0x11e48 <Test_perifericos+0x2b0>
   11e48:	82 ef       	ldi	r24, 0xF2	; 242
   11e4a:	91 e7       	ldi	r25, 0x71	; 113
   11e4c:	ed b7       	in	r30, 0x3d	; 61
   11e4e:	fe b7       	in	r31, 0x3e	; 62
   11e50:	92 83       	std	Z+2, r25	; 0x02
   11e52:	81 83       	std	Z+1, r24	; 0x01
   11e54:	88 89       	ldd	r24, Y+16	; 0x10
   11e56:	99 89       	ldd	r25, Y+17	; 0x11
   11e58:	aa 89       	ldd	r26, Y+18	; 0x12
   11e5a:	bb 89       	ldd	r27, Y+19	; 0x13
   11e5c:	83 83       	std	Z+3, r24	; 0x03
   11e5e:	94 83       	std	Z+4, r25	; 0x04
   11e60:	a5 83       	std	Z+5, r26	; 0x05
   11e62:	b6 83       	std	Z+6, r27	; 0x06
   11e64:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Shoulder = %ld  \n ",Pose_test.Pos_Shoulder);	
   11e68:	81 e1       	ldi	r24, 0x11	; 17
   11e6a:	92 e7       	ldi	r25, 0x72	; 114
   11e6c:	ad b7       	in	r26, 0x3d	; 61
   11e6e:	be b7       	in	r27, 0x3e	; 62
   11e70:	12 96       	adiw	r26, 0x02	; 2
   11e72:	9c 93       	st	X, r25
   11e74:	8e 93       	st	-X, r24
   11e76:	11 97       	sbiw	r26, 0x01	; 1
   11e78:	8c 89       	ldd	r24, Y+20	; 0x14
   11e7a:	9d 89       	ldd	r25, Y+21	; 0x15
   11e7c:	ae 89       	ldd	r26, Y+22	; 0x16
   11e7e:	bf 89       	ldd	r27, Y+23	; 0x17
   11e80:	ed b7       	in	r30, 0x3d	; 61
   11e82:	fe b7       	in	r31, 0x3e	; 62
   11e84:	83 83       	std	Z+3, r24	; 0x03
   11e86:	94 83       	std	Z+4, r25	; 0x04
   11e88:	a5 83       	std	Z+5, r26	; 0x05
   11e8a:	b6 83       	std	Z+6, r27	; 0x06
   11e8c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Elbow = %ld  \n ",Pose_test.Pos_Elbow);	
   11e90:	83 e3       	ldi	r24, 0x33	; 51
   11e92:	92 e7       	ldi	r25, 0x72	; 114
   11e94:	ad b7       	in	r26, 0x3d	; 61
   11e96:	be b7       	in	r27, 0x3e	; 62
   11e98:	12 96       	adiw	r26, 0x02	; 2
   11e9a:	9c 93       	st	X, r25
   11e9c:	8e 93       	st	-X, r24
   11e9e:	11 97       	sbiw	r26, 0x01	; 1
   11ea0:	88 8d       	ldd	r24, Y+24	; 0x18
   11ea2:	99 8d       	ldd	r25, Y+25	; 0x19
   11ea4:	aa 8d       	ldd	r26, Y+26	; 0x1a
   11ea6:	bb 8d       	ldd	r27, Y+27	; 0x1b
   11ea8:	ed b7       	in	r30, 0x3d	; 61
   11eaa:	fe b7       	in	r31, 0x3e	; 62
   11eac:	83 83       	std	Z+3, r24	; 0x03
   11eae:	94 83       	std	Z+4, r25	; 0x04
   11eb0:	a5 83       	std	Z+5, r26	; 0x05
   11eb2:	b6 83       	std	Z+6, r27	; 0x06
   11eb4:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Pitch = %ld  \n ",Pose_test.Pos_Pitch);	
   11eb8:	82 e5       	ldi	r24, 0x52	; 82
   11eba:	92 e7       	ldi	r25, 0x72	; 114
   11ebc:	ad b7       	in	r26, 0x3d	; 61
   11ebe:	be b7       	in	r27, 0x3e	; 62
   11ec0:	12 96       	adiw	r26, 0x02	; 2
   11ec2:	9c 93       	st	X, r25
   11ec4:	8e 93       	st	-X, r24
   11ec6:	11 97       	sbiw	r26, 0x01	; 1
   11ec8:	8c 8d       	ldd	r24, Y+28	; 0x1c
   11eca:	9d 8d       	ldd	r25, Y+29	; 0x1d
   11ecc:	ae 8d       	ldd	r26, Y+30	; 0x1e
   11ece:	bf 8d       	ldd	r27, Y+31	; 0x1f
   11ed0:	ed b7       	in	r30, 0x3d	; 61
   11ed2:	fe b7       	in	r31, 0x3e	; 62
   11ed4:	83 83       	std	Z+3, r24	; 0x03
   11ed6:	94 83       	std	Z+4, r25	; 0x04
   11ed8:	a5 83       	std	Z+5, r26	; 0x05
   11eda:	b6 83       	std	Z+6, r27	; 0x06
   11edc:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Roll= %ld  \n ",Pose_test.Pos_Roll);	
   11ee0:	81 e7       	ldi	r24, 0x71	; 113
   11ee2:	92 e7       	ldi	r25, 0x72	; 114
   11ee4:	ad b7       	in	r26, 0x3d	; 61
   11ee6:	be b7       	in	r27, 0x3e	; 62
   11ee8:	12 96       	adiw	r26, 0x02	; 2
   11eea:	9c 93       	st	X, r25
   11eec:	8e 93       	st	-X, r24
   11eee:	11 97       	sbiw	r26, 0x01	; 1
   11ef0:	88 a1       	ldd	r24, Y+32	; 0x20
   11ef2:	99 a1       	ldd	r25, Y+33	; 0x21
   11ef4:	aa a1       	ldd	r26, Y+34	; 0x22
   11ef6:	bb a1       	ldd	r27, Y+35	; 0x23
   11ef8:	ed b7       	in	r30, 0x3d	; 61
   11efa:	fe b7       	in	r31, 0x3e	; 62
   11efc:	83 83       	std	Z+3, r24	; 0x03
   11efe:	94 83       	std	Z+4, r25	; 0x04
   11f00:	a5 83       	std	Z+5, r26	; 0x05
   11f02:	b6 83       	std	Z+6, r27	; 0x06
   11f04:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	
	printf("Actualizando Pose_test a \n");
   11f08:	2d b7       	in	r18, 0x3d	; 61
   11f0a:	3e b7       	in	r19, 0x3e	; 62
   11f0c:	2a 5f       	subi	r18, 0xFA	; 250
   11f0e:	3f 4f       	sbci	r19, 0xFF	; 255
   11f10:	0f b6       	in	r0, 0x3f	; 63
   11f12:	f8 94       	cli
   11f14:	3e bf       	out	0x3e, r19	; 62
   11f16:	0f be       	out	0x3f, r0	; 63
   11f18:	2d bf       	out	0x3d, r18	; 61
   11f1a:	8e e8       	ldi	r24, 0x8E	; 142
   11f1c:	92 e7       	ldi	r25, 0x72	; 114
   11f1e:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	printf("Pose_test->Pos_num = 3   \n");	
   11f22:	88 ea       	ldi	r24, 0xA8	; 168
   11f24:	92 e7       	ldi	r25, 0x72	; 114
   11f26:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	printf("Pose_test->Pos_Waist = 5670 \n ");	
   11f2a:	00 d0       	rcall	.+0      	; 0x11f2c <Test_perifericos+0x394>
   11f2c:	82 ec       	ldi	r24, 0xC2	; 194
   11f2e:	92 e7       	ldi	r25, 0x72	; 114
   11f30:	ad b7       	in	r26, 0x3d	; 61
   11f32:	be b7       	in	r27, 0x3e	; 62
   11f34:	12 96       	adiw	r26, 0x02	; 2
   11f36:	9c 93       	st	X, r25
   11f38:	8e 93       	st	-X, r24
   11f3a:	11 97       	sbiw	r26, 0x01	; 1
   11f3c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Shoulder = 6000 \n ");	
   11f40:	81 ee       	ldi	r24, 0xE1	; 225
   11f42:	92 e7       	ldi	r25, 0x72	; 114
   11f44:	ed b7       	in	r30, 0x3d	; 61
   11f46:	fe b7       	in	r31, 0x3e	; 62
   11f48:	92 83       	std	Z+2, r25	; 0x02
   11f4a:	81 83       	std	Z+1, r24	; 0x01
   11f4c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Elbow = 2400 \n ");	
   11f50:	83 e0       	ldi	r24, 0x03	; 3
   11f52:	93 e7       	ldi	r25, 0x73	; 115
   11f54:	ad b7       	in	r26, 0x3d	; 61
   11f56:	be b7       	in	r27, 0x3e	; 62
   11f58:	12 96       	adiw	r26, 0x02	; 2
   11f5a:	9c 93       	st	X, r25
   11f5c:	8e 93       	st	-X, r24
   11f5e:	11 97       	sbiw	r26, 0x01	; 1
   11f60:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Pitch = 1000 \n ");	
   11f64:	82 e2       	ldi	r24, 0x22	; 34
   11f66:	93 e7       	ldi	r25, 0x73	; 115
   11f68:	ed b7       	in	r30, 0x3d	; 61
   11f6a:	fe b7       	in	r31, 0x3e	; 62
   11f6c:	92 83       	std	Z+2, r25	; 0x02
   11f6e:	81 83       	std	Z+1, r24	; 0x01
   11f70:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Roll= 10 \n ");	
   11f74:	81 e4       	ldi	r24, 0x41	; 65
   11f76:	93 e7       	ldi	r25, 0x73	; 115
   11f78:	ad b7       	in	r26, 0x3d	; 61
   11f7a:	be b7       	in	r27, 0x3e	; 62
   11f7c:	12 96       	adiw	r26, 0x02	; 2
   11f7e:	9c 93       	st	X, r25
   11f80:	8e 93       	st	-X, r24
   11f82:	11 97       	sbiw	r26, 0x01	; 1
   11f84:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	Pose_test.id= 3;	
   11f88:	83 e0       	ldi	r24, 0x03	; 3
   11f8a:	90 e0       	ldi	r25, 0x00	; 0
   11f8c:	9f 87       	std	Y+15, r25	; 0x0f
   11f8e:	8e 87       	std	Y+14, r24	; 0x0e
	Pose_test.Pos_Waist=5670;	
   11f90:	86 e2       	ldi	r24, 0x26	; 38
   11f92:	96 e1       	ldi	r25, 0x16	; 22
   11f94:	a0 e0       	ldi	r26, 0x00	; 0
   11f96:	b0 e0       	ldi	r27, 0x00	; 0
   11f98:	88 8b       	std	Y+16, r24	; 0x10
   11f9a:	99 8b       	std	Y+17, r25	; 0x11
   11f9c:	aa 8b       	std	Y+18, r26	; 0x12
   11f9e:	bb 8b       	std	Y+19, r27	; 0x13
	Pose_test.Pos_Shoulder=6000;	
   11fa0:	80 e7       	ldi	r24, 0x70	; 112
   11fa2:	97 e1       	ldi	r25, 0x17	; 23
   11fa4:	a0 e0       	ldi	r26, 0x00	; 0
   11fa6:	b0 e0       	ldi	r27, 0x00	; 0
   11fa8:	8c 8b       	std	Y+20, r24	; 0x14
   11faa:	9d 8b       	std	Y+21, r25	; 0x15
   11fac:	ae 8b       	std	Y+22, r26	; 0x16
   11fae:	bf 8b       	std	Y+23, r27	; 0x17
	Pose_test.Pos_Elbow=2400;	
   11fb0:	80 e6       	ldi	r24, 0x60	; 96
   11fb2:	99 e0       	ldi	r25, 0x09	; 9
   11fb4:	a0 e0       	ldi	r26, 0x00	; 0
   11fb6:	b0 e0       	ldi	r27, 0x00	; 0
   11fb8:	88 8f       	std	Y+24, r24	; 0x18
   11fba:	99 8f       	std	Y+25, r25	; 0x19
   11fbc:	aa 8f       	std	Y+26, r26	; 0x1a
   11fbe:	bb 8f       	std	Y+27, r27	; 0x1b
	Pose_test.Pos_Pitch=1000;	
   11fc0:	88 ee       	ldi	r24, 0xE8	; 232
   11fc2:	93 e0       	ldi	r25, 0x03	; 3
   11fc4:	a0 e0       	ldi	r26, 0x00	; 0
   11fc6:	b0 e0       	ldi	r27, 0x00	; 0
   11fc8:	8c 8f       	std	Y+28, r24	; 0x1c
   11fca:	9d 8f       	std	Y+29, r25	; 0x1d
   11fcc:	ae 8f       	std	Y+30, r26	; 0x1e
   11fce:	bf 8f       	std	Y+31, r27	; 0x1f
	Pose_test.Pos_Roll=10;
   11fd0:	8a e0       	ldi	r24, 0x0A	; 10
   11fd2:	90 e0       	ldi	r25, 0x00	; 0
   11fd4:	a0 e0       	ldi	r26, 0x00	; 0
   11fd6:	b0 e0       	ldi	r27, 0x00	; 0
   11fd8:	88 a3       	std	Y+32, r24	; 0x20
   11fda:	99 a3       	std	Y+33, r25	; 0x21
   11fdc:	aa a3       	std	Y+34, r26	; 0x22
   11fde:	bb a3       	std	Y+35, r27	; 0x23
	/* grabando pose*/
	rv=ee24xx_write_bytes(addr,sizeof(PoseRobot),(uint8 *)&Pose_test);			
   11fe0:	0f 90       	pop	r0
   11fe2:	0f 90       	pop	r0
   11fe4:	b6 01       	movw	r22, r12
   11fe6:	c7 01       	movw	r24, r14
   11fe8:	47 e1       	ldi	r20, 0x17	; 23
   11fea:	50 e0       	ldi	r21, 0x00	; 0
   11fec:	98 01       	movw	r18, r16
   11fee:	0e 94 0d 88 	call	0x1101a	; 0x1101a <ee24xx_write_bytes>
   11ff2:	9c 01       	movw	r18, r24
	if(rv)
   11ff4:	00 97       	sbiw	r24, 0x00	; 0
   11ff6:	81 f0       	breq	.+32     	; 0x12018 <Test_perifericos+0x480>
	{
		printf("Numero de datos grabados corectamente al grabar Num_Poses => %d\n",rv);
   11ff8:	00 d0       	rcall	.+0      	; 0x11ffa <Test_perifericos+0x462>
   11ffa:	00 d0       	rcall	.+0      	; 0x11ffc <Test_perifericos+0x464>
   11ffc:	8c e5       	ldi	r24, 0x5C	; 92
   11ffe:	93 e7       	ldi	r25, 0x73	; 115
   12000:	ed b7       	in	r30, 0x3d	; 61
   12002:	fe b7       	in	r31, 0x3e	; 62
   12004:	92 83       	std	Z+2, r25	; 0x02
   12006:	81 83       	std	Z+1, r24	; 0x01
   12008:	34 83       	std	Z+4, r19	; 0x04
   1200a:	23 83       	std	Z+3, r18	; 0x03
   1200c:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
   12010:	0f 90       	pop	r0
   12012:	0f 90       	pop	r0
   12014:	0f 90       	pop	r0
   12016:	0f 90       	pop	r0
		
	}		
	printf("Comprobando, Pose_test...\n");
   12018:	8d e9       	ldi	r24, 0x9D	; 157
   1201a:	93 e7       	ldi	r25, 0x73	; 115
   1201c:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	printf("Pose_test->Pos_num = %d   \n",Pose_test.id);	
   12020:	00 d0       	rcall	.+0      	; 0x12022 <Test_perifericos+0x48a>
   12022:	00 d0       	rcall	.+0      	; 0x12024 <Test_perifericos+0x48c>
   12024:	86 ed       	ldi	r24, 0xD6	; 214
   12026:	91 e7       	ldi	r25, 0x71	; 113
   12028:	ad b7       	in	r26, 0x3d	; 61
   1202a:	be b7       	in	r27, 0x3e	; 62
   1202c:	12 96       	adiw	r26, 0x02	; 2
   1202e:	9c 93       	st	X, r25
   12030:	8e 93       	st	-X, r24
   12032:	11 97       	sbiw	r26, 0x01	; 1
   12034:	8e 85       	ldd	r24, Y+14	; 0x0e
   12036:	9f 85       	ldd	r25, Y+15	; 0x0f
   12038:	14 96       	adiw	r26, 0x04	; 4
   1203a:	9c 93       	st	X, r25
   1203c:	8e 93       	st	-X, r24
   1203e:	13 97       	sbiw	r26, 0x03	; 3
   12040:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Waist = %ld  \n ",Pose_test.Pos_Waist);	
   12044:	00 d0       	rcall	.+0      	; 0x12046 <Test_perifericos+0x4ae>
   12046:	82 ef       	ldi	r24, 0xF2	; 242
   12048:	91 e7       	ldi	r25, 0x71	; 113
   1204a:	ed b7       	in	r30, 0x3d	; 61
   1204c:	fe b7       	in	r31, 0x3e	; 62
   1204e:	92 83       	std	Z+2, r25	; 0x02
   12050:	81 83       	std	Z+1, r24	; 0x01
   12052:	88 89       	ldd	r24, Y+16	; 0x10
   12054:	99 89       	ldd	r25, Y+17	; 0x11
   12056:	aa 89       	ldd	r26, Y+18	; 0x12
   12058:	bb 89       	ldd	r27, Y+19	; 0x13
   1205a:	83 83       	std	Z+3, r24	; 0x03
   1205c:	94 83       	std	Z+4, r25	; 0x04
   1205e:	a5 83       	std	Z+5, r26	; 0x05
   12060:	b6 83       	std	Z+6, r27	; 0x06
   12062:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Shoulder = %ld  \n ",Pose_test.Pos_Shoulder);	
   12066:	81 e1       	ldi	r24, 0x11	; 17
   12068:	92 e7       	ldi	r25, 0x72	; 114
   1206a:	ad b7       	in	r26, 0x3d	; 61
   1206c:	be b7       	in	r27, 0x3e	; 62
   1206e:	12 96       	adiw	r26, 0x02	; 2
   12070:	9c 93       	st	X, r25
   12072:	8e 93       	st	-X, r24
   12074:	11 97       	sbiw	r26, 0x01	; 1
   12076:	8c 89       	ldd	r24, Y+20	; 0x14
   12078:	9d 89       	ldd	r25, Y+21	; 0x15
   1207a:	ae 89       	ldd	r26, Y+22	; 0x16
   1207c:	bf 89       	ldd	r27, Y+23	; 0x17
   1207e:	ed b7       	in	r30, 0x3d	; 61
   12080:	fe b7       	in	r31, 0x3e	; 62
   12082:	83 83       	std	Z+3, r24	; 0x03
   12084:	94 83       	std	Z+4, r25	; 0x04
   12086:	a5 83       	std	Z+5, r26	; 0x05
   12088:	b6 83       	std	Z+6, r27	; 0x06
   1208a:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Elbow = %ld  \n ",Pose_test.Pos_Elbow);	
   1208e:	83 e3       	ldi	r24, 0x33	; 51
   12090:	92 e7       	ldi	r25, 0x72	; 114
   12092:	ad b7       	in	r26, 0x3d	; 61
   12094:	be b7       	in	r27, 0x3e	; 62
   12096:	12 96       	adiw	r26, 0x02	; 2
   12098:	9c 93       	st	X, r25
   1209a:	8e 93       	st	-X, r24
   1209c:	11 97       	sbiw	r26, 0x01	; 1
   1209e:	88 8d       	ldd	r24, Y+24	; 0x18
   120a0:	99 8d       	ldd	r25, Y+25	; 0x19
   120a2:	aa 8d       	ldd	r26, Y+26	; 0x1a
   120a4:	bb 8d       	ldd	r27, Y+27	; 0x1b
   120a6:	ed b7       	in	r30, 0x3d	; 61
   120a8:	fe b7       	in	r31, 0x3e	; 62
   120aa:	83 83       	std	Z+3, r24	; 0x03
   120ac:	94 83       	std	Z+4, r25	; 0x04
   120ae:	a5 83       	std	Z+5, r26	; 0x05
   120b0:	b6 83       	std	Z+6, r27	; 0x06
   120b2:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Pitch = %ld  \n ",Pose_test.Pos_Pitch);	
   120b6:	82 e5       	ldi	r24, 0x52	; 82
   120b8:	92 e7       	ldi	r25, 0x72	; 114
   120ba:	ad b7       	in	r26, 0x3d	; 61
   120bc:	be b7       	in	r27, 0x3e	; 62
   120be:	12 96       	adiw	r26, 0x02	; 2
   120c0:	9c 93       	st	X, r25
   120c2:	8e 93       	st	-X, r24
   120c4:	11 97       	sbiw	r26, 0x01	; 1
   120c6:	8c 8d       	ldd	r24, Y+28	; 0x1c
   120c8:	9d 8d       	ldd	r25, Y+29	; 0x1d
   120ca:	ae 8d       	ldd	r26, Y+30	; 0x1e
   120cc:	bf 8d       	ldd	r27, Y+31	; 0x1f
   120ce:	ed b7       	in	r30, 0x3d	; 61
   120d0:	fe b7       	in	r31, 0x3e	; 62
   120d2:	83 83       	std	Z+3, r24	; 0x03
   120d4:	94 83       	std	Z+4, r25	; 0x04
   120d6:	a5 83       	std	Z+5, r26	; 0x05
   120d8:	b6 83       	std	Z+6, r27	; 0x06
   120da:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	printf("Pose_test->Pos_Roll= %ld  \n ",Pose_test.Pos_Roll);	
   120de:	81 e7       	ldi	r24, 0x71	; 113
   120e0:	92 e7       	ldi	r25, 0x72	; 114
   120e2:	ad b7       	in	r26, 0x3d	; 61
   120e4:	be b7       	in	r27, 0x3e	; 62
   120e6:	12 96       	adiw	r26, 0x02	; 2
   120e8:	9c 93       	st	X, r25
   120ea:	8e 93       	st	-X, r24
   120ec:	11 97       	sbiw	r26, 0x01	; 1
   120ee:	88 a1       	ldd	r24, Y+32	; 0x20
   120f0:	99 a1       	ldd	r25, Y+33	; 0x21
   120f2:	aa a1       	ldd	r26, Y+34	; 0x22
   120f4:	bb a1       	ldd	r27, Y+35	; 0x23
   120f6:	ed b7       	in	r30, 0x3d	; 61
   120f8:	fe b7       	in	r31, 0x3e	; 62
   120fa:	83 83       	std	Z+3, r24	; 0x03
   120fc:	94 83       	std	Z+4, r25	; 0x04
   120fe:	a5 83       	std	Z+5, r26	; 0x05
   12100:	b6 83       	std	Z+6, r27	; 0x06
   12102:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	//Reiniciando
	Pose_test.id= 0;	
   12106:	1f 86       	std	Y+15, r1	; 0x0f
   12108:	1e 86       	std	Y+14, r1	; 0x0e
	Pose_test.Pos_Waist=0;	
   1210a:	18 8a       	std	Y+16, r1	; 0x10
   1210c:	19 8a       	std	Y+17, r1	; 0x11
   1210e:	1a 8a       	std	Y+18, r1	; 0x12
   12110:	1b 8a       	std	Y+19, r1	; 0x13
	Pose_test.Pos_Shoulder=0;	
   12112:	1c 8a       	std	Y+20, r1	; 0x14
   12114:	1d 8a       	std	Y+21, r1	; 0x15
   12116:	1e 8a       	std	Y+22, r1	; 0x16
   12118:	1f 8a       	std	Y+23, r1	; 0x17
	Pose_test.Pos_Elbow=0;	
   1211a:	18 8e       	std	Y+24, r1	; 0x18
   1211c:	19 8e       	std	Y+25, r1	; 0x19
   1211e:	1a 8e       	std	Y+26, r1	; 0x1a
   12120:	1b 8e       	std	Y+27, r1	; 0x1b
	Pose_test.Pos_Pitch=0;	
   12122:	1c 8e       	std	Y+28, r1	; 0x1c
   12124:	1d 8e       	std	Y+29, r1	; 0x1d
   12126:	1e 8e       	std	Y+30, r1	; 0x1e
   12128:	1f 8e       	std	Y+31, r1	; 0x1f
	Pose_test.Pos_Roll=0;
   1212a:	18 a2       	std	Y+32, r1	; 0x20
   1212c:	19 a2       	std	Y+33, r1	; 0x21
   1212e:	1a a2       	std	Y+34, r1	; 0x22
   12130:	1b a2       	std	Y+35, r1	; 0x23
	/* grabando pose*/
	rv=ee24xx_write_bytes(addr,sizeof(PoseRobot),(uint8 *)&Pose_test);	
   12132:	2d b7       	in	r18, 0x3d	; 61
   12134:	3e b7       	in	r19, 0x3e	; 62
   12136:	2a 5f       	subi	r18, 0xFA	; 250
   12138:	3f 4f       	sbci	r19, 0xFF	; 255
   1213a:	0f b6       	in	r0, 0x3f	; 63
   1213c:	f8 94       	cli
   1213e:	3e bf       	out	0x3e, r19	; 62
   12140:	0f be       	out	0x3f, r0	; 63
   12142:	2d bf       	out	0x3d, r18	; 61
   12144:	6b 2d       	mov	r22, r11
   12146:	7a 2d       	mov	r23, r10
   12148:	89 2d       	mov	r24, r9
   1214a:	98 2d       	mov	r25, r8
   1214c:	47 e1       	ldi	r20, 0x17	; 23
   1214e:	50 e0       	ldi	r21, 0x00	; 0
   12150:	98 01       	movw	r18, r16
   12152:	0e 94 0d 88 	call	0x1101a	; 0x1101a <ee24xx_write_bytes>
	printf("Resultado corecto Y/N\n");
   12156:	86 ef       	ldi	r24, 0xF6	; 246
   12158:	90 e7       	ldi	r25, 0x70	; 112
   1215a:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	scanf("%s",&pause);
   1215e:	00 d0       	rcall	.+0      	; 0x12160 <Test_perifericos+0x5c8>
   12160:	00 d0       	rcall	.+0      	; 0x12162 <Test_perifericos+0x5ca>
   12162:	8c e0       	ldi	r24, 0x0C	; 12
   12164:	91 e7       	ldi	r25, 0x71	; 113
   12166:	ad b7       	in	r26, 0x3d	; 61
   12168:	be b7       	in	r27, 0x3e	; 62
   1216a:	12 96       	adiw	r26, 0x02	; 2
   1216c:	9c 93       	st	X, r25
   1216e:	8e 93       	st	-X, r24
   12170:	11 97       	sbiw	r26, 0x01	; 1
   12172:	ce 01       	movw	r24, r28
   12174:	01 96       	adiw	r24, 0x01	; 1
   12176:	14 96       	adiw	r26, 0x04	; 4
   12178:	9c 93       	st	X, r25
   1217a:	8e 93       	st	-X, r24
   1217c:	13 97       	sbiw	r26, 0x03	; 3
   1217e:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>

	//Prueba RTC
	printf("Prueba RTC...\n");
   12182:	0f 90       	pop	r0
   12184:	0f 90       	pop	r0
   12186:	0f 90       	pop	r0
   12188:	0f 90       	pop	r0
   1218a:	87 eb       	ldi	r24, 0xB7	; 183
   1218c:	93 e7       	ldi	r25, 0x73	; 115
   1218e:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	Read_Fecha(&Test_Fecha);
   12192:	ce 01       	movw	r24, r28
   12194:	06 96       	adiw	r24, 0x06	; 6
   12196:	0e 94 b4 88 	call	0x11168	; 0x11168 <Read_Fecha>
	printf("Fecha = Hoy es el dia %s %x de %s de 200%x. \n",Dayname(Test_Fecha.dw),Test_Fecha.dt,Monthname(Test_Fecha.mo),Test_Fecha.yr);						
   1219a:	8c 85       	ldd	r24, Y+12	; 0x0c
   1219c:	0e 94 47 3b 	call	0x768e	; 0x768e <Dayname>
   121a0:	8c 01       	movw	r16, r24
   121a2:	f9 84       	ldd	r15, Y+9	; 0x09
   121a4:	8a 85       	ldd	r24, Y+10	; 0x0a
   121a6:	0e 94 70 3b 	call	0x76e0	; 0x76e0 <Monthname>
   121aa:	ed b7       	in	r30, 0x3d	; 61
   121ac:	fe b7       	in	r31, 0x3e	; 62
   121ae:	3a 97       	sbiw	r30, 0x0a	; 10
   121b0:	0f b6       	in	r0, 0x3f	; 63
   121b2:	f8 94       	cli
   121b4:	fe bf       	out	0x3e, r31	; 62
   121b6:	0f be       	out	0x3f, r0	; 63
   121b8:	ed bf       	out	0x3d, r30	; 61
   121ba:	31 96       	adiw	r30, 0x01	; 1
   121bc:	25 ec       	ldi	r18, 0xC5	; 197
   121be:	33 e7       	ldi	r19, 0x73	; 115
   121c0:	ad b7       	in	r26, 0x3d	; 61
   121c2:	be b7       	in	r27, 0x3e	; 62
   121c4:	12 96       	adiw	r26, 0x02	; 2
   121c6:	3c 93       	st	X, r19
   121c8:	2e 93       	st	-X, r18
   121ca:	11 97       	sbiw	r26, 0x01	; 1
   121cc:	13 83       	std	Z+3, r17	; 0x03
   121ce:	02 83       	std	Z+2, r16	; 0x02
   121d0:	f4 82       	std	Z+4, r15	; 0x04
   121d2:	15 82       	std	Z+5, r1	; 0x05
   121d4:	97 83       	std	Z+7, r25	; 0x07
   121d6:	86 83       	std	Z+6, r24	; 0x06
   121d8:	8b 85       	ldd	r24, Y+11	; 0x0b
   121da:	80 87       	std	Z+8, r24	; 0x08
   121dc:	11 86       	std	Z+9, r1	; 0x09
   121de:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
	if((Test_Fecha.hr & 0x20) != 0)			
   121e2:	88 85       	ldd	r24, Y+8	; 0x08
   121e4:	90 e0       	ldi	r25, 0x00	; 0
   121e6:	ed b7       	in	r30, 0x3d	; 61
   121e8:	fe b7       	in	r31, 0x3e	; 62
   121ea:	3a 96       	adiw	r30, 0x0a	; 10
   121ec:	0f b6       	in	r0, 0x3f	; 63
   121ee:	f8 94       	cli
   121f0:	fe bf       	out	0x3e, r31	; 62
   121f2:	0f be       	out	0x3f, r0	; 63
   121f4:	ed bf       	out	0x3d, r30	; 61
   121f6:	9c 01       	movw	r18, r24
   121f8:	2f 71       	andi	r18, 0x1F	; 31
   121fa:	30 70       	andi	r19, 0x00	; 0
   121fc:	85 ff       	sbrs	r24, 5
   121fe:	0e c0       	rjmp	.+28     	; 0x1221c <Test_perifericos+0x684>
		printf("Son las %x:%x:%x PM \n",(Test_Fecha.hr & 0x1F),Test_Fecha.mn,Test_Fecha.sc);
   12200:	8d b7       	in	r24, 0x3d	; 61
   12202:	9e b7       	in	r25, 0x3e	; 62
   12204:	08 97       	sbiw	r24, 0x08	; 8
   12206:	0f b6       	in	r0, 0x3f	; 63
   12208:	f8 94       	cli
   1220a:	9e bf       	out	0x3e, r25	; 62
   1220c:	0f be       	out	0x3f, r0	; 63
   1220e:	8d bf       	out	0x3d, r24	; 61
   12210:	ed b7       	in	r30, 0x3d	; 61
   12212:	fe b7       	in	r31, 0x3e	; 62
   12214:	31 96       	adiw	r30, 0x01	; 1
   12216:	83 ef       	ldi	r24, 0xF3	; 243
   12218:	93 e7       	ldi	r25, 0x73	; 115
   1221a:	0d c0       	rjmp	.+26     	; 0x12236 <Test_perifericos+0x69e>
	else 
		printf("Son las %x:%x:%x AM \n",(Test_Fecha.hr & 0x1F),Test_Fecha.mn,Test_Fecha.sc);
   1221c:	8d b7       	in	r24, 0x3d	; 61
   1221e:	9e b7       	in	r25, 0x3e	; 62
   12220:	08 97       	sbiw	r24, 0x08	; 8
   12222:	0f b6       	in	r0, 0x3f	; 63
   12224:	f8 94       	cli
   12226:	9e bf       	out	0x3e, r25	; 62
   12228:	0f be       	out	0x3f, r0	; 63
   1222a:	8d bf       	out	0x3d, r24	; 61
   1222c:	ed b7       	in	r30, 0x3d	; 61
   1222e:	fe b7       	in	r31, 0x3e	; 62
   12230:	31 96       	adiw	r30, 0x01	; 1
   12232:	89 e0       	ldi	r24, 0x09	; 9
   12234:	94 e7       	ldi	r25, 0x74	; 116
   12236:	ad b7       	in	r26, 0x3d	; 61
   12238:	be b7       	in	r27, 0x3e	; 62
   1223a:	12 96       	adiw	r26, 0x02	; 2
   1223c:	9c 93       	st	X, r25
   1223e:	8e 93       	st	-X, r24
   12240:	11 97       	sbiw	r26, 0x01	; 1
   12242:	33 83       	std	Z+3, r19	; 0x03
   12244:	22 83       	std	Z+2, r18	; 0x02
   12246:	8f 81       	ldd	r24, Y+7	; 0x07
   12248:	84 83       	std	Z+4, r24	; 0x04
   1224a:	15 82       	std	Z+5, r1	; 0x05
   1224c:	8e 81       	ldd	r24, Y+6	; 0x06
   1224e:	86 83       	std	Z+6, r24	; 0x06
   12250:	17 82       	std	Z+7, r1	; 0x07
   12252:	0e 94 c9 9f 	call	0x13f92	; 0x13f92 <printf>
   12256:	ed b7       	in	r30, 0x3d	; 61
   12258:	fe b7       	in	r31, 0x3e	; 62
   1225a:	38 96       	adiw	r30, 0x08	; 8
   1225c:	0f b6       	in	r0, 0x3f	; 63
   1225e:	f8 94       	cli
   12260:	fe bf       	out	0x3e, r31	; 62
   12262:	0f be       	out	0x3f, r0	; 63
   12264:	ed bf       	out	0x3d, r30	; 61
	printf("Resultado corecto Y/N\n");
   12266:	86 ef       	ldi	r24, 0xF6	; 246
   12268:	90 e7       	ldi	r25, 0x70	; 112
   1226a:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
	scanf("%s",&pause);
   1226e:	00 d0       	rcall	.+0      	; 0x12270 <Test_perifericos+0x6d8>
   12270:	00 d0       	rcall	.+0      	; 0x12272 <Test_perifericos+0x6da>
   12272:	8c e0       	ldi	r24, 0x0C	; 12
   12274:	91 e7       	ldi	r25, 0x71	; 113
   12276:	ad b7       	in	r26, 0x3d	; 61
   12278:	be b7       	in	r27, 0x3e	; 62
   1227a:	12 96       	adiw	r26, 0x02	; 2
   1227c:	9c 93       	st	X, r25
   1227e:	8e 93       	st	-X, r24
   12280:	11 97       	sbiw	r26, 0x01	; 1
   12282:	ce 01       	movw	r24, r28
   12284:	01 96       	adiw	r24, 0x01	; 1
   12286:	14 96       	adiw	r26, 0x04	; 4
   12288:	9c 93       	st	X, r25
   1228a:	8e 93       	st	-X, r24
   1228c:	13 97       	sbiw	r26, 0x03	; 3
   1228e:	0e 94 17 a0 	call	0x1402e	; 0x1402e <scanf>
   12292:	0f 90       	pop	r0
   12294:	0f 90       	pop	r0
   12296:	0f 90       	pop	r0
   12298:	0f 90       	pop	r0





}
   1229a:	a4 96       	adiw	r28, 0x24	; 36
   1229c:	0f b6       	in	r0, 0x3f	; 63
   1229e:	f8 94       	cli
   122a0:	de bf       	out	0x3e, r29	; 62
   122a2:	0f be       	out	0x3f, r0	; 63
   122a4:	cd bf       	out	0x3d, r28	; 61
   122a6:	cf 91       	pop	r28
   122a8:	df 91       	pop	r29
   122aa:	1f 91       	pop	r17
   122ac:	0f 91       	pop	r16
   122ae:	ff 90       	pop	r15
   122b0:	ef 90       	pop	r14
   122b2:	df 90       	pop	r13
   122b4:	cf 90       	pop	r12
   122b6:	bf 90       	pop	r11
   122b8:	af 90       	pop	r10
   122ba:	9f 90       	pop	r9
   122bc:	8f 90       	pop	r8
   122be:	08 95       	ret

000122c0 <openGripper>:
 
 
	// Los switch son normalmente Abierto. (Se necesitan de alguna resistencia de pullup para estos)
    
    //abriendo el gripper
	GRIPPERCTL |= _BV(DER);  		//1
   122c0:	88 9a       	sbi	0x11, 0	; 17
    GRIPPERCTL &= ~(_BV(IZQ)); 	//0
   122c2:	89 98       	cbi	0x11, 1	; 17
	pin=PINF;
   122c4:	8f b1       	in	r24, 0x0f	; 15
   122c6:	2a e0       	ldi	r18, 0x0A	; 10
   122c8:	30 e0       	ldi	r19, 0x00	; 0
   122ca:	48 ec       	ldi	r20, 0xC8	; 200
   122cc:	50 e0       	ldi	r21, 0x00	; 0
	printf("openGripper=> Abriendo Gripper= %#X\n",pin);
	#endif	
	for(;;) 
	{
		
		if (!bit_is_set(PINF,FINDER))
   122ce:	7e 9b       	sbis	0x0f, 6	; 15
   122d0:	0c c0       	rjmp	.+24     	; 0x122ea <openGripper+0x2a>
			return;
		}
		
		else// not ready 
		{ 
			timer--;
   122d2:	21 50       	subi	r18, 0x01	; 1
   122d4:	30 40       	sbci	r19, 0x00	; 0
   122d6:	88 ee       	ldi	r24, 0xE8	; 232
   122d8:	93 e0       	ldi	r25, 0x03	; 3
   122da:	fa 01       	movw	r30, r20
   122dc:	31 97       	sbiw	r30, 0x01	; 1
   122de:	f1 f7       	brne	.-4      	; 0x122dc <openGripper+0x1c>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   122e0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   122e2:	d9 f7       	brne	.-10     	; 0x122da <openGripper+0x1a>
			_delay_ms(100);
	
			if(timer == 0) 
   122e4:	21 15       	cp	r18, r1
   122e6:	31 05       	cpc	r19, r1
   122e8:	91 f7       	brne	.-28     	; 0x122ce <openGripper+0xe>
			{
				//Parar Motor
				//Mantener el motor apadado
				PORTF     |=	_BV(DER) | _BV(IZQ);
   122ea:	81 b3       	in	r24, 0x11	; 17
   122ec:	83 60       	ori	r24, 0x03	; 3
   122ee:	81 bb       	out	0x11, r24	; 17
   122f0:	08 95       	ret

000122f2 <openGripper_time>:
		}
  	} // for EVER      
} // openGripper

void openGripper_time(int tiempo) 
{
   122f2:	ac 01       	movw	r20, r24
	uint8 i;
	
	//se abre el gripper por un periodo de tiempo
	
	GRIPPERCTL |= _BV(DER);  		//1
   122f4:	88 9a       	sbi	0x11, 0	; 17
    GRIPPERCTL &= ~(_BV(IZQ)); 	//0
   122f6:	89 98       	cbi	0x11, 1	; 17
   122f8:	20 e0       	ldi	r18, 0x00	; 0
   122fa:	68 ec       	ldi	r22, 0xC8	; 200
   122fc:	70 e0       	ldi	r23, 0x00	; 0
   122fe:	08 c0       	rjmp	.+16     	; 0x12310 <openGripper_time+0x1e>
	
	

	for (i = 0; i < tiempo; i++)   
   12300:	88 ee       	ldi	r24, 0xE8	; 232
   12302:	93 e0       	ldi	r25, 0x03	; 3
   12304:	fb 01       	movw	r30, r22
   12306:	31 97       	sbiw	r30, 0x01	; 1
   12308:	f1 f7       	brne	.-4      	; 0x12306 <openGripper_time+0x14>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   1230a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   1230c:	d9 f7       	brne	.-10     	; 0x12304 <openGripper_time+0x12>
   1230e:	2f 5f       	subi	r18, 0xFF	; 255
   12310:	82 2f       	mov	r24, r18
   12312:	90 e0       	ldi	r25, 0x00	; 0
   12314:	84 17       	cp	r24, r20
   12316:	95 07       	cpc	r25, r21
   12318:	9c f3       	brlt	.-26     	; 0x12300 <openGripper_time+0xe>
			_delay_ms(100);
	
	//Parar Motor
	//Mantener el motor apadado
	PORTF     |=	_BV(DER) | _BV(IZQ);
   1231a:	81 b3       	in	r24, 0x11	; 17
   1231c:	83 60       	ori	r24, 0x03	; 3
   1231e:	81 bb       	out	0x11, r24	; 17

	
	
	
    
} // openGripper_time
   12320:	08 95       	ret

00012322 <closeGripper>:
	
	
	
	
	//cerrando el gripper
	GRIPPERCTL &= ~(_BV(DER));  	//0
   12322:	88 98       	cbi	0x11, 0	; 17
    GRIPPERCTL |= _BV(IZQ); 	//1
   12324:	89 9a       	sbi	0x11, 1	; 17
	pin=PINF;
   12326:	8f b1       	in	r24, 0x0f	; 15
   12328:	2a e0       	ldi	r18, 0x0A	; 10
   1232a:	30 e0       	ldi	r19, 0x00	; 0
   1232c:	48 ec       	ldi	r20, 0xC8	; 200
   1232e:	50 e0       	ldi	r21, 0x00	; 0
	
		
	for(;;) 
	{
		
		if (!bit_is_set(PINF,FINIZQ))
   12330:	7f 9b       	sbis	0x0f, 7	; 15
   12332:	0c c0       	rjmp	.+24     	; 0x1234c <closeGripper+0x2a>
			return;
		}
		
		else// not ready 
		{ 
			timer--;
   12334:	21 50       	subi	r18, 0x01	; 1
   12336:	30 40       	sbci	r19, 0x00	; 0
   12338:	88 ee       	ldi	r24, 0xE8	; 232
   1233a:	93 e0       	ldi	r25, 0x03	; 3
   1233c:	fa 01       	movw	r30, r20
   1233e:	31 97       	sbiw	r30, 0x01	; 1
   12340:	f1 f7       	brne	.-4      	; 0x1233e <closeGripper+0x1c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   12342:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   12344:	d9 f7       	brne	.-10     	; 0x1233c <closeGripper+0x1a>
			_delay_ms(100);
			
			if(timer == 0) 
   12346:	21 15       	cp	r18, r1
   12348:	31 05       	cpc	r19, r1
   1234a:	91 f7       	brne	.-28     	; 0x12330 <closeGripper+0xe>
			{
				//Parar Motor
				//Mantener el motor apadado
				PORTF     |=	_BV(DER) | _BV(IZQ);
   1234c:	81 b3       	in	r24, 0x11	; 17
   1234e:	83 60       	ori	r24, 0x03	; 3
   12350:	81 bb       	out	0x11, r24	; 17
   12352:	08 95       	ret

00012354 <closeGripper_time>:

} // closeGripper


void closeGripper_time(int tiempo) 
{
   12354:	ac 01       	movw	r20, r24
	uint8 i;
	
	//se cierra el gripper por un periodo de tiempo
	
	GRIPPERCTL &= ~(_BV(DER));  	//0
   12356:	88 98       	cbi	0x11, 0	; 17
    GRIPPERCTL |= _BV(IZQ); 		//1
   12358:	89 9a       	sbi	0x11, 1	; 17
   1235a:	20 e0       	ldi	r18, 0x00	; 0
   1235c:	68 ec       	ldi	r22, 0xC8	; 200
   1235e:	70 e0       	ldi	r23, 0x00	; 0
   12360:	08 c0       	rjmp	.+16     	; 0x12372 <closeGripper_time+0x1e>
	
	

	for (i = 0; i < tiempo; i++)   
   12362:	88 ee       	ldi	r24, 0xE8	; 232
   12364:	93 e0       	ldi	r25, 0x03	; 3
   12366:	fb 01       	movw	r30, r22
   12368:	31 97       	sbiw	r30, 0x01	; 1
   1236a:	f1 f7       	brne	.-4      	; 0x12368 <closeGripper_time+0x14>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   1236c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   1236e:	d9 f7       	brne	.-10     	; 0x12366 <closeGripper_time+0x12>
   12370:	2f 5f       	subi	r18, 0xFF	; 255
   12372:	82 2f       	mov	r24, r18
   12374:	90 e0       	ldi	r25, 0x00	; 0
   12376:	84 17       	cp	r24, r20
   12378:	95 07       	cpc	r25, r21
   1237a:	9c f3       	brlt	.-26     	; 0x12362 <closeGripper_time+0xe>
			_delay_ms(100);
	
	//Parar Motor
	//Mantener el motor apadado
	PORTF     |=	_BV(DER) | _BV(IZQ);
   1237c:	81 b3       	in	r24, 0x11	; 17
   1237e:	83 60       	ori	r24, 0x03	; 3
   12380:	81 bb       	out	0x11, r24	; 17
	
	
	
	
    
} // closeGripper_time
   12382:	08 95       	ret

00012384 <Estado_gripper>:

//Si el gripper tiene CARGA una pieza, la funcion retorn abierto asi el gripper este cerrado.......
int8 Estado_gripper(void)
{

	if (!bit_is_set(PINF,FINIZQ))
   12384:	7f 99       	sbic	0x0f, 7	; 15
   12386:	06 c0       	rjmp	.+12     	; 0x12394 <Estado_gripper+0x10>
	{
		//#ifdef DEBUGGRIPPER
		printf("Estado_gripper=> El Gripper esta cerrado. \n");
   12388:	8f e1       	ldi	r24, 0x1F	; 31
   1238a:	94 e7       	ldi	r25, 0x74	; 116
   1238c:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
   12390:	81 e0       	ldi	r24, 0x01	; 1
   12392:	08 95       	ret
		//#endif
		return 1;
	}
	if (!bit_is_set(PINF,FINDER))
   12394:	7e 99       	sbic	0x0f, 6	; 15
   12396:	06 c0       	rjmp	.+12     	; 0x123a4 <Estado_gripper+0x20>
	{
		//#ifdef DEBUGGRIPPER
		printf("Estado_gripper=> El Gripper esta abierto. \n");
   12398:	8a e4       	ldi	r24, 0x4A	; 74
   1239a:	94 e7       	ldi	r25, 0x74	; 116
   1239c:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
   123a0:	80 e0       	ldi	r24, 0x00	; 0
   123a2:	08 95       	ret
		//#endif		
		return 0;
	}
	//#ifdef DEBUGGRIPPER
	printf("Estado_gripper=> El Gripper no esta definido. \n");
   123a4:	85 e7       	ldi	r24, 0x75	; 117
   123a6:	94 e7       	ldi	r25, 0x74	; 116
   123a8:	0e 94 e2 9f 	call	0x13fc4	; 0x13fc4 <puts>
   123ac:	8f ef       	ldi	r24, 0xFF	; 255
	//#endif
	return -1;


   123ae:	08 95       	ret

000123b0 <vfprintf>:
   123b0:	2f 92       	push	r2
   123b2:	3f 92       	push	r3
   123b4:	4f 92       	push	r4
   123b6:	5f 92       	push	r5
   123b8:	6f 92       	push	r6
   123ba:	7f 92       	push	r7
   123bc:	8f 92       	push	r8
   123be:	9f 92       	push	r9
   123c0:	af 92       	push	r10
   123c2:	bf 92       	push	r11
   123c4:	cf 92       	push	r12
   123c6:	df 92       	push	r13
   123c8:	ef 92       	push	r14
   123ca:	ff 92       	push	r15
   123cc:	0f 93       	push	r16
   123ce:	1f 93       	push	r17
   123d0:	df 93       	push	r29
   123d2:	cf 93       	push	r28
   123d4:	cd b7       	in	r28, 0x3d	; 61
   123d6:	de b7       	in	r29, 0x3e	; 62
   123d8:	61 97       	sbiw	r28, 0x11	; 17
   123da:	0f b6       	in	r0, 0x3f	; 63
   123dc:	f8 94       	cli
   123de:	de bf       	out	0x3e, r29	; 62
   123e0:	0f be       	out	0x3f, r0	; 63
   123e2:	cd bf       	out	0x3d, r28	; 61
   123e4:	3c 01       	movw	r6, r24
   123e6:	7f 87       	std	Y+15, r23	; 0x0f
   123e8:	6e 87       	std	Y+14, r22	; 0x0e
   123ea:	6a 01       	movw	r12, r20
   123ec:	fc 01       	movw	r30, r24
   123ee:	17 82       	std	Z+7, r1	; 0x07
   123f0:	16 82       	std	Z+6, r1	; 0x06
   123f2:	83 81       	ldd	r24, Z+3	; 0x03
   123f4:	81 fd       	sbrc	r24, 1
   123f6:	03 c0       	rjmp	.+6      	; 0x123fe <vfprintf+0x4e>
   123f8:	6f ef       	ldi	r22, 0xFF	; 255
   123fa:	7f ef       	ldi	r23, 0xFF	; 255
   123fc:	6f c3       	rjmp	.+1758   	; 0x12adc <vfprintf+0x72c>
   123fe:	9e 01       	movw	r18, r28
   12400:	2f 5f       	subi	r18, 0xFF	; 255
   12402:	3f 4f       	sbci	r19, 0xFF	; 255
   12404:	39 8b       	std	Y+17, r19	; 0x11
   12406:	28 8b       	std	Y+16, r18	; 0x10
   12408:	f3 01       	movw	r30, r6
   1240a:	23 81       	ldd	r18, Z+3	; 0x03
   1240c:	ee 85       	ldd	r30, Y+14	; 0x0e
   1240e:	ff 85       	ldd	r31, Y+15	; 0x0f
   12410:	23 fd       	sbrc	r18, 3
   12412:	85 91       	lpm	r24, Z+
   12414:	23 ff       	sbrs	r18, 3
   12416:	81 91       	ld	r24, Z+
   12418:	ff 87       	std	Y+15, r31	; 0x0f
   1241a:	ee 87       	std	Y+14, r30	; 0x0e
   1241c:	88 23       	and	r24, r24
   1241e:	09 f4       	brne	.+2      	; 0x12422 <vfprintf+0x72>
   12420:	5a c3       	rjmp	.+1716   	; 0x12ad6 <vfprintf+0x726>
   12422:	85 32       	cpi	r24, 0x25	; 37
   12424:	51 f4       	brne	.+20     	; 0x1243a <vfprintf+0x8a>
   12426:	ee 85       	ldd	r30, Y+14	; 0x0e
   12428:	ff 85       	ldd	r31, Y+15	; 0x0f
   1242a:	23 fd       	sbrc	r18, 3
   1242c:	85 91       	lpm	r24, Z+
   1242e:	23 ff       	sbrs	r18, 3
   12430:	81 91       	ld	r24, Z+
   12432:	ff 87       	std	Y+15, r31	; 0x0f
   12434:	ee 87       	std	Y+14, r30	; 0x0e
   12436:	85 32       	cpi	r24, 0x25	; 37
   12438:	29 f4       	brne	.+10     	; 0x12444 <vfprintf+0x94>
   1243a:	90 e0       	ldi	r25, 0x00	; 0
   1243c:	b3 01       	movw	r22, r6
   1243e:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   12442:	e2 cf       	rjmp	.-60     	; 0x12408 <vfprintf+0x58>
   12444:	98 2f       	mov	r25, r24
   12446:	10 e0       	ldi	r17, 0x00	; 0
   12448:	88 24       	eor	r8, r8
   1244a:	99 24       	eor	r9, r9
   1244c:	10 32       	cpi	r17, 0x20	; 32
   1244e:	b0 f4       	brcc	.+44     	; 0x1247c <vfprintf+0xcc>
   12450:	9b 32       	cpi	r25, 0x2B	; 43
   12452:	69 f0       	breq	.+26     	; 0x1246e <vfprintf+0xbe>
   12454:	9c 32       	cpi	r25, 0x2C	; 44
   12456:	28 f4       	brcc	.+10     	; 0x12462 <vfprintf+0xb2>
   12458:	90 32       	cpi	r25, 0x20	; 32
   1245a:	51 f0       	breq	.+20     	; 0x12470 <vfprintf+0xc0>
   1245c:	93 32       	cpi	r25, 0x23	; 35
   1245e:	71 f4       	brne	.+28     	; 0x1247c <vfprintf+0xcc>
   12460:	0b c0       	rjmp	.+22     	; 0x12478 <vfprintf+0xc8>
   12462:	9d 32       	cpi	r25, 0x2D	; 45
   12464:	39 f0       	breq	.+14     	; 0x12474 <vfprintf+0xc4>
   12466:	90 33       	cpi	r25, 0x30	; 48
   12468:	49 f4       	brne	.+18     	; 0x1247c <vfprintf+0xcc>
   1246a:	11 60       	ori	r17, 0x01	; 1
   1246c:	28 c0       	rjmp	.+80     	; 0x124be <vfprintf+0x10e>
   1246e:	12 60       	ori	r17, 0x02	; 2
   12470:	14 60       	ori	r17, 0x04	; 4
   12472:	25 c0       	rjmp	.+74     	; 0x124be <vfprintf+0x10e>
   12474:	18 60       	ori	r17, 0x08	; 8
   12476:	23 c0       	rjmp	.+70     	; 0x124be <vfprintf+0x10e>
   12478:	10 61       	ori	r17, 0x10	; 16
   1247a:	21 c0       	rjmp	.+66     	; 0x124be <vfprintf+0x10e>
   1247c:	17 fd       	sbrc	r17, 7
   1247e:	2a c0       	rjmp	.+84     	; 0x124d4 <vfprintf+0x124>
   12480:	89 2f       	mov	r24, r25
   12482:	80 53       	subi	r24, 0x30	; 48
   12484:	8a 30       	cpi	r24, 0x0A	; 10
   12486:	78 f4       	brcc	.+30     	; 0x124a6 <vfprintf+0xf6>
   12488:	16 ff       	sbrs	r17, 6
   1248a:	06 c0       	rjmp	.+12     	; 0x12498 <vfprintf+0xe8>
   1248c:	fa e0       	ldi	r31, 0x0A	; 10
   1248e:	9f 9e       	mul	r9, r31
   12490:	90 2c       	mov	r9, r0
   12492:	11 24       	eor	r1, r1
   12494:	98 0e       	add	r9, r24
   12496:	13 c0       	rjmp	.+38     	; 0x124be <vfprintf+0x10e>
   12498:	3a e0       	ldi	r19, 0x0A	; 10
   1249a:	83 9e       	mul	r8, r19
   1249c:	80 2c       	mov	r8, r0
   1249e:	11 24       	eor	r1, r1
   124a0:	88 0e       	add	r8, r24
   124a2:	10 62       	ori	r17, 0x20	; 32
   124a4:	0c c0       	rjmp	.+24     	; 0x124be <vfprintf+0x10e>
   124a6:	9e 32       	cpi	r25, 0x2E	; 46
   124a8:	21 f4       	brne	.+8      	; 0x124b2 <vfprintf+0x102>
   124aa:	16 fd       	sbrc	r17, 6
   124ac:	14 c3       	rjmp	.+1576   	; 0x12ad6 <vfprintf+0x726>
   124ae:	10 64       	ori	r17, 0x40	; 64
   124b0:	06 c0       	rjmp	.+12     	; 0x124be <vfprintf+0x10e>
   124b2:	9c 36       	cpi	r25, 0x6C	; 108
   124b4:	11 f4       	brne	.+4      	; 0x124ba <vfprintf+0x10a>
   124b6:	10 68       	ori	r17, 0x80	; 128
   124b8:	02 c0       	rjmp	.+4      	; 0x124be <vfprintf+0x10e>
   124ba:	98 36       	cpi	r25, 0x68	; 104
   124bc:	59 f4       	brne	.+22     	; 0x124d4 <vfprintf+0x124>
   124be:	ee 85       	ldd	r30, Y+14	; 0x0e
   124c0:	ff 85       	ldd	r31, Y+15	; 0x0f
   124c2:	23 fd       	sbrc	r18, 3
   124c4:	95 91       	lpm	r25, Z+
   124c6:	23 ff       	sbrs	r18, 3
   124c8:	91 91       	ld	r25, Z+
   124ca:	ff 87       	std	Y+15, r31	; 0x0f
   124cc:	ee 87       	std	Y+14, r30	; 0x0e
   124ce:	99 23       	and	r25, r25
   124d0:	09 f0       	breq	.+2      	; 0x124d4 <vfprintf+0x124>
   124d2:	bc cf       	rjmp	.-136    	; 0x1244c <vfprintf+0x9c>
   124d4:	89 2f       	mov	r24, r25
   124d6:	85 54       	subi	r24, 0x45	; 69
   124d8:	83 30       	cpi	r24, 0x03	; 3
   124da:	20 f4       	brcc	.+8      	; 0x124e4 <vfprintf+0x134>
   124dc:	81 2f       	mov	r24, r17
   124de:	80 61       	ori	r24, 0x10	; 16
   124e0:	90 5e       	subi	r25, 0xE0	; 224
   124e2:	07 c0       	rjmp	.+14     	; 0x124f2 <vfprintf+0x142>
   124e4:	89 2f       	mov	r24, r25
   124e6:	85 56       	subi	r24, 0x65	; 101
   124e8:	83 30       	cpi	r24, 0x03	; 3
   124ea:	08 f0       	brcs	.+2      	; 0x124ee <vfprintf+0x13e>
   124ec:	9f c1       	rjmp	.+830    	; 0x1282c <vfprintf+0x47c>
   124ee:	81 2f       	mov	r24, r17
   124f0:	8f 7e       	andi	r24, 0xEF	; 239
   124f2:	86 fd       	sbrc	r24, 6
   124f4:	02 c0       	rjmp	.+4      	; 0x124fa <vfprintf+0x14a>
   124f6:	76 e0       	ldi	r23, 0x06	; 6
   124f8:	97 2e       	mov	r9, r23
   124fa:	6f e3       	ldi	r22, 0x3F	; 63
   124fc:	f6 2e       	mov	r15, r22
   124fe:	f8 22       	and	r15, r24
   12500:	95 36       	cpi	r25, 0x65	; 101
   12502:	19 f4       	brne	.+6      	; 0x1250a <vfprintf+0x15a>
   12504:	f0 e4       	ldi	r31, 0x40	; 64
   12506:	ff 2a       	or	r15, r31
   12508:	07 c0       	rjmp	.+14     	; 0x12518 <vfprintf+0x168>
   1250a:	96 36       	cpi	r25, 0x66	; 102
   1250c:	19 f4       	brne	.+6      	; 0x12514 <vfprintf+0x164>
   1250e:	20 e8       	ldi	r18, 0x80	; 128
   12510:	f2 2a       	or	r15, r18
   12512:	02 c0       	rjmp	.+4      	; 0x12518 <vfprintf+0x168>
   12514:	91 10       	cpse	r9, r1
   12516:	9a 94       	dec	r9
   12518:	f7 fe       	sbrs	r15, 7
   1251a:	0a c0       	rjmp	.+20     	; 0x12530 <vfprintf+0x180>
   1251c:	3b e3       	ldi	r19, 0x3B	; 59
   1251e:	39 15       	cp	r19, r9
   12520:	18 f4       	brcc	.+6      	; 0x12528 <vfprintf+0x178>
   12522:	5c e3       	ldi	r21, 0x3C	; 60
   12524:	b5 2e       	mov	r11, r21
   12526:	02 c0       	rjmp	.+4      	; 0x1252c <vfprintf+0x17c>
   12528:	b9 2c       	mov	r11, r9
   1252a:	b3 94       	inc	r11
   1252c:	27 e0       	ldi	r18, 0x07	; 7
   1252e:	09 c0       	rjmp	.+18     	; 0x12542 <vfprintf+0x192>
   12530:	47 e0       	ldi	r20, 0x07	; 7
   12532:	49 15       	cp	r20, r9
   12534:	20 f4       	brcc	.+8      	; 0x1253e <vfprintf+0x18e>
   12536:	bb 24       	eor	r11, r11
   12538:	47 e0       	ldi	r20, 0x07	; 7
   1253a:	94 2e       	mov	r9, r20
   1253c:	f7 cf       	rjmp	.-18     	; 0x1252c <vfprintf+0x17c>
   1253e:	29 2d       	mov	r18, r9
   12540:	bb 24       	eor	r11, r11
   12542:	c6 01       	movw	r24, r12
   12544:	04 96       	adiw	r24, 0x04	; 4
   12546:	9d 87       	std	Y+13, r25	; 0x0d
   12548:	8c 87       	std	Y+12, r24	; 0x0c
   1254a:	f6 01       	movw	r30, r12
   1254c:	60 81       	ld	r22, Z
   1254e:	71 81       	ldd	r23, Z+1	; 0x01
   12550:	82 81       	ldd	r24, Z+2	; 0x02
   12552:	93 81       	ldd	r25, Z+3	; 0x03
   12554:	ae 01       	movw	r20, r28
   12556:	4f 5f       	subi	r20, 0xFF	; 255
   12558:	5f 4f       	sbci	r21, 0xFF	; 255
   1255a:	0b 2d       	mov	r16, r11
   1255c:	0e 94 d0 9d 	call	0x13ba0	; 0x13ba0 <__ftoa_engine>
   12560:	6c 01       	movw	r12, r24
   12562:	09 81       	ldd	r16, Y+1	; 0x01
   12564:	20 2e       	mov	r2, r16
   12566:	33 24       	eor	r3, r3
   12568:	00 ff       	sbrs	r16, 0
   1256a:	04 c0       	rjmp	.+8      	; 0x12574 <vfprintf+0x1c4>
   1256c:	03 fd       	sbrc	r16, 3
   1256e:	02 c0       	rjmp	.+4      	; 0x12574 <vfprintf+0x1c4>
   12570:	1d e2       	ldi	r17, 0x2D	; 45
   12572:	09 c0       	rjmp	.+18     	; 0x12586 <vfprintf+0x1d6>
   12574:	f1 fe       	sbrs	r15, 1
   12576:	02 c0       	rjmp	.+4      	; 0x1257c <vfprintf+0x1cc>
   12578:	1b e2       	ldi	r17, 0x2B	; 43
   1257a:	05 c0       	rjmp	.+10     	; 0x12586 <vfprintf+0x1d6>
   1257c:	f2 fc       	sbrc	r15, 2
   1257e:	02 c0       	rjmp	.+4      	; 0x12584 <vfprintf+0x1d4>
   12580:	10 e0       	ldi	r17, 0x00	; 0
   12582:	01 c0       	rjmp	.+2      	; 0x12586 <vfprintf+0x1d6>
   12584:	10 e2       	ldi	r17, 0x20	; 32
   12586:	c1 01       	movw	r24, r2
   12588:	8c 70       	andi	r24, 0x0C	; 12
   1258a:	90 70       	andi	r25, 0x00	; 0
   1258c:	89 2b       	or	r24, r25
   1258e:	b9 f1       	breq	.+110    	; 0x125fe <vfprintf+0x24e>
   12590:	11 23       	and	r17, r17
   12592:	11 f4       	brne	.+4      	; 0x12598 <vfprintf+0x1e8>
   12594:	83 e0       	ldi	r24, 0x03	; 3
   12596:	01 c0       	rjmp	.+2      	; 0x1259a <vfprintf+0x1ea>
   12598:	84 e0       	ldi	r24, 0x04	; 4
   1259a:	88 15       	cp	r24, r8
   1259c:	10 f0       	brcs	.+4      	; 0x125a2 <vfprintf+0x1f2>
   1259e:	88 24       	eor	r8, r8
   125a0:	0a c0       	rjmp	.+20     	; 0x125b6 <vfprintf+0x206>
   125a2:	88 1a       	sub	r8, r24
   125a4:	f3 fc       	sbrc	r15, 3
   125a6:	07 c0       	rjmp	.+14     	; 0x125b6 <vfprintf+0x206>
   125a8:	80 e2       	ldi	r24, 0x20	; 32
   125aa:	90 e0       	ldi	r25, 0x00	; 0
   125ac:	b3 01       	movw	r22, r6
   125ae:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   125b2:	8a 94       	dec	r8
   125b4:	c9 f7       	brne	.-14     	; 0x125a8 <vfprintf+0x1f8>
   125b6:	11 23       	and	r17, r17
   125b8:	29 f0       	breq	.+10     	; 0x125c4 <vfprintf+0x214>
   125ba:	81 2f       	mov	r24, r17
   125bc:	90 e0       	ldi	r25, 0x00	; 0
   125be:	b3 01       	movw	r22, r6
   125c0:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   125c4:	23 fe       	sbrs	r2, 3
   125c6:	03 c0       	rjmp	.+6      	; 0x125ce <vfprintf+0x21e>
   125c8:	05 e6       	ldi	r16, 0x65	; 101
   125ca:	18 e1       	ldi	r17, 0x18	; 24
   125cc:	0e c0       	rjmp	.+28     	; 0x125ea <vfprintf+0x23a>
   125ce:	09 e6       	ldi	r16, 0x69	; 105
   125d0:	18 e1       	ldi	r17, 0x18	; 24
   125d2:	0b c0       	rjmp	.+22     	; 0x125ea <vfprintf+0x23a>
   125d4:	e1 14       	cp	r14, r1
   125d6:	f1 04       	cpc	r15, r1
   125d8:	09 f0       	breq	.+2      	; 0x125dc <vfprintf+0x22c>
   125da:	80 52       	subi	r24, 0x20	; 32
   125dc:	90 e0       	ldi	r25, 0x00	; 0
   125de:	b3 01       	movw	r22, r6
   125e0:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   125e4:	0f 5f       	subi	r16, 0xFF	; 255
   125e6:	1f 4f       	sbci	r17, 0xFF	; 255
   125e8:	05 c0       	rjmp	.+10     	; 0x125f4 <vfprintf+0x244>
   125ea:	ef 2c       	mov	r14, r15
   125ec:	ff 24       	eor	r15, r15
   125ee:	f0 e1       	ldi	r31, 0x10	; 16
   125f0:	ef 22       	and	r14, r31
   125f2:	ff 24       	eor	r15, r15
   125f4:	f8 01       	movw	r30, r16
   125f6:	84 91       	lpm	r24, Z+
   125f8:	88 23       	and	r24, r24
   125fa:	61 f7       	brne	.-40     	; 0x125d4 <vfprintf+0x224>
   125fc:	14 c1       	rjmp	.+552    	; 0x12826 <vfprintf+0x476>
   125fe:	f7 fe       	sbrs	r15, 7
   12600:	12 c0       	rjmp	.+36     	; 0x12626 <vfprintf+0x276>
   12602:	bc 0c       	add	r11, r12
   12604:	24 fe       	sbrs	r2, 4
   12606:	04 c0       	rjmp	.+8      	; 0x12610 <vfprintf+0x260>
   12608:	8a 81       	ldd	r24, Y+2	; 0x02
   1260a:	81 33       	cpi	r24, 0x31	; 49
   1260c:	09 f4       	brne	.+2      	; 0x12610 <vfprintf+0x260>
   1260e:	ba 94       	dec	r11
   12610:	1b 14       	cp	r1, r11
   12612:	1c f0       	brlt	.+6      	; 0x1261a <vfprintf+0x26a>
   12614:	bb 24       	eor	r11, r11
   12616:	b3 94       	inc	r11
   12618:	2d c0       	rjmp	.+90     	; 0x12674 <vfprintf+0x2c4>
   1261a:	f8 e0       	ldi	r31, 0x08	; 8
   1261c:	fb 15       	cp	r31, r11
   1261e:	50 f5       	brcc	.+84     	; 0x12674 <vfprintf+0x2c4>
   12620:	38 e0       	ldi	r19, 0x08	; 8
   12622:	b3 2e       	mov	r11, r19
   12624:	27 c0       	rjmp	.+78     	; 0x12674 <vfprintf+0x2c4>
   12626:	f6 fc       	sbrc	r15, 6
   12628:	25 c0       	rjmp	.+74     	; 0x12674 <vfprintf+0x2c4>
   1262a:	89 2d       	mov	r24, r9
   1262c:	90 e0       	ldi	r25, 0x00	; 0
   1262e:	8c 15       	cp	r24, r12
   12630:	9d 05       	cpc	r25, r13
   12632:	4c f0       	brlt	.+18     	; 0x12646 <vfprintf+0x296>
   12634:	2c ef       	ldi	r18, 0xFC	; 252
   12636:	c2 16       	cp	r12, r18
   12638:	2f ef       	ldi	r18, 0xFF	; 255
   1263a:	d2 06       	cpc	r13, r18
   1263c:	24 f0       	brlt	.+8      	; 0x12646 <vfprintf+0x296>
   1263e:	30 e8       	ldi	r19, 0x80	; 128
   12640:	f3 2a       	or	r15, r19
   12642:	01 c0       	rjmp	.+2      	; 0x12646 <vfprintf+0x296>
   12644:	9a 94       	dec	r9
   12646:	99 20       	and	r9, r9
   12648:	49 f0       	breq	.+18     	; 0x1265c <vfprintf+0x2ac>
   1264a:	e2 e0       	ldi	r30, 0x02	; 2
   1264c:	f0 e0       	ldi	r31, 0x00	; 0
   1264e:	ec 0f       	add	r30, r28
   12650:	fd 1f       	adc	r31, r29
   12652:	e9 0d       	add	r30, r9
   12654:	f1 1d       	adc	r31, r1
   12656:	80 81       	ld	r24, Z
   12658:	80 33       	cpi	r24, 0x30	; 48
   1265a:	a1 f3       	breq	.-24     	; 0x12644 <vfprintf+0x294>
   1265c:	f7 fe       	sbrs	r15, 7
   1265e:	0a c0       	rjmp	.+20     	; 0x12674 <vfprintf+0x2c4>
   12660:	b9 2c       	mov	r11, r9
   12662:	b3 94       	inc	r11
   12664:	89 2d       	mov	r24, r9
   12666:	90 e0       	ldi	r25, 0x00	; 0
   12668:	c8 16       	cp	r12, r24
   1266a:	d9 06       	cpc	r13, r25
   1266c:	14 f0       	brlt	.+4      	; 0x12672 <vfprintf+0x2c2>
   1266e:	99 24       	eor	r9, r9
   12670:	01 c0       	rjmp	.+2      	; 0x12674 <vfprintf+0x2c4>
   12672:	9c 18       	sub	r9, r12
   12674:	f7 fc       	sbrc	r15, 7
   12676:	03 c0       	rjmp	.+6      	; 0x1267e <vfprintf+0x2ce>
   12678:	25 e0       	ldi	r18, 0x05	; 5
   1267a:	30 e0       	ldi	r19, 0x00	; 0
   1267c:	09 c0       	rjmp	.+18     	; 0x12690 <vfprintf+0x2e0>
   1267e:	1c 14       	cp	r1, r12
   12680:	1d 04       	cpc	r1, r13
   12682:	1c f0       	brlt	.+6      	; 0x1268a <vfprintf+0x2da>
   12684:	21 e0       	ldi	r18, 0x01	; 1
   12686:	30 e0       	ldi	r19, 0x00	; 0
   12688:	03 c0       	rjmp	.+6      	; 0x12690 <vfprintf+0x2e0>
   1268a:	96 01       	movw	r18, r12
   1268c:	2f 5f       	subi	r18, 0xFF	; 255
   1268e:	3f 4f       	sbci	r19, 0xFF	; 255
   12690:	11 23       	and	r17, r17
   12692:	11 f0       	breq	.+4      	; 0x12698 <vfprintf+0x2e8>
   12694:	2f 5f       	subi	r18, 0xFF	; 255
   12696:	3f 4f       	sbci	r19, 0xFF	; 255
   12698:	99 20       	and	r9, r9
   1269a:	29 f0       	breq	.+10     	; 0x126a6 <vfprintf+0x2f6>
   1269c:	89 2d       	mov	r24, r9
   1269e:	90 e0       	ldi	r25, 0x00	; 0
   126a0:	01 96       	adiw	r24, 0x01	; 1
   126a2:	28 0f       	add	r18, r24
   126a4:	39 1f       	adc	r19, r25
   126a6:	88 2d       	mov	r24, r8
   126a8:	90 e0       	ldi	r25, 0x00	; 0
   126aa:	28 17       	cp	r18, r24
   126ac:	39 07       	cpc	r19, r25
   126ae:	14 f0       	brlt	.+4      	; 0x126b4 <vfprintf+0x304>
   126b0:	88 24       	eor	r8, r8
   126b2:	01 c0       	rjmp	.+2      	; 0x126b6 <vfprintf+0x306>
   126b4:	82 1a       	sub	r8, r18
   126b6:	4f 2c       	mov	r4, r15
   126b8:	55 24       	eor	r5, r5
   126ba:	c2 01       	movw	r24, r4
   126bc:	89 70       	andi	r24, 0x09	; 9
   126be:	90 70       	andi	r25, 0x00	; 0
   126c0:	89 2b       	or	r24, r25
   126c2:	39 f0       	breq	.+14     	; 0x126d2 <vfprintf+0x322>
   126c4:	08 c0       	rjmp	.+16     	; 0x126d6 <vfprintf+0x326>
   126c6:	80 e2       	ldi	r24, 0x20	; 32
   126c8:	90 e0       	ldi	r25, 0x00	; 0
   126ca:	b3 01       	movw	r22, r6
   126cc:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   126d0:	8a 94       	dec	r8
   126d2:	88 20       	and	r8, r8
   126d4:	c1 f7       	brne	.-16     	; 0x126c6 <vfprintf+0x316>
   126d6:	11 23       	and	r17, r17
   126d8:	29 f0       	breq	.+10     	; 0x126e4 <vfprintf+0x334>
   126da:	81 2f       	mov	r24, r17
   126dc:	90 e0       	ldi	r25, 0x00	; 0
   126de:	b3 01       	movw	r22, r6
   126e0:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   126e4:	43 fe       	sbrs	r4, 3
   126e6:	07 c0       	rjmp	.+14     	; 0x126f6 <vfprintf+0x346>
   126e8:	08 c0       	rjmp	.+16     	; 0x126fa <vfprintf+0x34a>
   126ea:	80 e3       	ldi	r24, 0x30	; 48
   126ec:	90 e0       	ldi	r25, 0x00	; 0
   126ee:	b3 01       	movw	r22, r6
   126f0:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   126f4:	8a 94       	dec	r8
   126f6:	88 20       	and	r8, r8
   126f8:	c1 f7       	brne	.-16     	; 0x126ea <vfprintf+0x33a>
   126fa:	f7 fe       	sbrs	r15, 7
   126fc:	46 c0       	rjmp	.+140    	; 0x1278a <vfprintf+0x3da>
   126fe:	86 01       	movw	r16, r12
   12700:	d7 fe       	sbrs	r13, 7
   12702:	02 c0       	rjmp	.+4      	; 0x12708 <vfprintf+0x358>
   12704:	00 e0       	ldi	r16, 0x00	; 0
   12706:	10 e0       	ldi	r17, 0x00	; 0
   12708:	76 01       	movw	r14, r12
   1270a:	08 94       	sec
   1270c:	e1 1c       	adc	r14, r1
   1270e:	f1 1c       	adc	r15, r1
   12710:	e0 1a       	sub	r14, r16
   12712:	f1 0a       	sbc	r15, r17
   12714:	41 e0       	ldi	r20, 0x01	; 1
   12716:	50 e0       	ldi	r21, 0x00	; 0
   12718:	4c 0f       	add	r20, r28
   1271a:	5d 1f       	adc	r21, r29
   1271c:	e4 0e       	add	r14, r20
   1271e:	f5 1e       	adc	r15, r21
   12720:	26 01       	movw	r4, r12
   12722:	4b 18       	sub	r4, r11
   12724:	51 08       	sbc	r5, r1
   12726:	89 2d       	mov	r24, r9
   12728:	90 e0       	ldi	r25, 0x00	; 0
   1272a:	aa 24       	eor	r10, r10
   1272c:	bb 24       	eor	r11, r11
   1272e:	a8 1a       	sub	r10, r24
   12730:	b9 0a       	sbc	r11, r25
   12732:	5f ef       	ldi	r21, 0xFF	; 255
   12734:	0f 3f       	cpi	r16, 0xFF	; 255
   12736:	15 07       	cpc	r17, r21
   12738:	29 f4       	brne	.+10     	; 0x12744 <vfprintf+0x394>
   1273a:	8e e2       	ldi	r24, 0x2E	; 46
   1273c:	90 e0       	ldi	r25, 0x00	; 0
   1273e:	b3 01       	movw	r22, r6
   12740:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   12744:	c0 16       	cp	r12, r16
   12746:	d1 06       	cpc	r13, r17
   12748:	34 f0       	brlt	.+12     	; 0x12756 <vfprintf+0x3a6>
   1274a:	40 16       	cp	r4, r16
   1274c:	51 06       	cpc	r5, r17
   1274e:	1c f4       	brge	.+6      	; 0x12756 <vfprintf+0x3a6>
   12750:	f7 01       	movw	r30, r14
   12752:	80 81       	ld	r24, Z
   12754:	01 c0       	rjmp	.+2      	; 0x12758 <vfprintf+0x3a8>
   12756:	80 e3       	ldi	r24, 0x30	; 48
   12758:	01 50       	subi	r16, 0x01	; 1
   1275a:	10 40       	sbci	r17, 0x00	; 0
   1275c:	08 94       	sec
   1275e:	e1 1c       	adc	r14, r1
   12760:	f1 1c       	adc	r15, r1
   12762:	0a 15       	cp	r16, r10
   12764:	1b 05       	cpc	r17, r11
   12766:	2c f0       	brlt	.+10     	; 0x12772 <vfprintf+0x3c2>
   12768:	90 e0       	ldi	r25, 0x00	; 0
   1276a:	b3 01       	movw	r22, r6
   1276c:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   12770:	e0 cf       	rjmp	.-64     	; 0x12732 <vfprintf+0x382>
   12772:	0c 15       	cp	r16, r12
   12774:	1d 05       	cpc	r17, r13
   12776:	39 f4       	brne	.+14     	; 0x12786 <vfprintf+0x3d6>
   12778:	9a 81       	ldd	r25, Y+2	; 0x02
   1277a:	96 33       	cpi	r25, 0x36	; 54
   1277c:	18 f4       	brcc	.+6      	; 0x12784 <vfprintf+0x3d4>
   1277e:	95 33       	cpi	r25, 0x35	; 53
   12780:	11 f4       	brne	.+4      	; 0x12786 <vfprintf+0x3d6>
   12782:	24 fe       	sbrs	r2, 4
   12784:	81 e3       	ldi	r24, 0x31	; 49
   12786:	90 e0       	ldi	r25, 0x00	; 0
   12788:	4b c0       	rjmp	.+150    	; 0x12820 <vfprintf+0x470>
   1278a:	8a 81       	ldd	r24, Y+2	; 0x02
   1278c:	81 33       	cpi	r24, 0x31	; 49
   1278e:	09 f0       	breq	.+2      	; 0x12792 <vfprintf+0x3e2>
   12790:	0f 7e       	andi	r16, 0xEF	; 239
   12792:	90 e0       	ldi	r25, 0x00	; 0
   12794:	b3 01       	movw	r22, r6
   12796:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   1279a:	99 20       	and	r9, r9
   1279c:	a1 f0       	breq	.+40     	; 0x127c6 <vfprintf+0x416>
   1279e:	8e e2       	ldi	r24, 0x2E	; 46
   127a0:	90 e0       	ldi	r25, 0x00	; 0
   127a2:	b3 01       	movw	r22, r6
   127a4:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   127a8:	12 e0       	ldi	r17, 0x02	; 2
   127aa:	e1 e0       	ldi	r30, 0x01	; 1
   127ac:	f0 e0       	ldi	r31, 0x00	; 0
   127ae:	ec 0f       	add	r30, r28
   127b0:	fd 1f       	adc	r31, r29
   127b2:	e1 0f       	add	r30, r17
   127b4:	f1 1d       	adc	r31, r1
   127b6:	1f 5f       	subi	r17, 0xFF	; 255
   127b8:	80 81       	ld	r24, Z
   127ba:	90 e0       	ldi	r25, 0x00	; 0
   127bc:	b3 01       	movw	r22, r6
   127be:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   127c2:	9a 94       	dec	r9
   127c4:	91 f7       	brne	.-28     	; 0x127aa <vfprintf+0x3fa>
   127c6:	44 fc       	sbrc	r4, 4
   127c8:	03 c0       	rjmp	.+6      	; 0x127d0 <vfprintf+0x420>
   127ca:	85 e6       	ldi	r24, 0x65	; 101
   127cc:	90 e0       	ldi	r25, 0x00	; 0
   127ce:	02 c0       	rjmp	.+4      	; 0x127d4 <vfprintf+0x424>
   127d0:	85 e4       	ldi	r24, 0x45	; 69
   127d2:	90 e0       	ldi	r25, 0x00	; 0
   127d4:	b3 01       	movw	r22, r6
   127d6:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   127da:	d7 fc       	sbrc	r13, 7
   127dc:	05 c0       	rjmp	.+10     	; 0x127e8 <vfprintf+0x438>
   127de:	c1 14       	cp	r12, r1
   127e0:	d1 04       	cpc	r13, r1
   127e2:	41 f4       	brne	.+16     	; 0x127f4 <vfprintf+0x444>
   127e4:	04 ff       	sbrs	r16, 4
   127e6:	06 c0       	rjmp	.+12     	; 0x127f4 <vfprintf+0x444>
   127e8:	d0 94       	com	r13
   127ea:	c1 94       	neg	r12
   127ec:	d1 08       	sbc	r13, r1
   127ee:	d3 94       	inc	r13
   127f0:	8d e2       	ldi	r24, 0x2D	; 45
   127f2:	01 c0       	rjmp	.+2      	; 0x127f6 <vfprintf+0x446>
   127f4:	8b e2       	ldi	r24, 0x2B	; 43
   127f6:	90 e0       	ldi	r25, 0x00	; 0
   127f8:	b3 01       	movw	r22, r6
   127fa:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   127fe:	80 e3       	ldi	r24, 0x30	; 48
   12800:	05 c0       	rjmp	.+10     	; 0x1280c <vfprintf+0x45c>
   12802:	8f 5f       	subi	r24, 0xFF	; 255
   12804:	26 ef       	ldi	r18, 0xF6	; 246
   12806:	3f ef       	ldi	r19, 0xFF	; 255
   12808:	c2 0e       	add	r12, r18
   1280a:	d3 1e       	adc	r13, r19
   1280c:	3a e0       	ldi	r19, 0x0A	; 10
   1280e:	c3 16       	cp	r12, r19
   12810:	d1 04       	cpc	r13, r1
   12812:	bc f7       	brge	.-18     	; 0x12802 <vfprintf+0x452>
   12814:	90 e0       	ldi	r25, 0x00	; 0
   12816:	b3 01       	movw	r22, r6
   12818:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   1281c:	c6 01       	movw	r24, r12
   1281e:	c0 96       	adiw	r24, 0x30	; 48
   12820:	b3 01       	movw	r22, r6
   12822:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   12826:	cc 84       	ldd	r12, Y+12	; 0x0c
   12828:	dd 84       	ldd	r13, Y+13	; 0x0d
   1282a:	52 c1       	rjmp	.+676    	; 0x12ad0 <vfprintf+0x720>
   1282c:	93 36       	cpi	r25, 0x63	; 99
   1282e:	31 f0       	breq	.+12     	; 0x1283c <vfprintf+0x48c>
   12830:	93 37       	cpi	r25, 0x73	; 115
   12832:	99 f0       	breq	.+38     	; 0x1285a <vfprintf+0x4aa>
   12834:	93 35       	cpi	r25, 0x53	; 83
   12836:	09 f0       	breq	.+2      	; 0x1283a <vfprintf+0x48a>
   12838:	59 c0       	rjmp	.+178    	; 0x128ec <vfprintf+0x53c>
   1283a:	23 c0       	rjmp	.+70     	; 0x12882 <vfprintf+0x4d2>
   1283c:	f6 01       	movw	r30, r12
   1283e:	80 81       	ld	r24, Z
   12840:	89 83       	std	Y+1, r24	; 0x01
   12842:	5e 01       	movw	r10, r28
   12844:	08 94       	sec
   12846:	a1 1c       	adc	r10, r1
   12848:	b1 1c       	adc	r11, r1
   1284a:	22 e0       	ldi	r18, 0x02	; 2
   1284c:	30 e0       	ldi	r19, 0x00	; 0
   1284e:	c2 0e       	add	r12, r18
   12850:	d3 1e       	adc	r13, r19
   12852:	21 e0       	ldi	r18, 0x01	; 1
   12854:	e2 2e       	mov	r14, r18
   12856:	f1 2c       	mov	r15, r1
   12858:	12 c0       	rjmp	.+36     	; 0x1287e <vfprintf+0x4ce>
   1285a:	f6 01       	movw	r30, r12
   1285c:	a0 80       	ld	r10, Z
   1285e:	b1 80       	ldd	r11, Z+1	; 0x01
   12860:	16 fd       	sbrc	r17, 6
   12862:	03 c0       	rjmp	.+6      	; 0x1286a <vfprintf+0x4ba>
   12864:	6f ef       	ldi	r22, 0xFF	; 255
   12866:	7f ef       	ldi	r23, 0xFF	; 255
   12868:	02 c0       	rjmp	.+4      	; 0x1286e <vfprintf+0x4be>
   1286a:	69 2d       	mov	r22, r9
   1286c:	70 e0       	ldi	r23, 0x00	; 0
   1286e:	22 e0       	ldi	r18, 0x02	; 2
   12870:	30 e0       	ldi	r19, 0x00	; 0
   12872:	c2 0e       	add	r12, r18
   12874:	d3 1e       	adc	r13, r19
   12876:	c5 01       	movw	r24, r10
   12878:	0e 94 d5 9e 	call	0x13daa	; 0x13daa <strnlen>
   1287c:	7c 01       	movw	r14, r24
   1287e:	1f 77       	andi	r17, 0x7F	; 127
   12880:	13 c0       	rjmp	.+38     	; 0x128a8 <vfprintf+0x4f8>
   12882:	f6 01       	movw	r30, r12
   12884:	a0 80       	ld	r10, Z
   12886:	b1 80       	ldd	r11, Z+1	; 0x01
   12888:	16 fd       	sbrc	r17, 6
   1288a:	03 c0       	rjmp	.+6      	; 0x12892 <vfprintf+0x4e2>
   1288c:	6f ef       	ldi	r22, 0xFF	; 255
   1288e:	7f ef       	ldi	r23, 0xFF	; 255
   12890:	02 c0       	rjmp	.+4      	; 0x12896 <vfprintf+0x4e6>
   12892:	69 2d       	mov	r22, r9
   12894:	70 e0       	ldi	r23, 0x00	; 0
   12896:	22 e0       	ldi	r18, 0x02	; 2
   12898:	30 e0       	ldi	r19, 0x00	; 0
   1289a:	c2 0e       	add	r12, r18
   1289c:	d3 1e       	adc	r13, r19
   1289e:	c5 01       	movw	r24, r10
   128a0:	0e 94 c3 9e 	call	0x13d86	; 0x13d86 <strnlen_P>
   128a4:	7c 01       	movw	r14, r24
   128a6:	10 68       	ori	r17, 0x80	; 128
   128a8:	13 ff       	sbrs	r17, 3
   128aa:	07 c0       	rjmp	.+14     	; 0x128ba <vfprintf+0x50a>
   128ac:	1b c0       	rjmp	.+54     	; 0x128e4 <vfprintf+0x534>
   128ae:	80 e2       	ldi	r24, 0x20	; 32
   128b0:	90 e0       	ldi	r25, 0x00	; 0
   128b2:	b3 01       	movw	r22, r6
   128b4:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   128b8:	8a 94       	dec	r8
   128ba:	88 2d       	mov	r24, r8
   128bc:	90 e0       	ldi	r25, 0x00	; 0
   128be:	e8 16       	cp	r14, r24
   128c0:	f9 06       	cpc	r15, r25
   128c2:	a8 f3       	brcs	.-22     	; 0x128ae <vfprintf+0x4fe>
   128c4:	0f c0       	rjmp	.+30     	; 0x128e4 <vfprintf+0x534>
   128c6:	f5 01       	movw	r30, r10
   128c8:	17 fd       	sbrc	r17, 7
   128ca:	85 91       	lpm	r24, Z+
   128cc:	17 ff       	sbrs	r17, 7
   128ce:	81 91       	ld	r24, Z+
   128d0:	5f 01       	movw	r10, r30
   128d2:	90 e0       	ldi	r25, 0x00	; 0
   128d4:	b3 01       	movw	r22, r6
   128d6:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   128da:	81 10       	cpse	r8, r1
   128dc:	8a 94       	dec	r8
   128de:	08 94       	sec
   128e0:	e1 08       	sbc	r14, r1
   128e2:	f1 08       	sbc	r15, r1
   128e4:	e1 14       	cp	r14, r1
   128e6:	f1 04       	cpc	r15, r1
   128e8:	71 f7       	brne	.-36     	; 0x128c6 <vfprintf+0x516>
   128ea:	f2 c0       	rjmp	.+484    	; 0x12ad0 <vfprintf+0x720>
   128ec:	94 36       	cpi	r25, 0x64	; 100
   128ee:	11 f0       	breq	.+4      	; 0x128f4 <vfprintf+0x544>
   128f0:	99 36       	cpi	r25, 0x69	; 105
   128f2:	89 f5       	brne	.+98     	; 0x12956 <vfprintf+0x5a6>
   128f4:	17 ff       	sbrs	r17, 7
   128f6:	08 c0       	rjmp	.+16     	; 0x12908 <vfprintf+0x558>
   128f8:	f6 01       	movw	r30, r12
   128fa:	20 81       	ld	r18, Z
   128fc:	31 81       	ldd	r19, Z+1	; 0x01
   128fe:	42 81       	ldd	r20, Z+2	; 0x02
   12900:	53 81       	ldd	r21, Z+3	; 0x03
   12902:	84 e0       	ldi	r24, 0x04	; 4
   12904:	90 e0       	ldi	r25, 0x00	; 0
   12906:	0a c0       	rjmp	.+20     	; 0x1291c <vfprintf+0x56c>
   12908:	f6 01       	movw	r30, r12
   1290a:	80 81       	ld	r24, Z
   1290c:	91 81       	ldd	r25, Z+1	; 0x01
   1290e:	9c 01       	movw	r18, r24
   12910:	44 27       	eor	r20, r20
   12912:	37 fd       	sbrc	r19, 7
   12914:	40 95       	com	r20
   12916:	54 2f       	mov	r21, r20
   12918:	82 e0       	ldi	r24, 0x02	; 2
   1291a:	90 e0       	ldi	r25, 0x00	; 0
   1291c:	c8 0e       	add	r12, r24
   1291e:	d9 1e       	adc	r13, r25
   12920:	9f e6       	ldi	r25, 0x6F	; 111
   12922:	f9 2e       	mov	r15, r25
   12924:	f1 22       	and	r15, r17
   12926:	57 ff       	sbrs	r21, 7
   12928:	09 c0       	rjmp	.+18     	; 0x1293c <vfprintf+0x58c>
   1292a:	50 95       	com	r21
   1292c:	40 95       	com	r20
   1292e:	30 95       	com	r19
   12930:	21 95       	neg	r18
   12932:	3f 4f       	sbci	r19, 0xFF	; 255
   12934:	4f 4f       	sbci	r20, 0xFF	; 255
   12936:	5f 4f       	sbci	r21, 0xFF	; 255
   12938:	90 e8       	ldi	r25, 0x80	; 128
   1293a:	f9 2a       	or	r15, r25
   1293c:	ca 01       	movw	r24, r20
   1293e:	b9 01       	movw	r22, r18
   12940:	ae 01       	movw	r20, r28
   12942:	4f 5f       	subi	r20, 0xFF	; 255
   12944:	5f 4f       	sbci	r21, 0xFF	; 255
   12946:	2a e0       	ldi	r18, 0x0A	; 10
   12948:	30 e0       	ldi	r19, 0x00	; 0
   1294a:	0e 94 43 a0 	call	0x14086	; 0x14086 <__ultoa_invert>
   1294e:	e8 2e       	mov	r14, r24
   12950:	e8 89       	ldd	r30, Y+16	; 0x10
   12952:	ee 1a       	sub	r14, r30
   12954:	41 c0       	rjmp	.+130    	; 0x129d8 <vfprintf+0x628>
   12956:	95 37       	cpi	r25, 0x75	; 117
   12958:	21 f4       	brne	.+8      	; 0x12962 <vfprintf+0x5b2>
   1295a:	1f 7e       	andi	r17, 0xEF	; 239
   1295c:	2a e0       	ldi	r18, 0x0A	; 10
   1295e:	30 e0       	ldi	r19, 0x00	; 0
   12960:	1c c0       	rjmp	.+56     	; 0x1299a <vfprintf+0x5ea>
   12962:	19 7f       	andi	r17, 0xF9	; 249
   12964:	9f 36       	cpi	r25, 0x6F	; 111
   12966:	61 f0       	breq	.+24     	; 0x12980 <vfprintf+0x5d0>
   12968:	90 37       	cpi	r25, 0x70	; 112
   1296a:	20 f4       	brcc	.+8      	; 0x12974 <vfprintf+0x5c4>
   1296c:	98 35       	cpi	r25, 0x58	; 88
   1296e:	09 f0       	breq	.+2      	; 0x12972 <vfprintf+0x5c2>
   12970:	b2 c0       	rjmp	.+356    	; 0x12ad6 <vfprintf+0x726>
   12972:	0f c0       	rjmp	.+30     	; 0x12992 <vfprintf+0x5e2>
   12974:	90 37       	cpi	r25, 0x70	; 112
   12976:	39 f0       	breq	.+14     	; 0x12986 <vfprintf+0x5d6>
   12978:	98 37       	cpi	r25, 0x78	; 120
   1297a:	09 f0       	breq	.+2      	; 0x1297e <vfprintf+0x5ce>
   1297c:	ac c0       	rjmp	.+344    	; 0x12ad6 <vfprintf+0x726>
   1297e:	04 c0       	rjmp	.+8      	; 0x12988 <vfprintf+0x5d8>
   12980:	28 e0       	ldi	r18, 0x08	; 8
   12982:	30 e0       	ldi	r19, 0x00	; 0
   12984:	0a c0       	rjmp	.+20     	; 0x1299a <vfprintf+0x5ea>
   12986:	10 61       	ori	r17, 0x10	; 16
   12988:	14 fd       	sbrc	r17, 4
   1298a:	14 60       	ori	r17, 0x04	; 4
   1298c:	20 e1       	ldi	r18, 0x10	; 16
   1298e:	30 e0       	ldi	r19, 0x00	; 0
   12990:	04 c0       	rjmp	.+8      	; 0x1299a <vfprintf+0x5ea>
   12992:	14 fd       	sbrc	r17, 4
   12994:	16 60       	ori	r17, 0x06	; 6
   12996:	20 e1       	ldi	r18, 0x10	; 16
   12998:	32 e0       	ldi	r19, 0x02	; 2
   1299a:	17 ff       	sbrs	r17, 7
   1299c:	08 c0       	rjmp	.+16     	; 0x129ae <vfprintf+0x5fe>
   1299e:	f6 01       	movw	r30, r12
   129a0:	60 81       	ld	r22, Z
   129a2:	71 81       	ldd	r23, Z+1	; 0x01
   129a4:	82 81       	ldd	r24, Z+2	; 0x02
   129a6:	93 81       	ldd	r25, Z+3	; 0x03
   129a8:	44 e0       	ldi	r20, 0x04	; 4
   129aa:	50 e0       	ldi	r21, 0x00	; 0
   129ac:	08 c0       	rjmp	.+16     	; 0x129be <vfprintf+0x60e>
   129ae:	f6 01       	movw	r30, r12
   129b0:	80 81       	ld	r24, Z
   129b2:	91 81       	ldd	r25, Z+1	; 0x01
   129b4:	bc 01       	movw	r22, r24
   129b6:	80 e0       	ldi	r24, 0x00	; 0
   129b8:	90 e0       	ldi	r25, 0x00	; 0
   129ba:	42 e0       	ldi	r20, 0x02	; 2
   129bc:	50 e0       	ldi	r21, 0x00	; 0
   129be:	c4 0e       	add	r12, r20
   129c0:	d5 1e       	adc	r13, r21
   129c2:	ae 01       	movw	r20, r28
   129c4:	4f 5f       	subi	r20, 0xFF	; 255
   129c6:	5f 4f       	sbci	r21, 0xFF	; 255
   129c8:	0e 94 43 a0 	call	0x14086	; 0x14086 <__ultoa_invert>
   129cc:	e8 2e       	mov	r14, r24
   129ce:	58 89       	ldd	r21, Y+16	; 0x10
   129d0:	e5 1a       	sub	r14, r21
   129d2:	8f e7       	ldi	r24, 0x7F	; 127
   129d4:	f8 2e       	mov	r15, r24
   129d6:	f1 22       	and	r15, r17
   129d8:	f6 fe       	sbrs	r15, 6
   129da:	0b c0       	rjmp	.+22     	; 0x129f2 <vfprintf+0x642>
   129dc:	8e ef       	ldi	r24, 0xFE	; 254
   129de:	f8 22       	and	r15, r24
   129e0:	e9 14       	cp	r14, r9
   129e2:	38 f4       	brcc	.+14     	; 0x129f2 <vfprintf+0x642>
   129e4:	f4 fe       	sbrs	r15, 4
   129e6:	07 c0       	rjmp	.+14     	; 0x129f6 <vfprintf+0x646>
   129e8:	f2 fc       	sbrc	r15, 2
   129ea:	05 c0       	rjmp	.+10     	; 0x129f6 <vfprintf+0x646>
   129ec:	9f ee       	ldi	r25, 0xEF	; 239
   129ee:	f9 22       	and	r15, r25
   129f0:	02 c0       	rjmp	.+4      	; 0x129f6 <vfprintf+0x646>
   129f2:	1e 2d       	mov	r17, r14
   129f4:	01 c0       	rjmp	.+2      	; 0x129f8 <vfprintf+0x648>
   129f6:	19 2d       	mov	r17, r9
   129f8:	f4 fe       	sbrs	r15, 4
   129fa:	0d c0       	rjmp	.+26     	; 0x12a16 <vfprintf+0x666>
   129fc:	fe 01       	movw	r30, r28
   129fe:	ee 0d       	add	r30, r14
   12a00:	f1 1d       	adc	r31, r1
   12a02:	80 81       	ld	r24, Z
   12a04:	80 33       	cpi	r24, 0x30	; 48
   12a06:	19 f4       	brne	.+6      	; 0x12a0e <vfprintf+0x65e>
   12a08:	e9 ee       	ldi	r30, 0xE9	; 233
   12a0a:	fe 22       	and	r15, r30
   12a0c:	08 c0       	rjmp	.+16     	; 0x12a1e <vfprintf+0x66e>
   12a0e:	1f 5f       	subi	r17, 0xFF	; 255
   12a10:	f2 fe       	sbrs	r15, 2
   12a12:	05 c0       	rjmp	.+10     	; 0x12a1e <vfprintf+0x66e>
   12a14:	03 c0       	rjmp	.+6      	; 0x12a1c <vfprintf+0x66c>
   12a16:	8f 2d       	mov	r24, r15
   12a18:	86 78       	andi	r24, 0x86	; 134
   12a1a:	09 f0       	breq	.+2      	; 0x12a1e <vfprintf+0x66e>
   12a1c:	1f 5f       	subi	r17, 0xFF	; 255
   12a1e:	0f 2d       	mov	r16, r15
   12a20:	f3 fc       	sbrc	r15, 3
   12a22:	14 c0       	rjmp	.+40     	; 0x12a4c <vfprintf+0x69c>
   12a24:	f0 fe       	sbrs	r15, 0
   12a26:	0f c0       	rjmp	.+30     	; 0x12a46 <vfprintf+0x696>
   12a28:	18 15       	cp	r17, r8
   12a2a:	10 f0       	brcs	.+4      	; 0x12a30 <vfprintf+0x680>
   12a2c:	9e 2c       	mov	r9, r14
   12a2e:	0b c0       	rjmp	.+22     	; 0x12a46 <vfprintf+0x696>
   12a30:	9e 2c       	mov	r9, r14
   12a32:	98 0c       	add	r9, r8
   12a34:	91 1a       	sub	r9, r17
   12a36:	18 2d       	mov	r17, r8
   12a38:	06 c0       	rjmp	.+12     	; 0x12a46 <vfprintf+0x696>
   12a3a:	80 e2       	ldi	r24, 0x20	; 32
   12a3c:	90 e0       	ldi	r25, 0x00	; 0
   12a3e:	b3 01       	movw	r22, r6
   12a40:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   12a44:	1f 5f       	subi	r17, 0xFF	; 255
   12a46:	18 15       	cp	r17, r8
   12a48:	c0 f3       	brcs	.-16     	; 0x12a3a <vfprintf+0x68a>
   12a4a:	04 c0       	rjmp	.+8      	; 0x12a54 <vfprintf+0x6a4>
   12a4c:	18 15       	cp	r17, r8
   12a4e:	10 f4       	brcc	.+4      	; 0x12a54 <vfprintf+0x6a4>
   12a50:	81 1a       	sub	r8, r17
   12a52:	01 c0       	rjmp	.+2      	; 0x12a56 <vfprintf+0x6a6>
   12a54:	88 24       	eor	r8, r8
   12a56:	04 ff       	sbrs	r16, 4
   12a58:	0f c0       	rjmp	.+30     	; 0x12a78 <vfprintf+0x6c8>
   12a5a:	80 e3       	ldi	r24, 0x30	; 48
   12a5c:	90 e0       	ldi	r25, 0x00	; 0
   12a5e:	b3 01       	movw	r22, r6
   12a60:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   12a64:	02 ff       	sbrs	r16, 2
   12a66:	1d c0       	rjmp	.+58     	; 0x12aa2 <vfprintf+0x6f2>
   12a68:	01 fd       	sbrc	r16, 1
   12a6a:	03 c0       	rjmp	.+6      	; 0x12a72 <vfprintf+0x6c2>
   12a6c:	88 e7       	ldi	r24, 0x78	; 120
   12a6e:	90 e0       	ldi	r25, 0x00	; 0
   12a70:	0e c0       	rjmp	.+28     	; 0x12a8e <vfprintf+0x6de>
   12a72:	88 e5       	ldi	r24, 0x58	; 88
   12a74:	90 e0       	ldi	r25, 0x00	; 0
   12a76:	0b c0       	rjmp	.+22     	; 0x12a8e <vfprintf+0x6de>
   12a78:	80 2f       	mov	r24, r16
   12a7a:	86 78       	andi	r24, 0x86	; 134
   12a7c:	91 f0       	breq	.+36     	; 0x12aa2 <vfprintf+0x6f2>
   12a7e:	01 ff       	sbrs	r16, 1
   12a80:	02 c0       	rjmp	.+4      	; 0x12a86 <vfprintf+0x6d6>
   12a82:	8b e2       	ldi	r24, 0x2B	; 43
   12a84:	01 c0       	rjmp	.+2      	; 0x12a88 <vfprintf+0x6d8>
   12a86:	80 e2       	ldi	r24, 0x20	; 32
   12a88:	f7 fc       	sbrc	r15, 7
   12a8a:	8d e2       	ldi	r24, 0x2D	; 45
   12a8c:	90 e0       	ldi	r25, 0x00	; 0
   12a8e:	b3 01       	movw	r22, r6
   12a90:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   12a94:	06 c0       	rjmp	.+12     	; 0x12aa2 <vfprintf+0x6f2>
   12a96:	80 e3       	ldi	r24, 0x30	; 48
   12a98:	90 e0       	ldi	r25, 0x00	; 0
   12a9a:	b3 01       	movw	r22, r6
   12a9c:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   12aa0:	9a 94       	dec	r9
   12aa2:	e9 14       	cp	r14, r9
   12aa4:	c0 f3       	brcs	.-16     	; 0x12a96 <vfprintf+0x6e6>
   12aa6:	ea 94       	dec	r14
   12aa8:	e1 e0       	ldi	r30, 0x01	; 1
   12aaa:	f0 e0       	ldi	r31, 0x00	; 0
   12aac:	ec 0f       	add	r30, r28
   12aae:	fd 1f       	adc	r31, r29
   12ab0:	ee 0d       	add	r30, r14
   12ab2:	f1 1d       	adc	r31, r1
   12ab4:	80 81       	ld	r24, Z
   12ab6:	90 e0       	ldi	r25, 0x00	; 0
   12ab8:	b3 01       	movw	r22, r6
   12aba:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   12abe:	ee 20       	and	r14, r14
   12ac0:	91 f7       	brne	.-28     	; 0x12aa6 <vfprintf+0x6f6>
   12ac2:	06 c0       	rjmp	.+12     	; 0x12ad0 <vfprintf+0x720>
   12ac4:	80 e2       	ldi	r24, 0x20	; 32
   12ac6:	90 e0       	ldi	r25, 0x00	; 0
   12ac8:	b3 01       	movw	r22, r6
   12aca:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   12ace:	8a 94       	dec	r8
   12ad0:	88 20       	and	r8, r8
   12ad2:	c1 f7       	brne	.-16     	; 0x12ac4 <vfprintf+0x714>
   12ad4:	99 cc       	rjmp	.-1742   	; 0x12408 <vfprintf+0x58>
   12ad6:	f3 01       	movw	r30, r6
   12ad8:	66 81       	ldd	r22, Z+6	; 0x06
   12ada:	77 81       	ldd	r23, Z+7	; 0x07
   12adc:	cb 01       	movw	r24, r22
   12ade:	61 96       	adiw	r28, 0x11	; 17
   12ae0:	0f b6       	in	r0, 0x3f	; 63
   12ae2:	f8 94       	cli
   12ae4:	de bf       	out	0x3e, r29	; 62
   12ae6:	0f be       	out	0x3f, r0	; 63
   12ae8:	cd bf       	out	0x3d, r28	; 61
   12aea:	cf 91       	pop	r28
   12aec:	df 91       	pop	r29
   12aee:	1f 91       	pop	r17
   12af0:	0f 91       	pop	r16
   12af2:	ff 90       	pop	r15
   12af4:	ef 90       	pop	r14
   12af6:	df 90       	pop	r13
   12af8:	cf 90       	pop	r12
   12afa:	bf 90       	pop	r11
   12afc:	af 90       	pop	r10
   12afe:	9f 90       	pop	r9
   12b00:	8f 90       	pop	r8
   12b02:	7f 90       	pop	r7
   12b04:	6f 90       	pop	r6
   12b06:	5f 90       	pop	r5
   12b08:	4f 90       	pop	r4
   12b0a:	3f 90       	pop	r3
   12b0c:	2f 90       	pop	r2
   12b0e:	08 95       	ret

00012b10 <putval>:
   12b10:	fc 01       	movw	r30, r24
   12b12:	20 fd       	sbrc	r18, 0
   12b14:	08 c0       	rjmp	.+16     	; 0x12b26 <putval+0x16>
   12b16:	23 fd       	sbrc	r18, 3
   12b18:	05 c0       	rjmp	.+10     	; 0x12b24 <putval+0x14>
   12b1a:	22 ff       	sbrs	r18, 2
   12b1c:	02 c0       	rjmp	.+4      	; 0x12b22 <putval+0x12>
   12b1e:	73 83       	std	Z+3, r23	; 0x03
   12b20:	62 83       	std	Z+2, r22	; 0x02
   12b22:	51 83       	std	Z+1, r21	; 0x01
   12b24:	40 83       	st	Z, r20
   12b26:	08 95       	ret

00012b28 <mulacc>:
   12b28:	ef 92       	push	r14
   12b2a:	ff 92       	push	r15
   12b2c:	0f 93       	push	r16
   12b2e:	1f 93       	push	r17
   12b30:	44 ff       	sbrs	r20, 4
   12b32:	02 c0       	rjmp	.+4      	; 0x12b38 <mulacc+0x10>
   12b34:	33 e0       	ldi	r19, 0x03	; 3
   12b36:	11 c0       	rjmp	.+34     	; 0x12b5a <mulacc+0x32>
   12b38:	46 ff       	sbrs	r20, 6
   12b3a:	02 c0       	rjmp	.+4      	; 0x12b40 <mulacc+0x18>
   12b3c:	34 e0       	ldi	r19, 0x04	; 4
   12b3e:	0d c0       	rjmp	.+26     	; 0x12b5a <mulacc+0x32>
   12b40:	db 01       	movw	r26, r22
   12b42:	fc 01       	movw	r30, r24
   12b44:	aa 0f       	add	r26, r26
   12b46:	bb 1f       	adc	r27, r27
   12b48:	ee 1f       	adc	r30, r30
   12b4a:	ff 1f       	adc	r31, r31
   12b4c:	10 94       	com	r1
   12b4e:	d1 f7       	brne	.-12     	; 0x12b44 <mulacc+0x1c>
   12b50:	6a 0f       	add	r22, r26
   12b52:	7b 1f       	adc	r23, r27
   12b54:	8e 1f       	adc	r24, r30
   12b56:	9f 1f       	adc	r25, r31
   12b58:	31 e0       	ldi	r19, 0x01	; 1
   12b5a:	66 0f       	add	r22, r22
   12b5c:	77 1f       	adc	r23, r23
   12b5e:	88 1f       	adc	r24, r24
   12b60:	99 1f       	adc	r25, r25
   12b62:	31 50       	subi	r19, 0x01	; 1
   12b64:	d1 f7       	brne	.-12     	; 0x12b5a <mulacc+0x32>
   12b66:	7b 01       	movw	r14, r22
   12b68:	8c 01       	movw	r16, r24
   12b6a:	e2 0e       	add	r14, r18
   12b6c:	f1 1c       	adc	r15, r1
   12b6e:	01 1d       	adc	r16, r1
   12b70:	11 1d       	adc	r17, r1
   12b72:	a8 01       	movw	r20, r16
   12b74:	97 01       	movw	r18, r14
   12b76:	b7 01       	movw	r22, r14
   12b78:	ca 01       	movw	r24, r20
   12b7a:	1f 91       	pop	r17
   12b7c:	0f 91       	pop	r16
   12b7e:	ff 90       	pop	r15
   12b80:	ef 90       	pop	r14
   12b82:	08 95       	ret

00012b84 <skip_spaces>:
   12b84:	0f 93       	push	r16
   12b86:	1f 93       	push	r17
   12b88:	cf 93       	push	r28
   12b8a:	df 93       	push	r29
   12b8c:	8c 01       	movw	r16, r24
   12b8e:	c8 01       	movw	r24, r16
   12b90:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12b94:	ec 01       	movw	r28, r24
   12b96:	97 fd       	sbrc	r25, 7
   12b98:	08 c0       	rjmp	.+16     	; 0x12baa <skip_spaces+0x26>
   12b9a:	0e 94 a8 9e 	call	0x13d50	; 0x13d50 <isspace>
   12b9e:	89 2b       	or	r24, r25
   12ba0:	b1 f7       	brne	.-20     	; 0x12b8e <skip_spaces+0xa>
   12ba2:	ce 01       	movw	r24, r28
   12ba4:	b8 01       	movw	r22, r16
   12ba6:	0e 94 29 a0 	call	0x14052	; 0x14052 <ungetc>
   12baa:	ce 01       	movw	r24, r28
   12bac:	df 91       	pop	r29
   12bae:	cf 91       	pop	r28
   12bb0:	1f 91       	pop	r17
   12bb2:	0f 91       	pop	r16
   12bb4:	08 95       	ret

00012bb6 <conv_int>:
   12bb6:	8f 92       	push	r8
   12bb8:	9f 92       	push	r9
   12bba:	af 92       	push	r10
   12bbc:	bf 92       	push	r11
   12bbe:	df 92       	push	r13
   12bc0:	ef 92       	push	r14
   12bc2:	ff 92       	push	r15
   12bc4:	0f 93       	push	r16
   12bc6:	1f 93       	push	r17
   12bc8:	cf 93       	push	r28
   12bca:	df 93       	push	r29
   12bcc:	5c 01       	movw	r10, r24
   12bce:	eb 01       	movw	r28, r22
   12bd0:	4a 01       	movw	r8, r20
   12bd2:	12 2f       	mov	r17, r18
   12bd4:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12bd8:	ac 01       	movw	r20, r24
   12bda:	8b 32       	cpi	r24, 0x2B	; 43
   12bdc:	19 f0       	breq	.+6      	; 0x12be4 <conv_int+0x2e>
   12bde:	8d 32       	cpi	r24, 0x2D	; 45
   12be0:	51 f4       	brne	.+20     	; 0x12bf6 <conv_int+0x40>
   12be2:	10 68       	ori	r17, 0x80	; 128
   12be4:	21 97       	sbiw	r28, 0x01	; 1
   12be6:	09 f4       	brne	.+2      	; 0x12bea <conv_int+0x34>
   12be8:	6d c0       	rjmp	.+218    	; 0x12cc4 <conv_int+0x10e>
   12bea:	c5 01       	movw	r24, r10
   12bec:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12bf0:	ac 01       	movw	r20, r24
   12bf2:	97 fd       	sbrc	r25, 7
   12bf4:	67 c0       	rjmp	.+206    	; 0x12cc4 <conv_int+0x10e>
   12bf6:	6d ef       	ldi	r22, 0xFD	; 253
   12bf8:	d6 2e       	mov	r13, r22
   12bfa:	d1 22       	and	r13, r17
   12bfc:	8d 2d       	mov	r24, r13
   12bfe:	80 73       	andi	r24, 0x30	; 48
   12c00:	01 f5       	brne	.+64     	; 0x12c42 <conv_int+0x8c>
   12c02:	40 33       	cpi	r20, 0x30	; 48
   12c04:	f1 f4       	brne	.+60     	; 0x12c42 <conv_int+0x8c>
   12c06:	21 97       	sbiw	r28, 0x01	; 1
   12c08:	09 f4       	brne	.+2      	; 0x12c0c <conv_int+0x56>
   12c0a:	47 c0       	rjmp	.+142    	; 0x12c9a <conv_int+0xe4>
   12c0c:	c5 01       	movw	r24, r10
   12c0e:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12c12:	ac 01       	movw	r20, r24
   12c14:	97 fd       	sbrc	r25, 7
   12c16:	41 c0       	rjmp	.+130    	; 0x12c9a <conv_int+0xe4>
   12c18:	82 e0       	ldi	r24, 0x02	; 2
   12c1a:	d8 2a       	or	r13, r24
   12c1c:	48 37       	cpi	r20, 0x78	; 120
   12c1e:	11 f0       	breq	.+4      	; 0x12c24 <conv_int+0x6e>
   12c20:	48 35       	cpi	r20, 0x58	; 88
   12c22:	59 f4       	brne	.+22     	; 0x12c3a <conv_int+0x84>
   12c24:	80 e4       	ldi	r24, 0x40	; 64
   12c26:	d8 2a       	or	r13, r24
   12c28:	21 97       	sbiw	r28, 0x01	; 1
   12c2a:	b9 f1       	breq	.+110    	; 0x12c9a <conv_int+0xe4>
   12c2c:	c5 01       	movw	r24, r10
   12c2e:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12c32:	ac 01       	movw	r20, r24
   12c34:	99 23       	and	r25, r25
   12c36:	2c f4       	brge	.+10     	; 0x12c42 <conv_int+0x8c>
   12c38:	30 c0       	rjmp	.+96     	; 0x12c9a <conv_int+0xe4>
   12c3a:	d6 fc       	sbrc	r13, 6
   12c3c:	02 c0       	rjmp	.+4      	; 0x12c42 <conv_int+0x8c>
   12c3e:	80 e1       	ldi	r24, 0x10	; 16
   12c40:	d8 2a       	or	r13, r24
   12c42:	ee 24       	eor	r14, r14
   12c44:	ff 24       	eor	r15, r15
   12c46:	87 01       	movw	r16, r14
   12c48:	24 2f       	mov	r18, r20
   12c4a:	20 53       	subi	r18, 0x30	; 48
   12c4c:	28 30       	cpi	r18, 0x08	; 8
   12c4e:	88 f0       	brcs	.+34     	; 0x12c72 <conv_int+0xbc>
   12c50:	d4 fc       	sbrc	r13, 4
   12c52:	09 c0       	rjmp	.+18     	; 0x12c66 <conv_int+0xb0>
   12c54:	2a 30       	cpi	r18, 0x0A	; 10
   12c56:	68 f0       	brcs	.+26     	; 0x12c72 <conv_int+0xbc>
   12c58:	d6 fe       	sbrs	r13, 6
   12c5a:	05 c0       	rjmp	.+10     	; 0x12c66 <conv_int+0xb0>
   12c5c:	2f 7d       	andi	r18, 0xDF	; 223
   12c5e:	82 2f       	mov	r24, r18
   12c60:	81 51       	subi	r24, 0x11	; 17
   12c62:	86 30       	cpi	r24, 0x06	; 6
   12c64:	28 f0       	brcs	.+10     	; 0x12c70 <conv_int+0xba>
   12c66:	ca 01       	movw	r24, r20
   12c68:	b5 01       	movw	r22, r10
   12c6a:	0e 94 29 a0 	call	0x14052	; 0x14052 <ungetc>
   12c6e:	12 c0       	rjmp	.+36     	; 0x12c94 <conv_int+0xde>
   12c70:	27 50       	subi	r18, 0x07	; 7
   12c72:	c8 01       	movw	r24, r16
   12c74:	b7 01       	movw	r22, r14
   12c76:	4d 2d       	mov	r20, r13
   12c78:	0e 94 94 95 	call	0x12b28	; 0x12b28 <mulacc>
   12c7c:	7b 01       	movw	r14, r22
   12c7e:	8c 01       	movw	r16, r24
   12c80:	82 e0       	ldi	r24, 0x02	; 2
   12c82:	d8 2a       	or	r13, r24
   12c84:	21 97       	sbiw	r28, 0x01	; 1
   12c86:	61 f0       	breq	.+24     	; 0x12ca0 <conv_int+0xea>
   12c88:	c5 01       	movw	r24, r10
   12c8a:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12c8e:	ac 01       	movw	r20, r24
   12c90:	97 ff       	sbrs	r25, 7
   12c92:	da cf       	rjmp	.-76     	; 0x12c48 <conv_int+0x92>
   12c94:	d1 fc       	sbrc	r13, 1
   12c96:	04 c0       	rjmp	.+8      	; 0x12ca0 <conv_int+0xea>
   12c98:	15 c0       	rjmp	.+42     	; 0x12cc4 <conv_int+0x10e>
   12c9a:	ee 24       	eor	r14, r14
   12c9c:	ff 24       	eor	r15, r15
   12c9e:	87 01       	movw	r16, r14
   12ca0:	d7 fe       	sbrs	r13, 7
   12ca2:	08 c0       	rjmp	.+16     	; 0x12cb4 <conv_int+0xfe>
   12ca4:	10 95       	com	r17
   12ca6:	00 95       	com	r16
   12ca8:	f0 94       	com	r15
   12caa:	e0 94       	com	r14
   12cac:	e1 1c       	adc	r14, r1
   12cae:	f1 1c       	adc	r15, r1
   12cb0:	01 1d       	adc	r16, r1
   12cb2:	11 1d       	adc	r17, r1
   12cb4:	c4 01       	movw	r24, r8
   12cb6:	b8 01       	movw	r22, r16
   12cb8:	a7 01       	movw	r20, r14
   12cba:	2d 2d       	mov	r18, r13
   12cbc:	0e 94 88 95 	call	0x12b10	; 0x12b10 <putval>
   12cc0:	81 e0       	ldi	r24, 0x01	; 1
   12cc2:	01 c0       	rjmp	.+2      	; 0x12cc6 <conv_int+0x110>
   12cc4:	80 e0       	ldi	r24, 0x00	; 0
   12cc6:	df 91       	pop	r29
   12cc8:	cf 91       	pop	r28
   12cca:	1f 91       	pop	r17
   12ccc:	0f 91       	pop	r16
   12cce:	ff 90       	pop	r15
   12cd0:	ef 90       	pop	r14
   12cd2:	df 90       	pop	r13
   12cd4:	bf 90       	pop	r11
   12cd6:	af 90       	pop	r10
   12cd8:	9f 90       	pop	r9
   12cda:	8f 90       	pop	r8
   12cdc:	08 95       	ret

00012cde <conv_brk>:
   12cde:	6f 92       	push	r6
   12ce0:	7f 92       	push	r7
   12ce2:	8f 92       	push	r8
   12ce4:	9f 92       	push	r9
   12ce6:	af 92       	push	r10
   12ce8:	bf 92       	push	r11
   12cea:	cf 92       	push	r12
   12cec:	df 92       	push	r13
   12cee:	ef 92       	push	r14
   12cf0:	ff 92       	push	r15
   12cf2:	0f 93       	push	r16
   12cf4:	1f 93       	push	r17
   12cf6:	df 93       	push	r29
   12cf8:	cf 93       	push	r28
   12cfa:	cd b7       	in	r28, 0x3d	; 61
   12cfc:	de b7       	in	r29, 0x3e	; 62
   12cfe:	a0 97       	sbiw	r28, 0x20	; 32
   12d00:	0f b6       	in	r0, 0x3f	; 63
   12d02:	f8 94       	cli
   12d04:	de bf       	out	0x3e, r29	; 62
   12d06:	0f be       	out	0x3f, r0	; 63
   12d08:	cd bf       	out	0x3d, r28	; 61
   12d0a:	5c 01       	movw	r10, r24
   12d0c:	6b 01       	movw	r12, r22
   12d0e:	8a 01       	movw	r16, r20
   12d10:	79 01       	movw	r14, r18
   12d12:	fe 01       	movw	r30, r28
   12d14:	31 96       	adiw	r30, 0x01	; 1
   12d16:	80 e2       	ldi	r24, 0x20	; 32
   12d18:	df 01       	movw	r26, r30
   12d1a:	1d 92       	st	X+, r1
   12d1c:	8a 95       	dec	r24
   12d1e:	e9 f7       	brne	.-6      	; 0x12d1a <conv_brk+0x3c>
   12d20:	70 e0       	ldi	r23, 0x00	; 0
   12d22:	30 e0       	ldi	r19, 0x00	; 0
   12d24:	60 e0       	ldi	r22, 0x00	; 0
   12d26:	40 e0       	ldi	r20, 0x00	; 0
   12d28:	50 e0       	ldi	r21, 0x00	; 0
   12d2a:	3f 01       	movw	r6, r30
   12d2c:	a1 e0       	ldi	r26, 0x01	; 1
   12d2e:	b0 e0       	ldi	r27, 0x00	; 0
   12d30:	f5 01       	movw	r30, r10
   12d32:	83 81       	ldd	r24, Z+3	; 0x03
   12d34:	f7 01       	movw	r30, r14
   12d36:	83 fd       	sbrc	r24, 3
   12d38:	25 91       	lpm	r18, Z+
   12d3a:	83 ff       	sbrs	r24, 3
   12d3c:	21 91       	ld	r18, Z+
   12d3e:	7f 01       	movw	r14, r30
   12d40:	22 23       	and	r18, r18
   12d42:	09 f4       	brne	.+2      	; 0x12d46 <conv_brk+0x68>
   12d44:	81 c0       	rjmp	.+258    	; 0x12e48 <conv_brk+0x16a>
   12d46:	2e 35       	cpi	r18, 0x5E	; 94
   12d48:	19 f4       	brne	.+6      	; 0x12d50 <conv_brk+0x72>
   12d4a:	41 15       	cp	r20, r1
   12d4c:	51 05       	cpc	r21, r1
   12d4e:	69 f1       	breq	.+90     	; 0x12daa <conv_brk+0xcc>
   12d50:	87 2f       	mov	r24, r23
   12d52:	90 e0       	ldi	r25, 0x00	; 0
   12d54:	84 17       	cp	r24, r20
   12d56:	95 07       	cpc	r25, r21
   12d58:	44 f4       	brge	.+16     	; 0x12d6a <conv_brk+0x8c>
   12d5a:	2d 35       	cpi	r18, 0x5D	; 93
   12d5c:	51 f1       	breq	.+84     	; 0x12db2 <conv_brk+0xd4>
   12d5e:	2d 32       	cpi	r18, 0x2D	; 45
   12d60:	21 f4       	brne	.+8      	; 0x12d6a <conv_brk+0x8c>
   12d62:	33 23       	and	r19, r19
   12d64:	29 f4       	brne	.+10     	; 0x12d70 <conv_brk+0x92>
   12d66:	31 e0       	ldi	r19, 0x01	; 1
   12d68:	21 c0       	rjmp	.+66     	; 0x12dac <conv_brk+0xce>
   12d6a:	33 23       	and	r19, r19
   12d6c:	09 f4       	brne	.+2      	; 0x12d70 <conv_brk+0x92>
   12d6e:	62 2f       	mov	r22, r18
   12d70:	32 2f       	mov	r19, r18
   12d72:	83 2f       	mov	r24, r19
   12d74:	86 95       	lsr	r24
   12d76:	86 95       	lsr	r24
   12d78:	86 95       	lsr	r24
   12d7a:	f3 01       	movw	r30, r6
   12d7c:	e8 0f       	add	r30, r24
   12d7e:	f1 1d       	adc	r31, r1
   12d80:	83 2f       	mov	r24, r19
   12d82:	87 70       	andi	r24, 0x07	; 7
   12d84:	4d 01       	movw	r8, r26
   12d86:	02 c0       	rjmp	.+4      	; 0x12d8c <conv_brk+0xae>
   12d88:	88 0c       	add	r8, r8
   12d8a:	99 1c       	adc	r9, r9
   12d8c:	8a 95       	dec	r24
   12d8e:	e2 f7       	brpl	.-8      	; 0x12d88 <conv_brk+0xaa>
   12d90:	20 81       	ld	r18, Z
   12d92:	28 29       	or	r18, r8
   12d94:	20 83       	st	Z, r18
   12d96:	36 17       	cp	r19, r22
   12d98:	11 f4       	brne	.+4      	; 0x12d9e <conv_brk+0xc0>
   12d9a:	30 e0       	ldi	r19, 0x00	; 0
   12d9c:	07 c0       	rjmp	.+14     	; 0x12dac <conv_brk+0xce>
   12d9e:	36 17       	cp	r19, r22
   12da0:	10 f4       	brcc	.+4      	; 0x12da6 <conv_brk+0xc8>
   12da2:	3f 5f       	subi	r19, 0xFF	; 255
   12da4:	e6 cf       	rjmp	.-52     	; 0x12d72 <conv_brk+0x94>
   12da6:	31 50       	subi	r19, 0x01	; 1
   12da8:	e4 cf       	rjmp	.-56     	; 0x12d72 <conv_brk+0x94>
   12daa:	71 e0       	ldi	r23, 0x01	; 1
   12dac:	4f 5f       	subi	r20, 0xFF	; 255
   12dae:	5f 4f       	sbci	r21, 0xFF	; 255
   12db0:	bf cf       	rjmp	.-130    	; 0x12d30 <conv_brk+0x52>
   12db2:	33 23       	and	r19, r19
   12db4:	19 f0       	breq	.+6      	; 0x12dbc <conv_brk+0xde>
   12db6:	8e 81       	ldd	r24, Y+6	; 0x06
   12db8:	80 62       	ori	r24, 0x20	; 32
   12dba:	8e 83       	std	Y+6, r24	; 0x06
   12dbc:	77 23       	and	r23, r23
   12dbe:	59 f0       	breq	.+22     	; 0x12dd6 <conv_brk+0xf8>
   12dc0:	fe 01       	movw	r30, r28
   12dc2:	31 96       	adiw	r30, 0x01	; 1
   12dc4:	9e 01       	movw	r18, r28
   12dc6:	2f 5d       	subi	r18, 0xDF	; 223
   12dc8:	3f 4f       	sbci	r19, 0xFF	; 255
   12dca:	80 81       	ld	r24, Z
   12dcc:	80 95       	com	r24
   12dce:	81 93       	st	Z+, r24
   12dd0:	e2 17       	cp	r30, r18
   12dd2:	f3 07       	cpc	r31, r19
   12dd4:	d1 f7       	brne	.-12     	; 0x12dca <conv_brk+0xec>
   12dd6:	99 24       	eor	r9, r9
   12dd8:	93 94       	inc	r9
   12dda:	3e 01       	movw	r6, r28
   12ddc:	08 94       	sec
   12dde:	61 1c       	adc	r6, r1
   12de0:	71 1c       	adc	r7, r1
   12de2:	c5 01       	movw	r24, r10
   12de4:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12de8:	ac 01       	movw	r20, r24
   12dea:	97 fd       	sbrc	r25, 7
   12dec:	25 c0       	rjmp	.+74     	; 0x12e38 <conv_brk+0x15a>
   12dee:	86 95       	lsr	r24
   12df0:	86 95       	lsr	r24
   12df2:	86 95       	lsr	r24
   12df4:	f3 01       	movw	r30, r6
   12df6:	e8 0f       	add	r30, r24
   12df8:	f1 1d       	adc	r31, r1
   12dfa:	80 81       	ld	r24, Z
   12dfc:	90 e0       	ldi	r25, 0x00	; 0
   12dfe:	9a 01       	movw	r18, r20
   12e00:	27 70       	andi	r18, 0x07	; 7
   12e02:	30 70       	andi	r19, 0x00	; 0
   12e04:	02 c0       	rjmp	.+4      	; 0x12e0a <conv_brk+0x12c>
   12e06:	95 95       	asr	r25
   12e08:	87 95       	ror	r24
   12e0a:	2a 95       	dec	r18
   12e0c:	e2 f7       	brpl	.-8      	; 0x12e06 <conv_brk+0x128>
   12e0e:	80 fd       	sbrc	r24, 0
   12e10:	05 c0       	rjmp	.+10     	; 0x12e1c <conv_brk+0x13e>
   12e12:	ca 01       	movw	r24, r20
   12e14:	b5 01       	movw	r22, r10
   12e16:	0e 94 29 a0 	call	0x14052	; 0x14052 <ungetc>
   12e1a:	0e c0       	rjmp	.+28     	; 0x12e38 <conv_brk+0x15a>
   12e1c:	01 15       	cp	r16, r1
   12e1e:	11 05       	cpc	r17, r1
   12e20:	19 f0       	breq	.+6      	; 0x12e28 <conv_brk+0x14a>
   12e22:	d8 01       	movw	r26, r16
   12e24:	4d 93       	st	X+, r20
   12e26:	8d 01       	movw	r16, r26
   12e28:	08 94       	sec
   12e2a:	c1 08       	sbc	r12, r1
   12e2c:	d1 08       	sbc	r13, r1
   12e2e:	99 24       	eor	r9, r9
   12e30:	c1 14       	cp	r12, r1
   12e32:	d1 04       	cpc	r13, r1
   12e34:	b1 f6       	brne	.-84     	; 0x12de2 <conv_brk+0x104>
   12e36:	02 c0       	rjmp	.+4      	; 0x12e3c <conv_brk+0x15e>
   12e38:	99 20       	and	r9, r9
   12e3a:	31 f4       	brne	.+12     	; 0x12e48 <conv_brk+0x16a>
   12e3c:	01 15       	cp	r16, r1
   12e3e:	11 05       	cpc	r17, r1
   12e40:	29 f0       	breq	.+10     	; 0x12e4c <conv_brk+0x16e>
   12e42:	f8 01       	movw	r30, r16
   12e44:	10 82       	st	Z, r1
   12e46:	02 c0       	rjmp	.+4      	; 0x12e4c <conv_brk+0x16e>
   12e48:	ee 24       	eor	r14, r14
   12e4a:	ff 24       	eor	r15, r15
   12e4c:	c7 01       	movw	r24, r14
   12e4e:	a0 96       	adiw	r28, 0x20	; 32
   12e50:	0f b6       	in	r0, 0x3f	; 63
   12e52:	f8 94       	cli
   12e54:	de bf       	out	0x3e, r29	; 62
   12e56:	0f be       	out	0x3f, r0	; 63
   12e58:	cd bf       	out	0x3d, r28	; 61
   12e5a:	cf 91       	pop	r28
   12e5c:	df 91       	pop	r29
   12e5e:	1f 91       	pop	r17
   12e60:	0f 91       	pop	r16
   12e62:	ff 90       	pop	r15
   12e64:	ef 90       	pop	r14
   12e66:	df 90       	pop	r13
   12e68:	cf 90       	pop	r12
   12e6a:	bf 90       	pop	r11
   12e6c:	af 90       	pop	r10
   12e6e:	9f 90       	pop	r9
   12e70:	8f 90       	pop	r8
   12e72:	7f 90       	pop	r7
   12e74:	6f 90       	pop	r6
   12e76:	08 95       	ret

00012e78 <conv_flt>:
   12e78:	2f 92       	push	r2
   12e7a:	3f 92       	push	r3
   12e7c:	5f 92       	push	r5
   12e7e:	6f 92       	push	r6
   12e80:	7f 92       	push	r7
   12e82:	8f 92       	push	r8
   12e84:	9f 92       	push	r9
   12e86:	af 92       	push	r10
   12e88:	bf 92       	push	r11
   12e8a:	cf 92       	push	r12
   12e8c:	df 92       	push	r13
   12e8e:	ef 92       	push	r14
   12e90:	ff 92       	push	r15
   12e92:	0f 93       	push	r16
   12e94:	1f 93       	push	r17
   12e96:	cf 93       	push	r28
   12e98:	df 93       	push	r29
   12e9a:	3c 01       	movw	r6, r24
   12e9c:	7b 01       	movw	r14, r22
   12e9e:	1a 01       	movw	r2, r20
   12ea0:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12ea4:	ec 01       	movw	r28, r24
   12ea6:	8b 32       	cpi	r24, 0x2B	; 43
   12ea8:	39 f0       	breq	.+14     	; 0x12eb8 <conv_flt+0x40>
   12eaa:	8d 32       	cpi	r24, 0x2D	; 45
   12eac:	11 f0       	breq	.+4      	; 0x12eb2 <conv_flt+0x3a>
   12eae:	55 24       	eor	r5, r5
   12eb0:	11 c0       	rjmp	.+34     	; 0x12ed4 <conv_flt+0x5c>
   12eb2:	b0 e8       	ldi	r27, 0x80	; 128
   12eb4:	5b 2e       	mov	r5, r27
   12eb6:	01 c0       	rjmp	.+2      	; 0x12eba <conv_flt+0x42>
   12eb8:	55 24       	eor	r5, r5
   12eba:	08 94       	sec
   12ebc:	e1 08       	sbc	r14, r1
   12ebe:	f1 08       	sbc	r15, r1
   12ec0:	e1 14       	cp	r14, r1
   12ec2:	f1 04       	cpc	r15, r1
   12ec4:	09 f4       	brne	.+2      	; 0x12ec8 <conv_flt+0x50>
   12ec6:	18 c1       	rjmp	.+560    	; 0x130f8 <conv_flt+0x280>
   12ec8:	c3 01       	movw	r24, r6
   12eca:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12ece:	ec 01       	movw	r28, r24
   12ed0:	97 fd       	sbrc	r25, 7
   12ed2:	12 c1       	rjmp	.+548    	; 0x130f8 <conv_flt+0x280>
   12ed4:	ce 01       	movw	r24, r28
   12ed6:	0e 94 b0 9e 	call	0x13d60	; 0x13d60 <tolower>
   12eda:	89 36       	cpi	r24, 0x69	; 105
   12edc:	91 05       	cpc	r25, r1
   12ede:	21 f0       	breq	.+8      	; 0x12ee8 <conv_flt+0x70>
   12ee0:	8e 36       	cpi	r24, 0x6E	; 110
   12ee2:	91 05       	cpc	r25, r1
   12ee4:	99 f5       	brne	.+102    	; 0x12f4c <conv_flt+0xd4>
   12ee6:	1d c0       	rjmp	.+58     	; 0x12f22 <conv_flt+0xaa>
   12ee8:	02 e8       	ldi	r16, 0x82	; 130
   12eea:	18 e1       	ldi	r17, 0x18	; 24
   12eec:	1c c0       	rjmp	.+56     	; 0x12f26 <conv_flt+0xae>
   12eee:	08 94       	sec
   12ef0:	e1 08       	sbc	r14, r1
   12ef2:	f1 08       	sbc	r15, r1
   12ef4:	e1 14       	cp	r14, r1
   12ef6:	f1 04       	cpc	r15, r1
   12ef8:	71 f0       	breq	.+28     	; 0x12f16 <conv_flt+0x9e>
   12efa:	c3 01       	movw	r24, r6
   12efc:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12f00:	ec 01       	movw	r28, r24
   12f02:	97 fd       	sbrc	r25, 7
   12f04:	08 c0       	rjmp	.+16     	; 0x12f16 <conv_flt+0x9e>
   12f06:	0e 94 b0 9e 	call	0x13d60	; 0x13d60 <tolower>
   12f0a:	d8 16       	cp	r13, r24
   12f0c:	61 f0       	breq	.+24     	; 0x12f26 <conv_flt+0xae>
   12f0e:	ce 01       	movw	r24, r28
   12f10:	b3 01       	movw	r22, r6
   12f12:	0e 94 29 a0 	call	0x14052	; 0x14052 <ungetc>
   12f16:	28 e1       	ldi	r18, 0x18	; 24
   12f18:	05 38       	cpi	r16, 0x85	; 133
   12f1a:	12 07       	cpc	r17, r18
   12f1c:	09 f0       	breq	.+2      	; 0x12f20 <conv_flt+0xa8>
   12f1e:	ec c0       	rjmp	.+472    	; 0x130f8 <conv_flt+0x280>
   12f20:	08 c0       	rjmp	.+16     	; 0x12f32 <conv_flt+0xba>
   12f22:	0f e7       	ldi	r16, 0x7F	; 127
   12f24:	18 e1       	ldi	r17, 0x18	; 24
   12f26:	f8 01       	movw	r30, r16
   12f28:	0f 5f       	subi	r16, 0xFF	; 255
   12f2a:	1f 4f       	sbci	r17, 0xFF	; 255
   12f2c:	d4 90       	lpm	r13, Z+
   12f2e:	dd 20       	and	r13, r13
   12f30:	f1 f6       	brne	.-68     	; 0x12eee <conv_flt+0x76>
   12f32:	02 58       	subi	r16, 0x82	; 130
   12f34:	18 41       	sbci	r17, 0x18	; 24
   12f36:	29 f0       	breq	.+10     	; 0x12f42 <conv_flt+0xca>
   12f38:	80 e0       	ldi	r24, 0x00	; 0
   12f3a:	90 e0       	ldi	r25, 0x00	; 0
   12f3c:	a0 e8       	ldi	r26, 0x80	; 128
   12f3e:	bf e7       	ldi	r27, 0x7F	; 127
   12f40:	cf c0       	rjmp	.+414    	; 0x130e0 <conv_flt+0x268>
   12f42:	80 e0       	ldi	r24, 0x00	; 0
   12f44:	90 e0       	ldi	r25, 0x00	; 0
   12f46:	a0 ec       	ldi	r26, 0xC0	; 192
   12f48:	bf e7       	ldi	r27, 0x7F	; 127
   12f4a:	ca c0       	rjmp	.+404    	; 0x130e0 <conv_flt+0x268>
   12f4c:	cc 24       	eor	r12, r12
   12f4e:	dd 24       	eor	r13, r13
   12f50:	88 24       	eor	r8, r8
   12f52:	99 24       	eor	r9, r9
   12f54:	54 01       	movw	r10, r8
   12f56:	ae 01       	movw	r20, r28
   12f58:	40 53       	subi	r20, 0x30	; 48
   12f5a:	24 2f       	mov	r18, r20
   12f5c:	4a 30       	cpi	r20, 0x0A	; 10
   12f5e:	38 f5       	brcc	.+78     	; 0x12fae <conv_flt+0x136>
   12f60:	52 e0       	ldi	r21, 0x02	; 2
   12f62:	55 2a       	or	r5, r21
   12f64:	85 2d       	mov	r24, r5
   12f66:	90 e0       	ldi	r25, 0x00	; 0
   12f68:	ac 01       	movw	r20, r24
   12f6a:	48 70       	andi	r20, 0x08	; 8
   12f6c:	50 70       	andi	r21, 0x00	; 0
   12f6e:	52 fe       	sbrs	r5, 2
   12f70:	06 c0       	rjmp	.+12     	; 0x12f7e <conv_flt+0x106>
   12f72:	45 2b       	or	r20, r21
   12f74:	11 f5       	brne	.+68     	; 0x12fba <conv_flt+0x142>
   12f76:	08 94       	sec
   12f78:	c1 1c       	adc	r12, r1
   12f7a:	d1 1c       	adc	r13, r1
   12f7c:	1e c0       	rjmp	.+60     	; 0x12fba <conv_flt+0x142>
   12f7e:	45 2b       	or	r20, r21
   12f80:	19 f0       	breq	.+6      	; 0x12f88 <conv_flt+0x110>
   12f82:	08 94       	sec
   12f84:	c1 08       	sbc	r12, r1
   12f86:	d1 08       	sbc	r13, r1
   12f88:	c5 01       	movw	r24, r10
   12f8a:	b4 01       	movw	r22, r8
   12f8c:	40 e2       	ldi	r20, 0x20	; 32
   12f8e:	0e 94 94 95 	call	0x12b28	; 0x12b28 <mulacc>
   12f92:	4b 01       	movw	r8, r22
   12f94:	5c 01       	movw	r10, r24
   12f96:	88 e9       	ldi	r24, 0x98	; 152
   12f98:	88 16       	cp	r8, r24
   12f9a:	89 e9       	ldi	r24, 0x99	; 153
   12f9c:	98 06       	cpc	r9, r24
   12f9e:	89 e9       	ldi	r24, 0x99	; 153
   12fa0:	a8 06       	cpc	r10, r24
   12fa2:	89 e1       	ldi	r24, 0x19	; 25
   12fa4:	b8 06       	cpc	r11, r24
   12fa6:	48 f0       	brcs	.+18     	; 0x12fba <conv_flt+0x142>
   12fa8:	94 e0       	ldi	r25, 0x04	; 4
   12faa:	59 2a       	or	r5, r25
   12fac:	06 c0       	rjmp	.+12     	; 0x12fba <conv_flt+0x142>
   12fae:	4e 3f       	cpi	r20, 0xFE	; 254
   12fb0:	81 f4       	brne	.+32     	; 0x12fd2 <conv_flt+0x15a>
   12fb2:	53 fc       	sbrc	r5, 3
   12fb4:	0e c0       	rjmp	.+28     	; 0x12fd2 <conv_flt+0x15a>
   12fb6:	e8 e0       	ldi	r30, 0x08	; 8
   12fb8:	5e 2a       	or	r5, r30
   12fba:	08 94       	sec
   12fbc:	e1 08       	sbc	r14, r1
   12fbe:	f1 08       	sbc	r15, r1
   12fc0:	e1 14       	cp	r14, r1
   12fc2:	f1 04       	cpc	r15, r1
   12fc4:	31 f0       	breq	.+12     	; 0x12fd2 <conv_flt+0x15a>
   12fc6:	c3 01       	movw	r24, r6
   12fc8:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12fcc:	ec 01       	movw	r28, r24
   12fce:	97 ff       	sbrs	r25, 7
   12fd0:	c2 cf       	rjmp	.-124    	; 0x12f56 <conv_flt+0xde>
   12fd2:	51 fe       	sbrs	r5, 1
   12fd4:	91 c0       	rjmp	.+290    	; 0x130f8 <conv_flt+0x280>
   12fd6:	c5 36       	cpi	r28, 0x65	; 101
   12fd8:	19 f0       	breq	.+6      	; 0x12fe0 <conv_flt+0x168>
   12fda:	c5 34       	cpi	r28, 0x45	; 69
   12fdc:	09 f0       	breq	.+2      	; 0x12fe0 <conv_flt+0x168>
   12fde:	46 c0       	rjmp	.+140    	; 0x1306c <conv_flt+0x1f4>
   12fe0:	08 94       	sec
   12fe2:	e1 08       	sbc	r14, r1
   12fe4:	f1 08       	sbc	r15, r1
   12fe6:	e1 14       	cp	r14, r1
   12fe8:	f1 04       	cpc	r15, r1
   12fea:	09 f4       	brne	.+2      	; 0x12fee <conv_flt+0x176>
   12fec:	85 c0       	rjmp	.+266    	; 0x130f8 <conv_flt+0x280>
   12fee:	c3 01       	movw	r24, r6
   12ff0:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   12ff4:	ec 01       	movw	r28, r24
   12ff6:	97 fd       	sbrc	r25, 7
   12ff8:	7f c0       	rjmp	.+254    	; 0x130f8 <conv_flt+0x280>
   12ffa:	8b 32       	cpi	r24, 0x2B	; 43
   12ffc:	21 f0       	breq	.+8      	; 0x13006 <conv_flt+0x18e>
   12ffe:	8d 32       	cpi	r24, 0x2D	; 45
   13000:	69 f4       	brne	.+26     	; 0x1301c <conv_flt+0x1a4>
   13002:	f0 e1       	ldi	r31, 0x10	; 16
   13004:	5f 2a       	or	r5, r31
   13006:	08 94       	sec
   13008:	e1 08       	sbc	r14, r1
   1300a:	f1 08       	sbc	r15, r1
   1300c:	e1 14       	cp	r14, r1
   1300e:	f1 04       	cpc	r15, r1
   13010:	09 f4       	brne	.+2      	; 0x13014 <conv_flt+0x19c>
   13012:	72 c0       	rjmp	.+228    	; 0x130f8 <conv_flt+0x280>
   13014:	c3 01       	movw	r24, r6
   13016:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   1301a:	ec 01       	movw	r28, r24
   1301c:	ce 01       	movw	r24, r28
   1301e:	c0 97       	sbiw	r24, 0x30	; 48
   13020:	0a 97       	sbiw	r24, 0x0a	; 10
   13022:	08 f0       	brcs	.+2      	; 0x13026 <conv_flt+0x1ae>
   13024:	69 c0       	rjmp	.+210    	; 0x130f8 <conv_flt+0x280>
   13026:	00 e0       	ldi	r16, 0x00	; 0
   13028:	10 e0       	ldi	r17, 0x00	; 0
   1302a:	b8 01       	movw	r22, r16
   1302c:	88 27       	eor	r24, r24
   1302e:	77 fd       	sbrc	r23, 7
   13030:	80 95       	com	r24
   13032:	98 2f       	mov	r25, r24
   13034:	ae 01       	movw	r20, r28
   13036:	40 53       	subi	r20, 0x30	; 48
   13038:	24 2f       	mov	r18, r20
   1303a:	40 e2       	ldi	r20, 0x20	; 32
   1303c:	0e 94 94 95 	call	0x12b28	; 0x12b28 <mulacc>
   13040:	8b 01       	movw	r16, r22
   13042:	08 94       	sec
   13044:	e1 08       	sbc	r14, r1
   13046:	f1 08       	sbc	r15, r1
   13048:	e1 14       	cp	r14, r1
   1304a:	f1 04       	cpc	r15, r1
   1304c:	39 f0       	breq	.+14     	; 0x1305c <conv_flt+0x1e4>
   1304e:	c3 01       	movw	r24, r6
   13050:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   13054:	ec 01       	movw	r28, r24
   13056:	c0 97       	sbiw	r24, 0x30	; 48
   13058:	0a 97       	sbiw	r24, 0x0a	; 10
   1305a:	38 f3       	brcs	.-50     	; 0x1302a <conv_flt+0x1b2>
   1305c:	b8 01       	movw	r22, r16
   1305e:	54 fe       	sbrs	r5, 4
   13060:	03 c0       	rjmp	.+6      	; 0x13068 <conv_flt+0x1f0>
   13062:	70 95       	com	r23
   13064:	61 95       	neg	r22
   13066:	7f 4f       	sbci	r23, 0xFF	; 255
   13068:	c6 0e       	add	r12, r22
   1306a:	d7 1e       	adc	r13, r23
   1306c:	ef 28       	or	r14, r15
   1306e:	31 f0       	breq	.+12     	; 0x1307c <conv_flt+0x204>
   13070:	d7 fd       	sbrc	r29, 7
   13072:	04 c0       	rjmp	.+8      	; 0x1307c <conv_flt+0x204>
   13074:	ce 01       	movw	r24, r28
   13076:	b3 01       	movw	r22, r6
   13078:	0e 94 29 a0 	call	0x14052	; 0x14052 <ungetc>
   1307c:	c5 01       	movw	r24, r10
   1307e:	b4 01       	movw	r22, r8
   13080:	0e 94 d0 9a 	call	0x135a0	; 0x135a0 <__floatunsisf>
   13084:	d7 fe       	sbrs	r13, 7
   13086:	0d c0       	rjmp	.+26     	; 0x130a2 <conv_flt+0x22a>
   13088:	ae e9       	ldi	r26, 0x9E	; 158
   1308a:	ea 2e       	mov	r14, r26
   1308c:	a8 e1       	ldi	r26, 0x18	; 24
   1308e:	fa 2e       	mov	r15, r26
   13090:	d0 94       	com	r13
   13092:	c1 94       	neg	r12
   13094:	d1 08       	sbc	r13, r1
   13096:	d3 94       	inc	r13
   13098:	c0 e2       	ldi	r28, 0x20	; 32
   1309a:	d0 e0       	ldi	r29, 0x00	; 0
   1309c:	00 e0       	ldi	r16, 0x00	; 0
   1309e:	10 e0       	ldi	r17, 0x00	; 0
   130a0:	0e c0       	rjmp	.+28     	; 0x130be <conv_flt+0x246>
   130a2:	f6 eb       	ldi	r31, 0xB6	; 182
   130a4:	ef 2e       	mov	r14, r31
   130a6:	f8 e1       	ldi	r31, 0x18	; 24
   130a8:	ff 2e       	mov	r15, r31
   130aa:	f6 cf       	rjmp	.-20     	; 0x13098 <conv_flt+0x220>
   130ac:	f7 01       	movw	r30, r14
   130ae:	25 91       	lpm	r18, Z+
   130b0:	35 91       	lpm	r19, Z+
   130b2:	45 91       	lpm	r20, Z+
   130b4:	54 91       	lpm	r21, Z+
   130b6:	0e 94 d9 9b 	call	0x137b2	; 0x137b2 <__mulsf3>
   130ba:	cc 1a       	sub	r12, r28
   130bc:	dd 0a       	sbc	r13, r29
   130be:	cc 16       	cp	r12, r28
   130c0:	dd 06       	cpc	r13, r29
   130c2:	a0 f7       	brcc	.-24     	; 0x130ac <conv_flt+0x234>
   130c4:	d6 95       	lsr	r29
   130c6:	c7 95       	ror	r28
   130c8:	0f 5f       	subi	r16, 0xFF	; 255
   130ca:	1f 4f       	sbci	r17, 0xFF	; 255
   130cc:	06 30       	cpi	r16, 0x06	; 6
   130ce:	11 05       	cpc	r17, r1
   130d0:	29 f0       	breq	.+10     	; 0x130dc <conv_flt+0x264>
   130d2:	ec ef       	ldi	r30, 0xFC	; 252
   130d4:	ff ef       	ldi	r31, 0xFF	; 255
   130d6:	ee 0e       	add	r14, r30
   130d8:	ff 1e       	adc	r15, r31
   130da:	f1 cf       	rjmp	.-30     	; 0x130be <conv_flt+0x246>
   130dc:	dc 01       	movw	r26, r24
   130de:	cb 01       	movw	r24, r22
   130e0:	57 fc       	sbrc	r5, 7
   130e2:	b0 58       	subi	r27, 0x80	; 128
   130e4:	21 14       	cp	r2, r1
   130e6:	31 04       	cpc	r3, r1
   130e8:	29 f0       	breq	.+10     	; 0x130f4 <conv_flt+0x27c>
   130ea:	f1 01       	movw	r30, r2
   130ec:	80 83       	st	Z, r24
   130ee:	91 83       	std	Z+1, r25	; 0x01
   130f0:	a2 83       	std	Z+2, r26	; 0x02
   130f2:	b3 83       	std	Z+3, r27	; 0x03
   130f4:	81 e0       	ldi	r24, 0x01	; 1
   130f6:	01 c0       	rjmp	.+2      	; 0x130fa <conv_flt+0x282>
   130f8:	80 e0       	ldi	r24, 0x00	; 0
   130fa:	df 91       	pop	r29
   130fc:	cf 91       	pop	r28
   130fe:	1f 91       	pop	r17
   13100:	0f 91       	pop	r16
   13102:	ff 90       	pop	r15
   13104:	ef 90       	pop	r14
   13106:	df 90       	pop	r13
   13108:	cf 90       	pop	r12
   1310a:	bf 90       	pop	r11
   1310c:	af 90       	pop	r10
   1310e:	9f 90       	pop	r9
   13110:	8f 90       	pop	r8
   13112:	7f 90       	pop	r7
   13114:	6f 90       	pop	r6
   13116:	5f 90       	pop	r5
   13118:	3f 90       	pop	r3
   1311a:	2f 90       	pop	r2
   1311c:	08 95       	ret

0001311e <vfscanf>:
   1311e:	5f 92       	push	r5
   13120:	6f 92       	push	r6
   13122:	7f 92       	push	r7
   13124:	8f 92       	push	r8
   13126:	9f 92       	push	r9
   13128:	af 92       	push	r10
   1312a:	bf 92       	push	r11
   1312c:	cf 92       	push	r12
   1312e:	df 92       	push	r13
   13130:	ef 92       	push	r14
   13132:	ff 92       	push	r15
   13134:	0f 93       	push	r16
   13136:	1f 93       	push	r17
   13138:	cf 93       	push	r28
   1313a:	df 93       	push	r29
   1313c:	4c 01       	movw	r8, r24
   1313e:	5b 01       	movw	r10, r22
   13140:	3a 01       	movw	r6, r20
   13142:	fc 01       	movw	r30, r24
   13144:	17 82       	std	Z+7, r1	; 0x07
   13146:	16 82       	std	Z+6, r1	; 0x06
   13148:	55 24       	eor	r5, r5
   1314a:	04 c1       	rjmp	.+520    	; 0x13354 <vfscanf+0x236>
   1314c:	81 2f       	mov	r24, r17
   1314e:	90 e0       	ldi	r25, 0x00	; 0
   13150:	0e 94 a8 9e 	call	0x13d50	; 0x13d50 <isspace>
   13154:	89 2b       	or	r24, r25
   13156:	21 f0       	breq	.+8      	; 0x13160 <vfscanf+0x42>
   13158:	c4 01       	movw	r24, r8
   1315a:	0e 94 c2 95 	call	0x12b84	; 0x12b84 <skip_spaces>
   1315e:	fa c0       	rjmp	.+500    	; 0x13354 <vfscanf+0x236>
   13160:	15 32       	cpi	r17, 0x25	; 37
   13162:	49 f4       	brne	.+18     	; 0x13176 <vfscanf+0x58>
   13164:	f5 01       	movw	r30, r10
   13166:	f3 fc       	sbrc	r15, 3
   13168:	65 91       	lpm	r22, Z+
   1316a:	f3 fe       	sbrs	r15, 3
   1316c:	61 91       	ld	r22, Z+
   1316e:	5f 01       	movw	r10, r30
   13170:	65 32       	cpi	r22, 0x25	; 37
   13172:	69 f4       	brne	.+26     	; 0x1318e <vfscanf+0x70>
   13174:	15 e2       	ldi	r17, 0x25	; 37
   13176:	c4 01       	movw	r24, r8
   13178:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   1317c:	97 fd       	sbrc	r25, 7
   1317e:	f6 c0       	rjmp	.+492    	; 0x1336c <vfscanf+0x24e>
   13180:	18 17       	cp	r17, r24
   13182:	09 f4       	brne	.+2      	; 0x13186 <vfscanf+0x68>
   13184:	e7 c0       	rjmp	.+462    	; 0x13354 <vfscanf+0x236>
   13186:	b4 01       	movw	r22, r8
   13188:	0e 94 29 a0 	call	0x14052	; 0x14052 <ungetc>
   1318c:	f4 c0       	rjmp	.+488    	; 0x13376 <vfscanf+0x258>
   1318e:	6a 32       	cpi	r22, 0x2A	; 42
   13190:	19 f0       	breq	.+6      	; 0x13198 <vfscanf+0x7a>
   13192:	16 2f       	mov	r17, r22
   13194:	00 e0       	ldi	r16, 0x00	; 0
   13196:	06 c0       	rjmp	.+12     	; 0x131a4 <vfscanf+0x86>
   13198:	f3 fc       	sbrc	r15, 3
   1319a:	15 91       	lpm	r17, Z+
   1319c:	f3 fe       	sbrs	r15, 3
   1319e:	11 91       	ld	r17, Z+
   131a0:	5f 01       	movw	r10, r30
   131a2:	01 e0       	ldi	r16, 0x01	; 1
   131a4:	cc 24       	eor	r12, r12
   131a6:	dd 24       	eor	r13, r13
   131a8:	0e c0       	rjmp	.+28     	; 0x131c6 <vfscanf+0xa8>
   131aa:	02 60       	ori	r16, 0x02	; 2
   131ac:	b6 01       	movw	r22, r12
   131ae:	80 e0       	ldi	r24, 0x00	; 0
   131b0:	90 e0       	ldi	r25, 0x00	; 0
   131b2:	40 e2       	ldi	r20, 0x20	; 32
   131b4:	0e 94 94 95 	call	0x12b28	; 0x12b28 <mulacc>
   131b8:	6b 01       	movw	r12, r22
   131ba:	f5 01       	movw	r30, r10
   131bc:	f3 fc       	sbrc	r15, 3
   131be:	15 91       	lpm	r17, Z+
   131c0:	f3 fe       	sbrs	r15, 3
   131c2:	11 91       	ld	r17, Z+
   131c4:	5f 01       	movw	r10, r30
   131c6:	21 2f       	mov	r18, r17
   131c8:	20 53       	subi	r18, 0x30	; 48
   131ca:	2a 30       	cpi	r18, 0x0A	; 10
   131cc:	70 f3       	brcs	.-36     	; 0x131aa <vfscanf+0x8c>
   131ce:	01 fd       	sbrc	r16, 1
   131d0:	04 c0       	rjmp	.+8      	; 0x131da <vfscanf+0xbc>
   131d2:	cc 24       	eor	r12, r12
   131d4:	ca 94       	dec	r12
   131d6:	dc 2c       	mov	r13, r12
   131d8:	04 c0       	rjmp	.+8      	; 0x131e2 <vfscanf+0xc4>
   131da:	c1 14       	cp	r12, r1
   131dc:	d1 04       	cpc	r13, r1
   131de:	09 f4       	brne	.+2      	; 0x131e2 <vfscanf+0xc4>
   131e0:	ca c0       	rjmp	.+404    	; 0x13376 <vfscanf+0x258>
   131e2:	18 36       	cpi	r17, 0x68	; 104
   131e4:	21 f0       	breq	.+8      	; 0x131ee <vfscanf+0xd0>
   131e6:	1c 36       	cpi	r17, 0x6C	; 108
   131e8:	99 f4       	brne	.+38     	; 0x13210 <vfscanf+0xf2>
   131ea:	f5 01       	movw	r30, r10
   131ec:	0b c0       	rjmp	.+22     	; 0x13204 <vfscanf+0xe6>
   131ee:	f5 01       	movw	r30, r10
   131f0:	f3 fc       	sbrc	r15, 3
   131f2:	65 91       	lpm	r22, Z+
   131f4:	f3 fe       	sbrs	r15, 3
   131f6:	61 91       	ld	r22, Z+
   131f8:	68 36       	cpi	r22, 0x68	; 104
   131fa:	19 f0       	breq	.+6      	; 0x13202 <vfscanf+0xe4>
   131fc:	5f 01       	movw	r10, r30
   131fe:	16 2f       	mov	r17, r22
   13200:	07 c0       	rjmp	.+14     	; 0x13210 <vfscanf+0xf2>
   13202:	08 60       	ori	r16, 0x08	; 8
   13204:	04 60       	ori	r16, 0x04	; 4
   13206:	f3 fc       	sbrc	r15, 3
   13208:	15 91       	lpm	r17, Z+
   1320a:	f3 fe       	sbrs	r15, 3
   1320c:	11 91       	ld	r17, Z+
   1320e:	5f 01       	movw	r10, r30
   13210:	11 23       	and	r17, r17
   13212:	09 f4       	brne	.+2      	; 0x13216 <vfscanf+0xf8>
   13214:	b0 c0       	rjmp	.+352    	; 0x13376 <vfscanf+0x258>
   13216:	8d e6       	ldi	r24, 0x6D	; 109
   13218:	98 e1       	ldi	r25, 0x18	; 24
   1321a:	61 2f       	mov	r22, r17
   1321c:	70 e0       	ldi	r23, 0x00	; 0
   1321e:	0e 94 b8 9e 	call	0x13d70	; 0x13d70 <strchr_P>
   13222:	89 2b       	or	r24, r25
   13224:	09 f4       	brne	.+2      	; 0x13228 <vfscanf+0x10a>
   13226:	a7 c0       	rjmp	.+334    	; 0x13376 <vfscanf+0x258>
   13228:	80 2f       	mov	r24, r16
   1322a:	00 ff       	sbrs	r16, 0
   1322c:	03 c0       	rjmp	.+6      	; 0x13234 <vfscanf+0x116>
   1322e:	ee 24       	eor	r14, r14
   13230:	ff 24       	eor	r15, r15
   13232:	07 c0       	rjmp	.+14     	; 0x13242 <vfscanf+0x124>
   13234:	f3 01       	movw	r30, r6
   13236:	e0 80       	ld	r14, Z
   13238:	f1 80       	ldd	r15, Z+1	; 0x01
   1323a:	22 e0       	ldi	r18, 0x02	; 2
   1323c:	30 e0       	ldi	r19, 0x00	; 0
   1323e:	62 0e       	add	r6, r18
   13240:	73 1e       	adc	r7, r19
   13242:	1e 36       	cpi	r17, 0x6E	; 110
   13244:	51 f4       	brne	.+20     	; 0x1325a <vfscanf+0x13c>
   13246:	f4 01       	movw	r30, r8
   13248:	46 81       	ldd	r20, Z+6	; 0x06
   1324a:	57 81       	ldd	r21, Z+7	; 0x07
   1324c:	60 e0       	ldi	r22, 0x00	; 0
   1324e:	70 e0       	ldi	r23, 0x00	; 0
   13250:	c7 01       	movw	r24, r14
   13252:	20 2f       	mov	r18, r16
   13254:	0e 94 88 95 	call	0x12b10	; 0x12b10 <putval>
   13258:	7d c0       	rjmp	.+250    	; 0x13354 <vfscanf+0x236>
   1325a:	13 36       	cpi	r17, 0x63	; 99
   1325c:	b9 f4       	brne	.+46     	; 0x1328c <vfscanf+0x16e>
   1325e:	81 fd       	sbrc	r24, 1
   13260:	03 c0       	rjmp	.+6      	; 0x13268 <vfscanf+0x14a>
   13262:	11 e0       	ldi	r17, 0x01	; 1
   13264:	c1 2e       	mov	r12, r17
   13266:	d1 2c       	mov	r13, r1
   13268:	c4 01       	movw	r24, r8
   1326a:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   1326e:	97 fd       	sbrc	r25, 7
   13270:	7d c0       	rjmp	.+250    	; 0x1336c <vfscanf+0x24e>
   13272:	e1 14       	cp	r14, r1
   13274:	f1 04       	cpc	r15, r1
   13276:	19 f0       	breq	.+6      	; 0x1327e <vfscanf+0x160>
   13278:	f7 01       	movw	r30, r14
   1327a:	81 93       	st	Z+, r24
   1327c:	7f 01       	movw	r14, r30
   1327e:	08 94       	sec
   13280:	c1 08       	sbc	r12, r1
   13282:	d1 08       	sbc	r13, r1
   13284:	c1 14       	cp	r12, r1
   13286:	d1 04       	cpc	r13, r1
   13288:	79 f7       	brne	.-34     	; 0x13268 <vfscanf+0x14a>
   1328a:	62 c0       	rjmp	.+196    	; 0x13350 <vfscanf+0x232>
   1328c:	1b 35       	cpi	r17, 0x5B	; 91
   1328e:	59 f4       	brne	.+22     	; 0x132a6 <vfscanf+0x188>
   13290:	c4 01       	movw	r24, r8
   13292:	b6 01       	movw	r22, r12
   13294:	a7 01       	movw	r20, r14
   13296:	95 01       	movw	r18, r10
   13298:	0e 94 6f 96 	call	0x12cde	; 0x12cde <conv_brk>
   1329c:	5c 01       	movw	r10, r24
   1329e:	00 97       	sbiw	r24, 0x00	; 0
   132a0:	09 f0       	breq	.+2      	; 0x132a4 <vfscanf+0x186>
   132a2:	56 c0       	rjmp	.+172    	; 0x13350 <vfscanf+0x232>
   132a4:	50 c0       	rjmp	.+160    	; 0x13346 <vfscanf+0x228>
   132a6:	c4 01       	movw	r24, r8
   132a8:	0e 94 c2 95 	call	0x12b84	; 0x12b84 <skip_spaces>
   132ac:	97 fd       	sbrc	r25, 7
   132ae:	5e c0       	rjmp	.+188    	; 0x1336c <vfscanf+0x24e>
   132b0:	1f 36       	cpi	r17, 0x6F	; 111
   132b2:	d1 f1       	breq	.+116    	; 0x13328 <vfscanf+0x20a>
   132b4:	10 37       	cpi	r17, 0x70	; 112
   132b6:	38 f4       	brcc	.+14     	; 0x132c6 <vfscanf+0x1a8>
   132b8:	14 36       	cpi	r17, 0x64	; 100
   132ba:	a1 f1       	breq	.+104    	; 0x13324 <vfscanf+0x206>
   132bc:	19 36       	cpi	r17, 0x69	; 105
   132be:	a9 f1       	breq	.+106    	; 0x1332a <vfscanf+0x20c>
   132c0:	18 35       	cpi	r17, 0x58	; 88
   132c2:	d1 f5       	brne	.+116    	; 0x13338 <vfscanf+0x21a>
   132c4:	2d c0       	rjmp	.+90     	; 0x13320 <vfscanf+0x202>
   132c6:	13 37       	cpi	r17, 0x73	; 115
   132c8:	51 f0       	breq	.+20     	; 0x132de <vfscanf+0x1c0>
   132ca:	14 37       	cpi	r17, 0x74	; 116
   132cc:	18 f4       	brcc	.+6      	; 0x132d4 <vfscanf+0x1b6>
   132ce:	10 37       	cpi	r17, 0x70	; 112
   132d0:	99 f5       	brne	.+102    	; 0x13338 <vfscanf+0x21a>
   132d2:	26 c0       	rjmp	.+76     	; 0x13320 <vfscanf+0x202>
   132d4:	15 37       	cpi	r17, 0x75	; 117
   132d6:	31 f1       	breq	.+76     	; 0x13324 <vfscanf+0x206>
   132d8:	18 37       	cpi	r17, 0x78	; 120
   132da:	71 f5       	brne	.+92     	; 0x13338 <vfscanf+0x21a>
   132dc:	21 c0       	rjmp	.+66     	; 0x13320 <vfscanf+0x202>
   132de:	c4 01       	movw	r24, r8
   132e0:	0e 94 01 9f 	call	0x13e02	; 0x13e02 <fgetc>
   132e4:	ec 01       	movw	r28, r24
   132e6:	97 fd       	sbrc	r25, 7
   132e8:	15 c0       	rjmp	.+42     	; 0x13314 <vfscanf+0x1f6>
   132ea:	0e 94 a8 9e 	call	0x13d50	; 0x13d50 <isspace>
   132ee:	89 2b       	or	r24, r25
   132f0:	29 f0       	breq	.+10     	; 0x132fc <vfscanf+0x1de>
   132f2:	ce 01       	movw	r24, r28
   132f4:	b4 01       	movw	r22, r8
   132f6:	0e 94 29 a0 	call	0x14052	; 0x14052 <ungetc>
   132fa:	0c c0       	rjmp	.+24     	; 0x13314 <vfscanf+0x1f6>
   132fc:	e1 14       	cp	r14, r1
   132fe:	f1 04       	cpc	r15, r1
   13300:	19 f0       	breq	.+6      	; 0x13308 <vfscanf+0x1ea>
   13302:	f7 01       	movw	r30, r14
   13304:	c1 93       	st	Z+, r28
   13306:	7f 01       	movw	r14, r30
   13308:	08 94       	sec
   1330a:	c1 08       	sbc	r12, r1
   1330c:	d1 08       	sbc	r13, r1
   1330e:	c1 14       	cp	r12, r1
   13310:	d1 04       	cpc	r13, r1
   13312:	29 f7       	brne	.-54     	; 0x132de <vfscanf+0x1c0>
   13314:	e1 14       	cp	r14, r1
   13316:	f1 04       	cpc	r15, r1
   13318:	d9 f0       	breq	.+54     	; 0x13350 <vfscanf+0x232>
   1331a:	f7 01       	movw	r30, r14
   1331c:	10 82       	st	Z, r1
   1331e:	18 c0       	rjmp	.+48     	; 0x13350 <vfscanf+0x232>
   13320:	00 64       	ori	r16, 0x40	; 64
   13322:	03 c0       	rjmp	.+6      	; 0x1332a <vfscanf+0x20c>
   13324:	00 62       	ori	r16, 0x20	; 32
   13326:	01 c0       	rjmp	.+2      	; 0x1332a <vfscanf+0x20c>
   13328:	00 61       	ori	r16, 0x10	; 16
   1332a:	c4 01       	movw	r24, r8
   1332c:	b6 01       	movw	r22, r12
   1332e:	a7 01       	movw	r20, r14
   13330:	20 2f       	mov	r18, r16
   13332:	0e 94 db 95 	call	0x12bb6	; 0x12bb6 <conv_int>
   13336:	05 c0       	rjmp	.+10     	; 0x13342 <vfscanf+0x224>
   13338:	c4 01       	movw	r24, r8
   1333a:	b6 01       	movw	r22, r12
   1333c:	a7 01       	movw	r20, r14
   1333e:	0e 94 3c 97 	call	0x12e78	; 0x12e78 <conv_flt>
   13342:	88 23       	and	r24, r24
   13344:	29 f4       	brne	.+10     	; 0x13350 <vfscanf+0x232>
   13346:	f4 01       	movw	r30, r8
   13348:	83 81       	ldd	r24, Z+3	; 0x03
   1334a:	80 73       	andi	r24, 0x30	; 48
   1334c:	79 f4       	brne	.+30     	; 0x1336c <vfscanf+0x24e>
   1334e:	13 c0       	rjmp	.+38     	; 0x13376 <vfscanf+0x258>
   13350:	00 ff       	sbrs	r16, 0
   13352:	53 94       	inc	r5
   13354:	f4 01       	movw	r30, r8
   13356:	f3 80       	ldd	r15, Z+3	; 0x03
   13358:	f5 01       	movw	r30, r10
   1335a:	f3 fc       	sbrc	r15, 3
   1335c:	15 91       	lpm	r17, Z+
   1335e:	f3 fe       	sbrs	r15, 3
   13360:	11 91       	ld	r17, Z+
   13362:	5f 01       	movw	r10, r30
   13364:	11 23       	and	r17, r17
   13366:	09 f0       	breq	.+2      	; 0x1336a <vfscanf+0x24c>
   13368:	f1 ce       	rjmp	.-542    	; 0x1314c <vfscanf+0x2e>
   1336a:	05 c0       	rjmp	.+10     	; 0x13376 <vfscanf+0x258>
   1336c:	55 20       	and	r5, r5
   1336e:	19 f4       	brne	.+6      	; 0x13376 <vfscanf+0x258>
   13370:	2f ef       	ldi	r18, 0xFF	; 255
   13372:	3f ef       	ldi	r19, 0xFF	; 255
   13374:	02 c0       	rjmp	.+4      	; 0x1337a <vfscanf+0x25c>
   13376:	25 2d       	mov	r18, r5
   13378:	30 e0       	ldi	r19, 0x00	; 0
   1337a:	c9 01       	movw	r24, r18
   1337c:	df 91       	pop	r29
   1337e:	cf 91       	pop	r28
   13380:	1f 91       	pop	r17
   13382:	0f 91       	pop	r16
   13384:	ff 90       	pop	r15
   13386:	ef 90       	pop	r14
   13388:	df 90       	pop	r13
   1338a:	cf 90       	pop	r12
   1338c:	bf 90       	pop	r11
   1338e:	af 90       	pop	r10
   13390:	9f 90       	pop	r9
   13392:	8f 90       	pop	r8
   13394:	7f 90       	pop	r7
   13396:	6f 90       	pop	r6
   13398:	5f 90       	pop	r5
   1339a:	08 95       	ret

0001339c <__subsf3>:
   1339c:	50 58       	subi	r21, 0x80	; 128

0001339e <__addsf3>:
   1339e:	bb 27       	eor	r27, r27
   133a0:	aa 27       	eor	r26, r26
   133a2:	0e d0       	rcall	.+28     	; 0x133c0 <__addsf3x>
   133a4:	b1 c1       	rjmp	.+866    	; 0x13708 <__fp_round>
   133a6:	a2 d1       	rcall	.+836    	; 0x136ec <__fp_pscA>
   133a8:	30 f0       	brcs	.+12     	; 0x133b6 <__addsf3+0x18>
   133aa:	a7 d1       	rcall	.+846    	; 0x136fa <__fp_pscB>
   133ac:	20 f0       	brcs	.+8      	; 0x133b6 <__addsf3+0x18>
   133ae:	31 f4       	brne	.+12     	; 0x133bc <__addsf3+0x1e>
   133b0:	9f 3f       	cpi	r25, 0xFF	; 255
   133b2:	11 f4       	brne	.+4      	; 0x133b8 <__addsf3+0x1a>
   133b4:	1e f4       	brtc	.+6      	; 0x133bc <__addsf3+0x1e>
   133b6:	97 c1       	rjmp	.+814    	; 0x136e6 <__fp_nan>
   133b8:	0e f4       	brtc	.+2      	; 0x133bc <__addsf3+0x1e>
   133ba:	e0 95       	com	r30
   133bc:	e7 fb       	bst	r30, 7
   133be:	64 c1       	rjmp	.+712    	; 0x13688 <__fp_inf>

000133c0 <__addsf3x>:
   133c0:	e9 2f       	mov	r30, r25
   133c2:	b3 d1       	rcall	.+870    	; 0x1372a <__fp_split3>
   133c4:	80 f3       	brcs	.-32     	; 0x133a6 <__addsf3+0x8>
   133c6:	ba 17       	cp	r27, r26
   133c8:	62 07       	cpc	r22, r18
   133ca:	73 07       	cpc	r23, r19
   133cc:	84 07       	cpc	r24, r20
   133ce:	95 07       	cpc	r25, r21
   133d0:	18 f0       	brcs	.+6      	; 0x133d8 <__addsf3x+0x18>
   133d2:	71 f4       	brne	.+28     	; 0x133f0 <__addsf3x+0x30>
   133d4:	9e f5       	brtc	.+102    	; 0x1343c <__addsf3x+0x7c>
   133d6:	e2 c1       	rjmp	.+964    	; 0x1379c <__fp_zero>
   133d8:	0e f4       	brtc	.+2      	; 0x133dc <__addsf3x+0x1c>
   133da:	e0 95       	com	r30
   133dc:	0b 2e       	mov	r0, r27
   133de:	ba 2f       	mov	r27, r26
   133e0:	a0 2d       	mov	r26, r0
   133e2:	0b 01       	movw	r0, r22
   133e4:	b9 01       	movw	r22, r18
   133e6:	90 01       	movw	r18, r0
   133e8:	0c 01       	movw	r0, r24
   133ea:	ca 01       	movw	r24, r20
   133ec:	a0 01       	movw	r20, r0
   133ee:	11 24       	eor	r1, r1
   133f0:	ff 27       	eor	r31, r31
   133f2:	59 1b       	sub	r21, r25
   133f4:	99 f0       	breq	.+38     	; 0x1341c <__addsf3x+0x5c>
   133f6:	59 3f       	cpi	r21, 0xF9	; 249
   133f8:	50 f4       	brcc	.+20     	; 0x1340e <__addsf3x+0x4e>
   133fa:	50 3e       	cpi	r21, 0xE0	; 224
   133fc:	68 f1       	brcs	.+90     	; 0x13458 <__addsf3x+0x98>
   133fe:	1a 16       	cp	r1, r26
   13400:	f0 40       	sbci	r31, 0x00	; 0
   13402:	a2 2f       	mov	r26, r18
   13404:	23 2f       	mov	r18, r19
   13406:	34 2f       	mov	r19, r20
   13408:	44 27       	eor	r20, r20
   1340a:	58 5f       	subi	r21, 0xF8	; 248
   1340c:	f3 cf       	rjmp	.-26     	; 0x133f4 <__addsf3x+0x34>
   1340e:	46 95       	lsr	r20
   13410:	37 95       	ror	r19
   13412:	27 95       	ror	r18
   13414:	a7 95       	ror	r26
   13416:	f0 40       	sbci	r31, 0x00	; 0
   13418:	53 95       	inc	r21
   1341a:	c9 f7       	brne	.-14     	; 0x1340e <__addsf3x+0x4e>
   1341c:	7e f4       	brtc	.+30     	; 0x1343c <__addsf3x+0x7c>
   1341e:	1f 16       	cp	r1, r31
   13420:	ba 0b       	sbc	r27, r26
   13422:	62 0b       	sbc	r22, r18
   13424:	73 0b       	sbc	r23, r19
   13426:	84 0b       	sbc	r24, r20
   13428:	ba f0       	brmi	.+46     	; 0x13458 <__addsf3x+0x98>
   1342a:	91 50       	subi	r25, 0x01	; 1
   1342c:	a1 f0       	breq	.+40     	; 0x13456 <__addsf3x+0x96>
   1342e:	ff 0f       	add	r31, r31
   13430:	bb 1f       	adc	r27, r27
   13432:	66 1f       	adc	r22, r22
   13434:	77 1f       	adc	r23, r23
   13436:	88 1f       	adc	r24, r24
   13438:	c2 f7       	brpl	.-16     	; 0x1342a <__addsf3x+0x6a>
   1343a:	0e c0       	rjmp	.+28     	; 0x13458 <__addsf3x+0x98>
   1343c:	ba 0f       	add	r27, r26
   1343e:	62 1f       	adc	r22, r18
   13440:	73 1f       	adc	r23, r19
   13442:	84 1f       	adc	r24, r20
   13444:	48 f4       	brcc	.+18     	; 0x13458 <__addsf3x+0x98>
   13446:	87 95       	ror	r24
   13448:	77 95       	ror	r23
   1344a:	67 95       	ror	r22
   1344c:	b7 95       	ror	r27
   1344e:	f7 95       	ror	r31
   13450:	9e 3f       	cpi	r25, 0xFE	; 254
   13452:	08 f0       	brcs	.+2      	; 0x13456 <__addsf3x+0x96>
   13454:	b3 cf       	rjmp	.-154    	; 0x133bc <__addsf3+0x1e>
   13456:	93 95       	inc	r25
   13458:	88 0f       	add	r24, r24
   1345a:	08 f0       	brcs	.+2      	; 0x1345e <__addsf3x+0x9e>
   1345c:	99 27       	eor	r25, r25
   1345e:	ee 0f       	add	r30, r30
   13460:	97 95       	ror	r25
   13462:	87 95       	ror	r24
   13464:	08 95       	ret

00013466 <__cmpsf2>:
   13466:	ec d0       	rcall	.+472    	; 0x13640 <__fp_cmp>
   13468:	08 f4       	brcc	.+2      	; 0x1346c <__cmpsf2+0x6>
   1346a:	81 e0       	ldi	r24, 0x01	; 1
   1346c:	08 95       	ret

0001346e <__divsf3>:
   1346e:	0c d0       	rcall	.+24     	; 0x13488 <__divsf3x>
   13470:	4b c1       	rjmp	.+662    	; 0x13708 <__fp_round>
   13472:	43 d1       	rcall	.+646    	; 0x136fa <__fp_pscB>
   13474:	40 f0       	brcs	.+16     	; 0x13486 <__divsf3+0x18>
   13476:	3a d1       	rcall	.+628    	; 0x136ec <__fp_pscA>
   13478:	30 f0       	brcs	.+12     	; 0x13486 <__divsf3+0x18>
   1347a:	21 f4       	brne	.+8      	; 0x13484 <__divsf3+0x16>
   1347c:	5f 3f       	cpi	r21, 0xFF	; 255
   1347e:	19 f0       	breq	.+6      	; 0x13486 <__divsf3+0x18>
   13480:	03 c1       	rjmp	.+518    	; 0x13688 <__fp_inf>
   13482:	51 11       	cpse	r21, r1
   13484:	8c c1       	rjmp	.+792    	; 0x1379e <__fp_szero>
   13486:	2f c1       	rjmp	.+606    	; 0x136e6 <__fp_nan>

00013488 <__divsf3x>:
   13488:	50 d1       	rcall	.+672    	; 0x1372a <__fp_split3>
   1348a:	98 f3       	brcs	.-26     	; 0x13472 <__divsf3+0x4>

0001348c <__divsf3_pse>:
   1348c:	99 23       	and	r25, r25
   1348e:	c9 f3       	breq	.-14     	; 0x13482 <__divsf3+0x14>
   13490:	55 23       	and	r21, r21
   13492:	b1 f3       	breq	.-20     	; 0x13480 <__divsf3+0x12>
   13494:	95 1b       	sub	r25, r21
   13496:	55 0b       	sbc	r21, r21
   13498:	bb 27       	eor	r27, r27
   1349a:	aa 27       	eor	r26, r26
   1349c:	62 17       	cp	r22, r18
   1349e:	73 07       	cpc	r23, r19
   134a0:	84 07       	cpc	r24, r20
   134a2:	38 f0       	brcs	.+14     	; 0x134b2 <__divsf3_pse+0x26>
   134a4:	9f 5f       	subi	r25, 0xFF	; 255
   134a6:	5f 4f       	sbci	r21, 0xFF	; 255
   134a8:	22 0f       	add	r18, r18
   134aa:	33 1f       	adc	r19, r19
   134ac:	44 1f       	adc	r20, r20
   134ae:	aa 1f       	adc	r26, r26
   134b0:	a9 f3       	breq	.-22     	; 0x1349c <__divsf3_pse+0x10>
   134b2:	33 d0       	rcall	.+102    	; 0x1351a <__divsf3_pse+0x8e>
   134b4:	0e 2e       	mov	r0, r30
   134b6:	3a f0       	brmi	.+14     	; 0x134c6 <__divsf3_pse+0x3a>
   134b8:	e0 e8       	ldi	r30, 0x80	; 128
   134ba:	30 d0       	rcall	.+96     	; 0x1351c <__divsf3_pse+0x90>
   134bc:	91 50       	subi	r25, 0x01	; 1
   134be:	50 40       	sbci	r21, 0x00	; 0
   134c0:	e6 95       	lsr	r30
   134c2:	00 1c       	adc	r0, r0
   134c4:	ca f7       	brpl	.-14     	; 0x134b8 <__divsf3_pse+0x2c>
   134c6:	29 d0       	rcall	.+82     	; 0x1351a <__divsf3_pse+0x8e>
   134c8:	fe 2f       	mov	r31, r30
   134ca:	27 d0       	rcall	.+78     	; 0x1351a <__divsf3_pse+0x8e>
   134cc:	66 0f       	add	r22, r22
   134ce:	77 1f       	adc	r23, r23
   134d0:	88 1f       	adc	r24, r24
   134d2:	bb 1f       	adc	r27, r27
   134d4:	26 17       	cp	r18, r22
   134d6:	37 07       	cpc	r19, r23
   134d8:	48 07       	cpc	r20, r24
   134da:	ab 07       	cpc	r26, r27
   134dc:	b0 e8       	ldi	r27, 0x80	; 128
   134de:	09 f0       	breq	.+2      	; 0x134e2 <__divsf3_pse+0x56>
   134e0:	bb 0b       	sbc	r27, r27
   134e2:	80 2d       	mov	r24, r0
   134e4:	bf 01       	movw	r22, r30
   134e6:	ff 27       	eor	r31, r31
   134e8:	93 58       	subi	r25, 0x83	; 131
   134ea:	5f 4f       	sbci	r21, 0xFF	; 255
   134ec:	2a f0       	brmi	.+10     	; 0x134f8 <__divsf3_pse+0x6c>
   134ee:	9e 3f       	cpi	r25, 0xFE	; 254
   134f0:	51 05       	cpc	r21, r1
   134f2:	68 f0       	brcs	.+26     	; 0x1350e <__divsf3_pse+0x82>
   134f4:	c9 c0       	rjmp	.+402    	; 0x13688 <__fp_inf>
   134f6:	53 c1       	rjmp	.+678    	; 0x1379e <__fp_szero>
   134f8:	5f 3f       	cpi	r21, 0xFF	; 255
   134fa:	ec f3       	brlt	.-6      	; 0x134f6 <__divsf3_pse+0x6a>
   134fc:	98 3e       	cpi	r25, 0xE8	; 232
   134fe:	dc f3       	brlt	.-10     	; 0x134f6 <__divsf3_pse+0x6a>
   13500:	86 95       	lsr	r24
   13502:	77 95       	ror	r23
   13504:	67 95       	ror	r22
   13506:	b7 95       	ror	r27
   13508:	f7 95       	ror	r31
   1350a:	9f 5f       	subi	r25, 0xFF	; 255
   1350c:	c9 f7       	brne	.-14     	; 0x13500 <__divsf3_pse+0x74>
   1350e:	88 0f       	add	r24, r24
   13510:	91 1d       	adc	r25, r1
   13512:	96 95       	lsr	r25
   13514:	87 95       	ror	r24
   13516:	97 f9       	bld	r25, 7
   13518:	08 95       	ret
   1351a:	e1 e0       	ldi	r30, 0x01	; 1
   1351c:	66 0f       	add	r22, r22
   1351e:	77 1f       	adc	r23, r23
   13520:	88 1f       	adc	r24, r24
   13522:	bb 1f       	adc	r27, r27
   13524:	62 17       	cp	r22, r18
   13526:	73 07       	cpc	r23, r19
   13528:	84 07       	cpc	r24, r20
   1352a:	ba 07       	cpc	r27, r26
   1352c:	20 f0       	brcs	.+8      	; 0x13536 <__divsf3_pse+0xaa>
   1352e:	62 1b       	sub	r22, r18
   13530:	73 0b       	sbc	r23, r19
   13532:	84 0b       	sbc	r24, r20
   13534:	ba 0b       	sbc	r27, r26
   13536:	ee 1f       	adc	r30, r30
   13538:	88 f7       	brcc	.-30     	; 0x1351c <__divsf3_pse+0x90>
   1353a:	e0 95       	com	r30
   1353c:	08 95       	ret

0001353e <__fixsfsi>:
   1353e:	04 d0       	rcall	.+8      	; 0x13548 <__fixunssfsi>
   13540:	68 94       	set
   13542:	b1 11       	cpse	r27, r1
   13544:	2c c1       	rjmp	.+600    	; 0x1379e <__fp_szero>
   13546:	08 95       	ret

00013548 <__fixunssfsi>:
   13548:	f8 d0       	rcall	.+496    	; 0x1373a <__fp_splitA>
   1354a:	88 f0       	brcs	.+34     	; 0x1356e <__fixunssfsi+0x26>
   1354c:	9f 57       	subi	r25, 0x7F	; 127
   1354e:	90 f0       	brcs	.+36     	; 0x13574 <__fixunssfsi+0x2c>
   13550:	b9 2f       	mov	r27, r25
   13552:	99 27       	eor	r25, r25
   13554:	b7 51       	subi	r27, 0x17	; 23
   13556:	a0 f0       	brcs	.+40     	; 0x13580 <__fixunssfsi+0x38>
   13558:	d1 f0       	breq	.+52     	; 0x1358e <__fixunssfsi+0x46>
   1355a:	66 0f       	add	r22, r22
   1355c:	77 1f       	adc	r23, r23
   1355e:	88 1f       	adc	r24, r24
   13560:	99 1f       	adc	r25, r25
   13562:	1a f0       	brmi	.+6      	; 0x1356a <__fixunssfsi+0x22>
   13564:	ba 95       	dec	r27
   13566:	c9 f7       	brne	.-14     	; 0x1355a <__fixunssfsi+0x12>
   13568:	12 c0       	rjmp	.+36     	; 0x1358e <__fixunssfsi+0x46>
   1356a:	b1 30       	cpi	r27, 0x01	; 1
   1356c:	81 f0       	breq	.+32     	; 0x1358e <__fixunssfsi+0x46>
   1356e:	16 d1       	rcall	.+556    	; 0x1379c <__fp_zero>
   13570:	b1 e0       	ldi	r27, 0x01	; 1
   13572:	08 95       	ret
   13574:	13 c1       	rjmp	.+550    	; 0x1379c <__fp_zero>
   13576:	67 2f       	mov	r22, r23
   13578:	78 2f       	mov	r23, r24
   1357a:	88 27       	eor	r24, r24
   1357c:	b8 5f       	subi	r27, 0xF8	; 248
   1357e:	39 f0       	breq	.+14     	; 0x1358e <__fixunssfsi+0x46>
   13580:	b9 3f       	cpi	r27, 0xF9	; 249
   13582:	cc f3       	brlt	.-14     	; 0x13576 <__fixunssfsi+0x2e>
   13584:	86 95       	lsr	r24
   13586:	77 95       	ror	r23
   13588:	67 95       	ror	r22
   1358a:	b3 95       	inc	r27
   1358c:	d9 f7       	brne	.-10     	; 0x13584 <__fixunssfsi+0x3c>
   1358e:	3e f4       	brtc	.+14     	; 0x1359e <__fixunssfsi+0x56>
   13590:	90 95       	com	r25
   13592:	80 95       	com	r24
   13594:	70 95       	com	r23
   13596:	61 95       	neg	r22
   13598:	7f 4f       	sbci	r23, 0xFF	; 255
   1359a:	8f 4f       	sbci	r24, 0xFF	; 255
   1359c:	9f 4f       	sbci	r25, 0xFF	; 255
   1359e:	08 95       	ret

000135a0 <__floatunsisf>:
   135a0:	e8 94       	clt
   135a2:	09 c0       	rjmp	.+18     	; 0x135b6 <__floatsisf+0x12>

000135a4 <__floatsisf>:
   135a4:	97 fb       	bst	r25, 7
   135a6:	3e f4       	brtc	.+14     	; 0x135b6 <__floatsisf+0x12>
   135a8:	90 95       	com	r25
   135aa:	80 95       	com	r24
   135ac:	70 95       	com	r23
   135ae:	61 95       	neg	r22
   135b0:	7f 4f       	sbci	r23, 0xFF	; 255
   135b2:	8f 4f       	sbci	r24, 0xFF	; 255
   135b4:	9f 4f       	sbci	r25, 0xFF	; 255
   135b6:	99 23       	and	r25, r25
   135b8:	a9 f0       	breq	.+42     	; 0x135e4 <__floatsisf+0x40>
   135ba:	f9 2f       	mov	r31, r25
   135bc:	96 e9       	ldi	r25, 0x96	; 150
   135be:	bb 27       	eor	r27, r27
   135c0:	93 95       	inc	r25
   135c2:	f6 95       	lsr	r31
   135c4:	87 95       	ror	r24
   135c6:	77 95       	ror	r23
   135c8:	67 95       	ror	r22
   135ca:	b7 95       	ror	r27
   135cc:	f1 11       	cpse	r31, r1
   135ce:	f8 cf       	rjmp	.-16     	; 0x135c0 <__floatsisf+0x1c>
   135d0:	fa f4       	brpl	.+62     	; 0x13610 <__floatsisf+0x6c>
   135d2:	bb 0f       	add	r27, r27
   135d4:	11 f4       	brne	.+4      	; 0x135da <__floatsisf+0x36>
   135d6:	60 ff       	sbrs	r22, 0
   135d8:	1b c0       	rjmp	.+54     	; 0x13610 <__floatsisf+0x6c>
   135da:	6f 5f       	subi	r22, 0xFF	; 255
   135dc:	7f 4f       	sbci	r23, 0xFF	; 255
   135de:	8f 4f       	sbci	r24, 0xFF	; 255
   135e0:	9f 4f       	sbci	r25, 0xFF	; 255
   135e2:	16 c0       	rjmp	.+44     	; 0x13610 <__floatsisf+0x6c>
   135e4:	88 23       	and	r24, r24
   135e6:	11 f0       	breq	.+4      	; 0x135ec <__floatsisf+0x48>
   135e8:	96 e9       	ldi	r25, 0x96	; 150
   135ea:	11 c0       	rjmp	.+34     	; 0x1360e <__floatsisf+0x6a>
   135ec:	77 23       	and	r23, r23
   135ee:	21 f0       	breq	.+8      	; 0x135f8 <__floatsisf+0x54>
   135f0:	9e e8       	ldi	r25, 0x8E	; 142
   135f2:	87 2f       	mov	r24, r23
   135f4:	76 2f       	mov	r23, r22
   135f6:	05 c0       	rjmp	.+10     	; 0x13602 <__floatsisf+0x5e>
   135f8:	66 23       	and	r22, r22
   135fa:	71 f0       	breq	.+28     	; 0x13618 <__floatsisf+0x74>
   135fc:	96 e8       	ldi	r25, 0x86	; 134
   135fe:	86 2f       	mov	r24, r22
   13600:	70 e0       	ldi	r23, 0x00	; 0
   13602:	60 e0       	ldi	r22, 0x00	; 0
   13604:	2a f0       	brmi	.+10     	; 0x13610 <__floatsisf+0x6c>
   13606:	9a 95       	dec	r25
   13608:	66 0f       	add	r22, r22
   1360a:	77 1f       	adc	r23, r23
   1360c:	88 1f       	adc	r24, r24
   1360e:	da f7       	brpl	.-10     	; 0x13606 <__floatsisf+0x62>
   13610:	88 0f       	add	r24, r24
   13612:	96 95       	lsr	r25
   13614:	87 95       	ror	r24
   13616:	97 f9       	bld	r25, 7
   13618:	08 95       	ret

0001361a <floor>:
   1361a:	a9 d0       	rcall	.+338    	; 0x1376e <__fp_trunc>
   1361c:	80 f0       	brcs	.+32     	; 0x1363e <floor+0x24>
   1361e:	9f 37       	cpi	r25, 0x7F	; 127
   13620:	40 f4       	brcc	.+16     	; 0x13632 <floor+0x18>
   13622:	91 11       	cpse	r25, r1
   13624:	0e f0       	brts	.+2      	; 0x13628 <floor+0xe>
   13626:	bb c0       	rjmp	.+374    	; 0x1379e <__fp_szero>
   13628:	60 e0       	ldi	r22, 0x00	; 0
   1362a:	70 e0       	ldi	r23, 0x00	; 0
   1362c:	80 e8       	ldi	r24, 0x80	; 128
   1362e:	9f eb       	ldi	r25, 0xBF	; 191
   13630:	08 95       	ret
   13632:	26 f4       	brtc	.+8      	; 0x1363c <floor+0x22>
   13634:	1b 16       	cp	r1, r27
   13636:	61 1d       	adc	r22, r1
   13638:	71 1d       	adc	r23, r1
   1363a:	81 1d       	adc	r24, r1
   1363c:	2b c0       	rjmp	.+86     	; 0x13694 <__fp_mintl>
   1363e:	45 c0       	rjmp	.+138    	; 0x136ca <__fp_mpack>

00013640 <__fp_cmp>:
   13640:	99 0f       	add	r25, r25
   13642:	00 08       	sbc	r0, r0
   13644:	55 0f       	add	r21, r21
   13646:	aa 0b       	sbc	r26, r26
   13648:	e0 e8       	ldi	r30, 0x80	; 128
   1364a:	fe ef       	ldi	r31, 0xFE	; 254
   1364c:	16 16       	cp	r1, r22
   1364e:	17 06       	cpc	r1, r23
   13650:	e8 07       	cpc	r30, r24
   13652:	f9 07       	cpc	r31, r25
   13654:	c0 f0       	brcs	.+48     	; 0x13686 <__fp_cmp+0x46>
   13656:	12 16       	cp	r1, r18
   13658:	13 06       	cpc	r1, r19
   1365a:	e4 07       	cpc	r30, r20
   1365c:	f5 07       	cpc	r31, r21
   1365e:	98 f0       	brcs	.+38     	; 0x13686 <__fp_cmp+0x46>
   13660:	62 1b       	sub	r22, r18
   13662:	73 0b       	sbc	r23, r19
   13664:	84 0b       	sbc	r24, r20
   13666:	95 0b       	sbc	r25, r21
   13668:	39 f4       	brne	.+14     	; 0x13678 <__fp_cmp+0x38>
   1366a:	0a 26       	eor	r0, r26
   1366c:	61 f0       	breq	.+24     	; 0x13686 <__fp_cmp+0x46>
   1366e:	23 2b       	or	r18, r19
   13670:	24 2b       	or	r18, r20
   13672:	25 2b       	or	r18, r21
   13674:	21 f4       	brne	.+8      	; 0x1367e <__fp_cmp+0x3e>
   13676:	08 95       	ret
   13678:	0a 26       	eor	r0, r26
   1367a:	09 f4       	brne	.+2      	; 0x1367e <__fp_cmp+0x3e>
   1367c:	a1 40       	sbci	r26, 0x01	; 1
   1367e:	a6 95       	lsr	r26
   13680:	8f ef       	ldi	r24, 0xFF	; 255
   13682:	81 1d       	adc	r24, r1
   13684:	81 1d       	adc	r24, r1
   13686:	08 95       	ret

00013688 <__fp_inf>:
   13688:	97 f9       	bld	r25, 7
   1368a:	9f 67       	ori	r25, 0x7F	; 127
   1368c:	80 e8       	ldi	r24, 0x80	; 128
   1368e:	70 e0       	ldi	r23, 0x00	; 0
   13690:	60 e0       	ldi	r22, 0x00	; 0
   13692:	08 95       	ret

00013694 <__fp_mintl>:
   13694:	88 23       	and	r24, r24
   13696:	71 f4       	brne	.+28     	; 0x136b4 <__fp_mintl+0x20>
   13698:	77 23       	and	r23, r23
   1369a:	21 f0       	breq	.+8      	; 0x136a4 <__fp_mintl+0x10>
   1369c:	98 50       	subi	r25, 0x08	; 8
   1369e:	87 2b       	or	r24, r23
   136a0:	76 2f       	mov	r23, r22
   136a2:	07 c0       	rjmp	.+14     	; 0x136b2 <__fp_mintl+0x1e>
   136a4:	66 23       	and	r22, r22
   136a6:	11 f4       	brne	.+4      	; 0x136ac <__fp_mintl+0x18>
   136a8:	99 27       	eor	r25, r25
   136aa:	0d c0       	rjmp	.+26     	; 0x136c6 <__fp_mintl+0x32>
   136ac:	90 51       	subi	r25, 0x10	; 16
   136ae:	86 2b       	or	r24, r22
   136b0:	70 e0       	ldi	r23, 0x00	; 0
   136b2:	60 e0       	ldi	r22, 0x00	; 0
   136b4:	2a f0       	brmi	.+10     	; 0x136c0 <__fp_mintl+0x2c>
   136b6:	9a 95       	dec	r25
   136b8:	66 0f       	add	r22, r22
   136ba:	77 1f       	adc	r23, r23
   136bc:	88 1f       	adc	r24, r24
   136be:	da f7       	brpl	.-10     	; 0x136b6 <__fp_mintl+0x22>
   136c0:	88 0f       	add	r24, r24
   136c2:	96 95       	lsr	r25
   136c4:	87 95       	ror	r24
   136c6:	97 f9       	bld	r25, 7
   136c8:	08 95       	ret

000136ca <__fp_mpack>:
   136ca:	9f 3f       	cpi	r25, 0xFF	; 255
   136cc:	31 f0       	breq	.+12     	; 0x136da <__fp_mpack_finite+0xc>

000136ce <__fp_mpack_finite>:
   136ce:	91 50       	subi	r25, 0x01	; 1
   136d0:	20 f4       	brcc	.+8      	; 0x136da <__fp_mpack_finite+0xc>
   136d2:	87 95       	ror	r24
   136d4:	77 95       	ror	r23
   136d6:	67 95       	ror	r22
   136d8:	b7 95       	ror	r27
   136da:	88 0f       	add	r24, r24
   136dc:	91 1d       	adc	r25, r1
   136de:	96 95       	lsr	r25
   136e0:	87 95       	ror	r24
   136e2:	97 f9       	bld	r25, 7
   136e4:	08 95       	ret

000136e6 <__fp_nan>:
   136e6:	9f ef       	ldi	r25, 0xFF	; 255
   136e8:	80 ec       	ldi	r24, 0xC0	; 192
   136ea:	08 95       	ret

000136ec <__fp_pscA>:
   136ec:	00 24       	eor	r0, r0
   136ee:	0a 94       	dec	r0
   136f0:	16 16       	cp	r1, r22
   136f2:	17 06       	cpc	r1, r23
   136f4:	18 06       	cpc	r1, r24
   136f6:	09 06       	cpc	r0, r25
   136f8:	08 95       	ret

000136fa <__fp_pscB>:
   136fa:	00 24       	eor	r0, r0
   136fc:	0a 94       	dec	r0
   136fe:	12 16       	cp	r1, r18
   13700:	13 06       	cpc	r1, r19
   13702:	14 06       	cpc	r1, r20
   13704:	05 06       	cpc	r0, r21
   13706:	08 95       	ret

00013708 <__fp_round>:
   13708:	09 2e       	mov	r0, r25
   1370a:	03 94       	inc	r0
   1370c:	00 0c       	add	r0, r0
   1370e:	11 f4       	brne	.+4      	; 0x13714 <__fp_round+0xc>
   13710:	88 23       	and	r24, r24
   13712:	52 f0       	brmi	.+20     	; 0x13728 <__fp_round+0x20>
   13714:	bb 0f       	add	r27, r27
   13716:	40 f4       	brcc	.+16     	; 0x13728 <__fp_round+0x20>
   13718:	bf 2b       	or	r27, r31
   1371a:	11 f4       	brne	.+4      	; 0x13720 <__fp_round+0x18>
   1371c:	60 ff       	sbrs	r22, 0
   1371e:	04 c0       	rjmp	.+8      	; 0x13728 <__fp_round+0x20>
   13720:	6f 5f       	subi	r22, 0xFF	; 255
   13722:	7f 4f       	sbci	r23, 0xFF	; 255
   13724:	8f 4f       	sbci	r24, 0xFF	; 255
   13726:	9f 4f       	sbci	r25, 0xFF	; 255
   13728:	08 95       	ret

0001372a <__fp_split3>:
   1372a:	57 fd       	sbrc	r21, 7
   1372c:	90 58       	subi	r25, 0x80	; 128
   1372e:	44 0f       	add	r20, r20
   13730:	55 1f       	adc	r21, r21
   13732:	59 f0       	breq	.+22     	; 0x1374a <__fp_splitA+0x10>
   13734:	5f 3f       	cpi	r21, 0xFF	; 255
   13736:	71 f0       	breq	.+28     	; 0x13754 <__fp_splitA+0x1a>
   13738:	47 95       	ror	r20

0001373a <__fp_splitA>:
   1373a:	88 0f       	add	r24, r24
   1373c:	97 fb       	bst	r25, 7
   1373e:	99 1f       	adc	r25, r25
   13740:	61 f0       	breq	.+24     	; 0x1375a <__fp_splitA+0x20>
   13742:	9f 3f       	cpi	r25, 0xFF	; 255
   13744:	79 f0       	breq	.+30     	; 0x13764 <__fp_splitA+0x2a>
   13746:	87 95       	ror	r24
   13748:	08 95       	ret
   1374a:	12 16       	cp	r1, r18
   1374c:	13 06       	cpc	r1, r19
   1374e:	14 06       	cpc	r1, r20
   13750:	55 1f       	adc	r21, r21
   13752:	f2 cf       	rjmp	.-28     	; 0x13738 <__fp_split3+0xe>
   13754:	46 95       	lsr	r20
   13756:	f1 df       	rcall	.-30     	; 0x1373a <__fp_splitA>
   13758:	08 c0       	rjmp	.+16     	; 0x1376a <__fp_splitA+0x30>
   1375a:	16 16       	cp	r1, r22
   1375c:	17 06       	cpc	r1, r23
   1375e:	18 06       	cpc	r1, r24
   13760:	99 1f       	adc	r25, r25
   13762:	f1 cf       	rjmp	.-30     	; 0x13746 <__fp_splitA+0xc>
   13764:	86 95       	lsr	r24
   13766:	71 05       	cpc	r23, r1
   13768:	61 05       	cpc	r22, r1
   1376a:	08 94       	sec
   1376c:	08 95       	ret

0001376e <__fp_trunc>:
   1376e:	e5 df       	rcall	.-54     	; 0x1373a <__fp_splitA>
   13770:	a0 f0       	brcs	.+40     	; 0x1379a <__fp_trunc+0x2c>
   13772:	be e7       	ldi	r27, 0x7E	; 126
   13774:	b9 17       	cp	r27, r25
   13776:	88 f4       	brcc	.+34     	; 0x1379a <__fp_trunc+0x2c>
   13778:	bb 27       	eor	r27, r27
   1377a:	9f 38       	cpi	r25, 0x8F	; 143
   1377c:	60 f4       	brcc	.+24     	; 0x13796 <__fp_trunc+0x28>
   1377e:	16 16       	cp	r1, r22
   13780:	b1 1d       	adc	r27, r1
   13782:	67 2f       	mov	r22, r23
   13784:	78 2f       	mov	r23, r24
   13786:	88 27       	eor	r24, r24
   13788:	98 5f       	subi	r25, 0xF8	; 248
   1378a:	f7 cf       	rjmp	.-18     	; 0x1377a <__fp_trunc+0xc>
   1378c:	86 95       	lsr	r24
   1378e:	77 95       	ror	r23
   13790:	67 95       	ror	r22
   13792:	b1 1d       	adc	r27, r1
   13794:	93 95       	inc	r25
   13796:	96 39       	cpi	r25, 0x96	; 150
   13798:	c8 f3       	brcs	.-14     	; 0x1378c <__fp_trunc+0x1e>
   1379a:	08 95       	ret

0001379c <__fp_zero>:
   1379c:	e8 94       	clt

0001379e <__fp_szero>:
   1379e:	bb 27       	eor	r27, r27
   137a0:	66 27       	eor	r22, r22
   137a2:	77 27       	eor	r23, r23
   137a4:	cb 01       	movw	r24, r22
   137a6:	97 f9       	bld	r25, 7
   137a8:	08 95       	ret

000137aa <__gesf2>:
   137aa:	4a df       	rcall	.-364    	; 0x13640 <__fp_cmp>
   137ac:	08 f4       	brcc	.+2      	; 0x137b0 <__gesf2+0x6>
   137ae:	8f ef       	ldi	r24, 0xFF	; 255
   137b0:	08 95       	ret

000137b2 <__mulsf3>:
   137b2:	0b d0       	rcall	.+22     	; 0x137ca <__mulsf3x>
   137b4:	a9 cf       	rjmp	.-174    	; 0x13708 <__fp_round>
   137b6:	9a df       	rcall	.-204    	; 0x136ec <__fp_pscA>
   137b8:	28 f0       	brcs	.+10     	; 0x137c4 <__mulsf3+0x12>
   137ba:	9f df       	rcall	.-194    	; 0x136fa <__fp_pscB>
   137bc:	18 f0       	brcs	.+6      	; 0x137c4 <__mulsf3+0x12>
   137be:	95 23       	and	r25, r21
   137c0:	09 f0       	breq	.+2      	; 0x137c4 <__mulsf3+0x12>
   137c2:	62 cf       	rjmp	.-316    	; 0x13688 <__fp_inf>
   137c4:	90 cf       	rjmp	.-224    	; 0x136e6 <__fp_nan>
   137c6:	11 24       	eor	r1, r1
   137c8:	ea cf       	rjmp	.-44     	; 0x1379e <__fp_szero>

000137ca <__mulsf3x>:
   137ca:	af df       	rcall	.-162    	; 0x1372a <__fp_split3>
   137cc:	a0 f3       	brcs	.-24     	; 0x137b6 <__mulsf3+0x4>

000137ce <__mulsf3_pse>:
   137ce:	95 9f       	mul	r25, r21
   137d0:	d1 f3       	breq	.-12     	; 0x137c6 <__mulsf3+0x14>
   137d2:	95 0f       	add	r25, r21
   137d4:	50 e0       	ldi	r21, 0x00	; 0
   137d6:	55 1f       	adc	r21, r21
   137d8:	62 9f       	mul	r22, r18
   137da:	f0 01       	movw	r30, r0
   137dc:	72 9f       	mul	r23, r18
   137de:	bb 27       	eor	r27, r27
   137e0:	f0 0d       	add	r31, r0
   137e2:	b1 1d       	adc	r27, r1
   137e4:	63 9f       	mul	r22, r19
   137e6:	aa 27       	eor	r26, r26
   137e8:	f0 0d       	add	r31, r0
   137ea:	b1 1d       	adc	r27, r1
   137ec:	aa 1f       	adc	r26, r26
   137ee:	64 9f       	mul	r22, r20
   137f0:	66 27       	eor	r22, r22
   137f2:	b0 0d       	add	r27, r0
   137f4:	a1 1d       	adc	r26, r1
   137f6:	66 1f       	adc	r22, r22
   137f8:	82 9f       	mul	r24, r18
   137fa:	22 27       	eor	r18, r18
   137fc:	b0 0d       	add	r27, r0
   137fe:	a1 1d       	adc	r26, r1
   13800:	62 1f       	adc	r22, r18
   13802:	73 9f       	mul	r23, r19
   13804:	b0 0d       	add	r27, r0
   13806:	a1 1d       	adc	r26, r1
   13808:	62 1f       	adc	r22, r18
   1380a:	83 9f       	mul	r24, r19
   1380c:	a0 0d       	add	r26, r0
   1380e:	61 1d       	adc	r22, r1
   13810:	22 1f       	adc	r18, r18
   13812:	74 9f       	mul	r23, r20
   13814:	33 27       	eor	r19, r19
   13816:	a0 0d       	add	r26, r0
   13818:	61 1d       	adc	r22, r1
   1381a:	23 1f       	adc	r18, r19
   1381c:	84 9f       	mul	r24, r20
   1381e:	60 0d       	add	r22, r0
   13820:	21 1d       	adc	r18, r1
   13822:	82 2f       	mov	r24, r18
   13824:	76 2f       	mov	r23, r22
   13826:	6a 2f       	mov	r22, r26
   13828:	11 24       	eor	r1, r1
   1382a:	9f 57       	subi	r25, 0x7F	; 127
   1382c:	50 40       	sbci	r21, 0x00	; 0
   1382e:	8a f0       	brmi	.+34     	; 0x13852 <__mulsf3_pse+0x84>
   13830:	e1 f0       	breq	.+56     	; 0x1386a <__mulsf3_pse+0x9c>
   13832:	88 23       	and	r24, r24
   13834:	4a f0       	brmi	.+18     	; 0x13848 <__mulsf3_pse+0x7a>
   13836:	ee 0f       	add	r30, r30
   13838:	ff 1f       	adc	r31, r31
   1383a:	bb 1f       	adc	r27, r27
   1383c:	66 1f       	adc	r22, r22
   1383e:	77 1f       	adc	r23, r23
   13840:	88 1f       	adc	r24, r24
   13842:	91 50       	subi	r25, 0x01	; 1
   13844:	50 40       	sbci	r21, 0x00	; 0
   13846:	a9 f7       	brne	.-22     	; 0x13832 <__mulsf3_pse+0x64>
   13848:	9e 3f       	cpi	r25, 0xFE	; 254
   1384a:	51 05       	cpc	r21, r1
   1384c:	70 f0       	brcs	.+28     	; 0x1386a <__mulsf3_pse+0x9c>
   1384e:	1c cf       	rjmp	.-456    	; 0x13688 <__fp_inf>
   13850:	a6 cf       	rjmp	.-180    	; 0x1379e <__fp_szero>
   13852:	5f 3f       	cpi	r21, 0xFF	; 255
   13854:	ec f3       	brlt	.-6      	; 0x13850 <__mulsf3_pse+0x82>
   13856:	98 3e       	cpi	r25, 0xE8	; 232
   13858:	dc f3       	brlt	.-10     	; 0x13850 <__mulsf3_pse+0x82>
   1385a:	86 95       	lsr	r24
   1385c:	77 95       	ror	r23
   1385e:	67 95       	ror	r22
   13860:	b7 95       	ror	r27
   13862:	f7 95       	ror	r31
   13864:	e7 95       	ror	r30
   13866:	9f 5f       	subi	r25, 0xFF	; 255
   13868:	c1 f7       	brne	.-16     	; 0x1385a <__mulsf3_pse+0x8c>
   1386a:	fe 2b       	or	r31, r30
   1386c:	88 0f       	add	r24, r24
   1386e:	91 1d       	adc	r25, r1
   13870:	96 95       	lsr	r25
   13872:	87 95       	ror	r24
   13874:	97 f9       	bld	r25, 7
   13876:	08 95       	ret

00013878 <__mulsi3>:
   13878:	62 9f       	mul	r22, r18
   1387a:	d0 01       	movw	r26, r0
   1387c:	73 9f       	mul	r23, r19
   1387e:	f0 01       	movw	r30, r0
   13880:	82 9f       	mul	r24, r18
   13882:	e0 0d       	add	r30, r0
   13884:	f1 1d       	adc	r31, r1
   13886:	64 9f       	mul	r22, r20
   13888:	e0 0d       	add	r30, r0
   1388a:	f1 1d       	adc	r31, r1
   1388c:	92 9f       	mul	r25, r18
   1388e:	f0 0d       	add	r31, r0
   13890:	83 9f       	mul	r24, r19
   13892:	f0 0d       	add	r31, r0
   13894:	74 9f       	mul	r23, r20
   13896:	f0 0d       	add	r31, r0
   13898:	65 9f       	mul	r22, r21
   1389a:	f0 0d       	add	r31, r0
   1389c:	99 27       	eor	r25, r25
   1389e:	72 9f       	mul	r23, r18
   138a0:	b0 0d       	add	r27, r0
   138a2:	e1 1d       	adc	r30, r1
   138a4:	f9 1f       	adc	r31, r25
   138a6:	63 9f       	mul	r22, r19
   138a8:	b0 0d       	add	r27, r0
   138aa:	e1 1d       	adc	r30, r1
   138ac:	f9 1f       	adc	r31, r25
   138ae:	bd 01       	movw	r22, r26
   138b0:	cf 01       	movw	r24, r30
   138b2:	11 24       	eor	r1, r1
   138b4:	08 95       	ret

000138b6 <__udivmodqi4>:
   138b6:	99 1b       	sub	r25, r25
   138b8:	79 e0       	ldi	r23, 0x09	; 9
   138ba:	04 c0       	rjmp	.+8      	; 0x138c4 <__udivmodqi4_ep>

000138bc <__udivmodqi4_loop>:
   138bc:	99 1f       	adc	r25, r25
   138be:	96 17       	cp	r25, r22
   138c0:	08 f0       	brcs	.+2      	; 0x138c4 <__udivmodqi4_ep>
   138c2:	96 1b       	sub	r25, r22

000138c4 <__udivmodqi4_ep>:
   138c4:	88 1f       	adc	r24, r24
   138c6:	7a 95       	dec	r23
   138c8:	c9 f7       	brne	.-14     	; 0x138bc <__udivmodqi4_loop>
   138ca:	80 95       	com	r24
   138cc:	08 95       	ret

000138ce <__divmodhi4>:
   138ce:	97 fb       	bst	r25, 7
   138d0:	09 2e       	mov	r0, r25
   138d2:	07 26       	eor	r0, r23
   138d4:	0a d0       	rcall	.+20     	; 0x138ea <__divmodhi4_neg1>
   138d6:	77 fd       	sbrc	r23, 7
   138d8:	04 d0       	rcall	.+8      	; 0x138e2 <__divmodhi4_neg2>
   138da:	27 d0       	rcall	.+78     	; 0x1392a <__udivmodhi4>
   138dc:	06 d0       	rcall	.+12     	; 0x138ea <__divmodhi4_neg1>
   138de:	00 20       	and	r0, r0
   138e0:	1a f4       	brpl	.+6      	; 0x138e8 <__divmodhi4_exit>

000138e2 <__divmodhi4_neg2>:
   138e2:	70 95       	com	r23
   138e4:	61 95       	neg	r22
   138e6:	7f 4f       	sbci	r23, 0xFF	; 255

000138e8 <__divmodhi4_exit>:
   138e8:	08 95       	ret

000138ea <__divmodhi4_neg1>:
   138ea:	f6 f7       	brtc	.-4      	; 0x138e8 <__divmodhi4_exit>
   138ec:	90 95       	com	r25
   138ee:	81 95       	neg	r24
   138f0:	9f 4f       	sbci	r25, 0xFF	; 255
   138f2:	08 95       	ret

000138f4 <__divmodsi4>:
   138f4:	97 fb       	bst	r25, 7
   138f6:	09 2e       	mov	r0, r25
   138f8:	05 26       	eor	r0, r21
   138fa:	0e d0       	rcall	.+28     	; 0x13918 <__divmodsi4_neg1>
   138fc:	57 fd       	sbrc	r21, 7
   138fe:	04 d0       	rcall	.+8      	; 0x13908 <__divmodsi4_neg2>
   13900:	28 d0       	rcall	.+80     	; 0x13952 <__udivmodsi4>
   13902:	0a d0       	rcall	.+20     	; 0x13918 <__divmodsi4_neg1>
   13904:	00 1c       	adc	r0, r0
   13906:	38 f4       	brcc	.+14     	; 0x13916 <__divmodsi4_exit>

00013908 <__divmodsi4_neg2>:
   13908:	50 95       	com	r21
   1390a:	40 95       	com	r20
   1390c:	30 95       	com	r19
   1390e:	21 95       	neg	r18
   13910:	3f 4f       	sbci	r19, 0xFF	; 255
   13912:	4f 4f       	sbci	r20, 0xFF	; 255
   13914:	5f 4f       	sbci	r21, 0xFF	; 255

00013916 <__divmodsi4_exit>:
   13916:	08 95       	ret

00013918 <__divmodsi4_neg1>:
   13918:	f6 f7       	brtc	.-4      	; 0x13916 <__divmodsi4_exit>
   1391a:	90 95       	com	r25
   1391c:	80 95       	com	r24
   1391e:	70 95       	com	r23
   13920:	61 95       	neg	r22
   13922:	7f 4f       	sbci	r23, 0xFF	; 255
   13924:	8f 4f       	sbci	r24, 0xFF	; 255
   13926:	9f 4f       	sbci	r25, 0xFF	; 255
   13928:	08 95       	ret

0001392a <__udivmodhi4>:
   1392a:	aa 1b       	sub	r26, r26
   1392c:	bb 1b       	sub	r27, r27
   1392e:	51 e1       	ldi	r21, 0x11	; 17
   13930:	07 c0       	rjmp	.+14     	; 0x13940 <__udivmodhi4_ep>

00013932 <__udivmodhi4_loop>:
   13932:	aa 1f       	adc	r26, r26
   13934:	bb 1f       	adc	r27, r27
   13936:	a6 17       	cp	r26, r22
   13938:	b7 07       	cpc	r27, r23
   1393a:	10 f0       	brcs	.+4      	; 0x13940 <__udivmodhi4_ep>
   1393c:	a6 1b       	sub	r26, r22
   1393e:	b7 0b       	sbc	r27, r23

00013940 <__udivmodhi4_ep>:
   13940:	88 1f       	adc	r24, r24
   13942:	99 1f       	adc	r25, r25
   13944:	5a 95       	dec	r21
   13946:	a9 f7       	brne	.-22     	; 0x13932 <__udivmodhi4_loop>
   13948:	80 95       	com	r24
   1394a:	90 95       	com	r25
   1394c:	bc 01       	movw	r22, r24
   1394e:	cd 01       	movw	r24, r26
   13950:	08 95       	ret

00013952 <__udivmodsi4>:
   13952:	a1 e2       	ldi	r26, 0x21	; 33
   13954:	1a 2e       	mov	r1, r26
   13956:	aa 1b       	sub	r26, r26
   13958:	bb 1b       	sub	r27, r27
   1395a:	fd 01       	movw	r30, r26
   1395c:	0d c0       	rjmp	.+26     	; 0x13978 <__udivmodsi4_ep>

0001395e <__udivmodsi4_loop>:
   1395e:	aa 1f       	adc	r26, r26
   13960:	bb 1f       	adc	r27, r27
   13962:	ee 1f       	adc	r30, r30
   13964:	ff 1f       	adc	r31, r31
   13966:	a2 17       	cp	r26, r18
   13968:	b3 07       	cpc	r27, r19
   1396a:	e4 07       	cpc	r30, r20
   1396c:	f5 07       	cpc	r31, r21
   1396e:	20 f0       	brcs	.+8      	; 0x13978 <__udivmodsi4_ep>
   13970:	a2 1b       	sub	r26, r18
   13972:	b3 0b       	sbc	r27, r19
   13974:	e4 0b       	sbc	r30, r20
   13976:	f5 0b       	sbc	r31, r21

00013978 <__udivmodsi4_ep>:
   13978:	66 1f       	adc	r22, r22
   1397a:	77 1f       	adc	r23, r23
   1397c:	88 1f       	adc	r24, r24
   1397e:	99 1f       	adc	r25, r25
   13980:	1a 94       	dec	r1
   13982:	69 f7       	brne	.-38     	; 0x1395e <__udivmodsi4_loop>
   13984:	60 95       	com	r22
   13986:	70 95       	com	r23
   13988:	80 95       	com	r24
   1398a:	90 95       	com	r25
   1398c:	9b 01       	movw	r18, r22
   1398e:	ac 01       	movw	r20, r24
   13990:	bd 01       	movw	r22, r26
   13992:	cf 01       	movw	r24, r30
   13994:	08 95       	ret

00013996 <malloc>:
   13996:	cf 93       	push	r28
   13998:	df 93       	push	r29
   1399a:	bc 01       	movw	r22, r24
   1399c:	82 30       	cpi	r24, 0x02	; 2
   1399e:	91 05       	cpc	r25, r1
   139a0:	10 f4       	brcc	.+4      	; 0x139a6 <malloc+0x10>
   139a2:	62 e0       	ldi	r22, 0x02	; 2
   139a4:	70 e0       	ldi	r23, 0x00	; 0
   139a6:	a0 91 cc 79 	lds	r26, 0x79CC
   139aa:	b0 91 cd 79 	lds	r27, 0x79CD
   139ae:	ed 01       	movw	r28, r26
   139b0:	e0 e0       	ldi	r30, 0x00	; 0
   139b2:	f0 e0       	ldi	r31, 0x00	; 0
   139b4:	40 e0       	ldi	r20, 0x00	; 0
   139b6:	50 e0       	ldi	r21, 0x00	; 0
   139b8:	21 c0       	rjmp	.+66     	; 0x139fc <malloc+0x66>
   139ba:	88 81       	ld	r24, Y
   139bc:	99 81       	ldd	r25, Y+1	; 0x01
   139be:	86 17       	cp	r24, r22
   139c0:	97 07       	cpc	r25, r23
   139c2:	69 f4       	brne	.+26     	; 0x139de <malloc+0x48>
   139c4:	8a 81       	ldd	r24, Y+2	; 0x02
   139c6:	9b 81       	ldd	r25, Y+3	; 0x03
   139c8:	30 97       	sbiw	r30, 0x00	; 0
   139ca:	19 f0       	breq	.+6      	; 0x139d2 <malloc+0x3c>
   139cc:	93 83       	std	Z+3, r25	; 0x03
   139ce:	82 83       	std	Z+2, r24	; 0x02
   139d0:	04 c0       	rjmp	.+8      	; 0x139da <malloc+0x44>
   139d2:	90 93 cd 79 	sts	0x79CD, r25
   139d6:	80 93 cc 79 	sts	0x79CC, r24
   139da:	fe 01       	movw	r30, r28
   139dc:	34 c0       	rjmp	.+104    	; 0x13a46 <malloc+0xb0>
   139de:	68 17       	cp	r22, r24
   139e0:	79 07       	cpc	r23, r25
   139e2:	38 f4       	brcc	.+14     	; 0x139f2 <malloc+0x5c>
   139e4:	41 15       	cp	r20, r1
   139e6:	51 05       	cpc	r21, r1
   139e8:	19 f0       	breq	.+6      	; 0x139f0 <malloc+0x5a>
   139ea:	84 17       	cp	r24, r20
   139ec:	95 07       	cpc	r25, r21
   139ee:	08 f4       	brcc	.+2      	; 0x139f2 <malloc+0x5c>
   139f0:	ac 01       	movw	r20, r24
   139f2:	fe 01       	movw	r30, r28
   139f4:	8a 81       	ldd	r24, Y+2	; 0x02
   139f6:	9b 81       	ldd	r25, Y+3	; 0x03
   139f8:	9c 01       	movw	r18, r24
   139fa:	e9 01       	movw	r28, r18
   139fc:	20 97       	sbiw	r28, 0x00	; 0
   139fe:	e9 f6       	brne	.-70     	; 0x139ba <malloc+0x24>
   13a00:	41 15       	cp	r20, r1
   13a02:	51 05       	cpc	r21, r1
   13a04:	a9 f1       	breq	.+106    	; 0x13a70 <malloc+0xda>
   13a06:	ca 01       	movw	r24, r20
   13a08:	86 1b       	sub	r24, r22
   13a0a:	97 0b       	sbc	r25, r23
   13a0c:	04 97       	sbiw	r24, 0x04	; 4
   13a0e:	08 f4       	brcc	.+2      	; 0x13a12 <malloc+0x7c>
   13a10:	ba 01       	movw	r22, r20
   13a12:	e0 e0       	ldi	r30, 0x00	; 0
   13a14:	f0 e0       	ldi	r31, 0x00	; 0
   13a16:	2a c0       	rjmp	.+84     	; 0x13a6c <malloc+0xd6>
   13a18:	8d 91       	ld	r24, X+
   13a1a:	9c 91       	ld	r25, X
   13a1c:	11 97       	sbiw	r26, 0x01	; 1
   13a1e:	84 17       	cp	r24, r20
   13a20:	95 07       	cpc	r25, r21
   13a22:	f9 f4       	brne	.+62     	; 0x13a62 <malloc+0xcc>
   13a24:	64 17       	cp	r22, r20
   13a26:	75 07       	cpc	r23, r21
   13a28:	81 f4       	brne	.+32     	; 0x13a4a <malloc+0xb4>
   13a2a:	12 96       	adiw	r26, 0x02	; 2
   13a2c:	8d 91       	ld	r24, X+
   13a2e:	9c 91       	ld	r25, X
   13a30:	13 97       	sbiw	r26, 0x03	; 3
   13a32:	30 97       	sbiw	r30, 0x00	; 0
   13a34:	19 f0       	breq	.+6      	; 0x13a3c <malloc+0xa6>
   13a36:	93 83       	std	Z+3, r25	; 0x03
   13a38:	82 83       	std	Z+2, r24	; 0x02
   13a3a:	04 c0       	rjmp	.+8      	; 0x13a44 <malloc+0xae>
   13a3c:	90 93 cd 79 	sts	0x79CD, r25
   13a40:	80 93 cc 79 	sts	0x79CC, r24
   13a44:	fd 01       	movw	r30, r26
   13a46:	32 96       	adiw	r30, 0x02	; 2
   13a48:	4f c0       	rjmp	.+158    	; 0x13ae8 <malloc+0x152>
   13a4a:	ca 01       	movw	r24, r20
   13a4c:	86 1b       	sub	r24, r22
   13a4e:	97 0b       	sbc	r25, r23
   13a50:	fd 01       	movw	r30, r26
   13a52:	e8 0f       	add	r30, r24
   13a54:	f9 1f       	adc	r31, r25
   13a56:	61 93       	st	Z+, r22
   13a58:	71 93       	st	Z+, r23
   13a5a:	02 97       	sbiw	r24, 0x02	; 2
   13a5c:	8d 93       	st	X+, r24
   13a5e:	9c 93       	st	X, r25
   13a60:	43 c0       	rjmp	.+134    	; 0x13ae8 <malloc+0x152>
   13a62:	fd 01       	movw	r30, r26
   13a64:	82 81       	ldd	r24, Z+2	; 0x02
   13a66:	93 81       	ldd	r25, Z+3	; 0x03
   13a68:	9c 01       	movw	r18, r24
   13a6a:	d9 01       	movw	r26, r18
   13a6c:	10 97       	sbiw	r26, 0x00	; 0
   13a6e:	a1 f6       	brne	.-88     	; 0x13a18 <malloc+0x82>
   13a70:	80 91 ca 79 	lds	r24, 0x79CA
   13a74:	90 91 cb 79 	lds	r25, 0x79CB
   13a78:	89 2b       	or	r24, r25
   13a7a:	41 f4       	brne	.+16     	; 0x13a8c <malloc+0xf6>
   13a7c:	80 91 a6 74 	lds	r24, 0x74A6
   13a80:	90 91 a7 74 	lds	r25, 0x74A7
   13a84:	90 93 cb 79 	sts	0x79CB, r25
   13a88:	80 93 ca 79 	sts	0x79CA, r24
   13a8c:	40 91 a8 74 	lds	r20, 0x74A8
   13a90:	50 91 a9 74 	lds	r21, 0x74A9
   13a94:	41 15       	cp	r20, r1
   13a96:	51 05       	cpc	r21, r1
   13a98:	41 f4       	brne	.+16     	; 0x13aaa <malloc+0x114>
   13a9a:	4d b7       	in	r20, 0x3d	; 61
   13a9c:	5e b7       	in	r21, 0x3e	; 62
   13a9e:	80 91 a4 74 	lds	r24, 0x74A4
   13aa2:	90 91 a5 74 	lds	r25, 0x74A5
   13aa6:	48 1b       	sub	r20, r24
   13aa8:	59 0b       	sbc	r21, r25
   13aaa:	20 91 ca 79 	lds	r18, 0x79CA
   13aae:	30 91 cb 79 	lds	r19, 0x79CB
   13ab2:	24 17       	cp	r18, r20
   13ab4:	35 07       	cpc	r19, r21
   13ab6:	b0 f4       	brcc	.+44     	; 0x13ae4 <malloc+0x14e>
   13ab8:	ca 01       	movw	r24, r20
   13aba:	82 1b       	sub	r24, r18
   13abc:	93 0b       	sbc	r25, r19
   13abe:	86 17       	cp	r24, r22
   13ac0:	97 07       	cpc	r25, r23
   13ac2:	80 f0       	brcs	.+32     	; 0x13ae4 <malloc+0x14e>
   13ac4:	ab 01       	movw	r20, r22
   13ac6:	4e 5f       	subi	r20, 0xFE	; 254
   13ac8:	5f 4f       	sbci	r21, 0xFF	; 255
   13aca:	84 17       	cp	r24, r20
   13acc:	95 07       	cpc	r25, r21
   13ace:	50 f0       	brcs	.+20     	; 0x13ae4 <malloc+0x14e>
   13ad0:	42 0f       	add	r20, r18
   13ad2:	53 1f       	adc	r21, r19
   13ad4:	50 93 cb 79 	sts	0x79CB, r21
   13ad8:	40 93 ca 79 	sts	0x79CA, r20
   13adc:	f9 01       	movw	r30, r18
   13ade:	61 93       	st	Z+, r22
   13ae0:	71 93       	st	Z+, r23
   13ae2:	02 c0       	rjmp	.+4      	; 0x13ae8 <malloc+0x152>
   13ae4:	e0 e0       	ldi	r30, 0x00	; 0
   13ae6:	f0 e0       	ldi	r31, 0x00	; 0
   13ae8:	cf 01       	movw	r24, r30
   13aea:	df 91       	pop	r29
   13aec:	cf 91       	pop	r28
   13aee:	08 95       	ret

00013af0 <free>:
   13af0:	cf 93       	push	r28
   13af2:	df 93       	push	r29
   13af4:	00 97       	sbiw	r24, 0x00	; 0
   13af6:	09 f4       	brne	.+2      	; 0x13afa <free+0xa>
   13af8:	50 c0       	rjmp	.+160    	; 0x13b9a <free+0xaa>
   13afa:	ec 01       	movw	r28, r24
   13afc:	22 97       	sbiw	r28, 0x02	; 2
   13afe:	1b 82       	std	Y+3, r1	; 0x03
   13b00:	1a 82       	std	Y+2, r1	; 0x02
   13b02:	a0 91 cc 79 	lds	r26, 0x79CC
   13b06:	b0 91 cd 79 	lds	r27, 0x79CD
   13b0a:	10 97       	sbiw	r26, 0x00	; 0
   13b0c:	09 f1       	breq	.+66     	; 0x13b50 <free+0x60>
   13b0e:	40 e0       	ldi	r20, 0x00	; 0
   13b10:	50 e0       	ldi	r21, 0x00	; 0
   13b12:	ac 17       	cp	r26, r28
   13b14:	bd 07       	cpc	r27, r29
   13b16:	08 f1       	brcs	.+66     	; 0x13b5a <free+0x6a>
   13b18:	bb 83       	std	Y+3, r27	; 0x03
   13b1a:	aa 83       	std	Y+2, r26	; 0x02
   13b1c:	fe 01       	movw	r30, r28
   13b1e:	21 91       	ld	r18, Z+
   13b20:	31 91       	ld	r19, Z+
   13b22:	e2 0f       	add	r30, r18
   13b24:	f3 1f       	adc	r31, r19
   13b26:	ae 17       	cp	r26, r30
   13b28:	bf 07       	cpc	r27, r31
   13b2a:	79 f4       	brne	.+30     	; 0x13b4a <free+0x5a>
   13b2c:	8d 91       	ld	r24, X+
   13b2e:	9c 91       	ld	r25, X
   13b30:	11 97       	sbiw	r26, 0x01	; 1
   13b32:	28 0f       	add	r18, r24
   13b34:	39 1f       	adc	r19, r25
   13b36:	2e 5f       	subi	r18, 0xFE	; 254
   13b38:	3f 4f       	sbci	r19, 0xFF	; 255
   13b3a:	39 83       	std	Y+1, r19	; 0x01
   13b3c:	28 83       	st	Y, r18
   13b3e:	12 96       	adiw	r26, 0x02	; 2
   13b40:	8d 91       	ld	r24, X+
   13b42:	9c 91       	ld	r25, X
   13b44:	13 97       	sbiw	r26, 0x03	; 3
   13b46:	9b 83       	std	Y+3, r25	; 0x03
   13b48:	8a 83       	std	Y+2, r24	; 0x02
   13b4a:	41 15       	cp	r20, r1
   13b4c:	51 05       	cpc	r21, r1
   13b4e:	71 f4       	brne	.+28     	; 0x13b6c <free+0x7c>
   13b50:	d0 93 cd 79 	sts	0x79CD, r29
   13b54:	c0 93 cc 79 	sts	0x79CC, r28
   13b58:	20 c0       	rjmp	.+64     	; 0x13b9a <free+0xaa>
   13b5a:	12 96       	adiw	r26, 0x02	; 2
   13b5c:	8d 91       	ld	r24, X+
   13b5e:	9c 91       	ld	r25, X
   13b60:	13 97       	sbiw	r26, 0x03	; 3
   13b62:	ad 01       	movw	r20, r26
   13b64:	00 97       	sbiw	r24, 0x00	; 0
   13b66:	11 f0       	breq	.+4      	; 0x13b6c <free+0x7c>
   13b68:	dc 01       	movw	r26, r24
   13b6a:	d3 cf       	rjmp	.-90     	; 0x13b12 <free+0x22>
   13b6c:	fa 01       	movw	r30, r20
   13b6e:	d3 83       	std	Z+3, r29	; 0x03
   13b70:	c2 83       	std	Z+2, r28	; 0x02
   13b72:	21 91       	ld	r18, Z+
   13b74:	31 91       	ld	r19, Z+
   13b76:	e2 0f       	add	r30, r18
   13b78:	f3 1f       	adc	r31, r19
   13b7a:	ce 17       	cp	r28, r30
   13b7c:	df 07       	cpc	r29, r31
   13b7e:	69 f4       	brne	.+26     	; 0x13b9a <free+0xaa>
   13b80:	88 81       	ld	r24, Y
   13b82:	99 81       	ldd	r25, Y+1	; 0x01
   13b84:	28 0f       	add	r18, r24
   13b86:	39 1f       	adc	r19, r25
   13b88:	2e 5f       	subi	r18, 0xFE	; 254
   13b8a:	3f 4f       	sbci	r19, 0xFF	; 255
   13b8c:	fa 01       	movw	r30, r20
   13b8e:	31 83       	std	Z+1, r19	; 0x01
   13b90:	20 83       	st	Z, r18
   13b92:	8a 81       	ldd	r24, Y+2	; 0x02
   13b94:	9b 81       	ldd	r25, Y+3	; 0x03
   13b96:	93 83       	std	Z+3, r25	; 0x03
   13b98:	82 83       	std	Z+2, r24	; 0x02
   13b9a:	df 91       	pop	r29
   13b9c:	cf 91       	pop	r28
   13b9e:	08 95       	ret

00013ba0 <__ftoa_engine>:
   13ba0:	28 30       	cpi	r18, 0x08	; 8
   13ba2:	08 f0       	brcs	.+2      	; 0x13ba6 <__ftoa_engine+0x6>
   13ba4:	27 e0       	ldi	r18, 0x07	; 7
   13ba6:	33 27       	eor	r19, r19
   13ba8:	da 01       	movw	r26, r20
   13baa:	99 0f       	add	r25, r25
   13bac:	31 1d       	adc	r19, r1
   13bae:	87 fd       	sbrc	r24, 7
   13bb0:	91 60       	ori	r25, 0x01	; 1
   13bb2:	00 96       	adiw	r24, 0x00	; 0
   13bb4:	61 05       	cpc	r22, r1
   13bb6:	71 05       	cpc	r23, r1
   13bb8:	39 f4       	brne	.+14     	; 0x13bc8 <__ftoa_engine+0x28>
   13bba:	32 60       	ori	r19, 0x02	; 2
   13bbc:	2e 5f       	subi	r18, 0xFE	; 254
   13bbe:	3d 93       	st	X+, r19
   13bc0:	30 e3       	ldi	r19, 0x30	; 48
   13bc2:	2a 95       	dec	r18
   13bc4:	e1 f7       	brne	.-8      	; 0x13bbe <__ftoa_engine+0x1e>
   13bc6:	08 95       	ret
   13bc8:	9f 3f       	cpi	r25, 0xFF	; 255
   13bca:	30 f0       	brcs	.+12     	; 0x13bd8 <__ftoa_engine+0x38>
   13bcc:	80 38       	cpi	r24, 0x80	; 128
   13bce:	71 05       	cpc	r23, r1
   13bd0:	61 05       	cpc	r22, r1
   13bd2:	09 f0       	breq	.+2      	; 0x13bd6 <__ftoa_engine+0x36>
   13bd4:	3c 5f       	subi	r19, 0xFC	; 252
   13bd6:	3c 5f       	subi	r19, 0xFC	; 252
   13bd8:	3d 93       	st	X+, r19
   13bda:	91 30       	cpi	r25, 0x01	; 1
   13bdc:	08 f0       	brcs	.+2      	; 0x13be0 <__ftoa_engine+0x40>
   13bde:	80 68       	ori	r24, 0x80	; 128
   13be0:	91 1d       	adc	r25, r1
   13be2:	df 93       	push	r29
   13be4:	cf 93       	push	r28
   13be6:	1f 93       	push	r17
   13be8:	0f 93       	push	r16
   13bea:	ff 92       	push	r15
   13bec:	ef 92       	push	r14
   13bee:	19 2f       	mov	r17, r25
   13bf0:	98 7f       	andi	r25, 0xF8	; 248
   13bf2:	96 95       	lsr	r25
   13bf4:	e9 2f       	mov	r30, r25
   13bf6:	96 95       	lsr	r25
   13bf8:	96 95       	lsr	r25
   13bfa:	e9 0f       	add	r30, r25
   13bfc:	ff 27       	eor	r31, r31
   13bfe:	ec 5e       	subi	r30, 0xEC	; 236
   13c00:	f6 4e       	sbci	r31, 0xE6	; 230
   13c02:	99 27       	eor	r25, r25
   13c04:	33 27       	eor	r19, r19
   13c06:	ee 24       	eor	r14, r14
   13c08:	ff 24       	eor	r15, r15
   13c0a:	a7 01       	movw	r20, r14
   13c0c:	e7 01       	movw	r28, r14
   13c0e:	05 90       	lpm	r0, Z+
   13c10:	08 94       	sec
   13c12:	07 94       	ror	r0
   13c14:	28 f4       	brcc	.+10     	; 0x13c20 <__ftoa_engine+0x80>
   13c16:	36 0f       	add	r19, r22
   13c18:	e7 1e       	adc	r14, r23
   13c1a:	f8 1e       	adc	r15, r24
   13c1c:	49 1f       	adc	r20, r25
   13c1e:	51 1d       	adc	r21, r1
   13c20:	66 0f       	add	r22, r22
   13c22:	77 1f       	adc	r23, r23
   13c24:	88 1f       	adc	r24, r24
   13c26:	99 1f       	adc	r25, r25
   13c28:	06 94       	lsr	r0
   13c2a:	a1 f7       	brne	.-24     	; 0x13c14 <__ftoa_engine+0x74>
   13c2c:	05 90       	lpm	r0, Z+
   13c2e:	07 94       	ror	r0
   13c30:	28 f4       	brcc	.+10     	; 0x13c3c <__ftoa_engine+0x9c>
   13c32:	e7 0e       	add	r14, r23
   13c34:	f8 1e       	adc	r15, r24
   13c36:	49 1f       	adc	r20, r25
   13c38:	56 1f       	adc	r21, r22
   13c3a:	c1 1d       	adc	r28, r1
   13c3c:	77 0f       	add	r23, r23
   13c3e:	88 1f       	adc	r24, r24
   13c40:	99 1f       	adc	r25, r25
   13c42:	66 1f       	adc	r22, r22
   13c44:	06 94       	lsr	r0
   13c46:	a1 f7       	brne	.-24     	; 0x13c30 <__ftoa_engine+0x90>
   13c48:	05 90       	lpm	r0, Z+
   13c4a:	07 94       	ror	r0
   13c4c:	28 f4       	brcc	.+10     	; 0x13c58 <__ftoa_engine+0xb8>
   13c4e:	f8 0e       	add	r15, r24
   13c50:	49 1f       	adc	r20, r25
   13c52:	56 1f       	adc	r21, r22
   13c54:	c7 1f       	adc	r28, r23
   13c56:	d1 1d       	adc	r29, r1
   13c58:	88 0f       	add	r24, r24
   13c5a:	99 1f       	adc	r25, r25
   13c5c:	66 1f       	adc	r22, r22
   13c5e:	77 1f       	adc	r23, r23
   13c60:	06 94       	lsr	r0
   13c62:	a1 f7       	brne	.-24     	; 0x13c4c <__ftoa_engine+0xac>
   13c64:	05 90       	lpm	r0, Z+
   13c66:	07 94       	ror	r0
   13c68:	20 f4       	brcc	.+8      	; 0x13c72 <__ftoa_engine+0xd2>
   13c6a:	49 0f       	add	r20, r25
   13c6c:	56 1f       	adc	r21, r22
   13c6e:	c7 1f       	adc	r28, r23
   13c70:	d8 1f       	adc	r29, r24
   13c72:	99 0f       	add	r25, r25
   13c74:	66 1f       	adc	r22, r22
   13c76:	77 1f       	adc	r23, r23
   13c78:	88 1f       	adc	r24, r24
   13c7a:	06 94       	lsr	r0
   13c7c:	a9 f7       	brne	.-22     	; 0x13c68 <__ftoa_engine+0xc8>
   13c7e:	84 91       	lpm	r24, Z+
   13c80:	10 95       	com	r17
   13c82:	17 70       	andi	r17, 0x07	; 7
   13c84:	41 f0       	breq	.+16     	; 0x13c96 <__ftoa_engine+0xf6>
   13c86:	d6 95       	lsr	r29
   13c88:	c7 95       	ror	r28
   13c8a:	57 95       	ror	r21
   13c8c:	47 95       	ror	r20
   13c8e:	f7 94       	ror	r15
   13c90:	e7 94       	ror	r14
   13c92:	1a 95       	dec	r17
   13c94:	c1 f7       	brne	.-16     	; 0x13c86 <__ftoa_engine+0xe6>
   13c96:	ea eb       	ldi	r30, 0xBA	; 186
   13c98:	f8 e1       	ldi	r31, 0x18	; 24
   13c9a:	68 94       	set
   13c9c:	15 90       	lpm	r1, Z+
   13c9e:	15 91       	lpm	r17, Z+
   13ca0:	35 91       	lpm	r19, Z+
   13ca2:	65 91       	lpm	r22, Z+
   13ca4:	95 91       	lpm	r25, Z+
   13ca6:	05 90       	lpm	r0, Z+
   13ca8:	7f e2       	ldi	r23, 0x2F	; 47
   13caa:	73 95       	inc	r23
   13cac:	e1 18       	sub	r14, r1
   13cae:	f1 0a       	sbc	r15, r17
   13cb0:	43 0b       	sbc	r20, r19
   13cb2:	56 0b       	sbc	r21, r22
   13cb4:	c9 0b       	sbc	r28, r25
   13cb6:	d0 09       	sbc	r29, r0
   13cb8:	c0 f7       	brcc	.-16     	; 0x13caa <__ftoa_engine+0x10a>
   13cba:	e1 0c       	add	r14, r1
   13cbc:	f1 1e       	adc	r15, r17
   13cbe:	43 1f       	adc	r20, r19
   13cc0:	56 1f       	adc	r21, r22
   13cc2:	c9 1f       	adc	r28, r25
   13cc4:	d0 1d       	adc	r29, r0
   13cc6:	7e f4       	brtc	.+30     	; 0x13ce6 <__ftoa_engine+0x146>
   13cc8:	70 33       	cpi	r23, 0x30	; 48
   13cca:	11 f4       	brne	.+4      	; 0x13cd0 <__ftoa_engine+0x130>
   13ccc:	8a 95       	dec	r24
   13cce:	e6 cf       	rjmp	.-52     	; 0x13c9c <__ftoa_engine+0xfc>
   13cd0:	e8 94       	clt
   13cd2:	01 50       	subi	r16, 0x01	; 1
   13cd4:	30 f0       	brcs	.+12     	; 0x13ce2 <__ftoa_engine+0x142>
   13cd6:	08 0f       	add	r16, r24
   13cd8:	0a f4       	brpl	.+2      	; 0x13cdc <__ftoa_engine+0x13c>
   13cda:	00 27       	eor	r16, r16
   13cdc:	02 17       	cp	r16, r18
   13cde:	08 f4       	brcc	.+2      	; 0x13ce2 <__ftoa_engine+0x142>
   13ce0:	20 2f       	mov	r18, r16
   13ce2:	23 95       	inc	r18
   13ce4:	02 2f       	mov	r16, r18
   13ce6:	7a 33       	cpi	r23, 0x3A	; 58
   13ce8:	28 f0       	brcs	.+10     	; 0x13cf4 <__ftoa_engine+0x154>
   13cea:	79 e3       	ldi	r23, 0x39	; 57
   13cec:	7d 93       	st	X+, r23
   13cee:	2a 95       	dec	r18
   13cf0:	e9 f7       	brne	.-6      	; 0x13cec <__ftoa_engine+0x14c>
   13cf2:	10 c0       	rjmp	.+32     	; 0x13d14 <__ftoa_engine+0x174>
   13cf4:	7d 93       	st	X+, r23
   13cf6:	2a 95       	dec	r18
   13cf8:	89 f6       	brne	.-94     	; 0x13c9c <__ftoa_engine+0xfc>
   13cfa:	06 94       	lsr	r0
   13cfc:	97 95       	ror	r25
   13cfe:	67 95       	ror	r22
   13d00:	37 95       	ror	r19
   13d02:	17 95       	ror	r17
   13d04:	17 94       	ror	r1
   13d06:	e1 18       	sub	r14, r1
   13d08:	f1 0a       	sbc	r15, r17
   13d0a:	43 0b       	sbc	r20, r19
   13d0c:	56 0b       	sbc	r21, r22
   13d0e:	c9 0b       	sbc	r28, r25
   13d10:	d0 09       	sbc	r29, r0
   13d12:	98 f0       	brcs	.+38     	; 0x13d3a <__ftoa_engine+0x19a>
   13d14:	23 95       	inc	r18
   13d16:	7e 91       	ld	r23, -X
   13d18:	73 95       	inc	r23
   13d1a:	7a 33       	cpi	r23, 0x3A	; 58
   13d1c:	08 f0       	brcs	.+2      	; 0x13d20 <__ftoa_engine+0x180>
   13d1e:	70 e3       	ldi	r23, 0x30	; 48
   13d20:	7c 93       	st	X, r23
   13d22:	20 13       	cpse	r18, r16
   13d24:	b8 f7       	brcc	.-18     	; 0x13d14 <__ftoa_engine+0x174>
   13d26:	7e 91       	ld	r23, -X
   13d28:	70 61       	ori	r23, 0x10	; 16
   13d2a:	7d 93       	st	X+, r23
   13d2c:	30 f0       	brcs	.+12     	; 0x13d3a <__ftoa_engine+0x19a>
   13d2e:	83 95       	inc	r24
   13d30:	71 e3       	ldi	r23, 0x31	; 49
   13d32:	7d 93       	st	X+, r23
   13d34:	70 e3       	ldi	r23, 0x30	; 48
   13d36:	2a 95       	dec	r18
   13d38:	e1 f7       	brne	.-8      	; 0x13d32 <__ftoa_engine+0x192>
   13d3a:	11 24       	eor	r1, r1
   13d3c:	ef 90       	pop	r14
   13d3e:	ff 90       	pop	r15
   13d40:	0f 91       	pop	r16
   13d42:	1f 91       	pop	r17
   13d44:	cf 91       	pop	r28
   13d46:	df 91       	pop	r29
   13d48:	99 27       	eor	r25, r25
   13d4a:	87 fd       	sbrc	r24, 7
   13d4c:	90 95       	com	r25
   13d4e:	08 95       	ret

00013d50 <isspace>:
   13d50:	91 11       	cpse	r25, r1
   13d52:	1f c2       	rjmp	.+1086   	; 0x14192 <__ctype_isfalse>
   13d54:	80 32       	cpi	r24, 0x20	; 32
   13d56:	19 f0       	breq	.+6      	; 0x13d5e <isspace+0xe>
   13d58:	89 50       	subi	r24, 0x09	; 9
   13d5a:	85 50       	subi	r24, 0x05	; 5
   13d5c:	d0 f7       	brcc	.-12     	; 0x13d52 <isspace+0x2>
   13d5e:	08 95       	ret

00013d60 <tolower>:
   13d60:	91 11       	cpse	r25, r1
   13d62:	08 95       	ret
   13d64:	81 54       	subi	r24, 0x41	; 65
   13d66:	8a 51       	subi	r24, 0x1A	; 26
   13d68:	08 f4       	brcc	.+2      	; 0x13d6c <tolower+0xc>
   13d6a:	80 5e       	subi	r24, 0xE0	; 224
   13d6c:	85 5a       	subi	r24, 0xA5	; 165
   13d6e:	08 95       	ret

00013d70 <strchr_P>:
   13d70:	fc 01       	movw	r30, r24
   13d72:	05 90       	lpm	r0, Z+
   13d74:	06 16       	cp	r0, r22
   13d76:	21 f0       	breq	.+8      	; 0x13d80 <strchr_P+0x10>
   13d78:	00 20       	and	r0, r0
   13d7a:	d9 f7       	brne	.-10     	; 0x13d72 <strchr_P+0x2>
   13d7c:	c0 01       	movw	r24, r0
   13d7e:	08 95       	ret
   13d80:	31 97       	sbiw	r30, 0x01	; 1
   13d82:	cf 01       	movw	r24, r30
   13d84:	08 95       	ret

00013d86 <strnlen_P>:
   13d86:	fc 01       	movw	r30, r24
   13d88:	05 90       	lpm	r0, Z+
   13d8a:	61 50       	subi	r22, 0x01	; 1
   13d8c:	70 40       	sbci	r23, 0x00	; 0
   13d8e:	01 10       	cpse	r0, r1
   13d90:	d8 f7       	brcc	.-10     	; 0x13d88 <strnlen_P+0x2>
   13d92:	80 95       	com	r24
   13d94:	90 95       	com	r25
   13d96:	8e 0f       	add	r24, r30
   13d98:	9f 1f       	adc	r25, r31
   13d9a:	08 95       	ret

00013d9c <memset>:
   13d9c:	dc 01       	movw	r26, r24
   13d9e:	01 c0       	rjmp	.+2      	; 0x13da2 <memset+0x6>
   13da0:	6d 93       	st	X+, r22
   13da2:	41 50       	subi	r20, 0x01	; 1
   13da4:	50 40       	sbci	r21, 0x00	; 0
   13da6:	e0 f7       	brcc	.-8      	; 0x13da0 <memset+0x4>
   13da8:	08 95       	ret

00013daa <strnlen>:
   13daa:	fc 01       	movw	r30, r24
   13dac:	61 50       	subi	r22, 0x01	; 1
   13dae:	70 40       	sbci	r23, 0x00	; 0
   13db0:	01 90       	ld	r0, Z+
   13db2:	01 10       	cpse	r0, r1
   13db4:	d8 f7       	brcc	.-10     	; 0x13dac <strnlen+0x2>
   13db6:	80 95       	com	r24
   13db8:	90 95       	com	r25
   13dba:	8e 0f       	add	r24, r30
   13dbc:	9f 1f       	adc	r25, r31
   13dbe:	08 95       	ret

00013dc0 <itoa>:
   13dc0:	fb 01       	movw	r30, r22
   13dc2:	9f 01       	movw	r18, r30
   13dc4:	e8 94       	clt
   13dc6:	42 30       	cpi	r20, 0x02	; 2
   13dc8:	c4 f0       	brlt	.+48     	; 0x13dfa <itoa+0x3a>
   13dca:	45 32       	cpi	r20, 0x25	; 37
   13dcc:	b4 f4       	brge	.+44     	; 0x13dfa <itoa+0x3a>
   13dce:	4a 30       	cpi	r20, 0x0A	; 10
   13dd0:	29 f4       	brne	.+10     	; 0x13ddc <itoa+0x1c>
   13dd2:	97 fb       	bst	r25, 7
   13dd4:	1e f4       	brtc	.+6      	; 0x13ddc <itoa+0x1c>
   13dd6:	90 95       	com	r25
   13dd8:	81 95       	neg	r24
   13dda:	9f 4f       	sbci	r25, 0xFF	; 255
   13ddc:	64 2f       	mov	r22, r20
   13dde:	77 27       	eor	r23, r23
   13de0:	0e 94 95 9c 	call	0x1392a	; 0x1392a <__udivmodhi4>
   13de4:	80 5d       	subi	r24, 0xD0	; 208
   13de6:	8a 33       	cpi	r24, 0x3A	; 58
   13de8:	0c f0       	brlt	.+2      	; 0x13dec <itoa+0x2c>
   13dea:	89 5d       	subi	r24, 0xD9	; 217
   13dec:	81 93       	st	Z+, r24
   13dee:	cb 01       	movw	r24, r22
   13df0:	00 97       	sbiw	r24, 0x00	; 0
   13df2:	a1 f7       	brne	.-24     	; 0x13ddc <itoa+0x1c>
   13df4:	16 f4       	brtc	.+4      	; 0x13dfa <itoa+0x3a>
   13df6:	5d e2       	ldi	r21, 0x2D	; 45
   13df8:	51 93       	st	Z+, r21
   13dfa:	10 82       	st	Z, r1
   13dfc:	c9 01       	movw	r24, r18
   13dfe:	0c 94 cc a0 	jmp	0x14198	; 0x14198 <strrev>

00013e02 <fgetc>:
   13e02:	cf 93       	push	r28
   13e04:	df 93       	push	r29
   13e06:	ec 01       	movw	r28, r24
   13e08:	4b 81       	ldd	r20, Y+3	; 0x03
   13e0a:	40 ff       	sbrs	r20, 0
   13e0c:	1a c0       	rjmp	.+52     	; 0x13e42 <fgetc+0x40>
   13e0e:	46 ff       	sbrs	r20, 6
   13e10:	0a c0       	rjmp	.+20     	; 0x13e26 <fgetc+0x24>
   13e12:	4f 7b       	andi	r20, 0xBF	; 191
   13e14:	4b 83       	std	Y+3, r20	; 0x03
   13e16:	8e 81       	ldd	r24, Y+6	; 0x06
   13e18:	9f 81       	ldd	r25, Y+7	; 0x07
   13e1a:	01 96       	adiw	r24, 0x01	; 1
   13e1c:	9f 83       	std	Y+7, r25	; 0x07
   13e1e:	8e 83       	std	Y+6, r24	; 0x06
   13e20:	8a 81       	ldd	r24, Y+2	; 0x02
   13e22:	28 2f       	mov	r18, r24
   13e24:	2b c0       	rjmp	.+86     	; 0x13e7c <fgetc+0x7a>
   13e26:	42 ff       	sbrs	r20, 2
   13e28:	13 c0       	rjmp	.+38     	; 0x13e50 <fgetc+0x4e>
   13e2a:	e8 81       	ld	r30, Y
   13e2c:	f9 81       	ldd	r31, Y+1	; 0x01
   13e2e:	80 81       	ld	r24, Z
   13e30:	28 2f       	mov	r18, r24
   13e32:	33 27       	eor	r19, r19
   13e34:	27 fd       	sbrc	r18, 7
   13e36:	30 95       	com	r19
   13e38:	21 15       	cp	r18, r1
   13e3a:	31 05       	cpc	r19, r1
   13e3c:	29 f4       	brne	.+10     	; 0x13e48 <fgetc+0x46>
   13e3e:	40 62       	ori	r20, 0x20	; 32
   13e40:	4b 83       	std	Y+3, r20	; 0x03
   13e42:	2f ef       	ldi	r18, 0xFF	; 255
   13e44:	3f ef       	ldi	r19, 0xFF	; 255
   13e46:	1b c0       	rjmp	.+54     	; 0x13e7e <fgetc+0x7c>
   13e48:	31 96       	adiw	r30, 0x01	; 1
   13e4a:	f9 83       	std	Y+1, r31	; 0x01
   13e4c:	e8 83       	st	Y, r30
   13e4e:	11 c0       	rjmp	.+34     	; 0x13e72 <fgetc+0x70>
   13e50:	ea 85       	ldd	r30, Y+10	; 0x0a
   13e52:	fb 85       	ldd	r31, Y+11	; 0x0b
   13e54:	ce 01       	movw	r24, r28
   13e56:	09 95       	icall
   13e58:	9c 01       	movw	r18, r24
   13e5a:	97 ff       	sbrs	r25, 7
   13e5c:	0a c0       	rjmp	.+20     	; 0x13e72 <fgetc+0x70>
   13e5e:	9b 81       	ldd	r25, Y+3	; 0x03
   13e60:	2f 5f       	subi	r18, 0xFF	; 255
   13e62:	3f 4f       	sbci	r19, 0xFF	; 255
   13e64:	11 f0       	breq	.+4      	; 0x13e6a <fgetc+0x68>
   13e66:	80 e2       	ldi	r24, 0x20	; 32
   13e68:	01 c0       	rjmp	.+2      	; 0x13e6c <fgetc+0x6a>
   13e6a:	80 e1       	ldi	r24, 0x10	; 16
   13e6c:	89 2b       	or	r24, r25
   13e6e:	8b 83       	std	Y+3, r24	; 0x03
   13e70:	e8 cf       	rjmp	.-48     	; 0x13e42 <fgetc+0x40>
   13e72:	8e 81       	ldd	r24, Y+6	; 0x06
   13e74:	9f 81       	ldd	r25, Y+7	; 0x07
   13e76:	01 96       	adiw	r24, 0x01	; 1
   13e78:	9f 83       	std	Y+7, r25	; 0x07
   13e7a:	8e 83       	std	Y+6, r24	; 0x06
   13e7c:	30 e0       	ldi	r19, 0x00	; 0
   13e7e:	c9 01       	movw	r24, r18
   13e80:	df 91       	pop	r29
   13e82:	cf 91       	pop	r28
   13e84:	08 95       	ret

00013e86 <fprintf>:
   13e86:	df 93       	push	r29
   13e88:	cf 93       	push	r28
   13e8a:	cd b7       	in	r28, 0x3d	; 61
   13e8c:	de b7       	in	r29, 0x3e	; 62
   13e8e:	9e 01       	movw	r18, r28
   13e90:	27 5f       	subi	r18, 0xF7	; 247
   13e92:	3f 4f       	sbci	r19, 0xFF	; 255
   13e94:	8d 81       	ldd	r24, Y+5	; 0x05
   13e96:	9e 81       	ldd	r25, Y+6	; 0x06
   13e98:	6f 81       	ldd	r22, Y+7	; 0x07
   13e9a:	78 85       	ldd	r23, Y+8	; 0x08
   13e9c:	a9 01       	movw	r20, r18
   13e9e:	0e 94 d8 91 	call	0x123b0	; 0x123b0 <vfprintf>
   13ea2:	cf 91       	pop	r28
   13ea4:	df 91       	pop	r29
   13ea6:	08 95       	ret

00013ea8 <fprintf_P>:
   13ea8:	0f 93       	push	r16
   13eaa:	1f 93       	push	r17
   13eac:	df 93       	push	r29
   13eae:	cf 93       	push	r28
   13eb0:	cd b7       	in	r28, 0x3d	; 61
   13eb2:	de b7       	in	r29, 0x3e	; 62
   13eb4:	0f 81       	ldd	r16, Y+7	; 0x07
   13eb6:	18 85       	ldd	r17, Y+8	; 0x08
   13eb8:	9e 01       	movw	r18, r28
   13eba:	25 5f       	subi	r18, 0xF5	; 245
   13ebc:	3f 4f       	sbci	r19, 0xFF	; 255
   13ebe:	f8 01       	movw	r30, r16
   13ec0:	83 81       	ldd	r24, Z+3	; 0x03
   13ec2:	88 60       	ori	r24, 0x08	; 8
   13ec4:	83 83       	std	Z+3, r24	; 0x03
   13ec6:	c8 01       	movw	r24, r16
   13ec8:	69 85       	ldd	r22, Y+9	; 0x09
   13eca:	7a 85       	ldd	r23, Y+10	; 0x0a
   13ecc:	a9 01       	movw	r20, r18
   13ece:	0e 94 d8 91 	call	0x123b0	; 0x123b0 <vfprintf>
   13ed2:	f8 01       	movw	r30, r16
   13ed4:	23 81       	ldd	r18, Z+3	; 0x03
   13ed6:	27 7f       	andi	r18, 0xF7	; 247
   13ed8:	23 83       	std	Z+3, r18	; 0x03
   13eda:	cf 91       	pop	r28
   13edc:	df 91       	pop	r29
   13ede:	1f 91       	pop	r17
   13ee0:	0f 91       	pop	r16
   13ee2:	08 95       	ret

00013ee4 <fputc>:
   13ee4:	0f 93       	push	r16
   13ee6:	1f 93       	push	r17
   13ee8:	cf 93       	push	r28
   13eea:	df 93       	push	r29
   13eec:	8c 01       	movw	r16, r24
   13eee:	eb 01       	movw	r28, r22
   13ef0:	8b 81       	ldd	r24, Y+3	; 0x03
   13ef2:	81 ff       	sbrs	r24, 1
   13ef4:	1b c0       	rjmp	.+54     	; 0x13f2c <fputc+0x48>
   13ef6:	82 ff       	sbrs	r24, 2
   13ef8:	0d c0       	rjmp	.+26     	; 0x13f14 <fputc+0x30>
   13efa:	2e 81       	ldd	r18, Y+6	; 0x06
   13efc:	3f 81       	ldd	r19, Y+7	; 0x07
   13efe:	8c 81       	ldd	r24, Y+4	; 0x04
   13f00:	9d 81       	ldd	r25, Y+5	; 0x05
   13f02:	28 17       	cp	r18, r24
   13f04:	39 07       	cpc	r19, r25
   13f06:	64 f4       	brge	.+24     	; 0x13f20 <fputc+0x3c>
   13f08:	e8 81       	ld	r30, Y
   13f0a:	f9 81       	ldd	r31, Y+1	; 0x01
   13f0c:	01 93       	st	Z+, r16
   13f0e:	f9 83       	std	Y+1, r31	; 0x01
   13f10:	e8 83       	st	Y, r30
   13f12:	06 c0       	rjmp	.+12     	; 0x13f20 <fputc+0x3c>
   13f14:	e8 85       	ldd	r30, Y+8	; 0x08
   13f16:	f9 85       	ldd	r31, Y+9	; 0x09
   13f18:	80 2f       	mov	r24, r16
   13f1a:	09 95       	icall
   13f1c:	89 2b       	or	r24, r25
   13f1e:	31 f4       	brne	.+12     	; 0x13f2c <fputc+0x48>
   13f20:	8e 81       	ldd	r24, Y+6	; 0x06
   13f22:	9f 81       	ldd	r25, Y+7	; 0x07
   13f24:	01 96       	adiw	r24, 0x01	; 1
   13f26:	9f 83       	std	Y+7, r25	; 0x07
   13f28:	8e 83       	std	Y+6, r24	; 0x06
   13f2a:	02 c0       	rjmp	.+4      	; 0x13f30 <fputc+0x4c>
   13f2c:	0f ef       	ldi	r16, 0xFF	; 255
   13f2e:	1f ef       	ldi	r17, 0xFF	; 255
   13f30:	c8 01       	movw	r24, r16
   13f32:	df 91       	pop	r29
   13f34:	cf 91       	pop	r28
   13f36:	1f 91       	pop	r17
   13f38:	0f 91       	pop	r16
   13f3a:	08 95       	ret

00013f3c <fputs>:
   13f3c:	ef 92       	push	r14
   13f3e:	ff 92       	push	r15
   13f40:	0f 93       	push	r16
   13f42:	1f 93       	push	r17
   13f44:	cf 93       	push	r28
   13f46:	df 93       	push	r29
   13f48:	7c 01       	movw	r14, r24
   13f4a:	8b 01       	movw	r16, r22
   13f4c:	db 01       	movw	r26, r22
   13f4e:	13 96       	adiw	r26, 0x03	; 3
   13f50:	8c 91       	ld	r24, X
   13f52:	81 fd       	sbrc	r24, 1
   13f54:	03 c0       	rjmp	.+6      	; 0x13f5c <fputs+0x20>
   13f56:	cf ef       	ldi	r28, 0xFF	; 255
   13f58:	df ef       	ldi	r29, 0xFF	; 255
   13f5a:	13 c0       	rjmp	.+38     	; 0x13f82 <fputs+0x46>
   13f5c:	c0 e0       	ldi	r28, 0x00	; 0
   13f5e:	d0 e0       	ldi	r29, 0x00	; 0
   13f60:	0b c0       	rjmp	.+22     	; 0x13f78 <fputs+0x3c>
   13f62:	d8 01       	movw	r26, r16
   13f64:	18 96       	adiw	r26, 0x08	; 8
   13f66:	ed 91       	ld	r30, X+
   13f68:	fc 91       	ld	r31, X
   13f6a:	19 97       	sbiw	r26, 0x09	; 9
   13f6c:	b8 01       	movw	r22, r16
   13f6e:	09 95       	icall
   13f70:	89 2b       	or	r24, r25
   13f72:	11 f0       	breq	.+4      	; 0x13f78 <fputs+0x3c>
   13f74:	cf ef       	ldi	r28, 0xFF	; 255
   13f76:	df ef       	ldi	r29, 0xFF	; 255
   13f78:	f7 01       	movw	r30, r14
   13f7a:	81 91       	ld	r24, Z+
   13f7c:	7f 01       	movw	r14, r30
   13f7e:	88 23       	and	r24, r24
   13f80:	81 f7       	brne	.-32     	; 0x13f62 <fputs+0x26>
   13f82:	ce 01       	movw	r24, r28
   13f84:	df 91       	pop	r29
   13f86:	cf 91       	pop	r28
   13f88:	1f 91       	pop	r17
   13f8a:	0f 91       	pop	r16
   13f8c:	ff 90       	pop	r15
   13f8e:	ef 90       	pop	r14
   13f90:	08 95       	ret

00013f92 <printf>:
   13f92:	df 93       	push	r29
   13f94:	cf 93       	push	r28
   13f96:	cd b7       	in	r28, 0x3d	; 61
   13f98:	de b7       	in	r29, 0x3e	; 62
   13f9a:	fe 01       	movw	r30, r28
   13f9c:	35 96       	adiw	r30, 0x05	; 5
   13f9e:	61 91       	ld	r22, Z+
   13fa0:	71 91       	ld	r23, Z+
   13fa2:	80 91 d0 79 	lds	r24, 0x79D0
   13fa6:	90 91 d1 79 	lds	r25, 0x79D1
   13faa:	af 01       	movw	r20, r30
   13fac:	0e 94 d8 91 	call	0x123b0	; 0x123b0 <vfprintf>
   13fb0:	cf 91       	pop	r28
   13fb2:	df 91       	pop	r29
   13fb4:	08 95       	ret

00013fb6 <putchar>:
   13fb6:	60 91 d0 79 	lds	r22, 0x79D0
   13fba:	70 91 d1 79 	lds	r23, 0x79D1
   13fbe:	0e 94 72 9f 	call	0x13ee4	; 0x13ee4 <fputc>
   13fc2:	08 95       	ret

00013fc4 <puts>:
   13fc4:	0f 93       	push	r16
   13fc6:	1f 93       	push	r17
   13fc8:	cf 93       	push	r28
   13fca:	df 93       	push	r29
   13fcc:	8c 01       	movw	r16, r24
   13fce:	e0 91 d0 79 	lds	r30, 0x79D0
   13fd2:	f0 91 d1 79 	lds	r31, 0x79D1
   13fd6:	83 81       	ldd	r24, Z+3	; 0x03
   13fd8:	81 ff       	sbrs	r24, 1
   13fda:	21 c0       	rjmp	.+66     	; 0x1401e <puts+0x5a>
   13fdc:	c0 e0       	ldi	r28, 0x00	; 0
   13fde:	d0 e0       	ldi	r29, 0x00	; 0
   13fe0:	0d c0       	rjmp	.+26     	; 0x13ffc <puts+0x38>
   13fe2:	e0 91 d0 79 	lds	r30, 0x79D0
   13fe6:	f0 91 d1 79 	lds	r31, 0x79D1
   13fea:	20 85       	ldd	r18, Z+8	; 0x08
   13fec:	31 85       	ldd	r19, Z+9	; 0x09
   13fee:	bf 01       	movw	r22, r30
   13ff0:	f9 01       	movw	r30, r18
   13ff2:	09 95       	icall
   13ff4:	89 2b       	or	r24, r25
   13ff6:	11 f0       	breq	.+4      	; 0x13ffc <puts+0x38>
   13ff8:	cf ef       	ldi	r28, 0xFF	; 255
   13ffa:	df ef       	ldi	r29, 0xFF	; 255
   13ffc:	f8 01       	movw	r30, r16
   13ffe:	81 91       	ld	r24, Z+
   14000:	8f 01       	movw	r16, r30
   14002:	88 23       	and	r24, r24
   14004:	71 f7       	brne	.-36     	; 0x13fe2 <puts+0x1e>
   14006:	e0 91 d0 79 	lds	r30, 0x79D0
   1400a:	f0 91 d1 79 	lds	r31, 0x79D1
   1400e:	20 85       	ldd	r18, Z+8	; 0x08
   14010:	31 85       	ldd	r19, Z+9	; 0x09
   14012:	8a e0       	ldi	r24, 0x0A	; 10
   14014:	bf 01       	movw	r22, r30
   14016:	f9 01       	movw	r30, r18
   14018:	09 95       	icall
   1401a:	89 2b       	or	r24, r25
   1401c:	11 f0       	breq	.+4      	; 0x14022 <puts+0x5e>
   1401e:	cf ef       	ldi	r28, 0xFF	; 255
   14020:	df ef       	ldi	r29, 0xFF	; 255
   14022:	ce 01       	movw	r24, r28
   14024:	df 91       	pop	r29
   14026:	cf 91       	pop	r28
   14028:	1f 91       	pop	r17
   1402a:	0f 91       	pop	r16
   1402c:	08 95       	ret

0001402e <scanf>:
   1402e:	df 93       	push	r29
   14030:	cf 93       	push	r28
   14032:	cd b7       	in	r28, 0x3d	; 61
   14034:	de b7       	in	r29, 0x3e	; 62
   14036:	fe 01       	movw	r30, r28
   14038:	35 96       	adiw	r30, 0x05	; 5
   1403a:	61 91       	ld	r22, Z+
   1403c:	71 91       	ld	r23, Z+
   1403e:	80 91 ce 79 	lds	r24, 0x79CE
   14042:	90 91 cf 79 	lds	r25, 0x79CF
   14046:	af 01       	movw	r20, r30
   14048:	0e 94 8f 98 	call	0x1311e	; 0x1311e <vfscanf>
   1404c:	cf 91       	pop	r28
   1404e:	df 91       	pop	r29
   14050:	08 95       	ret

00014052 <ungetc>:
   14052:	9c 01       	movw	r18, r24
   14054:	fb 01       	movw	r30, r22
   14056:	83 81       	ldd	r24, Z+3	; 0x03
   14058:	80 ff       	sbrs	r24, 0
   1405a:	11 c0       	rjmp	.+34     	; 0x1407e <ungetc+0x2c>
   1405c:	86 fd       	sbrc	r24, 6
   1405e:	0f c0       	rjmp	.+30     	; 0x1407e <ungetc+0x2c>
   14060:	9f ef       	ldi	r25, 0xFF	; 255
   14062:	2f 3f       	cpi	r18, 0xFF	; 255
   14064:	39 07       	cpc	r19, r25
   14066:	59 f0       	breq	.+22     	; 0x1407e <ungetc+0x2c>
   14068:	22 83       	std	Z+2, r18	; 0x02
   1406a:	80 64       	ori	r24, 0x40	; 64
   1406c:	8f 7d       	andi	r24, 0xDF	; 223
   1406e:	83 83       	std	Z+3, r24	; 0x03
   14070:	86 81       	ldd	r24, Z+6	; 0x06
   14072:	97 81       	ldd	r25, Z+7	; 0x07
   14074:	01 97       	sbiw	r24, 0x01	; 1
   14076:	97 83       	std	Z+7, r25	; 0x07
   14078:	86 83       	std	Z+6, r24	; 0x06
   1407a:	30 e0       	ldi	r19, 0x00	; 0
   1407c:	02 c0       	rjmp	.+4      	; 0x14082 <ungetc+0x30>
   1407e:	2f ef       	ldi	r18, 0xFF	; 255
   14080:	3f ef       	ldi	r19, 0xFF	; 255
   14082:	c9 01       	movw	r24, r18
   14084:	08 95       	ret

00014086 <__ultoa_invert>:
   14086:	fa 01       	movw	r30, r20
   14088:	aa 27       	eor	r26, r26
   1408a:	28 30       	cpi	r18, 0x08	; 8
   1408c:	51 f1       	breq	.+84     	; 0x140e2 <__ultoa_invert+0x5c>
   1408e:	20 31       	cpi	r18, 0x10	; 16
   14090:	81 f1       	breq	.+96     	; 0x140f2 <__ultoa_invert+0x6c>
   14092:	e8 94       	clt
   14094:	6f 93       	push	r22
   14096:	6e 7f       	andi	r22, 0xFE	; 254
   14098:	6e 5f       	subi	r22, 0xFE	; 254
   1409a:	7f 4f       	sbci	r23, 0xFF	; 255
   1409c:	8f 4f       	sbci	r24, 0xFF	; 255
   1409e:	9f 4f       	sbci	r25, 0xFF	; 255
   140a0:	af 4f       	sbci	r26, 0xFF	; 255
   140a2:	b1 e0       	ldi	r27, 0x01	; 1
   140a4:	3e d0       	rcall	.+124    	; 0x14122 <__ultoa_invert+0x9c>
   140a6:	b4 e0       	ldi	r27, 0x04	; 4
   140a8:	3c d0       	rcall	.+120    	; 0x14122 <__ultoa_invert+0x9c>
   140aa:	67 0f       	add	r22, r23
   140ac:	78 1f       	adc	r23, r24
   140ae:	89 1f       	adc	r24, r25
   140b0:	9a 1f       	adc	r25, r26
   140b2:	a1 1d       	adc	r26, r1
   140b4:	68 0f       	add	r22, r24
   140b6:	79 1f       	adc	r23, r25
   140b8:	8a 1f       	adc	r24, r26
   140ba:	91 1d       	adc	r25, r1
   140bc:	a1 1d       	adc	r26, r1
   140be:	6a 0f       	add	r22, r26
   140c0:	71 1d       	adc	r23, r1
   140c2:	81 1d       	adc	r24, r1
   140c4:	91 1d       	adc	r25, r1
   140c6:	a1 1d       	adc	r26, r1
   140c8:	20 d0       	rcall	.+64     	; 0x1410a <__ultoa_invert+0x84>
   140ca:	09 f4       	brne	.+2      	; 0x140ce <__ultoa_invert+0x48>
   140cc:	68 94       	set
   140ce:	3f 91       	pop	r19
   140d0:	2a e0       	ldi	r18, 0x0A	; 10
   140d2:	26 9f       	mul	r18, r22
   140d4:	11 24       	eor	r1, r1
   140d6:	30 19       	sub	r19, r0
   140d8:	30 5d       	subi	r19, 0xD0	; 208
   140da:	31 93       	st	Z+, r19
   140dc:	de f6       	brtc	.-74     	; 0x14094 <__ultoa_invert+0xe>
   140de:	cf 01       	movw	r24, r30
   140e0:	08 95       	ret
   140e2:	46 2f       	mov	r20, r22
   140e4:	47 70       	andi	r20, 0x07	; 7
   140e6:	40 5d       	subi	r20, 0xD0	; 208
   140e8:	41 93       	st	Z+, r20
   140ea:	b3 e0       	ldi	r27, 0x03	; 3
   140ec:	0f d0       	rcall	.+30     	; 0x1410c <__ultoa_invert+0x86>
   140ee:	c9 f7       	brne	.-14     	; 0x140e2 <__ultoa_invert+0x5c>
   140f0:	f6 cf       	rjmp	.-20     	; 0x140de <__ultoa_invert+0x58>
   140f2:	46 2f       	mov	r20, r22
   140f4:	4f 70       	andi	r20, 0x0F	; 15
   140f6:	40 5d       	subi	r20, 0xD0	; 208
   140f8:	4a 33       	cpi	r20, 0x3A	; 58
   140fa:	18 f0       	brcs	.+6      	; 0x14102 <__ultoa_invert+0x7c>
   140fc:	49 5d       	subi	r20, 0xD9	; 217
   140fe:	31 fd       	sbrc	r19, 1
   14100:	40 52       	subi	r20, 0x20	; 32
   14102:	41 93       	st	Z+, r20
   14104:	02 d0       	rcall	.+4      	; 0x1410a <__ultoa_invert+0x84>
   14106:	a9 f7       	brne	.-22     	; 0x140f2 <__ultoa_invert+0x6c>
   14108:	ea cf       	rjmp	.-44     	; 0x140de <__ultoa_invert+0x58>
   1410a:	b4 e0       	ldi	r27, 0x04	; 4
   1410c:	a6 95       	lsr	r26
   1410e:	97 95       	ror	r25
   14110:	87 95       	ror	r24
   14112:	77 95       	ror	r23
   14114:	67 95       	ror	r22
   14116:	ba 95       	dec	r27
   14118:	c9 f7       	brne	.-14     	; 0x1410c <__ultoa_invert+0x86>
   1411a:	00 97       	sbiw	r24, 0x00	; 0
   1411c:	61 05       	cpc	r22, r1
   1411e:	71 05       	cpc	r23, r1
   14120:	08 95       	ret
   14122:	9b 01       	movw	r18, r22
   14124:	ac 01       	movw	r20, r24
   14126:	0a 2e       	mov	r0, r26
   14128:	06 94       	lsr	r0
   1412a:	57 95       	ror	r21
   1412c:	47 95       	ror	r20
   1412e:	37 95       	ror	r19
   14130:	27 95       	ror	r18
   14132:	ba 95       	dec	r27
   14134:	c9 f7       	brne	.-14     	; 0x14128 <__ultoa_invert+0xa2>
   14136:	62 0f       	add	r22, r18
   14138:	73 1f       	adc	r23, r19
   1413a:	84 1f       	adc	r24, r20
   1413c:	95 1f       	adc	r25, r21
   1413e:	a0 1d       	adc	r26, r0
   14140:	08 95       	ret

00014142 <__eerd_block_m1280>:
   14142:	dc 01       	movw	r26, r24
   14144:	cb 01       	movw	r24, r22

00014146 <__eerd_blraw_m1280>:
   14146:	fc 01       	movw	r30, r24
   14148:	f9 99       	sbic	0x1f, 1	; 31
   1414a:	fe cf       	rjmp	.-4      	; 0x14148 <__eerd_blraw_m1280+0x2>
   1414c:	06 c0       	rjmp	.+12     	; 0x1415a <__eerd_blraw_m1280+0x14>
   1414e:	f2 bd       	out	0x22, r31	; 34
   14150:	e1 bd       	out	0x21, r30	; 33
   14152:	f8 9a       	sbi	0x1f, 0	; 31
   14154:	31 96       	adiw	r30, 0x01	; 1
   14156:	00 b4       	in	r0, 0x20	; 32
   14158:	0d 92       	st	X+, r0
   1415a:	41 50       	subi	r20, 0x01	; 1
   1415c:	50 40       	sbci	r21, 0x00	; 0
   1415e:	b8 f7       	brcc	.-18     	; 0x1414e <__eerd_blraw_m1280+0x8>
   14160:	08 95       	ret

00014162 <__eewr_block_m1280>:
   14162:	dc 01       	movw	r26, r24
   14164:	cb 01       	movw	r24, r22
   14166:	03 c0       	rjmp	.+6      	; 0x1416e <__eewr_block_m1280+0xc>
   14168:	2d 91       	ld	r18, X+
   1416a:	0e 94 bc a0 	call	0x14178	; 0x14178 <__eewr_r18_m1280>
   1416e:	41 50       	subi	r20, 0x01	; 1
   14170:	50 40       	sbci	r21, 0x00	; 0
   14172:	d0 f7       	brcc	.-12     	; 0x14168 <__eewr_block_m1280+0x6>
   14174:	08 95       	ret

00014176 <__eewr_byte_m1280>:
   14176:	26 2f       	mov	r18, r22

00014178 <__eewr_r18_m1280>:
   14178:	f9 99       	sbic	0x1f, 1	; 31
   1417a:	fe cf       	rjmp	.-4      	; 0x14178 <__eewr_r18_m1280>
   1417c:	1f ba       	out	0x1f, r1	; 31
   1417e:	92 bd       	out	0x22, r25	; 34
   14180:	81 bd       	out	0x21, r24	; 33
   14182:	20 bd       	out	0x20, r18	; 32
   14184:	0f b6       	in	r0, 0x3f	; 63
   14186:	f8 94       	cli
   14188:	fa 9a       	sbi	0x1f, 2	; 31
   1418a:	f9 9a       	sbi	0x1f, 1	; 31
   1418c:	0f be       	out	0x3f, r0	; 63
   1418e:	01 96       	adiw	r24, 0x01	; 1
   14190:	08 95       	ret

00014192 <__ctype_isfalse>:
   14192:	99 27       	eor	r25, r25
   14194:	88 27       	eor	r24, r24

00014196 <__ctype_istrue>:
   14196:	08 95       	ret

00014198 <strrev>:
   14198:	dc 01       	movw	r26, r24
   1419a:	fc 01       	movw	r30, r24
   1419c:	67 2f       	mov	r22, r23
   1419e:	71 91       	ld	r23, Z+
   141a0:	77 23       	and	r23, r23
   141a2:	e1 f7       	brne	.-8      	; 0x1419c <strrev+0x4>
   141a4:	32 97       	sbiw	r30, 0x02	; 2
   141a6:	04 c0       	rjmp	.+8      	; 0x141b0 <strrev+0x18>
   141a8:	7c 91       	ld	r23, X
   141aa:	6d 93       	st	X+, r22
   141ac:	70 83       	st	Z, r23
   141ae:	62 91       	ld	r22, -Z
   141b0:	ae 17       	cp	r26, r30
   141b2:	bf 07       	cpc	r27, r31
   141b4:	c8 f3       	brcs	.-14     	; 0x141a8 <strrev+0x10>
   141b6:	08 95       	ret

000141b8 <_exit>:
   141b8:	f8 94       	cli

000141ba <__stop_program>:
   141ba:	ff cf       	rjmp	.-2      	; 0x141ba <__stop_program>
